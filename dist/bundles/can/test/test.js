/*[traceur-runtime]*/
this._System=this.System,function(t){"use strict";function e(t,e,r){for(var n=[e],u=0;u<r.length;u++)n[u+1]=r[u];var i=$(Function.prototype.bind,t,n);return i}function r(t,r){var n=new(e(t,null,r));return n}function n(){return"__$"+Math.floor(1e9*Math.random())+"$"+ ++P+"$__"}function u(t){return E[t]}function i(){var t=n();return E[t]=!0,t}function o(t,e,r){return[x,t,e,r]}function c(t){return t&&t[0]===x}function a(){M=i(),Function.prototype.call=s(function(t){var e=f(function(t){for(var e=[],r=1;r<arguments.length;++r)e[r-1]=arguments[r];var n=o(this,t,e);return n},this,arguments);return e}),Function.prototype.apply=s(function(t,e){var r=f(function(t,e){var r=o(this,t,e);return r},this,arguments);return r})}function s(t){return null===M&&a(),t[M]=!0,t}function l(t){return!!t[M]}function f(t,e,r){var n=r[0];if(c(n))return n=$(t,e,n[3]);for(n=o(t,e,r);;){if(n=l(t)?$(t,n[2],[n]):$(t,n[2],n[3]),!c(n))return n;t=n[1]}}function h(){var t;return t=l(this)?r(this,[o(null,null,arguments)]):r(this,arguments)}if(!t.$traceurRuntime){var m=Object,p=TypeError,b=m.create,y=m.defineProperties,v=m.defineProperty,g=m.freeze,d=m.getOwnPropertyDescriptor,j=m.getOwnPropertyNames,w=m.keys,O=m.prototype.hasOwnProperty,S=(m.prototype.toString,Object.preventExtensions),R=Object.seal,_=Object.isExtensible,$=Function.prototype.call.bind(Function.prototype.apply),P=0,E=b(null),x=Object.create(null),M=null;!function(){function e(t){return{configurable:!0,enumerable:!1,value:t,writable:!0}}function r(t){return"object"==typeof t&&t instanceof l}function c(t){return r(t)?"symbol":typeof t}function a(t){var e=new l(t);if(!(this instanceof a))return e;throw new TypeError("Symbol cannot be new'ed")}function l(t){var e=n();v(this,J,{value:this}),v(this,Q,{value:e}),v(this,X,{value:t}),P(this),Z[e]=this}function $(t){var e=t[tt];return e&&e.self===t?e:_(t)?(rt.hash.value=nt++,rt.self.value=t,et.value=b(null,rt),v(t,tt,et),et.value):void 0}function P(t){return $(t),g.apply(this,arguments)}function x(t){return $(t),S.apply(this,arguments)}function M(t){return $(t),R.apply(this,arguments)}function I(t){return Z[t]||E[t]}function N(t){return r(t)?t[Q]:t}function k(t){for(var e=[],r=0;r<t.length;r++)I(t[r])||e.push(t[r]);return e}function T(t){return k(j(t))}function A(t){return k(w(t))}function C(t){for(var e=[],r=j(t),n=0;n<r.length;n++){var u=Z[r[n]];u&&e.push(u)}return e}function F(t,e){return d(t,N(e))}function G(t){return O.call(this,N(t))}function H(e){return t.$traceurRuntime.options[e]}function U(t,e,n){return r(e)&&(e=e[Q]),v(t,e,n),t}function z(t){v(t,"defineProperty",{value:U}),v(t,"getOwnPropertyNames",{value:T}),v(t,"getOwnPropertyDescriptor",{value:F}),v(t.prototype,"hasOwnProperty",{value:G}),v(t,"freeze",{value:P}),v(t,"preventExtensions",{value:x}),v(t,"seal",{value:M}),v(t,"keys",{value:A})}function D(t){for(var e=1;e<arguments.length;e++)for(var r=j(arguments[e]),n=0;n<r.length;n++){var u=r[n];"__esModule"===u||"default"===u||I(u)||!function(e,r){v(t,r,{get:function(){return e[r]},enumerable:!0})}(arguments[e],r[n])}return t}function V(t){return null!=t&&("object"==typeof t||"function"==typeof t)}function q(t){if(null==t)throw p();return m(t)}function Y(t){if(null==t)throw new TypeError("Value cannot be converted to an Object");return t}function L(t,e){t.Symbol?ut=!0:(t.Symbol=e,Object.getOwnPropertySymbols=C,ut=!1),t.Symbol.iterator||(t.Symbol.iterator=e("Symbol.iterator")),t.Symbol.observer||(t.Symbol.observer=e("Symbol.observer"))}function W(){return ut}function K(t){L(t,a),t.Reflect=t.Reflect||{},t.Reflect.global=t.Reflect.global||t,z(t.Object)}var B=e,Q=n(),X=n(),J=n(),Z=b(null);v(a.prototype,"constructor",e(a)),v(a.prototype,"toString",B(function(){var t=this[J];return t[Q]})),v(a.prototype,"valueOf",B(function(){var t=this[J];if(!t)throw TypeError("Conversion from symbol to string");return H("symbols")?t:t[Q]})),v(l.prototype,"constructor",e(a)),v(l.prototype,"toString",{value:a.prototype.toString,enumerable:!1}),v(l.prototype,"valueOf",{value:a.prototype.valueOf,enumerable:!1});var tt=i(),et={value:void 0},rt={hash:{value:void 0},self:{value:void 0}},nt=0;P(l.prototype);var ut;K(t),t.$traceurRuntime={call:f,checkObjectCoercible:Y,construct:h,continuation:o,createPrivateName:i,defineProperties:y,defineProperty:v,exportStar:D,getOwnHashObject:$,getOwnPropertyDescriptor:d,getOwnPropertyNames:j,hasNativeSymbol:W,initTailRecursiveFunction:s,isObject:V,isPrivateName:u,isSymbolString:I,keys:w,options:{},setupGlobals:K,toObject:q,toProperty:N,"typeof":c}}()}}("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this),function(){function t(t,e,r,n,u,i,o){var c=[];return t&&c.push(t,":"),r&&(c.push("//"),e&&c.push(e,"@"),c.push(r),n&&c.push(":",n)),u&&c.push(u),i&&c.push("?",i),o&&c.push("#",o),c.join("")}function e(t){return t.match(c)}function r(t){if("/"===t)return"/";for(var e="/"===t[0]?"/":"",r="/"===t.slice(-1)?"/":"",n=t.split("/"),u=[],i=0,o=0;o<n.length;o++){var c=n[o];switch(c){case"":case".":break;case"..":u.length?u.pop():i++;break;default:u.push(c)}}if(!e){for(;i-->0;)u.unshift("..");0===u.length&&u.push(".")}return e+u.join("/")+r}function n(e){var n=e[a.PATH]||"";return n=r(n),e[a.PATH]=n,t(e[a.SCHEME],e[a.USER_INFO],e[a.DOMAIN],e[a.PORT],e[a.PATH],e[a.QUERY_DATA],e[a.FRAGMENT])}function u(t){var r=e(t);return n(r)}function i(t,r){var u=e(r),i=e(t);if(u[a.SCHEME])return n(u);u[a.SCHEME]=i[a.SCHEME];for(var o=a.SCHEME;o<=a.PORT;o++)u[o]||(u[o]=i[o]);if("/"==u[a.PATH][0])return n(u);var c=i[a.PATH],s=c.lastIndexOf("/");return c=c.slice(0,s+1)+u[a.PATH],u[a.PATH]=c,n(u)}function o(t){if(!t)return!1;if("/"===t[0])return!0;var r=e(t);return r[a.SCHEME]?!0:!1}var c=new RegExp("^(?:([^:/?#.]+):)?(?://(?:([^/?#]*)@)?([\\w\\d\\-\\u0100-\\uffff.%]*)(?::([0-9]+))?)?([^?#]+)?(?:\\?([^#]*))?(?:#(.*))?$"),a={SCHEME:1,USER_INFO:2,DOMAIN:3,PORT:4,PATH:5,QUERY_DATA:6,FRAGMENT:7};$traceurRuntime.canonicalizeUrl=u,$traceurRuntime.isAbsolute=o,$traceurRuntime.removeDotSegments=r,$traceurRuntime.resolveUrl=i}(),function(t){"use strict";function e(t,e){this.url=t,this.value_=e}function r(t,e){this.message=this.constructor.name+": "+this.stripCause(e)+" in "+t,e instanceof r||!e.stack?this.stack="":this.stack=this.stripStack(e.stack)}function n(t,e){var r=[],n=e-3;0>n&&(n=0);for(var u=n;e>u;u++)r.push(t[u]);return r}function u(t,e){var r=e+1;r>t.length-1&&(r=t.length-1);for(var n=[],u=e;r>=u;u++)n.push(t[u]);return n}function i(t){for(var e="",r=0;t-1>r;r++)e+="-";return e}function o(t,r){e.call(this,t,null),this.func=r}function c(t){if(t){var e=v.normalize(t);return p[e]}}function a(t){var e=arguments[1],r=Object.create(null);return Object.getOwnPropertyNames(t).forEach(function(n){var u,i;if(e===y){var o=Object.getOwnPropertyDescriptor(t,n);o.get&&(u=o.get)}u||(i=t[n],u=function(){return i}),Object.defineProperty(r,n,{get:u,enumerable:!0})}),Object.preventExtensions(r),r}var s,l=$traceurRuntime,f=l.canonicalizeUrl,h=l.resolveUrl,m=l.isAbsolute,p=Object.create(null);s=t.location&&t.location.href?h(t.location.href,"./"):"",r.prototype=Object.create(Error.prototype),r.prototype.constructor=r,r.prototype.stripError=function(t){return t.replace(/.*Error:/,this.constructor.name+":")},r.prototype.stripCause=function(t){return t?t.message?this.stripError(t.message):t+"":""},r.prototype.loadedBy=function(t){this.stack+="\n loaded by "+t},r.prototype.stripStack=function(t){var e=[];return t.split("\n").some(function(t){return/UncoatedModuleInstantiator/.test(t)?!0:void e.push(t)}),e[0]=this.stripError(e[0]),e.join("\n")},o.prototype=Object.create(e.prototype),o.prototype.getUncoatedModule=function(){var e=this;if(this.value_)return this.value_;try{var o;return void 0!==typeof $traceurRuntime&&$traceurRuntime.require&&(o=$traceurRuntime.require.bind(null,this.url)),this.value_=this.func.call(t,o)}catch(c){if(c instanceof r)throw c.loadedBy(this.url),c;if(c.stack){var a=this.func.toString().split("\n"),s=[];c.stack.split("\n").some(function(t,r){if(t.indexOf("UncoatedModuleInstantiator.getUncoatedModule")>0)return!0;var o=/(at\s[^\s]*\s).*>:(\d*):(\d*)\)/.exec(t);if(o){var c=parseInt(o[2],10);s=s.concat(n(a,c)),1===r?s.push(i(o[3])+"^ "+e.url):s.push(i(o[3])+"^"),s=s.concat(u(a,c)),s.push("= = = = = = = = =")}else s.push(t)}),c.stack=s.join("\n")}throw new r(this.url,c)}};var b=Object.create(null),y={},v={normalize:function(t,e,r){if("string"!=typeof t)throw new TypeError("module name must be a string, not "+typeof t);if(m(t))return f(t);if(/[^\.]\/\.\.\//.test(t))throw new Error("module name embeds /../: "+t);return"."===t[0]&&e?h(e,t):f(t)},get:function(t){var e=c(t);if(!e)return void 0;var r=b[e.url];return r?r:(r=a(e.getUncoatedModule(),y),b[e.url]=r)},set:function(t,e){t=String(t),p[t]=new o(t,function(){return e}),b[t]=e},get baseURL(){return s},set baseURL(t){s=String(t)},registerModule:function(t,e,r){var n=v.normalize(t);if(p[n])throw new Error("duplicate module named "+n);p[n]=new o(n,r)},bundleStore:Object.create(null),register:function(t,e,r){e&&(e.length||r.length)?this.bundleStore[t]={deps:e,execute:function(){var t=arguments,n={};e.forEach(function(e,r){return n[e]=t[r]});var u=r.call(this,n);return u.execute.call(this),u.exports}}:this.registerModule(t,e,r)},getAnonymousModule:function(e){return new a(e.call(t),y)}},g=new a({ModuleStore:v});v.set("@traceur/src/runtime/ModuleStore.js",g);var d=$traceurRuntime.setupGlobals;$traceurRuntime.setupGlobals=function(t){d(t)},$traceurRuntime.ModuleStore=v,t.System={register:v.register.bind(v),registerModule:v.registerModule.bind(v),get:v.get,set:v.set,normalize:v.normalize}}("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this),System.registerModule("traceur-runtime@0.0.91/src/runtime/async.js",[],function(){"use strict";function t(){}function e(){}function r(t){return t.prototype=s(e.prototype),t.__proto__=e,t}function n(t,e){for(var r=[],n=2;n<arguments.length;n++)r[n-2]=arguments[n];var u=s(e.prototype);return u[l]=this,u[f]=r,u[h]=t,u}function u(t,e){return new Promise(function(r,n){var u=t({next:function(t){return e.call(u,t)},"throw":function(t){n(t)},"return":function(t){r(t)}})})}function i(t){return Promise.resolve().then(t)}function o(t,e){return new y(t,e)}if("object"!=typeof $traceurRuntime)throw new Error("traceur runtime not found.");var c=$traceurRuntime.createPrivateName,a=$traceurRuntime.defineProperty,s=($traceurRuntime.defineProperties,Object.create),l=c(),f=c(),h=c();t.prototype=e,e.constructor=t,a(e,"constructor",{enumerable:!1});var m=function(){function t(t){var e=this;this.decoratedObserver=$traceurRuntime.createDecoratedGenerator(t,function(){e.done=!0}),this.done=!1,this.inReturn=!1}return $traceurRuntime.createClass(t,{"throw":function(t){if(!this.inReturn)throw t},"yield":function(t){if(this.done)throw void(this.inReturn=!0);var e;try{e=this.decoratedObserver.next(t)}catch(r){throw this.done=!0,r}if(void 0!==e){if(e.done)throw this.done=!0,void(this.inReturn=!0);return e.value}},yieldFor:function(t){var e=this;return $traceurRuntime.observeForEach(t[$traceurRuntime.toProperty(Symbol.observer)].bind(t),function(t){if(e.done)return void this["return"]();var r;try{r=e.decoratedObserver.next(t)}catch(n){throw e.done=!0,n}if(void 0!==r)return r.done&&(e.done=!0),r})}},{})}();e.prototype[Symbol.observer]=function(t){var e=this[h],r=new m(t);return $traceurRuntime.schedule(function(){return e(r)}).then(function(t){r.done||r.decoratedObserver["return"](t)})["catch"](function(t){r.done||r.decoratedObserver["throw"](t)}),r.decoratedObserver},a(e.prototype,Symbol.observer,{enumerable:!1});var p=Symbol(),b=Symbol(),y=function(){function t(t,e){this[p]=t,this[b]=e}return $traceurRuntime.createClass(t,{next:function(t){var e=this[p].next(t);return void 0!==e&&e.done&&this[b].call(this),e},"throw":function(t){return this[b].call(this),this[p]["throw"](t)},"return":function(t){return this[b].call(this),this[p]["return"](t)}},{})}();return Array.prototype[$traceurRuntime.toProperty(Symbol.observer)]=function(t){var e=!1,r=o(t,function(){return e=!0}),n=!0,u=!1,i=void 0;try{for(var c=void 0,a=this[$traceurRuntime.toProperty(Symbol.iterator)]();!(n=(c=a.next()).done);n=!0){var s=c.value;if(r.next(s),e)return}}catch(l){u=!0,i=l}finally{try{n||null==a["return"]||a["return"]()}finally{if(u)throw i}}return r["return"](),r},a(Array.prototype,$traceurRuntime.toProperty(Symbol.observer),{enumerable:!1}),$traceurRuntime.initAsyncGeneratorFunction=r,$traceurRuntime.createAsyncGeneratorInstance=n,$traceurRuntime.observeForEach=u,$traceurRuntime.schedule=i,$traceurRuntime.createDecoratedGenerator=o,{}}),System.registerModule("traceur-runtime@0.0.91/src/runtime/classes.js",[],function(){"use strict";function t(t,e){var r=b(t);do{var n=p(r,e);if(n)return n;r=b(r)}while(r);return void 0}function e(t){return t.__proto__}function r(e,r,n){var u=t(r,n);if(u){var i=u.value;return i?i:u.get?u.get.call(e):i}return void 0}function n(e,r,n,u){var i=t(r,n);if(i&&i.set)return i.set.call(e,u),u;throw l("super has no setter '"+n+"'.")}function u(t,e){v(t).forEach(e),g(t).forEach(e)}function i(t){var e={};return u(t,function(r){e[r]=p(t,r),e[r].enumerable=!1}),e}function o(t){u(t,function(e){m(t,e,d)})}function c(t,e,r,n){return m(e,"constructor",{value:t,configurable:!0,enumerable:!1,writable:!0}),arguments.length>3?("function"==typeof n&&(t.__proto__=n),t.prototype=f(a(n),i(e))):(o(e),t.prototype=e),m(t,"prototype",{configurable:!1,writable:!1}),h(t,i(r))}function a(t){if("function"==typeof t){var e=t.prototype;if(s(e)===e||null===e)return t.prototype;throw new l("super prototype must be an Object or null")}if(null===t)return null;throw new l("Super expression must either be null or a function, not "+typeof t+".")}var s=Object,l=TypeError,f=s.create,h=$traceurRuntime.defineProperties,m=$traceurRuntime.defineProperty,p=$traceurRuntime.getOwnPropertyDescriptor,b=($traceurRuntime.getOwnPropertyNames,Object.getPrototypeOf),y=Object,v=y.getOwnPropertyNames,g=y.getOwnPropertySymbols,d={enumerable:!1};return $traceurRuntime.createClass=c,$traceurRuntime.superConstructor=e,$traceurRuntime.superGet=r,$traceurRuntime.superSet=n,{}}),System.registerModule("traceur-runtime@0.0.91/src/runtime/destructuring.js",[],function(){"use strict";function t(t){for(var e,r=[],n=0;!(e=t.next()).done;)r[n++]=e.value;return r}return $traceurRuntime.iteratorToArray=t,{}}),System.registerModule("traceur-runtime@0.0.91/src/runtime/generators.js",[],function(){"use strict";function t(t){return{configurable:!0,enumerable:!1,value:t,writable:!0}}function e(t){return new Error("Traceur compiler bug: invalid state in state machine: "+t)}function r(){this.state=0,this.GState=v,this.storedException=void 0,this.finallyFallThrough=void 0,this.sent_=void 0,this.returnValue=void 0,this.oldReturnValue=void 0,this.tryStack_=[]}function n(t,e,r,n){switch(t.GState){case g:throw new Error('"'+r+'" on executing generator');case j:if("next"==r)return{value:void 0,done:!0};if(n===S)return{value:t.returnValue,done:!0};throw n;case v:if("throw"===r){if(t.GState=j,n===S)return{value:t.returnValue,done:!0};throw n}if(void 0!==n)throw y("Sent value to newborn generator");case d:t.GState=g,t.action=r,t.sent=n;var u;try{u=e(t)}catch(i){if(i!==S)throw i;u=t}var o=u===t;return o&&(u=t.returnValue),t.GState=o?j:d,{value:u,done:o}}}function u(){}function i(){}function o(t,e,n){var u=l(t,n),i=new r,o=b(e.prototype);return o[R]=i,o[_]=u,o}function c(t){return t.prototype=b(i.prototype),t.__proto__=i,t}function a(){r.call(this),this.err=void 0;var t=this;t.result=new Promise(function(e,r){t.resolve=e,t.reject=r})}function s(t,e){var r=l(t,e),n=new a;return n.createCallback=function(t){return function(e){n.state=t,n.value=e,r(n)}},n.errback=function(t){f(n,t),r(n)},r(n),n.result}function l(t,e){return function(r){for(;;)try{return t.call(e,r)}catch(n){f(r,n)}}}function f(t,e){t.storedException=e;var r=t.tryStack_[t.tryStack_.length-1];return r?(t.state=void 0!==r["catch"]?r["catch"]:r["finally"],void(void 0!==r.finallyFallThrough&&(t.finallyFallThrough=r.finallyFallThrough))):void t.handleException(e)}if("object"!=typeof $traceurRuntime)throw new Error("traceur runtime not found.");var h=$traceurRuntime.createPrivateName,m=$traceurRuntime.defineProperties,p=$traceurRuntime.defineProperty,b=Object.create,y=TypeError,v=0,g=1,d=2,j=3,w=-2,O=-3,S={};r.prototype={pushTry:function(t,e){if(null!==e){for(var r=null,n=this.tryStack_.length-1;n>=0;n--)if(void 0!==this.tryStack_[n]["catch"]){r=this.tryStack_[n]["catch"];break}null===r&&(r=O),this.tryStack_.push({"finally":e,finallyFallThrough:r})}null!==t&&this.tryStack_.push({"catch":t})},popTry:function(){this.tryStack_.pop()},maybeUncatchable:function(){if(this.storedException===S)throw S},get sent(){return this.maybeThrow(),this.sent_},set sent(t){this.sent_=t},get sentIgnoreThrow(){return this.sent_},maybeThrow:function(){if("throw"===this.action)throw this.action="next",this.sent_},end:function(){switch(this.state){case w:return this;case O:throw this.storedException;default:throw e(this.state)}},handleException:function(t){throw this.GState=j,this.state=w,t},wrapYieldStar:function(t){var e=this;return{next:function(e){return t.next(e)},"throw":function(r){var n;if(r===S){if(t["return"]){if(n=t["return"](e.returnValue),!n.done)return e.returnValue=e.oldReturnValue,n;e.returnValue=n.value}throw r}if(t["throw"])return t["throw"](r);throw t["return"]&&t["return"](),y("Inner iterator does not have a throw method")}}}};var R=h(),_=h();return u.prototype=i,p(i,"constructor",t(u)),i.prototype={constructor:i,next:function(t){return n(this[R],this[_],"next",t)},"throw":function(t){return n(this[R],this[_],"throw",t)},"return":function(t){return this[R].oldReturnValue=this[R].returnValue,this[R].returnValue=t,n(this[R],this[_],"throw",S)}},m(i.prototype,{constructor:{enumerable:!1},next:{enumerable:!1},"throw":{enumerable:!1},"return":{enumerable:!1}}),Object.defineProperty(i.prototype,Symbol.iterator,t(function(){return this})),a.prototype=b(r.prototype),a.prototype.end=function(){switch(this.state){case w:this.resolve(this.returnValue);break;case O:this.reject(this.storedException);break;default:this.reject(e(this.state))}},a.prototype.handleException=function(){this.state=O},$traceurRuntime.asyncWrap=s,$traceurRuntime.initGeneratorFunction=c,$traceurRuntime.createGeneratorInstance=o,{}}),System.registerModule("traceur-runtime@0.0.91/src/runtime/relativeRequire.js",[],function(){"use strict";function t(t,r){function n(t){return"/"===t.slice(-1)}function u(t){return"/"===t[0]}function i(t){return"."===t[0]}return e=e||"undefined"!=typeof require&&require("path"),n(r)||u(r)?void 0:i(r)?require(e.resolve(e.dirname(t),r)):require(r)}var e;return $traceurRuntime.require=t,{}}),System.registerModule("traceur-runtime@0.0.91/src/runtime/spread.js",[],function(){"use strict";function t(){for(var t,e=[],r=0,n=0;n<arguments.length;n++){var u=$traceurRuntime.checkObjectCoercible(arguments[n]);if("function"!=typeof u[$traceurRuntime.toProperty(Symbol.iterator)])throw new TypeError("Cannot spread non-iterable object.");for(var i=u[$traceurRuntime.toProperty(Symbol.iterator)]();!(t=i.next()).done;)e[r++]=t.value}return e}return $traceurRuntime.spread=t,{}}),System.registerModule("traceur-runtime@0.0.91/src/runtime/template.js",[],function(){"use strict";function t(t){var e=arguments[1],o=t.join("${}"),c=i[o];return c?c:(e||(e=u.call(t)),i[o]=n(r(e,"raw",{value:n(t)})))}var e=Object,r=e.defineProperty,n=e.freeze,u=Array.prototype.slice,i=Object.create(null);return $traceurRuntime.getTemplateObject=t,{}}),System.registerModule("traceur-runtime@0.0.91/src/runtime/type-assertions.js",[],function(){"use strict";function t(t){for(var e=[],u=1;u<arguments.length;u++)e[u-1]=arguments[u];var i=n,o=$traceurRuntime.getOwnHashObject(t).hash;i[o]||(i[o]=Object.create(null)),i=i[o];for(var c=0;c<e.length-1;c++)o=$traceurRuntime.getOwnHashObject(e[c]).hash,i[o]||(i[o]=Object.create(null)),i=i[o];var a=e[e.length-1];return o=$traceurRuntime.getOwnHashObject(a).hash,i[o]||(i[o]=new r(t,e)),i[o]}var e={any:{name:"any"},"boolean":{name:"boolean"},number:{name:"number"},string:{name:"string"},symbol:{name:"symbol"},"void":{name:"void"}},r=function(){function t(t,e){this.type=t,this.argumentTypes=e}return $traceurRuntime.createClass(t,{},{})}(),n=Object.create(null);return $traceurRuntime.GenericType=r,$traceurRuntime.genericType=t,$traceurRuntime.type=e,{}}),System.registerModule("traceur-runtime@0.0.91/src/runtime/runtime-modules.js",[],function(){"use strict";return System.get("traceur-runtime@0.0.91/src/runtime/relativeRequire.js"),System.get("traceur-runtime@0.0.91/src/runtime/spread.js"),System.get("traceur-runtime@0.0.91/src/runtime/destructuring.js"),System.get("traceur-runtime@0.0.91/src/runtime/classes.js"),System.get("traceur-runtime@0.0.91/src/runtime/async.js"),System.get("traceur-runtime@0.0.91/src/runtime/generators.js"),System.get("traceur-runtime@0.0.91/src/runtime/template.js"),System.get("traceur-runtime@0.0.91/src/runtime/type-assertions.js"),{}}),System.get("traceur-runtime@0.0.91/src/runtime/runtime-modules.js"),System.registerModule("traceur-runtime@0.0.91/src/runtime/polyfills/utils.js",[],function(){"use strict";function t(t){return t>>>0}function e(t){return t&&("object"==typeof t||"function"==typeof t)}function r(t){return"function"==typeof t}function n(t){return"number"==typeof t}function u(t){return t=+t,j(t)?0:0!==t&&d(t)?t>0?g(t):v(t):t}function i(t){var e=u(t);return 0>e?0:O(e,R)}function o(t){return e(t)?t[Symbol.iterator]:void 0}function c(t){return r(t)}function a(t,e){return{value:t,done:e}}function s(t,e,r){e in t||Object.defineProperty(t,e,r)}function l(t,e,r){s(t,e,{value:r,configurable:!0,enumerable:!1,writable:!0})}function f(t,e,r){s(t,e,{value:r,configurable:!1,enumerable:!1,writable:!1})}function h(t,e){for(var r=0;r<e.length;r+=2){var n=e[r],u=e[r+1];l(t,n,u)}}function m(t,e){for(var r=0;r<e.length;r+=2){var n=e[r],u=e[r+1];f(t,n,u)}}function p(t,e,r){r&&r.iterator&&!t[r.iterator]&&(t["@@iterator"]&&(e=t["@@iterator"]),Object.defineProperty(t,r.iterator,{value:e,configurable:!0,enumerable:!1,writable:!0}))}function b(t){_.push(t)}function y(t){_.forEach(function(e){return e(t)})}var v=Math.ceil,g=Math.floor,d=isFinite,j=isNaN,w=Math.pow,O=Math.min,S=$traceurRuntime.toObject,R=w(2,53)-1,_=[];return{get toObject(){return S},get toUint32(){return t},get isObject(){return e},get isCallable(){return r},get isNumber(){return n},get toInteger(){return u},get toLength(){return i},get checkIterable(){return o},get isConstructor(){return c},get createIteratorResultObject(){return a},get maybeDefine(){return s},get maybeDefineMethod(){return l},get maybeDefineConst(){return f},get maybeAddFunctions(){return h},get maybeAddConsts(){return m},get maybeAddIterator(){return p},get registerPolyfill(){return b},get polyfillAll(){return y}}}),System.registerModule("traceur-runtime@0.0.91/src/runtime/polyfills/Map.js",[],function(){"use strict";function t(t,e){if(i(e)){var r=a(e);return r&&t.objectIndex_[r.hash]}return"string"==typeof e?t.stringIndex_[e]:t.primitiveIndex_[e]}function e(t){t.entries_=[],t.objectIndex_=Object.create(null),t.stringIndex_=Object.create(null),t.primitiveIndex_=Object.create(null),t.deletedCount_=0}function r(t){var e=t,r=e.Map,n=e.Symbol;if(!(r&&$traceurRuntime.hasNativeSymbol()&&r.prototype[n.iterator]&&r.prototype.entries))return!0;try{return 1!==new r([[]]).size}catch(u){return!1}}function n(t){r(t)&&(t.Map=f)}var u=System.get("traceur-runtime@0.0.91/src/runtime/polyfills/utils.js"),i=u.isObject,o=u.registerPolyfill,c=$traceurRuntime,a=c.getOwnHashObject,s=(c.hasNativeSymbol,Object.prototype.hasOwnProperty),l={},f=function(){function r(){var t,r,n=arguments[0];if(!i(this))throw new TypeError("Map called on incompatible type");if(s.call(this,"entries_"))throw new TypeError("Map can not be reentrantly initialised");if(e(this),null!==n&&void 0!==n){var u=!0,o=!1,c=void 0;try{for(var a=void 0,l=n[$traceurRuntime.toProperty(Symbol.iterator)]();!(u=(a=l.next()).done);u=!0){var f=a.value,h=(t=f[$traceurRuntime.toProperty(Symbol.iterator)](),(r=t.next()).done?void 0:r.value),m=(r=t.next()).done?void 0:r.value;this.set(h,m)}}catch(p){o=!0,c=p}finally{try{u||null==l["return"]||l["return"]()}finally{if(o)throw c}}}}return $traceurRuntime.createClass(r,{get size(){return this.entries_.length/2-this.deletedCount_},get:function(e){var r=t(this,e);return void 0!==r?this.entries_[r+1]:void 0},set:function(e,r){var n=i(e),u="string"==typeof e,o=t(this,e);if(void 0!==o)this.entries_[o+1]=r;else if(o=this.entries_.length,this.entries_[o]=e,this.entries_[o+1]=r,n){var c=a(e),s=c.hash;this.objectIndex_[s]=o}else u?this.stringIndex_[e]=o:this.primitiveIndex_[e]=o;return this},has:function(e){return void 0!==t(this,e)},"delete":function(t){var e,r,n=i(t),u="string"==typeof t;if(n){var o=a(t);o&&(e=this.objectIndex_[r=o.hash],delete this.objectIndex_[r])}else u?(e=this.stringIndex_[t],delete this.stringIndex_[t]):(e=this.primitiveIndex_[t],delete this.primitiveIndex_[t]);return void 0!==e?(this.entries_[e]=l,this.entries_[e+1]=void 0,this.deletedCount_++,!0):!1},clear:function(){e(this)},forEach:function(t){for(var e=arguments[1],r=0;r<this.entries_.length;r+=2){var n=this.entries_[r],u=this.entries_[r+1];n!==l&&t.call(e,u,n,this)}},entries:$traceurRuntime.initGeneratorFunction(function n(){var t,e,r;return $traceurRuntime.createGeneratorInstance(function(n){for(;;)switch(n.state){case 0:t=0,n.state=12;break;case 12:n.state=t<this.entries_.length?8:-2;break;case 4:t+=2,n.state=12;break;case 8:e=this.entries_[t],r=this.entries_[t+1],n.state=9;break;case 9:n.state=e===l?4:6;break;case 6:return n.state=2,[e,r];case 2:n.maybeThrow(),n.state=4;break;default:return n.end()}},n,this)}),keys:$traceurRuntime.initGeneratorFunction(function u(){var t,e,r;return $traceurRuntime.createGeneratorInstance(function(n){for(;;)switch(n.state){case 0:t=0,n.state=12;break;case 12:n.state=t<this.entries_.length?8:-2;break;case 4:t+=2,n.state=12;break;case 8:e=this.entries_[t],r=this.entries_[t+1],n.state=9;break;case 9:n.state=e===l?4:6;break;case 6:return n.state=2,e;case 2:n.maybeThrow(),n.state=4;break;default:return n.end()}},u,this)}),values:$traceurRuntime.initGeneratorFunction(function o(){var t,e,r;return $traceurRuntime.createGeneratorInstance(function(n){for(;;)switch(n.state){case 0:t=0,n.state=12;break;case 12:n.state=t<this.entries_.length?8:-2;break;case 4:t+=2,n.state=12;break;case 8:e=this.entries_[t],r=this.entries_[t+1],n.state=9;break;case 9:n.state=e===l?4:6;break;case 6:return n.state=2,r;case 2:n.maybeThrow(),n.state=4;break;default:return n.end()}},o,this)})},{})}();return Object.defineProperty(f.prototype,Symbol.iterator,{configurable:!0,writable:!0,value:f.prototype.entries}),o(n),{get Map(){return f},get polyfillMap(){return n}}}),System.get("traceur-runtime@0.0.91/src/runtime/polyfills/Map.js"),System.registerModule("traceur-runtime@0.0.91/src/runtime/polyfills/Set.js",[],function(){"use strict";function t(t){t.map_=new o}function e(t){var e=t,r=e.Set,n=e.Symbol;if(!(r&&$traceurRuntime.hasNativeSymbol()&&r.prototype[n.iterator]&&r.prototype.values))return!0;try{return 1!==new r([1]).size}catch(u){return!1}}function r(t){e(t)&&(t.Set=a)}var n=System.get("traceur-runtime@0.0.91/src/runtime/polyfills/utils.js"),u=n.isObject,i=n.registerPolyfill,o=System.get("traceur-runtime@0.0.91/src/runtime/polyfills/Map.js").Map,c=($traceurRuntime.getOwnHashObject,Object.prototype.hasOwnProperty),a=function(){function e(){var e=arguments[0];if(!u(this))throw new TypeError("Set called on incompatible type");if(c.call(this,"map_"))throw new TypeError("Set can not be reentrantly initialised");if(t(this),null!==e&&void 0!==e){var r=!0,n=!1,i=void 0;try{for(var o=void 0,a=e[$traceurRuntime.toProperty(Symbol.iterator)]();!(r=(o=a.next()).done);r=!0){var s=o.value;this.add(s)}}catch(l){n=!0,i=l}finally{try{r||null==a["return"]||a["return"]()}finally{if(n)throw i}}}}return $traceurRuntime.createClass(e,{get size(){return this.map_.size},has:function(t){return this.map_.has(t)},add:function(t){return this.map_.set(t,t),this},"delete":function(t){return this.map_["delete"](t)},clear:function(){return this.map_.clear()},forEach:function(t){var e=arguments[1],r=this;return this.map_.forEach(function(n,u){t.call(e,u,u,r)})},values:$traceurRuntime.initGeneratorFunction(function r(){var t,e;return $traceurRuntime.createGeneratorInstance(function(r){for(;;)switch(r.state){case 0:t=r.wrapYieldStar(this.map_.keys()[Symbol.iterator]()),r.sent=void 0,r.action="next",r.state=12;break;case 12:e=t[r.action](r.sentIgnoreThrow),r.state=9;break;case 9:r.state=e.done?3:2;break;case 3:r.sent=e.value,r.state=-2;break;case 2:return r.state=12,e.value;default:return r.end()}},r,this)}),entries:$traceurRuntime.initGeneratorFunction(function n(){var t,e;return $traceurRuntime.createGeneratorInstance(function(r){for(;;)switch(r.state){case 0:t=r.wrapYieldStar(this.map_.entries()[Symbol.iterator]()),r.sent=void 0,r.action="next",r.state=12;break;case 12:e=t[r.action](r.sentIgnoreThrow),r.state=9;break;case 9:r.state=e.done?3:2;break;case 3:r.sent=e.value,r.state=-2;break;case 2:return r.state=12,e.value;default:return r.end()}},n,this)})},{})}();return Object.defineProperty(a.prototype,Symbol.iterator,{configurable:!0,writable:!0,value:a.prototype.values}),Object.defineProperty(a.prototype,"keys",{configurable:!0,writable:!0,value:a.prototype.values}),i(r),{get Set(){return a},get polyfillSet(){return r}}}),System.get("traceur-runtime@0.0.91/src/runtime/polyfills/Set.js"),System.registerModule("traceur-runtime@0.0.91/node_modules/rsvp/lib/rsvp/asap.js",[],function(){"use strict";function t(t,e){v[l]=t,v[l+1]=e,l+=2,2===l&&s()}function e(){var t=process.nextTick,e=process.versions.node.match(/^(?:(\d+)\.)?(?:(\d+)\.)?(\*|\d+)$/);return Array.isArray(e)&&"0"===e[1]&&"10"===e[2]&&(t=setImmediate),function(){t(o)}}function r(){return function(){a(o)}}function n(){var t=0,e=new p(o),r=document.createTextNode("");return e.observe(r,{characterData:!0}),function(){r.data=t=++t%2}}function u(){var t=new MessageChannel;return t.port1.onmessage=o,function(){t.port2.postMessage(0)}}function i(){return function(){setTimeout(o,1)}}function o(){for(var t=0;l>t;t+=2){var e=v[t],r=v[t+1];e(r),v[t]=void 0,v[t+1]=void 0}l=0}function c(){try{var t=require,e=t("vertx");return a=e.runOnLoop||e.runOnContext,r()}catch(n){return i()}}var a,s,l=0,f=({}.toString,t),h="undefined"!=typeof window?window:void 0,m=h||{},p=m.MutationObserver||m.WebKitMutationObserver,b="undefined"!=typeof process&&"[object process]"==={}.toString.call(process),y="undefined"!=typeof Uint8ClampedArray&&"undefined"!=typeof importScripts&&"undefined"!=typeof MessageChannel,v=new Array(1e3);return s=b?e():p?n():y?u():void 0===h&&"function"==typeof require?c():i(),{get default(){return f}}}),System.registerModule("traceur-runtime@0.0.91/src/runtime/polyfills/Promise.js",[],function(){"use strict";function t(t){return t&&"object"==typeof t&&void 0!==t.status_}function e(t){return t}function r(t){throw t}function n(t){var n=void 0!==arguments[1]?arguments[1]:e,i=void 0!==arguments[2]?arguments[2]:r,o=u(t.constructor);switch(t.status_){case void 0:throw TypeError;case 0:t.onResolve_.push(n,o),t.onReject_.push(i,o);break;case 1:l(t.value_,[n,o]);break;case-1:l(t.value_,[i,o])}return o.promise}function u(t){if(this===d){var e=o(new d(v));return{promise:e,resolve:function(t){c(e,t)},reject:function(t){a(e,t)}}}var r={};return r.promise=new t(function(t,e){r.resolve=t,r.reject=e}),r}function i(t,e,r,n,u){return t.status_=e,t.value_=r,t.onResolve_=n,t.onReject_=u,t}function o(t){return i(t,0,void 0,[],[])}function c(t,e){s(t,1,e,t.onResolve_)}function a(t,e){s(t,-1,e,t.onReject_)}function s(t,e,r,n){0===t.status_&&(l(r,n),i(t,e,r))}function l(t,e){b(function(){for(var r=0;r<e.length;r+=2)f(t,e[r],e[r+1])})}function f(e,r,u){
try{var i=r(e);if(i===u.promise)throw new TypeError;t(i)?n(i,u.resolve,u.reject):u.resolve(i)}catch(o){try{u.reject(o)}catch(o){}}}function h(t){return t&&("object"==typeof t||"function"==typeof t)}function m(e,r){if(!t(r)&&h(r)){var n;try{n=r.then}catch(i){var o=j.call(e,i);return r[w]=o,o}if("function"==typeof n){var c=r[w];if(c)return c;var a=u(e);r[w]=a.promise;try{n.call(r,a.resolve,a.reject)}catch(i){a.reject(i)}return a.promise}}return r}function p(t){t.Promise||(t.Promise=g)}var b=System.get("traceur-runtime@0.0.91/node_modules/rsvp/lib/rsvp/asap.js")["default"],y=System.get("traceur-runtime@0.0.91/src/runtime/polyfills/utils.js").registerPolyfill,v={},g=function(){function s(t){if(t!==v){if("function"!=typeof t)throw new TypeError;var e=o(this);try{t(function(t){c(e,t)},function(t){a(e,t)})}catch(r){a(e,r)}}}return $traceurRuntime.createClass(s,{"catch":function(t){return this.then(void 0,t)},then:function(u,i){"function"!=typeof u&&(u=e),"function"!=typeof i&&(i=r);var o=this,c=this.constructor;return n(this,function(e){return e=m(c,e),e===o?i(new TypeError):t(e)?e.then(u,i):u(e)},i)}},{resolve:function(e){return this===d?t(e)?e:i(new d(v),1,e):new this(function(t,r){t(e)})},reject:function(t){return this===d?i(new d(v),-1,t):new this(function(e,r){r(t)})},all:function(t){var e=u(this),r=[];try{var n=function(t){return function(n){r[t]=n,0===--i&&e.resolve(r)}},i=0,o=0,c=!0,a=!1,s=void 0;try{for(var l=void 0,f=t[$traceurRuntime.toProperty(Symbol.iterator)]();!(c=(l=f.next()).done);c=!0){var h=l.value,m=n(o);this.resolve(h).then(m,function(t){e.reject(t)}),++o,++i}}catch(p){a=!0,s=p}finally{try{c||null==f["return"]||f["return"]()}finally{if(a)throw s}}0===i&&e.resolve(r)}catch(b){e.reject(b)}return e.promise},race:function(t){var e=u(this);try{for(var r=0;r<t.length;r++)this.resolve(t[r]).then(function(t){e.resolve(t)},function(t){e.reject(t)})}catch(n){e.reject(n)}return e.promise}})}(),d=g,j=d.reject,w="@@thenable";return y(p),{get Promise(){return g},get polyfillPromise(){return p}}}),System.get("traceur-runtime@0.0.91/src/runtime/polyfills/Promise.js"),System.registerModule("traceur-runtime@0.0.91/src/runtime/polyfills/StringIterator.js",[],function(){"use strict";function t(t){var e=String(t),r=Object.create(a.prototype);return r[u(o)]=e,r[u(c)]=0,r}var e=System.get("traceur-runtime@0.0.91/src/runtime/polyfills/utils.js"),r=e.createIteratorResultObject,n=e.isObject,u=$traceurRuntime.toProperty,i=Object.prototype.hasOwnProperty,o=Symbol("iteratedString"),c=Symbol("stringIteratorNextIndex"),a=function(){function t(){}var e;return $traceurRuntime.createClass(t,(e={},Object.defineProperty(e,"next",{value:function(){var t=this;if(!n(t)||!i.call(t,o))throw new TypeError("this must be a StringIterator object");var e=t[u(o)];if(void 0===e)return r(void 0,!0);var a=t[u(c)],s=e.length;if(a>=s)return t[u(o)]=void 0,r(void 0,!0);var l,f=e.charCodeAt(a);if(55296>f||f>56319||a+1===s)l=String.fromCharCode(f);else{var h=e.charCodeAt(a+1);l=56320>h||h>57343?String.fromCharCode(f):String.fromCharCode(f)+String.fromCharCode(h)}return t[u(c)]=a+l.length,r(l,!1)},configurable:!0,enumerable:!0,writable:!0}),Object.defineProperty(e,Symbol.iterator,{value:function(){return this},configurable:!0,enumerable:!0,writable:!0}),e),{})}();return{get createStringIterator(){return t}}}),System.registerModule("traceur-runtime@0.0.91/src/runtime/polyfills/String.js",[],function(){"use strict";function t(t){var e=String(this);if(null==this||"[object RegExp]"==p.call(t))throw TypeError();var r=e.length,n=String(t),u=(n.length,arguments.length>1?arguments[1]:void 0),i=u?Number(u):0;isNaN(i)&&(i=0);var o=Math.min(Math.max(i,0),r);return b.call(e,n,i)==o}function e(t){var e=String(this);if(null==this||"[object RegExp]"==p.call(t))throw TypeError();var r=e.length,n=String(t),u=n.length,i=r;if(arguments.length>1){var o=arguments[1];void 0!==o&&(i=o?Number(o):0,isNaN(i)&&(i=0))}var c=Math.min(Math.max(i,0),r),a=c-u;return 0>a?!1:y.call(e,n,a)==a}function r(t){if(null==this)throw TypeError();var e=String(this);if(t&&"[object RegExp]"==p.call(t))throw TypeError();var r=e.length,n=String(t),u=n.length,i=arguments.length>1?arguments[1]:void 0,o=i?Number(i):0;o!=o&&(o=0);var c=Math.min(Math.max(o,0),r);return u+c>r?!1:-1!=b.call(e,n,o)}function n(t){if(null==this)throw TypeError();var e=String(this),r=t?Number(t):0;if(isNaN(r)&&(r=0),0>r||r==1/0)throw RangeError();if(0==r)return"";for(var n="";r--;)n+=e;return n}function u(t){if(null==this)throw TypeError();var e=String(this),r=e.length,n=t?Number(t):0;if(isNaN(n)&&(n=0),0>n||n>=r)return void 0;var u,i=e.charCodeAt(n);return i>=55296&&56319>=i&&r>n+1&&(u=e.charCodeAt(n+1),u>=56320&&57343>=u)?1024*(i-55296)+u-56320+65536:i}function i(t){var e=t.raw,r=e.length>>>0;if(0===r)return"";for(var n="",u=0;;){if(n+=e[u],u+1===r)return n;n+=arguments[++u]}}function o(t){var e,r,n=[],u=Math.floor,i=-1,o=arguments.length;if(!o)return"";for(;++i<o;){var c=Number(arguments[i]);if(!isFinite(c)||0>c||c>1114111||u(c)!=c)throw RangeError("Invalid code point: "+c);65535>=c?n.push(c):(c-=65536,e=(c>>10)+55296,r=c%1024+56320,n.push(e,r))}return String.fromCharCode.apply(null,n)}function c(){var t=$traceurRuntime.checkObjectCoercible(this),e=String(t);return s(e)}function a(a){var s=a.String;f(s.prototype,["codePointAt",u,"endsWith",e,"includes",r,"repeat",n,"startsWith",t]),f(s,["fromCodePoint",o,"raw",i]),h(s.prototype,c,Symbol)}var s=System.get("traceur-runtime@0.0.91/src/runtime/polyfills/StringIterator.js").createStringIterator,l=System.get("traceur-runtime@0.0.91/src/runtime/polyfills/utils.js"),f=l.maybeAddFunctions,h=l.maybeAddIterator,m=l.registerPolyfill,p=Object.prototype.toString,b=String.prototype.indexOf,y=String.prototype.lastIndexOf;return m(a),{get startsWith(){return t},get endsWith(){return e},get includes(){return r},get repeat(){return n},get codePointAt(){return u},get raw(){return i},get fromCodePoint(){return o},get stringPrototypeIterator(){return c},get polyfillString(){return a}}}),System.get("traceur-runtime@0.0.91/src/runtime/polyfills/String.js"),System.registerModule("traceur-runtime@0.0.91/src/runtime/polyfills/ArrayIterator.js",[],function(){"use strict";function t(t,e){var r=i(t),n=new f;return n.iteratorObject_=r,n.arrayIteratorNextIndex_=0,n.arrayIterationKind_=e,n}function e(){return t(this,l)}function r(){return t(this,a)}function n(){return t(this,s)}var u=System.get("traceur-runtime@0.0.91/src/runtime/polyfills/utils.js"),i=u.toObject,o=u.toUint32,c=u.createIteratorResultObject,a=1,s=2,l=3,f=function(){function t(){}var e;return $traceurRuntime.createClass(t,(e={},Object.defineProperty(e,"next",{value:function(){var t=i(this),e=t.iteratorObject_;if(!e)throw new TypeError("Object is not an ArrayIterator");var r=t.arrayIteratorNextIndex_,n=t.arrayIterationKind_,u=o(e.length);return r>=u?(t.arrayIteratorNextIndex_=1/0,c(void 0,!0)):(t.arrayIteratorNextIndex_=r+1,n==s?c(e[r],!1):n==l?c([r,e[r]],!1):c(r,!1))},configurable:!0,enumerable:!0,writable:!0}),Object.defineProperty(e,Symbol.iterator,{value:function(){return this},configurable:!0,enumerable:!0,writable:!0}),e),{})}();return{get entries(){return e},get keys(){return r},get values(){return n}}}),System.registerModule("traceur-runtime@0.0.91/src/runtime/polyfills/Array.js",[],function(){"use strict";function t(t){var e,r,n=arguments[1],u=arguments[2],i=this,o=j(t),c=void 0!==n,a=0;if(c&&!m(n))throw TypeError();if(h(o)){e=p(i)?new i:[];var s=!0,l=!1,f=void 0;try{for(var b=void 0,y=o[$traceurRuntime.toProperty(Symbol.iterator)]();!(s=(b=y.next()).done);s=!0){var v=b.value;c?e[a]=n.call(u,v,a):e[a]=v,a++}}catch(g){l=!0,f=g}finally{try{s||null==y["return"]||y["return"]()}finally{if(l)throw f}}return e.length=a,e}for(r=d(o.length),e=p(i)?new i(r):new Array(r);r>a;a++)c?e[a]="undefined"==typeof u?n(o[a],a):n.call(u,o[a],a):e[a]=o[a];return e.length=r,e}function e(){for(var t=[],e=0;e<arguments.length;e++)t[e]=arguments[e];for(var r=this,n=t.length,u=p(r)?new r(n):new Array(n),i=0;n>i;i++)u[i]=t[i];return u.length=n,u}function r(t){var e=void 0!==arguments[1]?arguments[1]:0,r=arguments[2],n=j(this),u=d(n.length),i=g(e),o=void 0!==r?g(r):u;for(i=0>i?Math.max(u+i,0):Math.min(i,u),o=0>o?Math.max(u+o,0):Math.min(o,u);o>i;)n[i]=t,i++;return n}function n(t){var e=arguments[1];return i(this,t,e)}function u(t){var e=arguments[1];return i(this,t,e,!0)}function i(t,e){var r=arguments[2],n=void 0!==arguments[3]?arguments[3]:!1,u=j(t),i=d(u.length);if(!m(e))throw TypeError();for(var o=0;i>o;o++){var c=u[o];if(e.call(r,c,o,u))return n?o:c}return n?-1:void 0}function o(i){var o=i,c=o.Array,f=o.Object,h=o.Symbol,m=l;h&&h.iterator&&c.prototype[h.iterator]&&(m=c.prototype[h.iterator]),b(c.prototype,["entries",a,"keys",s,"values",m,"fill",r,"find",n,"findIndex",u]),b(c,["from",t,"of",e]),y(c.prototype,m,h),y(f.getPrototypeOf([].values()),function(){return this},h)}var c=System.get("traceur-runtime@0.0.91/src/runtime/polyfills/ArrayIterator.js"),a=c.entries,s=c.keys,l=c.values,f=System.get("traceur-runtime@0.0.91/src/runtime/polyfills/utils.js"),h=f.checkIterable,m=f.isCallable,p=f.isConstructor,b=f.maybeAddFunctions,y=f.maybeAddIterator,v=f.registerPolyfill,g=f.toInteger,d=f.toLength,j=f.toObject;return v(o),{get from(){return t},get of(){return e},get fill(){return r},get find(){return n},get findIndex(){return u},get polyfillArray(){return o}}}),System.get("traceur-runtime@0.0.91/src/runtime/polyfills/Array.js"),System.registerModule("traceur-runtime@0.0.91/src/runtime/polyfills/Object.js",[],function(){"use strict";function t(t,e){return t===e?0!==t||1/t===1/e:t!==t&&e!==e}function e(t){for(var e=1;e<arguments.length;e++){var r=arguments[e],n=null==r?[]:h(r),u=void 0,i=n.length;for(u=0;i>u;u++){var o=n[u];f(o)||(t[o]=r[o])}}return t}function r(t,e){var r,n,u=l(e),i=u.length;for(r=0;i>r;r++){var o=u[r];f(o)||(n=s(e,u[r]),a(t,u[r],n))}return t}function n(n){var u=n.Object;i(u,["assign",e,"is",t,"mixin",r])}var u=System.get("traceur-runtime@0.0.91/src/runtime/polyfills/utils.js"),i=u.maybeAddFunctions,o=u.registerPolyfill,c=$traceurRuntime,a=c.defineProperty,s=c.getOwnPropertyDescriptor,l=c.getOwnPropertyNames,f=c.isPrivateName,h=c.keys;return o(n),{get is(){return t},get assign(){return e},get mixin(){return r},get polyfillObject(){return n}}}),System.get("traceur-runtime@0.0.91/src/runtime/polyfills/Object.js"),System.registerModule("traceur-runtime@0.0.91/src/runtime/polyfills/Number.js",[],function(){"use strict";function t(t){return o(t)&&h(t)}function e(e){return t(e)&&l(e)===e}function r(t){return o(t)&&m(t)}function n(e){if(t(e)){var r=l(e);if(r===e)return f(r)<=p}return!1}function u(u){var i=u.Number;c(i,["MAX_SAFE_INTEGER",p,"MIN_SAFE_INTEGER",b,"EPSILON",y]),a(i,["isFinite",t,"isInteger",e,"isNaN",r,"isSafeInteger",n])}var i=System.get("traceur-runtime@0.0.91/src/runtime/polyfills/utils.js"),o=i.isNumber,c=i.maybeAddConsts,a=i.maybeAddFunctions,s=i.registerPolyfill,l=i.toInteger,f=Math.abs,h=isFinite,m=isNaN,p=Math.pow(2,53)-1,b=-Math.pow(2,53)+1,y=Math.pow(2,-52);return s(u),{get MAX_SAFE_INTEGER(){return p},get MIN_SAFE_INTEGER(){return b},get EPSILON(){return y},get isFinite(){return t},get isInteger(){return e},get isNaN(){return r},get isSafeInteger(){return n},get polyfillNumber(){return u}}}),System.get("traceur-runtime@0.0.91/src/runtime/polyfills/Number.js"),System.registerModule("traceur-runtime@0.0.91/src/runtime/polyfills/fround.js",[],function(){"use strict";function t(t,e,r){function n(t){var e=l(t),r=t-e;return.5>r?e:r>.5?e+1:e%2?e+1:e}var u,i,o,c,p,b,y,v=(1<<e-1)-1;for(t!==t?(i=(1<<e)-1,o=m(2,r-1),u=0):t===1/0||t===-(1/0)?(i=(1<<e)-1,o=0,u=0>t?1:0):0===t?(i=0,o=0,u=1/t===-(1/0)?1:0):(u=0>t,t=s(t),t>=m(2,1-v)?(i=h(l(f(t)/a),1023),o=n(t/m(2,i)*m(2,r)),o/m(2,r)>=2&&(i+=1,o=1),i>v?(i=(1<<e)-1,o=0):(i+=v,o-=m(2,r))):(i=0,o=n(t/m(2,1-v-r)))),p=[],c=r;c;c-=1)p.push(o%2?1:0),o=l(o/2);for(c=e;c;c-=1)p.push(i%2?1:0),i=l(i/2);for(p.push(u?1:0),p.reverse(),b=p.join(""),y=[];b.length;)y.push(parseInt(b.substring(0,8),2)),b=b.substring(8);return y}function e(t,e,r){var n,u,i,o,c,a,s,l,f=[];for(n=t.length;n;n-=1)for(i=t[n-1],u=8;u;u-=1)f.push(i%2?1:0),i>>=1;return f.reverse(),o=f.join(""),c=(1<<e-1)-1,a=parseInt(o.substring(0,1),2)?-1:1,s=parseInt(o.substring(1,1+e),2),l=parseInt(o.substring(1+e),2),s===(1<<e)-1?0!==l?NaN:a*(1/0):s>0?a*m(2,s-c)*(1+l/m(2,r)):0!==l?a*m(2,-(c-1))*(l/m(2,r)):0>a?-0:0}function r(t){return e(t,8,23)}function n(e){return t(e,8,23)}function u(t){return 0===t||!i(t)||o(t)?t:r(n(Number(t)))}var i=isFinite,o=isNaN,c=Math,a=c.LN2,s=c.abs,l=c.floor,f=c.log,h=c.min,m=c.pow;return{get fround(){return u}}}),System.registerModule("traceur-runtime@0.0.91/src/runtime/polyfills/Math.js",[],function(){"use strict";function t(t){if(t=S(+t),0==t)return 32;var e=0;return 0===(4294901760&t)&&(t<<=16,e+=16),0===(4278190080&t)&&(t<<=8,e+=8),0===(4026531840&t)&&(t<<=4,e+=4),0===(3221225472&t)&&(t<<=2,e+=2),0===(2147483648&t)&&(t<<=1,e+=1),e}function e(t,e){t=S(+t),e=S(+e);var r=t>>>16&65535,n=65535&t,u=e>>>16&65535,i=65535&e;return n*i+(r*i+n*u<<16>>>0)|0}function r(t){return t=+t,t>0?1:0>t?-1:t}function n(t){return.4342944819032518*I(t)}function u(t){return 1.4426950408889634*I(t)}function i(t){if(t=+t,-1>t||_(t))return NaN;if(0===t||t===1/0)return t;if(-1===t)return-(1/0);var e=0,r=50;if(0>t||t>1)return I(1+t);for(var n=1;r>n;n++)n%2===0?e-=N(t,n)/n:e+=N(t,n)/n;return e}function o(t){return t=+t,t===-(1/0)?-1:R(t)&&0!==t?x(t)-1:t}function c(t){return t=+t,0===t?1:_(t)?NaN:R(t)?(0>t&&(t=-t),t>21?x(t)/2:(x(t)+x(-t))/2):1/0}function a(t){return t=+t,R(t)&&0!==t?(x(t)-x(-t))/2:t}function s(t){if(t=+t,0===t)return t;if(!R(t))return r(t);var e=x(t),n=x(-t);return(e-n)/(e+n)}function l(t){return t=+t,1>t?NaN:R(t)?I(t+k(t+1)*k(t-1)):t}function f(t){return t=+t,0!==t&&R(t)?t>0?I(t+k(t*t+1)):-I(-t+k(t*t+1)):t}function h(t){return t=+t,-1===t?-(1/0):1===t?1/0:0===t?t:_(t)||-1>t||t>1?NaN:.5*I((1+t)/(1-t))}function m(t,e){for(var r=arguments.length,n=new Array(r),u=0,i=0;r>i;i++){var o=arguments[i];if(o=+o,o===1/0||o===-(1/0))return 1/0;o=P(o),o>u&&(u=o),n[i]=o}0===u&&(u=1);for(var c=0,a=0,i=0;r>i;i++){var o=n[i]/u,s=o*o-a,l=c+s;a=l-c-s,c=l}return k(c)*u}function p(t){return t=+t,t>0?M(t):0>t?E(t):t}function b(t){if(t=+t,0===t)return t;var e=0>t;e&&(t=-t);var r=N(t,1/3);return e?-r:r}function y(y){var g=y.Math;w(g,["acosh",l,"asinh",f,"atanh",h,"cbrt",b,"clz32",t,"cosh",c,"expm1",o,"fround",v,"hypot",m,"imul",e,"log10",n,"log1p",i,"log2",u,"sign",r,"sinh",a,"tanh",s,"trunc",p])}var v,g,d=System.get("traceur-runtime@0.0.91/src/runtime/polyfills/fround.js").fround,j=System.get("traceur-runtime@0.0.91/src/runtime/polyfills/utils.js"),w=j.maybeAddFunctions,O=j.registerPolyfill,S=j.toUint32,R=isFinite,_=isNaN,$=Math,P=$.abs,E=$.ceil,x=$.exp,M=$.floor,I=$.log,N=$.pow,k=$.sqrt;return"function"==typeof Float32Array?(g=new Float32Array(1),v=function(t){return g[0]=Number(t),g[0]}):v=d,O(y),{get clz32(){return t},get imul(){return e},get sign(){return r},get log10(){return n},get log2(){return u},get log1p(){return i},get expm1(){return o},get cosh(){return c},get sinh(){return a},get tanh(){return s},get acosh(){return l},get asinh(){return f},get atanh(){return h},get hypot(){return m},get trunc(){return p},get fround(){return v},get cbrt(){return b},get polyfillMath(){return y}}}),System.get("traceur-runtime@0.0.91/src/runtime/polyfills/Math.js"),System.registerModule("traceur-runtime@0.0.91/src/runtime/polyfills/polyfills.js",[],function(){"use strict";var t=System.get("traceur-runtime@0.0.91/src/runtime/polyfills/utils.js").polyfillAll;t(Reflect.global);var e=$traceurRuntime.setupGlobals;return $traceurRuntime.setupGlobals=function(r){e(r),t(r)},{}}),System.get("traceur-runtime@0.0.91/src/runtime/polyfills/polyfills.js"),this.System=this._System,delete this._System;
/*[system-bundles-config]*/
System.bundles = {"bundles/can/test/test.css!":["qunitjs@1.23.1#qunit/qunit.css!$css"]};
/*npm-utils*/
define('npm-utils', function (require, exports, module) {
    (function (global) {
        var slice = Array.prototype.slice;
        var npmModuleRegEx = /.+@.+\..+\..+#.+/;
        var conditionalModuleRegEx = /#\{[^\}]+\}|#\?.+$/;
        var utils = {
            extend: function (d, s, deep) {
                var val;
                for (var prop in s) {
                    val = s[prop];
                    if (deep) {
                        if (utils.isArray(val)) {
                            d[prop] = slice.call(val);
                        } else if (utils.isObject(val)) {
                            d[prop] = utils.extend({}, val, deep);
                        } else {
                            d[prop] = s[prop];
                        }
                    } else {
                        d[prop] = s[prop];
                    }
                }
                return d;
            },
            map: function (arr, fn) {
                var i = 0, len = arr.length, out = [];
                for (; i < len; i++) {
                    out.push(fn.call(arr, arr[i]));
                }
                return out;
            },
            filter: function (arr, fn) {
                var i = 0, len = arr.length, out = [], res;
                for (; i < len; i++) {
                    res = fn.call(arr, arr[i]);
                    if (res) {
                        out.push(arr[i]);
                    }
                }
                return out;
            },
            forEach: function (arr, fn) {
                var i = 0, len = arr.length;
                for (; i < len; i++) {
                    fn.call(arr, arr[i], i);
                }
            },
            isObject: function (obj) {
                return typeof obj === 'object';
            },
            isArray: Array.isArray || function (arr) {
                return Object.prototype.toString.call(arr) === '[object Array]';
            },
            isEnv: function (name) {
                return this.isEnv ? this.isEnv(name) : this.env === name;
            },
            warnOnce: function (msg) {
                var w = this._warnings = this._warnings || {};
                if (w[msg])
                    return;
                w[msg] = true;
                if (typeof steal !== 'undefined' && typeof console !== 'undefined' && console.warn) {
                    steal.done().then(function () {
                        console.warn(msg);
                    });
                }
            },
            relativeURI: function (baseURL, url) {
                return typeof steal !== 'undefined' ? steal.relativeURI(baseURL, url) : url;
            },
            moduleName: {
                create: function (descriptor, standard) {
                    if (standard) {
                        return descriptor.moduleName;
                    } else {
                        if (descriptor === '@empty') {
                            return descriptor;
                        }
                        var modulePath;
                        if (descriptor.modulePath) {
                            modulePath = descriptor.modulePath.substr(0, 2) === './' ? descriptor.modulePath.substr(2) : descriptor.modulePath;
                        }
                        return descriptor.packageName + (descriptor.version ? '@' + descriptor.version : '') + (modulePath ? '#' + modulePath : '') + (descriptor.plugin ? descriptor.plugin : '');
                    }
                },
                isNpm: function (moduleName) {
                    return npmModuleRegEx.test(moduleName);
                },
                isConditional: function (moduleName) {
                    return conditionalModuleRegEx.test(moduleName);
                },
                isFullyConvertedNpm: function (parsedModuleName) {
                    return !!(parsedModuleName.packageName && parsedModuleName.version && parsedModuleName.modulePath);
                },
                isScoped: function (moduleName) {
                    return moduleName[0] === '@';
                },
                parse: function (moduleName, currentPackageName, global) {
                    var pluginParts = moduleName.split('!');
                    var modulePathParts = pluginParts[0].split('#');
                    var versionParts = modulePathParts[0].split('@');
                    if (!modulePathParts[1] && !versionParts[0]) {
                        versionParts = ['@' + versionParts[1]];
                    }
                    if (versionParts.length === 3 && utils.moduleName.isScoped(moduleName)) {
                        versionParts.splice(0, 1);
                        versionParts[0] = '@' + versionParts[0];
                    }
                    var packageName, modulePath;
                    if (currentPackageName && utils.path.isRelative(moduleName)) {
                        packageName = currentPackageName;
                        modulePath = versionParts[0];
                    } else {
                        if (modulePathParts[1]) {
                            packageName = versionParts[0];
                            modulePath = modulePathParts[1];
                        } else {
                            var folderParts = versionParts[0].split('/');
                            if (folderParts.length && folderParts[0][0] === '@') {
                                packageName = folderParts.splice(0, 2).join('/');
                            } else {
                                packageName = folderParts.shift();
                            }
                            modulePath = folderParts.join('/');
                        }
                    }
                    return {
                        plugin: pluginParts.length === 2 ? '!' + pluginParts[1] : undefined,
                        version: versionParts[1],
                        modulePath: modulePath,
                        packageName: packageName,
                        moduleName: moduleName,
                        isGlobal: global
                    };
                },
                parseFromPackage: function (loader, refPkg, name, parentName) {
                    var packageName = utils.pkg.name(refPkg), parsedModuleName = utils.moduleName.parse(name, packageName), isRelative = utils.path.isRelative(parsedModuleName.modulePath);
                    if (isRelative && !parentName) {
                        throw new Error('Cannot resolve a relative module identifier ' + 'with no parent module:', name);
                    }
                    if (isRelative) {
                        var parentParsed = utils.moduleName.parse(parentName, packageName);
                        if (parentParsed.packageName === parsedModuleName.packageName && parentParsed.modulePath) {
                            var makePathRelative = true;
                            if (name === '../' || name === './' || name === '..') {
                                var relativePath = utils.path.relativeTo(parentParsed.modulePath, name);
                                var isInRoot = utils.path.isPackageRootDir(relativePath);
                                if (isInRoot) {
                                    parsedModuleName.modulePath = utils.pkg.main(refPkg);
                                    makePathRelative = false;
                                } else {
                                    parsedModuleName.modulePath = name + (utils.path.endsWithSlash(name) ? '' : '/') + 'index';
                                }
                            }
                            if (makePathRelative) {
                                parsedModuleName.modulePath = utils.path.makeRelative(utils.path.joinURIs(parentParsed.modulePath, parsedModuleName.modulePath));
                            }
                        }
                    }
                    var mapName = utils.moduleName.create(parsedModuleName), mappedName;
                    if (refPkg.browser && typeof refPkg.browser !== 'string' && mapName in refPkg.browser && (!refPkg.system || !refPkg.system.ignoreBrowser)) {
                        mappedName = refPkg.browser[mapName] === false ? '@empty' : refPkg.browser[mapName];
                    }
                    var global = loader && loader.globalBrowser && loader.globalBrowser[mapName];
                    if (global) {
                        mappedName = global.moduleName === false ? '@empty' : global.moduleName;
                    }
                    if (mappedName) {
                        return utils.moduleName.parse(mappedName, packageName, !!global);
                    } else {
                        return parsedModuleName;
                    }
                },
                nameAndVersion: function (parsedModuleName) {
                    return parsedModuleName.packageName + '@' + parsedModuleName.version;
                }
            },
            pkg: {
                name: function (pkg) {
                    return pkg.system && pkg.system.name || pkg.name;
                },
                main: function (pkg) {
                    var main;
                    if (pkg.system && pkg.system.main) {
                        main = pkg.system.main;
                    } else if (typeof pkg.browser === 'string') {
                        if (utils.path.endsWithSlash(pkg.browser)) {
                            main = pkg.browser + 'index';
                        } else {
                            main = pkg.browser;
                        }
                    } else if (typeof pkg.jam === 'object') {
                        main = pkg.jam.main;
                    } else if (pkg.main) {
                        main = pkg.main;
                    } else {
                        main = 'index';
                    }
                    return utils.path.removeJS(utils.path.removeDotSlash(main));
                },
                rootDir: function (pkg, isRoot) {
                    var root = isRoot ? utils.path.removePackage(pkg.fileUrl) : utils.path.pkgDir(pkg.fileUrl);
                    var lib = utils.pkg.directoriesLib(pkg);
                    if (lib) {
                        root = utils.path.joinURIs(utils.path.addEndingSlash(root), lib);
                    }
                    return root;
                },
                isRoot: function (loader, pkg) {
                    var root = utils.pkg.getDefault(loader);
                    return pkg.name === root.name && pkg.version === root.version;
                },
                getDefault: function (loader) {
                    return loader.npmPaths.__default;
                },
                findByModuleNameOrAddress: function (loader, moduleName, moduleAddress) {
                    if (loader.npm) {
                        if (moduleName) {
                            var parsed = utils.moduleName.parse(moduleName);
                            if (parsed.version && parsed.packageName) {
                                var name = parsed.packageName + '@' + parsed.version;
                                if (name in loader.npm) {
                                    return loader.npm[name];
                                }
                            }
                        }
                        if (moduleAddress) {
                            var startingAddress = utils.relativeURI(loader.baseURL, moduleAddress);
                            var packageFolder = utils.pkg.folderAddress(startingAddress);
                            return packageFolder ? loader.npmPaths[packageFolder] : utils.pkg.getDefault(loader);
                        } else {
                            return utils.pkg.getDefault(loader);
                        }
                    }
                },
                folderAddress: function (address) {
                    var nodeModules = '/node_modules/', nodeModulesIndex = address.lastIndexOf(nodeModules), nextSlash = address.indexOf('/', nodeModulesIndex + nodeModules.length);
                    if (nodeModulesIndex >= 0) {
                        return nextSlash >= 0 ? address.substr(0, nextSlash) : address;
                    }
                },
                findDep: function (loader, refPkg, name) {
                    if (loader.npm && refPkg && !utils.path.startsWithDotSlash(name)) {
                        var nameAndVersion = name + '@' + refPkg.resolutions[name];
                        var pkg = loader.npm[nameAndVersion];
                        return pkg;
                    }
                },
                findDepWalking: function (loader, refPackage, name) {
                    if (loader.npm && refPackage && !utils.path.startsWithDotSlash(name)) {
                        var curPackage = utils.path.depPackageDir(refPackage.fileUrl, name);
                        while (curPackage) {
                            var pkg = loader.npmPaths[curPackage];
                            if (pkg) {
                                return pkg;
                            }
                            var parentAddress = utils.path.parentNodeModuleAddress(curPackage);
                            if (!parentAddress) {
                                return;
                            }
                            curPackage = parentAddress + '/' + name;
                        }
                    }
                },
                findByName: function (loader, name) {
                    if (loader.npm && !utils.path.startsWithDotSlash(name)) {
                        return loader.npm[name];
                    }
                },
                findByNameAndVersion: function (loader, name, version) {
                    if (loader.npm && !utils.path.startsWithDotSlash(name)) {
                        var nameAndVersion = name + '@' + version;
                        return loader.npm[nameAndVersion];
                    }
                },
                findByUrl: function (loader, url) {
                    if (loader.npm) {
                        url = utils.pkg.folderAddress(url);
                        return loader.npmPaths[url];
                    }
                },
                directoriesLib: function (pkg) {
                    var system = pkg.system;
                    var lib = system && system.directories && system.directories.lib;
                    var ignores = [
                            '.',
                            '/'
                        ], ignore;
                    if (!lib)
                        return undefined;
                    while (!!(ignore = ignores.shift())) {
                        if (lib[0] === ignore) {
                            lib = lib.substr(1);
                        }
                    }
                    return lib;
                },
                hasDirectoriesLib: function (pkg) {
                    var system = pkg.system;
                    return system && system.directories && !!system.directories.lib;
                },
                findPackageInfo: function (context, pkg) {
                    var pkgInfo = context.pkgInfo;
                    if (pkgInfo) {
                        var out;
                        utils.forEach(pkgInfo, function (p) {
                            if (pkg.name === p.name && pkg.version === p.version) {
                                out = p;
                            }
                        });
                        return out;
                    }
                },
                saveResolution: function (context, refPkg, pkg) {
                    var npmPkg = utils.pkg.findPackageInfo(context, refPkg);
                    npmPkg.resolutions[pkg.name] = refPkg.resolutions[pkg.name] = pkg.version;
                }
            },
            path: {
                makeRelative: function (path) {
                    if (utils.path.isRelative(path) && path.substr(0, 1) !== '/') {
                        return path;
                    } else {
                        return './' + path;
                    }
                },
                removeJS: function (path) {
                    return path.replace(/\.js(!|$)/, function (whole, part) {
                        return part;
                    });
                },
                removePackage: function (path) {
                    return path.replace(/\/package\.json.*/, '');
                },
                addJS: function (path) {
                    if (/\.js(on)?$/.test(path)) {
                        return path;
                    } else {
                        return path + '.js';
                    }
                },
                isRelative: function (path) {
                    return path.substr(0, 1) === '.';
                },
                joinURIs: function (base, href) {
                    function removeDotSegments(input) {
                        var output = [];
                        input.replace(/^(\.\.?(\/|$))+/, '').replace(/\/(\.(\/|$))+/g, '/').replace(/\/\.\.$/, '/../').replace(/\/?[^\/]*/g, function (p) {
                            if (p === '/..') {
                                output.pop();
                            } else {
                                output.push(p);
                            }
                        });
                        return output.join('').replace(/^\//, input.charAt(0) === '/' ? '/' : '');
                    }
                    href = parseURI(href || '');
                    base = parseURI(base || '');
                    return !href || !base ? null : (href.protocol || base.protocol) + (href.protocol || href.authority ? href.authority : base.authority) + removeDotSegments(href.protocol || href.authority || href.pathname.charAt(0) === '/' ? href.pathname : href.pathname ? (base.authority && !base.pathname ? '/' : '') + base.pathname.slice(0, base.pathname.lastIndexOf('/') + 1) + href.pathname : base.pathname) + (href.protocol || href.authority || href.pathname ? href.search : href.search || base.search) + href.hash;
                },
                startsWithDotSlash: function (path) {
                    return path.substr(0, 2) === './';
                },
                removeDotSlash: function (path) {
                    return utils.path.startsWithDotSlash(path) ? path.substr(2) : path;
                },
                endsWithSlash: function (path) {
                    return path[path.length - 1] === '/';
                },
                addEndingSlash: function (path) {
                    return utils.path.endsWithSlash(path) ? path : path + '/';
                },
                depPackage: function (parentPackageAddress, childName) {
                    var packageFolderName = parentPackageAddress.replace(/\/package\.json.*/, '');
                    return (packageFolderName ? packageFolderName + '/' : '') + 'node_modules/' + childName + '/package.json';
                },
                peerPackage: function (parentPackageAddress, childName) {
                    var packageFolderName = parentPackageAddress.replace(/\/package\.json.*/, '');
                    return packageFolderName.substr(0, packageFolderName.lastIndexOf('/')) + '/' + childName + '/package.json';
                },
                depPackageDir: function (parentPackageAddress, childName) {
                    return utils.path.depPackage(parentPackageAddress, childName).replace(/\/package\.json.*/, '');
                },
                peerNodeModuleAddress: function (address) {
                    var nodeModules = '/node_modules/', nodeModulesIndex = address.lastIndexOf(nodeModules);
                    if (nodeModulesIndex >= 0) {
                        return address.substr(0, nodeModulesIndex + nodeModules.length - 1);
                    }
                },
                parentNodeModuleAddress: function (address) {
                    var nodeModules = '/node_modules/', nodeModulesIndex = address.lastIndexOf(nodeModules), prevModulesIndex = address.lastIndexOf(nodeModules, nodeModulesIndex - 1);
                    if (prevModulesIndex >= 0) {
                        return address.substr(0, prevModulesIndex + nodeModules.length - 1);
                    }
                },
                pkgDir: function (address) {
                    var nodeModules = '/node_modules/', nodeModulesIndex = address.lastIndexOf(nodeModules), nextSlash = address.indexOf('/', nodeModulesIndex + nodeModules.length);
                    if (address[nodeModulesIndex + nodeModules.length] === '@') {
                        nextSlash = address.indexOf('/', nextSlash + 1);
                    }
                    if (nodeModulesIndex >= 0) {
                        return nextSlash >= 0 ? address.substr(0, nextSlash) : address;
                    }
                },
                basename: function (address) {
                    var parts = address.split('/');
                    return parts[parts.length - 1];
                },
                relativeTo: function (modulePath, rel) {
                    var parts = modulePath.split('/');
                    var idx = 1;
                    while (rel[idx] === '.') {
                        parts.pop();
                        idx++;
                    }
                    return parts.join('/');
                },
                isPackageRootDir: function (pth) {
                    return pth.indexOf('/') === -1;
                }
            },
            includeInBuild: true
        };
        function parseURI(url) {
            var m = String(url).replace(/^\s+|\s+$/g, '').match(/^([^:\/?#]+:)?(\/\/(?:[^:@]*(?::[^:@]*)?@)?(([^:\/?#]*)(?::(\d*))?))?([^?#]*)(\?[^#]*)?(#[\s\S]*)?/);
            return m ? {
                href: m[0] || '',
                protocol: m[1] || '',
                authority: m[2] || '',
                host: m[3] || '',
                hostname: m[4] || '',
                port: m[5] || '',
                pathname: m[6] || '',
                search: m[7] || '',
                hash: m[8] || ''
            } : null;
        }
        module.exports = utils;
    }(function () {
        return this;
    }()));
});
/*npm-extension*/
define('npm-extension', function (require, exports, module) {
    (function (global) {
        'format cjs';
        var utils = require('./npm-utils');
        exports.includeInBuild = true;
        var isNode = typeof process === 'object' && {}.toString.call(process) === '[object process]';
        var isWorker = typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope;
        var isBrowser = typeof window !== 'undefined' && !isNode && !isWorker;
        exports.addExtension = function (System) {
            if (System._extensions) {
                System._extensions.push(exports.addExtension);
            }
            var oldNormalize = System.normalize;
            System.normalize = function (name, parentName, parentAddress, pluginNormalize) {
                if (parentName && this.npmParentMap && this.npmParentMap[parentName]) {
                    parentName = this.npmParentMap[parentName];
                }
                var hasNoParent = !parentName;
                var nameIsRelative = utils.path.isRelative(name);
                var parentIsNpmModule = utils.moduleName.isNpm(parentName);
                var identifierEndsWithSlash = utils.path.endsWithSlash(name);
                if (parentName && nameIsRelative && !parentIsNpmModule) {
                    return oldNormalize.call(this, name, parentName, parentAddress, pluginNormalize);
                }
                if (utils.moduleName.isConditional(name)) {
                    return oldNormalize.call(this, name, parentName, parentAddress, pluginNormalize);
                }
                var hasContextualMap = typeof this.map[parentName] === 'object' && this.map[parentName][name];
                if (hasContextualMap) {
                    return oldNormalize.call(this, name, parentName, parentAddress, pluginNormalize);
                }
                var refPkg = utils.pkg.findByModuleNameOrAddress(this, parentName, parentAddress);
                if (!refPkg) {
                    return oldNormalize.call(this, name, parentName, parentAddress, pluginNormalize);
                }
                var parsedModuleName = utils.moduleName.parseFromPackage(this, refPkg, name, parentName);
                var isRoot = utils.pkg.isRoot(this, refPkg);
                var parsedPackageNameIsReferringPackage = parsedModuleName.packageName === refPkg.name;
                var isRelativeToParentNpmModule = parentIsNpmModule && nameIsRelative && parsedPackageNameIsReferringPackage;
                var depPkg, wantedPkg;
                if (isRelativeToParentNpmModule) {
                    depPkg = refPkg;
                }
                var context = this.npmContext;
                var crawl = context && context.crawl;
                var isDev = !!crawl;
                if (!depPkg) {
                    if (crawl && !isRoot) {
                        var parentPkg = nameIsRelative ? null : crawl.matchedVersion(context, refPkg.name, refPkg.version);
                        if (parentPkg) {
                            wantedPkg = crawl.getDependencyMap(this, parentPkg, isRoot)[parsedModuleName.packageName];
                            if (wantedPkg) {
                                var foundPkg = crawl.matchedVersion(this.npmContext, wantedPkg.name, wantedPkg.version);
                                if (foundPkg) {
                                    depPkg = utils.pkg.findByUrl(this, foundPkg.fileUrl);
                                }
                            }
                        }
                    } else {
                        if (isRoot) {
                            depPkg = utils.pkg.findDepWalking(this, refPkg, parsedModuleName.packageName);
                        } else {
                            depPkg = utils.pkg.findDep(this, refPkg, parsedModuleName.packageName);
                        }
                    }
                }
                if (parsedPackageNameIsReferringPackage) {
                    depPkg = utils.pkg.findByNameAndVersion(this, parsedModuleName.packageName, refPkg.version);
                }
                var lookupByName = parsedModuleName.isGlobal || hasNoParent;
                if (!depPkg) {
                    depPkg = utils.pkg.findByName(this, parsedModuleName.packageName);
                }
                var isThePackageWeWant = !isDev || !depPkg || (wantedPkg ? crawl.pkgSatisfies(depPkg, wantedPkg.version) : true);
                if (!isThePackageWeWant) {
                    depPkg = undefined;
                } else if (isDev && depPkg) {
                    utils.pkg.saveResolution(context, refPkg, depPkg);
                }
                if (!depPkg) {
                    var browserPackageName = this.globalBrowser[parsedModuleName.packageName];
                    if (browserPackageName) {
                        parsedModuleName.packageName = browserPackageName.moduleName;
                        depPkg = utils.pkg.findByName(this, parsedModuleName.packageName);
                    }
                }
                if (!depPkg && isRoot && name === refPkg.main && utils.pkg.hasDirectoriesLib(refPkg)) {
                    parsedModuleName.version = refPkg.version;
                    parsedModuleName.packageName = refPkg.name;
                    parsedModuleName.modulePath = utils.pkg.main(refPkg);
                    return oldNormalize.call(this, utils.moduleName.create(parsedModuleName), parentName, parentAddress, pluginNormalize);
                }
                var loader = this;
                if (!depPkg) {
                    if (crawl) {
                        var parentPkg = crawl.matchedVersion(this.npmContext, refPkg.name, refPkg.version);
                        if (parentPkg) {
                            depPkg = crawl.getDependencyMap(this, parentPkg, isRoot)[parsedModuleName.packageName];
                        }
                    }
                    if (!depPkg) {
                        if (refPkg.browser && refPkg.browser[name]) {
                            return oldNormalize.call(this, refPkg.browser[name], parentName, parentAddress, pluginNormalize);
                        }
                        return oldNormalize.call(this, name, parentName, parentAddress, pluginNormalize);
                    }
                    return crawl.dep(this.npmContext, parentPkg, refPkg, depPkg, isRoot).then(createModuleNameAndNormalize);
                } else {
                    return createModuleNameAndNormalize(depPkg);
                }
                function createModuleNameAndNormalize(depPkg) {
                    parsedModuleName.version = depPkg.version;
                    if (!parsedModuleName.modulePath) {
                        parsedModuleName.modulePath = utils.pkg.main(depPkg);
                    }
                    var moduleName = utils.moduleName.create(parsedModuleName);
                    if (refPkg.system && refPkg.system.map && typeof refPkg.system.map[moduleName] === 'string') {
                        moduleName = refPkg.system.map[moduleName];
                    }
                    var p = oldNormalize.call(loader, moduleName, parentName, parentAddress, pluginNormalize);
                    if (identifierEndsWithSlash) {
                        p.then(function (name) {
                            if (context && context.forwardSlashMap) {
                                context.forwardSlashMap[name] = true;
                            }
                        });
                    }
                    return p;
                }
            };
            var oldLocate = System.locate;
            System.locate = function (load) {
                var parsedModuleName = utils.moduleName.parse(load.name), loader = this;
                if (parsedModuleName.version && this.npm && !loader.paths[load.name]) {
                    var pkg = this.npm[utils.moduleName.nameAndVersion(parsedModuleName)];
                    if (pkg) {
                        return oldLocate.call(this, load).then(function (address) {
                            var expectedAddress = utils.path.joinURIs(System.baseURL, load.name);
                            if (isBrowser) {
                                expectedAddress = expectedAddress.replace(/#/g, '%23');
                            }
                            if (address !== expectedAddress + '.js' && address !== expectedAddress) {
                                return address;
                            }
                            var root = utils.pkg.rootDir(pkg, utils.pkg.isRoot(loader, pkg));
                            if (parsedModuleName.modulePath) {
                                var npmAddress = utils.path.joinURIs(utils.path.addEndingSlash(root), parsedModuleName.plugin ? parsedModuleName.modulePath : utils.path.addJS(parsedModuleName.modulePath));
                                address = typeof steal !== 'undefined' ? utils.path.joinURIs(loader.baseURL, npmAddress) : npmAddress;
                            }
                            return address;
                        });
                    }
                }
                return oldLocate.call(this, load);
            };
            var oldFetch = System.fetch;
            System.fetch = function (load) {
                if (load.metadata.dryRun) {
                    return oldFetch.apply(this, arguments);
                }
                var loader = this;
                var context = loader.npmContext;
                var fetchPromise = Promise.resolve(oldFetch.apply(this, arguments));
                if (utils.moduleName.isNpm(load.name)) {
                    fetchPromise = fetchPromise.then(null, function (err) {
                        var types = [].slice.call(retryTypes);
                        return retryAll(types, err);
                        function retryAll(types, err) {
                            if (!types.length) {
                                throw err;
                            }
                            var type = types.shift();
                            if (!type.test(load)) {
                                throw err;
                            }
                            return Promise.resolve(retryFetch.call(loader, load, type)).then(null, function (err) {
                                return retryAll(types, err);
                            });
                        }
                    });
                }
                return fetchPromise;
            };
            var convertName = function (loader, name) {
                var pkg = utils.pkg.findByName(loader, name.split('/')[0]);
                if (pkg) {
                    var parsed = utils.moduleName.parse(name, pkg.name);
                    parsed.version = pkg.version;
                    if (!parsed.modulePath) {
                        parsed.modulePath = utils.pkg.main(pkg);
                    }
                    return utils.moduleName.create(parsed);
                }
                return name;
            };
            var configSpecial = {
                map: function (map) {
                    var newMap = {}, val;
                    for (var name in map) {
                        val = map[name];
                        newMap[convertName(this, name)] = typeof val === 'object' ? configSpecial.map(val) : convertName(this, val);
                    }
                    return newMap;
                },
                meta: function (map) {
                    var newMap = {};
                    for (var name in map) {
                        newMap[convertName(this, name)] = map[name];
                    }
                    return newMap;
                },
                paths: function (paths) {
                    var newPaths = {};
                    for (var name in paths) {
                        newPaths[convertName(this, name)] = paths[name];
                    }
                    return newPaths;
                }
            };
            var oldConfig = System.config;
            System.config = function (cfg) {
                var loader = this;
                for (var name in cfg) {
                    if (configSpecial[name]) {
                        cfg[name] = configSpecial[name].call(loader, cfg[name]);
                    }
                }
                oldConfig.apply(loader, arguments);
            };
            function retryFetch(load, type) {
                var loader = this;
                var moduleName = typeof type.name === 'function' ? type.name(loader, load) : load.name + type.name;
                var local = utils.extend({}, load);
                local.name = moduleName;
                local.metadata = { dryRun: true };
                return Promise.resolve(loader.locate(local)).then(function (address) {
                    local.address = address;
                    return loader.fetch(local);
                }).then(function (source) {
                    load.address = local.address;
                    loader.npmParentMap[load.name] = local.name;
                    var npmLoad = loader.npmContext && loader.npmContext.npmLoad;
                    if (npmLoad) {
                        npmLoad.saveLoadIfNeeded(loader.npmContext);
                        if (!isNode) {
                            utils.warnOnce('Some 404s were encountered ' + 'while loading. Don\'t panic! ' + 'These will only happen in dev ' + 'and are harmless.');
                        }
                    }
                    return source;
                });
            }
            var retryTypes = [
                {
                    name: function (loader, load) {
                        var context = loader.npmContext;
                        if (context.forwardSlashMap[load.name]) {
                            var parts = load.name.split('/');
                            parts.pop();
                            return parts.concat(['index']).join('/');
                        }
                        return load.name + '/index';
                    },
                    test: function () {
                        return true;
                    }
                },
                {
                    name: '.json',
                    test: function (load) {
                        return utils.moduleName.isNpm(load.name) && utils.path.basename(load.address) === 'package.js';
                    }
                }
            ];
        };
    }(function () {
        return this;
    }()));
});
/*npm-load*/
define('npm-load', [], function(){ return {}; });
/*semver*/
define('semver', [], function(){ return {}; });
/*npm-crawl*/
define('npm-crawl', [], function(){ return {}; });
/*npm-convert*/
define('npm-convert', [], function(){ return {}; });
/*npm*/
define('npm', [], function(){ return {}; });
/*package.json!npm*/
define('package.json!npm', [
    '@loader',
    'npm-extension',
    'module'
], function (loader, npmExtension, module) {
    npmExtension.addExtension(loader);
    if (!loader.main) {
        loader.main = 'can';
    }
    loader._npmExtensions = [].slice.call(arguments, 2);
    (function (loader, packages, options) {
        var g = loader.global;
        if (!g.process) {
            g.process = {
                cwd: function () {
                    var baseURL = loader.baseURL;
                    return baseURL;
                },
                browser: true,
                env: { NODE_ENV: loader.env },
                version: '',
                platform: navigator && navigator.userAgent && /Windows/.test(navigator.userAgent) ? 'win' : ''
            };
        }
        if (!loader.npm) {
            loader.npm = {};
            loader.npmPaths = {};
            loader.globalBrowser = {};
        }
        if (!loader.npmParentMap) {
            loader.npmParentMap = options.npmParentMap || {};
        }
        var rootPkg = loader.npmPaths.__default = packages[0];
        var lib = packages[0].system && packages[0].system.directories && packages[0].system.directories.lib;
        var setGlobalBrowser = function (globals, pkg) {
            for (var name in globals) {
                loader.globalBrowser[name] = {
                    pkg: pkg,
                    moduleName: globals[name]
                };
            }
        };
        var setInNpm = function (name, pkg) {
            if (!loader.npm[name]) {
                loader.npm[name] = pkg;
            }
            loader.npm[name + '@' + pkg.version] = pkg;
        };
        var forEach = function (arr, fn) {
            var i = 0, len = arr.length;
            for (; i < len; i++) {
                fn.call(arr, arr[i]);
            }
        };
        var setupLiveReload = function () {
            var hasLiveReload = !!(loader.liveReloadInstalled || loader._liveMap);
            if (hasLiveReload) {
                loader['import']('live-reload', { name: module.id }).then(function (reload) {
                    reload.dispose(function () {
                        delete loader.npm;
                        delete loader.npmPaths;
                        delete loader.npmParentMap;
                        delete loader.npmContext;
                    });
                });
            }
        };
        var ignoredConfig = [
            'bundle',
            'configDependencies',
            'transpiler'
        ];
        forEach(packages, function (pkg) {
            if (pkg.system) {
                var system = pkg.system;
                var main = system.main;
                delete system.main;
                var configDeps = system.configDependencies;
                if (pkg !== rootPkg) {
                    forEach(ignoredConfig, function (name) {
                        delete system[name];
                    });
                }
                loader.config(system);
                if (pkg === rootPkg) {
                    system.configDependencies = configDeps;
                }
                system.main = main;
            }
            if (pkg.globalBrowser) {
                setGlobalBrowser(pkg.globalBrowser, pkg);
            }
            var systemName = system && system.name;
            if (systemName) {
                setInNpm(systemName, pkg);
            } else {
                setInNpm(pkg.name, pkg);
            }
            if (!loader.npm[pkg.name]) {
                loader.npm[pkg.name] = pkg;
            }
            loader.npm[pkg.name + '@' + pkg.version] = pkg;
            var pkgAddress = pkg.fileUrl.replace(/\/package\.json.*/, '');
            loader.npmPaths[pkgAddress] = pkg;
        });
        forEach(loader._npmExtensions || [], function (ext) {
            if (ext.systemConfig) {
                loader.config(ext.systemConfig);
            }
        });
        setupLiveReload();
    }(loader, [
        {
            'name': 'can',
            'version': '3.4.1',
            'fileUrl': './package.json',
            'main': 'can.js',
            'system': {
                'npmAlgorithm': 'flat',
                'main': 'can',
                'npmIgnore': {
                    'bit-docs': true,
                    'testee': true,
                    'async': true,
                    'saucelabs': true,
                    'wd': true,
                    'http-server': true
                },
                'meta': {
                    'socket.io-client@1.7.3#dist/socket.io': { 'format': 'cjs' },
                    'socket.io-client/dist/socket.io': { 'format': 'cjs' }
                }
            },
            'globalBrowser': {},
            'browser': {},
            'resolutions': {
                'can': '3.4.1',
                'can-connect': '1.3.8',
                'can-construct-super': '3.0.3',
                'can-define': '1.0.17',
                'can-set': '1.1.0',
                'can-stache-converters': '3.0.7',
                'can-view-model': '3.1.3',
                'can-view-target': '3.0.7',
                'can-simple-dom': '1.0.5',
                'can-map-define': '3.0.5',
                'can-view-href': '3.0.4',
                'can-map-backup': '3.0.3',
                'can-validate-legacy': '1.0.2',
                'can-fixture': '1.0.13',
                'can-compute': '3.0.7',
                'can-component': '3.0.6',
                'can-construct': '3.1.1',
                'can-util': '3.3.2',
                'can-stache': '3.0.20',
                'can-stache-bindings': '3.0.12',
                'can-event': '3.1.1',
                'can-view-import': '3.0.6',
                'can-view-nodelist': '3.0.4',
                'can-view-live': '3.0.6',
                'can-view-scope': '3.1.4',
                'can-view-parser': '3.0.6',
                'can-view-autorender': '3.0.4',
                'can-map': '3.0.6',
                'can-list': '3.0.3',
                'can-control': '3.0.7',
                'steal-qunit': '0.1.4',
                'can-ejs': '3.0.4',
                'funcunit': '3.2.0'
            }
        },
        {
            'name': 'can-cid',
            'version': '1.0.3',
            'fileUrl': './node_modules/can-cid/package.json',
            'main': 'can-cid',
            'globalBrowser': {},
            'browser': {},
            'resolutions': { 'can-namespace': '1.0.0' }
        },
        {
            'name': 'can-component',
            'version': '3.0.6',
            'fileUrl': './node_modules/can-component/package.json',
            'main': 'can-component',
            'system': {
                'configDependencies': ['live-reload'],
                'npmAlgorithm': 'flat'
            },
            'globalBrowser': {},
            'browser': {},
            'resolutions': {
                'can-component': '3.0.6',
                'can-stache': '3.0.20',
                'steal-qunit': '0.1.4',
                'can-define': '1.0.17',
                'can-view-model': '3.1.3',
                'can-types': '1.0.4',
                'can-construct': '3.1.1',
                'can-compute': '3.0.7',
                'can-map': '3.0.6',
                'can-list': '3.0.3',
                'can-event': '3.1.1',
                'can-util': '3.3.2',
                'can-vdom': '3.0.2',
                'can-view-scope': '3.1.4',
                'can-view-callbacks': '3.0.6',
                'can-namespace': '1.0.0',
                'can-stache-bindings': '3.0.12',
                'can-view-nodelist': '3.0.4',
                'can-control': '3.0.7',
                'can-observation': '3.1.2'
            }
        },
        {
            'name': 'can-compute',
            'version': '3.0.7',
            'fileUrl': './node_modules/can-compute/package.json',
            'main': 'can-compute',
            'globalBrowser': {},
            'browser': {},
            'resolutions': {
                'can-compute': '3.0.7',
                'steal-qunit': '0.1.4',
                'can-event': '3.1.1',
                'can-observation': '3.1.2',
                'can-define': '1.0.17',
                'can-util': '3.3.2',
                'can-cid': '1.0.3',
                'can-namespace': '1.0.0',
                'can-types': '1.0.4'
            }
        },
        {
            'name': 'can-connect',
            'version': '1.3.8',
            'fileUrl': './node_modules/can-connect/package.json',
            'main': 'can-connect.js',
            'globalBrowser': {},
            'browser': {},
            'resolutions': {
                'can-connect': '1.3.8',
                'steal-qunit': '0.1.4',
                'can-set': '1.1.0',
                'can-define': '1.0.17',
                'can-fixture': '1.0.13',
                'can-util': '3.3.2',
                'jquery': '3.1.1',
                'can-namespace': '1.0.0',
                'can-event': '3.1.1',
                'can-observation': '3.1.2',
                'can-types': '1.0.4',
                'can-compute': '3.0.7',
                'can-map': '3.0.6',
                'can-list': '3.0.3',
                'steal-stache': '3.0.5',
                'can-stache-bindings': '3.0.12',
                'can-stache': '3.0.20',
                'can-view-callbacks': '3.0.6',
                'can-view-nodelist': '3.0.4',
                'can-construct': '3.1.1'
            }
        },
        {
            'name': 'can-connect-feathers',
            'version': '3.5.2',
            'fileUrl': './node_modules/can-connect-feathers/package.json',
            'main': 'can-connect-feathers',
            'globalBrowser': {},
            'browser': {},
            'resolutions': {}
        },
        {
            'name': 'can-construct',
            'version': '3.1.1',
            'fileUrl': './node_modules/can-construct/package.json',
            'main': 'can-construct',
            'globalBrowser': {},
            'browser': {},
            'resolutions': {
                'steal-qunit': '0.1.4',
                'can-construct': '3.1.1',
                'can-util': '3.3.2',
                'can-types': '1.0.4',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-construct-super',
            'version': '3.0.3',
            'fileUrl': './node_modules/can-construct-super/package.json',
            'main': 'can-construct-super',
            'globalBrowser': {},
            'browser': {},
            'resolutions': {
                'can-construct-super': '3.0.3',
                'steal-qunit': '0.1.4',
                'can-util': '3.3.2',
                'can-construct': '3.1.1'
            }
        },
        {
            'name': 'can-control',
            'version': '3.0.7',
            'fileUrl': './node_modules/can-control/package.json',
            'main': 'can-control',
            'globalBrowser': {},
            'browser': {},
            'resolutions': {
                'can-control': '3.0.7',
                'steal-qunit': '0.1.4',
                'can-util': '3.3.2',
                'can-event': '3.1.1',
                'can-types': '1.0.4',
                'can-map': '3.0.6',
                'can-define': '1.0.17',
                'can-construct': '3.1.1',
                'can-namespace': '1.0.0',
                'can-compute': '3.0.7',
                'can-observation': '3.1.2'
            }
        },
        {
            'name': 'can-define',
            'version': '1.0.17',
            'fileUrl': './node_modules/can-define/package.json',
            'main': 'can-define.js',
            'globalBrowser': {},
            'browser': {},
            'resolutions': {
                'can-define': '1.0.17',
                'can-util': '3.3.2',
                'can-types': '1.0.4',
                'steal-qunit': '0.1.4',
                'can-construct': '3.1.1',
                'can-observation': '3.1.2',
                'can-event': '3.1.1',
                'can-namespace': '1.0.0',
                'can-cid': '1.0.3',
                'can-stache': '3.0.20',
                'can-compute': '3.0.7',
                'can-list': '3.0.3'
            }
        },
        {
            'name': 'can-define-stream',
            'version': '0.0.7',
            'fileUrl': './node_modules/can-define-stream/package.json',
            'main': 'can-define-stream',
            'globalBrowser': {},
            'browser': {},
            'resolutions': {}
        },
        {
            'name': 'can-ejs',
            'version': '3.0.4',
            'fileUrl': './node_modules/can-ejs/package.json',
            'main': 'can-ejs',
            'globalBrowser': {},
            'browser': {},
            'resolutions': {
                'steal-qunit': '0.1.4',
                'can-ejs': '3.0.4',
                'can-map': '3.0.6',
                'can-util': '3.3.2',
                'can-list': '3.0.3',
                'can-compute': '3.0.7',
                'can-legacy-view-helpers': '0.5.0',
                'can-namespace': '1.0.0',
                'can-types': '1.0.4',
                'can-observation': '3.1.2'
            }
        },
        {
            'name': 'can-event',
            'version': '3.1.1',
            'fileUrl': './node_modules/can-event/package.json',
            'main': 'can-event',
            'system': { 'npmAlgorithm': 'flat' },
            'globalBrowser': {},
            'browser': {},
            'resolutions': {
                'can-event': '3.1.1',
                'steal-qunit': '0.1.4',
                'can-util': '3.3.2',
                'can-namespace': '1.0.0',
                'can-types': '1.0.4',
                'can-cid': '1.0.3'
            }
        },
        {
            'name': 'can-fixture',
            'version': '1.0.13',
            'fileUrl': './node_modules/can-fixture/package.json',
            'main': 'fixture.js',
            'globalBrowser': {},
            'browser': {},
            'resolutions': {
                'steal-qunit': '0.1.4',
                'can-fixture': '1.0.13',
                'can-set': '1.1.0',
                'jquery': '3.1.1',
                'can-util': '3.3.2',
                'can-namespace': '1.0.0',
                'can-connect': '1.3.8'
            }
        },
        {
            'name': 'can-fixture-socket',
            'version': '0.6.2',
            'fileUrl': './node_modules/can-fixture-socket/package.json',
            'main': 'can-fixture-socket',
            'globalBrowser': {},
            'browser': {},
            'resolutions': {}
        },
        {
            'name': 'can-jquery',
            'version': '3.0.4',
            'fileUrl': './node_modules/can-jquery/package.json',
            'main': 'can-jquery.js',
            'globalBrowser': {},
            'browser': {},
            'resolutions': {}
        },
        {
            'name': 'can-list',
            'version': '3.0.3',
            'fileUrl': './node_modules/can-list/package.json',
            'main': 'can-list',
            'system': {
                'configDependencies': ['live-reload'],
                'npmAlgorithm': 'flat'
            },
            'globalBrowser': {},
            'browser': {},
            'resolutions': {
                'can-list': '3.0.3',
                'steal-qunit': '0.1.4',
                'can-observation': '3.1.2',
                'can-map': '3.0.6',
                'can-map-define': '3.0.5',
                'can-event': '3.1.1',
                'can-namespace': '1.0.0',
                'can-cid': '1.0.3',
                'can-util': '3.3.2',
                'can-types': '1.0.4'
            }
        },
        {
            'name': 'can-map',
            'version': '3.0.6',
            'fileUrl': './node_modules/can-map/package.json',
            'main': 'can-map',
            'globalBrowser': {},
            'browser': {},
            'resolutions': {
                'can-map': '3.0.6',
                'steal-qunit': '0.1.4',
                'can-observation': '3.1.2',
                'can-construct': '3.1.1',
                'can-event': '3.1.1',
                'can-compute': '3.0.7',
                'can-namespace': '1.0.0',
                'can-util': '3.3.2',
                'can-cid': '1.0.3',
                'can-types': '1.0.4'
            }
        },
        {
            'name': 'can-map-backup',
            'version': '3.0.3',
            'fileUrl': './node_modules/can-map-backup/package.json',
            'main': 'can-map-backup',
            'globalBrowser': {},
            'browser': {},
            'resolutions': {
                'can-compute': '3.0.7',
                'can-map': '3.0.6',
                'can-map-backup': '3.0.3',
                'can-map-define': '3.0.5',
                'steal-qunit': '0.1.4',
                'can-set': '1.1.0',
                'can-util': '3.3.2'
            }
        },
        {
            'name': 'can-map-define',
            'version': '3.0.5',
            'fileUrl': './node_modules/can-map-define/package.json',
            'main': 'can-map-define',
            'globalBrowser': {},
            'browser': {},
            'resolutions': {
                'steal-qunit': '0.1.4',
                'can-util': '3.3.2',
                'can-map': '3.0.6',
                'can-list': '3.0.3',
                'can-compute': '3.0.7',
                'can-map-define': '3.0.5',
                'can-event': '3.1.1'
            }
        },
        {
            'name': 'can-namespace',
            'version': '1.0.0',
            'fileUrl': './node_modules/can-namespace/package.json',
            'main': 'can-namespace',
            'system': { 'npmAlgorithm': 'flat' },
            'globalBrowser': {},
            'browser': {},
            'resolutions': {}
        },
        {
            'name': 'can-observation',
            'version': '3.1.2',
            'fileUrl': './node_modules/can-observation/package.json',
            'main': 'can-observation',
            'system': {
                'configDependencies': ['live-reload'],
                'npmAlgorithm': 'flat'
            },
            'globalBrowser': {},
            'browser': {},
            'resolutions': {
                'can-event': '3.1.1',
                'can-util': '3.3.2',
                'can-namespace': '1.0.0',
                'can-observation': '3.1.2',
                'can-cid': '1.0.3',
                'can-types': '1.0.4'
            }
        },
        {
            'name': 'can-route',
            'version': '3.0.8',
            'fileUrl': './node_modules/can-route/package.json',
            'main': 'can-route',
            'globalBrowser': {},
            'browser': {},
            'resolutions': {
                'can-event': '3.1.1',
                'can-observation': '3.1.2',
                'can-compute': '3.0.7',
                'can-namespace': '1.0.0',
                'can-util': '3.3.2',
                'can-types': '1.0.4',
                'can-route': '3.0.8'
            }
        },
        {
            'name': 'can-set',
            'version': '1.1.0',
            'fileUrl': './node_modules/can-set/package.json',
            'main': 'src/set.js',
            'globalBrowser': {},
            'browser': {},
            'resolutions': {
                'can-set': '1.1.0',
                'steal-qunit': '0.1.4',
                'can-namespace': '1.0.0',
                'can-util': '3.3.2'
            }
        },
        {
            'name': 'can-route-pushstate',
            'version': '3.0.3',
            'fileUrl': './node_modules/can-route-pushstate/package.json',
            'main': 'can-route-pushstate',
            'globalBrowser': {},
            'browser': {},
            'resolutions': {}
        },
        {
            'name': 'can-simple-dom',
            'version': '1.0.5',
            'fileUrl': './node_modules/can-simple-dom/package.json',
            'main': 'dist/cjs/simple-dom.js',
            'system': {
                'main': 'simple-dom.js',
                'directories': { 'lib': 'lib' },
                'npmIgnore': { 'testee': true }
            },
            'globalBrowser': {},
            'browser': {},
            'resolutions': {
                'can-simple-dom': '1.0.5',
                'steal-qunit': '0.1.4',
                'he': '1.1.1',
                'simple-html-tokenizer': '0.2.6',
                'micro-location': '0.1.5'
            }
        },
        {
            'name': 'can-simple-map',
            'version': '3.1.3',
            'fileUrl': './node_modules/can-simple-map/package.json',
            'main': 'can-simple-map',
            'globalBrowser': {},
            'browser': {},
            'resolutions': {
                'can-construct': '3.1.1',
                'can-event': '3.1.1',
                'can-util': '3.3.2',
                'can-types': '1.0.4',
                'can-observation': '3.1.2'
            }
        },
        {
            'name': 'can-stache',
            'version': '3.0.20',
            'fileUrl': './node_modules/can-stache/package.json',
            'main': 'can-stache',
            'globalBrowser': {},
            'browser': {},
            'resolutions': {
                'can-stache': '3.0.20',
                'steal-qunit': '0.1.4',
                'can-map': '3.0.6',
                'can-list': '3.0.3',
                'can-compute': '3.0.7',
                'can-define': '1.0.17',
                'can-view-callbacks': '3.0.6',
                'can-view-scope': '3.1.4',
                'can-view-parser': '3.0.6',
                'can-view-nodelist': '3.0.4',
                'can-event': '3.1.1',
                'can-vdom': '3.0.2',
                'can-util': '3.3.2',
                'can-namespace': '1.0.0',
                'can-view-target': '3.0.7',
                'can-route': '3.0.8',
                'can-observation': '3.1.2',
                'can-view-live': '3.0.6',
                'can-types': '1.0.4'
            }
        },
        {
            'name': 'can-stache-bindings',
            'version': '3.0.12',
            'fileUrl': './node_modules/can-stache-bindings/package.json',
            'main': 'can-stache-bindings',
            'globalBrowser': {},
            'browser': {},
            'resolutions': {
                'can-stache-bindings': '3.0.12',
                'steal-qunit': '0.1.4',
                'can-list': '3.0.3',
                'can-map': '3.0.6',
                'can-stache': '3.0.20',
                'can-event': '3.1.1',
                'can-view-callbacks': '3.0.6',
                'can-compute': '3.0.7',
                'can-view-model': '3.1.3',
                'can-util': '3.3.2',
                'can-vdom': '3.0.2',
                'can-types': '1.0.4',
                'can-view-live': '3.0.6',
                'can-view-scope': '3.1.4',
                'can-observation': '3.1.2',
                'can-define': '1.0.17',
                'can-view-nodelist': '3.0.4'
            }
        },
        {
            'name': 'can-stache-converters',
            'version': '3.0.7',
            'fileUrl': './node_modules/can-stache-converters/package.json',
            'main': 'can-stache-converters',
            'globalBrowser': {},
            'browser': {},
            'resolutions': {
                'can-stache-converters': '3.0.7',
                'can-event': '3.1.1',
                'can-define': '1.0.17',
                'can-stache': '3.0.20',
                'can-util': '3.3.2',
                'steal-qunit': '0.1.4',
                'can-compute': '3.0.7',
                'can-stache-bindings': '3.0.12'
            }
        },
        {
            'name': 'can-stream-kefir',
            'version': '0.1.2',
            'fileUrl': './node_modules/can-stream-kefir/package.json',
            'main': 'can-stream-kefir',
            'globalBrowser': {},
            'browser': {},
            'resolutions': {}
        },
        {
            'name': 'can-types',
            'version': '1.0.4',
            'fileUrl': './node_modules/can-types/package.json',
            'main': 'can-types',
            'globalBrowser': {},
            'browser': {},
            'resolutions': { 'can-namespace': '1.0.0' }
        },
        {
            'name': 'can-util',
            'version': '3.3.2',
            'fileUrl': './node_modules/can-util/package.json',
            'main': 'can-util',
            'globalBrowser': {},
            'browser': {},
            'resolutions': {
                'can-util': '3.3.2',
                'can-namespace': '1.0.0',
                'can-types': '1.0.4',
                'can-cid': '1.0.3',
                'steal-qunit': '0.1.4'
            }
        },
        {
            'name': 'can-validate-legacy',
            'version': '1.0.2',
            'fileUrl': './node_modules/can-validate-legacy/package.json',
            'main': 'can-validate.js',
            'globalBrowser': {},
            'browser': {
                'can-validate-legacy#can-validate': 'can-validate-legacy#dist/cjs/can-validate/can-validate',
                'can-validate-legacy#map/validate': 'can-validate-legacy#dist/cjs/can-validate/map/validate/validate',
                'can-validate-legacy#validations': 'can-validate-legacy#dist/cjs/can-validate/validations',
                'can-validate-legacy#shims/validatejs.shim': 'can-validate-legacy#dist/cjs/can-validate/shims/validatejs.shim'
            },
            'resolutions': {
                'can-util': '3.3.2',
                'can-map': '3.0.6',
                'steal-qunit': '0.1.4',
                'can-map-define': '3.0.5',
                'can-validate-legacy': '1.0.2',
                'jquery': '3.1.1',
                'can-compute': '3.0.7',
                'validate.js': '0.11.1'
            }
        },
        {
            'name': 'can-vdom',
            'version': '3.0.2',
            'fileUrl': './node_modules/can-vdom/package.json',
            'main': 'can-vdom.js',
            'globalBrowser': {},
            'browser': {},
            'resolutions': {
                'can-vdom': '3.0.2',
                'can-simple-dom': '0.4.8',
                'can-view-parser': '3.0.6'
            }
        },
        {
            'name': 'can-view-autorender',
            'version': '3.0.4',
            'fileUrl': './node_modules/can-view-autorender/package.json',
            'main': 'can-view-autorender',
            'globalBrowser': {},
            'browser': {},
            'resolutions': { 'steal-qunit': '0.1.4' }
        },
        {
            'name': 'can-view-callbacks',
            'version': '3.0.6',
            'fileUrl': './node_modules/can-view-callbacks/package.json',
            'main': 'can-view-callbacks',
            'globalBrowser': {},
            'browser': {},
            'resolutions': {
                'can-observation': '3.1.2',
                'can-util': '3.3.2',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-view-href',
            'version': '3.0.4',
            'fileUrl': './node_modules/can-view-href/package.json',
            'main': 'can-view-href',
            'globalBrowser': {},
            'browser': {},
            'resolutions': {
                'can-route': '3.0.8',
                'steal-qunit': '0.1.4',
                'can-view-href': '3.0.4',
                'can-stache': '3.0.20',
                'can-view-callbacks': '3.0.6',
                'can-compute': '3.0.7',
                'can-util': '3.3.2'
            }
        },
        {
            'name': 'can-view-import',
            'version': '3.0.6',
            'fileUrl': './node_modules/can-view-import/package.json',
            'main': 'can-view-import',
            'globalBrowser': {},
            'browser': {},
            'resolutions': {
                'can-map': '3.0.6',
                'can-component': '3.0.6',
                'can-stache': '3.0.20',
                'can-compute': '3.0.7',
                'steal-qunit': '0.1.4',
                'can-util': '3.3.2',
                'can-view-callbacks': '3.0.6',
                'can-view-import': '3.0.6',
                'can-view-nodelist': '3.0.4',
                'can-event': '3.1.1'
            }
        },
        {
            'name': 'can-view-live',
            'version': '3.0.6',
            'fileUrl': './node_modules/can-view-live/package.json',
            'main': 'can-view-live',
            'globalBrowser': {},
            'browser': {},
            'resolutions': {
                'can-view-live': '3.0.6',
                'can-compute': '3.0.7',
                'can-map': '3.0.6',
                'can-list': '3.0.3',
                'can-view-nodelist': '3.0.4',
                'can-event': '3.1.1',
                'steal-qunit': '0.1.4',
                'can-util': '3.3.2',
                'can-view-parser': '3.0.6',
                'can-view-callbacks': '3.0.6',
                'can-types': '1.0.4'
            }
        },
        {
            'name': 'can-view-model',
            'version': '3.1.3',
            'fileUrl': './node_modules/can-view-model/package.json',
            'main': 'can-view-model',
            'globalBrowser': {},
            'browser': {},
            'resolutions': {
                'can-view-model': '3.1.3',
                'steal-qunit': '0.1.4',
                'can-simple-map': '3.1.3',
                'can-types': '1.0.4',
                'can-util': '3.3.2',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-view-nodelist',
            'version': '3.0.4',
            'fileUrl': './node_modules/can-view-nodelist/package.json',
            'main': 'can-view-nodelist',
            'globalBrowser': {},
            'browser': {},
            'resolutions': {
                'can-view-nodelist': '3.0.4',
                'can-util': '3.3.2',
                'steal-qunit': '0.1.4',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-view-parser',
            'version': '3.0.6',
            'fileUrl': './node_modules/can-view-parser/package.json',
            'main': 'can-view-parser',
            'globalBrowser': {},
            'browser': {},
            'resolutions': {
                'can-view-parser': '3.0.6',
                'steal-qunit': '0.1.4',
                'can-namespace': '1.0.0',
                'can-util': '3.3.2'
            }
        },
        {
            'name': 'can-view-scope',
            'version': '3.1.4',
            'fileUrl': './node_modules/can-view-scope/package.json',
            'main': 'can-view-scope',
            'globalBrowser': {},
            'browser': {},
            'resolutions': {
                'can-view-scope': '3.1.4',
                'can-map': '3.0.6',
                'can-list': '3.0.3',
                'can-observation': '3.1.2',
                'can-compute': '3.0.7',
                'steal-qunit': '0.1.4',
                'can-define': '1.0.17',
                'can-util': '3.3.2',
                'can-namespace': '1.0.0',
                'can-types': '1.0.4',
                'can-simple-map': '3.1.3'
            }
        },
        {
            'name': 'can-view-target',
            'version': '3.0.7',
            'fileUrl': './node_modules/can-view-target/package.json',
            'main': 'can-view-target',
            'globalBrowser': {},
            'browser': {},
            'resolutions': {
                'can-view-target': '3.0.7',
                'can-simple-dom': '1.0.5',
                'steal-qunit': '0.1.4',
                'can-util': '3.3.2',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-zone',
            'version': '0.6.6',
            'fileUrl': './node_modules/can-zone/package.json',
            'main': 'lib/zone.js',
            'globalBrowser': {},
            'browser': {},
            'resolutions': {}
        },
        {
            'name': 'es6-promise',
            'version': '4.1.0',
            'fileUrl': './node_modules/es6-promise/package.json',
            'main': 'dist/es6-promise.js',
            'globalBrowser': {},
            'browser': { 'vertx': '@empty' },
            'resolutions': {}
        },
        {
            'name': 'feathers',
            'version': '2.1.1',
            'fileUrl': './node_modules/feathers/package.json',
            'main': 'lib/index',
            'globalBrowser': {},
            'browser': { 'feathers#lib/index': 'feathers#lib/client/index' },
            'resolutions': {}
        },
        {
            'name': 'feathers-authentication-client',
            'version': '0.1.10',
            'fileUrl': './node_modules/feathers-authentication-client/package.json',
            'main': 'lib/index',
            'globalBrowser': {},
            'browser': {},
            'resolutions': {}
        },
        {
            'name': 'feathers-hooks',
            'version': '1.8.1',
            'fileUrl': './node_modules/feathers-hooks/package.json',
            'main': 'lib/hooks.js',
            'globalBrowser': {},
            'browser': {},
            'resolutions': {}
        },
        {
            'name': 'feathers-rest',
            'version': '1.7.1',
            'fileUrl': './node_modules/feathers-rest/package.json',
            'main': 'lib/',
            'globalBrowser': {},
            'browser': { 'feathers-rest#lib/index': 'feathers-rest#lib/client/index' },
            'resolutions': {}
        },
        {
            'name': 'feathers-socketio',
            'version': '1.5.2',
            'fileUrl': './node_modules/feathers-socketio/package.json',
            'main': 'lib/',
            'globalBrowser': {},
            'browser': { 'feathers-socketio#lib/index': 'feathers-socketio#lib/client' },
            'resolutions': {}
        },
        {
            'name': 'funcunit',
            'version': '3.2.0',
            'fileUrl': './node_modules/funcunit/package.json',
            'main': 'dist/cjs/funcunit.js',
            'system': {
                'main': 'funcunit',
                'map': { 'chai': 'chai/chai' },
                'npmIgnore': {
                    'documentjs': true,
                    'steal': true,
                    'steal-tools': true,
                    'testee': true
                }
            },
            'globalBrowser': {},
            'browser': {},
            'resolutions': {
                'funcunit': '3.2.0',
                'syn': '0.4.2',
                'jquery': '1.11.0'
            }
        },
        {
            'name': 'jquery',
            'version': '3.1.1',
            'fileUrl': './node_modules/jquery/package.json',
            'main': 'dist/jquery.js',
            'globalBrowser': {},
            'browser': {},
            'resolutions': {}
        },
        {
            'name': 'jquery-ui',
            'version': '1.12.1',
            'fileUrl': './node_modules/jquery-ui/package.json',
            'main': 'ui/widget.js',
            'globalBrowser': {},
            'browser': {},
            'resolutions': {}
        },
        {
            'name': 'socket.io-client',
            'version': '1.7.3',
            'fileUrl': './node_modules/socket.io-client/package.json',
            'main': './lib/index',
            'globalBrowser': {},
            'browser': {},
            'resolutions': {}
        },
        {
            'name': 'steal-qunit',
            'version': '0.1.4',
            'fileUrl': './node_modules/steal-qunit/package.json',
            'main': 'steal-qunit',
            'system': {
                'npmIgnore': {
                    'bower': true,
                    'grunt': true,
                    'grunt-cli': true,
                    'grunt-contrib-copy': true,
                    'grunt-contrib-watch': true,
                    'steal': true,
                    'steal-tools': true,
                    'testee': true
                },
                'meta': {
                    'qunitjs@1.23.1#qunit/qunit': {
                        'format': 'global',
                        'exports': 'QUnit',
                        'deps': ['steal-qunit/add-dom']
                    }
                }
            },
            'globalBrowser': {},
            'browser': {},
            'resolutions': { 'qunitjs': '1.23.1' }
        },
        {
            'name': 'steal-stache',
            'version': '3.0.5',
            'fileUrl': './node_modules/steal-stache/package.json',
            'main': 'dist/cjs/steal-stache',
            'system': {
                'main': 'steal-stache',
                'configDependencies': ['live-reload'],
                'npmIgnore': [
                    'documentjs',
                    'testee',
                    'generator-donejs',
                    'donejs-cli',
                    'steal-tools'
                ],
                'npmAlgorithm': 'flat',
                'ext': { 'stache': 'steal-stache' }
            },
            'globalBrowser': {},
            'browser': {},
            'resolutions': {}
        },
        {
            'name': 'qunitjs',
            'version': '1.23.1',
            'fileUrl': './node_modules/qunitjs/package.json',
            'main': 'qunit/qunit.js',
            'globalBrowser': {},
            'browser': {},
            'resolutions': { 'steal-qunit': '0.1.4' }
        },
        {
            'name': 'validate.js',
            'version': '0.11.1',
            'fileUrl': './node_modules/validate.js/package.json',
            'main': 'validate.js',
            'globalBrowser': {},
            'browser': {},
            'resolutions': {}
        },
        {
            'name': 'syn',
            'version': '0.4.2',
            'fileUrl': './node_modules/syn/package.json',
            'main': 'dist/cjs/syn.js',
            'globalBrowser': {},
            'browser': {},
            'resolutions': { 'syn': '0.4.2' }
        },
        {
            'name': 'can-legacy-view-helpers',
            'version': '0.5.0',
            'fileUrl': './node_modules/can-legacy-view-helpers/package.json',
            'main': 'dist/cjs/can-legacy-view-helpers',
            'system': {
                'npmIgnore': {
                    'documentjs': true,
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-legacy-view-helpers'
            },
            'globalBrowser': {},
            'browser': {},
            'resolutions': {
                'can-legacy-view-helpers': '0.5.0',
                'can-util': '3.3.2',
                'can-compute': '3.0.7',
                'can-view-callbacks': '3.0.6',
                'can-view-parser': '3.0.6',
                'can-event': '3.1.1'
            }
        },
        {
            'name': 'can-simple-dom',
            'version': '0.4.8',
            'fileUrl': './node_modules/can-vdom/node_modules/can-simple-dom/package.json',
            'main': 'dist/cjs/simple-dom.js',
            'system': {
                'directories': { 'lib': 'lib' },
                'npmIgnore': ['testee'],
                'main': 'simple-dom.js'
            },
            'globalBrowser': {},
            'browser': {},
            'resolutions': { 'can-simple-dom': '0.4.8' }
        },
        {
            'name': 'he',
            'version': '1.1.1',
            'fileUrl': './node_modules/he/package.json',
            'main': 'he.js',
            'globalBrowser': {},
            'browser': {},
            'resolutions': {}
        },
        {
            'name': 'simple-html-tokenizer',
            'version': '0.2.6',
            'fileUrl': './node_modules/simple-html-tokenizer/package.json',
            'main': 'dist/simple-html-tokenizer.js',
            'globalBrowser': {},
            'browser': {},
            'resolutions': { 'simple-html-tokenizer': '0.2.6' }
        },
        {
            'name': 'micro-location',
            'version': '0.1.5',
            'fileUrl': './node_modules/micro-location/package.json',
            'main': 'lib/micro-location.js',
            'globalBrowser': {},
            'browser': {},
            'resolutions': {}
        },
        {
            'name': 'jquery',
            'version': '1.11.0',
            'fileUrl': './node_modules/funcunit/node_modules/jquery/package.json',
            'main': 'dist/jquery.js',
            'globalBrowser': {},
            'browser': {},
            'resolutions': {}
        }
    ], { 'npmParentMap': {} }));
});
/*can-util@3.3.2#js/assign/assign*/
define('can-util@3.3.2#js/assign/assign', function (require, exports, module) {
    module.exports = function (d, s) {
        for (var prop in s) {
            d[prop] = s[prop];
        }
        return d;
    };
});
/*can-util@3.3.2#js/is-array/is-array*/
define('can-util@3.3.2#js/is-array/is-array', function (require, exports, module) {
    module.exports = function (arr) {
        return Array.isArray(arr);
    };
});
/*can-util@3.3.2#js/is-function/is-function*/
define('can-util@3.3.2#js/is-function/is-function', function (require, exports, module) {
    var isFunction = function () {
        if (typeof document !== 'undefined' && typeof document.getElementsByTagName('body') === 'function') {
            return function (value) {
                return Object.prototype.toString.call(value) === '[object Function]';
            };
        }
        return function (value) {
            return typeof value === 'function';
        };
    }();
    module.exports = isFunction;
});
/*can-util@3.3.2#js/is-plain-object/is-plain-object*/
define('can-util@3.3.2#js/is-plain-object/is-plain-object', function (require, exports, module) {
    var core_hasOwn = Object.prototype.hasOwnProperty;
    function isWindow(obj) {
        return obj !== null && obj == obj.window;
    }
    function isPlainObject(obj) {
        if (!obj || typeof obj !== 'object' || obj.nodeType || isWindow(obj)) {
            return false;
        }
        try {
            if (obj.constructor && !core_hasOwn.call(obj, 'constructor') && !core_hasOwn.call(obj.constructor.prototype, 'isPrototypeOf')) {
                return false;
            }
        } catch (e) {
            return false;
        }
        var key;
        for (key in obj) {
        }
        return key === undefined || core_hasOwn.call(obj, key);
    }
    module.exports = isPlainObject;
});
/*can-util@3.3.2#js/deep-assign/deep-assign*/
define('can-util@3.3.2#js/deep-assign/deep-assign', function (require, exports, module) {
    var isArray = require('../is-array/is-array');
    var isFunction = require('../is-function/is-function');
    var isPlainObject = require('../is-plain-object/is-plain-object');
    function deepAssign() {
        var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length;
        if (typeof target !== 'object' && !isFunction(target)) {
            target = {};
        }
        if (length === i) {
            target = this;
            --i;
        }
        for (; i < length; i++) {
            if ((options = arguments[i]) != null) {
                for (name in options) {
                    src = target[name];
                    copy = options[name];
                    if (target === copy) {
                        continue;
                    }
                    if (copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
                        if (copyIsArray) {
                            copyIsArray = false;
                            clone = src && isArray(src) ? src : [];
                        } else {
                            clone = src && isPlainObject(src) ? src : {};
                        }
                        target[name] = deepAssign(clone, copy);
                    } else if (copy !== undefined) {
                        target[name] = copy;
                    }
                }
            }
        }
        return target;
    }
    module.exports = deepAssign;
});
/*can-util@3.3.2#js/log/log*/
define('can-util@3.3.2#js/log/log', function (require, exports, module) {
    exports.warnTimeout = 5000;
    exports.logLevel = 0;
    exports.warn = function (out) {
        var ll = this.logLevel;
        if (ll < 2) {
            Array.prototype.unshift.call(arguments, 'WARN:');
            if (typeof console !== 'undefined' && console.warn) {
                this._logger('warn', Array.prototype.slice.call(arguments));
            } else if (typeof console !== 'undefined' && console.log) {
                this._logger('log', Array.prototype.slice.call(arguments));
            } else if (window && window.opera && window.opera.postError) {
                window.opera.postError('CanJS WARNING: ' + out);
            }
        }
    };
    exports.log = function (out) {
        var ll = this.logLevel;
        if (ll < 1) {
            if (typeof console !== 'undefined' && console.log) {
                Array.prototype.unshift.call(arguments, 'INFO:');
                this._logger('log', Array.prototype.slice.call(arguments));
            } else if (window && window.opera && window.opera.postError) {
                window.opera.postError('CanJS INFO: ' + out);
            }
        }
    };
    exports.error = function (out) {
        var ll = this.logLevel;
        if (ll < 1) {
            if (typeof console !== 'undefined' && console.error) {
                Array.prototype.unshift.call(arguments, 'ERROR:');
                this._logger('error', Array.prototype.slice.call(arguments));
            } else if (window && window.opera && window.opera.postError) {
                window.opera.postError('ERROR: ' + out);
            }
        }
    };
    exports._logger = function (type, arr) {
        try {
            console[type].apply(console, arr);
        } catch (e) {
            console[type](arr);
        }
    };
});
/*can-util@3.3.2#js/dev/dev*/
define('can-util@3.3.2#js/dev/dev', function (require, exports, module) {
    var canLog = require('../log/log');
    module.exports = {
        warnTimeout: 5000,
        logLevel: 0,
        warn: function () {
        },
        log: function () {
        },
        _logger: canLog._logger
    };
});
/*can-util@3.3.2#js/is-array-like/is-array-like*/
define('can-util@3.3.2#js/is-array-like/is-array-like', function (require, exports, module) {
    function isArrayLike(obj) {
        var type = typeof obj;
        if (type === 'string') {
            return true;
        }
        var length = obj && type !== 'boolean' && typeof obj !== 'number' && 'length' in obj && obj.length;
        return typeof obj !== 'function' && (length === 0 || typeof length === 'number' && length > 0 && length - 1 in obj);
    }
    module.exports = isArrayLike;
});
/*can-namespace@1.0.0#can-namespace*/
define('can-namespace@1.0.0#can-namespace', function (require, exports, module) {
    module.exports = {};
});
/*can-types@1.0.4#can-types*/
define('can-types@1.0.4#can-types', function (require, exports, module) {
    var namespace = require('can-namespace');
    var types = {
        isMapLike: function () {
            return false;
        },
        isListLike: function () {
            return false;
        },
        isPromise: function (obj) {
            return obj instanceof Promise || Object.prototype.toString.call(obj) === '[object Promise]';
        },
        isConstructor: function (func) {
            if (typeof func !== 'function') {
                return false;
            }
            for (var prop in func.prototype) {
                return true;
            }
            return false;
        },
        isCallableForValue: function (obj) {
            return typeof obj === 'function' && !types.isConstructor(obj);
        },
        isCompute: function (obj) {
            return obj && obj.isComputed;
        },
        iterator: typeof Symbol === 'function' && Symbol.iterator || '@@iterator',
        DefaultMap: null,
        DefaultList: null,
        queueTask: function (task) {
            var args = task[2] || [];
            task[0].apply(task[1], args);
        },
        wrapElement: function (element) {
            return element;
        },
        unwrapElement: function (element) {
            return element;
        }
    };
    if (namespace.types) {
        throw new Error('You can\'t have two versions of can-types, check your dependencies');
    } else {
        module.exports = namespace.types = types;
    }
});
/*can-util@3.3.2#js/is-iterable/is-iterable*/
define('can-util@3.3.2#js/is-iterable/is-iterable', function (require, exports, module) {
    var types = require('can-types');
    module.exports = function (obj) {
        return obj && !!obj[types.iterator];
    };
});
/*can-util@3.3.2#js/each/each*/
define('can-util@3.3.2#js/each/each', function (require, exports, module) {
    var isArrayLike = require('../is-array-like/is-array-like');
    var has = Object.prototype.hasOwnProperty;
    var isIterable = require('../is-iterable/is-iterable');
    var types = require('can-types');
    function each(elements, callback, context) {
        var i = 0, key, len, item;
        if (elements) {
            if (isArrayLike(elements)) {
                for (len = elements.length; i < len; i++) {
                    item = elements[i];
                    if (callback.call(context || item, item, i, elements) === false) {
                        break;
                    }
                }
            } else if (isIterable(elements)) {
                var iter = elements[types.iterator]();
                var res, value;
                while (!(res = iter.next()).done) {
                    value = res.value;
                    callback.call(context || elements, Array.isArray(value) ? value[1] : value, value[0]);
                }
            } else if (typeof elements === 'object') {
                for (key in elements) {
                    if (has.call(elements, key) && callback.call(context || elements[key], elements[key], key, elements) === false) {
                        break;
                    }
                }
            }
        }
        return elements;
    }
    module.exports = each;
});
/*can-util@3.3.2#js/make-array/make-array*/
define('can-util@3.3.2#js/make-array/make-array', function (require, exports, module) {
    var each = require('../each/each');
    function makeArray(arr) {
        var ret = [];
        each(arr, function (a, i) {
            ret[i] = a;
        });
        return ret;
    }
    module.exports = makeArray;
});
/*can-util@3.3.2#js/is-container/is-container*/
define('can-util@3.3.2#js/is-container/is-container', function (require, exports, module) {
    module.exports = function (current) {
        return /^f|^o/.test(typeof current);
    };
});
/*can-util@3.3.2#js/get/get*/
define('can-util@3.3.2#js/get/get', function (require, exports, module) {
    var isContainer = require('../is-container/is-container');
    function get(obj, name) {
        var parts = typeof name !== 'undefined' ? (name + '').replace(/\[/g, '.').replace(/]/g, '').split('.') : [], length = parts.length, current, i, container;
        if (!length) {
            return obj;
        }
        current = obj;
        for (i = 0; i < length && isContainer(current); i++) {
            container = current;
            current = container[parts[i]];
        }
        return current;
    }
    module.exports = get;
});
/*can-util@3.3.2#js/string/string*/
define('can-util@3.3.2#js/string/string', function (require, exports, module) {
    var get = require('../get/get');
    var isContainer = require('../is-container/is-container');
    var canDev = require('../dev/dev');
    var isArray = require('../is-array/is-array');
    var strUndHash = /_|-/, strColons = /\=\=/, strWords = /([A-Z]+)([A-Z][a-z])/g, strLowUp = /([a-z\d])([A-Z])/g, strDash = /([a-z\d])([A-Z])/g, strReplacer = /\{([^\}]+)\}/g, strQuote = /"/g, strSingleQuote = /'/g, strHyphenMatch = /-+(.)?/g, strCamelMatch = /[a-z][A-Z]/g, convertBadValues = function (content) {
            var isInvalid = content === null || content === undefined || isNaN(content) && '' + content === 'NaN';
            return '' + (isInvalid ? '' : content);
        }, deleteAtPath = function (data, path) {
            var parts = path ? path.replace(/\[/g, '.').replace(/]/g, '').split('.') : [];
            var current = data;
            for (var i = 0; i < parts.length - 1; i++) {
                if (current) {
                    current = current[parts[i]];
                }
            }
            if (current) {
                delete current[parts[parts.length - 1]];
            }
        };
    var string = {
        esc: function (content) {
            return convertBadValues(content).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(strQuote, '&#34;').replace(strSingleQuote, '&#39;');
        },
        getObject: function (name, roots) {
            roots = isArray(roots) ? roots : [roots || window];
            var result, l = roots.length;
            for (var i = 0; i < l; i++) {
                result = get(roots[i], name);
                if (result) {
                    return result;
                }
            }
        },
        capitalize: function (s, cache) {
            return s.charAt(0).toUpperCase() + s.slice(1);
        },
        camelize: function (str) {
            return convertBadValues(str).replace(strHyphenMatch, function (match, chr) {
                return chr ? chr.toUpperCase() : '';
            });
        },
        hyphenate: function (str) {
            return convertBadValues(str).replace(strCamelMatch, function (str, offset) {
                return str.charAt(0) + '-' + str.charAt(1).toLowerCase();
            });
        },
        underscore: function (s) {
            return s.replace(strColons, '/').replace(strWords, '$1_$2').replace(strLowUp, '$1_$2').replace(strDash, '_').toLowerCase();
        },
        sub: function (str, data, remove) {
            var obs = [];
            str = str || '';
            obs.push(str.replace(strReplacer, function (whole, inside) {
                var ob = get(data, inside);
                if (remove === true) {
                    deleteAtPath(data, inside);
                }
                if (ob === undefined || ob === null) {
                    obs = null;
                    return '';
                }
                if (isContainer(ob) && obs) {
                    obs.push(ob);
                    return '';
                }
                return '' + ob;
            }));
            return obs === null ? obs : obs.length <= 1 ? obs[0] : obs;
        },
        replacer: strReplacer,
        undHash: strUndHash
    };
    module.exports = string;
});
/*can-construct@3.1.1#can-construct*/
define('can-construct@3.1.1#can-construct', function (require, exports, module) {
    'use strict';
    var assign = require('can-util/js/assign/assign');
    var deepAssign = require('can-util/js/deep-assign/deep-assign');
    var dev = require('can-util/js/dev/dev');
    var makeArray = require('can-util/js/make-array/make-array');
    var types = require('can-types');
    var namespace = require('can-namespace');
    var initializing = 0;
    var Construct = function () {
        if (arguments.length) {
            return Construct.extend.apply(Construct, arguments);
        }
    };
    var canGetDescriptor;
    try {
        Object.getOwnPropertyDescriptor({});
        canGetDescriptor = true;
    } catch (e) {
        canGetDescriptor = false;
    }
    var getDescriptor = function (newProps, name) {
            var descriptor = Object.getOwnPropertyDescriptor(newProps, name);
            if (descriptor && (descriptor.get || descriptor.set)) {
                return descriptor;
            }
            return null;
        }, inheritGetterSetter = function (newProps, oldProps, addTo) {
            addTo = addTo || newProps;
            var descriptor;
            for (var name in newProps) {
                if (descriptor = getDescriptor(newProps, name)) {
                    this._defineProperty(addTo, oldProps, name, descriptor);
                } else {
                    Construct._overwrite(addTo, oldProps, name, newProps[name]);
                }
            }
        }, simpleInherit = function (newProps, oldProps, addTo) {
            addTo = addTo || newProps;
            for (var name in newProps) {
                Construct._overwrite(addTo, oldProps, name, newProps[name]);
            }
        };
    assign(Construct, {
        constructorExtends: true,
        newInstance: function () {
            var inst = this.instance(), args;
            if (inst.setup) {
                Object.defineProperty(inst, '__inSetup', {
                    configurable: true,
                    enumerable: false,
                    value: true,
                    writable: true
                });
                args = inst.setup.apply(inst, arguments);
                if (args instanceof Construct.ReturnValue) {
                    return args.value;
                }
                inst.__inSetup = false;
            }
            if (inst.init) {
                inst.init.apply(inst, args || arguments);
            }
            return inst;
        },
        _inherit: canGetDescriptor ? inheritGetterSetter : simpleInherit,
        _defineProperty: function (what, oldProps, propName, descriptor) {
            Object.defineProperty(what, propName, descriptor);
        },
        _overwrite: function (what, oldProps, propName, val) {
            Object.defineProperty(what, propName, {
                value: val,
                configurable: true,
                enumerable: true,
                writable: true
            });
        },
        setup: function (base) {
            this.defaults = deepAssign(true, {}, base.defaults, this.defaults);
        },
        instance: function () {
            initializing = 1;
            var inst = new this();
            initializing = 0;
            return inst;
        },
        extend: function (name, staticProperties, instanceProperties) {
            var shortName = name, klass = staticProperties, proto = instanceProperties;
            if (typeof shortName !== 'string') {
                proto = klass;
                klass = shortName;
                shortName = null;
            }
            if (!proto) {
                proto = klass;
                klass = null;
            }
            proto = proto || {};
            var _super_class = this, _super = this.prototype, Constructor, prototype;
            prototype = this.instance();
            Construct._inherit(proto, _super, prototype);
            if (shortName) {
            } else if (klass && klass.shortName) {
                shortName = klass.shortName;
            } else if (this.shortName) {
                shortName = this.shortName;
            }
            function init() {
                if (!initializing) {
                    return (!this || this.constructor !== Constructor) && arguments.length && Constructor.constructorExtends ? Constructor.extend.apply(Constructor, arguments) : Constructor.newInstance.apply(Constructor, arguments);
                }
            }
            Constructor = typeof namedCtor === 'function' ? namedCtor(constructorName, init) : function () {
                return init.apply(this, arguments);
            };
            for (var propName in _super_class) {
                if (_super_class.hasOwnProperty(propName)) {
                    Constructor[propName] = _super_class[propName];
                }
            }
            Construct._inherit(klass, _super_class, Constructor);
            assign(Constructor, {
                constructor: Constructor,
                prototype: prototype
            });
            if (shortName !== undefined) {
                Constructor.shortName = shortName;
            }
            Constructor.prototype.constructor = Constructor;
            var t = [_super_class].concat(makeArray(arguments)), args = Constructor.setup.apply(Constructor, t);
            if (Constructor.init) {
                Constructor.init.apply(Constructor, args || t);
            }
            return Constructor;
        },
        ReturnValue: function (value) {
            this.value = value;
        }
    });
    Construct.prototype.setup = function () {
    };
    Construct.prototype.init = function () {
    };
    var oldIsConstructor = types.isConstructor;
    types.isConstructor = function (obj) {
        return obj.prototype instanceof Construct || oldIsConstructor.call(null, obj);
    };
    module.exports = namespace.Construct = Construct;
});
/*can-util@3.3.2#js/is-empty-object/is-empty-object*/
define('can-util@3.3.2#js/is-empty-object/is-empty-object', function (require, exports, module) {
    module.exports = function (obj) {
        for (var prop in obj) {
            return false;
        }
        return true;
    };
});
/*can-util@3.3.2#dom/data/data*/
define('can-util@3.3.2#dom/data/data', function (require, exports, module) {
    var isEmptyObject = require('../../js/is-empty-object/is-empty-object');
    var data = {};
    var expando = 'can' + new Date();
    var uuid = 0;
    var setData = function (name, value) {
        var id = this[expando] || (this[expando] = ++uuid), store = data[id] || (data[id] = {});
        if (name !== undefined) {
            store[name] = value;
        }
        return store;
    };
    module.exports = {
        getCid: function () {
            return this[expando];
        },
        cid: function () {
            return this[expando] || (this[expando] = ++uuid);
        },
        expando: expando,
        clean: function (prop) {
            var id = this[expando];
            if (data[id] && data[id][prop]) {
                delete data[id][prop];
            }
            if (isEmptyObject(data[id])) {
                delete data[id];
            }
        },
        get: function (key) {
            var id = this[expando], store = id && data[id];
            return key === undefined ? store || setData(this) : store && store[key];
        },
        set: setData
    };
});
/*can-util@3.3.2#dom/class-name/class-name*/
define('can-util@3.3.2#dom/class-name/class-name', function (require, exports, module) {
    var has = function (className) {
        if (this.classList) {
            return this.classList.contains(className);
        } else {
            return !!this.className.match(new RegExp('(\\s|^)' + className + '(\\s|$)'));
        }
    };
    module.exports = {
        has: has,
        add: function (className) {
            if (this.classList) {
                this.classList.add(className);
            } else if (!has.call(this, className)) {
                this.className += ' ' + className;
            }
        },
        remove: function (className) {
            if (this.classList) {
                this.classList.remove(className);
            } else if (has.call(this, className)) {
                var reg = new RegExp('(\\s|^)' + className + '(\\s|$)');
                this.className = this.className.replace(reg, ' ');
            }
        }
    };
});
/*can-util@3.3.2#js/global/global*/
define('can-util@3.3.2#js/global/global', function (require, exports, module) {
    (function (global) {
        var GLOBAL;
        module.exports = function (setGlobal) {
            if (setGlobal !== undefined) {
                GLOBAL = setGlobal;
            }
            if (GLOBAL) {
                return GLOBAL;
            } else {
                return GLOBAL = typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope ? self : typeof process === 'object' && {}.toString.call(process) === '[object process]' ? global : window;
            }
        };
    }(function () {
        return this;
    }()));
});
/*can-util@3.3.2#dom/document/document*/
define('can-util@3.3.2#dom/document/document', function (require, exports, module) {
    (function (global) {
        var global = require('../../js/global/global');
        var setDocument;
        module.exports = function (setDoc) {
            if (setDoc) {
                setDocument = setDoc;
            }
            return setDocument || global().document;
        };
    }(function () {
        return this;
    }()));
});
/*can-util@3.3.2#dom/events/events*/
define('can-util@3.3.2#dom/events/events', function (require, exports, module) {
    var assign = require('../../js/assign/assign');
    var _document = require('../document/document');
    module.exports = {
        addEventListener: function () {
            this.addEventListener.apply(this, arguments);
        },
        removeEventListener: function () {
            this.removeEventListener.apply(this, arguments);
        },
        canAddEventListener: function () {
            return this.nodeName && (this.nodeType === 1 || this.nodeType === 9) || this === window;
        },
        dispatch: function (event, args, bubbles) {
            var doc = _document();
            var ev = doc.createEvent('HTMLEvents');
            var isString = typeof event === 'string';
            ev.initEvent(isString ? event : event.type, bubbles === undefined ? true : bubbles, false);
            if (!isString) {
                assign(ev, event);
            }
            ev.args = args;
            return this.dispatchEvent(ev);
        }
    };
});
/*can-cid@1.0.3#can-cid*/
define('can-cid@1.0.3#can-cid', function (require, exports, module) {
    var namespace = require('can-namespace');
    var _cid = 0;
    var cid = function (object, name) {
        if (!object._cid) {
            _cid++;
            object._cid = (name || '') + _cid;
        }
        return object._cid;
    };
    if (namespace.cid) {
        throw new Error('You can\'t have two versions of can-cid, check your dependencies');
    } else {
        module.exports = namespace.cid = cid;
    }
});
/*can-util@3.3.2#dom/dispatch/dispatch*/
define('can-util@3.3.2#dom/dispatch/dispatch', function (require, exports, module) {
    var domEvents = require('../events/events');
    module.exports = function () {
        return domEvents.dispatch.apply(this, arguments);
    };
});
/*can-util@3.3.2#dom/matches/matches*/
define('can-util@3.3.2#dom/matches/matches', function (require, exports, module) {
    var matchesMethod = function (element) {
        return element.matches || element.webkitMatchesSelector || element.webkitMatchesSelector || element.mozMatchesSelector || element.msMatchesSelector || element.oMatchesSelector;
    };
    module.exports = function () {
        var method = matchesMethod(this);
        return method ? method.apply(this, arguments) : false;
    };
});
/*can-util@3.3.2#dom/events/delegate/delegate*/
define('can-util@3.3.2#dom/events/delegate/delegate', function (require, exports, module) {
    var domEvents = require('../events');
    var domData = require('../../data/data');
    var domMatches = require('../../matches/matches');
    var each = require('../../../js/each/each');
    var isEmptyObject = require('../../../js/is-empty-object/is-empty-object');
    var dataName = 'delegateEvents';
    var useCapture = function (eventType) {
        return eventType === 'focus' || eventType === 'blur';
    };
    var handleEvent = function (ev) {
        var events = domData.get.call(this, dataName);
        var eventTypeEvents = events[ev.type];
        var matches = [];
        if (eventTypeEvents) {
            var selectorDelegates = [];
            each(eventTypeEvents, function (delegates) {
                selectorDelegates.push(delegates);
            });
            var cur = ev.target;
            do {
                selectorDelegates.forEach(function (delegates) {
                    if (domMatches.call(cur, delegates[0].selector)) {
                        matches.push({
                            target: cur,
                            delegates: delegates
                        });
                    }
                });
                cur = cur.parentNode;
            } while (cur && cur !== ev.currentTarget);
        }
        var oldStopProp = ev.stopPropagation;
        ev.stopPropagation = function () {
            oldStopProp.apply(this, arguments);
            this.cancelBubble = true;
        };
        for (var i = 0; i < matches.length; i++) {
            var match = matches[i];
            var delegates = match.delegates;
            for (var d = 0, dLen = delegates.length; d < dLen; d++) {
                if (delegates[d].handler.call(match.target, ev) === false) {
                    return false;
                }
                if (ev.cancelBubble) {
                    return;
                }
            }
        }
    };
    domEvents.addDelegateListener = function (eventType, selector, handler) {
        var events = domData.get.call(this, dataName), eventTypeEvents;
        if (!events) {
            domData.set.call(this, dataName, events = {});
        }
        if (!(eventTypeEvents = events[eventType])) {
            eventTypeEvents = events[eventType] = {};
            domEvents.addEventListener.call(this, eventType, handleEvent, useCapture(eventType));
        }
        if (!eventTypeEvents[selector]) {
            eventTypeEvents[selector] = [];
        }
        eventTypeEvents[selector].push({
            handler: handler,
            selector: selector
        });
    };
    domEvents.removeDelegateListener = function (eventType, selector, handler) {
        var events = domData.get.call(this, dataName);
        if (events[eventType] && events[eventType][selector]) {
            var eventTypeEvents = events[eventType], delegates = eventTypeEvents[selector], i = 0;
            while (i < delegates.length) {
                if (delegates[i].handler === handler) {
                    delegates.splice(i, 1);
                } else {
                    i++;
                }
            }
            if (delegates.length === 0) {
                delete eventTypeEvents[selector];
                if (isEmptyObject(eventTypeEvents)) {
                    domEvents.removeEventListener.call(this, eventType, handleEvent, useCapture(eventType));
                    delete events[eventType];
                    if (isEmptyObject(events)) {
                        domData.clean.call(this, dataName);
                    }
                }
            }
        }
    };
});
/*can-event@3.1.1#can-event*/
define('can-event@3.1.1#can-event', function (require, exports, module) {
    var domEvents = require('can-util/dom/events/events');
    var CID = require('can-cid');
    var isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');
    var domDispatch = require('can-util/dom/dispatch/dispatch');
    var namespace = require('can-namespace');
    require('can-util/dom/events/delegate/delegate');
    function makeHandlerArgs(event, args) {
        if (typeof event === 'string') {
            event = { type: event };
        }
        var handlerArgs = [event];
        if (args) {
            handlerArgs.push.apply(handlerArgs, args);
        }
        return handlerArgs;
    }
    function getHandlers(eventName) {
        var events = this.__bindEvents;
        if (!events) {
            return;
        }
        var handlers = events[eventName];
        if (!handlers) {
            return;
        } else {
            return handlers;
        }
    }
    var canEvent = {
        addEventListener: function (event, handler) {
            var allEvents = this.__bindEvents || (this.__bindEvents = {}), eventList = allEvents[event] || (allEvents[event] = []);
            eventList.push(handler);
            return this;
        },
        removeEventListener: function (event, fn) {
            if (!this.__bindEvents) {
                return this;
            }
            var handlers = this.__bindEvents[event] || [], i = 0, handler, isFunction = typeof fn === 'function';
            while (i < handlers.length) {
                handler = handlers[i];
                if (isFunction && handler === fn || !isFunction && (handler.cid === fn || !fn)) {
                    handlers.splice(i, 1);
                } else {
                    i++;
                }
            }
            return this;
        },
        dispatchSync: function (event, args) {
            var handlerArgs = makeHandlerArgs(event, args);
            var handlers = getHandlers.call(this, handlerArgs[0].type);
            if (!handlers) {
                return;
            }
            handlers = handlers.slice(0);
            for (var i = 0, len = handlers.length; i < len; i++) {
                handlers[i].apply(this, handlerArgs);
            }
            return handlerArgs[0];
        },
        on: function (eventName, selector, handler) {
            var method = typeof selector === 'string' ? 'addDelegateListener' : 'addEventListener';
            var listenWithDOM = domEvents.canAddEventListener.call(this);
            var eventBinder = listenWithDOM ? domEvents[method] : this[method] || canEvent[method];
            return eventBinder.apply(this, arguments);
        },
        off: function (eventName, selector, handler) {
            var method = typeof selector === 'string' ? 'removeDelegateListener' : 'removeEventListener';
            var listenWithDOM = domEvents.canAddEventListener.call(this);
            var eventBinder = listenWithDOM ? domEvents[method] : this[method] || canEvent[method];
            return eventBinder.apply(this, arguments);
        },
        trigger: function () {
            var listenWithDOM = domEvents.canAddEventListener.call(this);
            var dispatch = listenWithDOM ? domDispatch : canEvent.dispatch;
            return dispatch.apply(this, arguments);
        },
        one: function (event, handler) {
            var one = function () {
                canEvent.off.call(this, event, one);
                return handler.apply(this, arguments);
            };
            canEvent.on.call(this, event, one);
            return this;
        },
        listenTo: function (other, event, handler) {
            var idedEvents = this.__listenToEvents;
            if (!idedEvents) {
                idedEvents = this.__listenToEvents = {};
            }
            var otherId = CID(other);
            var othersEvents = idedEvents[otherId];
            if (!othersEvents) {
                othersEvents = idedEvents[otherId] = {
                    obj: other,
                    events: {}
                };
            }
            var eventsEvents = othersEvents.events[event];
            if (!eventsEvents) {
                eventsEvents = othersEvents.events[event] = [];
            }
            eventsEvents.push(handler);
            canEvent.on.call(other, event, handler);
        },
        stopListening: function (other, event, handler) {
            var idedEvents = this.__listenToEvents, iterIdedEvents = idedEvents, i = 0;
            if (!idedEvents) {
                return this;
            }
            if (other) {
                var othercid = CID(other);
                (iterIdedEvents = {})[othercid] = idedEvents[othercid];
                if (!idedEvents[othercid]) {
                    return this;
                }
            }
            for (var cid in iterIdedEvents) {
                var othersEvents = iterIdedEvents[cid], eventsEvents;
                other = idedEvents[cid].obj;
                if (!event) {
                    eventsEvents = othersEvents.events;
                } else {
                    (eventsEvents = {})[event] = othersEvents.events[event];
                }
                for (var eventName in eventsEvents) {
                    var handlers = eventsEvents[eventName] || [];
                    i = 0;
                    while (i < handlers.length) {
                        if (handler && handler === handlers[i] || !handler) {
                            canEvent.off.call(other, eventName, handlers[i]);
                            handlers.splice(i, 1);
                        } else {
                            i++;
                        }
                    }
                    if (!handlers.length) {
                        delete othersEvents.events[eventName];
                    }
                }
                if (isEmptyObject(othersEvents.events)) {
                    delete idedEvents[cid];
                }
            }
            return this;
        }
    };
    canEvent.addEvent = canEvent.bind = function () {
        return canEvent.addEventListener.apply(this, arguments);
    };
    canEvent.unbind = canEvent.removeEvent = function () {
        return canEvent.removeEventListener.apply(this, arguments);
    };
    canEvent.delegate = canEvent.on;
    canEvent.undelegate = canEvent.off;
    canEvent.dispatch = canEvent.dispatchSync;
    Object.defineProperty(canEvent, 'makeHandlerArgs', {
        enumerable: false,
        value: makeHandlerArgs
    });
    Object.defineProperty(canEvent, 'handlers', {
        enumerable: false,
        value: getHandlers
    });
    Object.defineProperty(canEvent, 'flush', {
        enumerable: false,
        writable: true,
        value: function () {
        }
    });
    module.exports = namespace.event = canEvent;
});
/*can-util@3.3.2#js/last/last*/
define('can-util@3.3.2#js/last/last', function (require, exports, module) {
    module.exports = function (arr) {
        return arr && arr[arr.length - 1];
    };
});
/*can-event@3.1.1#batch/batch*/
define('can-event@3.1.1#batch/batch', function (require, exports, module) {
    'use strict';
    var canEvent = require('../can-event');
    var last = require('can-util/js/last/last');
    var namespace = require('can-namespace');
    var canTypes = require('can-types');
    var canDev = require('can-util/js/dev/dev');
    var canLog = require('can-util/js/log/log');
    var batchNum = 1, collectionQueue = null, queues = [], dispatchingQueues = false, makeHandlerArgs = canEvent.makeHandlerArgs, getHandlers = canEvent.handlers;
    function addToCollectionQueue(item, event, args, handlers) {
        var handlerArgs = makeHandlerArgs(event, args);
        var tasks = [];
        for (var i = 0, len = handlers.length; i < len; i++) {
            tasks[i] = [
                handlers[i],
                item,
                handlerArgs
            ];
        }
        [].push.apply(collectionQueue.tasks, tasks);
    }
    var canBatch = {
        transactions: 0,
        start: function (batchStopHandler) {
            canBatch.transactions++;
            if (canBatch.transactions === 1) {
                var queue = {
                    number: batchNum++,
                    index: 0,
                    tasks: [],
                    batchEnded: false,
                    callbacksIndex: 0,
                    callbacks: [],
                    complete: false
                };
                if (batchStopHandler) {
                    queue.callbacks.push(batchStopHandler);
                }
                collectionQueue = queue;
            }
        },
        collecting: function () {
            return collectionQueue;
        },
        dispatching: function () {
            return queues[0];
        },
        stop: function (force, callStart) {
            if (force) {
                canBatch.transactions = 0;
            } else {
                canBatch.transactions--;
            }
            if (canBatch.transactions === 0) {
                queues.push(collectionQueue);
                collectionQueue = null;
                if (!dispatchingQueues) {
                    canEvent.flush();
                }
            }
        },
        flush: function () {
            dispatchingQueues = true;
            while (queues.length) {
                var queue = queues[0];
                var tasks = queue.tasks, callbacks = queue.callbacks;
                canBatch.batchNum = queue.number;
                var len = tasks.length, index;
                while (queue.index < len) {
                    index = queue.index++;
                    tasks[index][0].apply(tasks[index][1], tasks[index][2]);
                }
                if (!queue.batchEnded) {
                    queue.batchEnded = true;
                    canEvent.dispatchSync.call(canBatch, 'batchEnd', [queue.number]);
                }
                while (queue.callbacksIndex < callbacks.length) {
                    callbacks[queue.callbacksIndex++]();
                }
                if (!queue.complete) {
                    queue.complete = true;
                    canBatch.batchNum = undefined;
                    queues.shift();
                }
            }
            dispatchingQueues = false;
        },
        dispatch: function (event, args) {
            var item = this, handlers;
            if (!item.__inSetup) {
                event = typeof event === 'string' ? { type: event } : event;
                if (event.batchNum) {
                    canEvent.dispatchSync.call(item, event, args);
                } else if (collectionQueue) {
                    handlers = getHandlers.call(this, event.type);
                    if (handlers) {
                        event.batchNum = collectionQueue.number;
                        addToCollectionQueue(item, event, args, handlers);
                    }
                } else if (queues.length) {
                    handlers = getHandlers.call(this, event.type);
                    if (handlers) {
                        canBatch.start();
                        event.batchNum = collectionQueue.number;
                        addToCollectionQueue(item, event, args, handlers);
                        last(queues).callbacks.push(canBatch.stop);
                    }
                } else {
                    handlers = getHandlers.call(this, event.type);
                    if (handlers) {
                        canBatch.start();
                        event.batchNum = collectionQueue.number;
                        addToCollectionQueue(item, event, args, handlers);
                        canBatch.stop();
                    }
                }
            }
        },
        queue: function (task, inCurrentBatch) {
            if (collectionQueue) {
                collectionQueue.tasks.push(task);
            } else if (queues.length) {
                if (inCurrentBatch && queues[0].index < queues.tasks.length) {
                    queues[0].tasks.push(task);
                } else {
                    canBatch.start();
                    collectionQueue.tasks.push(task);
                    last(queues).callbacks.push(canBatch.stop);
                }
            } else {
                canBatch.start();
                collectionQueue.tasks.push(task);
                canBatch.stop();
            }
        },
        queues: function () {
            return queues;
        },
        afterPreviousEvents: function (handler) {
            this.queue([handler]);
        },
        after: function (handler) {
            var queue = collectionQueue || queues[0];
            if (queue) {
                queue.callbacks.push(handler);
            } else {
                handler({});
            }
        }
    };
    canEvent.flush = canBatch.flush;
    canEvent.dispatch = canBatch.dispatch;
    canBatch.trigger = function () {
        canLog.warn('use canEvent.dispatch instead');
        return canEvent.dispatch.apply(this, arguments);
    };
    canTypes.queueTask = canBatch.queue;
    module.exports = namespace.batch = canBatch;
});
/*can-observation@3.1.2#can-observation*/
define('can-observation@3.1.2#can-observation', function (require, exports, module) {
    require('can-event');
    var canEvent = require('can-event');
    var canBatch = require('can-event/batch/batch');
    var assign = require('can-util/js/assign/assign');
    var namespace = require('can-namespace');
    var canLog = require('can-util/js/log/log');
    function Observation(func, context, compute) {
        this.newObserved = {};
        this.oldObserved = null;
        this.func = func;
        this.context = context;
        this.compute = compute.updater ? compute : { updater: compute };
        this.onDependencyChange = this.onDependencyChange.bind(this);
        this.childDepths = {};
        this.ignore = 0;
        this.needsUpdate = false;
    }
    var observationStack = [];
    Observation.observationStack = observationStack;
    var remaining = {
        updates: 0,
        notifications: 0
    };
    Observation.remaining = remaining;
    assign(Observation.prototype, {
        get: function () {
            if (this.bound) {
                canEvent.flush();
                if (remaining.updates) {
                    Observation.updateChildrenAndSelf(this);
                }
                return this.value;
            } else {
                return this.func.call(this.context);
            }
        },
        getPrimaryDepth: function () {
            return this.compute._primaryDepth || 0;
        },
        addEdge: function (objEv) {
            objEv.obj.addEventListener(objEv.event, this.onDependencyChange);
            if (objEv.obj.observation) {
                this.depth = null;
            }
        },
        removeEdge: function (objEv) {
            objEv.obj.removeEventListener(objEv.event, this.onDependencyChange);
            if (objEv.obj.observation) {
                this.depth = null;
            }
        },
        dependencyChange: function (ev) {
            if (this.bound) {
                if (ev.batchNum !== this.batchNum) {
                    Observation.registerUpdate(this, ev.batchNum);
                    this.batchNum = ev.batchNum;
                }
            }
        },
        onDependencyChange: function (ev, newVal, oldVal) {
            this.dependencyChange(ev, newVal, oldVal);
        },
        update: function (batchNum) {
            if (this.needsUpdate) {
                remaining.updates--;
            }
            this.needsUpdate = false;
            if (this.bound) {
                var oldValue = this.value;
                this.oldValue = null;
                this.start();
                if (oldValue !== this.value) {
                    this.compute.updater(this.value, oldValue, batchNum);
                    return true;
                }
            }
        },
        getValueAndBind: function () {
            canLog.warn('can-observation: call start instead of getValueAndBind');
            return this.start();
        },
        start: function () {
            this.bound = true;
            this.oldObserved = this.newObserved || {};
            this.ignore = 0;
            this.newObserved = {};
            observationStack.push(this);
            this.value = this.func.call(this.context);
            observationStack.pop();
            this.updateBindings();
        },
        updateBindings: function () {
            var newObserved = this.newObserved, oldObserved = this.oldObserved, name, obEv;
            for (name in newObserved) {
                obEv = newObserved[name];
                if (!oldObserved[name]) {
                    this.addEdge(obEv);
                } else {
                    oldObserved[name] = null;
                }
            }
            for (name in oldObserved) {
                obEv = oldObserved[name];
                if (obEv) {
                    this.removeEdge(obEv);
                }
            }
        },
        teardown: function () {
            canLog.warn('can-observation: call stop instead of teardown');
            return this.stop();
        },
        stop: function () {
            this.bound = false;
            for (var name in this.newObserved) {
                var ob = this.newObserved[name];
                this.removeEdge(ob);
            }
            this.newObserved = {};
        }
    });
    var updateOrder = [], curPrimaryDepth = Infinity, maxPrimaryDepth = 0, currentBatchNum, isUpdating = false;
    var updateUpdateOrder = function (observation) {
        var primaryDepth = observation.getPrimaryDepth();
        if (primaryDepth < curPrimaryDepth) {
            curPrimaryDepth = primaryDepth;
        }
        if (primaryDepth > maxPrimaryDepth) {
            maxPrimaryDepth = primaryDepth;
        }
        var primary = updateOrder[primaryDepth] || (updateOrder[primaryDepth] = []);
        return primary;
    };
    Observation.registerUpdate = function (observation, batchNum) {
        if (observation.needsUpdate) {
            return;
        }
        remaining.updates++;
        observation.needsUpdate = true;
        var objs = updateUpdateOrder(observation);
        objs.push(observation);
    };
    var afterCallbacks = [];
    Observation.updateAndNotify = function (ev, batchNum) {
        currentBatchNum = batchNum;
        if (isUpdating) {
            return;
        }
        isUpdating = true;
        while (true) {
            if (curPrimaryDepth <= maxPrimaryDepth) {
                var primary = updateOrder[curPrimaryDepth];
                var lastUpdate = primary && primary.pop();
                if (lastUpdate) {
                    lastUpdate.update(currentBatchNum);
                } else {
                    curPrimaryDepth++;
                }
            } else {
                updateOrder = [];
                curPrimaryDepth = Infinity;
                maxPrimaryDepth = 0;
                isUpdating = false;
                var afterCB = afterCallbacks;
                afterCallbacks = [];
                afterCB.forEach(function (cb) {
                    cb();
                });
                return;
            }
        }
    };
    canEvent.addEventListener.call(canBatch, 'batchEnd', Observation.updateAndNotify);
    Observation.afterUpdateAndNotify = function (callback) {
        canBatch.after(function () {
            if (isUpdating) {
                afterCallbacks.push(callback);
            } else {
                callback();
            }
        });
    };
    Observation.updateChildrenAndSelf = function (observation) {
        if (observation.needsUpdate) {
            return Observation.unregisterAndUpdate(observation);
        }
        var childHasChanged;
        for (var prop in observation.newObserved) {
            if (observation.newObserved[prop].obj.observation) {
                if (Observation.updateChildrenAndSelf(observation.newObserved[prop].obj.observation)) {
                    childHasChanged = true;
                }
            }
        }
        if (childHasChanged) {
            return observation.update(currentBatchNum);
        }
    };
    Observation.unregisterAndUpdate = function (observation) {
        var primaryDepth = observation.getPrimaryDepth();
        var primary = updateOrder[primaryDepth];
        if (primary) {
            var index = primary.indexOf(observation);
            if (index !== -1) {
                primary.splice(index, 1);
            }
        }
        return observation.update(currentBatchNum);
    };
    Observation.add = function (obj, event) {
        var top = observationStack[observationStack.length - 1];
        if (top && !top.ignore) {
            var evStr = event + '', name = obj._cid + '|' + evStr;
            if (top.traps) {
                top.traps.push({
                    obj: obj,
                    event: evStr,
                    name: name
                });
            } else {
                top.newObserved[name] = {
                    obj: obj,
                    event: evStr
                };
            }
        }
    };
    Observation.addAll = function (observes) {
        var top = observationStack[observationStack.length - 1];
        if (top) {
            if (top.traps) {
                top.traps.push.apply(top.traps, observes);
            } else {
                for (var i = 0, len = observes.length; i < len; i++) {
                    var trap = observes[i], name = trap.name;
                    if (!top.newObserved[name]) {
                        top.newObserved[name] = trap;
                    }
                }
            }
        }
    };
    Observation.ignore = function (fn) {
        return function () {
            if (observationStack.length) {
                var top = observationStack[observationStack.length - 1];
                top.ignore++;
                var res = fn.apply(this, arguments);
                top.ignore--;
                return res;
            } else {
                return fn.apply(this, arguments);
            }
        };
    };
    Observation.trap = function () {
        if (observationStack.length) {
            var top = observationStack[observationStack.length - 1];
            var oldTraps = top.traps;
            var traps = top.traps = [];
            return function () {
                top.traps = oldTraps;
                return traps;
            };
        } else {
            return function () {
                return [];
            };
        }
    };
    Observation.trapsCount = function () {
        if (observationStack.length) {
            var top = observationStack[observationStack.length - 1];
            return top.traps.length;
        } else {
            return 0;
        }
    };
    Observation.isRecording = function () {
        var len = observationStack.length;
        var last = len && observationStack[len - 1];
        return last && last.ignore === 0 && last;
    };
    if (namespace.Observation) {
        throw new Error('You can\'t have two versions of can-observation, check your dependencies');
    } else {
        module.exports = namespace.Observation = Observation;
    }
});
/*can-event@3.1.1#lifecycle/lifecycle*/
define('can-event@3.1.1#lifecycle/lifecycle', function (require, exports, module) {
    var canEvent = require('can-event');
    var lifecycle = function (prototype) {
        var baseAddEventListener = prototype.addEventListener;
        var baseRemoveEventListener = prototype.removeEventListener;
        prototype.addEventListener = function () {
            var ret = baseAddEventListener.apply(this, arguments);
            if (!this.__inSetup) {
                if (!this._bindings) {
                    this._bindings = 1;
                    if (this._eventSetup) {
                        this._eventSetup();
                    }
                } else {
                    this._bindings++;
                }
            }
            return ret;
        };
        prototype.removeEventListener = function (event, handler) {
            if (!this.__bindEvents) {
                return this;
            }
            var handlers = this.__bindEvents[event] || [];
            var handlerCount = handlers.length;
            var ret = baseRemoveEventListener.apply(this, arguments);
            if (this._bindings === null) {
                this._bindings = 0;
            } else {
                this._bindings = this._bindings - (handlerCount - handlers.length);
            }
            if (!this._bindings && this._eventTeardown) {
                this._eventTeardown();
            }
            return ret;
        };
        return prototype;
    };
    var baseEvents = lifecycle({
        addEventListener: canEvent.addEventListener,
        removeEventListener: canEvent.removeEventListener
    });
    lifecycle.addAndSetup = baseEvents.addEventListener;
    lifecycle.removeAndTeardown = baseEvents.removeEventListener;
    module.exports = lifecycle;
});
/*can-observation@3.1.2#reader/reader*/
define('can-observation@3.1.2#reader/reader', function (require, exports, module) {
    var Observation = require('can-observation');
    var assign = require('can-util/js/assign/assign');
    var CID = require('can-cid');
    var types = require('can-types');
    var dev = require('can-util/js/dev/dev');
    var canEvent = require('can-event');
    var each = require('can-util/js/each/each');
    var observeReader;
    var isAt = function (index, reads) {
        var prevRead = reads[index - 1];
        return prevRead && prevRead.at;
    };
    var readValue = function (value, index, reads, options, state, prev) {
        var usedValueReader;
        do {
            usedValueReader = false;
            for (var i = 0, len = observeReader.valueReaders.length; i < len; i++) {
                if (observeReader.valueReaders[i].test(value, index, reads, options)) {
                    value = observeReader.valueReaders[i].read(value, index, reads, options, state, prev);
                }
            }
        } while (usedValueReader);
        return value;
    };
    var specialRead = {
        index: true,
        key: true,
        event: true,
        element: true,
        viewModel: true
    };
    var checkForObservableAndNotify = function (options, state, getObserves, value, index) {
        if (options.foundObservable && !state.foundObservable) {
            if (Observation.trapsCount()) {
                Observation.addAll(getObserves());
                options.foundObservable(value, index);
                state.foundObservable = true;
            }
        }
    };
    observeReader = {
        read: function (parent, reads, options) {
            options = options || {};
            var state = { foundObservable: false };
            var getObserves;
            if (options.foundObservable) {
                getObserves = Observation.trap();
            }
            var cur = readValue(parent, 0, reads, options, state), type, prev, readLength = reads.length, i = 0, last;
            checkForObservableAndNotify(options, state, getObserves, parent, 0);
            while (i < readLength) {
                prev = cur;
                for (var r = 0, readersLength = observeReader.propertyReaders.length; r < readersLength; r++) {
                    var reader = observeReader.propertyReaders[r];
                    if (reader.test(cur)) {
                        cur = reader.read(cur, reads[i], i, options, state);
                        break;
                    }
                }
                checkForObservableAndNotify(options, state, getObserves, prev, i);
                last = cur;
                i = i + 1;
                cur = readValue(cur, i, reads, options, state, prev);
                checkForObservableAndNotify(options, state, getObserves, prev, i - 1);
                type = typeof cur;
                if (i < reads.length && (cur === null || type !== 'function' && type !== 'object')) {
                    if (options.earlyExit) {
                        options.earlyExit(prev, i - 1, cur);
                    }
                    return {
                        value: undefined,
                        parent: prev
                    };
                }
            }
            if (cur === undefined) {
                if (options.earlyExit) {
                    options.earlyExit(prev, i - 1);
                }
            }
            return {
                value: cur,
                parent: prev
            };
        },
        get: function (parent, reads, options) {
            return observeReader.read(parent, observeReader.reads(reads), options || {}).value;
        },
        valueReadersMap: {},
        valueReaders: [
            {
                name: 'function',
                test: function (value, i, reads, options) {
                    return types.isCallableForValue(value) && !types.isCompute(value);
                },
                read: function (value, i, reads, options, state, prev) {
                    if (isAt(i, reads)) {
                        return i === reads.length ? value.bind(prev) : value;
                    } else if (options.callMethodsOnObservables && types.isMapLike(prev)) {
                        return value.apply(prev, options.args || []);
                    } else if (options.isArgument && i === reads.length) {
                        return options.proxyMethods !== false ? value.bind(prev) : value;
                    }
                    return value.apply(prev, options.args || []);
                }
            },
            {
                name: 'compute',
                test: function (value, i, reads, options) {
                    return types.isCompute(value) && !isAt(i, reads);
                },
                read: function (value, i, reads, options, state) {
                    if (options.readCompute === false && i === reads.length) {
                        return value;
                    }
                    return value.get ? value.get() : value();
                },
                write: function (base, newVal) {
                    if (base.set) {
                        base.set(newVal);
                    } else {
                        base(newVal);
                    }
                }
            }
        ],
        propertyReadersMap: {},
        propertyReaders: [
            {
                name: 'map',
                test: function () {
                    return types.isMapLike.apply(this, arguments) || types.isListLike.apply(this, arguments);
                },
                read: function (value, prop, index, options, state) {
                    var res = value.get ? value.get(prop.key) : value.attr(prop.key);
                    if (res !== undefined) {
                        return res;
                    } else {
                        return value[prop.key];
                    }
                },
                write: function (base, prop, newVal) {
                    if (typeof base.set === 'function') {
                        base.set(prop, newVal);
                    } else {
                        base.attr(prop, newVal);
                    }
                }
            },
            {
                name: 'promise',
                test: function (value) {
                    return types.isPromise(value);
                },
                read: function (value, prop, index, options, state) {
                    var observeData = value.__observeData;
                    if (!value.__observeData) {
                        observeData = value.__observeData = {
                            isPending: true,
                            state: 'pending',
                            isResolved: false,
                            isRejected: false,
                            value: undefined,
                            reason: undefined
                        };
                        CID(observeData);
                        assign(observeData, canEvent);
                        value.then(function (value) {
                            observeData.isPending = false;
                            observeData.isResolved = true;
                            observeData.value = value;
                            observeData.state = 'resolved';
                            observeData.dispatch('state', [
                                'resolved',
                                'pending'
                            ]);
                        }, function (reason) {
                            observeData.isPending = false;
                            observeData.isRejected = true;
                            observeData.reason = reason;
                            observeData.state = 'rejected';
                            observeData.dispatch('state', [
                                'rejected',
                                'pending'
                            ]);
                        });
                    }
                    Observation.add(observeData, 'state');
                    return prop.key in observeData ? observeData[prop.key] : value[prop.key];
                }
            },
            {
                name: 'object',
                test: function () {
                    return true;
                },
                read: function (value, prop) {
                    if (value == null) {
                        return undefined;
                    } else {
                        if (typeof value === 'object') {
                            if (prop.key in value) {
                                return value[prop.key];
                            } else if (prop.at && specialRead[prop.key] && '@' + prop.key in value) {
                                return value['@' + prop.key];
                            }
                        } else {
                            return value[prop.key];
                        }
                    }
                },
                write: function (base, prop, newVal) {
                    base[prop] = newVal;
                }
            }
        ],
        reads: function (key) {
            var keys = [];
            var last = 0;
            var at = false;
            if (key.charAt(0) === '@') {
                last = 1;
                at = true;
            }
            var keyToAdd = '';
            for (var i = last; i < key.length; i++) {
                var character = key.charAt(i);
                if (character === '.' || character === '@') {
                    if (key.charAt(i - 1) !== '\\') {
                        keys.push({
                            key: keyToAdd,
                            at: at
                        });
                        at = character === '@';
                        keyToAdd = '';
                    } else {
                        keyToAdd = keyToAdd.substr(0, keyToAdd.length - 1) + '.';
                    }
                } else {
                    keyToAdd += character;
                }
            }
            keys.push({
                key: keyToAdd,
                at: at
            });
            return keys;
        },
        write: function (parent, key, value, options) {
            var keys = typeof key === 'string' ? observeReader.reads(key) : key;
            var last;
            if (keys.length > 1) {
                last = keys.pop();
                parent = observeReader.read(parent, keys, options).value;
                keys.push(last);
            } else {
                last = keys[0];
            }
            if (observeReader.valueReadersMap.compute.test(parent[last.key], keys.length - 1, keys, options)) {
                observeReader.valueReadersMap.compute.write(parent[last.key], value, options);
            } else {
                if (observeReader.valueReadersMap.compute.test(parent, keys.length - 1, keys, options)) {
                    parent = parent();
                }
                if (observeReader.propertyReadersMap.map.test(parent)) {
                    observeReader.propertyReadersMap.map.write(parent, last.key, value, options);
                } else if (observeReader.propertyReadersMap.object.test(parent)) {
                    observeReader.propertyReadersMap.object.write(parent, last.key, value, options);
                }
            }
        }
    };
    each(observeReader.propertyReaders, function (reader) {
        observeReader.propertyReadersMap[reader.name] = reader;
    });
    each(observeReader.valueReaders, function (reader) {
        observeReader.valueReadersMap[reader.name] = reader;
    });
    observeReader.set = observeReader.write;
    module.exports = observeReader;
});
/*can-compute@3.0.7#proto-compute*/
define('can-compute@3.0.7#proto-compute', function (require, exports, module) {
    var Observation = require('can-observation');
    var canEvent = require('can-event');
    var eventLifecycle = require('can-event/lifecycle/lifecycle');
    require('can-event/batch/batch');
    var observeReader = require('can-observation/reader/reader');
    var getObject = require('can-util/js/get/get');
    var CID = require('can-cid');
    var assign = require('can-util/js/assign/assign');
    var types = require('can-types');
    var isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');
    var canLog = require('can-util/js/log/log');
    var Compute = function (getterSetter, context, eventName, bindOnce) {
        CID(this, 'compute');
        var args = [];
        for (var i = 0, arglen = arguments.length; i < arglen; i++) {
            args[i] = arguments[i];
        }
        var contextType = typeof args[1];
        if (typeof args[0] === 'function') {
            this._setupGetterSetterFn(args[0], args[1], args[2], args[3]);
        } else if (args[1] !== undefined) {
            if (contextType === 'string' || contextType === 'number') {
                var isListLike = types.isListLike(args[0]);
                if (types.isMapLike(args[0]) || isListLike) {
                    var map = args[0];
                    var propertyName = args[1];
                    var mapGetterSetter = function (newValue) {
                        if (arguments.length) {
                            observeReader.set(map, propertyName, newValue);
                        } else {
                            if (isListLike) {
                                observeReader.get(map, 'length');
                            }
                            return observeReader.get(map, '' + propertyName);
                        }
                    };
                    this._setupGetterSetterFn(mapGetterSetter, args[1], args[2], args[3]);
                } else {
                    this._setupProperty(args[0], args[1], args[2]);
                }
            } else if (contextType === 'function') {
                this._setupSetter(args[0], args[1], args[2]);
            } else {
                if (args[1] && args[1].fn) {
                    this._setupAsyncCompute(args[0], args[1]);
                } else {
                    this._setupSettings(args[0], args[1]);
                }
            }
        } else {
            this._setupSimpleValue(args[0]);
        }
        this._args = args;
        this._primaryDepth = 0;
        this.isComputed = true;
    };
    var updateOnChange = function (compute, newValue, oldValue, batchNum) {
        var valueChanged = newValue !== oldValue && !(newValue !== newValue && oldValue !== oldValue);
        if (valueChanged) {
            canEvent.dispatch.call(compute, {
                type: 'change',
                batchNum: batchNum
            }, [
                newValue,
                oldValue
            ]);
        }
    };
    var setupComputeHandlers = function (compute, func, context) {
        var observation = new Observation(func, context, compute);
        compute.observation = observation;
        return {
            _on: function () {
                observation.start();
                compute.value = observation.value;
                compute.hasDependencies = !isEmptyObject(observation.newObserved);
            },
            _off: function () {
                observation.stop();
            },
            getDepth: function () {
                return observation.getDepth();
            }
        };
    };
    assign(Compute.prototype, {
        setPrimaryDepth: function (depth) {
            this._primaryDepth = depth;
        },
        _setupGetterSetterFn: function (getterSetter, context, eventName) {
            this._set = context ? getterSetter.bind(context) : getterSetter;
            this._get = context ? getterSetter.bind(context) : getterSetter;
            this._canObserve = eventName === false ? false : true;
            var handlers = setupComputeHandlers(this, getterSetter, context || this);
            assign(this, handlers);
        },
        _setupProperty: function (target, propertyName, eventName) {
            var self = this, handler;
            handler = function () {
                self.updater(self._get(), self.value);
            };
            this._get = function () {
                return getObject(target, propertyName);
            };
            this._set = function (value) {
                var properties = propertyName.split('.'), leafPropertyName = properties.pop(), targetProperty = getObject(target, properties.join('.'));
                targetProperty[leafPropertyName] = value;
            };
            this._on = function (update) {
                canEvent.on.call(target, eventName || propertyName, handler);
                this.value = this._get();
            };
            this._off = function () {
                return canEvent.off.call(target, eventName || propertyName, handler);
            };
        },
        _setupSetter: function (initialValue, setter, eventName) {
            this.value = initialValue;
            this._set = setter;
            assign(this, eventName);
        },
        _setupSettings: function (initialValue, settings) {
            this.value = initialValue;
            this._set = settings.set || this._set;
            this._get = settings.get || this._get;
            if (!settings.__selfUpdater) {
                var self = this, oldUpdater = this.updater;
                this.updater = function () {
                    oldUpdater.call(self, self._get(), self.value);
                };
            }
            this._on = settings.on ? settings.on : this._on;
            this._off = settings.off ? settings.off : this._off;
        },
        _setupAsyncCompute: function (initialValue, settings) {
            var self = this;
            var getter = settings.fn;
            var bindings;
            this.value = initialValue;
            this._setUpdates = true;
            this.lastSetValue = new Compute(initialValue);
            this._set = function (newVal) {
                if (newVal === self.lastSetValue.get()) {
                    return this.value;
                }
                return self.lastSetValue.set(newVal);
            };
            this._get = function () {
                return getter.call(settings.context, self.lastSetValue.get());
            };
            if (getter.length === 0) {
                bindings = setupComputeHandlers(this, getter, settings.context);
            } else if (getter.length === 1) {
                bindings = setupComputeHandlers(this, function () {
                    return getter.call(settings.context, self.lastSetValue.get());
                }, settings);
            } else {
                var oldUpdater = this.updater, resolve = Observation.ignore(function (newVal) {
                        oldUpdater.call(self, newVal, self.value);
                    });
                this.updater = function (newVal) {
                    oldUpdater.call(self, newVal, self.value);
                };
                bindings = setupComputeHandlers(this, function () {
                    var res = getter.call(settings.context, self.lastSetValue.get(), resolve);
                    return res !== undefined ? res : this.value;
                }, this);
            }
            assign(this, bindings);
        },
        _setupSimpleValue: function (initialValue) {
            this.value = initialValue;
        },
        _eventSetup: Observation.ignore(function () {
            this.bound = true;
            this._on(this.updater);
        }),
        _eventTeardown: function () {
            this._off(this.updater);
            this.bound = false;
        },
        addEventListener: eventLifecycle.addAndSetup,
        removeEventListener: eventLifecycle.removeAndTeardown,
        clone: function (context) {
            if (context && typeof this._args[0] === 'function') {
                this._args[1] = context;
            } else if (context) {
                this._args[2] = context;
            }
            return new Compute(this._args[0], this._args[1], this._args[2], this._args[3]);
        },
        _on: function () {
        },
        _off: function () {
        },
        get: function () {
            var recordingObservation = Observation.isRecording();
            if (recordingObservation && this._canObserve !== false) {
                Observation.add(this, 'change');
                if (!this.bound) {
                    Compute.temporarilyBind(this);
                }
            }
            if (this.bound) {
                if (this.observation) {
                    return this.observation.get();
                } else {
                    return this.value;
                }
            } else {
                return this._get();
            }
        },
        _get: function () {
            return this.value;
        },
        set: function (newVal) {
            var old = this.value;
            var setVal = this._set(newVal, old);
            if (this._setUpdates) {
                return this.value;
            }
            if (this.hasDependencies) {
                return this._get();
            }
            this.updater(setVal === undefined ? this._get() : setVal, old);
            return this.value;
        },
        _set: function (newVal) {
            return this.value = newVal;
        },
        updater: function (newVal, oldVal, batchNum) {
            this.value = newVal;
            if (this.observation) {
                this.observation.value = newVal;
            }
            updateOnChange(this, newVal, oldVal, batchNum);
        },
        toFunction: function () {
            return this._computeFn.bind(this);
        },
        _computeFn: function (newVal) {
            if (arguments.length) {
                return this.set(newVal);
            }
            return this.get();
        }
    });
    Compute.prototype.on = Compute.prototype.bind = Compute.prototype.addEventListener;
    Compute.prototype.off = Compute.prototype.unbind = Compute.prototype.removeEventListener;
    var k = function () {
    };
    var computes;
    var unbindComputes = function () {
        for (var i = 0, len = computes.length; i < len; i++) {
            computes[i].removeEventListener('change', k);
        }
        computes = null;
    };
    Compute.temporarilyBind = function (compute) {
        var computeInstance = compute.computeInstance || compute;
        computeInstance.addEventListener('change', k);
        if (!computes) {
            computes = [];
            setTimeout(unbindComputes, 10);
        }
        computes.push(computeInstance);
    };
    Compute.async = function (initialValue, asyncComputer, context) {
        return new Compute(initialValue, {
            fn: asyncComputer,
            context: context
        });
    };
    Compute.truthy = function (compute) {
        return new Compute(function () {
            var res = compute.get();
            if (typeof res === 'function') {
                res = res.get();
            }
            return !!res;
        });
    };
    module.exports = exports = Compute;
});
/*can-compute@3.0.7#can-compute*/
define('can-compute@3.0.7#can-compute', function (require, exports, module) {
    require('can-event');
    require('can-event/batch/batch');
    var Compute = require('./proto-compute');
    var CID = require('can-cid');
    var namespace = require('can-namespace');
    var addEventListener = function (ev, handler) {
        var compute = this;
        var computeHandler = handler && handler[compute.handlerKey];
        if (handler && !computeHandler) {
            computeHandler = handler[compute.handlerKey] = function () {
                handler.apply(compute, arguments);
            };
        }
        return compute.computeInstance.addEventListener(ev, computeHandler);
    };
    var removeEventListener = function (ev, handler) {
        var compute = this;
        var computeHandler = handler && handler[compute.handlerKey];
        if (computeHandler) {
            delete handler[compute.handlerKey];
            return compute.computeInstance.removeEventListener(ev, computeHandler);
        }
        return compute.computeInstance.removeEventListener.apply(compute.computeInstance, arguments);
    };
    var COMPUTE = function (getterSetter, context, eventName, bindOnce) {
        function compute(val) {
            if (arguments.length) {
                return compute.computeInstance.set(val);
            }
            return compute.computeInstance.get();
        }
        var cid = CID(compute, 'compute');
        compute.computeInstance = new Compute(getterSetter, context, eventName, bindOnce);
        compute.handlerKey = '__handler' + cid;
        compute.on = compute.bind = compute.addEventListener = addEventListener;
        compute.off = compute.unbind = compute.removeEventListener = removeEventListener;
        compute.isComputed = compute.computeInstance.isComputed;
        compute.clone = function (ctx) {
            if (typeof getterSetter === 'function') {
                context = ctx;
            }
            return COMPUTE(getterSetter, context, ctx, bindOnce);
        };
        return compute;
    };
    COMPUTE.truthy = function (compute) {
        return COMPUTE(function () {
            var res = compute();
            if (typeof res === 'function') {
                res = res();
            }
            return !!res;
        });
    };
    COMPUTE.async = function (initialValue, asyncComputer, context) {
        return COMPUTE(initialValue, {
            fn: asyncComputer,
            context: context
        });
    };
    COMPUTE.temporarilyBind = Compute.temporarilyBind;
    module.exports = namespace.compute = COMPUTE;
});
/*can-control@3.0.7#can-control*/
define('can-control@3.0.7#can-control', function (require, exports, module) {
    var Construct = require('can-construct');
    var namespace = require('can-namespace');
    var string = require('can-util/js/string/string');
    var assign = require('can-util/js/assign/assign');
    var isFunction = require('can-util/js/is-function/is-function');
    var each = require('can-util/js/each/each');
    var dev = require('can-util/js/dev/dev');
    var types = require('can-types');
    var get = require('can-util/js/get/get');
    var domData = require('can-util/dom/data/data');
    var className = require('can-util/dom/class-name/class-name');
    var domEvents = require('can-util/dom/events/events');
    var canEvent = require('can-event');
    var canCompute = require('can-compute');
    var observeReader = require('can-observation/reader/reader');
    var processors;
    require('can-util/dom/dispatch/dispatch');
    require('can-util/dom/events/delegate/delegate');
    var bind = function (el, ev, callback) {
            canEvent.on.call(el, ev, callback);
            return function () {
                canEvent.off.call(el, ev, callback);
            };
        }, slice = [].slice, paramReplacer = /\{([^\}]+)\}/g, delegate = function (el, selector, ev, callback) {
            canEvent.on.call(el, ev, selector, callback);
            return function () {
                canEvent.off.call(el, ev, selector, callback);
            };
        }, binder = function (el, ev, callback, selector) {
            return selector ? delegate(el, selector.trim(), ev, callback) : bind(el, ev, callback);
        }, basicProcessor;
    var Control = Construct.extend({
        setup: function () {
            Construct.setup.apply(this, arguments);
            if (Control) {
                var control = this, funcName;
                control.actions = {};
                for (funcName in control.prototype) {
                    if (control._isAction(funcName)) {
                        control.actions[funcName] = control._action(funcName);
                    }
                }
            }
        },
        _shifter: function (context, name) {
            var method = typeof name === 'string' ? context[name] : name;
            if (!isFunction(method)) {
                method = context[method];
            }
            return function () {
                var wrapped = types.wrapElement(this);
                context.called = name;
                return method.apply(context, [wrapped].concat(slice.call(arguments, 0)));
            };
        },
        _isAction: function (methodName) {
            var val = this.prototype[methodName], type = typeof val;
            return methodName !== 'constructor' && (type === 'function' || type === 'string' && isFunction(this.prototype[val])) && !!(Control.isSpecial(methodName) || processors[methodName] || /[^\w]/.test(methodName));
        },
        _action: function (methodName, options, controlInstance) {
            var readyCompute;
            paramReplacer.lastIndex = 0;
            if (options || !paramReplacer.test(methodName)) {
                readyCompute = canCompute(function () {
                    var delegate;
                    var name = methodName.replace(paramReplacer, function (matched, key) {
                        var value, parent;
                        if (this._isDelegate(options, key)) {
                            delegate = this._getDelegate(options, key);
                            return '';
                        }
                        key = this._removeDelegateFromKey(key);
                        parent = this._lookup(options)[0];
                        value = observeReader.read(parent, observeReader.reads(key), { readCompute: false }).value;
                        if (value === undefined && typeof window !== 'undefined') {
                            value = get(window, key);
                        }
                        if (!parent || !types.isMapLike(parent) && !value) {
                            return null;
                        }
                        if (typeof value === 'string') {
                            return value;
                        } else {
                            delegate = value;
                            return '';
                        }
                    }.bind(this));
                    name = name.trim();
                    var parts = name.split(/\s+/g), event = parts.pop();
                    return {
                        processor: this.processors[event] || basicProcessor,
                        parts: [
                            name,
                            parts.join(' '),
                            event
                        ],
                        delegate: delegate || undefined
                    };
                }, this);
                if (controlInstance) {
                    var handler = function (ev, ready) {
                        controlInstance._bindings.control[methodName](controlInstance.element);
                        controlInstance._bindings.control[methodName] = ready.processor(ready.delegate || controlInstance.element, ready.parts[2], ready.parts[1], methodName, controlInstance);
                    };
                    readyCompute.bind('change', handler);
                    controlInstance._bindings.readyComputes[methodName] = {
                        compute: readyCompute,
                        handler: handler
                    };
                }
                return readyCompute();
            }
        },
        _lookup: function (options) {
            return [
                options,
                window
            ];
        },
        _removeDelegateFromKey: function (key) {
            return key;
        },
        _isDelegate: function (options, key) {
            return key === 'element';
        },
        _getDelegate: function (options, key) {
            return undefined;
        },
        processors: {},
        defaults: {},
        convertElement: function (element) {
            element = typeof element === 'string' ? document.querySelector(element) : element;
            return types.wrapElement(element);
        },
        isSpecial: function (eventName) {
            return eventName === 'inserted' || eventName === 'removed';
        }
    }, {
        setup: function (element, options) {
            var cls = this.constructor, pluginname = cls.pluginName || cls.shortName, arr;
            this.element = cls.convertElement(element);
            if (pluginname && pluginname !== 'can_control') {
                className.add.call(element, pluginname);
            }
            arr = domData.get.call(this.element, 'controls');
            if (!arr) {
                arr = [];
                domData.set.call(this.element, 'controls', arr);
            }
            arr.push(this);
            if (types.isMapLike(options)) {
                for (var prop in cls.defaults) {
                    if (!options.hasOwnProperty(prop)) {
                        observeReader.set(options, prop, cls.defaults[prop]);
                    }
                }
                this.options = options;
            } else {
                this.options = assign(assign({}, cls.defaults), options);
            }
            this.on();
            return [
                this.element,
                this.options
            ];
        },
        on: function (el, selector, eventName, func) {
            if (!el) {
                this.off();
                var cls = this.constructor, bindings = this._bindings, actions = cls.actions, element = types.unwrapElement(this.element), destroyCB = Control._shifter(this, 'destroy'), funcName, ready;
                for (funcName in actions) {
                    if (actions.hasOwnProperty(funcName)) {
                        ready = actions[funcName] || cls._action(funcName, this.options, this);
                        if (ready) {
                            bindings.control[funcName] = ready.processor(ready.delegate || element, ready.parts[2], ready.parts[1], funcName, this);
                        }
                    }
                }
                domEvents.addEventListener.call(element, 'removed', destroyCB);
                bindings.user.push(function (el) {
                    domEvents.removeEventListener.call(el, 'removed', destroyCB);
                });
                return bindings.user.length;
            }
            if (typeof el === 'string') {
                func = eventName;
                eventName = selector;
                selector = el;
                el = this.element;
            }
            if (func === undefined) {
                func = eventName;
                eventName = selector;
                selector = null;
            }
            if (typeof func === 'string') {
                func = Control._shifter(this, func);
            }
            this._bindings.user.push(binder(el, eventName, func, selector));
            return this._bindings.user.length;
        },
        off: function () {
            var el = types.unwrapElement(this.element), bindings = this._bindings;
            if (bindings) {
                each(bindings.user || [], function (value) {
                    value(el);
                });
                each(bindings.control || {}, function (value) {
                    value(el);
                });
                each(bindings.readyComputes || {}, function (value) {
                    value.compute.unbind('change', value.handler);
                });
            }
            this._bindings = {
                user: [],
                control: {},
                readyComputes: {}
            };
        },
        destroy: function () {
            if (this.element === null) {
                return;
            }
            var Class = this.constructor, pluginName = Class.pluginName || Class.shortName && string.underscore(Class.shortName), controls;
            this.off();
            if (pluginName && pluginName !== 'can_control') {
                className.remove.call(this.element, pluginName);
            }
            controls = domData.get.call(this.element, 'controls');
            controls.splice(controls.indexOf(this), 1);
            canEvent.dispatch.call(this, 'destroyed');
            this.element = null;
        }
    });
    processors = Control.processors;
    basicProcessor = function (el, event, selector, methodName, control) {
        return binder(el, event, Control._shifter(control, methodName), selector);
    };
    each([
        'change',
        'click',
        'contextmenu',
        'dblclick',
        'keydown',
        'keyup',
        'keypress',
        'mousedown',
        'mousemove',
        'mouseout',
        'mouseover',
        'mouseup',
        'reset',
        'resize',
        'scroll',
        'select',
        'submit',
        'focusin',
        'focusout',
        'mouseenter',
        'mouseleave',
        'touchstart',
        'touchmove',
        'touchcancel',
        'touchend',
        'touchleave',
        'inserted',
        'removed',
        'dragstart',
        'dragenter',
        'dragover',
        'dragleave',
        'drag',
        'drop',
        'dragend'
    ], function (v) {
        processors[v] = basicProcessor;
    });
    module.exports = namespace.Control = Control;
});
/*can-component@3.0.6#control/control*/
define('can-component@3.0.6#control/control', function (require, exports, module) {
    var Control = require('can-control');
    var canEach = require('can-util/js/each/each');
    var string = require('can-util/js/string/string');
    var canCompute = require('can-compute');
    var observeReader = require('can-observation/reader/reader');
    var paramReplacer = /\{([^\}]+)\}/g;
    var ComponentControl = Control.extend({
        _lookup: function (options) {
            return [
                options.scope,
                options,
                window
            ];
        },
        _removeDelegateFromKey: function (key) {
            return key.replace(/^(scope|^viewModel)\./, '');
        },
        _isDelegate: function (options, key) {
            return key === 'scope' || key === 'viewModel';
        },
        _getDelegate: function (options, key) {
            return options[key];
        },
        _action: function (methodName, options, controlInstance) {
            var hasObjectLookup;
            paramReplacer.lastIndex = 0;
            hasObjectLookup = paramReplacer.test(methodName);
            if (!controlInstance && hasObjectLookup) {
                return;
            } else {
                return Control._action.apply(this, arguments);
            }
        }
    }, {
        setup: function (el, options) {
            this.scope = options.scope;
            this.viewModel = options.viewModel;
            return Control.prototype.setup.call(this, el, options);
        },
        off: function () {
            if (this._bindings) {
                canEach(this._bindings.readyComputes || {}, function (value) {
                    value.compute.unbind('change', value.handler);
                });
            }
            Control.prototype.off.apply(this, arguments);
            this._bindings.readyComputes = {};
        },
        destroy: function () {
            Control.prototype.destroy.apply(this, arguments);
            if (typeof this.options.destroy === 'function') {
                this.options.destroy.apply(this, arguments);
            }
        }
    });
    module.exports = ComponentControl;
});
/*can-simple-map@3.1.3#can-simple-map*/
define('can-simple-map@3.1.3#can-simple-map', function (require, exports, module) {
    var Construct = require('can-construct');
    var canEvent = require('can-event');
    var assign = require('can-util/js/assign/assign');
    var each = require('can-util/js/each/each');
    var types = require('can-types');
    var Observation = require('can-observation');
    var SimpleMap = Construct.extend({
        setup: function (initialData) {
            this._data = {};
            this.attr(initialData);
        },
        attr: function (prop, value) {
            var self = this;
            if (arguments.length === 0) {
                return assign({}, this._data);
            } else if (arguments.length > 1) {
                var old = this._data[prop];
                this._data[prop] = value;
                canEvent.dispatch.call(this, prop, [
                    value,
                    old
                ]);
            } else if (typeof prop === 'object') {
                Object.keys(prop).forEach(function (key) {
                    self.attr(key, prop[key]);
                });
            } else {
                if (prop !== 'constructor') {
                    Observation.add(this, prop);
                    return this._data[prop];
                }
                return this.constructor;
            }
        },
        serialize: function () {
            var serialized = {};
            each(this._data, function (data, prop) {
                serialized[prop] = data && typeof data.serialize === 'function' ? data.serialize() : data;
            });
            return serialized;
        },
        get: function () {
            return this.attr.apply(this, arguments);
        },
        set: function () {
            return this.attr.apply(this, arguments);
        }
    });
    assign(SimpleMap.prototype, canEvent);
    var oldIsMapLike = types.isMapLike;
    types.isMapLike = function (obj) {
        if (obj instanceof SimpleMap) {
            return true;
        }
        return oldIsMapLike.call(this, obj);
    };
    if (!types.DefaultMap) {
        types.DefaultMap = SimpleMap;
    }
    module.exports = SimpleMap;
});
/*can-view-scope@3.1.4#reference-map*/
define('can-view-scope@3.1.4#reference-map', function (require, exports, module) {
    var types = require('can-types');
    var SimpleMap = require('can-simple-map');
    var ReferenceMap = SimpleMap.extend({});
    var oldIsMapLike = types.isMapLike;
    types.isMapLike = function (obj) {
        if (obj instanceof ReferenceMap) {
            return true;
        }
        return oldIsMapLike.call(this, obj);
    };
    module.exports = ReferenceMap;
});
/*can-view-scope@3.1.4#compute_data*/
define('can-view-scope@3.1.4#compute_data', function (require, exports, module) {
    var Observation = require('can-observation');
    var observeReader = require('can-observation/reader/reader');
    var makeCompute = require('can-compute');
    var types = require('can-types');
    var isFunction = require('can-util/js/is-function/is-function');
    var isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');
    var isFastPath = function (computeData) {
        if (computeData.reads && computeData.reads.length === 1) {
            var root = computeData.root;
            if (types.isCompute(root)) {
                root = root();
            }
            return types.isMapLike(root) && !isFunction(root[computeData.reads[0].key]);
        }
        return;
    };
    var scopeReader = function (scope, key, options, computeData, newVal) {
        if (arguments.length > 4) {
            var root = computeData.root || computeData.setRoot;
            if (root) {
                observeReader.write(root, computeData.reads, newVal, options);
            } else {
                scope.set(key, newVal, options);
            }
        } else {
            if (computeData.root) {
                return observeReader.read(computeData.root, computeData.reads, options).value;
            }
            var data = scope.read(key, options);
            computeData.scope = data.scope;
            computeData.initialValue = data.value;
            computeData.reads = data.reads;
            computeData.root = data.rootObserve;
            computeData.setRoot = data.setRoot;
            return data.value;
        }
    };
    module.exports = function (scope, key, options) {
        options = options || { args: [] };
        var computeData = {}, scopeRead = function (newVal) {
                if (arguments.length) {
                    return scopeReader(scope, key, options, computeData, newVal);
                } else {
                    return scopeReader(scope, key, options, computeData);
                }
            }, compute = makeCompute(undefined, {
                on: function () {
                    observation.start();
                    if (isFastPath(computeData)) {
                        observation.dependencyChange = function (ev, newVal) {
                            if (types.isMapLike(ev.target) && typeof newVal !== 'function') {
                                this.newVal = newVal;
                            } else {
                                observation.dependencyChange = Observation.prototype.dependencyChange;
                                observation.start = Observation.prototype.start;
                                compute.fastPath = false;
                            }
                            return Observation.prototype.dependencyChange.call(this, ev);
                        };
                        observation.start = function () {
                            this.value = this.newVal;
                        };
                        compute.fastPath = true;
                    }
                    compute.computeInstance.value = observation.value;
                    compute.computeInstance.hasDependencies = !isEmptyObject(observation.newObserved);
                },
                off: function () {
                    observation.stop();
                },
                set: scopeRead,
                get: scopeRead,
                __selfUpdater: true
            }), observation = new Observation(scopeRead, null, compute.computeInstance);
        compute.computeInstance.observation = observation;
        computeData.compute = compute;
        return computeData;
    };
});
/*can-view-scope@3.1.4#can-view-scope*/
define('can-view-scope@3.1.4#can-view-scope', function (require, exports, module) {
    var observeReader = require('can-observation/reader/reader');
    var Observation = require('can-observation');
    var ReferenceMap = require('./reference-map');
    var makeComputeData = require('./compute_data');
    var assign = require('can-util/js/assign/assign');
    var each = require('can-util/js/each/each');
    var namespace = require('can-namespace');
    var dev = require('can-util/js/dev/dev');
    function Scope(context, parent, meta) {
        this._context = context;
        this._parent = parent;
        this._meta = meta || {};
        this.__cache = {};
    }
    assign(Scope, {
        read: observeReader.read,
        Refs: ReferenceMap,
        refsScope: function () {
            return new Scope(new this.Refs());
        }
    });
    assign(Scope.prototype, {
        add: function (context, meta) {
            if (context !== this._context) {
                return new this.constructor(context, this, meta);
            } else {
                return this;
            }
        },
        read: function (attr, options) {
            if (attr === '%root') {
                return { value: this.getRoot() };
            }
            if (attr === '%scope') {
                return { value: this };
            }
            var isDotSlash = attr.substr(0, 2) === './', isThisDot = attr.substr(0, 5) === 'this.', isInCurrentContext = isDotSlash || isThisDot, isInParentContext = attr.substr(0, 3) === '../', isCurrentContext = attr === '.' || attr === 'this', isParentContext = attr === '..', isContextBased = isInCurrentContext || isInParentContext || isCurrentContext || isParentContext;
            if (isContextBased && this._meta.notContext) {
                return this._parent.read(attr, options);
            }
            var currentScopeOnly;
            if (isInCurrentContext) {
                currentScopeOnly = true;
                attr = isDotSlash ? attr.substr(2) : attr.substr(5);
            } else if (isInParentContext || isParentContext) {
                var parent = this._parent;
                while (parent._meta.notContext) {
                    parent = parent._parent;
                }
                if (isParentContext) {
                    return { value: parent._context };
                }
                return parent.read(attr.substr(3) || '.', options);
            } else if (isCurrentContext) {
                return { value: this._context };
            }
            var keyReads = observeReader.reads(attr);
            if (keyReads[0].key.charAt(0) === '*') {
                return this.getRefs()._read(keyReads, options, true);
            } else {
                return this._read(keyReads, options, currentScopeOnly);
            }
        },
        _read: function (keyReads, options, currentScopeOnly) {
            var currentScope = this, currentContext, undefinedObserves = [], currentObserve, currentReads, setObserveDepth = -1, currentSetReads, currentSetObserve, readOptions = assign({
                    foundObservable: function (observe, nameIndex) {
                        currentObserve = observe;
                        currentReads = keyReads.slice(nameIndex);
                    },
                    earlyExit: function (parentValue, nameIndex) {
                        if (nameIndex > setObserveDepth || nameIndex === setObserveDepth && (typeof parentValue === 'object' && keyReads[nameIndex].key in parentValue)) {
                            currentSetObserve = currentObserve;
                            currentSetReads = currentReads;
                            setObserveDepth = nameIndex;
                        }
                    }
                }, options);
            while (currentScope) {
                currentContext = currentScope._context;
                if (currentContext !== null && (typeof currentContext === 'object' || typeof currentContext === 'function')) {
                    var getObserves = Observation.trap();
                    var data = observeReader.read(currentContext, keyReads, readOptions);
                    var observes = getObserves();
                    if (data.value !== undefined) {
                        Observation.addAll(observes);
                        return {
                            scope: currentScope,
                            rootObserve: currentObserve,
                            value: data.value,
                            reads: currentReads
                        };
                    } else {
                        undefinedObserves.push.apply(undefinedObserves, observes);
                    }
                }
                if (currentScopeOnly) {
                    currentScope = null;
                } else {
                    currentScope = currentScope._parent;
                }
            }
            Observation.addAll(undefinedObserves);
            return {
                setRoot: currentSetObserve,
                reads: currentSetReads,
                value: undefined
            };
        },
        get: function (key, options) {
            options = assign({ isArgument: true }, options);
            var res = this.read(key, options);
            return res.value;
        },
        peek: Observation.ignore(function (key, options) {
            return this.get(key, options);
        }),
        peak: Observation.ignore(function (key, options) {
            return this.peek(key, options);
        }),
        getScope: function (tester) {
            var scope = this;
            while (scope) {
                if (tester(scope)) {
                    return scope;
                }
                scope = scope._parent;
            }
        },
        getContext: function (tester) {
            var res = this.getScope(tester);
            return res && res._context;
        },
        getRefs: function () {
            return this.getScope(function (scope) {
                return scope._context instanceof Scope.Refs;
            });
        },
        getRoot: function () {
            var cur = this, child = this;
            while (cur._parent) {
                child = cur;
                cur = cur._parent;
            }
            if (cur._context instanceof Scope.Refs) {
                cur = child;
            }
            return cur._context;
        },
        set: function (key, value, options) {
            var dotIndex = key.lastIndexOf('.'), slashIndex = key.lastIndexOf('/'), contextPath, propName;
            if (slashIndex > dotIndex) {
                contextPath = key.substring(0, slashIndex);
                propName = key.substring(slashIndex + 1, key.length);
            } else {
                if (dotIndex !== -1) {
                    contextPath = key.substring(0, dotIndex);
                    propName = key.substring(dotIndex + 1, key.length);
                } else {
                    contextPath = '.';
                    propName = key;
                }
            }
            if (key.charAt(0) === '*') {
                observeReader.write(this.getRefs()._context, key, value, options);
            } else {
                var context = this.read(contextPath, options).value;
                observeReader.write(context, propName, value, options);
            }
        },
        attr: Observation.ignore(function (key, value, options) {
            console.warn('can-view-scope::attr is deprecated, please use peek, get or set');
            options = assign({ isArgument: true }, options);
            if (arguments.length === 2) {
                return this.set(key, value, options);
            } else {
                return this.get(key, options);
            }
        }),
        computeData: function (key, options) {
            return makeComputeData(this, key, options);
        },
        compute: function (key, options) {
            return this.computeData(key, options).compute;
        },
        cloneFromRef: function () {
            var contexts = [];
            var scope = this, context, parent;
            while (scope) {
                context = scope._context;
                if (context instanceof Scope.Refs) {
                    parent = scope._parent;
                    break;
                }
                contexts.unshift(context);
                scope = scope._parent;
            }
            if (parent) {
                each(contexts, function (context) {
                    parent = parent.add(context);
                });
                return parent;
            } else {
                return this;
            }
        }
    });
    function Options(data, parent, meta) {
        if (!data.helpers && !data.partials && !data.tags) {
            data = { helpers: data };
        }
        Scope.call(this, data, parent, meta);
    }
    Options.prototype = new Scope();
    Options.prototype.constructor = Options;
    Scope.Options = Options;
    namespace.view = namespace.view || {};
    module.exports = namespace.view.Scope = Scope;
});
/*can-stache@3.0.20#src/utils*/
define('can-stache@3.0.20#src/utils', function (require, exports, module) {
    var Scope = require('can-view-scope');
    var Observation = require('can-observation');
    var observationReader = require('can-observation/reader/reader');
    var compute = require('can-compute');
    var types = require('can-types');
    var isArrayLike = require('can-util/js/is-array-like/is-array-like');
    var Options = Scope.Options;
    module.exports = {
        isArrayLike: isArrayLike,
        emptyHandler: function () {
        },
        jsonParse: function (str) {
            if (str[0] === '\'') {
                return str.substr(1, str.length - 2);
            } else if (str === 'undefined') {
                return undefined;
            } else {
                return JSON.parse(str);
            }
        },
        mixins: {
            last: function () {
                return this.stack[this.stack.length - 1];
            },
            add: function (chars) {
                this.last().add(chars);
            },
            subSectionDepth: function () {
                return this.stack.length - 1;
            }
        },
        convertToScopes: function (helperOptions, scope, options, nodeList, truthyRenderer, falseyRenderer, isStringOnly) {
            if (truthyRenderer) {
                helperOptions.fn = this.makeRendererConvertScopes(truthyRenderer, scope, options, nodeList, isStringOnly);
            }
            if (falseyRenderer) {
                helperOptions.inverse = this.makeRendererConvertScopes(falseyRenderer, scope, options, nodeList, isStringOnly);
            }
        },
        makeRendererConvertScopes: function (renderer, parentScope, parentOptions, nodeList, observeObservables) {
            var rendererWithScope = function (ctx, opts, parentNodeList) {
                return renderer(ctx || parentScope, opts, parentNodeList);
            };
            var convertedRenderer = function (newScope, newOptions, parentNodeList) {
                if (newScope !== undefined && !(newScope instanceof Scope)) {
                    newScope = parentScope.add(newScope);
                }
                if (newOptions !== undefined && !(newOptions instanceof Options)) {
                    newOptions = parentOptions.add(newOptions);
                }
                var result = rendererWithScope(newScope, newOptions || parentOptions, parentNodeList || nodeList);
                return result;
            };
            return observeObservables ? convertedRenderer : Observation.ignore(convertedRenderer);
        },
        getItemsStringContent: function (items, isObserveList, helperOptions, options) {
            var txt = '', len = observationReader.get(items, 'length'), isObservable = types.isMapLike(items) || types.isListLike(items);
            for (var i = 0; i < len; i++) {
                var item = isObservable ? compute(items, '' + i) : items[i];
                txt += helperOptions.fn(item, options);
            }
            return txt;
        },
        getItemsFragContent: function (items, helperOptions, scope, asVariable) {
            var result = [], len = observationReader.get(items, 'length'), isObservable = types.isMapLike(items) || types.isListLike(items);
            for (var i = 0; i < len; i++) {
                var aliases = {
                    '%index': i,
                    '@index': i
                };
                var item = isObservable ? compute(items, '' + i) : items[i];
                if (asVariable) {
                    aliases[asVariable] = item;
                }
                result.push(helperOptions.fn(scope.add(aliases, { notContext: true }).add(item)));
            }
            return result;
        },
        Options: Options
    };
});
/*can-view-parser@3.0.6#can-view-parser*/
define('can-view-parser@3.0.6#can-view-parser', function (require, exports, module) {
    var namespace = require('can-namespace'), dev = require('can-util/js/dev/dev');
    function each(items, callback) {
        for (var i = 0; i < items.length; i++) {
            callback(items[i], i);
        }
    }
    function makeMap(str) {
        var obj = {}, items = str.split(',');
        each(items, function (name) {
            obj[name] = true;
        });
        return obj;
    }
    function handleIntermediate(intermediate, handler) {
        for (var i = 0, len = intermediate.length; i < len; i++) {
            var item = intermediate[i];
            handler[item.tokenType].apply(handler, item.args);
        }
        return intermediate;
    }
    var alphaNumeric = 'A-Za-z0-9', alphaNumericHU = '-:_' + alphaNumeric, camelCase = /([a-z])([A-Z])/g, defaultMagicStart = '{{', endTag = new RegExp('^<\\/([' + alphaNumericHU + ']+)[^>]*>'), defaultMagicMatch = new RegExp('\\{\\{([^\\}]*)\\}\\}\\}?', 'g'), space = /\s/, alphaRegex = new RegExp('[' + alphaNumeric + ']');
    var empty = makeMap('area,base,basefont,br,col,frame,hr,img,input,isindex,link,meta,param,embed');
    var caseMattersAttributes = makeMap('allowReorder,attributeName,attributeType,autoReverse,baseFrequency,baseProfile,calcMode,clipPathUnits,contentScriptType,contentStyleType,diffuseConstant,edgeMode,externalResourcesRequired,filterRes,filterUnits,glyphRef,gradientTransform,gradientUnits,kernelMatrix,kernelUnitLength,keyPoints,keySplines,keyTimes,lengthAdjust,limitingConeAngle,markerHeight,markerUnits,markerWidth,maskContentUnits,maskUnits,patternContentUnits,patternTransform,patternUnits,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,repeatCount,repeatDur,requiredExtensions,requiredFeatures,specularConstant,specularExponent,spreadMethod,startOffset,stdDeviation,stitchTiles,surfaceScale,systemLanguage,tableValues,textLength,viewBox,viewTarget,xChannelSelector,yChannelSelector');
    var caseMattersElements = makeMap('altGlyph,altGlyphDef,altGlyphItem,animateColor,animateMotion,animateTransform,clipPath,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,foreignObject,glyphRef,linearGradient,radialGradient,textPath');
    var closeSelf = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr');
    var special = makeMap('script');
    var tokenTypes = 'start,end,close,attrStart,attrEnd,attrValue,chars,comment,special,done'.split(',');
    var fn = function () {
    };
    var HTMLParser = function (html, handler, returnIntermediate) {
        if (typeof html === 'object') {
            return handleIntermediate(html, handler);
        }
        var intermediate = [];
        handler = handler || {};
        if (returnIntermediate) {
            each(tokenTypes, function (name) {
                var callback = handler[name] || fn;
                handler[name] = function () {
                    if (callback.apply(this, arguments) !== false) {
                        intermediate.push({
                            tokenType: name,
                            args: [].slice.call(arguments, 0)
                        });
                    }
                };
            });
        }
        var magicMatch = handler.magicMatch || defaultMagicMatch, magicStart = handler.magicStart || defaultMagicStart;
        function parseStartTag(tag, tagName, rest, unary) {
            tagName = caseMattersElements[tagName] ? tagName : tagName.toLowerCase();
            if (closeSelf[tagName] && stack.last() === tagName) {
                parseEndTag('', tagName);
            }
            unary = empty[tagName] || !!unary;
            handler.start(tagName, unary);
            if (!unary) {
                stack.push(tagName);
            }
            HTMLParser.parseAttrs(rest, handler);
            handler.end(tagName, unary);
        }
        function parseEndTag(tag, tagName) {
            var pos;
            if (!tagName) {
                pos = 0;
            } else {
                tagName = caseMattersElements[tagName] ? tagName : tagName.toLowerCase();
                for (pos = stack.length - 1; pos >= 0; pos--) {
                    if (stack[pos] === tagName) {
                        break;
                    }
                }
            }
            if (pos >= 0) {
                for (var i = stack.length - 1; i >= pos; i--) {
                    if (handler.close) {
                        handler.close(stack[i]);
                    }
                }
                stack.length = pos;
            }
        }
        function parseMustache(mustache, inside) {
            if (handler.special) {
                handler.special(inside);
            }
        }
        var callChars = function () {
            if (charsText) {
                if (handler.chars) {
                    handler.chars(charsText);
                }
            }
            charsText = '';
        };
        var index, chars, match, stack = [], last = html, charsText = '';
        stack.last = function () {
            return this[this.length - 1];
        };
        while (html) {
            chars = true;
            if (!stack.last() || !special[stack.last()]) {
                if (html.indexOf('<!--') === 0) {
                    index = html.indexOf('-->');
                    if (index >= 0) {
                        callChars();
                        if (handler.comment) {
                            handler.comment(html.substring(4, index));
                        }
                        html = html.substring(index + 3);
                        chars = false;
                    }
                } else if (html.indexOf('</') === 0) {
                    match = html.match(endTag);
                    if (match) {
                        callChars();
                        html = html.substring(match[0].length);
                        match[0].replace(endTag, parseEndTag);
                        chars = false;
                    }
                } else if (html.indexOf('<') === 0) {
                    var res = HTMLParser.searchStartTag(html);
                    if (res) {
                        callChars();
                        html = res.html;
                        parseStartTag.apply(null, res.match);
                        chars = false;
                    }
                } else if (html.indexOf(magicStart) === 0) {
                    match = html.match(magicMatch);
                    if (match) {
                        callChars();
                        html = html.substring(match[0].length);
                        match[0].replace(magicMatch, parseMustache);
                    }
                }
                if (chars) {
                    index = findBreak(html, magicStart);
                    if (index === 0 && html === last) {
                        charsText += html.charAt(0);
                        html = html.substr(1);
                        index = findBreak(html, magicStart);
                    }
                    var text = index < 0 ? html : html.substring(0, index);
                    html = index < 0 ? '' : html.substring(index);
                    if (text) {
                        charsText += text;
                    }
                }
            } else {
                html = html.replace(new RegExp('([\\s\\S]*?)</' + stack.last() + '[^>]*>'), function (all, text) {
                    text = text.replace(/<!--([\s\S]*?)-->|<!\[CDATA\[([\s\S]*?)]]>/g, '$1$2');
                    if (handler.chars) {
                        handler.chars(text);
                    }
                    return '';
                });
                parseEndTag('', stack.last());
            }
            if (html === last) {
                throw new Error('Parse Error: ' + html);
            }
            last = html;
        }
        callChars();
        parseEndTag();
        handler.done();
        return intermediate;
    };
    var callAttrStart = function (state, curIndex, handler, rest) {
        var attrName = rest.substring(typeof state.nameStart === 'number' ? state.nameStart : curIndex, curIndex), newAttrName = attrName, oldAttrName = attrName;
        if (!caseMattersAttributes[attrName] && camelCase.test(attrName)) {
            newAttrName = attrName.replace(camelCase, camelCaseToSpinalCase);
        }
        state.attrStart = newAttrName;
        handler.attrStart(state.attrStart);
        state.inName = false;
    };
    var callAttrEnd = function (state, curIndex, handler, rest) {
        if (state.valueStart !== undefined && state.valueStart < curIndex) {
            handler.attrValue(rest.substring(state.valueStart, curIndex));
        } else if (!state.inValue) {
        }
        handler.attrEnd(state.attrStart);
        state.attrStart = undefined;
        state.valueStart = undefined;
        state.inValue = false;
        state.inName = false;
        state.lookingForEq = false;
        state.inQuote = false;
        state.lookingForName = true;
    };
    var findBreak = function (str, magicStart) {
        var magicLength = magicStart.length;
        for (var i = 0, len = str.length; i < len; i++) {
            if (str[i] === '<' || str.substr(i, magicLength) === magicStart) {
                return i;
            }
        }
        return -1;
    };
    var camelCaseToSpinalCase = function (match, lowerCaseChar, upperCaseChar) {
        return lowerCaseChar + '-' + upperCaseChar.toLowerCase();
    };
    HTMLParser.parseAttrs = function (rest, handler) {
        if (!rest) {
            return;
        }
        var magicMatch = handler.magicMatch || defaultMagicMatch, magicStart = handler.magicStart || defaultMagicStart;
        var i = 0;
        var curIndex;
        var state = {
            inName: false,
            nameStart: undefined,
            inValue: false,
            valueStart: undefined,
            inQuote: false,
            attrStart: undefined,
            lookingForName: true,
            lookingForValue: false,
            lookingForEq: false
        };
        while (i < rest.length) {
            curIndex = i;
            var cur = rest.charAt(i);
            i++;
            if (magicStart === rest.substr(curIndex, magicStart.length)) {
                if (state.inValue && curIndex > state.valueStart) {
                    handler.attrValue(rest.substring(state.valueStart, curIndex));
                } else if (state.inName && state.nameStart < curIndex) {
                    callAttrStart(state, curIndex, handler, rest);
                    callAttrEnd(state, curIndex, handler, rest);
                } else if (state.lookingForValue) {
                    state.inValue = true;
                } else if (state.lookingForEq && state.attrStart) {
                    callAttrEnd(state, curIndex, handler, rest);
                }
                magicMatch.lastIndex = curIndex;
                var match = magicMatch.exec(rest);
                if (match) {
                    handler.special(match[1]);
                    i = curIndex + match[0].length;
                    if (state.inValue) {
                        state.valueStart = curIndex + match[0].length;
                    }
                }
            } else if (state.inValue) {
                if (state.inQuote) {
                    if (cur === state.inQuote) {
                        callAttrEnd(state, curIndex, handler, rest);
                    }
                } else if (space.test(cur)) {
                    callAttrEnd(state, curIndex, handler, rest);
                }
            } else if (cur === '=' && (state.lookingForEq || state.lookingForName || state.inName)) {
                if (!state.attrStart) {
                    callAttrStart(state, curIndex, handler, rest);
                    if (i === rest.length) {
                        callAttrEnd(state, curIndex, handler, rest);
                    }
                }
                state.lookingForValue = true;
                state.lookingForEq = false;
                state.lookingForName = false;
            } else if (state.inName) {
                if (space.test(cur)) {
                    callAttrStart(state, curIndex, handler, rest);
                    state.lookingForEq = true;
                }
            } else if (state.lookingForName) {
                if (!space.test(cur)) {
                    if (state.attrStart) {
                        callAttrEnd(state, curIndex, handler, rest);
                    }
                    state.nameStart = curIndex;
                    state.inName = true;
                }
            } else if (state.lookingForValue) {
                if (!space.test(cur)) {
                    state.lookingForValue = false;
                    state.inValue = true;
                    if (cur === '\'' || cur === '"') {
                        state.inQuote = cur;
                        state.valueStart = curIndex + 1;
                    } else {
                        state.valueStart = curIndex;
                    }
                } else if (i === rest.length) {
                    callAttrEnd(state, curIndex, handler, rest);
                }
            }
        }
        if (state.inName) {
            callAttrStart(state, curIndex + 1, handler, rest);
            callAttrEnd(state, curIndex + 1, handler, rest);
        } else if (state.lookingForEq) {
            callAttrEnd(state, curIndex + 1, handler, rest);
        } else if (state.inValue) {
            callAttrEnd(state, curIndex + 1, handler, rest);
        }
        magicMatch.lastIndex = 0;
    };
    HTMLParser.searchStartTag = function (html) {
        var closingIndex = html.indexOf('>');
        if (closingIndex === -1 || !alphaRegex.test(html[1])) {
            return null;
        }
        var tagName, tagContent, match, rest = '', unary = '';
        var startTag = html.substring(0, closingIndex + 1);
        var isUnary = startTag[startTag.length - 2] === '/';
        var spaceIndex = startTag.search(space);
        if (isUnary) {
            unary = '/';
            tagContent = startTag.substring(1, startTag.length - 2).trim();
        } else {
            tagContent = startTag.substring(1, startTag.length - 1).trim();
        }
        if (spaceIndex === -1) {
            tagName = tagContent;
        } else {
            spaceIndex--;
            tagName = tagContent.substring(0, spaceIndex);
            rest = tagContent.substring(spaceIndex);
        }
        match = [
            startTag,
            tagName,
            rest,
            unary
        ];
        return {
            match: match,
            html: html.substring(startTag.length)
        };
    };
    module.exports = namespace.HTMLParser = HTMLParser;
});
/*can-util@3.3.2#js/set-immediate/set-immediate*/
define('can-util@3.3.2#js/set-immediate/set-immediate', function (require, exports, module) {
    (function (global) {
        var global = require('../global/global')();
        module.exports = global.setImmediate || function (cb) {
            return setTimeout(cb, 0);
        };
    }(function () {
        return this;
    }()));
});
/*can-util@3.3.2#dom/mutation-observer/mutation-observer*/
define('can-util@3.3.2#dom/mutation-observer/mutation-observer', function (require, exports, module) {
    (function (global) {
        var global = require('../../js/global/global')();
        var setMutationObserver;
        module.exports = function (setMO) {
            if (setMO !== undefined) {
                setMutationObserver = setMO;
            }
            return setMutationObserver !== undefined ? setMutationObserver : global.MutationObserver || global.WebKitMutationObserver || global.MozMutationObserver;
        };
    }(function () {
        return this;
    }()));
});
/*can-util@3.3.2#dom/child-nodes/child-nodes*/
define('can-util@3.3.2#dom/child-nodes/child-nodes', function (require, exports, module) {
    function childNodes(node) {
        var childNodes = node.childNodes;
        if ('length' in childNodes) {
            return childNodes;
        } else {
            var cur = node.firstChild;
            var nodes = [];
            while (cur) {
                nodes.push(cur);
                cur = cur.nextSibling;
            }
            return nodes;
        }
    }
    module.exports = childNodes;
});
/*can-util@3.3.2#dom/contains/contains*/
define('can-util@3.3.2#dom/contains/contains', function (require, exports, module) {
    module.exports = function (child) {
        return this.contains(child);
    };
});
/*can-util@3.3.2#dom/mutate/mutate*/
define('can-util@3.3.2#dom/mutate/mutate', function (require, exports, module) {
    var makeArray = require('../../js/make-array/make-array');
    var setImmediate = require('../../js/set-immediate/set-immediate');
    var CID = require('can-cid');
    var getMutationObserver = require('../mutation-observer/mutation-observer');
    var childNodes = require('../child-nodes/child-nodes');
    var domContains = require('../contains/contains');
    var domDispatch = require('../dispatch/dispatch');
    var DOCUMENT = require('../document/document');
    var mutatedElements;
    var checks = {
        inserted: function (root, elem) {
            return domContains.call(root, elem);
        },
        removed: function (root, elem) {
            return !domContains.call(root, elem);
        }
    };
    var fireOn = function (elems, root, check, event, dispatched) {
        if (!elems.length) {
            return;
        }
        var children, cid;
        for (var i = 0, elem; (elem = elems[i]) !== undefined; i++) {
            cid = CID(elem);
            if (elem.getElementsByTagName && check(root, elem) && !dispatched[cid]) {
                dispatched[cid] = true;
                children = makeArray(elem.getElementsByTagName('*'));
                domDispatch.call(elem, event, [], false);
                for (var j = 0, child; (child = children[j]) !== undefined; j++) {
                    cid = CID(child);
                    if (!dispatched[cid]) {
                        domDispatch.call(child, event, [], false);
                        dispatched[cid] = true;
                    }
                }
            }
        }
    };
    var fireMutations = function () {
        var mutations = mutatedElements;
        mutatedElements = null;
        var firstElement = mutations[0][1][0];
        var doc = DOCUMENT() || firstElement.ownerDocument || firstElement;
        var root = doc.contains ? doc : doc.body;
        var dispatched = {
            inserted: {},
            removed: {}
        };
        mutations.forEach(function (mutation) {
            fireOn(mutation[1], root, checks[mutation[0]], mutation[0], dispatched[mutation[0]]);
        });
    };
    var mutated = function (elements, type) {
        if (!getMutationObserver() && elements.length) {
            var firstElement = elements[0];
            var doc = DOCUMENT() || firstElement.ownerDocument || firstElement;
            var root = doc.contains ? doc : doc.body;
            if (checks.inserted(root, firstElement)) {
                if (!mutatedElements) {
                    mutatedElements = [];
                    setImmediate(fireMutations);
                }
                mutatedElements.push([
                    type,
                    elements
                ]);
            }
        }
    };
    module.exports = {
        appendChild: function (child) {
            if (getMutationObserver()) {
                this.appendChild(child);
            } else {
                var children;
                if (child.nodeType === 11) {
                    children = makeArray(childNodes(child));
                } else {
                    children = [child];
                }
                this.appendChild(child);
                mutated(children, 'inserted');
            }
        },
        insertBefore: function (child, ref, document) {
            if (getMutationObserver()) {
                this.insertBefore(child, ref);
            } else {
                var children;
                if (child.nodeType === 11) {
                    children = makeArray(childNodes(child));
                } else {
                    children = [child];
                }
                this.insertBefore(child, ref);
                mutated(children, 'inserted');
            }
        },
        removeChild: function (child) {
            if (getMutationObserver()) {
                this.removeChild(child);
            } else {
                mutated([child], 'removed');
                this.removeChild(child);
            }
        },
        replaceChild: function (newChild, oldChild) {
            if (getMutationObserver()) {
                this.replaceChild(newChild, oldChild);
            } else {
                var children;
                if (newChild.nodeType === 11) {
                    children = makeArray(childNodes(newChild));
                } else {
                    children = [newChild];
                }
                mutated([oldChild], 'removed');
                this.replaceChild(newChild, oldChild);
                mutated(children, 'inserted');
            }
        },
        inserted: function (elements) {
            mutated(elements, 'inserted');
        },
        removed: function (elements) {
            mutated(elements, 'removed');
        }
    };
});
/*can-util@3.3.2#js/cid/get-cid*/
define('can-util@3.3.2#js/cid/get-cid', function (require, exports, module) {
    var CID = require('can-cid');
    var domData = require('../../dom/data/data');
    module.exports = function (obj) {
        if (typeof obj.nodeType === 'number') {
            return domData.cid.call(obj);
        } else {
            var type = typeof obj;
            var isObject = type !== null && (type === 'object' || type === 'function');
            return type + ':' + (isObject ? CID(obj) : obj);
        }
    };
});
/*can-util@3.3.2#js/cid-map/cid-map*/
define('can-util@3.3.2#js/cid-map/cid-map', function (require, exports, module) {
    (function (global) {
        var GLOBAL = require('../global/global');
        var each = require('../each/each');
        var getCID = require('../cid/get-cid');
        var CIDMap;
        if (GLOBAL().Map) {
            CIDMap = GLOBAL().Map;
        } else {
            var CIDMap = function () {
                this.values = {};
            };
            CIDMap.prototype.set = function (key, value) {
                this.values[getCID(key)] = {
                    key: key,
                    value: value
                };
            };
            CIDMap.prototype['delete'] = function (key) {
                var has = getCID(key) in this.values;
                if (has) {
                    delete this.values[getCID(key)];
                }
                return has;
            };
            CIDMap.prototype.forEach = function (cb, thisArg) {
                each(this.values, function (pair) {
                    return cb.call(thisArg || this, pair.value, pair.key, this);
                }, this);
            };
            CIDMap.prototype.has = function (key) {
                return getCID(key) in this.values;
            };
            CIDMap.prototype.get = function (key) {
                var obj = this.values[getCID(key)];
                return obj && obj.value;
            };
            CIDMap.prototype.clear = function (key) {
                return this.values = {};
            };
            Object.defineProperty(CIDMap.prototype, 'size', {
                get: function () {
                    var size = 0;
                    each(this.values, function () {
                        size++;
                    });
                    return size;
                }
            });
        }
        module.exports = CIDMap;
    }(function () {
        return this;
    }()));
});
/*can-view-nodelist@3.0.4#can-view-nodelist*/
define('can-view-nodelist@3.0.4#can-view-nodelist', function (require, exports, module) {
    var makeArray = require('can-util/js/make-array/make-array');
    var each = require('can-util/js/each/each');
    var namespace = require('can-namespace');
    var domMutate = require('can-util/dom/mutate/mutate');
    var CIDMap = require('can-util/js/cid-map/cid-map');
    var nodeMap = new CIDMap(), splice = [].splice, push = [].push, itemsInChildListTree = function (list) {
            var count = 0;
            for (var i = 0, len = list.length; i < len; i++) {
                var item = list[i];
                if (item.nodeType) {
                    count++;
                } else {
                    count += itemsInChildListTree(item);
                }
            }
            return count;
        }, replacementMap = function (replacements, idMap) {
            var map = new CIDMap();
            for (var i = 0, len = replacements.length; i < len; i++) {
                var node = nodeLists.first(replacements[i]);
                map.set(node, replacements[i]);
            }
            return map;
        }, addUnfoundAsDeepChildren = function (list, rMap) {
            rMap.forEach(function (replacement) {
                list.newDeepChildren.push(replacement);
            });
        };
    var nodeLists = {
        update: function (nodeList, newNodes) {
            var oldNodes = nodeLists.unregisterChildren(nodeList);
            newNodes = makeArray(newNodes);
            var oldListLength = nodeList.length;
            splice.apply(nodeList, [
                0,
                oldListLength
            ].concat(newNodes));
            if (nodeList.replacements) {
                nodeLists.nestReplacements(nodeList);
                nodeList.deepChildren = nodeList.newDeepChildren;
                nodeList.newDeepChildren = [];
            } else {
                nodeLists.nestList(nodeList);
            }
            return oldNodes;
        },
        nestReplacements: function (list) {
            var index = 0, idMap = {}, rMap = replacementMap(list.replacements, idMap), rCount = list.replacements.length;
            while (index < list.length && rCount) {
                var node = list[index], replacement = rMap.get(node);
                if (replacement) {
                    rMap['delete'](node);
                    list.splice(index, itemsInChildListTree(replacement), replacement);
                    rCount--;
                }
                index++;
            }
            if (rCount) {
                addUnfoundAsDeepChildren(list, rMap);
            }
            list.replacements = [];
        },
        nestList: function (list) {
            var index = 0;
            while (index < list.length) {
                var node = list[index], childNodeList = nodeMap.get(node);
                if (childNodeList) {
                    if (childNodeList !== list) {
                        list.splice(index, itemsInChildListTree(childNodeList), childNodeList);
                    }
                } else {
                    nodeMap.set(node, list);
                }
                index++;
            }
        },
        last: function (nodeList) {
            var last = nodeList[nodeList.length - 1];
            if (last.nodeType) {
                return last;
            } else {
                return nodeLists.last(last);
            }
        },
        first: function (nodeList) {
            var first = nodeList[0];
            if (first.nodeType) {
                return first;
            } else {
                return nodeLists.first(first);
            }
        },
        flatten: function (nodeList) {
            var items = [];
            for (var i = 0; i < nodeList.length; i++) {
                var item = nodeList[i];
                if (item.nodeType) {
                    items.push(item);
                } else {
                    items.push.apply(items, nodeLists.flatten(item));
                }
            }
            return items;
        },
        register: function (nodeList, unregistered, parent, directlyNested) {
            nodeList.unregistered = unregistered;
            nodeList.parentList = parent;
            nodeList.nesting = parent && typeof parent.nesting !== 'undefined' ? parent.nesting + 1 : 0;
            if (parent) {
                nodeList.deepChildren = [];
                nodeList.newDeepChildren = [];
                nodeList.replacements = [];
                if (parent !== true) {
                    if (directlyNested) {
                        parent.replacements.push(nodeList);
                    } else {
                        parent.newDeepChildren.push(nodeList);
                    }
                }
            } else {
                nodeLists.nestList(nodeList);
            }
            return nodeList;
        },
        unregisterChildren: function (nodeList) {
            var nodes = [];
            each(nodeList, function (node) {
                if (node.nodeType) {
                    if (!nodeList.replacements) {
                        nodeMap['delete'](node);
                    }
                    nodes.push(node);
                } else {
                    push.apply(nodes, nodeLists.unregister(node, true));
                }
            });
            each(nodeList.deepChildren, function (nodeList) {
                nodeLists.unregister(nodeList, true);
            });
            return nodes;
        },
        unregister: function (nodeList, isChild) {
            var nodes = nodeLists.unregisterChildren(nodeList, true);
            if (nodeList.unregistered) {
                var unregisteredCallback = nodeList.unregistered;
                nodeList.replacements = nodeList.unregistered = null;
                if (!isChild) {
                    var deepChildren = nodeList.parentList && nodeList.parentList.deepChildren;
                    if (deepChildren) {
                        var index = deepChildren.indexOf(nodeList);
                        if (index !== -1) {
                            deepChildren.splice(index, 1);
                        }
                    }
                }
                unregisteredCallback();
            }
            return nodes;
        },
        after: function (oldElements, newFrag) {
            var last = oldElements[oldElements.length - 1];
            if (last.nextSibling) {
                domMutate.insertBefore.call(last.parentNode, newFrag, last.nextSibling);
            } else {
                domMutate.appendChild.call(last.parentNode, newFrag);
            }
        },
        replace: function (oldElements, newFrag) {
            var selectedValue, parentNode = oldElements[0].parentNode;
            if (parentNode.nodeName.toUpperCase() === 'SELECT' && parentNode.selectedIndex >= 0) {
                selectedValue = parentNode.value;
            }
            if (oldElements.length === 1) {
                domMutate.replaceChild.call(parentNode, newFrag, oldElements[0]);
            } else {
                nodeLists.after(oldElements, newFrag);
                nodeLists.remove(oldElements);
            }
            if (selectedValue !== undefined) {
                parentNode.value = selectedValue;
            }
        },
        remove: function (elementsToBeRemoved) {
            var parent = elementsToBeRemoved[0] && elementsToBeRemoved[0].parentNode;
            each(elementsToBeRemoved, function (child) {
                domMutate.removeChild.call(parent, child);
            });
        },
        nodeMap: nodeMap
    };
    module.exports = namespace.nodeLists = nodeLists;
});
/*can-util@3.3.2#dom/fragment/fragment*/
define('can-util@3.3.2#dom/fragment/fragment', function (require, exports, module) {
    var getDocument = require('../document/document'), childNodes = require('../child-nodes/child-nodes');
    var fragmentRE = /^\s*<(\w+)[^>]*>/, toString = {}.toString, fragment = function (html, name, doc) {
            if (name === undefined) {
                name = fragmentRE.test(html) && RegExp.$1;
            }
            if (html && toString.call(html.replace) === '[object Function]') {
                html = html.replace(/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, '<$1></$2>');
            }
            var container = doc.createElement('div'), temp = doc.createElement('div');
            if (name === 'tbody' || name === 'tfoot' || name === 'thead' || name === 'colgroup') {
                temp.innerHTML = '<table>' + html + '</table>';
                container = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild;
            } else if (name === 'col') {
                temp.innerHTML = '<table><colgroup>' + html + '</colgroup></table>';
                container = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild.firstChild;
            } else if (name === 'tr') {
                temp.innerHTML = '<table><tbody>' + html + '</tbody></table>';
                container = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild.firstChild;
            } else if (name === 'td' || name === 'th') {
                temp.innerHTML = '<table><tbody><tr>' + html + '</tr></tbody></table>';
                container = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild.firstChild.firstChild;
            } else if (name === 'option') {
                temp.innerHTML = '<select>' + html + '</select>';
                container = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild;
            } else {
                container.innerHTML = '' + html;
            }
            var tmp = {}, children = childNodes(container);
            tmp.length = children.length;
            for (var i = 0; i < children.length; i++) {
                tmp[i] = children[i];
            }
            return [].slice.call(tmp);
        };
    var buildFragment = function (html, doc) {
        if (html && html.nodeType === 11) {
            return html;
        }
        if (!doc) {
            doc = getDocument();
        } else if (doc.length) {
            doc = doc[0];
        }
        var parts = fragment(html, undefined, doc), frag = (doc || document).createDocumentFragment();
        for (var i = 0, length = parts.length; i < length; i++) {
            frag.appendChild(parts[i]);
        }
        return frag;
    };
    module.exports = buildFragment;
});
/*can-util@3.3.2#dom/frag/frag*/
define('can-util@3.3.2#dom/frag/frag', function (require, exports, module) {
    var getDocument = require('../document/document');
    var fragment = require('../fragment/fragment');
    var each = require('../../js/each/each');
    var childNodes = require('../child-nodes/child-nodes');
    var makeFrag = function (item, doc) {
        var document = doc || getDocument();
        var frag;
        if (!item || typeof item === 'string') {
            frag = fragment(item == null ? '' : '' + item, document);
            if (!frag.childNodes.length) {
                frag.appendChild(document.createTextNode(''));
            }
            return frag;
        } else if (item.nodeType === 11) {
            return item;
        } else if (typeof item.nodeType === 'number') {
            frag = document.createDocumentFragment();
            frag.appendChild(item);
            return frag;
        } else if (typeof item.length === 'number') {
            frag = document.createDocumentFragment();
            each(item, function (item) {
                frag.appendChild(makeFrag(item));
            });
            if (!childNodes(frag).length) {
                frag.appendChild(document.createTextNode(''));
            }
            return frag;
        } else {
            frag = fragment('' + item, document);
            if (!childNodes(frag).length) {
                frag.appendChild(document.createTextNode(''));
            }
            return frag;
        }
    };
    module.exports = makeFrag;
});
/*can-util@3.3.2#dom/mutation-observer/document/document*/
define('can-util@3.3.2#dom/mutation-observer/document/document', function (require, exports, module) {
    (function (global) {
        var getDocument = require('../../document/document');
        var domData = require('../../data/data');
        module.exports = {
            add: function (handler) {
                var documentElement = getDocument().documentElement;
                var globalObserverData = domData.get.call(documentElement, 'globalObserverData');
                if (!globalObserverData) {
                    var observer = new MutationObserver(function (mutations) {
                        globalObserverData.handlers.forEach(function (handler) {
                            handler(mutations);
                        });
                    });
                    observer.observe(documentElement, {
                        childList: true,
                        subtree: true
                    });
                    globalObserverData = {
                        observer: observer,
                        handlers: []
                    };
                    domData.set.call(documentElement, 'globalObserverData', globalObserverData);
                }
                globalObserverData.handlers.push(handler);
            },
            remove: function (handler) {
                var documentElement = getDocument().documentElement;
                var globalObserverData = domData.get.call(documentElement, 'globalObserverData');
                if (globalObserverData) {
                    var index = globalObserverData.handlers.indexOf(handler);
                    if (index >= 0) {
                        globalObserverData.handlers.splice(index, 1);
                    }
                    if (globalObserverData.handlers.length === 0) {
                        globalObserverData.observer.disconnect();
                        domData.clean.call(documentElement, 'globalObserverData');
                    }
                }
            }
        };
    }(function () {
        return this;
    }()));
});
/*can-util@3.3.2#js/cid-set/cid-set*/
define('can-util@3.3.2#js/cid-set/cid-set', function (require, exports, module) {
    (function (global) {
        var GLOBAL = require('../global/global');
        var each = require('../each/each');
        var getCID = require('../cid/get-cid');
        var CIDSet;
        if (GLOBAL().Set) {
            CIDSet = GLOBAL().Set;
        } else {
            var CIDSet = function () {
                this.values = {};
            };
            CIDSet.prototype.add = function (value) {
                this.values[getCID(value)] = value;
            };
            CIDSet.prototype['delete'] = function (key) {
                var has = getCID(key) in this.values;
                if (has) {
                    delete this.values[getCID(key)];
                }
                return has;
            };
            CIDSet.prototype.forEach = function (cb, thisArg) {
                each(this.values, cb, thisArg);
            };
            CIDSet.prototype.has = function (value) {
                return getCID(value) in this.values;
            };
            CIDSet.prototype.clear = function (key) {
                return this.values = {};
            };
            Object.defineProperty(CIDSet.prototype, 'size', {
                get: function () {
                    var size = 0;
                    each(this.values, function () {
                        size++;
                    });
                    return size;
                }
            });
        }
        module.exports = CIDSet;
    }(function () {
        return this;
    }()));
});
/*can-util@3.3.2#dom/is-of-global-document/is-of-global-document*/
define('can-util@3.3.2#dom/is-of-global-document/is-of-global-document', function (require, exports, module) {
    var getDocument = require('../document/document');
    module.exports = function (el) {
        return (el.ownerDocument || el) === getDocument();
    };
});
/*can-util@3.3.2#dom/events/make-mutation-event/make-mutation-event*/
define('can-util@3.3.2#dom/events/make-mutation-event/make-mutation-event', function (require, exports, module) {
    (function (global) {
        var each = require('../../../js/each/each');
        var makeArray = require('../../../js/make-array/make-array');
        var events = require('../events');
        var domData = require('../../data/data');
        var getMutationObserver = require('../../mutation-observer/mutation-observer');
        var domDispatch = require('../../dispatch/dispatch');
        var mutationDocument = require('../../mutation-observer/document/document');
        var getDocument = require('../../document/document');
        var CIDStore = require('../../../js/cid-set/cid-set');
        require('../../is-of-global-document/is-of-global-document');
        module.exports = function (specialEventName, mutationNodesProperty) {
            var originalAdd = events.addEventListener, originalRemove = events.removeEventListener;
            var dispatchIfListening = function (mutatedNode, specialEventData, dispatched) {
                var doDispatch = true;
                if (dispatched.has(mutatedNode)) {
                    return true;
                }
                dispatched.add(mutatedNode);
                if (specialEventName === 'removed') {
                    var documentElement = getDocument().documentElement;
                    if (documentElement.contains(mutatedNode)) {
                        doDispatch = false;
                    }
                }
                if (doDispatch && specialEventData.nodeIdsRespondingToInsert.has(mutatedNode)) {
                    domDispatch.call(mutatedNode, specialEventName, [], false);
                }
            };
            events.addEventListener = function (eventName) {
                if (eventName === specialEventName && getMutationObserver()) {
                    var documentElement = getDocument().documentElement;
                    var specialEventData = domData.get.call(documentElement, specialEventName + 'Data');
                    if (!specialEventData) {
                        specialEventData = {
                            handler: function (mutations) {
                                var dispatched = new CIDStore();
                                mutations.forEach(function (mutation) {
                                    each(mutation[mutationNodesProperty], function (mutatedNode) {
                                        var children = mutatedNode.getElementsByTagName && makeArray(mutatedNode.getElementsByTagName('*'));
                                        var alreadyChecked = dispatchIfListening(mutatedNode, specialEventData, dispatched);
                                        if (children && !alreadyChecked) {
                                            for (var j = 0, child; (child = children[j]) !== undefined; j++) {
                                                dispatchIfListening(child, specialEventData, dispatched);
                                            }
                                        }
                                    });
                                });
                            },
                            nodeIdsRespondingToInsert: new CIDStore()
                        };
                        mutationDocument.add(specialEventData.handler);
                        domData.set.call(documentElement, specialEventName + 'Data', specialEventData);
                    }
                    specialEventData.nodeIdsRespondingToInsert.add(this);
                }
                return originalAdd.apply(this, arguments);
            };
            events.removeEventListener = function (eventName) {
                if (eventName === specialEventName && getMutationObserver()) {
                    var documentElement = getDocument().documentElement;
                    var specialEventData = domData.get.call(documentElement, specialEventName + 'Data');
                    if (specialEventData) {
                        specialEventData.nodeIdsRespondingToInsert['delete'](this);
                        if (!specialEventData.nodeIdsRespondingToInsert.size) {
                            mutationDocument.remove(specialEventData.handler);
                            domData.clean.call(documentElement, specialEventName + 'Data');
                        }
                    }
                }
                return originalRemove.apply(this, arguments);
            };
        };
    }(function () {
        return this;
    }()));
});
/*can-util@3.3.2#dom/events/removed/removed*/
define('can-util@3.3.2#dom/events/removed/removed', function (require, exports, module) {
    var makeMutationEvent = require('../make-mutation-event/make-mutation-event');
    makeMutationEvent('removed', 'removedNodes');
});
/*can-view-live@3.0.6#lib/core*/
define('can-view-live@3.0.6#lib/core', function (require, exports, module) {
    var parser = require('can-view-parser');
    var domEvents = require('can-util/dom/events/events');
    var nodeLists = require('can-view-nodelist');
    var makeFrag = require('can-util/dom/frag/frag');
    var childNodes = require('can-util/dom/child-nodes/child-nodes');
    require('can-util/dom/events/removed/removed');
    var childMutationCallbacks = {};
    var live = {
        setup: function (el, bind, unbind) {
            var tornDown = false, teardown = function () {
                    if (!tornDown) {
                        tornDown = true;
                        unbind(data);
                        domEvents.removeEventListener.call(el, 'removed', teardown);
                    }
                    return true;
                }, data = {
                    teardownCheck: function (parent) {
                        return parent ? false : teardown();
                    }
                };
            domEvents.addEventListener.call(el, 'removed', teardown);
            bind(data);
            return data;
        },
        listen: function (el, compute, change) {
            return live.setup(el, function () {
                compute.computeInstance.addEventListener('change', change);
            }, function (data) {
                compute.computeInstance.removeEventListener('change', change);
                if (data.nodeList) {
                    nodeLists.unregister(data.nodeList);
                }
            });
        },
        getAttributeParts: function (newVal) {
            var attrs = {}, attr;
            parser.parseAttrs(newVal, {
                attrStart: function (name) {
                    attrs[name] = '';
                    attr = name;
                },
                attrValue: function (value) {
                    attrs[attr] += value;
                },
                attrEnd: function () {
                }
            });
            return attrs;
        },
        isNode: function (obj) {
            return obj && obj.nodeType;
        },
        addTextNodeIfNoChildren: function (frag) {
            if (!frag.firstChild) {
                frag.appendChild(frag.ownerDocument.createTextNode(''));
            }
        },
        registerChildMutationCallback: function (tag, callback) {
            if (callback) {
                childMutationCallbacks[tag] = callback;
            } else {
                return childMutationCallbacks[tag];
            }
        },
        callChildMutationCallback: function (el) {
            var callback = el && childMutationCallbacks[el.nodeName.toLowerCase()];
            if (callback) {
                callback(el);
            }
        },
        replace: function (nodes, val, teardown) {
            var oldNodes = nodes.slice(0), frag = makeFrag(val);
            nodeLists.register(nodes, teardown);
            nodeLists.update(nodes, childNodes(frag));
            nodeLists.replace(oldNodes, frag);
            return nodes;
        },
        getParentNode: function (el, defaultParentNode) {
            return defaultParentNode && el.parentNode.nodeType === 11 ? defaultParentNode : el.parentNode;
        },
        makeString: function (txt) {
            return txt == null ? '' : '' + txt;
        }
    };
    module.exports = live;
});
/*can-util@3.3.2#js/diff/diff*/
define('can-util@3.3.2#js/diff/diff', function (require, exports, module) {
    var slice = [].slice;
    var defaultIdentity = function (a, b) {
        return a === b;
    };
    module.exports = exports = function (oldList, newList, identity) {
        identity = identity || defaultIdentity;
        var oldIndex = 0, newIndex = 0, oldLength = oldList.length, newLength = newList.length, patches = [];
        while (oldIndex < oldLength && newIndex < newLength) {
            var oldItem = oldList[oldIndex], newItem = newList[newIndex];
            if (identity(oldItem, newItem)) {
                oldIndex++;
                newIndex++;
                continue;
            }
            if (newIndex + 1 < newLength && identity(oldItem, newList[newIndex + 1])) {
                patches.push({
                    index: newIndex,
                    deleteCount: 0,
                    insert: [newList[newIndex]]
                });
                oldIndex++;
                newIndex += 2;
                continue;
            } else if (oldIndex + 1 < oldLength && identity(oldList[oldIndex + 1], newItem)) {
                patches.push({
                    index: newIndex,
                    deleteCount: 1,
                    insert: []
                });
                oldIndex += 2;
                newIndex++;
                continue;
            } else {
                patches.push({
                    index: newIndex,
                    deleteCount: oldLength - oldIndex,
                    insert: slice.call(newList, newIndex)
                });
                return patches;
            }
        }
        if (newIndex === newLength && oldIndex === oldLength) {
            return patches;
        }
        patches.push({
            index: newIndex,
            deleteCount: oldLength - oldIndex,
            insert: slice.call(newList, newIndex)
        });
        return patches;
    };
});
/*can-util@3.3.2#dom/events/attributes/attributes*/
define('can-util@3.3.2#dom/events/attributes/attributes', function (require, exports, module) {
    (function (global) {
        var events = require('../events');
        var isOfGlobalDocument = require('../../is-of-global-document/is-of-global-document');
        var domData = require('../../data/data');
        var getMutationObserver = require('../../mutation-observer/mutation-observer');
        var assign = require('../../../js/assign/assign');
        var domDispatch = require('../../dispatch/dispatch');
        var originalAdd = events.addEventListener, originalRemove = events.removeEventListener;
        events.addEventListener = function (eventName) {
            if (eventName === 'attributes') {
                var MutationObserver = getMutationObserver();
                if (isOfGlobalDocument(this) && MutationObserver) {
                    var self = this;
                    var observer = new MutationObserver(function (mutations) {
                        mutations.forEach(function (mutation) {
                            var copy = assign({}, mutation);
                            domDispatch.call(self, copy, [], false);
                        });
                    });
                    observer.observe(this, {
                        attributes: true,
                        attributeOldValue: true
                    });
                    domData.set.call(this, 'canAttributesObserver', observer);
                } else {
                    domData.set.call(this, 'canHasAttributesBindings', true);
                }
            }
            return originalAdd.apply(this, arguments);
        };
        events.removeEventListener = function (eventName) {
            if (eventName === 'attributes') {
                var MutationObserver = getMutationObserver();
                var observer;
                if (isOfGlobalDocument(this) && MutationObserver) {
                    observer = domData.get.call(this, 'canAttributesObserver');
                    if (observer && observer.disconnect) {
                        observer.disconnect();
                        domData.clean.call(this, 'canAttributesObserver');
                    }
                } else {
                    domData.clean.call(this, 'canHasAttributesBindings');
                }
            }
            return originalRemove.apply(this, arguments);
        };
    }(function () {
        return this;
    }()));
});
/*can-util@3.3.2#dom/attr/attr*/
define('can-util@3.3.2#dom/attr/attr', function (require, exports, module) {
    (function (global) {
        var setImmediate = require('../../js/set-immediate/set-immediate');
        var getDocument = require('../document/document');
        var global = require('../../js/global/global')();
        var isOfGlobalDocument = require('../is-of-global-document/is-of-global-document');
        var setData = require('../data/data');
        var domContains = require('../contains/contains');
        var domEvents = require('../events/events');
        var domDispatch = require('../dispatch/dispatch');
        var MUTATION_OBSERVER = require('../mutation-observer/mutation-observer');
        var each = require('../../js/each/each');
        var types = require('can-types');
        var diff = require('../../js/diff/diff');
        require('../events/attributes/attributes');
        var namespaces = { 'xlink': 'http://www.w3.org/1999/xlink' };
        var formElements = {
                'INPUT': true,
                'TEXTAREA': true,
                'SELECT': true
            }, toString = function (value) {
                if (value == null) {
                    return '';
                } else {
                    return '' + value;
                }
            }, isSVG = function (el) {
                return el.namespaceURI === 'http://www.w3.org/2000/svg';
            }, truthy = function () {
                return true;
            }, getSpecialTest = function (special) {
                return special && special.test || truthy;
            }, propProp = function (prop, obj) {
                obj = obj || {};
                obj.get = function () {
                    return this[prop];
                };
                obj.set = function (value) {
                    if (this[prop] !== value) {
                        this[prop] = value;
                    }
                    return value;
                };
                return obj;
            }, booleanProp = function (prop) {
                return {
                    isBoolean: true,
                    set: function (value) {
                        if (prop in this) {
                            this[prop] = value !== false;
                        } else {
                            this.setAttribute(prop, '');
                        }
                    },
                    remove: function () {
                        this[prop] = false;
                    }
                };
            }, setupMO = function (el, callback) {
                var attrMO = setData.get.call(el, 'attrMO');
                if (!attrMO) {
                    var onMutation = function () {
                        callback.call(el);
                    };
                    var MO = MUTATION_OBSERVER();
                    if (MO) {
                        var observer = new MO(onMutation);
                        observer.observe(el, {
                            childList: true,
                            subtree: true
                        });
                        setData.set.call(el, 'attrMO', observer);
                    } else {
                        setData.set.call(el, 'attrMO', true);
                        setData.set.call(el, 'canBindingCallback', { onMutation: onMutation });
                    }
                }
            }, setChildOptions = function (el, value) {
                if (value != null) {
                    var child = el.firstChild, hasSelected = false;
                    while (child) {
                        if (child.nodeName === 'OPTION') {
                            if (value === child.value) {
                                hasSelected = child.selected = true;
                                break;
                            }
                        }
                        child = child.nextSibling;
                    }
                    if (!hasSelected) {
                        el.selectedIndex = -1;
                    }
                } else {
                    el.selectedIndex = -1;
                }
            }, setChildOptionsOnChange = function (select, aEL) {
                var handler = setData.get.call(select, 'attrSetChildOptions');
                if (handler) {
                    return Function.prototype;
                }
                handler = function () {
                    setChildOptions(select, select.value);
                };
                setData.set.call(select, 'attrSetChildOptions', handler);
                aEL.call(select, 'change', handler);
                return function (rEL) {
                    setData.clean.call(select, 'attrSetChildOptions');
                    rEL.call(select, 'change', handler);
                };
            }, attr = {
                special: {
                    checked: {
                        get: function () {
                            return this.checked;
                        },
                        set: function (val) {
                            var notFalse = !!val || val === '' || arguments.length === 0;
                            this.checked = notFalse;
                            if (notFalse && this.type === 'radio') {
                                this.defaultChecked = true;
                            }
                            return val;
                        },
                        remove: function () {
                            this.checked = false;
                        },
                        test: function () {
                            return this.nodeName === 'INPUT';
                        }
                    },
                    'class': {
                        get: function () {
                            if (isSVG(this)) {
                                return this.getAttribute('class');
                            }
                            return this.className;
                        },
                        set: function (val) {
                            val = val || '';
                            if (isSVG(this)) {
                                this.setAttribute('class', '' + val);
                            } else {
                                this.className = val;
                            }
                            return val;
                        }
                    },
                    disabled: booleanProp('disabled'),
                    focused: {
                        get: function () {
                            return this === document.activeElement;
                        },
                        set: function (val) {
                            var cur = attr.get(this, 'focused');
                            if (cur !== val) {
                                var element = this;
                                types.queueTask([
                                    function () {
                                        if (val) {
                                            element.focus();
                                        } else {
                                            element.blur();
                                        }
                                    },
                                    this,
                                    []
                                ]);
                            }
                            return !!val;
                        },
                        addEventListener: function (eventName, handler, aEL) {
                            aEL.call(this, 'focus', handler);
                            aEL.call(this, 'blur', handler);
                            return function (rEL) {
                                rEL.call(this, 'focus', handler);
                                rEL.call(this, 'blur', handler);
                            };
                        },
                        test: function () {
                            return this.nodeName === 'INPUT';
                        }
                    },
                    'for': propProp('htmlFor'),
                    innertext: propProp('innerText'),
                    innerhtml: propProp('innerHTML'),
                    innerHTML: propProp('innerHTML', {
                        addEventListener: function (eventName, handler, aEL) {
                            var handlers = [];
                            var el = this;
                            each([
                                'change',
                                'blur'
                            ], function (eventName) {
                                var localHandler = function () {
                                    handler.apply(this, arguments);
                                };
                                domEvents.addEventListener.call(el, eventName, localHandler);
                                handlers.push([
                                    eventName,
                                    localHandler
                                ]);
                            });
                            return function (rEL) {
                                each(handlers, function (info) {
                                    rEL.call(el, info[0], info[1]);
                                });
                            };
                        }
                    }),
                    required: booleanProp('required'),
                    readonly: booleanProp('readOnly'),
                    selected: {
                        get: function () {
                            return this.selected;
                        },
                        set: function (val) {
                            val = !!val;
                            setData.set.call(this, 'lastSetValue', val);
                            return this.selected = val;
                        },
                        addEventListener: function (eventName, handler, aEL) {
                            var option = this;
                            var select = this.parentNode;
                            var lastVal = option.selected;
                            var localHandler = function (changeEvent) {
                                var curVal = option.selected;
                                lastVal = setData.get.call(option, 'lastSetValue') || lastVal;
                                if (curVal !== lastVal) {
                                    lastVal = curVal;
                                    domDispatch.call(option, eventName);
                                }
                            };
                            var removeChangeHandler = setChildOptionsOnChange(select, aEL);
                            domEvents.addEventListener.call(select, 'change', localHandler);
                            aEL.call(option, eventName, handler);
                            return function (rEL) {
                                removeChangeHandler(rEL);
                                domEvents.removeEventListener.call(select, 'change', localHandler);
                                rEL.call(option, eventName, handler);
                            };
                        },
                        test: function () {
                            return this.nodeName === 'OPTION' && this.parentNode && this.parentNode.nodeName === 'SELECT';
                        }
                    },
                    src: {
                        set: function (val) {
                            if (val == null || val === '') {
                                this.removeAttribute('src');
                                return null;
                            } else {
                                this.setAttribute('src', val);
                                return val;
                            }
                        }
                    },
                    style: {
                        set: function () {
                            var el = global.document && getDocument().createElement('div');
                            if (el && el.style && 'cssText' in el.style) {
                                return function (val) {
                                    return this.style.cssText = val || '';
                                };
                            } else {
                                return function (val) {
                                    return this.setAttribute('style', val);
                                };
                            }
                        }()
                    },
                    textcontent: propProp('textContent'),
                    value: {
                        get: function () {
                            var value = this.value;
                            if (this.nodeName === 'SELECT') {
                                if ('selectedIndex' in this && this.selectedIndex === -1) {
                                    value = undefined;
                                }
                            }
                            return value;
                        },
                        set: function (value) {
                            var nodeName = this.nodeName.toLowerCase();
                            if (nodeName === 'input') {
                                value = toString(value);
                            }
                            if (this.value !== value || nodeName === 'option') {
                                this.value = value;
                            }
                            if (attr.defaultValue[nodeName]) {
                                this.defaultValue = value;
                            }
                            if (nodeName === 'select') {
                                setData.set.call(this, 'attrValueLastVal', value);
                                setChildOptions(this, value === null ? value : this.value);
                                var docEl = this.ownerDocument.documentElement;
                                if (!domContains.call(docEl, this)) {
                                    var select = this;
                                    var initialSetHandler = function () {
                                        domEvents.removeEventListener.call(select, 'inserted', initialSetHandler);
                                        setChildOptions(select, value === null ? value : select.value);
                                    };
                                    domEvents.addEventListener.call(this, 'inserted', initialSetHandler);
                                }
                                setupMO(this, function () {
                                    var value = setData.get.call(this, 'attrValueLastVal');
                                    attr.set(this, 'value', value);
                                    domDispatch.call(this, 'change');
                                });
                            }
                            return value;
                        },
                        test: function () {
                            return formElements[this.nodeName];
                        }
                    },
                    values: {
                        get: function () {
                            var values = [];
                            var child = this.firstChild;
                            while (child) {
                                if (child.nodeName === 'OPTION' && child.selected) {
                                    values.push(child.value);
                                }
                                child = child.nextSibling;
                            }
                            return values;
                        },
                        set: function (values) {
                            values = values || [];
                            var child = this.firstChild;
                            while (child) {
                                if (child.nodeName === 'OPTION') {
                                    child.selected = values.indexOf(child.value) !== -1;
                                }
                                child = child.nextSibling;
                            }
                            setData.set.call(this, 'stickyValues', attr.get(this, 'values'));
                            setupMO(this, function () {
                                var previousValues = setData.get.call(this, 'stickyValues');
                                attr.set(this, 'values', previousValues);
                                var currentValues = setData.get.call(this, 'stickyValues');
                                var changes = diff(previousValues.slice().sort(), currentValues.slice().sort());
                                if (changes.length) {
                                    domDispatch.call(this, 'values');
                                }
                            });
                            return values;
                        },
                        addEventListener: function (eventName, handler, aEL) {
                            var localHandler = function () {
                                domDispatch.call(this, 'values');
                            };
                            domEvents.addEventListener.call(this, 'change', localHandler);
                            aEL.call(this, eventName, handler);
                            return function (rEL) {
                                domEvents.removeEventListener.call(this, 'change', localHandler);
                                rEL.call(this, eventName, handler);
                            };
                        }
                    }
                },
                defaultValue: {
                    input: true,
                    textarea: true
                },
                setAttrOrProp: function (el, attrName, val) {
                    attrName = attrName.toLowerCase();
                    var special = attr.special[attrName];
                    if (special && special.isBoolean && !val) {
                        this.remove(el, attrName);
                    } else {
                        this.set(el, attrName, val);
                    }
                },
                set: function (el, attrName, val) {
                    var usingMutationObserver = isOfGlobalDocument(el) && MUTATION_OBSERVER();
                    attrName = attrName.toLowerCase();
                    var oldValue;
                    if (!usingMutationObserver) {
                        oldValue = attr.get(el, attrName);
                    }
                    var newValue;
                    var special = attr.special[attrName];
                    var setter = special && special.set;
                    var test = getSpecialTest(special);
                    if (typeof setter === 'function' && test.call(el)) {
                        if (arguments.length === 2) {
                            newValue = setter.call(el);
                        } else {
                            newValue = setter.call(el, val);
                        }
                    } else {
                        attr.setAttribute(el, attrName, val);
                    }
                    if (!usingMutationObserver && newValue !== oldValue) {
                        attr.trigger(el, attrName, oldValue);
                    }
                },
                setSelectValue: function (el, value) {
                    attr.set(el, 'value', value);
                },
                setAttribute: function () {
                    var doc = getDocument();
                    if (doc && document.createAttribute) {
                        try {
                            doc.createAttribute('{}');
                        } catch (e) {
                            var invalidNodes = {}, attributeDummy = document.createElement('div');
                            return function (el, attrName, val) {
                                var first = attrName.charAt(0), cachedNode, node, attr;
                                if ((first === '{' || first === '(' || first === '*') && el.setAttributeNode) {
                                    cachedNode = invalidNodes[attrName];
                                    if (!cachedNode) {
                                        attributeDummy.innerHTML = '<div ' + attrName + '=""></div>';
                                        cachedNode = invalidNodes[attrName] = attributeDummy.childNodes[0].attributes[0];
                                    }
                                    node = cachedNode.cloneNode();
                                    node.value = val;
                                    el.setAttributeNode(node);
                                } else {
                                    attr = attrName.split(':');
                                    if (attr.length !== 1) {
                                        el.setAttributeNS(namespaces[attr[0]], attrName, val);
                                    } else {
                                        el.setAttribute(attrName, val);
                                    }
                                }
                            };
                        }
                    }
                    return function (el, attrName, val) {
                        el.setAttribute(attrName, val);
                    };
                }(),
                trigger: function (el, attrName, oldValue) {
                    if (setData.get.call(el, 'canHasAttributesBindings')) {
                        attrName = attrName.toLowerCase();
                        return setImmediate(function () {
                            domDispatch.call(el, {
                                type: 'attributes',
                                attributeName: attrName,
                                target: el,
                                oldValue: oldValue,
                                bubbles: false
                            }, []);
                        });
                    }
                },
                get: function (el, attrName) {
                    attrName = attrName.toLowerCase();
                    var special = attr.special[attrName];
                    var getter = special && special.get;
                    var test = getSpecialTest(special);
                    if (typeof getter === 'function' && test.call(el)) {
                        return getter.call(el);
                    } else {
                        return el.getAttribute(attrName);
                    }
                },
                remove: function (el, attrName) {
                    attrName = attrName.toLowerCase();
                    var oldValue;
                    if (!MUTATION_OBSERVER()) {
                        oldValue = attr.get(el, attrName);
                    }
                    var special = attr.special[attrName];
                    var setter = special && special.set;
                    var remover = special && special.remove;
                    var test = getSpecialTest(special);
                    if (typeof remover === 'function' && test.call(el)) {
                        remover.call(el);
                    } else if (typeof setter === 'function' && test.call(el)) {
                        setter.call(el, undefined);
                    } else {
                        el.removeAttribute(attrName);
                    }
                    if (!MUTATION_OBSERVER() && oldValue != null) {
                        attr.trigger(el, attrName, oldValue);
                    }
                },
                has: function () {
                    var el = getDocument() && document.createElement('div');
                    if (el && el.hasAttribute) {
                        return function (el, name) {
                            return el.hasAttribute(name);
                        };
                    } else {
                        return function (el, name) {
                            return el.getAttribute(name) !== null;
                        };
                    }
                }()
            };
        var oldAddEventListener = domEvents.addEventListener;
        domEvents.addEventListener = function (eventName, handler) {
            var special = attr.special[eventName];
            if (special && special.addEventListener) {
                var teardown = special.addEventListener.call(this, eventName, handler, oldAddEventListener);
                var teardowns = setData.get.call(this, 'attrTeardowns');
                if (!teardowns) {
                    setData.set.call(this, 'attrTeardowns', teardowns = {});
                }
                if (!teardowns[eventName]) {
                    teardowns[eventName] = [];
                }
                teardowns[eventName].push({
                    teardown: teardown,
                    handler: handler
                });
                return;
            }
            return oldAddEventListener.apply(this, arguments);
        };
        var oldRemoveEventListener = domEvents.removeEventListener;
        domEvents.removeEventListener = function (eventName, handler) {
            var special = attr.special[eventName];
            if (special && special.addEventListener) {
                var teardowns = setData.get.call(this, 'attrTeardowns');
                if (teardowns && teardowns[eventName]) {
                    var eventTeardowns = teardowns[eventName];
                    for (var i = 0, len = eventTeardowns.length; i < len; i++) {
                        if (eventTeardowns[i].handler === handler) {
                            eventTeardowns[i].teardown.call(this, oldRemoveEventListener);
                            eventTeardowns.splice(i, 1);
                            break;
                        }
                    }
                    if (eventTeardowns.length === 0) {
                        delete teardowns[eventName];
                    }
                }
                return;
            }
            return oldRemoveEventListener.apply(this, arguments);
        };
        module.exports = exports = attr;
    }(function () {
        return this;
    }()));
});
/*can-view-live@3.0.6#lib/attr*/
define('can-view-live@3.0.6#lib/attr', function (require, exports, module) {
    var attr = require('can-util/dom/attr/attr');
    var live = require('./core');
    live.attr = function (el, attributeName, compute) {
        live.listen(el, compute, function (ev, newVal) {
            attr.set(el, attributeName, newVal);
        });
        attr.set(el, attributeName, compute());
    };
});
/*can-view-callbacks@3.0.6#can-view-callbacks*/
define('can-view-callbacks@3.0.6#can-view-callbacks', function (require, exports, module) {
    (function (global) {
        var Observation = require('can-observation');
        var dev = require('can-util/js/dev/dev');
        var getGlobal = require('can-util/js/global/global');
        var domMutate = require('can-util/dom/mutate/mutate');
        var namespace = require('can-namespace');
        var attr = function (attributeName, attrHandler) {
            if (attrHandler) {
                if (typeof attributeName === 'string') {
                    attributes[attributeName] = attrHandler;
                } else {
                    regExpAttributes.push({
                        match: attributeName,
                        handler: attrHandler
                    });
                }
            } else {
                var cb = attributes[attributeName];
                if (!cb) {
                    for (var i = 0, len = regExpAttributes.length; i < len; i++) {
                        var attrMatcher = regExpAttributes[i];
                        if (attrMatcher.match.test(attributeName)) {
                            cb = attrMatcher.handler;
                            break;
                        }
                    }
                }
                return cb;
            }
        };
        var attributes = {}, regExpAttributes = [], automaticCustomElementCharacters = /[-\:]/;
        var tag = function (tagName, tagHandler) {
            if (tagHandler) {
                if (getGlobal().html5) {
                    getGlobal().html5.elements += ' ' + tagName;
                    getGlobal().html5.shivDocument();
                }
                tags[tagName.toLowerCase()] = tagHandler;
            } else {
                var cb;
                if (tagHandler === null) {
                    delete tags[tagName.toLowerCase()];
                } else {
                    cb = tags[tagName.toLowerCase()];
                }
                if (!cb && automaticCustomElementCharacters.test(tagName)) {
                    cb = function () {
                    };
                }
                return cb;
            }
        };
        var tags = {};
        var callbacks = {
            _tags: tags,
            _attributes: attributes,
            _regExpAttributes: regExpAttributes,
            tag: tag,
            attr: attr,
            tagHandler: function (el, tagName, tagData) {
                var helperTagCallback = tagData.options.get('tags.' + tagName, { proxyMethods: false }), tagCallback = helperTagCallback || tags[tagName];
                var scope = tagData.scope, res;
                if (tagCallback) {
                    res = Observation.ignore(tagCallback)(el, tagData);
                } else {
                    res = scope;
                }
                if (res && tagData.subtemplate) {
                    if (scope !== res) {
                        scope = scope.add(res);
                    }
                    var result = tagData.subtemplate(scope, tagData.options);
                    var frag = typeof result === 'string' ? can.view.frag(result) : result;
                    domMutate.appendChild.call(el, frag);
                }
            }
        };
        namespace.view = namespace.view || {};
        if (namespace.view.callbacks) {
            throw new Error('You can\'t have two versions of can-view-callbacks, check your dependencies');
        } else {
            module.exports = namespace.view.callbacks = callbacks;
        }
    }(function () {
        return this;
    }()));
});
/*can-view-live@3.0.6#lib/attrs*/
define('can-view-live@3.0.6#lib/attrs', function (require, exports, module) {
    var live = require('./core');
    var viewCallbacks = require('can-view-callbacks');
    var attr = require('can-util/dom/attr/attr');
    var domEvents = require('can-util/dom/events/events');
    var types = require('can-types');
    live.attrs = function (el, compute, scope, options) {
        if (!types.isCompute(compute)) {
            var attrs = live.getAttributeParts(compute);
            for (var name in attrs) {
                attr.set(el, name, attrs[name]);
            }
            return;
        }
        var oldAttrs = {};
        var setAttrs = function (newVal) {
            var newAttrs = live.getAttributeParts(newVal), name;
            for (name in newAttrs) {
                var newValue = newAttrs[name], oldValue = oldAttrs[name];
                if (newValue !== oldValue) {
                    attr.set(el, name, newValue);
                    var callback = viewCallbacks.attr(name);
                    if (callback) {
                        callback(el, {
                            attributeName: name,
                            scope: scope,
                            options: options
                        });
                    }
                }
                delete oldAttrs[name];
            }
            for (name in oldAttrs) {
                attr.remove(el, name);
            }
            oldAttrs = newAttrs;
        };
        var handler = function (ev, newVal) {
            setAttrs(newVal);
        };
        compute.addEventListener('change', handler);
        domEvents.addEventListener.call(el, 'removed', function () {
            compute.removeEventListener('change', handler);
        });
        setAttrs(compute());
    };
});
/*can-view-live@3.0.6#lib/html*/
define('can-view-live@3.0.6#lib/html', function (require, exports, module) {
    var live = require('./core');
    var nodeLists = require('can-view-nodelist');
    var makeFrag = require('can-util/dom/frag/frag');
    var makeArray = require('can-util/js/make-array/make-array');
    var childNodes = require('can-util/dom/child-nodes/child-nodes');
    live.html = function (el, compute, parentNode, nodeList) {
        var data;
        parentNode = live.getParentNode(el, parentNode);
        data = live.listen(parentNode, compute, function (ev, newVal, oldVal) {
            var attached = nodeLists.first(nodes).parentNode;
            if (attached) {
                makeAndPut(newVal);
            }
            var pn = nodeLists.first(nodes).parentNode;
            data.teardownCheck(pn);
            live.callChildMutationCallback(pn);
        });
        var nodes = nodeList || [el], makeAndPut = function (val) {
                var isFunction = typeof val === 'function', aNode = live.isNode(val), frag = makeFrag(isFunction ? '' : val), oldNodes = makeArray(nodes);
                live.addTextNodeIfNoChildren(frag);
                oldNodes = nodeLists.update(nodes, childNodes(frag));
                if (isFunction) {
                    val(frag.firstChild);
                }
                nodeLists.replace(oldNodes, frag);
            };
        data.nodeList = nodes;
        if (!nodeList) {
            nodeLists.register(nodes, data.teardownCheck);
        } else {
            nodeList.unregistered = data.teardownCheck;
        }
        makeAndPut(compute());
    };
});
/*can-view-live@3.0.6#lib/util/runInOrder*/
define('can-view-live@3.0.6#lib/util/runInOrder', function (require, exports, module) {
    module.exports = function makeRunInOrder() {
        var running = 0;
        var tasks = [];
        return function runInOrder(fn) {
            return function () {
                var fnArgs = arguments;
                if (running) {
                    tasks.push({
                        fn: fn,
                        args: fnArgs
                    });
                    return;
                }
                running++;
                fn.apply(null, fnArgs);
                running--;
                while (tasks.length) {
                    running++;
                    tasks[0].fn.apply(null, tasks[0].args);
                    tasks.shift();
                    running--;
                }
            };
        };
    };
});
/*can-view-live@3.0.6#lib/list*/
define('can-view-live@3.0.6#lib/list', function (require, exports, module) {
    var live = require('./core');
    var makeRunInOrder = require('./util/runInOrder');
    var runInOrder = makeRunInOrder();
    var nodeLists = require('can-view-nodelist');
    var makeCompute = require('can-compute');
    var canBatch = require('can-event/batch/batch');
    var frag = require('can-util/dom/frag/frag');
    var domMutate = require('can-util/dom/mutate/mutate');
    var childNodes = require('can-util/dom/child-nodes/child-nodes');
    var makeArray = require('can-util/js/make-array/make-array');
    var each = require('can-util/js/each/each');
    var isFunction = require('can-util/js/is-function/is-function');
    var diff = require('can-util/js/diff/diff');
    var splice = [].splice;
    var renderAndAddToNodeLists = function (newNodeLists, parentNodeList, render, context, args) {
            var itemNodeList = [];
            if (parentNodeList) {
                nodeLists.register(itemNodeList, null, parentNodeList, true);
                itemNodeList.parentList = parentNodeList;
                itemNodeList.expression = '#each SUBEXPRESSION';
            }
            var itemHTML = render.apply(context, args.concat([itemNodeList])), itemFrag = frag(itemHTML);
            var children = makeArray(childNodes(itemFrag));
            if (parentNodeList) {
                nodeLists.update(itemNodeList, children);
                newNodeLists.push(itemNodeList);
            } else {
                newNodeLists.push(nodeLists.register(children));
            }
            return itemFrag;
        }, removeFromNodeList = function (masterNodeList, index, length) {
            var removedMappings = masterNodeList.splice(index + 1, length), itemsToRemove = [];
            each(removedMappings, function (nodeList) {
                var nodesToRemove = nodeLists.unregister(nodeList);
                [].push.apply(itemsToRemove, nodesToRemove);
            });
            return itemsToRemove;
        }, addFalseyIfEmpty = function (list, falseyRender, masterNodeList, nodeList) {
            if (falseyRender && list.length === 0) {
                var falseyNodeLists = [];
                var falseyFrag = renderAndAddToNodeLists(falseyNodeLists, nodeList, falseyRender, list, [list]);
                nodeLists.after([masterNodeList[0]], falseyFrag);
                masterNodeList.push(falseyNodeLists[0]);
            }
        };
    live.list = function (el, compute, render, context, parentNode, nodeList, falseyRender) {
        var masterNodeList = nodeList || [el], indexMap = [], afterPreviousEvents = false, isTornDown = false, add = runInOrder(function add(ev, items, index) {
                if (!afterPreviousEvents) {
                    return;
                }
                var frag = text.ownerDocument.createDocumentFragment(), newNodeLists = [], newIndicies = [];
                each(items, function (item, key) {
                    var itemIndex = makeCompute(key + index), itemCompute = makeCompute(function (newVal) {
                            if (arguments.length) {
                                if ('set' in list) {
                                    list.set(itemIndex(), newVal);
                                } else {
                                    list.attr(itemIndex(), newVal);
                                }
                            } else {
                                return item;
                            }
                        }), itemFrag = renderAndAddToNodeLists(newNodeLists, nodeList, render, context, [
                            itemCompute,
                            itemIndex
                        ]);
                    frag.appendChild(itemFrag);
                    newIndicies.push(itemIndex);
                });
                var masterListIndex = index + 1;
                if (!indexMap.length) {
                    var falseyItemsToRemove = removeFromNodeList(masterNodeList, 0, masterNodeList.length - 1);
                    nodeLists.remove(falseyItemsToRemove);
                }
                if (!masterNodeList[masterListIndex]) {
                    nodeLists.after(masterListIndex === 1 ? [text] : [nodeLists.last(masterNodeList[masterListIndex - 1])], frag);
                } else {
                    var el = nodeLists.first(masterNodeList[masterListIndex]);
                    domMutate.insertBefore.call(el.parentNode, frag, el);
                }
                splice.apply(masterNodeList, [
                    masterListIndex,
                    0
                ].concat(newNodeLists));
                splice.apply(indexMap, [
                    index,
                    0
                ].concat(newIndicies));
                for (var i = index + newIndicies.length, len = indexMap.length; i < len; i++) {
                    indexMap[i](i);
                }
                if (ev.callChildMutationCallback !== false) {
                    live.callChildMutationCallback(text.parentNode);
                }
            }), set = function (ev, newVal, index) {
                remove({}, { length: 1 }, index, true);
                add({}, [newVal], index);
            }, remove = runInOrder(function remove(ev, items, index, duringTeardown, fullTeardown) {
                if (!afterPreviousEvents) {
                    return;
                }
                if (!duringTeardown && data.teardownCheck(text.parentNode)) {
                    return;
                }
                if (index < 0) {
                    index = indexMap.length + index;
                }
                var itemsToRemove = removeFromNodeList(masterNodeList, index, items.length);
                indexMap.splice(index, items.length);
                for (var i = index, len = indexMap.length; i < len; i++) {
                    indexMap[i](i);
                }
                if (!fullTeardown) {
                    addFalseyIfEmpty(list, falseyRender, masterNodeList, nodeList);
                    nodeLists.remove(itemsToRemove);
                    if (ev.callChildMutationCallback !== false) {
                        live.callChildMutationCallback(text.parentNode);
                    }
                } else {
                    nodeLists.unregister(masterNodeList);
                }
            }), move = function (ev, item, newIndex, currentIndex) {
                if (!afterPreviousEvents) {
                    return;
                }
                newIndex = newIndex + 1;
                currentIndex = currentIndex + 1;
                var referenceNodeList = masterNodeList[newIndex];
                var movedElements = frag(nodeLists.flatten(masterNodeList[currentIndex]));
                var referenceElement;
                if (currentIndex < newIndex) {
                    referenceElement = nodeLists.last(referenceNodeList).nextSibling;
                } else {
                    referenceElement = nodeLists.first(referenceNodeList);
                }
                var parentNode = masterNodeList[0].parentNode;
                parentNode.insertBefore(movedElements, referenceElement);
                var temp = masterNodeList[currentIndex];
                [].splice.apply(masterNodeList, [
                    currentIndex,
                    1
                ]);
                [].splice.apply(masterNodeList, [
                    newIndex,
                    0,
                    temp
                ]);
                newIndex = newIndex - 1;
                currentIndex = currentIndex - 1;
                var indexCompute = indexMap[currentIndex];
                [].splice.apply(indexMap, [
                    currentIndex,
                    1
                ]);
                [].splice.apply(indexMap, [
                    newIndex,
                    0,
                    indexCompute
                ]);
                var i = Math.min(currentIndex, newIndex);
                var len = indexMap.length;
                for (i, len; i < len; i++) {
                    indexMap[i](i);
                }
                if (ev.callChildMutationCallback !== false) {
                    live.callChildMutationCallback(text.parentNode);
                }
            }, text = el.ownerDocument.createTextNode(''), list, teardownList = function (fullTeardown) {
                if (list && list.removeEventListener) {
                    list.removeEventListener('add', add);
                    list.removeEventListener('set', set);
                    list.removeEventListener('remove', remove);
                    list.removeEventListener('move', move);
                }
                remove({ callChildMutationCallback: !!fullTeardown }, { length: masterNodeList.length - 1 }, 0, true, fullTeardown);
            }, updateList = function (ev, newList, oldList) {
                if (isTornDown) {
                    return;
                }
                afterPreviousEvents = true;
                if (newList && oldList) {
                    list = newList || [];
                    var patches = diff(oldList, newList);
                    if (oldList.removeEventListener) {
                        oldList.removeEventListener('add', add);
                        oldList.removeEventListener('set', set);
                        oldList.removeEventListener('remove', remove);
                        oldList.removeEventListener('move', move);
                    }
                    for (var i = 0, patchLen = patches.length; i < patchLen; i++) {
                        var patch = patches[i];
                        if (patch.deleteCount) {
                            remove({ callChildMutationCallback: false }, { length: patch.deleteCount }, patch.index, true);
                        }
                        if (patch.insert.length) {
                            add({ callChildMutationCallback: false }, patch.insert, patch.index);
                        }
                    }
                } else {
                    if (oldList) {
                        teardownList();
                    }
                    list = newList || [];
                    add({ callChildMutationCallback: false }, list, 0);
                    addFalseyIfEmpty(list, falseyRender, masterNodeList, nodeList);
                }
                live.callChildMutationCallback(text.parentNode);
                afterPreviousEvents = false;
                if (list.addEventListener) {
                    list.addEventListener('add', add);
                    list.addEventListener('set', set);
                    list.addEventListener('remove', remove);
                    list.addEventListener('move', move);
                }
                canBatch.afterPreviousEvents(function () {
                    afterPreviousEvents = true;
                });
            };
        parentNode = live.getParentNode(el, parentNode);
        var data = live.setup(parentNode, function () {
            if (isFunction(compute)) {
                compute.addEventListener('change', updateList);
            }
        }, function () {
            if (isFunction(compute)) {
                compute.removeEventListener('change', updateList);
            }
            teardownList(true);
        });
        if (!nodeList) {
            live.replace(masterNodeList, text, data.teardownCheck);
        } else {
            nodeLists.replace(masterNodeList, text);
            nodeLists.update(masterNodeList, [text]);
            nodeList.unregistered = function () {
                data.teardownCheck();
                isTornDown = true;
            };
        }
        updateList({}, isFunction(compute) ? compute() : compute);
    };
});
/*can-view-live@3.0.6#lib/text*/
define('can-view-live@3.0.6#lib/text', function (require, exports, module) {
    var live = require('./core');
    var nodeLists = require('can-view-nodelist');
    live.text = function (el, compute, parentNode, nodeList) {
        var parent = live.getParentNode(el, parentNode);
        var data = live.listen(parent, compute, function (ev, newVal, oldVal) {
            if (typeof node.nodeValue !== 'unknown') {
                node.nodeValue = live.makeString(newVal);
            }
            data.teardownCheck(node.parentNode);
        });
        var node = el.ownerDocument.createTextNode(live.makeString(compute()));
        if (nodeList) {
            nodeList.unregistered = data.teardownCheck;
            data.nodeList = nodeList;
            nodeLists.update(nodeList, [node]);
            nodeLists.replace([el], node);
        } else {
            data.nodeList = live.replace([el], node, data.teardownCheck);
        }
    };
});
/*can-view-live@3.0.6#can-view-live*/
define('can-view-live@3.0.6#can-view-live', function (require, exports, module) {
    var live = require('./lib/core');
    require('./lib/attr');
    require('./lib/attrs');
    require('./lib/html');
    require('./lib/list');
    require('./lib/text');
    module.exports = live;
});
/*can-util@3.3.2#js/base-url/base-url*/
define('can-util@3.3.2#js/base-url/base-url', function (require, exports, module) {
    (function (global) {
        var getGlobal = require('../global/global');
        var setBaseUrl;
        module.exports = function (setUrl) {
            if (setUrl !== undefined) {
                setBaseUrl = setUrl;
            }
            if (setBaseUrl !== undefined) {
                return setBaseUrl;
            }
            var global = getGlobal();
            if (global.location) {
                var href = global.location.href;
                var lastSlash = href.lastIndexOf('/');
                return lastSlash !== -1 ? href.substr(0, lastSlash) : href;
            } else if (typeof process !== 'undefined') {
                return process.cwd();
            }
        };
    }(function () {
        return this;
    }()));
});
/*can-util@3.3.2#js/parse-uri/parse-uri*/
define('can-util@3.3.2#js/parse-uri/parse-uri', function (require, exports, module) {
    module.exports = function (url) {
        var m = String(url).replace(/^\s+|\s+$/g, '').match(/^([^:\/?#]+:)?(\/\/(?:[^:@]*(?::[^:@]*)?@)?(([^:\/?#]*)(?::(\d*))?))?([^?#]*)(\?[^#]*)?(#[\s\S]*)?/);
        return m ? {
            href: m[0] || '',
            protocol: m[1] || '',
            authority: m[2] || '',
            host: m[3] || '',
            hostname: m[4] || '',
            port: m[5] || '',
            pathname: m[6] || '',
            search: m[7] || '',
            hash: m[8] || ''
        } : null;
    };
});
/*can-util@3.3.2#js/join-uris/join-uris*/
define('can-util@3.3.2#js/join-uris/join-uris', function (require, exports, module) {
    var parseURI = require('../parse-uri/parse-uri');
    module.exports = function (base, href) {
        function removeDotSegments(input) {
            var output = [];
            input.replace(/^(\.\.?(\/|$))+/, '').replace(/\/(\.(\/|$))+/g, '/').replace(/\/\.\.$/, '/../').replace(/\/?[^\/]*/g, function (p) {
                if (p === '/..') {
                    output.pop();
                } else {
                    output.push(p);
                }
            });
            return output.join('').replace(/^\//, input.charAt(0) === '/' ? '/' : '');
        }
        href = parseURI(href || '');
        base = parseURI(base || '');
        return !href || !base ? null : (href.protocol || base.protocol) + (href.protocol || href.authority ? href.authority : base.authority) + removeDotSegments(href.protocol || href.authority || href.pathname.charAt(0) === '/' ? href.pathname : href.pathname ? (base.authority && !base.pathname ? '/' : '') + base.pathname.slice(0, base.pathname.lastIndexOf('/') + 1) + href.pathname : base.pathname) + (href.protocol || href.authority || href.pathname ? href.search : href.search || base.search) + href.hash;
    };
});
/*can-stache@3.0.20#helpers/core*/
define('can-stache@3.0.20#helpers/core', function (require, exports, module) {
    var live = require('can-view-live');
    var nodeLists = require('can-view-nodelist');
    var compute = require('can-compute');
    var utils = require('../src/utils');
    var types = require('can-types');
    var isFunction = require('can-util/js/is-function/is-function');
    var getBaseURL = require('can-util/js/base-url/base-url');
    var joinURIs = require('can-util/js/join-uris/join-uris');
    var each = require('can-util/js/each/each');
    var assign = require('can-util/js/assign/assign');
    var isIterable = require('can-util/js/is-iterable/is-iterable');
    var domData = require('can-util/dom/data/data');
    var looksLikeOptions = function (options) {
        return options && typeof options.fn === 'function' && typeof options.inverse === 'function';
    };
    var resolve = function (value) {
        if (isFunction(value)) {
            return value();
        } else {
            return value;
        }
    };
    var resolveHash = function (hash) {
        var params = {};
        for (var prop in hash) {
            var value = hash[prop];
            if (value && value.isComputed) {
                params[prop] = value();
            } else {
                params[prop] = value;
            }
        }
        return params;
    };
    var helpers = {
        'each': function (items) {
            var args = [].slice.call(arguments), options = args.pop(), argsLen = args.length, argExprs = options.exprData.argExprs, resolved = resolve(items), asVariable, aliases, key;
            if (argsLen === 2 || argsLen === 3 && argExprs[1].key === 'as') {
                asVariable = args[argsLen - 1];
                if (typeof asVariable !== 'string') {
                    asVariable = argExprs[argsLen - 1].key;
                }
            }
            if (types.isListLike(resolved) && !options.stringOnly) {
                return function (el) {
                    var nodeList = [el];
                    nodeList.expression = 'live.list';
                    nodeLists.register(nodeList, null, options.nodeList, true);
                    nodeLists.update(options.nodeList, [el]);
                    var cb = function (item, index, parentNodeList) {
                        var aliases = {
                            '%index': index,
                            '@index': index
                        };
                        if (asVariable) {
                            aliases[asVariable] = item;
                        }
                        return options.fn(options.scope.add(aliases, { notContext: true }).add(item), options.options, parentNodeList);
                    };
                    live.list(el, items, cb, options.context, el.parentNode, nodeList, function (list, parentNodeList) {
                        return options.inverse(options.scope.add(list), options.options, parentNodeList);
                    });
                };
            }
            var expr = resolved, result;
            if (!!expr && utils.isArrayLike(expr)) {
                result = utils.getItemsFragContent(expr, options, options.scope, asVariable);
                return options.stringOnly ? result.join('') : result;
            } else if (isIterable(expr)) {
                result = [];
                each(expr, function (value, key) {
                    aliases = { '%key': key };
                    if (asVariable) {
                        aliases[asVariable] = value;
                    }
                    result.push(options.fn(options.scope.add(aliases, { notContext: true }).add(value)));
                });
                return options.stringOnly ? result.join('') : result;
            } else if (types.isMapLike(expr)) {
                result = [];
                (expr.forEach || expr.each).call(expr, function (val, key) {
                    var value = compute(expr, key);
                    aliases = {
                        '%key': key,
                        '@key': key
                    };
                    if (asVariable) {
                        aliases[asVariable] = expr[key];
                    }
                    result.push(options.fn(options.scope.add(aliases, { notContext: true }).add(value)));
                });
                return options.stringOnly ? result.join('') : result;
            } else if (expr instanceof Object) {
                result = [];
                for (key in expr) {
                    aliases = {
                        '%key': key,
                        '@key': key
                    };
                    if (asVariable) {
                        aliases[asVariable] = expr[key];
                    }
                    result.push(options.fn(options.scope.add(aliases, { notContext: true }).add(expr[key])));
                }
                return options.stringOnly ? result.join('') : result;
            }
        },
        '@index': function (offset, options) {
            if (!options) {
                options = offset;
                offset = 0;
            }
            var index = options.scope.peek('@index');
            return '' + ((isFunction(index) ? index() : index) + offset);
        },
        'if': function (expr, options) {
            var value;
            if (isFunction(expr)) {
                value = compute.truthy(expr)();
            } else {
                value = !!resolve(expr);
            }
            if (value) {
                return options.fn(options.scope || this);
            } else {
                return options.inverse(options.scope || this);
            }
        },
        'is': function () {
            var lastValue, curValue, options = arguments[arguments.length - 1];
            if (arguments.length - 2 <= 0) {
                return options.inverse();
            }
            var args = arguments;
            var callFn = compute(function () {
                for (var i = 0; i < args.length - 1; i++) {
                    curValue = resolve(args[i]);
                    curValue = isFunction(curValue) ? curValue() : curValue;
                    if (i > 0) {
                        if (curValue !== lastValue) {
                            return false;
                        }
                    }
                    lastValue = curValue;
                }
                return true;
            });
            return callFn() ? options.fn() : options.inverse();
        },
        'eq': function () {
            return helpers.is.apply(this, arguments);
        },
        'unless': function (expr, options) {
            return helpers['if'].apply(this, [
                expr,
                assign(assign({}, options), {
                    fn: options.inverse,
                    inverse: options.fn
                })
            ]);
        },
        'with': function (expr, options) {
            var ctx = expr;
            expr = resolve(expr);
            if (!!expr) {
                return options.fn(ctx);
            }
        },
        'log': function (options) {
            var logs = [];
            each(arguments, function (val) {
                if (!looksLikeOptions(val)) {
                    logs.push(val);
                }
            });
            if (typeof console !== 'undefined' && console.log) {
                if (!logs.length) {
                    console.log(options.context);
                } else {
                    console.log.apply(console, logs);
                }
            }
        },
        'data': function (attr) {
            var data = arguments.length === 2 ? this : arguments[1];
            return function (el) {
                domData.set.call(el, attr, data || this.context);
            };
        },
        'switch': function (expression, options) {
            resolve(expression);
            var found = false;
            var newOptions = options.helpers.add({
                'case': function (value, options) {
                    if (!found && resolve(expression) === resolve(value)) {
                        found = true;
                        return options.fn(options.scope || this);
                    }
                },
                'default': function (options) {
                    if (!found) {
                        return options.fn(options.scope || this);
                    }
                }
            });
            return options.fn(options.scope, newOptions);
        },
        'joinBase': function (firstExpr) {
            var args = [].slice.call(arguments);
            var options = args.pop();
            var moduleReference = args.map(function (expr) {
                var value = resolve(expr);
                return isFunction(value) ? value() : value;
            }).join('');
            var templateModule = options.helpers.peek('helpers.module');
            var parentAddress = templateModule ? templateModule.uri : undefined;
            var isRelative = moduleReference[0] === '.';
            if (isRelative && parentAddress) {
                return joinURIs(parentAddress, moduleReference);
            } else {
                var baseURL = typeof System !== 'undefined' && (System.renderingBaseURL || System.baseURL) || getBaseURL();
                if (moduleReference[0] !== '/' && baseURL[baseURL.length - 1] !== '/') {
                    baseURL += '/';
                }
                return joinURIs(baseURL, moduleReference);
            }
        }
    };
    helpers.eachOf = helpers.each;
    var registerHelper = function (name, callback) {
        helpers[name] = callback;
    };
    var makeSimpleHelper = function (fn) {
        return function () {
            var realArgs = [];
            each(arguments, function (val, i) {
                if (i <= arguments.length) {
                    while (val && val.isComputed) {
                        val = val();
                    }
                    realArgs.push(val);
                }
            });
            return fn.apply(this, realArgs);
        };
    };
    module.exports = {
        registerHelper: registerHelper,
        registerSimpleHelper: function (name, callback) {
            registerHelper(name, makeSimpleHelper(callback));
        },
        getHelper: function (name, options) {
            var helper = options && options.get && options.get('helpers.' + name, { proxyMethods: false });
            if (!helper) {
                helper = helpers[name];
            }
            if (helper) {
                return { fn: helper };
            }
        },
        resolve: resolve,
        resolveHash: resolveHash,
        looksLikeOptions: looksLikeOptions
    };
});
/*can-stache@3.0.20#src/expression*/
define('can-stache@3.0.20#src/expression', function (require, exports, module) {
    var compute = require('can-compute');
    var observeReader = require('can-observation/reader/reader');
    var utils = require('./utils');
    var mustacheHelpers = require('../helpers/core');
    var each = require('can-util/js/each/each');
    var isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');
    var dev = require('can-util/js/dev/dev');
    var assign = require('can-util/js/assign/assign');
    var last = require('can-util/js/last/last');
    var getKeyComputeData = function (key, scope, readOptions) {
            var data = scope.computeData(key, readOptions);
            compute.temporarilyBind(data.compute);
            return data;
        }, lookupValue = function (key, scope, helperOptions, readOptions) {
            var prop = getValueOfComputeOrFunction(key);
            var computeData = getKeyComputeData(prop, scope, readOptions);
            if (!computeData.compute.computeInstance.hasDependencies) {
                return {
                    value: computeData.initialValue,
                    computeData: computeData
                };
            } else {
                return {
                    value: computeData.compute,
                    computeData: computeData
                };
            }
        }, lookupValueOrHelper = function (key, scope, helperOptions, readOptions) {
            var res = lookupValue(key, scope, helperOptions, readOptions);
            if (res.computeData.initialValue === undefined) {
                if (key.charAt(0) === '@' && key !== '@index') {
                    key = key.substr(1);
                }
                var helper = mustacheHelpers.getHelper(key, helperOptions);
                res.helper = helper && helper.fn;
            }
            return res;
        }, lookupValueInResult = function (keyOrCompute, lookupOrCall, scope, helperOptions, readOptions) {
            var result = lookupOrCall.value(scope, {}, {});
            var c = compute(function (newVal) {
                var key = getValueOfComputeOrFunction(keyOrCompute);
                if (arguments.length) {
                    observeReader.write(result, observeReader.reads(key), newVal);
                } else {
                    return observeReader.get(result, '' + key);
                }
            });
            return { value: c };
        }, getValueOfComputeOrFunction = function (computeOrFunction) {
            if (typeof computeOrFunction.value === 'function') {
                return computeOrFunction.value();
            }
            if (typeof computeOrFunction === 'function') {
                return computeOrFunction();
            }
            return computeOrFunction;
        }, convertToArgExpression = function (expr) {
            if (!(expr instanceof Arg) && !(expr instanceof Literal)) {
                return new Arg(expr);
            } else {
                return expr;
            }
        };
    var Bracket = function (key, root) {
        this.root = root;
        this.key = key;
    };
    Bracket.prototype.value = function (scope) {
        var prop = this.key;
        var obj = this.root;
        if (prop instanceof Lookup) {
            prop = lookupValue(prop.key, scope, {}, {});
        } else if (prop instanceof Call) {
            prop = prop.value(scope, {}, {});
        }
        if (prop.computeData != null && prop.hasOwnProperty('value')) {
            prop = prop.value;
        }
        if (!obj) {
            return lookupValue(prop, scope, {}, {}).value;
        } else {
            return lookupValueInResult(prop, obj, scope, {}, {}).value;
        }
    };
    var Literal = function (value) {
        this._value = value;
    };
    Literal.prototype.value = function () {
        return this._value;
    };
    var Lookup = function (key, root) {
        this.key = key;
        this.rootExpr = root;
    };
    Lookup.prototype.value = function (scope, helperOptions) {
        var result = {};
        if (this.rootExpr) {
            result = lookupValueInResult(this.key, this.rootExpr, scope, {}, {});
        } else {
            result = lookupValueOrHelper(this.key, scope, helperOptions);
        }
        this.isHelper = result.helper && !result.helper.callAsMethod;
        return result.helper || result.value;
    };
    var ScopeLookup = function (key, root) {
        Lookup.apply(this, arguments);
    };
    ScopeLookup.prototype.value = function (scope, helperOptions) {
        if (this.rootExpr) {
            return lookupValueInResult(this.key, this.rootExpr, scope, {}, {}).value;
        }
        return lookupValue(this.key, scope, helperOptions).value;
    };
    var Arg = function (expression, modifiers) {
        this.expr = expression;
        this.modifiers = modifiers || {};
        this.isCompute = false;
    };
    Arg.prototype.value = function () {
        return this.expr.value.apply(this.expr, arguments);
    };
    var Hash = function () {
    };
    var Hashes = function (hashes) {
        this.hashExprs = hashes;
    };
    Hashes.prototype.value = function (scope, helperOptions) {
        var hash = {};
        for (var prop in this.hashExprs) {
            var val = convertToArgExpression(this.hashExprs[prop]), value = val.value.apply(val, arguments);
            hash[prop] = {
                call: value && value.isComputed && !val.modifiers.compute,
                value: value
            };
        }
        return compute(function () {
            var finalHash = {};
            for (var prop in hash) {
                finalHash[prop] = hash[prop].call ? hash[prop].value() : hash[prop].value;
            }
            return finalHash;
        });
    };
    var Call = function (methodExpression, argExpressions) {
        this.methodExpr = methodExpression;
        this.argExprs = argExpressions.map(convertToArgExpression);
    };
    Call.prototype.args = function (scope, helperOptions) {
        var args = [];
        for (var i = 0, len = this.argExprs.length; i < len; i++) {
            var arg = this.argExprs[i];
            var value = arg.value.apply(arg, arguments);
            args.push({
                call: value && value.isComputed && !arg.modifiers.compute,
                value: value
            });
        }
        return function () {
            var finalArgs = [];
            for (var i = 0, len = args.length; i < len; i++) {
                finalArgs[i] = args[i].call ? args[i].value() : args[i].value;
            }
            return finalArgs;
        };
    };
    Call.prototype.value = function (scope, helperScope, helperOptions) {
        var method = this.methodExpr.value(scope, helperScope);
        var isHelper = this.isHelper = this.methodExpr.isHelper;
        var getArgs = this.args(scope, helperScope);
        return compute(function (newVal) {
            var func = method;
            if (func && func.isComputed) {
                func = func();
            }
            if (typeof func === 'function') {
                var args = getArgs();
                if (isHelper && helperOptions) {
                    args.push(helperOptions);
                }
                if (arguments.length) {
                    args.unshift(new expression.SetIdentifier(newVal));
                }
                return func.apply(null, args);
            }
        });
    };
    var HelperLookup = function () {
        Lookup.apply(this, arguments);
    };
    HelperLookup.prototype.value = function (scope, helperOptions) {
        var result = lookupValueOrHelper(this.key, scope, helperOptions, {
            isArgument: true,
            args: [
                scope.peek('.'),
                scope
            ]
        });
        return result.helper || result.value;
    };
    var HelperScopeLookup = function () {
        Lookup.apply(this, arguments);
    };
    HelperScopeLookup.prototype.value = function (scope, helperOptions) {
        return lookupValue(this.key, scope, helperOptions, {
            callMethodsOnObservables: true,
            isArgument: true,
            args: [
                scope.peek('.'),
                scope
            ]
        }).value;
    };
    var Helper = function (methodExpression, argExpressions, hashExpressions) {
        this.methodExpr = methodExpression;
        this.argExprs = argExpressions;
        this.hashExprs = hashExpressions;
        this.mode = null;
    };
    Helper.prototype.args = function (scope, helperOptions) {
        var args = [];
        for (var i = 0, len = this.argExprs.length; i < len; i++) {
            var arg = this.argExprs[i];
            args.push(arg.value.apply(arg, arguments));
        }
        return args;
    };
    Helper.prototype.hash = function (scope, helperOptions) {
        var hash = {};
        for (var prop in this.hashExprs) {
            var val = this.hashExprs[prop];
            hash[prop] = val.value.apply(val, arguments);
        }
        return hash;
    };
    Helper.prototype.helperAndValue = function (scope, helperOptions) {
        var looksLikeAHelper = this.argExprs.length || !isEmptyObject(this.hashExprs), helper, value, methodKey = this.methodExpr instanceof Literal ? '' + this.methodExpr._value : this.methodExpr.key, initialValue, args;
        if (looksLikeAHelper) {
            helper = mustacheHelpers.getHelper(methodKey, helperOptions);
            var context = scope.peek('.');
            if (!helper && typeof context[methodKey] === 'function') {
                helper = { fn: context[methodKey] };
            }
        }
        if (!helper) {
            args = this.args(scope, helperOptions);
            var computeData = getKeyComputeData(methodKey, scope, {
                    isArgument: false,
                    args: args && args.length ? args : [
                        scope.peek('.'),
                        scope
                    ]
                }), compute = computeData.compute;
            initialValue = computeData.initialValue;
            if (computeData.compute.computeInstance.hasDependencies) {
                value = compute;
            } else {
                value = initialValue;
            }
            if (!looksLikeAHelper && initialValue === undefined) {
                helper = mustacheHelpers.getHelper(methodKey, helperOptions);
            }
        }
        return {
            value: value,
            args: args,
            helper: helper && helper.fn
        };
    };
    Helper.prototype.evaluator = function (helper, scope, helperOptions, readOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly) {
        var helperOptionArg = {
                fn: function () {
                },
                inverse: function () {
                },
                stringOnly: stringOnly
            }, context = scope.peek('.'), args = this.args(scope, helperOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly), hash = this.hash(scope, helperOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly);
        utils.convertToScopes(helperOptionArg, scope, helperOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly);
        assign(helperOptionArg, {
            context: context,
            scope: scope,
            contexts: scope,
            hash: hash,
            nodeList: nodeList,
            exprData: this,
            helperOptions: helperOptions,
            helpers: helperOptions
        });
        args.push(helperOptionArg);
        return function () {
            return helper.apply(context, args);
        };
    };
    Helper.prototype.value = function (scope, helperOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly) {
        var helperAndValue = this.helperAndValue(scope, helperOptions);
        var helper = helperAndValue.helper;
        if (!helper) {
            return helperAndValue.value;
        }
        var fn = this.evaluator(helper, scope, helperOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly);
        var computeValue = compute(fn);
        compute.temporarilyBind(computeValue);
        if (!computeValue.computeInstance.hasDependencies) {
            return computeValue();
        } else {
            return computeValue;
        }
    };
    var keyRegExp = /[\w\.\\\-_@\/\&%]+/, tokensRegExp = /('.*?'|".*?"|=|[\w\.\\\-_@\/*%\$]+|[\(\)]|,|\~|\[|\]\s*|\s*(?=\[))/g, bracketSpaceRegExp = /\]\s+/, literalRegExp = /^('.*?'|".*?"|[0-9]+\.?[0-9]*|true|false|null|undefined)$/;
    var isTokenKey = function (token) {
        return keyRegExp.test(token);
    };
    var testDot = /^[\.@]\w/;
    var isAddingToExpression = function (token) {
        return isTokenKey(token) && testDot.test(token);
    };
    var ensureChildren = function (type) {
        if (!type.children) {
            type.children = [];
        }
        return type;
    };
    var Stack = function () {
        this.root = {
            children: [],
            type: 'Root'
        };
        this.current = this.root;
        this.stack = [this.root];
    };
    assign(Stack.prototype, {
        top: function () {
            return last(this.stack);
        },
        isRootTop: function () {
            return this.top() === this.root;
        },
        popTo: function (types) {
            this.popUntil(types);
            this.pop();
        },
        pop: function () {
            if (!this.isRootTop()) {
                this.stack.pop();
            }
        },
        first: function (types) {
            var curIndex = this.stack.length - 1;
            while (curIndex > 0 && types.indexOf(this.stack[curIndex].type) === -1) {
                curIndex--;
            }
            return this.stack[curIndex];
        },
        firstParent: function (types) {
            var curIndex = this.stack.length - 2;
            while (curIndex > 0 && types.indexOf(this.stack[curIndex].type) === -1) {
                curIndex--;
            }
            return this.stack[curIndex];
        },
        popUntil: function (types) {
            while (types.indexOf(this.top().type) === -1 && !this.isRootTop()) {
                this.stack.pop();
            }
            return this.top();
        },
        addTo: function (types, type) {
            var cur = this.popUntil(types);
            ensureChildren(cur).children.push(type);
        },
        addToAndPush: function (types, type) {
            this.addTo(types, type);
            this.stack.push(type);
        },
        push: function (type) {
            this.stack.push(type);
        },
        topLastChild: function () {
            return last(this.top().children);
        },
        replaceTopLastChild: function (type) {
            var children = ensureChildren(this.top()).children;
            children.pop();
            children.push(type);
            return type;
        },
        replaceTopLastChildAndPush: function (type) {
            this.replaceTopLastChild(type);
            this.stack.push(type);
        },
        replaceTopAndPush: function (type) {
            var children;
            if (this.top() === this.root) {
                children = ensureChildren(this.top()).children;
            } else {
                this.stack.pop();
                children = ensureChildren(this.top()).children;
            }
            children.pop();
            children.push(type);
            this.stack.push(type);
            return type;
        }
    });
    var convertKeyToLookup = function (key) {
        var lastPath = key.lastIndexOf('./');
        var lastDot = key.lastIndexOf('.');
        if (lastDot > lastPath) {
            return key.substr(0, lastDot) + '@' + key.substr(lastDot + 1);
        }
        var firstNonPathCharIndex = lastPath === -1 ? 0 : lastPath + 2;
        var firstNonPathChar = key.charAt(firstNonPathCharIndex);
        if (firstNonPathChar === '.' || firstNonPathChar === '@') {
            return key.substr(0, firstNonPathCharIndex) + '@' + key.substr(firstNonPathCharIndex + 1);
        } else {
            return key.substr(0, firstNonPathCharIndex) + '@' + key.substr(firstNonPathCharIndex);
        }
    };
    var convertToAtLookup = function (ast) {
        if (ast.type === 'Lookup') {
            ast.key = convertKeyToLookup(ast.key);
        }
        return ast;
    };
    var convertToHelperIfTopIsLookup = function (stack) {
        var top = stack.top();
        if (top && top.type === 'Lookup') {
            var base = stack.stack[stack.stack.length - 2];
            if (base.type !== 'Helper' && base) {
                stack.replaceTopAndPush({
                    type: 'Helper',
                    method: top
                });
            }
        }
    };
    var expression = {
        convertKeyToLookup: convertKeyToLookup,
        Literal: Literal,
        Lookup: Lookup,
        ScopeLookup: ScopeLookup,
        Arg: Arg,
        Hash: Hash,
        Hashes: Hashes,
        Call: Call,
        Helper: Helper,
        HelperLookup: HelperLookup,
        HelperScopeLookup: HelperScopeLookup,
        Bracket: Bracket,
        SetIdentifier: function (value) {
            this.value = value;
        },
        tokenize: function (expression) {
            var tokens = [];
            (expression.trim() + ' ').replace(tokensRegExp, function (whole, arg) {
                if (bracketSpaceRegExp.test(arg)) {
                    tokens.push(arg[0]);
                    tokens.push(arg.slice(1));
                } else {
                    tokens.push(arg);
                }
            });
            return tokens;
        },
        lookupRules: {
            'default': function (ast, methodType, isArg) {
                var name = (methodType === 'Helper' && !ast.root ? 'Helper' : '') + (isArg ? 'Scope' : '') + 'Lookup';
                return expression[name];
            },
            'method': function (ast, methodType, isArg) {
                return ScopeLookup;
            }
        },
        methodRules: {
            'default': function (ast) {
                return ast.type === 'Call' ? Call : Helper;
            },
            'call': function (ast) {
                return Call;
            }
        },
        parse: function (expressionString, options) {
            options = options || {};
            var ast = this.ast(expressionString);
            if (!options.lookupRule) {
                options.lookupRule = 'default';
            }
            if (typeof options.lookupRule === 'string') {
                options.lookupRule = expression.lookupRules[options.lookupRule];
            }
            if (!options.methodRule) {
                options.methodRule = 'default';
            }
            if (typeof options.methodRule === 'string') {
                options.methodRule = expression.methodRules[options.methodRule];
            }
            var expr = this.hydrateAst(ast, options, options.baseMethodType || 'Helper');
            return expr;
        },
        hydrateAst: function (ast, options, methodType, isArg) {
            var hashes;
            if (ast.type === 'Lookup') {
                return new (options.lookupRule(ast, methodType, isArg))(ast.key, ast.root && this.hydrateAst(ast.root, options, methodType));
            } else if (ast.type === 'Literal') {
                return new Literal(ast.value);
            } else if (ast.type === 'Arg') {
                return new Arg(this.hydrateAst(ast.children[0], options, methodType, isArg), { compute: true });
            } else if (ast.type === 'Hash') {
                throw new Error('');
            } else if (ast.type === 'Hashes') {
                hashes = {};
                each(ast.children, function (hash) {
                    hashes[hash.prop] = this.hydrateAst(hash.children[0], options, methodType, true);
                }, this);
                return new Hashes(hashes);
            } else if (ast.type === 'Call' || ast.type === 'Helper') {
                hashes = {};
                var args = [], children = ast.children, ExpressionType = options.methodRule(ast);
                if (children) {
                    for (var i = 0; i < children.length; i++) {
                        var child = children[i];
                        if (child.type === 'Hashes' && ast.type === 'Helper' && ExpressionType !== Call) {
                            each(child.children, function (hash) {
                                hashes[hash.prop] = this.hydrateAst(hash.children[0], options, ast.type, true);
                            }, this);
                        } else {
                            args.push(this.hydrateAst(child, options, ast.type, true));
                        }
                    }
                }
                return new ExpressionType(this.hydrateAst(ast.method, options, ast.type), args, hashes);
            } else if (ast.type === 'Bracket') {
                return new Bracket(this.hydrateAst(ast.children[0], options), ast.root ? this.hydrateAst(ast.root, options) : undefined);
            }
        },
        ast: function (expression) {
            var tokens = this.tokenize(expression);
            return this.parseAst(tokens, { index: 0 });
        },
        parseAst: function (tokens, cursor) {
            var stack = new Stack(), top, firstParent, lastToken;
            while (cursor.index < tokens.length) {
                var token = tokens[cursor.index], nextToken = tokens[cursor.index + 1];
                cursor.index++;
                if (literalRegExp.test(token)) {
                    convertToHelperIfTopIsLookup(stack);
                    firstParent = stack.first([
                        'Helper',
                        'Call',
                        'Hash',
                        'Bracket'
                    ]);
                    if (firstParent.type === 'Hash' && (firstParent.children && firstParent.children.length > 0)) {
                        stack.addTo([
                            'Helper',
                            'Call',
                            'Bracket'
                        ], {
                            type: 'Literal',
                            value: utils.jsonParse(token)
                        });
                    } else if (firstParent.type === 'Bracket' && (firstParent.children && firstParent.children.length > 0)) {
                        stack.addTo([
                            'Helper',
                            'Call',
                            'Hash'
                        ], {
                            type: 'Literal',
                            value: utils.jsonParse(token)
                        });
                    } else {
                        stack.addTo([
                            'Helper',
                            'Call',
                            'Hash',
                            'Bracket'
                        ], {
                            type: 'Literal',
                            value: utils.jsonParse(token)
                        });
                    }
                } else if (nextToken === '=') {
                    top = stack.top();
                    if (top && top.type === 'Lookup') {
                        firstParent = stack.firstParent([
                            'Call',
                            'Helper',
                            'Hash'
                        ]);
                        if (firstParent.type === 'Call' || firstParent.type === 'Root') {
                            stack.popUntil(['Call']);
                            top = stack.top();
                            stack.replaceTopAndPush({
                                type: 'Helper',
                                method: top.type === 'Root' ? last(top.children) : top
                            });
                        }
                    }
                    firstParent = stack.firstParent([
                        'Call',
                        'Helper',
                        'Hashes'
                    ]);
                    var hash = {
                        type: 'Hash',
                        prop: token
                    };
                    if (firstParent.type === 'Hashes') {
                        stack.addToAndPush(['Hashes'], hash);
                    } else {
                        stack.addToAndPush([
                            'Helper',
                            'Call'
                        ], {
                            type: 'Hashes',
                            children: [hash]
                        });
                        stack.push(hash);
                    }
                    cursor.index++;
                } else if (keyRegExp.test(token)) {
                    lastToken = stack.topLastChild();
                    firstParent = stack.first([
                        'Helper',
                        'Call',
                        'Hash',
                        'Bracket'
                    ]);
                    if (lastToken && lastToken.type === 'Call' && isAddingToExpression(token)) {
                        stack.replaceTopLastChildAndPush({
                            type: 'Lookup',
                            root: lastToken,
                            key: token.slice(1)
                        });
                    } else if (firstParent.type === 'Bracket') {
                        if (!(firstParent.children && firstParent.children.length > 0)) {
                            stack.addToAndPush(['Bracket'], {
                                type: 'Lookup',
                                key: token
                            });
                        } else {
                            if (stack.first([
                                    'Helper',
                                    'Call',
                                    'Hash',
                                    'Arg'
                                ]).type === 'Helper' && token[0] !== '.') {
                                stack.addToAndPush(['Helper'], {
                                    type: 'Lookup',
                                    key: token
                                });
                            } else {
                                stack.replaceTopAndPush({
                                    type: 'Lookup',
                                    key: token.slice(1),
                                    root: firstParent
                                });
                            }
                        }
                    } else {
                        convertToHelperIfTopIsLookup(stack);
                        stack.addToAndPush([
                            'Helper',
                            'Call',
                            'Hash',
                            'Arg',
                            'Bracket'
                        ], {
                            type: 'Lookup',
                            key: token
                        });
                    }
                } else if (token === '~') {
                    convertToHelperIfTopIsLookup(stack);
                    stack.addToAndPush([
                        'Helper',
                        'Call',
                        'Hash'
                    ], {
                        type: 'Arg',
                        key: token
                    });
                } else if (token === '(') {
                    top = stack.top();
                    if (top.type === 'Lookup') {
                        stack.replaceTopAndPush({
                            type: 'Call',
                            method: convertToAtLookup(top)
                        });
                    } else {
                        throw new Error('Unable to understand expression ' + tokens.join(''));
                    }
                } else if (token === ')') {
                    stack.popTo(['Call']);
                } else if (token === ',') {
                    stack.popUntil(['Call']);
                } else if (token === '[') {
                    top = stack.top();
                    lastToken = stack.topLastChild();
                    if (lastToken && lastToken.type === 'Call') {
                        stack.replaceTopAndPush({
                            type: 'Bracket',
                            root: lastToken
                        });
                    } else if (top.type === 'Lookup' || top.type === 'Bracket') {
                        stack.replaceTopAndPush({
                            type: 'Bracket',
                            root: top
                        });
                    } else if (top.type === 'Call') {
                        stack.addToAndPush(['Call'], { type: 'Bracket' });
                    } else if (top === ' ') {
                        stack.popUntil(['Lookup']);
                        convertToHelperIfTopIsLookup(stack);
                        stack.addToAndPush([
                            'Helper',
                            'Call',
                            'Hash'
                        ], { type: 'Bracket' });
                    } else {
                        stack.replaceTopAndPush({ type: 'Bracket' });
                    }
                } else if (token === ']') {
                    stack.pop();
                } else if (token === ' ') {
                    stack.push(token);
                }
            }
            return stack.root.children[0];
        }
    };
    module.exports = expression;
});
/*can-view-model@3.1.3#can-view-model*/
define('can-view-model@3.1.3#can-view-model', function (require, exports, module) {
    'use strict';
    var domData = require('can-util/dom/data/data');
    var SimpleMap = require('can-simple-map');
    var types = require('can-types');
    var ns = require('can-namespace');
    var getDocument = require('can-util/dom/document/document');
    module.exports = ns.viewModel = function (el, attr, val) {
        el = typeof el === 'string' ? getDocument().querySelector(el) : el;
        var scope = domData.get.call(el, 'viewModel');
        if (!scope) {
            scope = types.DefaultMap ? new types.DefaultMap() : new SimpleMap();
            domData.set.call(el, 'viewModel', scope);
        }
        switch (arguments.length) {
        case 0:
        case 1:
            return scope;
        case 2:
            return 'attr' in scope ? scope.attr(attr) : scope[attr];
        default:
            if ('attr' in scope) {
                scope.attr(attr, val);
            } else {
                scope[attr] = val;
            }
            return el;
        }
    };
});
/*can-stache-bindings@3.0.12#can-stache-bindings*/
define('can-stache-bindings@3.0.12#can-stache-bindings', function (require, exports, module) {
    var expression = require('can-stache/src/expression');
    var viewCallbacks = require('can-view-callbacks');
    var live = require('can-view-live');
    var Scope = require('can-view-scope');
    var canViewModel = require('can-view-model');
    var canEvent = require('can-event');
    var canBatch = require('can-event/batch/batch');
    var compute = require('can-compute');
    var observeReader = require('can-observation/reader/reader');
    var Observation = require('can-observation');
    var assign = require('can-util/js/assign/assign');
    var makeArray = require('can-util/js/make-array/make-array');
    var each = require('can-util/js/each/each');
    var string = require('can-util/js/string/string');
    var dev = require('can-util/js/dev/dev');
    var types = require('can-types');
    var last = require('can-util/js/last/last');
    var getMutationObserver = require('can-util/dom/mutation-observer/mutation-observer');
    var domEvents = require('can-util/dom/events/events');
    require('can-util/dom/events/removed/removed');
    var domData = require('can-util/dom/data/data');
    var attr = require('can-util/dom/attr/attr');
    var canLog = require('can-util/js/log/log');
    var behaviors = {
        viewModel: function (el, tagData, makeViewModel, initialViewModelData) {
            initialViewModelData = initialViewModelData || {};
            var bindingsSemaphore = {}, viewModel, onCompleteBindings = [], onTeardowns = {}, bindingInfos = {}, attributeViewModelBindings = assign({}, initialViewModelData);
            each(makeArray(el.attributes), function (node) {
                var dataBinding = makeDataBinding(node, el, {
                    templateType: tagData.templateType,
                    scope: tagData.scope,
                    semaphore: bindingsSemaphore,
                    getViewModel: function () {
                        return viewModel;
                    },
                    attributeViewModelBindings: attributeViewModelBindings,
                    alreadyUpdatedChild: true,
                    nodeList: tagData.parentNodeList
                });
                if (dataBinding) {
                    if (dataBinding.onCompleteBinding) {
                        if (dataBinding.bindingInfo.parentToChild && dataBinding.value !== undefined) {
                            initialViewModelData[cleanVMName(dataBinding.bindingInfo.childName)] = dataBinding.value;
                        }
                        onCompleteBindings.push(dataBinding.onCompleteBinding);
                    }
                    onTeardowns[node.name] = dataBinding.onTeardown;
                }
            });
            viewModel = makeViewModel(initialViewModelData);
            for (var i = 0, len = onCompleteBindings.length; i < len; i++) {
                onCompleteBindings[i]();
            }
            domEvents.addEventListener.call(el, 'attributes', function (ev) {
                var attrName = ev.attributeName, value = el.getAttribute(attrName);
                if (onTeardowns[attrName]) {
                    onTeardowns[attrName]();
                }
                var parentBindingWasAttribute = bindingInfos[attrName] && bindingInfos[attrName].parent === 'attribute';
                if (value !== null || parentBindingWasAttribute) {
                    var dataBinding = makeDataBinding({
                        name: attrName,
                        value: value
                    }, el, {
                        templateType: tagData.templateType,
                        scope: tagData.scope,
                        semaphore: {},
                        getViewModel: function () {
                            return viewModel;
                        },
                        attributeViewModelBindings: attributeViewModelBindings,
                        initializeValues: true,
                        nodeList: tagData.parentNodeList
                    });
                    if (dataBinding) {
                        if (dataBinding.onCompleteBinding) {
                            dataBinding.onCompleteBinding();
                        }
                        bindingInfos[attrName] = dataBinding.bindingInfo;
                        onTeardowns[attrName] = dataBinding.onTeardown;
                    }
                }
            });
            return function () {
                for (var attrName in onTeardowns) {
                    onTeardowns[attrName]();
                }
            };
        },
        data: function (el, attrData) {
            if (domData.get.call(el, 'preventDataBindings')) {
                return;
            }
            var viewModel = canViewModel(el), semaphore = {}, teardown;
            var dataBinding = makeDataBinding({
                name: attrData.attributeName,
                value: el.getAttribute(attrData.attributeName),
                nodeList: attrData.nodeList
            }, el, {
                templateType: attrData.templateType,
                scope: attrData.scope,
                semaphore: semaphore,
                getViewModel: function () {
                    return viewModel;
                }
            });
            if (dataBinding.onCompleteBinding) {
                dataBinding.onCompleteBinding();
            }
            teardown = dataBinding.onTeardown;
            canEvent.one.call(el, 'removed', function () {
                teardown();
            });
            domEvents.addEventListener.call(el, 'attributes', function (ev) {
                var attrName = ev.attributeName, value = el.getAttribute(attrName);
                if (attrName === attrData.attributeName) {
                    if (teardown) {
                        teardown();
                    }
                    if (value !== null) {
                        var dataBinding = makeDataBinding({
                            name: attrName,
                            value: value
                        }, el, {
                            templateType: attrData.templateType,
                            scope: attrData.scope,
                            semaphore: semaphore,
                            getViewModel: function () {
                                return viewModel;
                            },
                            initializeValues: true,
                            nodeList: attrData.nodeList
                        });
                        if (dataBinding) {
                            if (dataBinding.onCompleteBinding) {
                                dataBinding.onCompleteBinding();
                            }
                            teardown = dataBinding.onTeardown;
                        }
                    }
                }
            });
        },
        reference: function (el, attrData) {
            if (el.getAttribute(attrData.attributeName)) {
                canLog.warn('*reference attributes can only export the view model.');
            }
            var name = string.camelize(attrData.attributeName.substr(1).toLowerCase());
            var viewModel = canViewModel(el);
            var refs = attrData.scope.getRefs();
            refs._context.attr('*' + name, viewModel);
        },
        event: function (el, data) {
            var attributeName = data.attributeName, legacyBinding = attributeName.indexOf('can-') === 0, event = attributeName.indexOf('can-') === 0 ? attributeName.substr('can-'.length) : removeBrackets(attributeName, '(', ')'), onBindElement = legacyBinding;
            if (event.charAt(0) === '$') {
                event = event.substr(1);
                onBindElement = true;
            }
            var handler = function (ev) {
                var attrVal = el.getAttribute(attributeName);
                if (!attrVal) {
                    return;
                }
                var viewModel = canViewModel(el);
                var expr = expression.parse(removeBrackets(attrVal), {
                    lookupRule: 'method',
                    methodRule: 'call'
                });
                if (!(expr instanceof expression.Call) && !(expr instanceof expression.Helper)) {
                    var defaultArgs = [
                        data.scope._context,
                        el
                    ].concat(makeArray(arguments)).map(function (data) {
                        return new expression.Arg(new expression.Literal(data));
                    });
                    expr = new expression.Call(expr, defaultArgs, {});
                }
                var localScope = data.scope.add({
                    '@element': el,
                    '@event': ev,
                    '@viewModel': viewModel,
                    '@scope': data.scope,
                    '@context': data.scope._context,
                    '%element': this,
                    '$element': types.wrapElement(el),
                    '%event': ev,
                    '%viewModel': viewModel,
                    '%scope': data.scope,
                    '%context': data.scope._context,
                    '%arguments': arguments
                }, { notContext: true });
                var scopeData = localScope.read(expr.methodExpr.key, { isArgument: true });
                if (!scopeData.value) {
                    scopeData = localScope.read(expr.methodExpr.key, { isArgument: true });
                    return null;
                }
                var args = expr.args(localScope, null)();
                return scopeData.value.apply(scopeData.parent, args);
            };
            if (special[event]) {
                var specialData = special[event](data, el, handler);
                handler = specialData.handler;
                event = specialData.event;
            }
            canEvent.on.call(onBindElement ? el : canViewModel(el), event, handler);
            var attributesHandler = function (ev) {
                if (ev.attributeName === attributeName && !this.getAttribute(attributeName)) {
                    canEvent.off.call(onBindElement ? el : canViewModel(el), event, handler);
                    canEvent.off.call(el, 'attributes', attributesHandler);
                }
            };
            canEvent.on.call(el, 'attributes', attributesHandler);
        },
        value: function (el, data) {
            var propName = '$value', attrValue = removeBrackets(el.getAttribute('can-value')).trim(), nodeName = el.nodeName.toLowerCase(), elType = nodeName === 'input' && (el.type || el.getAttribute('type')), getterSetter;
            if (nodeName === 'input' && (elType === 'checkbox' || elType === 'radio')) {
                var property = getComputeFrom.scope(el, data.scope, attrValue, {}, true);
                if (el.type === 'checkbox') {
                    var trueValue = attr.has(el, 'can-true-value') ? el.getAttribute('can-true-value') : true, falseValue = attr.has(el, 'can-false-value') ? el.getAttribute('can-false-value') : false;
                    getterSetter = compute(function (newValue) {
                        if (arguments.length) {
                            property(newValue ? trueValue : falseValue);
                        } else {
                            return property() == trueValue;
                        }
                    });
                } else if (elType === 'radio') {
                    getterSetter = compute(function (newValue) {
                        if (arguments.length) {
                            if (newValue) {
                                property(el.value);
                            }
                        } else {
                            return property() == el.value;
                        }
                    });
                }
                propName = '$checked';
                attrValue = 'getterSetter';
                data.scope = new Scope({ getterSetter: getterSetter });
            } else if (isContentEditable(el)) {
                propName = '$innerHTML';
            }
            var dataBinding = makeDataBinding({
                name: '{(' + propName + '})',
                value: attrValue
            }, el, {
                templateType: data.templateType,
                scope: data.scope,
                semaphore: {},
                initializeValues: true,
                legacyBindings: true,
                syncChildWithParent: true
            });
            canEvent.one.call(el, 'removed', function () {
                dataBinding.onTeardown();
            });
        }
    };
    viewCallbacks.attr(/^\{[^\}]+\}$/, behaviors.data);
    viewCallbacks.attr(/\*[\w\.\-_]+/, behaviors.reference);
    viewCallbacks.attr(/^\([\$?\w\.]+\)$/, behaviors.event);
    viewCallbacks.attr(/can-[\w\.]+/, behaviors.event);
    viewCallbacks.attr('can-value', behaviors.value);
    var getComputeFrom = {
        scope: function (el, scope, scopeProp, bindingData, mustBeACompute, stickyCompute) {
            if (!scopeProp) {
                return compute();
            } else {
                if (mustBeACompute) {
                    var parentExpression = expression.parse(scopeProp, { baseMethodType: 'Call' });
                    return parentExpression.value(scope, new Scope.Options({}));
                } else {
                    return function (newVal) {
                        scope.attr(cleanVMName(scopeProp), newVal);
                    };
                }
            }
        },
        viewModel: function (el, scope, vmName, bindingData, mustBeACompute, stickyCompute) {
            var setName = cleanVMName(vmName);
            if (mustBeACompute) {
                return compute(function (newVal) {
                    var viewModel = bindingData.getViewModel();
                    if (arguments.length) {
                        if (types.isMapLike(viewModel)) {
                            observeReader.set(viewModel, setName, newVal);
                        } else {
                            viewModel[setName] = newVal;
                        }
                    } else {
                        return vmName === '.' ? viewModel : observeReader.read(viewModel, observeReader.reads(vmName), {}).value;
                    }
                });
            } else {
                return function (newVal) {
                    var childCompute;
                    var viewModel = bindingData.getViewModel();
                    function updateViewModel(value, options) {
                        if (types.isMapLike(viewModel)) {
                            observeReader.set(viewModel, setName, value, options);
                        } else {
                            viewModel[setName] = value;
                        }
                    }
                    if (stickyCompute) {
                        childCompute = observeReader.get(viewModel, setName, { readCompute: false });
                        if (!childCompute || !childCompute.isComputed) {
                            childCompute = compute();
                            updateViewModel(childCompute, { readCompute: false });
                        }
                        childCompute(newVal);
                    } else {
                        updateViewModel(newVal);
                    }
                };
            }
        },
        attribute: function (el, scope, prop, bindingData, mustBeACompute, stickyCompute, event) {
            if (!event) {
                if (attr.special[prop] && attr.special[prop].addEventListener) {
                    event = prop;
                } else {
                    event = 'change';
                }
            }
            var hasChildren = el.nodeName.toLowerCase() === 'select', isMultiselectValue = prop === 'value' && hasChildren && el.multiple, set = function (newVal) {
                    if (bindingData.legacyBindings && hasChildren && 'selectedIndex' in el && prop === 'value') {
                        attr.setAttrOrProp(el, prop, newVal == null ? '' : newVal);
                    } else {
                        attr.setAttrOrProp(el, prop, newVal);
                    }
                    return newVal;
                }, get = function () {
                    return attr.get(el, prop);
                };
            if (isMultiselectValue) {
                prop = 'values';
            }
            return compute(get(), {
                on: function (updater) {
                    canEvent.on.call(el, event, updater);
                },
                off: function (updater) {
                    canEvent.off.call(el, event, updater);
                },
                get: get,
                set: set
            });
        }
    };
    var bind = {
        childToParent: function (el, parentCompute, childCompute, bindingsSemaphore, attrName, syncChild) {
            var parentUpdateIsFunction = typeof parentCompute === 'function';
            var updateParent = function (ev, newVal) {
                if (!bindingsSemaphore[attrName]) {
                    if (parentUpdateIsFunction) {
                        parentCompute(newVal);
                        if (syncChild) {
                            if (parentCompute() !== childCompute()) {
                                bindingsSemaphore[attrName] = (bindingsSemaphore[attrName] || 0) + 1;
                                childCompute(parentCompute());
                                Observation.afterUpdateAndNotify(function () {
                                    --bindingsSemaphore[attrName];
                                });
                            }
                        }
                    } else if (types.isMapLike(parentCompute)) {
                        parentCompute.attr(newVal, true);
                    }
                }
            };
            if (childCompute && childCompute.isComputed) {
                childCompute.bind('change', updateParent);
            }
            return updateParent;
        },
        parentToChild: function (el, parentCompute, childUpdate, bindingsSemaphore, attrName) {
            var updateChild = function (ev, newValue) {
                bindingsSemaphore[attrName] = (bindingsSemaphore[attrName] || 0) + 1;
                canBatch.start();
                childUpdate(newValue);
                Observation.afterUpdateAndNotify(function () {
                    --bindingsSemaphore[attrName];
                });
                canBatch.stop();
            };
            if (parentCompute && parentCompute.isComputed) {
                parentCompute.bind('change', updateChild);
            }
            return updateChild;
        }
    };
    var DOUBLE_CURLY_BRACE_REGEX = /\{\{/g;
    var getBindingInfo = function (node, attributeViewModelBindings, templateType, tagName) {
        var bindingInfo, attributeName = node.name, attributeValue = node.value || '';
        var matches = attributeName.match(bindingsRegExp);
        if (!matches) {
            var ignoreAttribute = ignoreAttributesRegExp.test(attributeName);
            var vmName = string.camelize(attributeName);
            if (ignoreAttribute || viewCallbacks.attr(attributeName)) {
                return;
            }
            var syntaxRight = attributeValue[0] === '{' && last(attributeValue) === '}';
            var isAttributeToChild = templateType === 'legacy' ? attributeViewModelBindings[vmName] : !syntaxRight;
            var scopeName = syntaxRight ? attributeValue.substr(1, attributeValue.length - 2) : attributeValue;
            if (isAttributeToChild) {
                return {
                    bindingAttributeName: attributeName,
                    parent: 'attribute',
                    parentName: attributeName,
                    child: 'viewModel',
                    childName: vmName,
                    parentToChild: true,
                    childToParent: true
                };
            } else {
                return {
                    bindingAttributeName: attributeName,
                    parent: 'scope',
                    parentName: scopeName,
                    child: 'viewModel',
                    childName: vmName,
                    parentToChild: true,
                    childToParent: true
                };
            }
        }
        var twoWay = !!matches[1], childToParent = twoWay || !!matches[2], parentToChild = twoWay || !childToParent;
        var childName = matches[3];
        var isDOM = childName.charAt(0) === '$';
        if (isDOM) {
            bindingInfo = {
                parent: 'scope',
                child: 'attribute',
                childToParent: childToParent,
                parentToChild: parentToChild,
                bindingAttributeName: attributeName,
                childName: childName.substr(1),
                parentName: attributeValue,
                initializeValues: true
            };
            if (tagName === 'select') {
                bindingInfo.stickyParentToChild = true;
            }
            return bindingInfo;
        } else {
            bindingInfo = {
                parent: 'scope',
                child: 'viewModel',
                childToParent: childToParent,
                parentToChild: parentToChild,
                bindingAttributeName: attributeName,
                childName: string.camelize(childName),
                parentName: attributeValue,
                initializeValues: true
            };
            if (attributeValue.trim().charAt(0) === '~') {
                bindingInfo.stickyParentToChild = true;
            }
            return bindingInfo;
        }
    };
    var bindingsRegExp = /\{(\()?(\^)?([^\}\)]+)\)?\}/, ignoreAttributesRegExp = /^(data-view-id|class|id|\[[\w\.-]+\]|#[\w\.-])$/i;
    var makeDataBinding = function (node, el, bindingData) {
        var bindingInfo = getBindingInfo(node, bindingData.attributeViewModelBindings, bindingData.templateType, el.nodeName.toLowerCase());
        if (!bindingInfo) {
            return;
        }
        bindingInfo.alreadyUpdatedChild = bindingData.alreadyUpdatedChild;
        if (bindingData.initializeValues) {
            bindingInfo.initializeValues = true;
        }
        var parentCompute = getComputeFrom[bindingInfo.parent](el, bindingData.scope, bindingInfo.parentName, bindingData, bindingInfo.parentToChild), childCompute = getComputeFrom[bindingInfo.child](el, bindingData.scope, bindingInfo.childName, bindingData, bindingInfo.childToParent, bindingInfo.stickyParentToChild && parentCompute), updateParent, updateChild, childLifecycle;
        if (bindingData.nodeList) {
            if (parentCompute && parentCompute.isComputed) {
                parentCompute.computeInstance.setPrimaryDepth(bindingData.nodeList.nesting + 1);
            }
            if (childCompute && childCompute.isComputed) {
                childCompute.computeInstance.setPrimaryDepth(bindingData.nodeList.nesting + 1);
            }
        }
        if (bindingInfo.parentToChild) {
            updateChild = bind.parentToChild(el, parentCompute, childCompute, bindingData.semaphore, bindingInfo.bindingAttributeName);
        }
        var completeBinding = function () {
            if (bindingInfo.childToParent) {
                updateParent = bind.childToParent(el, parentCompute, childCompute, bindingData.semaphore, bindingInfo.bindingAttributeName, bindingData.syncChildWithParent);
            } else if (bindingInfo.stickyParentToChild) {
                childCompute.bind('change', childLifecycle = function () {
                });
            }
            if (bindingInfo.initializeValues) {
                initializeValues(bindingInfo, childCompute, parentCompute, updateChild, updateParent);
            }
        };
        var onTeardown = function () {
            unbindUpdate(parentCompute, updateChild);
            unbindUpdate(childCompute, updateParent);
            unbindUpdate(childCompute, childLifecycle);
        };
        if (bindingInfo.child === 'viewModel') {
            return {
                value: bindingInfo.stickyParentToChild ? compute(getValue(parentCompute)) : getValue(parentCompute),
                onCompleteBinding: completeBinding,
                bindingInfo: bindingInfo,
                onTeardown: onTeardown
            };
        } else {
            completeBinding();
            return {
                bindingInfo: bindingInfo,
                onTeardown: onTeardown
            };
        }
    };
    var initializeValues = function (bindingInfo, childCompute, parentCompute, updateChild, updateParent) {
        var doUpdateParent = false;
        if (bindingInfo.parentToChild && !bindingInfo.childToParent) {
        } else if (!bindingInfo.parentToChild && bindingInfo.childToParent) {
            doUpdateParent = true;
        } else if (getValue(childCompute) === undefined) {
        } else if (getValue(parentCompute) === undefined) {
            doUpdateParent = true;
        }
        if (doUpdateParent) {
            updateParent({}, getValue(childCompute));
        } else {
            if (!bindingInfo.alreadyUpdatedChild) {
                updateChild({}, getValue(parentCompute));
            }
        }
    };
    if (!getMutationObserver()) {
        var updateSelectValue = function (el) {
            var bindingCallback = domData.get.call(el, 'canBindingCallback');
            if (bindingCallback) {
                bindingCallback.onMutation(el);
            }
        };
        live.registerChildMutationCallback('select', updateSelectValue);
        live.registerChildMutationCallback('optgroup', function (el) {
            updateSelectValue(el.parentNode);
        });
    }
    var isContentEditable = function () {
            var values = {
                '': true,
                'true': true,
                'false': false
            };
            var editable = function (el) {
                if (!el || !el.getAttribute) {
                    return;
                }
                var attr = el.getAttribute('contenteditable');
                return values[attr];
            };
            return function (el) {
                var val = editable(el);
                if (typeof val === 'boolean') {
                    return val;
                } else {
                    return !!editable(el.parentNode);
                }
            };
        }(), removeBrackets = function (value, open, close) {
            open = open || '{';
            close = close || '}';
            if (value[0] === open && value[value.length - 1] === close) {
                return value.substr(1, value.length - 2);
            }
            return value;
        }, getValue = function (value) {
            return value && value.isComputed ? value() : value;
        }, unbindUpdate = function (compute, updateOther) {
            if (compute && compute.isComputed && typeof updateOther === 'function') {
                compute.unbind('change', updateOther);
            }
        }, cleanVMName = function (name) {
            return name.replace(/@/g, '');
        };
    var special = {
        enter: function (data, el, original) {
            return {
                event: 'keyup',
                handler: function (ev) {
                    if (ev.keyCode === 13 || ev.key === 'Enter') {
                        return original.call(this, ev);
                    }
                }
            };
        }
    };
    module.exports = {
        behaviors: behaviors,
        getBindingInfo: getBindingInfo,
        special: special
    };
});
/*can-util@3.3.2#dom/events/inserted/inserted*/
define('can-util@3.3.2#dom/events/inserted/inserted', function (require, exports, module) {
    var makeMutationEvent = require('../make-mutation-event/make-mutation-event');
    makeMutationEvent('inserted', 'addedNodes');
});
/*can-component@3.0.6#can-component*/
define('can-component@3.0.6#can-component', function (require, exports, module) {
    var ComponentControl = require('./control/control');
    var namespace = require('can-namespace');
    var Construct = require('can-construct');
    var stacheBindings = require('can-stache-bindings');
    var Scope = require('can-view-scope');
    var viewCallbacks = require('can-view-callbacks');
    var nodeLists = require('can-view-nodelist');
    var domData = require('can-util/dom/data/data');
    var domMutate = require('can-util/dom/mutate/mutate');
    var getChildNodes = require('can-util/dom/child-nodes/child-nodes');
    var domDispatch = require('can-util/dom/dispatch/dispatch');
    var types = require('can-types');
    var string = require('can-util/js/string/string');
    var canEach = require('can-util/js/each/each');
    var isFunction = require('can-util/js/is-function/is-function');
    var canLog = require('can-util/js/log/log');
    require('can-util/dom/events/inserted/inserted');
    require('can-util/dom/events/removed/removed');
    require('can-view-model');
    var Component = Construct.extend({
        setup: function () {
            Construct.setup.apply(this, arguments);
            if (Component) {
                var self = this;
                this.Control = ComponentControl.extend(this.prototype.events);
                var protoViewModel = this.prototype.viewModel || this.prototype.scope;
                if (protoViewModel && this.prototype.ViewModel) {
                    throw new Error('Cannot provide both a ViewModel and a viewModel property');
                }
                var vmName = string.capitalize(string.camelize(this.prototype.tag)) + 'VM';
                if (this.prototype.ViewModel) {
                    if (typeof this.prototype.ViewModel === 'function') {
                        this.ViewModel = this.prototype.ViewModel;
                    } else {
                        this.ViewModel = types.DefaultMap.extend(vmName, this.prototype.ViewModel);
                    }
                } else {
                    if (protoViewModel) {
                        if (typeof protoViewModel === 'function') {
                            if (types.isMapLike(protoViewModel.prototype)) {
                                this.ViewModel = protoViewModel;
                            } else {
                                this.viewModelHandler = protoViewModel;
                            }
                        } else {
                            if (types.isMapLike(protoViewModel)) {
                                this.viewModelInstance = protoViewModel;
                            } else {
                                this.ViewModel = types.DefaultMap.extend(vmName, protoViewModel);
                            }
                        }
                    } else {
                        this.ViewModel = types.DefaultMap.extend(vmName, {});
                    }
                }
                if (this.prototype.template) {
                    this.renderer = this.prototype.template;
                }
                if (this.prototype.view) {
                    this.renderer = this.prototype.view;
                }
                viewCallbacks.tag(this.prototype.tag, function (el, options) {
                    new self(el, options);
                });
            }
        }
    }, {
        setup: function (el, componentTagData) {
            var component = this;
            var lexicalContent = (typeof this.leakScope === 'undefined' ? true : !this.leakScope) && !!(this.template || this.view);
            var teardownFunctions = [];
            var initialViewModelData = {};
            var callTeardownFunctions = function () {
                for (var i = 0, len = teardownFunctions.length; i < len; i++) {
                    teardownFunctions[i]();
                }
            };
            var setupBindings = !domData.get.call(el, 'preventDataBindings');
            var viewModel, frag;
            var teardownBindings;
            if (setupBindings) {
                var setupFn = componentTagData.setupBindings || function (el, callback, data) {
                    return stacheBindings.behaviors.viewModel(el, componentTagData, callback, data);
                };
                teardownBindings = setupFn(el, function (initialViewModelData) {
                    var ViewModel = component.constructor.ViewModel, viewModelHandler = component.constructor.viewModelHandler, viewModelInstance = component.constructor.viewModelInstance;
                    if (viewModelHandler) {
                        var scopeResult = viewModelHandler.call(component, initialViewModelData, componentTagData.scope, el);
                        if (types.isMapLike(scopeResult)) {
                            viewModelInstance = scopeResult;
                        } else if (types.isMapLike(scopeResult.prototype)) {
                            ViewModel = scopeResult;
                        } else {
                            ViewModel = types.DefaultMap.extend(scopeResult);
                        }
                    }
                    if (ViewModel) {
                        viewModelInstance = new component.constructor.ViewModel(initialViewModelData);
                    }
                    viewModel = viewModelInstance;
                    return viewModelInstance;
                }, initialViewModelData);
            }
            this.viewModel = viewModel;
            domData.set.call(el, 'viewModel', viewModel);
            domData.set.call(el, 'preventDataBindings', true);
            var shadowScope;
            if (lexicalContent) {
                shadowScope = Scope.refsScope().add(this.viewModel, { viewModel: true });
            } else {
                shadowScope = (this.constructor.renderer ? componentTagData.scope.add(new Scope.Refs()) : componentTagData.scope).add(this.viewModel, { viewModel: true });
            }
            var options = { helpers: {} }, addHelper = function (name, fn) {
                    options.helpers[name] = function () {
                        return fn.apply(viewModel, arguments);
                    };
                };
            canEach(this.helpers || {}, function (val, prop) {
                if (isFunction(val)) {
                    addHelper(prop, val);
                }
            });
            this._control = new this.constructor.Control(el, {
                scope: this.viewModel,
                viewModel: this.viewModel,
                destroy: callTeardownFunctions
            });
            var nodeList = nodeLists.register([], function () {
                domDispatch.call(el, 'beforeremove', [], false);
                if (teardownBindings) {
                    teardownBindings();
                }
            }, componentTagData.parentNodeList || true, false);
            nodeList.expression = '<' + this.tag + '>';
            teardownFunctions.push(function () {
                nodeLists.unregister(nodeList);
            });
            if (this.constructor.renderer) {
                if (!options.tags) {
                    options.tags = {};
                }
                options.tags.content = function contentHookup(el, contentTagData) {
                    var subtemplate = componentTagData.subtemplate || contentTagData.subtemplate, renderingLightContent = subtemplate === componentTagData.subtemplate;
                    if (subtemplate) {
                        delete options.tags.content;
                        var lightTemplateData;
                        if (renderingLightContent) {
                            if (lexicalContent) {
                                lightTemplateData = componentTagData;
                            } else {
                                lightTemplateData = {
                                    scope: contentTagData.scope.cloneFromRef(),
                                    options: contentTagData.options
                                };
                            }
                        } else {
                            lightTemplateData = contentTagData;
                        }
                        if (contentTagData.parentNodeList) {
                            var frag = subtemplate(lightTemplateData.scope, lightTemplateData.options, contentTagData.parentNodeList);
                            nodeLists.replace([el], frag);
                        } else {
                            nodeLists.replace([el], subtemplate(lightTemplateData.scope, lightTemplateData.options));
                        }
                        options.tags.content = contentHookup;
                    }
                };
                frag = this.constructor.renderer(shadowScope, componentTagData.options.add(options), nodeList);
            } else {
                frag = componentTagData.subtemplate ? componentTagData.subtemplate(shadowScope, componentTagData.options.add(options), nodeList) : document.createDocumentFragment();
            }
            domMutate.appendChild.call(el, frag);
            nodeLists.update(nodeList, getChildNodes(el));
        }
    });
    viewCallbacks.tag('content', function (el, tagData) {
        return tagData.scope;
    });
    module.exports = namespace.Component = Component;
});
/*can-view-target@3.0.7#can-view-target*/
define('can-view-target@3.0.7#can-view-target', function (require, exports, module) {
    var childNodes = require('can-util/dom/child-nodes/child-nodes');
    var domAttr = require('can-util/dom/attr/attr');
    var each = require('can-util/js/each/each');
    var makeArray = require('can-util/js/make-array/make-array');
    var getDocument = require('can-util/dom/document/document');
    var domMutate = require('can-util/dom/mutate/mutate');
    var namespace = require('can-namespace');
    var MUTATION_OBSERVER = require('can-util/dom/mutation-observer/mutation-observer');
    var processNodes = function (nodes, paths, location, document) {
            var frag = document.createDocumentFragment();
            for (var i = 0, len = nodes.length; i < len; i++) {
                var node = nodes[i];
                frag.appendChild(processNode(node, paths, location.concat(i), document));
            }
            return frag;
        }, keepsTextNodes = typeof document !== 'undefined' && function () {
            var testFrag = document.createDocumentFragment();
            var div = document.createElement('div');
            div.appendChild(document.createTextNode(''));
            div.appendChild(document.createTextNode(''));
            testFrag.appendChild(div);
            var cloned = testFrag.cloneNode(true);
            return childNodes(cloned.firstChild).length === 2;
        }(), clonesWork = typeof document !== 'undefined' && function () {
            var el = document.createElement('a');
            el.innerHTML = '<xyz></xyz>';
            var clone = el.cloneNode(true);
            var works = clone.innerHTML === '<xyz></xyz>';
            var MO, observer;
            if (works) {
                el = document.createDocumentFragment();
                el.appendChild(document.createTextNode('foo-bar'));
                MO = MUTATION_OBSERVER();
                if (MO) {
                    observer = new MO(function () {
                    });
                    observer.observe(document.documentElement, {
                        childList: true,
                        subtree: true
                    });
                    clone = el.cloneNode(true);
                    observer.disconnect();
                } else {
                    clone = el.cloneNode(true);
                }
                return clone.childNodes.length === 1;
            }
            return works;
        }(), namespacesWork = typeof document !== 'undefined' && !!document.createElementNS;
    var cloneNode = clonesWork ? function (el) {
        return el.cloneNode(true);
    } : function (node) {
        var document = node.ownerDocument;
        var copy;
        if (node.nodeType === 1) {
            copy = document.createElement(node.nodeName);
        } else if (node.nodeType === 3) {
            copy = document.createTextNode(node.nodeValue);
        } else if (node.nodeType === 8) {
            copy = document.createComment(node.nodeValue);
        } else if (node.nodeType === 11) {
            copy = document.createDocumentFragment();
        }
        if (node.attributes) {
            var attributes = makeArray(node.attributes);
            each(attributes, function (node) {
                if (node && node.specified) {
                    domAttr.setAttribute(copy, node.nodeName || node.name, node.nodeValue || node.value);
                }
            });
        }
        if (node && node.firstChild) {
            var child = node.firstChild;
            while (child) {
                copy.appendChild(cloneNode(child));
                child = child.nextSibling;
            }
        }
        return copy;
    };
    function processNode(node, paths, location, document) {
        var callback, loc = location, nodeType = typeof node, el, p, i, len;
        var getCallback = function () {
            if (!callback) {
                callback = {
                    path: location,
                    callbacks: []
                };
                paths.push(callback);
                loc = [];
            }
            return callback;
        };
        if (nodeType === 'object') {
            if (node.tag) {
                if (namespacesWork && node.namespace) {
                    el = document.createElementNS(node.namespace, node.tag);
                } else {
                    el = document.createElement(node.tag);
                }
                if (node.attrs) {
                    for (var attrName in node.attrs) {
                        var value = node.attrs[attrName];
                        if (typeof value === 'function') {
                            getCallback().callbacks.push({ callback: value });
                        } else {
                            domAttr.setAttribute(el, attrName, value);
                        }
                    }
                }
                if (node.attributes) {
                    for (i = 0, len = node.attributes.length; i < len; i++) {
                        getCallback().callbacks.push({ callback: node.attributes[i] });
                    }
                }
                if (node.children && node.children.length) {
                    if (callback) {
                        p = callback.paths = [];
                    } else {
                        p = paths;
                    }
                    el.appendChild(processNodes(node.children, p, loc, document));
                }
            } else if (node.comment) {
                el = document.createComment(node.comment);
                if (node.callbacks) {
                    for (i = 0, len = node.attributes.length; i < len; i++) {
                        getCallback().callbacks.push({ callback: node.callbacks[i] });
                    }
                }
            }
        } else if (nodeType === 'string') {
            el = document.createTextNode(node);
        } else if (nodeType === 'function') {
            if (keepsTextNodes) {
                el = document.createTextNode('');
                getCallback().callbacks.push({ callback: node });
            } else {
                el = document.createComment('~');
                getCallback().callbacks.push({
                    callback: function () {
                        var el = document.createTextNode('');
                        domMutate.replaceChild.call(this.parentNode, el, this);
                        return node.apply(el, arguments);
                    }
                });
            }
        }
        return el;
    }
    function getCallbacks(el, pathData, elementCallbacks) {
        var path = pathData.path, callbacks = pathData.callbacks, paths = pathData.paths, child = el, pathLength = path ? path.length : 0, pathsLength = paths ? paths.length : 0;
        for (var i = 0; i < pathLength; i++) {
            child = child.childNodes.item(path[i]);
        }
        for (i = 0; i < pathsLength; i++) {
            getCallbacks(child, paths[i], elementCallbacks);
        }
        elementCallbacks.push({
            element: child,
            callbacks: callbacks
        });
    }
    function hydrateCallbacks(callbacks, args) {
        var len = callbacks.length, callbacksLength, callbackElement, callbackData;
        for (var i = 0; i < len; i++) {
            callbackData = callbacks[i];
            callbacksLength = callbackData.callbacks.length;
            callbackElement = callbackData.element;
            for (var c = 0; c < callbacksLength; c++) {
                callbackData.callbacks[c].callback.apply(callbackElement, args);
            }
        }
    }
    function makeTarget(nodes, doc) {
        var paths = [];
        var frag = processNodes(nodes, paths, [], doc || getDocument());
        return {
            paths: paths,
            clone: frag,
            hydrate: function () {
                var cloned = cloneNode(this.clone);
                var args = makeArray(arguments);
                var callbacks = [];
                for (var i = 0; i < paths.length; i++) {
                    getCallbacks(cloned, paths[i], callbacks);
                }
                hydrateCallbacks(callbacks, args);
                return cloned;
            }
        };
    }
    makeTarget.keepsTextNodes = keepsTextNodes;
    makeTarget.cloneNode = cloneNode;
    namespace.view = namespace.view || {};
    module.exports = namespace.view.target = makeTarget;
});
/*can-stache@3.0.20#src/mustache_core*/
define('can-stache@3.0.20#src/mustache_core', function (require, exports, module) {
    var live = require('can-view-live');
    var nodeLists = require('can-view-nodelist');
    var compute = require('can-compute');
    var Observation = require('can-observation');
    var utils = require('./utils');
    var expression = require('./expression');
    var types = require('can-types');
    var frag = require('can-util/dom/frag/frag');
    var attr = require('can-util/dom/attr/attr');
    var mustacheLineBreakRegExp = /(?:(?:^|(\r?)\n)(\s*)(\{\{([^\}]*)\}\}\}?)([^\S\n\r]*)($|\r?\n))|(\{\{([^\}]*)\}\}\}?)/g, k = function () {
        };
    var core = {
        expression: expression,
        makeEvaluator: function (scope, helperOptions, nodeList, mode, exprData, truthyRenderer, falseyRenderer, stringOnly) {
            if (mode === '^') {
                var temp = truthyRenderer;
                truthyRenderer = falseyRenderer;
                falseyRenderer = temp;
            }
            var value, helperOptionArg;
            if (exprData instanceof expression.Call) {
                helperOptionArg = {
                    fn: function () {
                    },
                    inverse: function () {
                    },
                    context: scope.peek('.'),
                    scope: scope,
                    nodeList: nodeList,
                    exprData: exprData,
                    helpersScope: helperOptions
                };
                utils.convertToScopes(helperOptionArg, scope, helperOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly);
                value = exprData.value(scope, helperOptions, helperOptionArg);
                if (exprData.isHelper) {
                    return value;
                }
            } else if (exprData instanceof expression.Bracket) {
                value = exprData.value(scope);
                if (exprData.isHelper) {
                    return value;
                }
            } else if (exprData instanceof expression.Lookup) {
                value = exprData.value(scope);
                if (exprData.isHelper) {
                    return value;
                }
            } else if (exprData instanceof expression.Helper && exprData.methodExpr instanceof expression.Bracket) {
                value = exprData.methodExpr.value(scope);
                if (exprData.isHelper) {
                    return value;
                }
            } else {
                var readOptions = {
                    isArgument: true,
                    args: [
                        scope.peek('.'),
                        scope
                    ],
                    asCompute: true
                };
                var helperAndValue = exprData.helperAndValue(scope, helperOptions, readOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly);
                var helper = helperAndValue.helper;
                value = helperAndValue.value;
                if (helper) {
                    return exprData.evaluator(helper, scope, helperOptions, readOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly);
                }
            }
            if (!mode) {
                if (value && value.isComputed) {
                    return value;
                } else {
                    return function () {
                        return '' + (value != null ? value : '');
                    };
                }
            } else if (mode === '#' || mode === '^') {
                helperOptionArg = {
                    fn: function () {
                    },
                    inverse: function () {
                    }
                };
                utils.convertToScopes(helperOptionArg, scope, helperOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly);
                return function () {
                    var finalValue;
                    if (types.isCompute(value)) {
                        finalValue = value();
                    } else {
                        finalValue = value;
                    }
                    if (typeof finalValue === 'function') {
                        return finalValue;
                    } else if (typeof finalValue !== 'string' && utils.isArrayLike(finalValue)) {
                        var isObserveList = types.isMapLike(finalValue);
                        if (isObserveList ? finalValue.attr('length') : finalValue.length) {
                            if (stringOnly) {
                                return utils.getItemsStringContent(finalValue, isObserveList, helperOptionArg, helperOptions);
                            } else {
                                return frag(utils.getItemsFragContent(finalValue, helperOptionArg, scope));
                            }
                        } else {
                            return helperOptionArg.inverse(scope, helperOptions);
                        }
                    } else {
                        return finalValue ? helperOptionArg.fn(finalValue || scope, helperOptions) : helperOptionArg.inverse(scope, helperOptions);
                    }
                };
            } else {
            }
        },
        makeLiveBindingPartialRenderer: function (expressionString, state) {
            expressionString = expressionString.trim();
            var exprData, partialName = expressionString.split(/\s+/).shift();
            if (partialName !== expressionString) {
                exprData = core.expression.parse(expressionString);
            }
            return function (scope, options, parentSectionNodeList) {
                var nodeList = [this];
                nodeList.expression = '>' + partialName;
                nodeLists.register(nodeList, null, parentSectionNodeList || true, state.directlyNested);
                var partialFrag = compute(function () {
                    var localPartialName = partialName;
                    if (exprData && exprData.argExprs.length === 1) {
                        var newContext = exprData.argExprs[0].value(scope, options)();
                        if (typeof newContext === 'undefined') {
                        } else {
                            scope = scope.add(newContext);
                        }
                    }
                    var partial = options.peek('partials.' + localPartialName), renderer;
                    if (partial) {
                        renderer = function () {
                            return partial.render ? partial.render(scope, options, nodeList) : partial(scope, options);
                        };
                    } else {
                        var scopePartialName = scope.read(localPartialName, { isArgument: true }).value;
                        if (scopePartialName === null || !scopePartialName && localPartialName[0] === '*') {
                            return frag('');
                        }
                        if (scopePartialName) {
                            localPartialName = scopePartialName;
                        }
                        renderer = function () {
                            if (typeof localPartialName === 'function') {
                                return localPartialName(scope, options, nodeList);
                            } else {
                                return core.getTemplateById(localPartialName)(scope, options, nodeList);
                            }
                        };
                    }
                    var res = Observation.ignore(renderer)();
                    return frag(res);
                });
                partialFrag.computeInstance.setPrimaryDepth(nodeList.nesting);
                live.html(this, partialFrag, this.parentNode, nodeList);
            };
        },
        makeStringBranchRenderer: function (mode, expressionString) {
            var exprData = core.expression.parse(expressionString), fullExpression = mode + expressionString;
            if (!(exprData instanceof expression.Helper) && !(exprData instanceof expression.Call)) {
                exprData = new expression.Helper(exprData, [], {});
            }
            return function branchRenderer(scope, options, truthyRenderer, falseyRenderer) {
                var evaluator = scope.__cache[fullExpression];
                if (mode || !evaluator) {
                    evaluator = makeEvaluator(scope, options, null, mode, exprData, truthyRenderer, falseyRenderer, true);
                    if (!mode) {
                        scope.__cache[fullExpression] = evaluator;
                    }
                }
                var res = evaluator();
                return res == null ? '' : '' + res;
            };
        },
        makeLiveBindingBranchRenderer: function (mode, expressionString, state) {
            var exprData = core.expression.parse(expressionString);
            if (!(exprData instanceof expression.Helper) && !(exprData instanceof expression.Call) && !(exprData instanceof expression.Bracket) && !(exprData instanceof expression.Lookup)) {
                exprData = new expression.Helper(exprData, [], {});
            }
            return function branchRenderer(scope, options, parentSectionNodeList, truthyRenderer, falseyRenderer) {
                var nodeList = [this];
                nodeList.expression = expressionString;
                nodeLists.register(nodeList, null, parentSectionNodeList || true, state.directlyNested);
                var evaluator = makeEvaluator(scope, options, nodeList, mode, exprData, truthyRenderer, falseyRenderer, state.tag);
                var gotCompute = evaluator.isComputed, computeValue;
                if (gotCompute) {
                    computeValue = evaluator;
                } else {
                    computeValue = compute(evaluator, null, false);
                }
                computeValue.computeInstance.setPrimaryDepth(nodeList.nesting);
                computeValue.computeInstance.bind('change', k);
                var value = computeValue();
                if (typeof value === 'function') {
                    Observation.ignore(value)(this);
                } else if (gotCompute || computeValue.computeInstance.hasDependencies) {
                    if (state.attr) {
                        live.attr(this, state.attr, computeValue);
                    } else if (state.tag) {
                        live.attrs(this, computeValue);
                    } else if (state.text && typeof value !== 'object') {
                        live.text(this, computeValue, this.parentNode, nodeList);
                    } else {
                        live.html(this, computeValue, this.parentNode, nodeList);
                    }
                } else {
                    if (state.attr) {
                        attr.set(this, state.attr, value);
                    } else if (state.tag) {
                        live.attrs(this, value);
                    } else if (state.text && typeof value === 'string') {
                        this.nodeValue = value;
                    } else if (value != null) {
                        nodeLists.replace([this], frag(value, this.ownerDocument));
                    }
                }
                computeValue.computeInstance.unbind('change', k);
            };
        },
        splitModeFromExpression: function (expression, state) {
            expression = expression.trim();
            var mode = expression.charAt(0);
            if ('#/{&^>!'.indexOf(mode) >= 0) {
                expression = expression.substr(1).trim();
            } else {
                mode = null;
            }
            if (mode === '{' && state.node) {
                mode = null;
            }
            return {
                mode: mode,
                expression: expression
            };
        },
        cleanLineEndings: function (template) {
            return template.replace(mustacheLineBreakRegExp, function (whole, returnBefore, spaceBefore, special, expression, spaceAfter, returnAfter, spaceLessSpecial, spaceLessExpression, matchIndex) {
                spaceAfter = spaceAfter || '';
                returnBefore = returnBefore || '';
                spaceBefore = spaceBefore || '';
                var modeAndExpression = splitModeFromExpression(expression || spaceLessExpression, {});
                if (spaceLessSpecial || '>{'.indexOf(modeAndExpression.mode) >= 0) {
                    return whole;
                } else if ('^#!/'.indexOf(modeAndExpression.mode) >= 0) {
                    return special + (matchIndex !== 0 && returnAfter.length ? returnBefore + '\n' : '');
                } else {
                    return spaceBefore + special + spaceAfter + (spaceBefore.length || matchIndex !== 0 ? returnBefore + '\n' : '');
                }
            });
        },
        Options: utils.Options,
        getTemplateById: function () {
        }
    };
    var makeEvaluator = core.makeEvaluator, splitModeFromExpression = core.splitModeFromExpression;
    module.exports = core;
});
/*can-stache@3.0.20#src/html_section*/
define('can-stache@3.0.20#src/html_section', function (require, exports, module) {
    var target = require('can-view-target');
    var Scope = require('can-view-scope');
    var Observation = require('can-observation');
    var utils = require('./utils');
    var mustacheCore = require('./mustache_core');
    var getDocument = require('can-util/dom/document/document');
    var assign = require('can-util/js/assign/assign');
    var last = require('can-util/js/last/last');
    var decodeHTML = typeof document !== 'undefined' && function () {
        var el = getDocument().createElement('div');
        return function (html) {
            if (html.indexOf('&') === -1) {
                return html.replace(/\r\n/g, '\n');
            }
            el.innerHTML = html;
            return el.childNodes.length === 0 ? '' : el.childNodes.item(0).nodeValue;
        };
    }();
    var HTMLSectionBuilder = function () {
        this.stack = [new HTMLSection()];
    };
    assign(HTMLSectionBuilder.prototype, utils.mixins);
    assign(HTMLSectionBuilder.prototype, {
        startSubSection: function (process) {
            var newSection = new HTMLSection(process);
            this.stack.push(newSection);
            return newSection;
        },
        endSubSectionAndReturnRenderer: function () {
            if (this.last().isEmpty()) {
                this.stack.pop();
                return null;
            } else {
                var htmlSection = this.endSection();
                return htmlSection.compiled.hydrate.bind(htmlSection.compiled);
            }
        },
        startSection: function (process) {
            var newSection = new HTMLSection(process);
            this.last().add(newSection.targetCallback);
            this.stack.push(newSection);
        },
        endSection: function () {
            this.last().compile();
            return this.stack.pop();
        },
        inverse: function () {
            this.last().inverse();
        },
        compile: function () {
            var compiled = this.stack.pop().compile();
            return Observation.ignore(function (scope, options, nodeList) {
                if (!(scope instanceof Scope)) {
                    scope = Scope.refsScope().add(scope || {});
                }
                if (!(options instanceof mustacheCore.Options)) {
                    options = new mustacheCore.Options(options || {});
                }
                return compiled.hydrate(scope, options, nodeList);
            });
        },
        push: function (chars) {
            this.last().push(chars);
        },
        pop: function () {
            return this.last().pop();
        }
    });
    var HTMLSection = function (process) {
        this.data = 'targetData';
        this.targetData = [];
        this.targetStack = [];
        var self = this;
        this.targetCallback = function (scope, options, sectionNode) {
            process.call(this, scope, options, sectionNode, self.compiled.hydrate.bind(self.compiled), self.inverseCompiled && self.inverseCompiled.hydrate.bind(self.inverseCompiled));
        };
    };
    assign(HTMLSection.prototype, {
        inverse: function () {
            this.inverseData = [];
            this.data = 'inverseData';
        },
        push: function (data) {
            this.add(data);
            this.targetStack.push(data);
        },
        pop: function () {
            return this.targetStack.pop();
        },
        add: function (data) {
            if (typeof data === 'string') {
                data = decodeHTML(data);
            }
            if (this.targetStack.length) {
                last(this.targetStack).children.push(data);
            } else {
                this[this.data].push(data);
            }
        },
        compile: function () {
            this.compiled = target(this.targetData, getDocument());
            if (this.inverseData) {
                this.inverseCompiled = target(this.inverseData, getDocument());
                delete this.inverseData;
            }
            this.targetStack = this.targetData = null;
            return this.compiled;
        },
        children: function () {
            if (this.targetStack.length) {
                return last(this.targetStack).children;
            } else {
                return this[this.data];
            }
        },
        isEmpty: function () {
            return !this.targetData.length;
        }
    });
    HTMLSectionBuilder.HTMLSection = HTMLSection;
    module.exports = HTMLSectionBuilder;
});
/*can-stache@3.0.20#src/text_section*/
define('can-stache@3.0.20#src/text_section', function (require, exports, module) {
    var compute = require('can-compute');
    var live = require('can-view-live');
    var utils = require('./utils');
    var attr = require('can-util/dom/attr/attr');
    var assign = require('can-util/js/assign/assign');
    var noop = function () {
    };
    var TextSectionBuilder = function () {
        this.stack = [new TextSection()];
    };
    assign(TextSectionBuilder.prototype, utils.mixins);
    assign(TextSectionBuilder.prototype, {
        startSection: function (process) {
            var subSection = new TextSection();
            this.last().add({
                process: process,
                truthy: subSection
            });
            this.stack.push(subSection);
        },
        endSection: function () {
            this.stack.pop();
        },
        inverse: function () {
            this.stack.pop();
            var falseySection = new TextSection();
            this.last().last().falsey = falseySection;
            this.stack.push(falseySection);
        },
        compile: function (state) {
            var renderer = this.stack[0].compile();
            return function (scope, options) {
                var computeValue = compute(function () {
                    return renderer(scope, options);
                }, null, false);
                computeValue.computeInstance.addEventListener('change', noop);
                var value = computeValue();
                if (computeValue.computeInstance.hasDependencies) {
                    if (state.textContentOnly) {
                        live.text(this, computeValue);
                    } else if (state.attr) {
                        live.attr(this, state.attr, computeValue);
                    } else {
                        live.attrs(this, computeValue, scope, options);
                    }
                    computeValue.computeInstance.removeEventListener('change', noop);
                } else {
                    if (state.textContentOnly) {
                        this.nodeValue = value;
                    } else if (state.attr) {
                        attr.set(this, state.attr, value);
                    } else {
                        live.attrs(this, value);
                    }
                }
            };
        }
    });
    var passTruthyFalsey = function (process, truthy, falsey) {
        return function (scope, options) {
            return process.call(this, scope, options, truthy, falsey);
        };
    };
    var TextSection = function () {
        this.values = [];
    };
    assign(TextSection.prototype, {
        add: function (data) {
            this.values.push(data);
        },
        last: function () {
            return this.values[this.values.length - 1];
        },
        compile: function () {
            var values = this.values, len = values.length;
            for (var i = 0; i < len; i++) {
                var value = this.values[i];
                if (typeof value === 'object') {
                    values[i] = passTruthyFalsey(value.process, value.truthy && value.truthy.compile(), value.falsey && value.falsey.compile());
                }
            }
            return function (scope, options) {
                var txt = '', value;
                for (var i = 0; i < len; i++) {
                    value = values[i];
                    txt += typeof value === 'string' ? value : value.call(this, scope, options);
                }
                return txt;
            };
        }
    });
    module.exports = TextSectionBuilder;
});
/*can-stache@3.0.20#helpers/converter*/
define('can-stache@3.0.20#helpers/converter', function (require, exports, module) {
    var helpers = require('./core');
    var expression = require('../src/expression');
    var makeArray = require('can-util/js/make-array/make-array');
    helpers.registerConverter = function (name, getterSetter) {
        getterSetter = getterSetter || {};
        helpers.registerHelper(name, function (newVal, source) {
            var args = makeArray(arguments);
            if (newVal instanceof expression.SetIdentifier) {
                return typeof getterSetter.set === 'function' ? getterSetter.set.apply(this, [newVal.value].concat(args.slice(1))) : source(newVal.value);
            } else {
                return typeof getterSetter.get === 'function' ? getterSetter.get.apply(this, args) : args[0];
            }
        });
    };
    module.exports = helpers;
});
/*can-stache@3.0.20#src/intermediate_and_imports*/
define('can-stache@3.0.20#src/intermediate_and_imports', function (require, exports, module) {
    var mustacheCore = require('./mustache_core');
    var parser = require('can-view-parser');
    module.exports = function (source) {
        var template = mustacheCore.cleanLineEndings(source);
        var imports = [], dynamicImports = [], ases = {}, inImport = false, inFrom = false, inAs = false, isUnary = false, currentAs = '', currentFrom = '';
        var intermediate = parser(template, {
            start: function (tagName, unary) {
                isUnary = unary;
                if (tagName === 'can-import') {
                    inImport = true;
                } else if (inImport) {
                    inImport = false;
                }
            },
            attrStart: function (attrName) {
                if (attrName === 'from') {
                    inFrom = true;
                } else if (attrName === 'as' || attrName === 'export-as') {
                    inAs = true;
                }
            },
            attrEnd: function (attrName) {
                if (attrName === 'from') {
                    inFrom = false;
                } else if (attrName === 'as' || attrName === 'export-as') {
                    inAs = false;
                }
            },
            attrValue: function (value) {
                if (inFrom && inImport) {
                    imports.push(value);
                    if (!isUnary) {
                        dynamicImports.push(value);
                    }
                    currentFrom = value;
                } else if (inAs && inImport) {
                    currentAs = value;
                }
            },
            end: function (tagName) {
                if (tagName === 'can-import') {
                    if (currentAs) {
                        ases[currentAs] = currentFrom;
                        currentAs = '';
                    }
                }
            },
            close: function (tagName) {
                if (tagName === 'can-import') {
                    imports.pop();
                }
            }
        }, true);
        return {
            intermediate: intermediate,
            imports: imports,
            dynamicImports: dynamicImports,
            ases: ases,
            exports: ases
        };
    };
});
/*can-util@3.3.2#js/import/import*/
define('can-util@3.3.2#js/import/import', function (require, exports, module) {
    (function (global) {
        var isFunction = require('../is-function/is-function');
        var global = require('../global/global')();
        module.exports = function (moduleName, parentName) {
            return new Promise(function (resolve, reject) {
                try {
                    if (typeof global.System === 'object' && isFunction(global.System['import'])) {
                        global.System['import'](moduleName, { name: parentName }).then(resolve, reject);
                    } else if (global.define && global.define.amd) {
                        global.require([moduleName], function (value) {
                            resolve(value);
                        });
                    } else if (global.require) {
                        resolve(global.require(moduleName));
                    } else {
                        resolve();
                    }
                } catch (err) {
                    reject(err);
                }
            });
        };
    }(function () {
        return this;
    }()));
});
/*can-stache@3.0.20#can-stache*/
define('can-stache@3.0.20#can-stache', function (require, exports, module) {
    var parser = require('can-view-parser');
    var viewCallbacks = require('can-view-callbacks');
    var HTMLSectionBuilder = require('./src/html_section');
    var TextSectionBuilder = require('./src/text_section');
    var mustacheCore = require('./src/mustache_core');
    var mustacheHelpers = require('./helpers/core');
    require('./helpers/converter');
    var getIntermediateAndImports = require('./src/intermediate_and_imports');
    var namespace = require('can-namespace');
    var DOCUMENT = require('can-util/dom/document/document');
    var assign = require('can-util/js/assign/assign');
    var last = require('can-util/js/last/last');
    var importer = require('can-util/js/import/import');
    require('can-view-target');
    require('can-view-nodelist');
    viewCallbacks.tag('content', function (el, tagData) {
        return tagData.scope;
    });
    var svgNamespace = 'http://www.w3.org/2000/svg';
    var namespaces = {
            'svg': svgNamespace,
            'g': svgNamespace
        }, textContentOnlyTag = {
            style: true,
            script: true
        };
    function stache(template) {
        if (typeof template === 'string') {
            template = mustacheCore.cleanLineEndings(template);
        }
        var section = new HTMLSectionBuilder(), state = {
                node: null,
                attr: null,
                sectionElementStack: [],
                text: false,
                namespaceStack: [],
                textContentOnly: null
            }, makeRendererAndUpdateSection = function (section, mode, stache) {
                if (mode === '>') {
                    section.add(mustacheCore.makeLiveBindingPartialRenderer(stache, copyState()));
                } else if (mode === '/') {
                    section.endSection();
                    if (section instanceof HTMLSectionBuilder) {
                        state.sectionElementStack.pop();
                    }
                } else if (mode === 'else') {
                    section.inverse();
                } else {
                    var makeRenderer = section instanceof HTMLSectionBuilder ? mustacheCore.makeLiveBindingBranchRenderer : mustacheCore.makeStringBranchRenderer;
                    if (mode === '{' || mode === '&') {
                        section.add(makeRenderer(null, stache, copyState()));
                    } else if (mode === '#' || mode === '^') {
                        section.startSection(makeRenderer(mode, stache, copyState()));
                        if (section instanceof HTMLSectionBuilder) {
                            state.sectionElementStack.push('section');
                        }
                    } else {
                        section.add(makeRenderer(null, stache, copyState({ text: true })));
                    }
                }
            }, copyState = function (overwrites) {
                var lastElement = state.sectionElementStack[state.sectionElementStack.length - 1];
                var cur = {
                    tag: state.node && state.node.tag,
                    attr: state.attr && state.attr.name,
                    directlyNested: state.sectionElementStack.length ? lastElement === 'section' || lastElement === 'custom' : true,
                    textContentOnly: !!state.textContentOnly
                };
                return overwrites ? assign(cur, overwrites) : cur;
            }, addAttributesCallback = function (node, callback) {
                if (!node.attributes) {
                    node.attributes = [];
                }
                node.attributes.unshift(callback);
            };
        parser(template, {
            start: function (tagName, unary) {
                var matchedNamespace = namespaces[tagName];
                if (matchedNamespace && !unary) {
                    state.namespaceStack.push(matchedNamespace);
                }
                state.node = {
                    tag: tagName,
                    children: [],
                    namespace: matchedNamespace || last(state.namespaceStack)
                };
            },
            end: function (tagName, unary) {
                var isCustomTag = viewCallbacks.tag(tagName);
                if (unary) {
                    section.add(state.node);
                    if (isCustomTag) {
                        addAttributesCallback(state.node, function (scope, options, parentNodeList) {
                            viewCallbacks.tagHandler(this, tagName, {
                                scope: scope,
                                options: options,
                                subtemplate: null,
                                templateType: 'stache',
                                parentNodeList: parentNodeList
                            });
                        });
                    }
                } else {
                    section.push(state.node);
                    state.sectionElementStack.push(isCustomTag ? 'custom' : tagName);
                    if (isCustomTag) {
                        section.startSubSection();
                    } else if (textContentOnlyTag[tagName]) {
                        state.textContentOnly = new TextSectionBuilder();
                    }
                }
                state.node = null;
            },
            close: function (tagName) {
                var matchedNamespace = namespaces[tagName];
                if (matchedNamespace) {
                    state.namespaceStack.pop();
                }
                var isCustomTag = viewCallbacks.tag(tagName), renderer;
                if (isCustomTag) {
                    renderer = section.endSubSectionAndReturnRenderer();
                }
                if (textContentOnlyTag[tagName]) {
                    section.last().add(state.textContentOnly.compile(copyState()));
                    state.textContentOnly = null;
                }
                var oldNode = section.pop();
                if (isCustomTag) {
                    addAttributesCallback(oldNode, function (scope, options, parentNodeList) {
                        viewCallbacks.tagHandler(this, tagName, {
                            scope: scope,
                            options: options,
                            subtemplate: renderer,
                            templateType: 'stache',
                            parentNodeList: parentNodeList
                        });
                    });
                }
                state.sectionElementStack.pop();
            },
            attrStart: function (attrName) {
                if (state.node.section) {
                    state.node.section.add(attrName + '="');
                } else {
                    state.attr = {
                        name: attrName,
                        value: ''
                    };
                }
            },
            attrEnd: function (attrName) {
                if (state.node.section) {
                    state.node.section.add('" ');
                } else {
                    if (!state.node.attrs) {
                        state.node.attrs = {};
                    }
                    state.node.attrs[state.attr.name] = state.attr.section ? state.attr.section.compile(copyState()) : state.attr.value;
                    var attrCallback = viewCallbacks.attr(attrName);
                    if (attrCallback) {
                        if (!state.node.attributes) {
                            state.node.attributes = [];
                        }
                        state.node.attributes.push(function (scope, options, nodeList) {
                            attrCallback(this, {
                                attributeName: attrName,
                                scope: scope,
                                options: options,
                                nodeList: nodeList
                            });
                        });
                    }
                    state.attr = null;
                }
            },
            attrValue: function (value) {
                var section = state.node.section || state.attr.section;
                if (section) {
                    section.add(value);
                } else {
                    state.attr.value += value;
                }
            },
            chars: function (text) {
                (state.textContentOnly || section).add(text);
            },
            special: function (text) {
                var firstAndText = mustacheCore.splitModeFromExpression(text, state), mode = firstAndText.mode, expression = firstAndText.expression;
                if (expression === 'else') {
                    var inverseSection;
                    if (state.attr && state.attr.section) {
                        inverseSection = state.attr.section;
                    } else if (state.node && state.node.section) {
                        inverseSection = state.node.section;
                    } else {
                        inverseSection = state.textContentOnly || section;
                    }
                    inverseSection.inverse();
                    return;
                }
                if (mode === '!') {
                    return;
                }
                if (state.node && state.node.section) {
                    makeRendererAndUpdateSection(state.node.section, mode, expression);
                    if (state.node.section.subSectionDepth() === 0) {
                        state.node.attributes.push(state.node.section.compile(copyState()));
                        delete state.node.section;
                    }
                } else if (state.attr) {
                    if (!state.attr.section) {
                        state.attr.section = new TextSectionBuilder();
                        if (state.attr.value) {
                            state.attr.section.add(state.attr.value);
                        }
                    }
                    makeRendererAndUpdateSection(state.attr.section, mode, expression);
                } else if (state.node) {
                    if (!state.node.attributes) {
                        state.node.attributes = [];
                    }
                    if (!mode) {
                        state.node.attributes.push(mustacheCore.makeLiveBindingBranchRenderer(null, expression, copyState()));
                    } else if (mode === '#' || mode === '^') {
                        if (!state.node.section) {
                            state.node.section = new TextSectionBuilder();
                        }
                        makeRendererAndUpdateSection(state.node.section, mode, expression);
                    } else {
                        throw new Error(mode + ' is currently not supported within a tag.');
                    }
                } else {
                    makeRendererAndUpdateSection(state.textContentOnly || section, mode, expression);
                }
            },
            comment: function (text) {
                section.add({ comment: text });
            },
            done: function () {
            }
        });
        return section.compile();
    }
    assign(stache, mustacheHelpers);
    stache.safeString = function (text) {
        return {
            toString: function () {
                return text;
            }
        };
    };
    stache.async = function (source) {
        var iAi = getIntermediateAndImports(source);
        var importPromises = iAi.imports.map(function (moduleName) {
            return importer(moduleName);
        });
        return Promise.all(importPromises).then(function () {
            return stache(iAi.intermediate);
        });
    };
    var templates = {};
    stache.from = mustacheCore.getTemplateById = function (id) {
        if (!templates[id]) {
            var el = DOCUMENT().getElementById(id);
            templates[id] = stache(el.innerHTML);
        }
        return templates[id];
    };
    stache.registerPartial = function (id, partial) {
        templates[id] = typeof partial === 'string' ? stache(partial) : partial;
    };
    module.exports = namespace.stache = stache;
});
/*steal-qunit@0.1.4#add-dom*/
define('steal-qunit@0.1.4#add-dom', function (require, exports, module) {
    'format cjs';
    if (!document.getElementById('qunit')) {
        var qunit = document.createElement('div');
        qunit.id = 'qunit';
        (document.body || document.documentElement).appendChild(qunit);
    }
});
/*qunitjs@1.23.1#qunit/qunit*/
define('qunitjs@1.23.1#qunit/qunit', [
    'module',
    '@loader',
    'steal-qunit/add-dom'
], function (module, loader) {
    loader.get('@@global-helpers').prepareGlobal(module.id, ['steal-qunit/add-dom'], 'QUnit');
    var define = loader.global.define;
    var require = loader.global.require;
    var source = '/*!\n * QUnit 1.23.1\n * https://qunitjs.com/\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2016-04-12T17:29Z\n */\n\n( function( global ) {\n\nvar QUnit = {};\n\nvar Date = global.Date;\nvar now = Date.now || function() {\n\treturn new Date().getTime();\n};\n\nvar setTimeout = global.setTimeout;\nvar clearTimeout = global.clearTimeout;\n\n// Store a local window from the global to allow direct references.\nvar window = global.window;\n\nvar defined = {\n\tdocument: window && window.document !== undefined,\n\tsetTimeout: setTimeout !== undefined,\n\tsessionStorage: ( function() {\n\t\tvar x = "qunit-test-string";\n\t\ttry {\n\t\t\tsessionStorage.setItem( x, x );\n\t\t\tsessionStorage.removeItem( x );\n\t\t\treturn true;\n\t\t} catch ( e ) {\n\t\t\treturn false;\n\t\t}\n\t}() )\n};\n\nvar fileName = ( sourceFromStacktrace( 0 ) || "" ).replace( /(:\\d+)+\\)?/, "" ).replace( /.+\\//, "" );\nvar globalStartCalled = false;\nvar runStarted = false;\n\nvar toString = Object.prototype.toString,\n\thasOwn = Object.prototype.hasOwnProperty;\n\n// Returns a new Array with the elements that are in a but not in b\nfunction diff( a, b ) {\n\tvar i, j,\n\t\tresult = a.slice();\n\n\tfor ( i = 0; i < result.length; i++ ) {\n\t\tfor ( j = 0; j < b.length; j++ ) {\n\t\t\tif ( result[ i ] === b[ j ] ) {\n\t\t\t\tresult.splice( i, 1 );\n\t\t\t\ti--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\n// From jquery.js\nfunction inArray( elem, array ) {\n\tif ( array.indexOf ) {\n\t\treturn array.indexOf( elem );\n\t}\n\n\tfor ( var i = 0, length = array.length; i < length; i++ ) {\n\t\tif ( array[ i ] === elem ) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n/**\n * Makes a clone of an object using only Array or Object as base,\n * and copies over the own enumerable properties.\n *\n * @param {Object} obj\n * @return {Object} New object with only the own properties (recursively).\n */\nfunction objectValues ( obj ) {\n\tvar key, val,\n\t\tvals = QUnit.is( "array", obj ) ? [] : {};\n\tfor ( key in obj ) {\n\t\tif ( hasOwn.call( obj, key ) ) {\n\t\t\tval = obj[ key ];\n\t\t\tvals[ key ] = val === Object( val ) ? objectValues( val ) : val;\n\t\t}\n\t}\n\treturn vals;\n}\n\nfunction extend( a, b, undefOnly ) {\n\tfor ( var prop in b ) {\n\t\tif ( hasOwn.call( b, prop ) ) {\n\n\t\t\t// Avoid "Member not found" error in IE8 caused by messing with window.constructor\n\t\t\t// This block runs on every environment, so `global` is being used instead of `window`\n\t\t\t// to avoid errors on node.\n\t\t\tif ( prop !== "constructor" || a !== global ) {\n\t\t\t\tif ( b[ prop ] === undefined ) {\n\t\t\t\t\tdelete a[ prop ];\n\t\t\t\t} else if ( !( undefOnly && typeof a[ prop ] !== "undefined" ) ) {\n\t\t\t\t\ta[ prop ] = b[ prop ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a;\n}\n\nfunction objectType( obj ) {\n\tif ( typeof obj === "undefined" ) {\n\t\treturn "undefined";\n\t}\n\n\t// Consider: typeof null === object\n\tif ( obj === null ) {\n\t\treturn "null";\n\t}\n\n\tvar match = toString.call( obj ).match( /^\\[object\\s(.*)\\]$/ ),\n\t\ttype = match && match[ 1 ];\n\n\tswitch ( type ) {\n\t\tcase "Number":\n\t\t\tif ( isNaN( obj ) ) {\n\t\t\t\treturn "nan";\n\t\t\t}\n\t\t\treturn "number";\n\t\tcase "String":\n\t\tcase "Boolean":\n\t\tcase "Array":\n\t\tcase "Set":\n\t\tcase "Map":\n\t\tcase "Date":\n\t\tcase "RegExp":\n\t\tcase "Function":\n\t\tcase "Symbol":\n\t\t\treturn type.toLowerCase();\n\t}\n\tif ( typeof obj === "object" ) {\n\t\treturn "object";\n\t}\n}\n\n// Safe object type checking\nfunction is( type, obj ) {\n\treturn QUnit.objectType( obj ) === type;\n}\n\n// Doesn\'t support IE6 to IE9, it will return undefined on these browsers\n// See also https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error/Stack\nfunction extractStacktrace( e, offset ) {\n\toffset = offset === undefined ? 4 : offset;\n\n\tvar stack, include, i;\n\n\tif ( e.stack ) {\n\t\tstack = e.stack.split( "\\n" );\n\t\tif ( /^error$/i.test( stack[ 0 ] ) ) {\n\t\t\tstack.shift();\n\t\t}\n\t\tif ( fileName ) {\n\t\t\tinclude = [];\n\t\t\tfor ( i = offset; i < stack.length; i++ ) {\n\t\t\t\tif ( stack[ i ].indexOf( fileName ) !== -1 ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tinclude.push( stack[ i ] );\n\t\t\t}\n\t\t\tif ( include.length ) {\n\t\t\t\treturn include.join( "\\n" );\n\t\t\t}\n\t\t}\n\t\treturn stack[ offset ];\n\n\t// Support: Safari <=6 only\n\t} else if ( e.sourceURL ) {\n\n\t\t// Exclude useless self-reference for generated Error objects\n\t\tif ( /qunit.js$/.test( e.sourceURL ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// For actual exceptions, this is useful\n\t\treturn e.sourceURL + ":" + e.line;\n\t}\n}\n\nfunction sourceFromStacktrace( offset ) {\n\tvar error = new Error();\n\n\t// Support: Safari <=7 only, IE <=10 - 11 only\n\t// Not all browsers generate the `stack` property for `new Error()`, see also #636\n\tif ( !error.stack ) {\n\t\ttry {\n\t\t\tthrow error;\n\t\t} catch ( err ) {\n\t\t\terror = err;\n\t\t}\n\t}\n\n\treturn extractStacktrace( error, offset );\n}\n\n/**\n * Config object: Maintain internal state\n * Later exposed as QUnit.config\n * `config` initialized at top of scope\n */\nvar config = {\n\n\t// The queue of tests to run\n\tqueue: [],\n\n\t// Block until document ready\n\tblocking: true,\n\n\t// By default, run previously failed tests first\n\t// very useful in combination with "Hide passed tests" checked\n\treorder: true,\n\n\t// By default, modify document.title when suite is done\n\taltertitle: true,\n\n\t// HTML Reporter: collapse every test except the first failing test\n\t// If false, all failing tests will be expanded\n\tcollapse: true,\n\n\t// By default, scroll to top of the page when suite is done\n\tscrolltop: true,\n\n\t// Depth up-to which object will be dumped\n\tmaxDepth: 5,\n\n\t// When enabled, all tests must call expect()\n\trequireExpects: false,\n\n\t// Placeholder for user-configurable form-exposed URL parameters\n\turlConfig: [],\n\n\t// Set of all modules.\n\tmodules: [],\n\n\t// Stack of nested modules\n\tmoduleStack: [],\n\n\t// The first unnamed module\n\tcurrentModule: {\n\t\tname: "",\n\t\ttests: []\n\t},\n\n\tcallbacks: {}\n};\n\n// Push a loose unnamed module to the modules collection\nconfig.modules.push( config.currentModule );\n\nvar loggingCallbacks = {};\n\n// Register logging callbacks\nfunction registerLoggingCallbacks( obj ) {\n\tvar i, l, key,\n\t\tcallbackNames = [ "begin", "done", "log", "testStart", "testDone",\n\t\t\t"moduleStart", "moduleDone" ];\n\n\tfunction registerLoggingCallback( key ) {\n\t\tvar loggingCallback = function( callback ) {\n\t\t\tif ( objectType( callback ) !== "function" ) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t"QUnit logging methods require a callback function as their first parameters."\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconfig.callbacks[ key ].push( callback );\n\t\t};\n\n\t\t// DEPRECATED: This will be removed on QUnit 2.0.0+\n\t\t// Stores the registered functions allowing restoring\n\t\t// at verifyLoggingCallbacks() if modified\n\t\tloggingCallbacks[ key ] = loggingCallback;\n\n\t\treturn loggingCallback;\n\t}\n\n\tfor ( i = 0, l = callbackNames.length; i < l; i++ ) {\n\t\tkey = callbackNames[ i ];\n\n\t\t// Initialize key collection of logging callback\n\t\tif ( objectType( config.callbacks[ key ] ) === "undefined" ) {\n\t\t\tconfig.callbacks[ key ] = [];\n\t\t}\n\n\t\tobj[ key ] = registerLoggingCallback( key );\n\t}\n}\n\nfunction runLoggingCallbacks( key, args ) {\n\tvar i, l, callbacks;\n\n\tcallbacks = config.callbacks[ key ];\n\tfor ( i = 0, l = callbacks.length; i < l; i++ ) {\n\t\tcallbacks[ i ]( args );\n\t}\n}\n\n// DEPRECATED: This will be removed on 2.0.0+\n// This function verifies if the loggingCallbacks were modified by the user\n// If so, it will restore it, assign the given callback and print a console warning\nfunction verifyLoggingCallbacks() {\n\tvar loggingCallback, userCallback;\n\n\tfor ( loggingCallback in loggingCallbacks ) {\n\t\tif ( QUnit[ loggingCallback ] !== loggingCallbacks[ loggingCallback ] ) {\n\n\t\t\tuserCallback = QUnit[ loggingCallback ];\n\n\t\t\t// Restore the callback function\n\t\t\tQUnit[ loggingCallback ] = loggingCallbacks[ loggingCallback ];\n\n\t\t\t// Assign the deprecated given callback\n\t\t\tQUnit[ loggingCallback ]( userCallback );\n\n\t\t\tif ( global.console && global.console.warn ) {\n\t\t\t\tglobal.console.warn(\n\t\t\t\t\t"QUnit." + loggingCallback + " was replaced with a new value.\\n" +\n\t\t\t\t\t"Please, check out the documentation on how to apply logging callbacks.\\n" +\n\t\t\t\t\t"Reference: https://api.qunitjs.com/category/callbacks/"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n}\n\n( function() {\n\tif ( !defined.document ) {\n\t\treturn;\n\t}\n\n\t// `onErrorFnPrev` initialized at top of scope\n\t// Preserve other handlers\n\tvar onErrorFnPrev = window.onerror;\n\n\t// Cover uncaught exceptions\n\t// Returning true will suppress the default browser handler,\n\t// returning false will let it run.\n\twindow.onerror = function( error, filePath, linerNr ) {\n\t\tvar ret = false;\n\t\tif ( onErrorFnPrev ) {\n\t\t\tret = onErrorFnPrev( error, filePath, linerNr );\n\t\t}\n\n\t\t// Treat return value as window.onerror itself does,\n\t\t// Only do our handling if not suppressed.\n\t\tif ( ret !== true ) {\n\t\t\tif ( QUnit.config.current ) {\n\t\t\t\tif ( QUnit.config.current.ignoreGlobalErrors ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tQUnit.pushFailure( error, filePath + ":" + linerNr );\n\t\t\t} else {\n\t\t\t\tQUnit.test( "global failure", extend( function() {\n\t\t\t\t\tQUnit.pushFailure( error, filePath + ":" + linerNr );\n\t\t\t\t}, { validTest: true } ) );\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\treturn ret;\n\t};\n}() );\n\n// Figure out if we\'re running the tests from a server or not\nQUnit.isLocal = !( defined.document && window.location.protocol !== "file:" );\n\n// Expose the current QUnit version\nQUnit.version = "1.23.1";\n\nextend( QUnit, {\n\n\t// Call on start of module test to prepend name to all tests\n\tmodule: function( name, testEnvironment, executeNow ) {\n\t\tvar module, moduleFns;\n\t\tvar currentModule = config.currentModule;\n\n\t\tif ( arguments.length === 2 ) {\n\t\t\tif ( objectType( testEnvironment ) === "function" ) {\n\t\t\t\texecuteNow = testEnvironment;\n\t\t\t\ttestEnvironment = undefined;\n\t\t\t}\n\t\t}\n\n\t\t// DEPRECATED: handles setup/teardown functions,\n\t\t// beforeEach and afterEach should be used instead\n\t\tif ( testEnvironment && testEnvironment.setup ) {\n\t\t\ttestEnvironment.beforeEach = testEnvironment.setup;\n\t\t\tdelete testEnvironment.setup;\n\t\t}\n\t\tif ( testEnvironment && testEnvironment.teardown ) {\n\t\t\ttestEnvironment.afterEach = testEnvironment.teardown;\n\t\t\tdelete testEnvironment.teardown;\n\t\t}\n\n\t\tmodule = createModule();\n\n\t\tmoduleFns = {\n\t\t\tbeforeEach: setHook( module, "beforeEach" ),\n\t\t\tafterEach: setHook( module, "afterEach" )\n\t\t};\n\n\t\tif ( objectType( executeNow ) === "function" ) {\n\t\t\tconfig.moduleStack.push( module );\n\t\t\tsetCurrentModule( module );\n\t\t\texecuteNow.call( module.testEnvironment, moduleFns );\n\t\t\tconfig.moduleStack.pop();\n\t\t\tmodule = module.parentModule || currentModule;\n\t\t}\n\n\t\tsetCurrentModule( module );\n\n\t\tfunction createModule() {\n\t\t\tvar parentModule = config.moduleStack.length ?\n\t\t\t\tconfig.moduleStack.slice( -1 )[ 0 ] : null;\n\t\t\tvar moduleName = parentModule !== null ?\n\t\t\t\t[ parentModule.name, name ].join( " > " ) : name;\n\t\t\tvar module = {\n\t\t\t\tname: moduleName,\n\t\t\t\tparentModule: parentModule,\n\t\t\t\ttests: [],\n\t\t\t\tmoduleId: generateHash( moduleName )\n\t\t\t};\n\n\t\t\tvar env = {};\n\t\t\tif ( parentModule ) {\n\t\t\t\textend( env, parentModule.testEnvironment );\n\t\t\t\tdelete env.beforeEach;\n\t\t\t\tdelete env.afterEach;\n\t\t\t}\n\t\t\textend( env, testEnvironment );\n\t\t\tmodule.testEnvironment = env;\n\n\t\t\tconfig.modules.push( module );\n\t\t\treturn module;\n\t\t}\n\n\t\tfunction setCurrentModule( module ) {\n\t\t\tconfig.currentModule = module;\n\t\t}\n\n\t},\n\n\t// DEPRECATED: QUnit.asyncTest() will be removed in QUnit 2.0.\n\tasyncTest: asyncTest,\n\n\ttest: test,\n\n\tskip: skip,\n\n\tonly: only,\n\n\t// DEPRECATED: The functionality of QUnit.start() will be altered in QUnit 2.0.\n\t// In QUnit 2.0, invoking it will ONLY affect the `QUnit.config.autostart` blocking behavior.\n\tstart: function( count ) {\n\t\tvar globalStartAlreadyCalled = globalStartCalled;\n\n\t\tif ( !config.current ) {\n\t\t\tglobalStartCalled = true;\n\n\t\t\tif ( runStarted ) {\n\t\t\t\tthrow new Error( "Called start() outside of a test context while already started" );\n\t\t\t} else if ( globalStartAlreadyCalled || count > 1 ) {\n\t\t\t\tthrow new Error( "Called start() outside of a test context too many times" );\n\t\t\t} else if ( config.autostart ) {\n\t\t\t\tthrow new Error( "Called start() outside of a test context when " +\n\t\t\t\t\t"QUnit.config.autostart was true" );\n\t\t\t} else if ( !config.pageLoaded ) {\n\n\t\t\t\t// The page isn\'t completely loaded yet, so bail out and let `QUnit.load` handle it\n\t\t\t\tconfig.autostart = true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\n\t\t\t// If a test is running, adjust its semaphore\n\t\t\tconfig.current.semaphore -= count || 1;\n\n\t\t\t// If semaphore is non-numeric, throw error\n\t\t\tif ( isNaN( config.current.semaphore ) ) {\n\t\t\t\tconfig.current.semaphore = 0;\n\n\t\t\t\tQUnit.pushFailure(\n\t\t\t\t\t"Called start() with a non-numeric decrement.",\n\t\t\t\t\tsourceFromStacktrace( 2 )\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Don\'t start until equal number of stop-calls\n\t\t\tif ( config.current.semaphore > 0 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Throw an Error if start is called more often than stop\n\t\t\tif ( config.current.semaphore < 0 ) {\n\t\t\t\tconfig.current.semaphore = 0;\n\n\t\t\t\tQUnit.pushFailure(\n\t\t\t\t\t"Called start() while already started (test\'s semaphore was 0 already)",\n\t\t\t\t\tsourceFromStacktrace( 2 )\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tresumeProcessing();\n\t},\n\n\t// DEPRECATED: QUnit.stop() will be removed in QUnit 2.0.\n\tstop: function( count ) {\n\n\t\t// If there isn\'t a test running, don\'t allow QUnit.stop() to be called\n\t\tif ( !config.current ) {\n\t\t\tthrow new Error( "Called stop() outside of a test context" );\n\t\t}\n\n\t\t// If a test is running, adjust its semaphore\n\t\tconfig.current.semaphore += count || 1;\n\n\t\tpauseProcessing();\n\t},\n\n\tconfig: config,\n\n\tis: is,\n\n\tobjectType: objectType,\n\n\textend: extend,\n\n\tload: function() {\n\t\tconfig.pageLoaded = true;\n\n\t\t// Initialize the configuration options\n\t\textend( config, {\n\t\t\tstats: { all: 0, bad: 0 },\n\t\t\tmoduleStats: { all: 0, bad: 0 },\n\t\t\tstarted: 0,\n\t\t\tupdateRate: 1000,\n\t\t\tautostart: true,\n\t\t\tfilter: ""\n\t\t}, true );\n\n\t\tconfig.blocking = false;\n\n\t\tif ( config.autostart ) {\n\t\t\tresumeProcessing();\n\t\t}\n\t},\n\n\tstack: function( offset ) {\n\t\toffset = ( offset || 0 ) + 2;\n\t\treturn sourceFromStacktrace( offset );\n\t}\n} );\n\nregisterLoggingCallbacks( QUnit );\n\nfunction begin() {\n\tvar i, l,\n\t\tmodulesLog = [];\n\n\t// If the test run hasn\'t officially begun yet\n\tif ( !config.started ) {\n\n\t\t// Record the time of the test run\'s beginning\n\t\tconfig.started = now();\n\n\t\tverifyLoggingCallbacks();\n\n\t\t// Delete the loose unnamed module if unused.\n\t\tif ( config.modules[ 0 ].name === "" && config.modules[ 0 ].tests.length === 0 ) {\n\t\t\tconfig.modules.shift();\n\t\t}\n\n\t\t// Avoid unnecessary information by not logging modules\' test environments\n\t\tfor ( i = 0, l = config.modules.length; i < l; i++ ) {\n\t\t\tmodulesLog.push( {\n\t\t\t\tname: config.modules[ i ].name,\n\t\t\t\ttests: config.modules[ i ].tests\n\t\t\t} );\n\t\t}\n\n\t\t// The test run is officially beginning now\n\t\trunLoggingCallbacks( "begin", {\n\t\t\ttotalTests: Test.count,\n\t\t\tmodules: modulesLog\n\t\t} );\n\t}\n\n\tconfig.blocking = false;\n\tprocess( true );\n}\n\nfunction process( last ) {\n\tfunction next() {\n\t\tprocess( last );\n\t}\n\tvar start = now();\n\tconfig.depth = ( config.depth || 0 ) + 1;\n\n\twhile ( config.queue.length && !config.blocking ) {\n\t\tif ( !defined.setTimeout || config.updateRate <= 0 ||\n\t\t\t\t( ( now() - start ) < config.updateRate ) ) {\n\t\t\tif ( config.current ) {\n\n\t\t\t\t// Reset async tracking for each phase of the Test lifecycle\n\t\t\t\tconfig.current.usedAsync = false;\n\t\t\t}\n\t\t\tconfig.queue.shift()();\n\t\t} else {\n\t\t\tsetTimeout( next, 13 );\n\t\t\tbreak;\n\t\t}\n\t}\n\tconfig.depth--;\n\tif ( last && !config.blocking && !config.queue.length && config.depth === 0 ) {\n\t\tdone();\n\t}\n}\n\nfunction pauseProcessing() {\n\tconfig.blocking = true;\n\n\tif ( config.testTimeout && defined.setTimeout ) {\n\t\tclearTimeout( config.timeout );\n\t\tconfig.timeout = setTimeout( function() {\n\t\t\tif ( config.current ) {\n\t\t\t\tconfig.current.semaphore = 0;\n\t\t\t\tQUnit.pushFailure( "Test timed out", sourceFromStacktrace( 2 ) );\n\t\t\t} else {\n\t\t\t\tthrow new Error( "Test timed out" );\n\t\t\t}\n\t\t\tresumeProcessing();\n\t\t}, config.testTimeout );\n\t}\n}\n\nfunction resumeProcessing() {\n\trunStarted = true;\n\n\t// A slight delay to allow this iteration of the event loop to finish (more assertions, etc.)\n\tif ( defined.setTimeout ) {\n\t\tsetTimeout( function() {\n\t\t\tif ( config.current && config.current.semaphore > 0 ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( config.timeout ) {\n\t\t\t\tclearTimeout( config.timeout );\n\t\t\t}\n\n\t\t\tbegin();\n\t\t}, 13 );\n\t} else {\n\t\tbegin();\n\t}\n}\n\nfunction done() {\n\tvar runtime, passed;\n\n\tconfig.autorun = true;\n\n\t// Log the last module results\n\tif ( config.previousModule ) {\n\t\trunLoggingCallbacks( "moduleDone", {\n\t\t\tname: config.previousModule.name,\n\t\t\ttests: config.previousModule.tests,\n\t\t\tfailed: config.moduleStats.bad,\n\t\t\tpassed: config.moduleStats.all - config.moduleStats.bad,\n\t\t\ttotal: config.moduleStats.all,\n\t\t\truntime: now() - config.moduleStats.started\n\t\t} );\n\t}\n\tdelete config.previousModule;\n\n\truntime = now() - config.started;\n\tpassed = config.stats.all - config.stats.bad;\n\n\trunLoggingCallbacks( "done", {\n\t\tfailed: config.stats.bad,\n\t\tpassed: passed,\n\t\ttotal: config.stats.all,\n\t\truntime: runtime\n\t} );\n}\n\nfunction setHook( module, hookName ) {\n\tif ( module.testEnvironment === undefined ) {\n\t\tmodule.testEnvironment = {};\n\t}\n\n\treturn function( callback ) {\n\t\tmodule.testEnvironment[ hookName ] = callback;\n\t};\n}\n\nvar focused = false;\nvar priorityCount = 0;\nvar unitSampler;\n\nfunction Test( settings ) {\n\tvar i, l;\n\n\t++Test.count;\n\n\textend( this, settings );\n\tthis.assertions = [];\n\tthis.semaphore = 0;\n\tthis.usedAsync = false;\n\tthis.module = config.currentModule;\n\tthis.stack = sourceFromStacktrace( 3 );\n\n\t// Register unique strings\n\tfor ( i = 0, l = this.module.tests; i < l.length; i++ ) {\n\t\tif ( this.module.tests[ i ].name === this.testName ) {\n\t\t\tthis.testName += " ";\n\t\t}\n\t}\n\n\tthis.testId = generateHash( this.module.name, this.testName );\n\n\tthis.module.tests.push( {\n\t\tname: this.testName,\n\t\ttestId: this.testId\n\t} );\n\n\tif ( settings.skip ) {\n\n\t\t// Skipped tests will fully ignore any sent callback\n\t\tthis.callback = function() {};\n\t\tthis.async = false;\n\t\tthis.expected = 0;\n\t} else {\n\t\tthis.assert = new Assert( this );\n\t}\n}\n\nTest.count = 0;\n\nTest.prototype = {\n\tbefore: function() {\n\t\tif (\n\n\t\t\t// Emit moduleStart when we\'re switching from one module to another\n\t\t\tthis.module !== config.previousModule ||\n\n\t\t\t\t// They could be equal (both undefined) but if the previousModule property doesn\'t\n\t\t\t\t// yet exist it means this is the first test in a suite that isn\'t wrapped in a\n\t\t\t\t// module, in which case we\'ll just emit a moduleStart event for \'undefined\'.\n\t\t\t\t// Without this, reporters can get testStart before moduleStart  which is a problem.\n\t\t\t\t!hasOwn.call( config, "previousModule" )\n\t\t) {\n\t\t\tif ( hasOwn.call( config, "previousModule" ) ) {\n\t\t\t\trunLoggingCallbacks( "moduleDone", {\n\t\t\t\t\tname: config.previousModule.name,\n\t\t\t\t\ttests: config.previousModule.tests,\n\t\t\t\t\tfailed: config.moduleStats.bad,\n\t\t\t\t\tpassed: config.moduleStats.all - config.moduleStats.bad,\n\t\t\t\t\ttotal: config.moduleStats.all,\n\t\t\t\t\truntime: now() - config.moduleStats.started\n\t\t\t\t} );\n\t\t\t}\n\t\t\tconfig.previousModule = this.module;\n\t\t\tconfig.moduleStats = { all: 0, bad: 0, started: now() };\n\t\t\trunLoggingCallbacks( "moduleStart", {\n\t\t\t\tname: this.module.name,\n\t\t\t\ttests: this.module.tests\n\t\t\t} );\n\t\t}\n\n\t\tconfig.current = this;\n\n\t\tif ( this.module.testEnvironment ) {\n\t\t\tdelete this.module.testEnvironment.beforeEach;\n\t\t\tdelete this.module.testEnvironment.afterEach;\n\t\t}\n\t\tthis.testEnvironment = extend( {}, this.module.testEnvironment );\n\n\t\tthis.started = now();\n\t\trunLoggingCallbacks( "testStart", {\n\t\t\tname: this.testName,\n\t\t\tmodule: this.module.name,\n\t\t\ttestId: this.testId\n\t\t} );\n\n\t\tif ( !config.pollution ) {\n\t\t\tsaveGlobal();\n\t\t}\n\t},\n\n\trun: function() {\n\t\tvar promise;\n\n\t\tconfig.current = this;\n\n\t\tif ( this.async ) {\n\t\t\tQUnit.stop();\n\t\t}\n\n\t\tthis.callbackStarted = now();\n\n\t\tif ( config.notrycatch ) {\n\t\t\trunTest( this );\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\trunTest( this );\n\t\t} catch ( e ) {\n\t\t\tthis.pushFailure( "Died on test #" + ( this.assertions.length + 1 ) + " " +\n\t\t\t\tthis.stack + ": " + ( e.message || e ), extractStacktrace( e, 0 ) );\n\n\t\t\t// Else next test will carry the responsibility\n\t\t\tsaveGlobal();\n\n\t\t\t// Restart the tests if they\'re blocking\n\t\t\tif ( config.blocking ) {\n\t\t\t\tQUnit.start();\n\t\t\t}\n\t\t}\n\n\t\tfunction runTest( test ) {\n\t\t\tpromise = test.callback.call( test.testEnvironment, test.assert );\n\t\t\ttest.resolvePromise( promise );\n\t\t}\n\t},\n\n\tafter: function() {\n\t\tcheckPollution();\n\t},\n\n\tqueueHook: function( hook, hookName ) {\n\t\tvar promise,\n\t\t\ttest = this;\n\t\treturn function runHook() {\n\t\t\tconfig.current = test;\n\t\t\tif ( config.notrycatch ) {\n\t\t\t\tcallHook();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tcallHook();\n\t\t\t} catch ( error ) {\n\t\t\t\ttest.pushFailure( hookName + " failed on " + test.testName + ": " +\n\t\t\t\t( error.message || error ), extractStacktrace( error, 0 ) );\n\t\t\t}\n\n\t\t\tfunction callHook() {\n\t\t\t\tpromise = hook.call( test.testEnvironment, test.assert );\n\t\t\t\ttest.resolvePromise( promise, hookName );\n\t\t\t}\n\t\t};\n\t},\n\n\t// Currently only used for module level hooks, can be used to add global level ones\n\thooks: function( handler ) {\n\t\tvar hooks = [];\n\n\t\tfunction processHooks( test, module ) {\n\t\t\tif ( module.parentModule ) {\n\t\t\t\tprocessHooks( test, module.parentModule );\n\t\t\t}\n\t\t\tif ( module.testEnvironment &&\n\t\t\t\tQUnit.objectType( module.testEnvironment[ handler ] ) === "function" ) {\n\t\t\t\thooks.push( test.queueHook( module.testEnvironment[ handler ], handler ) );\n\t\t\t}\n\t\t}\n\n\t\t// Hooks are ignored on skipped tests\n\t\tif ( !this.skip ) {\n\t\t\tprocessHooks( this, this.module );\n\t\t}\n\t\treturn hooks;\n\t},\n\n\tfinish: function() {\n\t\tconfig.current = this;\n\t\tif ( config.requireExpects && this.expected === null ) {\n\t\t\tthis.pushFailure( "Expected number of assertions to be defined, but expect() was " +\n\t\t\t\t"not called.", this.stack );\n\t\t} else if ( this.expected !== null && this.expected !== this.assertions.length ) {\n\t\t\tthis.pushFailure( "Expected " + this.expected + " assertions, but " +\n\t\t\t\tthis.assertions.length + " were run", this.stack );\n\t\t} else if ( this.expected === null && !this.assertions.length ) {\n\t\t\tthis.pushFailure( "Expected at least one assertion, but none were run - call " +\n\t\t\t\t"expect(0) to accept zero assertions.", this.stack );\n\t\t}\n\n\t\tvar i,\n\t\t\tbad = 0;\n\n\t\tthis.runtime = now() - this.started;\n\t\tconfig.stats.all += this.assertions.length;\n\t\tconfig.moduleStats.all += this.assertions.length;\n\n\t\tfor ( i = 0; i < this.assertions.length; i++ ) {\n\t\t\tif ( !this.assertions[ i ].result ) {\n\t\t\t\tbad++;\n\t\t\t\tconfig.stats.bad++;\n\t\t\t\tconfig.moduleStats.bad++;\n\t\t\t}\n\t\t}\n\n\t\trunLoggingCallbacks( "testDone", {\n\t\t\tname: this.testName,\n\t\t\tmodule: this.module.name,\n\t\t\tskipped: !!this.skip,\n\t\t\tfailed: bad,\n\t\t\tpassed: this.assertions.length - bad,\n\t\t\ttotal: this.assertions.length,\n\t\t\truntime: this.runtime,\n\n\t\t\t// HTML Reporter use\n\t\t\tassertions: this.assertions,\n\t\t\ttestId: this.testId,\n\n\t\t\t// Source of Test\n\t\t\tsource: this.stack,\n\n\t\t\t// DEPRECATED: this property will be removed in 2.0.0, use runtime instead\n\t\t\tduration: this.runtime\n\t\t} );\n\n\t\t// QUnit.reset() is deprecated and will be replaced for a new\n\t\t// fixture reset function on QUnit 2.0/2.1.\n\t\t// It\'s still called here for backwards compatibility handling\n\t\tQUnit.reset();\n\n\t\tconfig.current = undefined;\n\t},\n\n\tqueue: function() {\n\t\tvar priority,\n\t\t\ttest = this;\n\n\t\tif ( !this.valid() ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfunction run() {\n\n\t\t\t// Each of these can by async\n\t\t\tsynchronize( [\n\t\t\t\tfunction() {\n\t\t\t\t\ttest.before();\n\t\t\t\t},\n\n\t\t\t\ttest.hooks( "beforeEach" ),\n\t\t\t\tfunction() {\n\t\t\t\t\ttest.run();\n\t\t\t\t},\n\n\t\t\t\ttest.hooks( "afterEach" ).reverse(),\n\n\t\t\t\tfunction() {\n\t\t\t\t\ttest.after();\n\t\t\t\t},\n\t\t\t\tfunction() {\n\t\t\t\t\ttest.finish();\n\t\t\t\t}\n\t\t\t] );\n\t\t}\n\n\t\t// Prioritize previously failed tests, detected from sessionStorage\n\t\tpriority = QUnit.config.reorder && defined.sessionStorage &&\n\t\t\t\t+sessionStorage.getItem( "qunit-test-" + this.module.name + "-" + this.testName );\n\n\t\treturn synchronize( run, priority, config.seed );\n\t},\n\n\tpushResult: function( resultInfo ) {\n\n\t\t// Destructure of resultInfo = { result, actual, expected, message, negative }\n\t\tvar source,\n\t\t\tdetails = {\n\t\t\t\tmodule: this.module.name,\n\t\t\t\tname: this.testName,\n\t\t\t\tresult: resultInfo.result,\n\t\t\t\tmessage: resultInfo.message,\n\t\t\t\tactual: resultInfo.actual,\n\t\t\t\texpected: resultInfo.expected,\n\t\t\t\ttestId: this.testId,\n\t\t\t\tnegative: resultInfo.negative || false,\n\t\t\t\truntime: now() - this.started\n\t\t\t};\n\n\t\tif ( !resultInfo.result ) {\n\t\t\tsource = sourceFromStacktrace();\n\n\t\t\tif ( source ) {\n\t\t\t\tdetails.source = source;\n\t\t\t}\n\t\t}\n\n\t\trunLoggingCallbacks( "log", details );\n\n\t\tthis.assertions.push( {\n\t\t\tresult: !!resultInfo.result,\n\t\t\tmessage: resultInfo.message\n\t\t} );\n\t},\n\n\tpushFailure: function( message, source, actual ) {\n\t\tif ( !( this instanceof Test ) ) {\n\t\t\tthrow new Error( "pushFailure() assertion outside test context, was " +\n\t\t\t\tsourceFromStacktrace( 2 ) );\n\t\t}\n\n\t\tvar details = {\n\t\t\t\tmodule: this.module.name,\n\t\t\t\tname: this.testName,\n\t\t\t\tresult: false,\n\t\t\t\tmessage: message || "error",\n\t\t\t\tactual: actual || null,\n\t\t\t\ttestId: this.testId,\n\t\t\t\truntime: now() - this.started\n\t\t\t};\n\n\t\tif ( source ) {\n\t\t\tdetails.source = source;\n\t\t}\n\n\t\trunLoggingCallbacks( "log", details );\n\n\t\tthis.assertions.push( {\n\t\t\tresult: false,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tresolvePromise: function( promise, phase ) {\n\t\tvar then, message,\n\t\t\ttest = this;\n\t\tif ( promise != null ) {\n\t\t\tthen = promise.then;\n\t\t\tif ( QUnit.objectType( then ) === "function" ) {\n\t\t\t\tQUnit.stop();\n\t\t\t\tthen.call(\n\t\t\t\t\tpromise,\n\t\t\t\t\tfunction() { QUnit.start(); },\n\t\t\t\t\tfunction( error ) {\n\t\t\t\t\t\tmessage = "Promise rejected " +\n\t\t\t\t\t\t\t( !phase ? "during" : phase.replace( /Each$/, "" ) ) +\n\t\t\t\t\t\t\t" " + test.testName + ": " + ( error.message || error );\n\t\t\t\t\t\ttest.pushFailure( message, extractStacktrace( error, 0 ) );\n\n\t\t\t\t\t\t// Else next test will carry the responsibility\n\t\t\t\t\t\tsaveGlobal();\n\n\t\t\t\t\t\t// Unblock\n\t\t\t\t\t\tQUnit.start();\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t},\n\n\tvalid: function() {\n\t\tvar filter = config.filter,\n\t\t\tregexFilter = /^(!?)\\/([\\w\\W]*)\\/(i?$)/.exec( filter ),\n\t\t\tmodule = config.module && config.module.toLowerCase(),\n\t\t\tfullName = ( this.module.name + ": " + this.testName );\n\n\t\tfunction moduleChainNameMatch( testModule ) {\n\t\t\tvar testModuleName = testModule.name ? testModule.name.toLowerCase() : null;\n\t\t\tif ( testModuleName === module ) {\n\t\t\t\treturn true;\n\t\t\t} else if ( testModule.parentModule ) {\n\t\t\t\treturn moduleChainNameMatch( testModule.parentModule );\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfunction moduleChainIdMatch( testModule ) {\n\t\t\treturn inArray( testModule.moduleId, config.moduleId ) > -1 ||\n\t\t\t\ttestModule.parentModule && moduleChainIdMatch( testModule.parentModule );\n\t\t}\n\n\t\t// Internally-generated tests are always valid\n\t\tif ( this.callback && this.callback.validTest ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif ( config.moduleId && config.moduleId.length > 0 &&\n\t\t\t!moduleChainIdMatch( this.module ) ) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( config.testId && config.testId.length > 0 &&\n\t\t\tinArray( this.testId, config.testId ) < 0 ) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( module && !moduleChainNameMatch( this.module ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( !filter ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn regexFilter ?\n\t\t\tthis.regexFilter( !!regexFilter[ 1 ], regexFilter[ 2 ], regexFilter[ 3 ], fullName ) :\n\t\t\tthis.stringFilter( filter, fullName );\n\t},\n\n\tregexFilter: function( exclude, pattern, flags, fullName ) {\n\t\tvar regex = new RegExp( pattern, flags );\n\t\tvar match = regex.test( fullName );\n\n\t\treturn match !== exclude;\n\t},\n\n\tstringFilter: function( filter, fullName ) {\n\t\tfilter = filter.toLowerCase();\n\t\tfullName = fullName.toLowerCase();\n\n\t\tvar include = filter.charAt( 0 ) !== "!";\n\t\tif ( !include ) {\n\t\t\tfilter = filter.slice( 1 );\n\t\t}\n\n\t\t// If the filter matches, we need to honour include\n\t\tif ( fullName.indexOf( filter ) !== -1 ) {\n\t\t\treturn include;\n\t\t}\n\n\t\t// Otherwise, do the opposite\n\t\treturn !include;\n\t}\n};\n\n// Resets the test setup. Useful for tests that modify the DOM.\n/*\nDEPRECATED: Use multiple tests instead of resetting inside a test.\nUse testStart or testDone for custom cleanup.\nThis method will throw an error in 2.0, and will be removed in 2.1\n*/\nQUnit.reset = function() {\n\n\t// Return on non-browser environments\n\t// This is necessary to not break on node tests\n\tif ( !defined.document ) {\n\t\treturn;\n\t}\n\n\tvar fixture = defined.document && document.getElementById &&\n\t\t\tdocument.getElementById( "qunit-fixture" );\n\n\tif ( fixture ) {\n\t\tfixture.innerHTML = config.fixture;\n\t}\n};\n\nQUnit.pushFailure = function() {\n\tif ( !QUnit.config.current ) {\n\t\tthrow new Error( "pushFailure() assertion outside test context, in " +\n\t\t\tsourceFromStacktrace( 2 ) );\n\t}\n\n\t// Gets current test obj\n\tvar currentTest = QUnit.config.current;\n\n\treturn currentTest.pushFailure.apply( currentTest, arguments );\n};\n\n// Based on Java\'s String.hashCode, a simple but not\n// rigorously collision resistant hashing function\nfunction generateHash( module, testName ) {\n\tvar hex,\n\t\ti = 0,\n\t\thash = 0,\n\t\tstr = module + "\\x1C" + testName,\n\t\tlen = str.length;\n\n\tfor ( ; i < len; i++ ) {\n\t\thash  = ( ( hash << 5 ) - hash ) + str.charCodeAt( i );\n\t\thash |= 0;\n\t}\n\n\t// Convert the possibly negative integer hash code into an 8 character hex string, which isn\'t\n\t// strictly necessary but increases user understanding that the id is a SHA-like hash\n\thex = ( 0x100000000 + hash ).toString( 16 );\n\tif ( hex.length < 8 ) {\n\t\thex = "0000000" + hex;\n\t}\n\n\treturn hex.slice( -8 );\n}\n\nfunction synchronize( callback, priority, seed ) {\n\tvar last = !priority,\n\t\tindex;\n\n\tif ( QUnit.objectType( callback ) === "array" ) {\n\t\twhile ( callback.length ) {\n\t\t\tsynchronize( callback.shift() );\n\t\t}\n\t\treturn;\n\t}\n\n\tif ( priority ) {\n\t\tconfig.queue.splice( priorityCount++, 0, callback );\n\t} else if ( seed ) {\n\t\tif ( !unitSampler ) {\n\t\t\tunitSampler = unitSamplerGenerator( seed );\n\t\t}\n\n\t\t// Insert into a random position after all priority items\n\t\tindex = Math.floor( unitSampler() * ( config.queue.length - priorityCount + 1 ) );\n\t\tconfig.queue.splice( priorityCount + index, 0, callback );\n\t} else {\n\t\tconfig.queue.push( callback );\n\t}\n\n\tif ( config.autorun && !config.blocking ) {\n\t\tprocess( last );\n\t}\n}\n\nfunction unitSamplerGenerator( seed ) {\n\n\t// 32-bit xorshift, requires only a nonzero seed\n\t// http://excamera.com/sphinx/article-xorshift.html\n\tvar sample = parseInt( generateHash( seed ), 16 ) || -1;\n\treturn function() {\n\t\tsample ^= sample << 13;\n\t\tsample ^= sample >>> 17;\n\t\tsample ^= sample << 5;\n\n\t\t// ECMAScript has no unsigned number type\n\t\tif ( sample < 0 ) {\n\t\t\tsample += 0x100000000;\n\t\t}\n\n\t\treturn sample / 0x100000000;\n\t};\n}\n\nfunction saveGlobal() {\n\tconfig.pollution = [];\n\n\tif ( config.noglobals ) {\n\t\tfor ( var key in global ) {\n\t\t\tif ( hasOwn.call( global, key ) ) {\n\n\t\t\t\t// In Opera sometimes DOM element ids show up here, ignore them\n\t\t\t\tif ( /^qunit-test-output/.test( key ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconfig.pollution.push( key );\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction checkPollution() {\n\tvar newGlobals,\n\t\tdeletedGlobals,\n\t\told = config.pollution;\n\n\tsaveGlobal();\n\n\tnewGlobals = diff( config.pollution, old );\n\tif ( newGlobals.length > 0 ) {\n\t\tQUnit.pushFailure( "Introduced global variable(s): " + newGlobals.join( ", " ) );\n\t}\n\n\tdeletedGlobals = diff( old, config.pollution );\n\tif ( deletedGlobals.length > 0 ) {\n\t\tQUnit.pushFailure( "Deleted global variable(s): " + deletedGlobals.join( ", " ) );\n\t}\n}\n\n// Will be exposed as QUnit.asyncTest\nfunction asyncTest( testName, expected, callback ) {\n\tif ( arguments.length === 2 ) {\n\t\tcallback = expected;\n\t\texpected = null;\n\t}\n\n\tQUnit.test( testName, expected, callback, true );\n}\n\n// Will be exposed as QUnit.test\nfunction test( testName, expected, callback, async ) {\n\tif ( focused )  { return; }\n\n\tvar newTest;\n\n\tif ( arguments.length === 2 ) {\n\t\tcallback = expected;\n\t\texpected = null;\n\t}\n\n\tnewTest = new Test( {\n\t\ttestName: testName,\n\t\texpected: expected,\n\t\tasync: async,\n\t\tcallback: callback\n\t} );\n\n\tnewTest.queue();\n}\n\n// Will be exposed as QUnit.skip\nfunction skip( testName ) {\n\tif ( focused )  { return; }\n\n\tvar test = new Test( {\n\t\ttestName: testName,\n\t\tskip: true\n\t} );\n\n\ttest.queue();\n}\n\n// Will be exposed as QUnit.only\nfunction only( testName, expected, callback, async ) {\n\tvar newTest;\n\n\tif ( focused )  { return; }\n\n\tQUnit.config.queue.length = 0;\n\tfocused = true;\n\n\tif ( arguments.length === 2 ) {\n\t\tcallback = expected;\n\t\texpected = null;\n\t}\n\n\tnewTest = new Test( {\n\t\ttestName: testName,\n\t\texpected: expected,\n\t\tasync: async,\n\t\tcallback: callback\n\t} );\n\n\tnewTest.queue();\n}\n\nfunction Assert( testContext ) {\n\tthis.test = testContext;\n}\n\n// Assert helpers\nQUnit.assert = Assert.prototype = {\n\n\t// Specify the number of expected assertions to guarantee that failed test\n\t// (no assertions are run at all) don\'t slip through.\n\texpect: function( asserts ) {\n\t\tif ( arguments.length === 1 ) {\n\t\t\tthis.test.expected = asserts;\n\t\t} else {\n\t\t\treturn this.test.expected;\n\t\t}\n\t},\n\n\t// Increment this Test\'s semaphore counter, then return a function that\n\t// decrements that counter a maximum of once.\n\tasync: function( count ) {\n\t\tvar test = this.test,\n\t\t\tpopped = false,\n\t\t\tacceptCallCount = count;\n\n\t\tif ( typeof acceptCallCount === "undefined" ) {\n\t\t\tacceptCallCount = 1;\n\t\t}\n\n\t\ttest.semaphore += 1;\n\t\ttest.usedAsync = true;\n\t\tpauseProcessing();\n\n\t\treturn function done() {\n\n\t\t\tif ( popped ) {\n\t\t\t\ttest.pushFailure( "Too many calls to the `assert.async` callback",\n\t\t\t\t\tsourceFromStacktrace( 2 ) );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tacceptCallCount -= 1;\n\t\t\tif ( acceptCallCount > 0 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttest.semaphore -= 1;\n\t\t\tpopped = true;\n\t\t\tresumeProcessing();\n\t\t};\n\t},\n\n\t// Exports test.push() to the user API\n\t// Alias of pushResult.\n\tpush: function( result, actual, expected, message, negative ) {\n\t\tvar currentAssert = this instanceof Assert ? this : QUnit.config.current.assert;\n\t\treturn currentAssert.pushResult( {\n\t\t\tresult: result,\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message,\n\t\t\tnegative: negative\n\t\t} );\n\t},\n\n\tpushResult: function( resultInfo ) {\n\n\t\t// Destructure of resultInfo = { result, actual, expected, message, negative }\n\t\tvar assert = this,\n\t\t\tcurrentTest = ( assert instanceof Assert && assert.test ) || QUnit.config.current;\n\n\t\t// Backwards compatibility fix.\n\t\t// Allows the direct use of global exported assertions and QUnit.assert.*\n\t\t// Although, it\'s use is not recommended as it can leak assertions\n\t\t// to other tests from async tests, because we only get a reference to the current test,\n\t\t// not exactly the test where assertion were intended to be called.\n\t\tif ( !currentTest ) {\n\t\t\tthrow new Error( "assertion outside test context, in " + sourceFromStacktrace( 2 ) );\n\t\t}\n\n\t\tif ( currentTest.usedAsync === true && currentTest.semaphore === 0 ) {\n\t\t\tcurrentTest.pushFailure( "Assertion after the final `assert.async` was resolved",\n\t\t\t\tsourceFromStacktrace( 2 ) );\n\n\t\t\t// Allow this assertion to continue running anyway...\n\t\t}\n\n\t\tif ( !( assert instanceof Assert ) ) {\n\t\t\tassert = currentTest.assert;\n\t\t}\n\n\t\treturn assert.test.pushResult( resultInfo );\n\t},\n\n\tok: function( result, message ) {\n\t\tmessage = message || ( result ? "okay" : "failed, expected argument to be truthy, was: " +\n\t\t\tQUnit.dump.parse( result ) );\n\t\tthis.pushResult( {\n\t\t\tresult: !!result,\n\t\t\tactual: result,\n\t\t\texpected: true,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tnotOk: function( result, message ) {\n\t\tmessage = message || ( !result ? "okay" : "failed, expected argument to be falsy, was: " +\n\t\t\tQUnit.dump.parse( result ) );\n\t\tthis.pushResult( {\n\t\t\tresult: !result,\n\t\t\tactual: result,\n\t\t\texpected: false,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tequal: function( actual, expected, message ) {\n\t\t/*jshint eqeqeq:false */\n\t\tthis.pushResult( {\n\t\t\tresult: expected == actual,\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tnotEqual: function( actual, expected, message ) {\n\t\t/*jshint eqeqeq:false */\n\t\tthis.pushResult( {\n\t\t\tresult: expected != actual,\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message,\n\t\t\tnegative: true\n\t\t} );\n\t},\n\n\tpropEqual: function( actual, expected, message ) {\n\t\tactual = objectValues( actual );\n\t\texpected = objectValues( expected );\n\t\tthis.pushResult( {\n\t\t\tresult: QUnit.equiv( actual, expected ),\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tnotPropEqual: function( actual, expected, message ) {\n\t\tactual = objectValues( actual );\n\t\texpected = objectValues( expected );\n\t\tthis.pushResult( {\n\t\t\tresult: !QUnit.equiv( actual, expected ),\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message,\n\t\t\tnegative: true\n\t\t} );\n\t},\n\n\tdeepEqual: function( actual, expected, message ) {\n\t\tthis.pushResult( {\n\t\t\tresult: QUnit.equiv( actual, expected ),\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tnotDeepEqual: function( actual, expected, message ) {\n\t\tthis.pushResult( {\n\t\t\tresult: !QUnit.equiv( actual, expected ),\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message,\n\t\t\tnegative: true\n\t\t} );\n\t},\n\n\tstrictEqual: function( actual, expected, message ) {\n\t\tthis.pushResult( {\n\t\t\tresult: expected === actual,\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tnotStrictEqual: function( actual, expected, message ) {\n\t\tthis.pushResult( {\n\t\t\tresult: expected !== actual,\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message,\n\t\t\tnegative: true\n\t\t} );\n\t},\n\n\t"throws": function( block, expected, message ) {\n\t\tvar actual, expectedType,\n\t\t\texpectedOutput = expected,\n\t\t\tok = false,\n\t\t\tcurrentTest = ( this instanceof Assert && this.test ) || QUnit.config.current;\n\n\t\t// \'expected\' is optional unless doing string comparison\n\t\tif ( message == null && typeof expected === "string" ) {\n\t\t\tmessage = expected;\n\t\t\texpected = null;\n\t\t}\n\n\t\tcurrentTest.ignoreGlobalErrors = true;\n\t\ttry {\n\t\t\tblock.call( currentTest.testEnvironment );\n\t\t} catch ( e ) {\n\t\t\tactual = e;\n\t\t}\n\t\tcurrentTest.ignoreGlobalErrors = false;\n\n\t\tif ( actual ) {\n\t\t\texpectedType = QUnit.objectType( expected );\n\n\t\t\t// We don\'t want to validate thrown error\n\t\t\tif ( !expected ) {\n\t\t\t\tok = true;\n\t\t\t\texpectedOutput = null;\n\n\t\t\t// Expected is a regexp\n\t\t\t} else if ( expectedType === "regexp" ) {\n\t\t\t\tok = expected.test( errorString( actual ) );\n\n\t\t\t// Expected is a string\n\t\t\t} else if ( expectedType === "string" ) {\n\t\t\t\tok = expected === errorString( actual );\n\n\t\t\t// Expected is a constructor, maybe an Error constructor\n\t\t\t} else if ( expectedType === "function" && actual instanceof expected ) {\n\t\t\t\tok = true;\n\n\t\t\t// Expected is an Error object\n\t\t\t} else if ( expectedType === "object" ) {\n\t\t\t\tok = actual instanceof expected.constructor &&\n\t\t\t\t\tactual.name === expected.name &&\n\t\t\t\t\tactual.message === expected.message;\n\n\t\t\t// Expected is a validation function which returns true if validation passed\n\t\t\t} else if ( expectedType === "function" && expected.call( {}, actual ) === true ) {\n\t\t\t\texpectedOutput = null;\n\t\t\t\tok = true;\n\t\t\t}\n\t\t}\n\n\t\tcurrentTest.assert.pushResult( {\n\t\t\tresult: ok,\n\t\t\tactual: actual,\n\t\t\texpected: expectedOutput,\n\t\t\tmessage: message\n\t\t} );\n\t}\n};\n\n// Provide an alternative to assert.throws(), for environments that consider throws a reserved word\n// Known to us are: Closure Compiler, Narwhal\n( function() {\n\t/*jshint sub:true */\n\tAssert.prototype.raises = Assert.prototype [ "throws" ]; //jscs:ignore requireDotNotation\n}() );\n\nfunction errorString( error ) {\n\tvar name, message,\n\t\tresultErrorString = error.toString();\n\tif ( resultErrorString.substring( 0, 7 ) === "[object" ) {\n\t\tname = error.name ? error.name.toString() : "Error";\n\t\tmessage = error.message ? error.message.toString() : "";\n\t\tif ( name && message ) {\n\t\t\treturn name + ": " + message;\n\t\t} else if ( name ) {\n\t\t\treturn name;\n\t\t} else if ( message ) {\n\t\t\treturn message;\n\t\t} else {\n\t\t\treturn "Error";\n\t\t}\n\t} else {\n\t\treturn resultErrorString;\n\t}\n}\n\n// Test for equality any JavaScript type.\n// Author: Philippe Rathé <prathe@gmail.com>\nQUnit.equiv = ( function() {\n\n\t// Stack to decide between skip/abort functions\n\tvar callers = [];\n\n\t// Stack to avoiding loops from circular referencing\n\tvar parents = [];\n\tvar parentsB = [];\n\n\tvar getProto = Object.getPrototypeOf || function( obj ) {\n\n\t\t/*jshint proto: true */\n\t\treturn obj.__proto__;\n\t};\n\n\tfunction useStrictEquality( b, a ) {\n\n\t\t// To catch short annotation VS \'new\' annotation of a declaration. e.g.:\n\t\t// `var i = 1;`\n\t\t// `var j = new Number(1);`\n\t\tif ( typeof a === "object" ) {\n\t\t\ta = a.valueOf();\n\t\t}\n\t\tif ( typeof b === "object" ) {\n\t\t\tb = b.valueOf();\n\t\t}\n\n\t\treturn a === b;\n\t}\n\n\tfunction compareConstructors( a, b ) {\n\t\tvar protoA = getProto( a );\n\t\tvar protoB = getProto( b );\n\n\t\t// Comparing constructors is more strict than using `instanceof`\n\t\tif ( a.constructor === b.constructor ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Ref #851\n\t\t// If the obj prototype descends from a null constructor, treat it\n\t\t// as a null prototype.\n\t\tif ( protoA && protoA.constructor === null ) {\n\t\t\tprotoA = null;\n\t\t}\n\t\tif ( protoB && protoB.constructor === null ) {\n\t\t\tprotoB = null;\n\t\t}\n\n\t\t// Allow objects with no prototype to be equivalent to\n\t\t// objects with Object as their constructor.\n\t\tif ( ( protoA === null && protoB === Object.prototype ) ||\n\t\t\t\t( protoB === null && protoA === Object.prototype ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tfunction getRegExpFlags( regexp ) {\n\t\treturn "flags" in regexp ? regexp.flags : regexp.toString().match( /[gimuy]*$/ )[ 0 ];\n\t}\n\n\tvar callbacks = {\n\t\t"string": useStrictEquality,\n\t\t"boolean": useStrictEquality,\n\t\t"number": useStrictEquality,\n\t\t"null": useStrictEquality,\n\t\t"undefined": useStrictEquality,\n\t\t"symbol": useStrictEquality,\n\t\t"date": useStrictEquality,\n\n\t\t"nan": function() {\n\t\t\treturn true;\n\t\t},\n\n\t\t"regexp": function( b, a ) {\n\t\t\treturn a.source === b.source &&\n\n\t\t\t\t// Include flags in the comparison\n\t\t\t\tgetRegExpFlags( a ) === getRegExpFlags( b );\n\t\t},\n\n\t\t// - skip when the property is a method of an instance (OOP)\n\t\t// - abort otherwise,\n\t\t// initial === would have catch identical references anyway\n\t\t"function": function() {\n\t\t\tvar caller = callers[ callers.length - 1 ];\n\t\t\treturn caller !== Object && typeof caller !== "undefined";\n\t\t},\n\n\t\t"array": function( b, a ) {\n\t\t\tvar i, j, len, loop, aCircular, bCircular;\n\n\t\t\tlen = a.length;\n\t\t\tif ( len !== b.length ) {\n\n\t\t\t\t// Safe and faster\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Track reference to avoid circular references\n\t\t\tparents.push( a );\n\t\t\tparentsB.push( b );\n\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\tloop = false;\n\t\t\t\tfor ( j = 0; j < parents.length; j++ ) {\n\t\t\t\t\taCircular = parents[ j ] === a[ i ];\n\t\t\t\t\tbCircular = parentsB[ j ] === b[ i ];\n\t\t\t\t\tif ( aCircular || bCircular ) {\n\t\t\t\t\t\tif ( a[ i ] === b[ i ] || aCircular && bCircular ) {\n\t\t\t\t\t\t\tloop = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tparents.pop();\n\t\t\t\t\t\t\tparentsB.pop();\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( !loop && !innerEquiv( a[ i ], b[ i ] ) ) {\n\t\t\t\t\tparents.pop();\n\t\t\t\t\tparentsB.pop();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tparents.pop();\n\t\t\tparentsB.pop();\n\t\t\treturn true;\n\t\t},\n\n\t\t"set": function( b, a ) {\n\t\t\tvar innerEq,\n\t\t\t\touterEq = true;\n\n\t\t\tif ( a.size !== b.size ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\ta.forEach( function( aVal ) {\n\t\t\t\tinnerEq = false;\n\n\t\t\t\tb.forEach( function( bVal ) {\n\t\t\t\t\tif ( innerEquiv( bVal, aVal ) ) {\n\t\t\t\t\t\tinnerEq = true;\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\tif ( !innerEq ) {\n\t\t\t\t\touterEq = false;\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\treturn outerEq;\n\t\t},\n\n\t\t"map": function( b, a ) {\n\t\t\tvar innerEq,\n\t\t\t\touterEq = true;\n\n\t\t\tif ( a.size !== b.size ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\ta.forEach( function( aVal, aKey ) {\n\t\t\t\tinnerEq = false;\n\n\t\t\t\tb.forEach( function( bVal, bKey ) {\n\t\t\t\t\tif ( innerEquiv( [ bVal, bKey ], [ aVal, aKey ] ) ) {\n\t\t\t\t\t\tinnerEq = true;\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\tif ( !innerEq ) {\n\t\t\t\t\touterEq = false;\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\treturn outerEq;\n\t\t},\n\n\t\t"object": function( b, a ) {\n\t\t\tvar i, j, loop, aCircular, bCircular;\n\n\t\t\t// Default to true\n\t\t\tvar eq = true;\n\t\t\tvar aProperties = [];\n\t\t\tvar bProperties = [];\n\n\t\t\tif ( compareConstructors( a, b ) === false ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Stack constructor before traversing properties\n\t\t\tcallers.push( a.constructor );\n\n\t\t\t// Track reference to avoid circular references\n\t\t\tparents.push( a );\n\t\t\tparentsB.push( b );\n\n\t\t\t// Be strict: don\'t ensure hasOwnProperty and go deep\n\t\t\tfor ( i in a ) {\n\t\t\t\tloop = false;\n\t\t\t\tfor ( j = 0; j < parents.length; j++ ) {\n\t\t\t\t\taCircular = parents[ j ] === a[ i ];\n\t\t\t\t\tbCircular = parentsB[ j ] === b[ i ];\n\t\t\t\t\tif ( aCircular || bCircular ) {\n\t\t\t\t\t\tif ( a[ i ] === b[ i ] || aCircular && bCircular ) {\n\t\t\t\t\t\t\tloop = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\teq = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taProperties.push( i );\n\t\t\t\tif ( !loop && !innerEquiv( a[ i ], b[ i ] ) ) {\n\t\t\t\t\teq = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tparents.pop();\n\t\t\tparentsB.pop();\n\n\t\t\t// Unstack, we are done\n\t\t\tcallers.pop();\n\n\t\t\tfor ( i in b ) {\n\n\t\t\t\t// Collect b\'s properties\n\t\t\t\tbProperties.push( i );\n\t\t\t}\n\n\t\t\t// Ensures identical properties name\n\t\t\treturn eq && innerEquiv( aProperties.sort(), bProperties.sort() );\n\t\t}\n\t};\n\n\tfunction typeEquiv( a, b ) {\n\t\tvar type = QUnit.objectType( a );\n\t\treturn QUnit.objectType( b ) === type && callbacks[ type ]( b, a );\n\t}\n\n\t// The real equiv function\n\tfunction innerEquiv( a, b ) {\n\n\t\t// We\'re done when there\'s nothing more to compare\n\t\tif ( arguments.length < 2 ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Require type-specific equality\n\t\treturn ( a === b || typeEquiv( a, b ) ) &&\n\n\t\t\t// ...across all consecutive argument pairs\n\t\t\t( arguments.length === 2 || innerEquiv.apply( this, [].slice.call( arguments, 1 ) ) );\n\t}\n\n\treturn innerEquiv;\n}() );\n\n// Based on jsDump by Ariel Flesler\n// http://flesler.blogspot.com/2008/05/jsdump-pretty-dump-of-any-javascript.html\nQUnit.dump = ( function() {\n\tfunction quote( str ) {\n\t\treturn "\\"" + str.toString().replace( /\\\\/g, "\\\\\\\\" ).replace( /"/g, "\\\\\\"" ) + "\\"";\n\t}\n\tfunction literal( o ) {\n\t\treturn o + "";\n\t}\n\tfunction join( pre, arr, post ) {\n\t\tvar s = dump.separator(),\n\t\t\tbase = dump.indent(),\n\t\t\tinner = dump.indent( 1 );\n\t\tif ( arr.join ) {\n\t\t\tarr = arr.join( "," + s + inner );\n\t\t}\n\t\tif ( !arr ) {\n\t\t\treturn pre + post;\n\t\t}\n\t\treturn [ pre, inner + arr, base + post ].join( s );\n\t}\n\tfunction array( arr, stack ) {\n\t\tvar i = arr.length,\n\t\t\tret = new Array( i );\n\n\t\tif ( dump.maxDepth && dump.depth > dump.maxDepth ) {\n\t\t\treturn "[object Array]";\n\t\t}\n\n\t\tthis.up();\n\t\twhile ( i-- ) {\n\t\t\tret[ i ] = this.parse( arr[ i ], undefined, stack );\n\t\t}\n\t\tthis.down();\n\t\treturn join( "[", ret, "]" );\n\t}\n\n\tvar reName = /^function (\\w+)/,\n\t\tdump = {\n\n\t\t\t// The objType is used mostly internally, you can fix a (custom) type in advance\n\t\t\tparse: function( obj, objType, stack ) {\n\t\t\t\tstack = stack || [];\n\t\t\t\tvar res, parser, parserType,\n\t\t\t\t\tinStack = inArray( obj, stack );\n\n\t\t\t\tif ( inStack !== -1 ) {\n\t\t\t\t\treturn "recursion(" + ( inStack - stack.length ) + ")";\n\t\t\t\t}\n\n\t\t\t\tobjType = objType || this.typeOf( obj  );\n\t\t\t\tparser = this.parsers[ objType ];\n\t\t\t\tparserType = typeof parser;\n\n\t\t\t\tif ( parserType === "function" ) {\n\t\t\t\t\tstack.push( obj );\n\t\t\t\t\tres = parser.call( this, obj, stack );\n\t\t\t\t\tstack.pop();\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\treturn ( parserType === "string" ) ? parser : this.parsers.error;\n\t\t\t},\n\t\t\ttypeOf: function( obj ) {\n\t\t\t\tvar type;\n\t\t\t\tif ( obj === null ) {\n\t\t\t\t\ttype = "null";\n\t\t\t\t} else if ( typeof obj === "undefined" ) {\n\t\t\t\t\ttype = "undefined";\n\t\t\t\t} else if ( QUnit.is( "regexp", obj ) ) {\n\t\t\t\t\ttype = "regexp";\n\t\t\t\t} else if ( QUnit.is( "date", obj ) ) {\n\t\t\t\t\ttype = "date";\n\t\t\t\t} else if ( QUnit.is( "function", obj ) ) {\n\t\t\t\t\ttype = "function";\n\t\t\t\t} else if ( obj.setInterval !== undefined &&\n\t\t\t\t\t\tobj.document !== undefined &&\n\t\t\t\t\t\tobj.nodeType === undefined ) {\n\t\t\t\t\ttype = "window";\n\t\t\t\t} else if ( obj.nodeType === 9 ) {\n\t\t\t\t\ttype = "document";\n\t\t\t\t} else if ( obj.nodeType ) {\n\t\t\t\t\ttype = "node";\n\t\t\t\t} else if (\n\n\t\t\t\t\t// Native arrays\n\t\t\t\t\ttoString.call( obj ) === "[object Array]" ||\n\n\t\t\t\t\t// NodeList objects\n\t\t\t\t\t( typeof obj.length === "number" && obj.item !== undefined &&\n\t\t\t\t\t( obj.length ? obj.item( 0 ) === obj[ 0 ] : ( obj.item( 0 ) === null &&\n\t\t\t\t\tobj[ 0 ] === undefined ) ) )\n\t\t\t\t) {\n\t\t\t\t\ttype = "array";\n\t\t\t\t} else if ( obj.constructor === Error.prototype.constructor ) {\n\t\t\t\t\ttype = "error";\n\t\t\t\t} else {\n\t\t\t\t\ttype = typeof obj;\n\t\t\t\t}\n\t\t\t\treturn type;\n\t\t\t},\n\n\t\t\tseparator: function() {\n\t\t\t\treturn this.multiline ? this.HTML ? "<br />" : "\\n" : this.HTML ? "&#160;" : " ";\n\t\t\t},\n\n\t\t\t// Extra can be a number, shortcut for increasing-calling-decreasing\n\t\t\tindent: function( extra ) {\n\t\t\t\tif ( !this.multiline ) {\n\t\t\t\t\treturn "";\n\t\t\t\t}\n\t\t\t\tvar chr = this.indentChar;\n\t\t\t\tif ( this.HTML ) {\n\t\t\t\t\tchr = chr.replace( /\\t/g, "   " ).replace( / /g, "&#160;" );\n\t\t\t\t}\n\t\t\t\treturn new Array( this.depth + ( extra || 0 ) ).join( chr );\n\t\t\t},\n\t\t\tup: function( a ) {\n\t\t\t\tthis.depth += a || 1;\n\t\t\t},\n\t\t\tdown: function( a ) {\n\t\t\t\tthis.depth -= a || 1;\n\t\t\t},\n\t\t\tsetParser: function( name, parser ) {\n\t\t\t\tthis.parsers[ name ] = parser;\n\t\t\t},\n\n\t\t\t// The next 3 are exposed so you can use them\n\t\t\tquote: quote,\n\t\t\tliteral: literal,\n\t\t\tjoin: join,\n\t\t\tdepth: 1,\n\t\t\tmaxDepth: QUnit.config.maxDepth,\n\n\t\t\t// This is the list of parsers, to modify them, use dump.setParser\n\t\t\tparsers: {\n\t\t\t\twindow: "[Window]",\n\t\t\t\tdocument: "[Document]",\n\t\t\t\terror: function( error ) {\n\t\t\t\t\treturn "Error(\\"" + error.message + "\\")";\n\t\t\t\t},\n\t\t\t\tunknown: "[Unknown]",\n\t\t\t\t"null": "null",\n\t\t\t\t"undefined": "undefined",\n\t\t\t\t"function": function( fn ) {\n\t\t\t\t\tvar ret = "function",\n\n\t\t\t\t\t\t// Functions never have name in IE\n\t\t\t\t\t\tname = "name" in fn ? fn.name : ( reName.exec( fn ) || [] )[ 1 ];\n\n\t\t\t\t\tif ( name ) {\n\t\t\t\t\t\tret += " " + name;\n\t\t\t\t\t}\n\t\t\t\t\tret += "(";\n\n\t\t\t\t\tret = [ ret, dump.parse( fn, "functionArgs" ), "){" ].join( "" );\n\t\t\t\t\treturn join( ret, dump.parse( fn, "functionCode" ), "}" );\n\t\t\t\t},\n\t\t\t\tarray: array,\n\t\t\t\tnodelist: array,\n\t\t\t\t"arguments": array,\n\t\t\t\tobject: function( map, stack ) {\n\t\t\t\t\tvar keys, key, val, i, nonEnumerableProperties,\n\t\t\t\t\t\tret = [];\n\n\t\t\t\t\tif ( dump.maxDepth && dump.depth > dump.maxDepth ) {\n\t\t\t\t\t\treturn "[object Object]";\n\t\t\t\t\t}\n\n\t\t\t\t\tdump.up();\n\t\t\t\t\tkeys = [];\n\t\t\t\t\tfor ( key in map ) {\n\t\t\t\t\t\tkeys.push( key );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Some properties are not always enumerable on Error objects.\n\t\t\t\t\tnonEnumerableProperties = [ "message", "name" ];\n\t\t\t\t\tfor ( i in nonEnumerableProperties ) {\n\t\t\t\t\t\tkey = nonEnumerableProperties[ i ];\n\t\t\t\t\t\tif ( key in map && inArray( key, keys ) < 0 ) {\n\t\t\t\t\t\t\tkeys.push( key );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tkeys.sort();\n\t\t\t\t\tfor ( i = 0; i < keys.length; i++ ) {\n\t\t\t\t\t\tkey = keys[ i ];\n\t\t\t\t\t\tval = map[ key ];\n\t\t\t\t\t\tret.push( dump.parse( key, "key" ) + ": " +\n\t\t\t\t\t\t\tdump.parse( val, undefined, stack ) );\n\t\t\t\t\t}\n\t\t\t\t\tdump.down();\n\t\t\t\t\treturn join( "{", ret, "}" );\n\t\t\t\t},\n\t\t\t\tnode: function( node ) {\n\t\t\t\t\tvar len, i, val,\n\t\t\t\t\t\topen = dump.HTML ? "&lt;" : "<",\n\t\t\t\t\t\tclose = dump.HTML ? "&gt;" : ">",\n\t\t\t\t\t\ttag = node.nodeName.toLowerCase(),\n\t\t\t\t\t\tret = open + tag,\n\t\t\t\t\t\tattrs = node.attributes;\n\n\t\t\t\t\tif ( attrs ) {\n\t\t\t\t\t\tfor ( i = 0, len = attrs.length; i < len; i++ ) {\n\t\t\t\t\t\t\tval = attrs[ i ].nodeValue;\n\n\t\t\t\t\t\t\t// IE6 includes all attributes in .attributes, even ones not explicitly\n\t\t\t\t\t\t\t// set. Those have values like undefined, null, 0, false, "" or\n\t\t\t\t\t\t\t// "inherit".\n\t\t\t\t\t\t\tif ( val && val !== "inherit" ) {\n\t\t\t\t\t\t\t\tret += " " + attrs[ i ].nodeName + "=" +\n\t\t\t\t\t\t\t\t\tdump.parse( val, "attribute" );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tret += close;\n\n\t\t\t\t\t// Show content of TextNode or CDATASection\n\t\t\t\t\tif ( node.nodeType === 3 || node.nodeType === 4 ) {\n\t\t\t\t\t\tret += node.nodeValue;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn ret + open + "/" + tag + close;\n\t\t\t\t},\n\n\t\t\t\t// Function calls it internally, it\'s the arguments part of the function\n\t\t\t\tfunctionArgs: function( fn ) {\n\t\t\t\t\tvar args,\n\t\t\t\t\t\tl = fn.length;\n\n\t\t\t\t\tif ( !l ) {\n\t\t\t\t\t\treturn "";\n\t\t\t\t\t}\n\n\t\t\t\t\targs = new Array( l );\n\t\t\t\t\twhile ( l-- ) {\n\n\t\t\t\t\t\t// 97 is \'a\'\n\t\t\t\t\t\targs[ l ] = String.fromCharCode( 97 + l );\n\t\t\t\t\t}\n\t\t\t\t\treturn " " + args.join( ", " ) + " ";\n\t\t\t\t},\n\n\t\t\t\t// Object calls it internally, the key part of an item in a map\n\t\t\t\tkey: quote,\n\n\t\t\t\t// Function calls it internally, it\'s the content of the function\n\t\t\t\tfunctionCode: "[code]",\n\n\t\t\t\t// Node calls it internally, it\'s a html attribute value\n\t\t\t\tattribute: quote,\n\t\t\t\tstring: quote,\n\t\t\t\tdate: quote,\n\t\t\t\tregexp: literal,\n\t\t\t\tnumber: literal,\n\t\t\t\t"boolean": literal\n\t\t\t},\n\n\t\t\t// If true, entities are escaped ( <, >, \\t, space and \\n )\n\t\t\tHTML: false,\n\n\t\t\t// Indentation unit\n\t\t\tindentChar: "  ",\n\n\t\t\t// If true, items in a collection, are separated by a \\n, else just a space.\n\t\t\tmultiline: true\n\t\t};\n\n\treturn dump;\n}() );\n\n// Back compat\nQUnit.jsDump = QUnit.dump;\n\n// Deprecated\n// Extend assert methods to QUnit for Backwards compatibility\n( function() {\n\tvar i,\n\t\tassertions = Assert.prototype;\n\n\tfunction applyCurrent( current ) {\n\t\treturn function() {\n\t\t\tvar assert = new Assert( QUnit.config.current );\n\t\t\tcurrent.apply( assert, arguments );\n\t\t};\n\t}\n\n\tfor ( i in assertions ) {\n\t\tQUnit[ i ] = applyCurrent( assertions[ i ] );\n\t}\n}() );\n\n// For browser, export only select globals\nif ( defined.document ) {\n\n\t( function() {\n\t\tvar i, l,\n\t\t\tkeys = [\n\t\t\t\t"test",\n\t\t\t\t"module",\n\t\t\t\t"expect",\n\t\t\t\t"asyncTest",\n\t\t\t\t"start",\n\t\t\t\t"stop",\n\t\t\t\t"ok",\n\t\t\t\t"notOk",\n\t\t\t\t"equal",\n\t\t\t\t"notEqual",\n\t\t\t\t"propEqual",\n\t\t\t\t"notPropEqual",\n\t\t\t\t"deepEqual",\n\t\t\t\t"notDeepEqual",\n\t\t\t\t"strictEqual",\n\t\t\t\t"notStrictEqual",\n\t\t\t\t"throws",\n\t\t\t\t"raises"\n\t\t\t];\n\n\t\tfor ( i = 0, l = keys.length; i < l; i++ ) {\n\t\t\twindow[ keys[ i ] ] = QUnit[ keys[ i ] ];\n\t\t}\n\t}() );\n\n\twindow.QUnit = QUnit;\n}\n\n// For nodejs\nif ( typeof module !== "undefined" && module && module.exports ) {\n\tmodule.exports = QUnit;\n\n\t// For consistency with CommonJS environments\' exports\n\tmodule.exports.QUnit = QUnit;\n}\n\n// For CommonJS with exports, but without module.exports, like Rhino\nif ( typeof exports !== "undefined" && exports ) {\n\texports.QUnit = QUnit;\n}\n\nif ( typeof define === "function" && define.amd ) {\n\tdefine( function() {\n\t\treturn QUnit;\n\t} );\n\tQUnit.config.autostart = false;\n}\n\n// Get a reference to the global object, like window in browsers\n}( ( function() {\n\treturn this;\n}() ) ) );\n\n( function() {\n\n// Only interact with URLs via window.location\nvar location = typeof window !== "undefined" && window.location;\nif ( !location ) {\n\treturn;\n}\n\nvar urlParams = getUrlParams();\n\nQUnit.urlParams = urlParams;\n\n// Match module/test by inclusion in an array\nQUnit.config.moduleId = [].concat( urlParams.moduleId || [] );\nQUnit.config.testId = [].concat( urlParams.testId || [] );\n\n// Exact case-insensitive match of the module name\nQUnit.config.module = urlParams.module;\n\n// Regular expression or case-insenstive substring match against "moduleName: testName"\nQUnit.config.filter = urlParams.filter;\n\n// Test order randomization\nif ( urlParams.seed === true ) {\n\n\t// Generate a random seed if the option is specified without a value\n\tQUnit.config.seed = Math.random().toString( 36 ).slice( 2 );\n} else if ( urlParams.seed ) {\n\tQUnit.config.seed = urlParams.seed;\n}\n\n// Add URL-parameter-mapped config values with UI form rendering data\nQUnit.config.urlConfig.push(\n\t{\n\t\tid: "hidepassed",\n\t\tlabel: "Hide passed tests",\n\t\ttooltip: "Only show tests and assertions that fail. Stored as query-strings."\n\t},\n\t{\n\t\tid: "noglobals",\n\t\tlabel: "Check for Globals",\n\t\ttooltip: "Enabling this will test if any test introduces new properties on the " +\n\t\t\t"global object (`window` in Browsers). Stored as query-strings."\n\t},\n\t{\n\t\tid: "notrycatch",\n\t\tlabel: "No try-catch",\n\t\ttooltip: "Enabling this will run tests outside of a try-catch block. Makes debugging " +\n\t\t\t"exceptions in IE reasonable. Stored as query-strings."\n\t}\n);\n\nQUnit.begin( function() {\n\tvar i, option,\n\t\turlConfig = QUnit.config.urlConfig;\n\n\tfor ( i = 0; i < urlConfig.length; i++ ) {\n\n\t\t// Options can be either strings or objects with nonempty "id" properties\n\t\toption = QUnit.config.urlConfig[ i ];\n\t\tif ( typeof option !== "string" ) {\n\t\t\toption = option.id;\n\t\t}\n\n\t\tif ( QUnit.config[ option ] === undefined ) {\n\t\t\tQUnit.config[ option ] = urlParams[ option ];\n\t\t}\n\t}\n} );\n\nfunction getUrlParams() {\n\tvar i, param, name, value;\n\tvar urlParams = {};\n\tvar params = location.search.slice( 1 ).split( "&" );\n\tvar length = params.length;\n\n\tfor ( i = 0; i < length; i++ ) {\n\t\tif ( params[ i ] ) {\n\t\t\tparam = params[ i ].split( "=" );\n\t\t\tname = decodeURIComponent( param[ 0 ] );\n\n\t\t\t// Allow just a key to turn on a flag, e.g., test.html?noglobals\n\t\t\tvalue = param.length === 1 ||\n\t\t\t\tdecodeURIComponent( param.slice( 1 ).join( "=" ) ) ;\n\t\t\tif ( urlParams[ name ] ) {\n\t\t\t\turlParams[ name ] = [].concat( urlParams[ name ], value );\n\t\t\t} else {\n\t\t\t\turlParams[ name ] = value;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn urlParams;\n}\n\n// Don\'t load the HTML Reporter on non-browser environments\nif ( typeof window === "undefined" || !window.document ) {\n\treturn;\n}\n\n// Deprecated QUnit.init - Ref #530\n// Re-initialize the configuration options\nQUnit.init = function() {\n\tvar config = QUnit.config;\n\n\tconfig.stats = { all: 0, bad: 0 };\n\tconfig.moduleStats = { all: 0, bad: 0 };\n\tconfig.started = 0;\n\tconfig.updateRate = 1000;\n\tconfig.blocking = false;\n\tconfig.autostart = true;\n\tconfig.autorun = false;\n\tconfig.filter = "";\n\tconfig.queue = [];\n\n\tappendInterface();\n};\n\nvar config = QUnit.config,\n\tdocument = window.document,\n\tcollapseNext = false,\n\thasOwn = Object.prototype.hasOwnProperty,\n\tunfilteredUrl = setUrl( { filter: undefined, module: undefined,\n\t\tmoduleId: undefined, testId: undefined } ),\n\tdefined = {\n\t\tsessionStorage: ( function() {\n\t\t\tvar x = "qunit-test-string";\n\t\t\ttry {\n\t\t\t\tsessionStorage.setItem( x, x );\n\t\t\t\tsessionStorage.removeItem( x );\n\t\t\t\treturn true;\n\t\t\t} catch ( e ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}() )\n\t},\n\tmodulesList = [];\n\n/**\n* Escape text for attribute or text content.\n*/\nfunction escapeText( s ) {\n\tif ( !s ) {\n\t\treturn "";\n\t}\n\ts = s + "";\n\n\t// Both single quotes and double quotes (for attributes)\n\treturn s.replace( /[\'"<>&]/g, function( s ) {\n\t\tswitch ( s ) {\n\t\tcase "\'":\n\t\t\treturn "&#039;";\n\t\tcase "\\"":\n\t\t\treturn "&quot;";\n\t\tcase "<":\n\t\t\treturn "&lt;";\n\t\tcase ">":\n\t\t\treturn "&gt;";\n\t\tcase "&":\n\t\t\treturn "&amp;";\n\t\t}\n\t} );\n}\n\n/**\n * @param {HTMLElement} elem\n * @param {string} type\n * @param {Function} fn\n */\nfunction addEvent( elem, type, fn ) {\n\tif ( elem.addEventListener ) {\n\n\t\t// Standards-based browsers\n\t\telem.addEventListener( type, fn, false );\n\t} else if ( elem.attachEvent ) {\n\n\t\t// Support: IE <9\n\t\telem.attachEvent( "on" + type, function() {\n\t\t\tvar event = window.event;\n\t\t\tif ( !event.target ) {\n\t\t\t\tevent.target = event.srcElement || document;\n\t\t\t}\n\n\t\t\tfn.call( elem, event );\n\t\t} );\n\t}\n}\n\n/**\n * @param {Array|NodeList} elems\n * @param {string} type\n * @param {Function} fn\n */\nfunction addEvents( elems, type, fn ) {\n\tvar i = elems.length;\n\twhile ( i-- ) {\n\t\taddEvent( elems[ i ], type, fn );\n\t}\n}\n\nfunction hasClass( elem, name ) {\n\treturn ( " " + elem.className + " " ).indexOf( " " + name + " " ) >= 0;\n}\n\nfunction addClass( elem, name ) {\n\tif ( !hasClass( elem, name ) ) {\n\t\telem.className += ( elem.className ? " " : "" ) + name;\n\t}\n}\n\nfunction toggleClass( elem, name, force ) {\n\tif ( force || typeof force === "undefined" && !hasClass( elem, name ) ) {\n\t\taddClass( elem, name );\n\t} else {\n\t\tremoveClass( elem, name );\n\t}\n}\n\nfunction removeClass( elem, name ) {\n\tvar set = " " + elem.className + " ";\n\n\t// Class name may appear multiple times\n\twhile ( set.indexOf( " " + name + " " ) >= 0 ) {\n\t\tset = set.replace( " " + name + " ", " " );\n\t}\n\n\t// Trim for prettiness\n\telem.className = typeof set.trim === "function" ? set.trim() : set.replace( /^\\s+|\\s+$/g, "" );\n}\n\nfunction id( name ) {\n\treturn document.getElementById && document.getElementById( name );\n}\n\nfunction getUrlConfigHtml() {\n\tvar i, j, val,\n\t\tescaped, escapedTooltip,\n\t\tselection = false,\n\t\turlConfig = config.urlConfig,\n\t\turlConfigHtml = "";\n\n\tfor ( i = 0; i < urlConfig.length; i++ ) {\n\n\t\t// Options can be either strings or objects with nonempty "id" properties\n\t\tval = config.urlConfig[ i ];\n\t\tif ( typeof val === "string" ) {\n\t\t\tval = {\n\t\t\t\tid: val,\n\t\t\t\tlabel: val\n\t\t\t};\n\t\t}\n\n\t\tescaped = escapeText( val.id );\n\t\tescapedTooltip = escapeText( val.tooltip );\n\n\t\tif ( !val.value || typeof val.value === "string" ) {\n\t\t\turlConfigHtml += "<input id=\'qunit-urlconfig-" + escaped +\n\t\t\t\t"\' name=\'" + escaped + "\' type=\'checkbox\'" +\n\t\t\t\t( val.value ? " value=\'" + escapeText( val.value ) + "\'" : "" ) +\n\t\t\t\t( config[ val.id ] ? " checked=\'checked\'" : "" ) +\n\t\t\t\t" title=\'" + escapedTooltip + "\' /><label for=\'qunit-urlconfig-" + escaped +\n\t\t\t\t"\' title=\'" + escapedTooltip + "\'>" + val.label + "</label>";\n\t\t} else {\n\t\t\turlConfigHtml += "<label for=\'qunit-urlconfig-" + escaped +\n\t\t\t\t"\' title=\'" + escapedTooltip + "\'>" + val.label +\n\t\t\t\t": </label><select id=\'qunit-urlconfig-" + escaped +\n\t\t\t\t"\' name=\'" + escaped + "\' title=\'" + escapedTooltip + "\'><option></option>";\n\n\t\t\tif ( QUnit.is( "array", val.value ) ) {\n\t\t\t\tfor ( j = 0; j < val.value.length; j++ ) {\n\t\t\t\t\tescaped = escapeText( val.value[ j ] );\n\t\t\t\t\turlConfigHtml += "<option value=\'" + escaped + "\'" +\n\t\t\t\t\t\t( config[ val.id ] === val.value[ j ] ?\n\t\t\t\t\t\t\t( selection = true ) && " selected=\'selected\'" : "" ) +\n\t\t\t\t\t\t">" + escaped + "</option>";\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( j in val.value ) {\n\t\t\t\t\tif ( hasOwn.call( val.value, j ) ) {\n\t\t\t\t\t\turlConfigHtml += "<option value=\'" + escapeText( j ) + "\'" +\n\t\t\t\t\t\t\t( config[ val.id ] === j ?\n\t\t\t\t\t\t\t\t( selection = true ) && " selected=\'selected\'" : "" ) +\n\t\t\t\t\t\t\t">" + escapeText( val.value[ j ] ) + "</option>";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( config[ val.id ] && !selection ) {\n\t\t\t\tescaped = escapeText( config[ val.id ] );\n\t\t\t\turlConfigHtml += "<option value=\'" + escaped +\n\t\t\t\t\t"\' selected=\'selected\' disabled=\'disabled\'>" + escaped + "</option>";\n\t\t\t}\n\t\t\turlConfigHtml += "</select>";\n\t\t}\n\t}\n\n\treturn urlConfigHtml;\n}\n\n// Handle "click" events on toolbar checkboxes and "change" for select menus.\n// Updates the URL with the new state of `config.urlConfig` values.\nfunction toolbarChanged() {\n\tvar updatedUrl, value, tests,\n\t\tfield = this,\n\t\tparams = {};\n\n\t// Detect if field is a select menu or a checkbox\n\tif ( "selectedIndex" in field ) {\n\t\tvalue = field.options[ field.selectedIndex ].value || undefined;\n\t} else {\n\t\tvalue = field.checked ? ( field.defaultValue || true ) : undefined;\n\t}\n\n\tparams[ field.name ] = value;\n\tupdatedUrl = setUrl( params );\n\n\t// Check if we can apply the change without a page refresh\n\tif ( "hidepassed" === field.name && "replaceState" in window.history ) {\n\t\tQUnit.urlParams[ field.name ] = value;\n\t\tconfig[ field.name ] = value || false;\n\t\ttests = id( "qunit-tests" );\n\t\tif ( tests ) {\n\t\t\ttoggleClass( tests, "hidepass", value || false );\n\t\t}\n\t\twindow.history.replaceState( null, "", updatedUrl );\n\t} else {\n\t\twindow.location = updatedUrl;\n\t}\n}\n\nfunction setUrl( params ) {\n\tvar key, arrValue, i,\n\t\tquerystring = "?",\n\t\tlocation = window.location;\n\n\tparams = QUnit.extend( QUnit.extend( {}, QUnit.urlParams ), params );\n\n\tfor ( key in params ) {\n\n\t\t// Skip inherited or undefined properties\n\t\tif ( hasOwn.call( params, key ) && params[ key ] !== undefined ) {\n\n\t\t\t// Output a parameter for each value of this key (but usually just one)\n\t\t\tarrValue = [].concat( params[ key ] );\n\t\t\tfor ( i = 0; i < arrValue.length; i++ ) {\n\t\t\t\tquerystring += encodeURIComponent( key );\n\t\t\t\tif ( arrValue[ i ] !== true ) {\n\t\t\t\t\tquerystring += "=" + encodeURIComponent( arrValue[ i ] );\n\t\t\t\t}\n\t\t\t\tquerystring += "&";\n\t\t\t}\n\t\t}\n\t}\n\treturn location.protocol + "//" + location.host +\n\t\tlocation.pathname + querystring.slice( 0, -1 );\n}\n\nfunction applyUrlParams() {\n\tvar selectedModule,\n\t\tmodulesList = id( "qunit-modulefilter" ),\n\t\tfilter = id( "qunit-filter-input" ).value;\n\n\tselectedModule = modulesList ?\n\t\tdecodeURIComponent( modulesList.options[ modulesList.selectedIndex ].value ) :\n\t\tundefined;\n\n\twindow.location = setUrl( {\n\t\tmodule: ( selectedModule === "" ) ? undefined : selectedModule,\n\t\tfilter: ( filter === "" ) ? undefined : filter,\n\n\t\t// Remove moduleId and testId filters\n\t\tmoduleId: undefined,\n\t\ttestId: undefined\n\t} );\n}\n\nfunction toolbarUrlConfigContainer() {\n\tvar urlConfigContainer = document.createElement( "span" );\n\n\turlConfigContainer.innerHTML = getUrlConfigHtml();\n\taddClass( urlConfigContainer, "qunit-url-config" );\n\n\t// For oldIE support:\n\t// * Add handlers to the individual elements instead of the container\n\t// * Use "click" instead of "change" for checkboxes\n\taddEvents( urlConfigContainer.getElementsByTagName( "input" ), "click", toolbarChanged );\n\taddEvents( urlConfigContainer.getElementsByTagName( "select" ), "change", toolbarChanged );\n\n\treturn urlConfigContainer;\n}\n\nfunction toolbarLooseFilter() {\n\tvar filter = document.createElement( "form" ),\n\t\tlabel = document.createElement( "label" ),\n\t\tinput = document.createElement( "input" ),\n\t\tbutton = document.createElement( "button" );\n\n\taddClass( filter, "qunit-filter" );\n\n\tlabel.innerHTML = "Filter: ";\n\n\tinput.type = "text";\n\tinput.value = config.filter || "";\n\tinput.name = "filter";\n\tinput.id = "qunit-filter-input";\n\n\tbutton.innerHTML = "Go";\n\n\tlabel.appendChild( input );\n\n\tfilter.appendChild( label );\n\tfilter.appendChild( button );\n\taddEvent( filter, "submit", function( ev ) {\n\t\tapplyUrlParams();\n\n\t\tif ( ev && ev.preventDefault ) {\n\t\t\tev.preventDefault();\n\t\t}\n\n\t\treturn false;\n\t} );\n\n\treturn filter;\n}\n\nfunction toolbarModuleFilterHtml() {\n\tvar i,\n\t\tmoduleFilterHtml = "";\n\n\tif ( !modulesList.length ) {\n\t\treturn false;\n\t}\n\n\tmoduleFilterHtml += "<label for=\'qunit-modulefilter\'>Module: </label>" +\n\t\t"<select id=\'qunit-modulefilter\' name=\'modulefilter\'><option value=\'\' " +\n\t\t( QUnit.urlParams.module === undefined ? "selected=\'selected\'" : "" ) +\n\t\t">< All Modules ></option>";\n\n\tfor ( i = 0; i < modulesList.length; i++ ) {\n\t\tmoduleFilterHtml += "<option value=\'" +\n\t\t\tescapeText( encodeURIComponent( modulesList[ i ] ) ) + "\' " +\n\t\t\t( QUnit.urlParams.module === modulesList[ i ] ? "selected=\'selected\'" : "" ) +\n\t\t\t">" + escapeText( modulesList[ i ] ) + "</option>";\n\t}\n\tmoduleFilterHtml += "</select>";\n\n\treturn moduleFilterHtml;\n}\n\nfunction toolbarModuleFilter() {\n\tvar toolbar = id( "qunit-testrunner-toolbar" ),\n\t\tmoduleFilter = document.createElement( "span" ),\n\t\tmoduleFilterHtml = toolbarModuleFilterHtml();\n\n\tif ( !toolbar || !moduleFilterHtml ) {\n\t\treturn false;\n\t}\n\n\tmoduleFilter.setAttribute( "id", "qunit-modulefilter-container" );\n\tmoduleFilter.innerHTML = moduleFilterHtml;\n\n\taddEvent( moduleFilter.lastChild, "change", applyUrlParams );\n\n\ttoolbar.appendChild( moduleFilter );\n}\n\nfunction appendToolbar() {\n\tvar toolbar = id( "qunit-testrunner-toolbar" );\n\n\tif ( toolbar ) {\n\t\ttoolbar.appendChild( toolbarUrlConfigContainer() );\n\t\ttoolbar.appendChild( toolbarLooseFilter() );\n\t\ttoolbarModuleFilter();\n\t}\n}\n\nfunction appendHeader() {\n\tvar header = id( "qunit-header" );\n\n\tif ( header ) {\n\t\theader.innerHTML = "<a href=\'" + escapeText( unfilteredUrl ) + "\'>" + header.innerHTML +\n\t\t\t"</a> ";\n\t}\n}\n\nfunction appendBanner() {\n\tvar banner = id( "qunit-banner" );\n\n\tif ( banner ) {\n\t\tbanner.className = "";\n\t}\n}\n\nfunction appendTestResults() {\n\tvar tests = id( "qunit-tests" ),\n\t\tresult = id( "qunit-testresult" );\n\n\tif ( result ) {\n\t\tresult.parentNode.removeChild( result );\n\t}\n\n\tif ( tests ) {\n\t\ttests.innerHTML = "";\n\t\tresult = document.createElement( "p" );\n\t\tresult.id = "qunit-testresult";\n\t\tresult.className = "result";\n\t\ttests.parentNode.insertBefore( result, tests );\n\t\tresult.innerHTML = "Running...<br />&#160;";\n\t}\n}\n\nfunction storeFixture() {\n\tvar fixture = id( "qunit-fixture" );\n\tif ( fixture ) {\n\t\tconfig.fixture = fixture.innerHTML;\n\t}\n}\n\nfunction appendFilteredTest() {\n\tvar testId = QUnit.config.testId;\n\tif ( !testId || testId.length <= 0 ) {\n\t\treturn "";\n\t}\n\treturn "<div id=\'qunit-filteredTest\'>Rerunning selected tests: " +\n\t\tescapeText( testId.join( ", " ) ) +\n\t\t" <a id=\'qunit-clearFilter\' href=\'" +\n\t\tescapeText( unfilteredUrl ) +\n\t\t"\'>Run all tests</a></div>";\n}\n\nfunction appendUserAgent() {\n\tvar userAgent = id( "qunit-userAgent" );\n\n\tif ( userAgent ) {\n\t\tuserAgent.innerHTML = "";\n\t\tuserAgent.appendChild(\n\t\t\tdocument.createTextNode(\n\t\t\t\t"QUnit " + QUnit.version + "; " + navigator.userAgent\n\t\t\t)\n\t\t);\n\t}\n}\n\nfunction appendInterface() {\n\tvar qunit = id( "qunit" );\n\n\tif ( qunit ) {\n\t\tqunit.innerHTML =\n\t\t\t"<h1 id=\'qunit-header\'>" + escapeText( document.title ) + "</h1>" +\n\t\t\t"<h2 id=\'qunit-banner\'></h2>" +\n\t\t\t"<div id=\'qunit-testrunner-toolbar\'></div>" +\n\t\t\tappendFilteredTest() +\n\t\t\t"<h2 id=\'qunit-userAgent\'></h2>" +\n\t\t\t"<ol id=\'qunit-tests\'></ol>";\n\t}\n\n\tappendHeader();\n\tappendBanner();\n\tappendTestResults();\n\tappendUserAgent();\n\tappendToolbar();\n}\n\nfunction appendTestsList( modules ) {\n\tvar i, l, x, z, test, moduleObj;\n\n\tfor ( i = 0, l = modules.length; i < l; i++ ) {\n\t\tmoduleObj = modules[ i ];\n\n\t\tfor ( x = 0, z = moduleObj.tests.length; x < z; x++ ) {\n\t\t\ttest = moduleObj.tests[ x ];\n\n\t\t\tappendTest( test.name, test.testId, moduleObj.name );\n\t\t}\n\t}\n}\n\nfunction appendTest( name, testId, moduleName ) {\n\tvar title, rerunTrigger, testBlock, assertList,\n\t\ttests = id( "qunit-tests" );\n\n\tif ( !tests ) {\n\t\treturn;\n\t}\n\n\ttitle = document.createElement( "strong" );\n\ttitle.innerHTML = getNameHtml( name, moduleName );\n\n\trerunTrigger = document.createElement( "a" );\n\trerunTrigger.innerHTML = "Rerun";\n\trerunTrigger.href = setUrl( { testId: testId } );\n\n\ttestBlock = document.createElement( "li" );\n\ttestBlock.appendChild( title );\n\ttestBlock.appendChild( rerunTrigger );\n\ttestBlock.id = "qunit-test-output-" + testId;\n\n\tassertList = document.createElement( "ol" );\n\tassertList.className = "qunit-assert-list";\n\n\ttestBlock.appendChild( assertList );\n\n\ttests.appendChild( testBlock );\n}\n\n// HTML Reporter initialization and load\nQUnit.begin( function( details ) {\n\tvar i, moduleObj, tests;\n\n\t// Sort modules by name for the picker\n\tfor ( i = 0; i < details.modules.length; i++ ) {\n\t\tmoduleObj = details.modules[ i ];\n\t\tif ( moduleObj.name ) {\n\t\t\tmodulesList.push( moduleObj.name );\n\t\t}\n\t}\n\tmodulesList.sort( function( a, b ) {\n\t\treturn a.localeCompare( b );\n\t} );\n\n\t// Capture fixture HTML from the page\n\tstoreFixture();\n\n\t// Initialize QUnit elements\n\tappendInterface();\n\tappendTestsList( details.modules );\n\ttests = id( "qunit-tests" );\n\tif ( tests && config.hidepassed ) {\n\t\taddClass( tests, "hidepass" );\n\t}\n} );\n\nQUnit.done( function( details ) {\n\tvar i, key,\n\t\tbanner = id( "qunit-banner" ),\n\t\ttests = id( "qunit-tests" ),\n\t\thtml = [\n\t\t\t"Tests completed in ",\n\t\t\tdetails.runtime,\n\t\t\t" milliseconds.<br />",\n\t\t\t"<span class=\'passed\'>",\n\t\t\tdetails.passed,\n\t\t\t"</span> assertions of <span class=\'total\'>",\n\t\t\tdetails.total,\n\t\t\t"</span> passed, <span class=\'failed\'>",\n\t\t\tdetails.failed,\n\t\t\t"</span> failed."\n\t\t].join( "" );\n\n\tif ( banner ) {\n\t\tbanner.className = details.failed ? "qunit-fail" : "qunit-pass";\n\t}\n\n\tif ( tests ) {\n\t\tid( "qunit-testresult" ).innerHTML = html;\n\t}\n\n\tif ( config.altertitle && document.title ) {\n\n\t\t// Show \u2716 for good, \u2714 for bad suite result in title\n\t\t// use escape sequences in case file gets loaded with non-utf-8-charset\n\t\tdocument.title = [\n\t\t\t( details.failed ? "\\u2716" : "\\u2714" ),\n\t\t\tdocument.title.replace( /^[\\u2714\\u2716] /i, "" )\n\t\t].join( " " );\n\t}\n\n\t// Clear own sessionStorage items if all tests passed\n\tif ( config.reorder && defined.sessionStorage && details.failed === 0 ) {\n\t\tfor ( i = 0; i < sessionStorage.length; i++ ) {\n\t\t\tkey = sessionStorage.key( i++ );\n\t\t\tif ( key.indexOf( "qunit-test-" ) === 0 ) {\n\t\t\t\tsessionStorage.removeItem( key );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Scroll back to top to show results\n\tif ( config.scrolltop && window.scrollTo ) {\n\t\twindow.scrollTo( 0, 0 );\n\t}\n} );\n\nfunction getNameHtml( name, module ) {\n\tvar nameHtml = "";\n\n\tif ( module ) {\n\t\tnameHtml = "<span class=\'module-name\'>" + escapeText( module ) + "</span>: ";\n\t}\n\n\tnameHtml += "<span class=\'test-name\'>" + escapeText( name ) + "</span>";\n\n\treturn nameHtml;\n}\n\nQUnit.testStart( function( details ) {\n\tvar running, testBlock, bad;\n\n\ttestBlock = id( "qunit-test-output-" + details.testId );\n\tif ( testBlock ) {\n\t\ttestBlock.className = "running";\n\t} else {\n\n\t\t// Report later registered tests\n\t\tappendTest( details.name, details.testId, details.module );\n\t}\n\n\trunning = id( "qunit-testresult" );\n\tif ( running ) {\n\t\tbad = QUnit.config.reorder && defined.sessionStorage &&\n\t\t\t+sessionStorage.getItem( "qunit-test-" + details.module + "-" + details.name );\n\n\t\trunning.innerHTML = ( bad ?\n\t\t\t"Rerunning previously failed test: <br />" :\n\t\t\t"Running: <br />" ) +\n\t\t\tgetNameHtml( details.name, details.module );\n\t}\n\n} );\n\nfunction stripHtml( string ) {\n\n\t// Strip tags, html entity and whitespaces\n\treturn string.replace( /<\\/?[^>]+(>|$)/g, "" ).replace( /\\&quot;/g, "" ).replace( /\\s+/g, "" );\n}\n\nQUnit.log( function( details ) {\n\tvar assertList, assertLi,\n\t\tmessage, expected, actual, diff,\n\t\tshowDiff = false,\n\t\ttestItem = id( "qunit-test-output-" + details.testId );\n\n\tif ( !testItem ) {\n\t\treturn;\n\t}\n\n\tmessage = escapeText( details.message ) || ( details.result ? "okay" : "failed" );\n\tmessage = "<span class=\'test-message\'>" + message + "</span>";\n\tmessage += "<span class=\'runtime\'>@ " + details.runtime + " ms</span>";\n\n\t// The pushFailure doesn\'t provide details.expected\n\t// when it calls, it\'s implicit to also not show expected and diff stuff\n\t// Also, we need to check details.expected existence, as it can exist and be undefined\n\tif ( !details.result && hasOwn.call( details, "expected" ) ) {\n\t\tif ( details.negative ) {\n\t\t\texpected = "NOT " + QUnit.dump.parse( details.expected );\n\t\t} else {\n\t\t\texpected = QUnit.dump.parse( details.expected );\n\t\t}\n\n\t\tactual = QUnit.dump.parse( details.actual );\n\t\tmessage += "<table><tr class=\'test-expected\'><th>Expected: </th><td><pre>" +\n\t\t\tescapeText( expected ) +\n\t\t\t"</pre></td></tr>";\n\n\t\tif ( actual !== expected ) {\n\n\t\t\tmessage += "<tr class=\'test-actual\'><th>Result: </th><td><pre>" +\n\t\t\t\tescapeText( actual ) + "</pre></td></tr>";\n\n\t\t\t// Don\'t show diff if actual or expected are booleans\n\t\t\tif ( !( /^(true|false)$/.test( actual ) ) &&\n\t\t\t\t\t!( /^(true|false)$/.test( expected ) ) ) {\n\t\t\t\tdiff = QUnit.diff( expected, actual );\n\t\t\t\tshowDiff = stripHtml( diff ).length !==\n\t\t\t\t\tstripHtml( expected ).length +\n\t\t\t\t\tstripHtml( actual ).length;\n\t\t\t}\n\n\t\t\t// Don\'t show diff if expected and actual are totally different\n\t\t\tif ( showDiff ) {\n\t\t\t\tmessage += "<tr class=\'test-diff\'><th>Diff: </th><td><pre>" +\n\t\t\t\t\tdiff + "</pre></td></tr>";\n\t\t\t}\n\t\t} else if ( expected.indexOf( "[object Array]" ) !== -1 ||\n\t\t\t\texpected.indexOf( "[object Object]" ) !== -1 ) {\n\t\t\tmessage += "<tr class=\'test-message\'><th>Message: </th><td>" +\n\t\t\t\t"Diff suppressed as the depth of object is more than current max depth (" +\n\t\t\t\tQUnit.config.maxDepth + ").<p>Hint: Use <code>QUnit.dump.maxDepth</code> to " +\n\t\t\t\t" run with a higher max depth or <a href=\'" +\n\t\t\t\tescapeText( setUrl( { maxDepth: -1 } ) ) + "\'>" +\n\t\t\t\t"Rerun</a> without max depth.</p></td></tr>";\n\t\t} else {\n\t\t\tmessage += "<tr class=\'test-message\'><th>Message: </th><td>" +\n\t\t\t\t"Diff suppressed as the expected and actual results have an equivalent" +\n\t\t\t\t" serialization</td></tr>";\n\t\t}\n\n\t\tif ( details.source ) {\n\t\t\tmessage += "<tr class=\'test-source\'><th>Source: </th><td><pre>" +\n\t\t\t\tescapeText( details.source ) + "</pre></td></tr>";\n\t\t}\n\n\t\tmessage += "</table>";\n\n\t// This occurs when pushFailure is set and we have an extracted stack trace\n\t} else if ( !details.result && details.source ) {\n\t\tmessage += "<table>" +\n\t\t\t"<tr class=\'test-source\'><th>Source: </th><td><pre>" +\n\t\t\tescapeText( details.source ) + "</pre></td></tr>" +\n\t\t\t"</table>";\n\t}\n\n\tassertList = testItem.getElementsByTagName( "ol" )[ 0 ];\n\n\tassertLi = document.createElement( "li" );\n\tassertLi.className = details.result ? "pass" : "fail";\n\tassertLi.innerHTML = message;\n\tassertList.appendChild( assertLi );\n} );\n\nQUnit.testDone( function( details ) {\n\tvar testTitle, time, testItem, assertList,\n\t\tgood, bad, testCounts, skipped, sourceName,\n\t\ttests = id( "qunit-tests" );\n\n\tif ( !tests ) {\n\t\treturn;\n\t}\n\n\ttestItem = id( "qunit-test-output-" + details.testId );\n\n\tassertList = testItem.getElementsByTagName( "ol" )[ 0 ];\n\n\tgood = details.passed;\n\tbad = details.failed;\n\n\t// Store result when possible\n\tif ( config.reorder && defined.sessionStorage ) {\n\t\tif ( bad ) {\n\t\t\tsessionStorage.setItem( "qunit-test-" + details.module + "-" + details.name, bad );\n\t\t} else {\n\t\t\tsessionStorage.removeItem( "qunit-test-" + details.module + "-" + details.name );\n\t\t}\n\t}\n\n\tif ( bad === 0 ) {\n\n\t\t// Collapse the passing tests\n\t\taddClass( assertList, "qunit-collapsed" );\n\t} else if ( bad && config.collapse && !collapseNext ) {\n\n\t\t// Skip collapsing the first failing test\n\t\tcollapseNext = true;\n\t} else {\n\n\t\t// Collapse remaining tests\n\t\taddClass( assertList, "qunit-collapsed" );\n\t}\n\n\t// The testItem.firstChild is the test name\n\ttestTitle = testItem.firstChild;\n\n\ttestCounts = bad ?\n\t\t"<b class=\'failed\'>" + bad + "</b>, " + "<b class=\'passed\'>" + good + "</b>, " :\n\t\t"";\n\n\ttestTitle.innerHTML += " <b class=\'counts\'>(" + testCounts +\n\t\tdetails.assertions.length + ")</b>";\n\n\tif ( details.skipped ) {\n\t\ttestItem.className = "skipped";\n\t\tskipped = document.createElement( "em" );\n\t\tskipped.className = "qunit-skipped-label";\n\t\tskipped.innerHTML = "skipped";\n\t\ttestItem.insertBefore( skipped, testTitle );\n\t} else {\n\t\taddEvent( testTitle, "click", function() {\n\t\t\ttoggleClass( assertList, "qunit-collapsed" );\n\t\t} );\n\n\t\ttestItem.className = bad ? "fail" : "pass";\n\n\t\ttime = document.createElement( "span" );\n\t\ttime.className = "runtime";\n\t\ttime.innerHTML = details.runtime + " ms";\n\t\ttestItem.insertBefore( time, assertList );\n\t}\n\n\t// Show the source of the test when showing assertions\n\tif ( details.source ) {\n\t\tsourceName = document.createElement( "p" );\n\t\tsourceName.innerHTML = "<strong>Source: </strong>" + details.source;\n\t\taddClass( sourceName, "qunit-source" );\n\t\tif ( bad === 0 ) {\n\t\t\taddClass( sourceName, "qunit-collapsed" );\n\t\t}\n\t\taddEvent( testTitle, "click", function() {\n\t\t\ttoggleClass( sourceName, "qunit-collapsed" );\n\t\t} );\n\t\ttestItem.appendChild( sourceName );\n\t}\n} );\n\n// Avoid readyState issue with phantomjs\n// Ref: #818\nvar notPhantom = ( function( p ) {\n\treturn !( p && p.version && p.version.major > 0 );\n} )( window.phantom );\n\nif ( notPhantom && document.readyState === "complete" ) {\n\tQUnit.load();\n} else {\n\taddEvent( window, "load", QUnit.load );\n}\n\n/*\n * This file is a modified version of google-diff-match-patch\'s JavaScript implementation\n * (https://code.google.com/p/google-diff-match-patch/source/browse/trunk/javascript/diff_match_patch_uncompressed.js),\n * modifications are licensed as more fully set forth in LICENSE.txt.\n *\n * The original source of google-diff-match-patch is attributable and licensed as follows:\n *\n * Copyright 2006 Google Inc.\n * https://code.google.com/p/google-diff-match-patch/\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * More Info:\n *  https://code.google.com/p/google-diff-match-patch/\n *\n * Usage: QUnit.diff(expected, actual)\n *\n */\nQUnit.diff = ( function() {\n\tfunction DiffMatchPatch() {\n\t}\n\n\t//  DIFF FUNCTIONS\n\n\t/**\n\t * The data structure representing a diff is an array of tuples:\n\t * [[DIFF_DELETE, \'Hello\'], [DIFF_INSERT, \'Goodbye\'], [DIFF_EQUAL, \' world.\']]\n\t * which means: delete \'Hello\', add \'Goodbye\' and keep \' world.\'\n\t */\n\tvar DIFF_DELETE = -1,\n\t\tDIFF_INSERT = 1,\n\t\tDIFF_EQUAL = 0;\n\n\t/**\n\t * Find the differences between two texts.  Simplifies the problem by stripping\n\t * any common prefix or suffix off the texts before diffing.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {boolean=} optChecklines Optional speedup flag. If present and false,\n\t *     then don\'t run a line-level diff first to identify the changed areas.\n\t *     Defaults to true, which does a faster, slightly less optimal diff.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t */\n\tDiffMatchPatch.prototype.DiffMain = function( text1, text2, optChecklines ) {\n\t\tvar deadline, checklines, commonlength,\n\t\t\tcommonprefix, commonsuffix, diffs;\n\n\t\t// The diff must be complete in up to 1 second.\n\t\tdeadline = ( new Date() ).getTime() + 1000;\n\n\t\t// Check for null inputs.\n\t\tif ( text1 === null || text2 === null ) {\n\t\t\tthrow new Error( "Null input. (DiffMain)" );\n\t\t}\n\n\t\t// Check for equality (speedup).\n\t\tif ( text1 === text2 ) {\n\t\t\tif ( text1 ) {\n\t\t\t\treturn [\n\t\t\t\t\t[ DIFF_EQUAL, text1 ]\n\t\t\t\t];\n\t\t\t}\n\t\t\treturn [];\n\t\t}\n\n\t\tif ( typeof optChecklines === "undefined" ) {\n\t\t\toptChecklines = true;\n\t\t}\n\n\t\tchecklines = optChecklines;\n\n\t\t// Trim off common prefix (speedup).\n\t\tcommonlength = this.diffCommonPrefix( text1, text2 );\n\t\tcommonprefix = text1.substring( 0, commonlength );\n\t\ttext1 = text1.substring( commonlength );\n\t\ttext2 = text2.substring( commonlength );\n\n\t\t// Trim off common suffix (speedup).\n\t\tcommonlength = this.diffCommonSuffix( text1, text2 );\n\t\tcommonsuffix = text1.substring( text1.length - commonlength );\n\t\ttext1 = text1.substring( 0, text1.length - commonlength );\n\t\ttext2 = text2.substring( 0, text2.length - commonlength );\n\n\t\t// Compute the diff on the middle block.\n\t\tdiffs = this.diffCompute( text1, text2, checklines, deadline );\n\n\t\t// Restore the prefix and suffix.\n\t\tif ( commonprefix ) {\n\t\t\tdiffs.unshift( [ DIFF_EQUAL, commonprefix ] );\n\t\t}\n\t\tif ( commonsuffix ) {\n\t\t\tdiffs.push( [ DIFF_EQUAL, commonsuffix ] );\n\t\t}\n\t\tthis.diffCleanupMerge( diffs );\n\t\treturn diffs;\n\t};\n\n\t/**\n\t * Reduce the number of edits by eliminating operationally trivial equalities.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t */\n\tDiffMatchPatch.prototype.diffCleanupEfficiency = function( diffs ) {\n\t\tvar changes, equalities, equalitiesLength, lastequality,\n\t\t\tpointer, preIns, preDel, postIns, postDel;\n\t\tchanges = false;\n\t\tequalities = []; // Stack of indices where equalities are found.\n\t\tequalitiesLength = 0; // Keeping our own length var is faster in JS.\n\t\t/** @type {?string} */\n\t\tlastequality = null;\n\n\t\t// Always equal to diffs[equalities[equalitiesLength - 1]][1]\n\t\tpointer = 0; // Index of current position.\n\n\t\t// Is there an insertion operation before the last equality.\n\t\tpreIns = false;\n\n\t\t// Is there a deletion operation before the last equality.\n\t\tpreDel = false;\n\n\t\t// Is there an insertion operation after the last equality.\n\t\tpostIns = false;\n\n\t\t// Is there a deletion operation after the last equality.\n\t\tpostDel = false;\n\t\twhile ( pointer < diffs.length ) {\n\n\t\t\t// Equality found.\n\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_EQUAL ) {\n\t\t\t\tif ( diffs[ pointer ][ 1 ].length < 4 && ( postIns || postDel ) ) {\n\n\t\t\t\t\t// Candidate found.\n\t\t\t\t\tequalities[ equalitiesLength++ ] = pointer;\n\t\t\t\t\tpreIns = postIns;\n\t\t\t\t\tpreDel = postDel;\n\t\t\t\t\tlastequality = diffs[ pointer ][ 1 ];\n\t\t\t\t} else {\n\n\t\t\t\t\t// Not a candidate, and can never become one.\n\t\t\t\t\tequalitiesLength = 0;\n\t\t\t\t\tlastequality = null;\n\t\t\t\t}\n\t\t\t\tpostIns = postDel = false;\n\n\t\t\t// An insertion or deletion.\n\t\t\t} else {\n\n\t\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_DELETE ) {\n\t\t\t\t\tpostDel = true;\n\t\t\t\t} else {\n\t\t\t\t\tpostIns = true;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Five types to be split:\n\t\t\t\t * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n\t\t\t\t * <ins>A</ins>X<ins>C</ins><del>D</del>\n\t\t\t\t * <ins>A</ins><del>B</del>X<ins>C</ins>\n\t\t\t\t * <ins>A</del>X<ins>C</ins><del>D</del>\n\t\t\t\t * <ins>A</ins><del>B</del>X<del>C</del>\n\t\t\t\t */\n\t\t\t\tif ( lastequality && ( ( preIns && preDel && postIns && postDel ) ||\n\t\t\t\t\t\t( ( lastequality.length < 2 ) &&\n\t\t\t\t\t\t( preIns + preDel + postIns + postDel ) === 3 ) ) ) {\n\n\t\t\t\t\t// Duplicate record.\n\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\tequalities[ equalitiesLength - 1 ],\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t[ DIFF_DELETE, lastequality ]\n\t\t\t\t\t);\n\n\t\t\t\t\t// Change second copy to insert.\n\t\t\t\t\tdiffs[ equalities[ equalitiesLength - 1 ] + 1 ][ 0 ] = DIFF_INSERT;\n\t\t\t\t\tequalitiesLength--; // Throw away the equality we just deleted;\n\t\t\t\t\tlastequality = null;\n\t\t\t\t\tif ( preIns && preDel ) {\n\n\t\t\t\t\t\t// No changes made which could affect previous entry, keep going.\n\t\t\t\t\t\tpostIns = postDel = true;\n\t\t\t\t\t\tequalitiesLength = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tequalitiesLength--; // Throw away the previous equality.\n\t\t\t\t\t\tpointer = equalitiesLength > 0 ? equalities[ equalitiesLength - 1 ] : -1;\n\t\t\t\t\t\tpostIns = postDel = false;\n\t\t\t\t\t}\n\t\t\t\t\tchanges = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\n\t\tif ( changes ) {\n\t\t\tthis.diffCleanupMerge( diffs );\n\t\t}\n\t};\n\n\t/**\n\t * Convert a diff array into a pretty HTML report.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t * @param {integer} string to be beautified.\n\t * @return {string} HTML representation.\n\t */\n\tDiffMatchPatch.prototype.diffPrettyHtml = function( diffs ) {\n\t\tvar op, data, x,\n\t\t\thtml = [];\n\t\tfor ( x = 0; x < diffs.length; x++ ) {\n\t\t\top = diffs[ x ][ 0 ]; // Operation (insert, delete, equal)\n\t\t\tdata = diffs[ x ][ 1 ]; // Text of change.\n\t\t\tswitch ( op ) {\n\t\t\tcase DIFF_INSERT:\n\t\t\t\thtml[ x ] = "<ins>" + escapeText( data ) + "</ins>";\n\t\t\t\tbreak;\n\t\t\tcase DIFF_DELETE:\n\t\t\t\thtml[ x ] = "<del>" + escapeText( data ) + "</del>";\n\t\t\t\tbreak;\n\t\t\tcase DIFF_EQUAL:\n\t\t\t\thtml[ x ] = "<span>" + escapeText( data ) + "</span>";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn html.join( "" );\n\t};\n\n\t/**\n\t * Determine the common prefix of two strings.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {number} The number of characters common to the start of each\n\t *     string.\n\t */\n\tDiffMatchPatch.prototype.diffCommonPrefix = function( text1, text2 ) {\n\t\tvar pointermid, pointermax, pointermin, pointerstart;\n\n\t\t// Quick check for common null cases.\n\t\tif ( !text1 || !text2 || text1.charAt( 0 ) !== text2.charAt( 0 ) ) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Binary search.\n\t\t// Performance analysis: https://neil.fraser.name/news/2007/10/09/\n\t\tpointermin = 0;\n\t\tpointermax = Math.min( text1.length, text2.length );\n\t\tpointermid = pointermax;\n\t\tpointerstart = 0;\n\t\twhile ( pointermin < pointermid ) {\n\t\t\tif ( text1.substring( pointerstart, pointermid ) ===\n\t\t\t\t\ttext2.substring( pointerstart, pointermid ) ) {\n\t\t\t\tpointermin = pointermid;\n\t\t\t\tpointerstart = pointermin;\n\t\t\t} else {\n\t\t\t\tpointermax = pointermid;\n\t\t\t}\n\t\t\tpointermid = Math.floor( ( pointermax - pointermin ) / 2 + pointermin );\n\t\t}\n\t\treturn pointermid;\n\t};\n\n\t/**\n\t * Determine the common suffix of two strings.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {number} The number of characters common to the end of each string.\n\t */\n\tDiffMatchPatch.prototype.diffCommonSuffix = function( text1, text2 ) {\n\t\tvar pointermid, pointermax, pointermin, pointerend;\n\n\t\t// Quick check for common null cases.\n\t\tif ( !text1 ||\n\t\t\t\t!text2 ||\n\t\t\t\ttext1.charAt( text1.length - 1 ) !== text2.charAt( text2.length - 1 ) ) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Binary search.\n\t\t// Performance analysis: https://neil.fraser.name/news/2007/10/09/\n\t\tpointermin = 0;\n\t\tpointermax = Math.min( text1.length, text2.length );\n\t\tpointermid = pointermax;\n\t\tpointerend = 0;\n\t\twhile ( pointermin < pointermid ) {\n\t\t\tif ( text1.substring( text1.length - pointermid, text1.length - pointerend ) ===\n\t\t\t\t\ttext2.substring( text2.length - pointermid, text2.length - pointerend ) ) {\n\t\t\t\tpointermin = pointermid;\n\t\t\t\tpointerend = pointermin;\n\t\t\t} else {\n\t\t\t\tpointermax = pointermid;\n\t\t\t}\n\t\t\tpointermid = Math.floor( ( pointermax - pointermin ) / 2 + pointermin );\n\t\t}\n\t\treturn pointermid;\n\t};\n\n\t/**\n\t * Find the differences between two texts.  Assumes that the texts do not\n\t * have any common prefix or suffix.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {boolean} checklines Speedup flag.  If false, then don\'t run a\n\t *     line-level diff first to identify the changed areas.\n\t *     If true, then run a faster, slightly less optimal diff.\n\t * @param {number} deadline Time when the diff should be complete by.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffCompute = function( text1, text2, checklines, deadline ) {\n\t\tvar diffs, longtext, shorttext, i, hm,\n\t\t\ttext1A, text2A, text1B, text2B,\n\t\t\tmidCommon, diffsA, diffsB;\n\n\t\tif ( !text1 ) {\n\n\t\t\t// Just add some text (speedup).\n\t\t\treturn [\n\t\t\t\t[ DIFF_INSERT, text2 ]\n\t\t\t];\n\t\t}\n\n\t\tif ( !text2 ) {\n\n\t\t\t// Just delete some text (speedup).\n\t\t\treturn [\n\t\t\t\t[ DIFF_DELETE, text1 ]\n\t\t\t];\n\t\t}\n\n\t\tlongtext = text1.length > text2.length ? text1 : text2;\n\t\tshorttext = text1.length > text2.length ? text2 : text1;\n\t\ti = longtext.indexOf( shorttext );\n\t\tif ( i !== -1 ) {\n\n\t\t\t// Shorter text is inside the longer text (speedup).\n\t\t\tdiffs = [\n\t\t\t\t[ DIFF_INSERT, longtext.substring( 0, i ) ],\n\t\t\t\t[ DIFF_EQUAL, shorttext ],\n\t\t\t\t[ DIFF_INSERT, longtext.substring( i + shorttext.length ) ]\n\t\t\t];\n\n\t\t\t// Swap insertions for deletions if diff is reversed.\n\t\t\tif ( text1.length > text2.length ) {\n\t\t\t\tdiffs[ 0 ][ 0 ] = diffs[ 2 ][ 0 ] = DIFF_DELETE;\n\t\t\t}\n\t\t\treturn diffs;\n\t\t}\n\n\t\tif ( shorttext.length === 1 ) {\n\n\t\t\t// Single character string.\n\t\t\t// After the previous speedup, the character can\'t be an equality.\n\t\t\treturn [\n\t\t\t\t[ DIFF_DELETE, text1 ],\n\t\t\t\t[ DIFF_INSERT, text2 ]\n\t\t\t];\n\t\t}\n\n\t\t// Check to see if the problem can be split in two.\n\t\thm = this.diffHalfMatch( text1, text2 );\n\t\tif ( hm ) {\n\n\t\t\t// A half-match was found, sort out the return data.\n\t\t\ttext1A = hm[ 0 ];\n\t\t\ttext1B = hm[ 1 ];\n\t\t\ttext2A = hm[ 2 ];\n\t\t\ttext2B = hm[ 3 ];\n\t\t\tmidCommon = hm[ 4 ];\n\n\t\t\t// Send both pairs off for separate processing.\n\t\t\tdiffsA = this.DiffMain( text1A, text2A, checklines, deadline );\n\t\t\tdiffsB = this.DiffMain( text1B, text2B, checklines, deadline );\n\n\t\t\t// Merge the results.\n\t\t\treturn diffsA.concat( [\n\t\t\t\t[ DIFF_EQUAL, midCommon ]\n\t\t\t], diffsB );\n\t\t}\n\n\t\tif ( checklines && text1.length > 100 && text2.length > 100 ) {\n\t\t\treturn this.diffLineMode( text1, text2, deadline );\n\t\t}\n\n\t\treturn this.diffBisect( text1, text2, deadline );\n\t};\n\n\t/**\n\t * Do the two texts share a substring which is at least half the length of the\n\t * longer text?\n\t * This speedup can produce non-minimal diffs.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {Array.<string>} Five element Array, containing the prefix of\n\t *     text1, the suffix of text1, the prefix of text2, the suffix of\n\t *     text2 and the common middle.  Or null if there was no match.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffHalfMatch = function( text1, text2 ) {\n\t\tvar longtext, shorttext, dmp,\n\t\t\ttext1A, text2B, text2A, text1B, midCommon,\n\t\t\thm1, hm2, hm;\n\n\t\tlongtext = text1.length > text2.length ? text1 : text2;\n\t\tshorttext = text1.length > text2.length ? text2 : text1;\n\t\tif ( longtext.length < 4 || shorttext.length * 2 < longtext.length ) {\n\t\t\treturn null; // Pointless.\n\t\t}\n\t\tdmp = this; // \'this\' becomes \'window\' in a closure.\n\n\t\t/**\n\t\t * Does a substring of shorttext exist within longtext such that the substring\n\t\t * is at least half the length of longtext?\n\t\t * Closure, but does not reference any external variables.\n\t\t * @param {string} longtext Longer string.\n\t\t * @param {string} shorttext Shorter string.\n\t\t * @param {number} i Start index of quarter length substring within longtext.\n\t\t * @return {Array.<string>} Five element Array, containing the prefix of\n\t\t *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n\t\t *     of shorttext and the common middle.  Or null if there was no match.\n\t\t * @private\n\t\t */\n\t\tfunction diffHalfMatchI( longtext, shorttext, i ) {\n\t\t\tvar seed, j, bestCommon, prefixLength, suffixLength,\n\t\t\t\tbestLongtextA, bestLongtextB, bestShorttextA, bestShorttextB;\n\n\t\t\t// Start with a 1/4 length substring at position i as a seed.\n\t\t\tseed = longtext.substring( i, i + Math.floor( longtext.length / 4 ) );\n\t\t\tj = -1;\n\t\t\tbestCommon = "";\n\t\t\twhile ( ( j = shorttext.indexOf( seed, j + 1 ) ) !== -1 ) {\n\t\t\t\tprefixLength = dmp.diffCommonPrefix( longtext.substring( i ),\n\t\t\t\t\tshorttext.substring( j ) );\n\t\t\t\tsuffixLength = dmp.diffCommonSuffix( longtext.substring( 0, i ),\n\t\t\t\t\tshorttext.substring( 0, j ) );\n\t\t\t\tif ( bestCommon.length < suffixLength + prefixLength ) {\n\t\t\t\t\tbestCommon = shorttext.substring( j - suffixLength, j ) +\n\t\t\t\t\t\tshorttext.substring( j, j + prefixLength );\n\t\t\t\t\tbestLongtextA = longtext.substring( 0, i - suffixLength );\n\t\t\t\t\tbestLongtextB = longtext.substring( i + prefixLength );\n\t\t\t\t\tbestShorttextA = shorttext.substring( 0, j - suffixLength );\n\t\t\t\t\tbestShorttextB = shorttext.substring( j + prefixLength );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( bestCommon.length * 2 >= longtext.length ) {\n\t\t\t\treturn [ bestLongtextA, bestLongtextB,\n\t\t\t\t\tbestShorttextA, bestShorttextB, bestCommon\n\t\t\t\t];\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\t// First check if the second quarter is the seed for a half-match.\n\t\thm1 = diffHalfMatchI( longtext, shorttext,\n\t\t\tMath.ceil( longtext.length / 4 ) );\n\n\t\t// Check again based on the third quarter.\n\t\thm2 = diffHalfMatchI( longtext, shorttext,\n\t\t\tMath.ceil( longtext.length / 2 ) );\n\t\tif ( !hm1 && !hm2 ) {\n\t\t\treturn null;\n\t\t} else if ( !hm2 ) {\n\t\t\thm = hm1;\n\t\t} else if ( !hm1 ) {\n\t\t\thm = hm2;\n\t\t} else {\n\n\t\t\t// Both matched.  Select the longest.\n\t\t\thm = hm1[ 4 ].length > hm2[ 4 ].length ? hm1 : hm2;\n\t\t}\n\n\t\t// A half-match was found, sort out the return data.\n\t\ttext1A, text1B, text2A, text2B;\n\t\tif ( text1.length > text2.length ) {\n\t\t\ttext1A = hm[ 0 ];\n\t\t\ttext1B = hm[ 1 ];\n\t\t\ttext2A = hm[ 2 ];\n\t\t\ttext2B = hm[ 3 ];\n\t\t} else {\n\t\t\ttext2A = hm[ 0 ];\n\t\t\ttext2B = hm[ 1 ];\n\t\t\ttext1A = hm[ 2 ];\n\t\t\ttext1B = hm[ 3 ];\n\t\t}\n\t\tmidCommon = hm[ 4 ];\n\t\treturn [ text1A, text1B, text2A, text2B, midCommon ];\n\t};\n\n\t/**\n\t * Do a quick line-level diff on both strings, then rediff the parts for\n\t * greater accuracy.\n\t * This speedup can produce non-minimal diffs.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {number} deadline Time when the diff should be complete by.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffLineMode = function( text1, text2, deadline ) {\n\t\tvar a, diffs, linearray, pointer, countInsert,\n\t\t\tcountDelete, textInsert, textDelete, j;\n\n\t\t// Scan the text on a line-by-line basis first.\n\t\ta = this.diffLinesToChars( text1, text2 );\n\t\ttext1 = a.chars1;\n\t\ttext2 = a.chars2;\n\t\tlinearray = a.lineArray;\n\n\t\tdiffs = this.DiffMain( text1, text2, false, deadline );\n\n\t\t// Convert the diff back to original text.\n\t\tthis.diffCharsToLines( diffs, linearray );\n\n\t\t// Eliminate freak matches (e.g. blank lines)\n\t\tthis.diffCleanupSemantic( diffs );\n\n\t\t// Rediff any replacement blocks, this time character-by-character.\n\t\t// Add a dummy entry at the end.\n\t\tdiffs.push( [ DIFF_EQUAL, "" ] );\n\t\tpointer = 0;\n\t\tcountDelete = 0;\n\t\tcountInsert = 0;\n\t\ttextDelete = "";\n\t\ttextInsert = "";\n\t\twhile ( pointer < diffs.length ) {\n\t\t\tswitch ( diffs[ pointer ][ 0 ] ) {\n\t\t\tcase DIFF_INSERT:\n\t\t\t\tcountInsert++;\n\t\t\t\ttextInsert += diffs[ pointer ][ 1 ];\n\t\t\t\tbreak;\n\t\t\tcase DIFF_DELETE:\n\t\t\t\tcountDelete++;\n\t\t\t\ttextDelete += diffs[ pointer ][ 1 ];\n\t\t\t\tbreak;\n\t\t\tcase DIFF_EQUAL:\n\n\t\t\t\t// Upon reaching an equality, check for prior redundancies.\n\t\t\t\tif ( countDelete >= 1 && countInsert >= 1 ) {\n\n\t\t\t\t\t// Delete the offending records and add the merged ones.\n\t\t\t\t\tdiffs.splice( pointer - countDelete - countInsert,\n\t\t\t\t\t\tcountDelete + countInsert );\n\t\t\t\t\tpointer = pointer - countDelete - countInsert;\n\t\t\t\t\ta = this.DiffMain( textDelete, textInsert, false, deadline );\n\t\t\t\t\tfor ( j = a.length - 1; j >= 0; j-- ) {\n\t\t\t\t\t\tdiffs.splice( pointer, 0, a[ j ] );\n\t\t\t\t\t}\n\t\t\t\t\tpointer = pointer + a.length;\n\t\t\t\t}\n\t\t\t\tcountInsert = 0;\n\t\t\t\tcountDelete = 0;\n\t\t\t\ttextDelete = "";\n\t\t\t\ttextInsert = "";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\t\tdiffs.pop(); // Remove the dummy entry at the end.\n\n\t\treturn diffs;\n\t};\n\n\t/**\n\t * Find the \'middle snake\' of a diff, split the problem in two\n\t * and return the recursively constructed diff.\n\t * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {number} deadline Time at which to bail if not yet complete.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffBisect = function( text1, text2, deadline ) {\n\t\tvar text1Length, text2Length, maxD, vOffset, vLength,\n\t\t\tv1, v2, x, delta, front, k1start, k1end, k2start,\n\t\t\tk2end, k2Offset, k1Offset, x1, x2, y1, y2, d, k1, k2;\n\n\t\t// Cache the text lengths to prevent multiple calls.\n\t\ttext1Length = text1.length;\n\t\ttext2Length = text2.length;\n\t\tmaxD = Math.ceil( ( text1Length + text2Length ) / 2 );\n\t\tvOffset = maxD;\n\t\tvLength = 2 * maxD;\n\t\tv1 = new Array( vLength );\n\t\tv2 = new Array( vLength );\n\n\t\t// Setting all elements to -1 is faster in Chrome & Firefox than mixing\n\t\t// integers and undefined.\n\t\tfor ( x = 0; x < vLength; x++ ) {\n\t\t\tv1[ x ] = -1;\n\t\t\tv2[ x ] = -1;\n\t\t}\n\t\tv1[ vOffset + 1 ] = 0;\n\t\tv2[ vOffset + 1 ] = 0;\n\t\tdelta = text1Length - text2Length;\n\n\t\t// If the total number of characters is odd, then the front path will collide\n\t\t// with the reverse path.\n\t\tfront = ( delta % 2 !== 0 );\n\n\t\t// Offsets for start and end of k loop.\n\t\t// Prevents mapping of space beyond the grid.\n\t\tk1start = 0;\n\t\tk1end = 0;\n\t\tk2start = 0;\n\t\tk2end = 0;\n\t\tfor ( d = 0; d < maxD; d++ ) {\n\n\t\t\t// Bail out if deadline is reached.\n\t\t\tif ( ( new Date() ).getTime() > deadline ) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Walk the front path one step.\n\t\t\tfor ( k1 = -d + k1start; k1 <= d - k1end; k1 += 2 ) {\n\t\t\t\tk1Offset = vOffset + k1;\n\t\t\t\tif ( k1 === -d || ( k1 !== d && v1[ k1Offset - 1 ] < v1[ k1Offset + 1 ] ) ) {\n\t\t\t\t\tx1 = v1[ k1Offset + 1 ];\n\t\t\t\t} else {\n\t\t\t\t\tx1 = v1[ k1Offset - 1 ] + 1;\n\t\t\t\t}\n\t\t\t\ty1 = x1 - k1;\n\t\t\t\twhile ( x1 < text1Length && y1 < text2Length &&\n\t\t\t\t\ttext1.charAt( x1 ) === text2.charAt( y1 ) ) {\n\t\t\t\t\tx1++;\n\t\t\t\t\ty1++;\n\t\t\t\t}\n\t\t\t\tv1[ k1Offset ] = x1;\n\t\t\t\tif ( x1 > text1Length ) {\n\n\t\t\t\t\t// Ran off the right of the graph.\n\t\t\t\t\tk1end += 2;\n\t\t\t\t} else if ( y1 > text2Length ) {\n\n\t\t\t\t\t// Ran off the bottom of the graph.\n\t\t\t\t\tk1start += 2;\n\t\t\t\t} else if ( front ) {\n\t\t\t\t\tk2Offset = vOffset + delta - k1;\n\t\t\t\t\tif ( k2Offset >= 0 && k2Offset < vLength && v2[ k2Offset ] !== -1 ) {\n\n\t\t\t\t\t\t// Mirror x2 onto top-left coordinate system.\n\t\t\t\t\t\tx2 = text1Length - v2[ k2Offset ];\n\t\t\t\t\t\tif ( x1 >= x2 ) {\n\n\t\t\t\t\t\t\t// Overlap detected.\n\t\t\t\t\t\t\treturn this.diffBisectSplit( text1, text2, x1, y1, deadline );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Walk the reverse path one step.\n\t\t\tfor ( k2 = -d + k2start; k2 <= d - k2end; k2 += 2 ) {\n\t\t\t\tk2Offset = vOffset + k2;\n\t\t\t\tif ( k2 === -d || ( k2 !== d && v2[ k2Offset - 1 ] < v2[ k2Offset + 1 ] ) ) {\n\t\t\t\t\tx2 = v2[ k2Offset + 1 ];\n\t\t\t\t} else {\n\t\t\t\t\tx2 = v2[ k2Offset - 1 ] + 1;\n\t\t\t\t}\n\t\t\t\ty2 = x2 - k2;\n\t\t\t\twhile ( x2 < text1Length && y2 < text2Length &&\n\t\t\t\t\ttext1.charAt( text1Length - x2 - 1 ) ===\n\t\t\t\t\ttext2.charAt( text2Length - y2 - 1 ) ) {\n\t\t\t\t\tx2++;\n\t\t\t\t\ty2++;\n\t\t\t\t}\n\t\t\t\tv2[ k2Offset ] = x2;\n\t\t\t\tif ( x2 > text1Length ) {\n\n\t\t\t\t\t// Ran off the left of the graph.\n\t\t\t\t\tk2end += 2;\n\t\t\t\t} else if ( y2 > text2Length ) {\n\n\t\t\t\t\t// Ran off the top of the graph.\n\t\t\t\t\tk2start += 2;\n\t\t\t\t} else if ( !front ) {\n\t\t\t\t\tk1Offset = vOffset + delta - k2;\n\t\t\t\t\tif ( k1Offset >= 0 && k1Offset < vLength && v1[ k1Offset ] !== -1 ) {\n\t\t\t\t\t\tx1 = v1[ k1Offset ];\n\t\t\t\t\t\ty1 = vOffset + x1 - k1Offset;\n\n\t\t\t\t\t\t// Mirror x2 onto top-left coordinate system.\n\t\t\t\t\t\tx2 = text1Length - x2;\n\t\t\t\t\t\tif ( x1 >= x2 ) {\n\n\t\t\t\t\t\t\t// Overlap detected.\n\t\t\t\t\t\t\treturn this.diffBisectSplit( text1, text2, x1, y1, deadline );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Diff took too long and hit the deadline or\n\t\t// number of diffs equals number of characters, no commonality at all.\n\t\treturn [\n\t\t\t[ DIFF_DELETE, text1 ],\n\t\t\t[ DIFF_INSERT, text2 ]\n\t\t];\n\t};\n\n\t/**\n\t * Given the location of the \'middle snake\', split the diff in two parts\n\t * and recurse.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {number} x Index of split point in text1.\n\t * @param {number} y Index of split point in text2.\n\t * @param {number} deadline Time at which to bail if not yet complete.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffBisectSplit = function( text1, text2, x, y, deadline ) {\n\t\tvar text1a, text1b, text2a, text2b, diffs, diffsb;\n\t\ttext1a = text1.substring( 0, x );\n\t\ttext2a = text2.substring( 0, y );\n\t\ttext1b = text1.substring( x );\n\t\ttext2b = text2.substring( y );\n\n\t\t// Compute both diffs serially.\n\t\tdiffs = this.DiffMain( text1a, text2a, false, deadline );\n\t\tdiffsb = this.DiffMain( text1b, text2b, false, deadline );\n\n\t\treturn diffs.concat( diffsb );\n\t};\n\n\t/**\n\t * Reduce the number of edits by eliminating semantically trivial equalities.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t */\n\tDiffMatchPatch.prototype.diffCleanupSemantic = function( diffs ) {\n\t\tvar changes, equalities, equalitiesLength, lastequality,\n\t\t\tpointer, lengthInsertions2, lengthDeletions2, lengthInsertions1,\n\t\t\tlengthDeletions1, deletion, insertion, overlapLength1, overlapLength2;\n\t\tchanges = false;\n\t\tequalities = []; // Stack of indices where equalities are found.\n\t\tequalitiesLength = 0; // Keeping our own length var is faster in JS.\n\t\t/** @type {?string} */\n\t\tlastequality = null;\n\n\t\t// Always equal to diffs[equalities[equalitiesLength - 1]][1]\n\t\tpointer = 0; // Index of current position.\n\n\t\t// Number of characters that changed prior to the equality.\n\t\tlengthInsertions1 = 0;\n\t\tlengthDeletions1 = 0;\n\n\t\t// Number of characters that changed after the equality.\n\t\tlengthInsertions2 = 0;\n\t\tlengthDeletions2 = 0;\n\t\twhile ( pointer < diffs.length ) {\n\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_EQUAL ) { // Equality found.\n\t\t\t\tequalities[ equalitiesLength++ ] = pointer;\n\t\t\t\tlengthInsertions1 = lengthInsertions2;\n\t\t\t\tlengthDeletions1 = lengthDeletions2;\n\t\t\t\tlengthInsertions2 = 0;\n\t\t\t\tlengthDeletions2 = 0;\n\t\t\t\tlastequality = diffs[ pointer ][ 1 ];\n\t\t\t} else { // An insertion or deletion.\n\t\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_INSERT ) {\n\t\t\t\t\tlengthInsertions2 += diffs[ pointer ][ 1 ].length;\n\t\t\t\t} else {\n\t\t\t\t\tlengthDeletions2 += diffs[ pointer ][ 1 ].length;\n\t\t\t\t}\n\n\t\t\t\t// Eliminate an equality that is smaller or equal to the edits on both\n\t\t\t\t// sides of it.\n\t\t\t\tif ( lastequality && ( lastequality.length <=\n\t\t\t\t\t\tMath.max( lengthInsertions1, lengthDeletions1 ) ) &&\n\t\t\t\t\t\t( lastequality.length <= Math.max( lengthInsertions2,\n\t\t\t\t\t\t\tlengthDeletions2 ) ) ) {\n\n\t\t\t\t\t// Duplicate record.\n\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\tequalities[ equalitiesLength - 1 ],\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t[ DIFF_DELETE, lastequality ]\n\t\t\t\t\t);\n\n\t\t\t\t\t// Change second copy to insert.\n\t\t\t\t\tdiffs[ equalities[ equalitiesLength - 1 ] + 1 ][ 0 ] = DIFF_INSERT;\n\n\t\t\t\t\t// Throw away the equality we just deleted.\n\t\t\t\t\tequalitiesLength--;\n\n\t\t\t\t\t// Throw away the previous equality (it needs to be reevaluated).\n\t\t\t\t\tequalitiesLength--;\n\t\t\t\t\tpointer = equalitiesLength > 0 ? equalities[ equalitiesLength - 1 ] : -1;\n\n\t\t\t\t\t// Reset the counters.\n\t\t\t\t\tlengthInsertions1 = 0;\n\t\t\t\t\tlengthDeletions1 = 0;\n\t\t\t\t\tlengthInsertions2 = 0;\n\t\t\t\t\tlengthDeletions2 = 0;\n\t\t\t\t\tlastequality = null;\n\t\t\t\t\tchanges = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\n\t\t// Normalize the diff.\n\t\tif ( changes ) {\n\t\t\tthis.diffCleanupMerge( diffs );\n\t\t}\n\n\t\t// Find any overlaps between deletions and insertions.\n\t\t// e.g: <del>abcxxx</del><ins>xxxdef</ins>\n\t\t//   -> <del>abc</del>xxx<ins>def</ins>\n\t\t// e.g: <del>xxxabc</del><ins>defxxx</ins>\n\t\t//   -> <ins>def</ins>xxx<del>abc</del>\n\t\t// Only extract an overlap if it is as big as the edit ahead or behind it.\n\t\tpointer = 1;\n\t\twhile ( pointer < diffs.length ) {\n\t\t\tif ( diffs[ pointer - 1 ][ 0 ] === DIFF_DELETE &&\n\t\t\t\t\tdiffs[ pointer ][ 0 ] === DIFF_INSERT ) {\n\t\t\t\tdeletion = diffs[ pointer - 1 ][ 1 ];\n\t\t\t\tinsertion = diffs[ pointer ][ 1 ];\n\t\t\t\toverlapLength1 = this.diffCommonOverlap( deletion, insertion );\n\t\t\t\toverlapLength2 = this.diffCommonOverlap( insertion, deletion );\n\t\t\t\tif ( overlapLength1 >= overlapLength2 ) {\n\t\t\t\t\tif ( overlapLength1 >= deletion.length / 2 ||\n\t\t\t\t\t\t\toverlapLength1 >= insertion.length / 2 ) {\n\n\t\t\t\t\t\t// Overlap found.  Insert an equality and trim the surrounding edits.\n\t\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\t\tpointer,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t[ DIFF_EQUAL, insertion.substring( 0, overlapLength1 ) ]\n\t\t\t\t\t\t);\n\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] =\n\t\t\t\t\t\t\tdeletion.substring( 0, deletion.length - overlapLength1 );\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] = insertion.substring( overlapLength1 );\n\t\t\t\t\t\tpointer++;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif ( overlapLength2 >= deletion.length / 2 ||\n\t\t\t\t\t\t\toverlapLength2 >= insertion.length / 2 ) {\n\n\t\t\t\t\t\t// Reverse overlap found.\n\t\t\t\t\t\t// Insert an equality and swap and trim the surrounding edits.\n\t\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\t\tpointer,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t[ DIFF_EQUAL, deletion.substring( 0, overlapLength2 ) ]\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tdiffs[ pointer - 1 ][ 0 ] = DIFF_INSERT;\n\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] =\n\t\t\t\t\t\t\tinsertion.substring( 0, insertion.length - overlapLength2 );\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 0 ] = DIFF_DELETE;\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] =\n\t\t\t\t\t\t\tdeletion.substring( overlapLength2 );\n\t\t\t\t\t\tpointer++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpointer++;\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\t};\n\n\t/**\n\t * Determine if the suffix of one string is the prefix of another.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {number} The number of characters common to the end of the first\n\t *     string and the start of the second string.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffCommonOverlap = function( text1, text2 ) {\n\t\tvar text1Length, text2Length, textLength,\n\t\t\tbest, length, pattern, found;\n\n\t\t// Cache the text lengths to prevent multiple calls.\n\t\ttext1Length = text1.length;\n\t\ttext2Length = text2.length;\n\n\t\t// Eliminate the null case.\n\t\tif ( text1Length === 0 || text2Length === 0 ) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Truncate the longer string.\n\t\tif ( text1Length > text2Length ) {\n\t\t\ttext1 = text1.substring( text1Length - text2Length );\n\t\t} else if ( text1Length < text2Length ) {\n\t\t\ttext2 = text2.substring( 0, text1Length );\n\t\t}\n\t\ttextLength = Math.min( text1Length, text2Length );\n\n\t\t// Quick check for the worst case.\n\t\tif ( text1 === text2 ) {\n\t\t\treturn textLength;\n\t\t}\n\n\t\t// Start by looking for a single character match\n\t\t// and increase length until no match is found.\n\t\t// Performance analysis: https://neil.fraser.name/news/2010/11/04/\n\t\tbest = 0;\n\t\tlength = 1;\n\t\twhile ( true ) {\n\t\t\tpattern = text1.substring( textLength - length );\n\t\t\tfound = text2.indexOf( pattern );\n\t\t\tif ( found === -1 ) {\n\t\t\t\treturn best;\n\t\t\t}\n\t\t\tlength += found;\n\t\t\tif ( found === 0 || text1.substring( textLength - length ) ===\n\t\t\t\t\ttext2.substring( 0, length ) ) {\n\t\t\t\tbest = length;\n\t\t\t\tlength++;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Split two texts into an array of strings.  Reduce the texts to a string of\n\t * hashes where each Unicode character represents one line.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}\n\t *     An object containing the encoded text1, the encoded text2 and\n\t *     the array of unique strings.\n\t *     The zeroth element of the array of unique strings is intentionally blank.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffLinesToChars = function( text1, text2 ) {\n\t\tvar lineArray, lineHash, chars1, chars2;\n\t\tlineArray = []; // E.g. lineArray[4] === \'Hello\\n\'\n\t\tlineHash = {};  // E.g. lineHash[\'Hello\\n\'] === 4\n\n\t\t// \'\\x00\' is a valid character, but various debuggers don\'t like it.\n\t\t// So we\'ll insert a junk entry to avoid generating a null character.\n\t\tlineArray[ 0 ] = "";\n\n\t\t/**\n\t\t * Split a text into an array of strings.  Reduce the texts to a string of\n\t\t * hashes where each Unicode character represents one line.\n\t\t * Modifies linearray and linehash through being a closure.\n\t\t * @param {string} text String to encode.\n\t\t * @return {string} Encoded string.\n\t\t * @private\n\t\t */\n\t\tfunction diffLinesToCharsMunge( text ) {\n\t\t\tvar chars, lineStart, lineEnd, lineArrayLength, line;\n\t\t\tchars = "";\n\n\t\t\t// Walk the text, pulling out a substring for each line.\n\t\t\t// text.split(\'\\n\') would would temporarily double our memory footprint.\n\t\t\t// Modifying text would create many large strings to garbage collect.\n\t\t\tlineStart = 0;\n\t\t\tlineEnd = -1;\n\n\t\t\t// Keeping our own length variable is faster than looking it up.\n\t\t\tlineArrayLength = lineArray.length;\n\t\t\twhile ( lineEnd < text.length - 1 ) {\n\t\t\t\tlineEnd = text.indexOf( "\\n", lineStart );\n\t\t\t\tif ( lineEnd === -1 ) {\n\t\t\t\t\tlineEnd = text.length - 1;\n\t\t\t\t}\n\t\t\t\tline = text.substring( lineStart, lineEnd + 1 );\n\t\t\t\tlineStart = lineEnd + 1;\n\n\t\t\t\tif ( lineHash.hasOwnProperty ? lineHash.hasOwnProperty( line ) :\n\t\t\t\t\t\t\t( lineHash[ line ] !== undefined ) ) {\n\t\t\t\t\tchars += String.fromCharCode( lineHash[ line ] );\n\t\t\t\t} else {\n\t\t\t\t\tchars += String.fromCharCode( lineArrayLength );\n\t\t\t\t\tlineHash[ line ] = lineArrayLength;\n\t\t\t\t\tlineArray[ lineArrayLength++ ] = line;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn chars;\n\t\t}\n\n\t\tchars1 = diffLinesToCharsMunge( text1 );\n\t\tchars2 = diffLinesToCharsMunge( text2 );\n\t\treturn {\n\t\t\tchars1: chars1,\n\t\t\tchars2: chars2,\n\t\t\tlineArray: lineArray\n\t\t};\n\t};\n\n\t/**\n\t * Rehydrate the text in a diff from a string of line hashes to real lines of\n\t * text.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t * @param {!Array.<string>} lineArray Array of unique strings.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffCharsToLines = function( diffs, lineArray ) {\n\t\tvar x, chars, text, y;\n\t\tfor ( x = 0; x < diffs.length; x++ ) {\n\t\t\tchars = diffs[ x ][ 1 ];\n\t\t\ttext = [];\n\t\t\tfor ( y = 0; y < chars.length; y++ ) {\n\t\t\t\ttext[ y ] = lineArray[ chars.charCodeAt( y ) ];\n\t\t\t}\n\t\t\tdiffs[ x ][ 1 ] = text.join( "" );\n\t\t}\n\t};\n\n\t/**\n\t * Reorder and merge like edit sections.  Merge equalities.\n\t * Any edit section can move as long as it doesn\'t cross an equality.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t */\n\tDiffMatchPatch.prototype.diffCleanupMerge = function( diffs ) {\n\t\tvar pointer, countDelete, countInsert, textInsert, textDelete,\n\t\t\tcommonlength, changes, diffPointer, position;\n\t\tdiffs.push( [ DIFF_EQUAL, "" ] ); // Add a dummy entry at the end.\n\t\tpointer = 0;\n\t\tcountDelete = 0;\n\t\tcountInsert = 0;\n\t\ttextDelete = "";\n\t\ttextInsert = "";\n\t\tcommonlength;\n\t\twhile ( pointer < diffs.length ) {\n\t\t\tswitch ( diffs[ pointer ][ 0 ] ) {\n\t\t\tcase DIFF_INSERT:\n\t\t\t\tcountInsert++;\n\t\t\t\ttextInsert += diffs[ pointer ][ 1 ];\n\t\t\t\tpointer++;\n\t\t\t\tbreak;\n\t\t\tcase DIFF_DELETE:\n\t\t\t\tcountDelete++;\n\t\t\t\ttextDelete += diffs[ pointer ][ 1 ];\n\t\t\t\tpointer++;\n\t\t\t\tbreak;\n\t\t\tcase DIFF_EQUAL:\n\n\t\t\t\t// Upon reaching an equality, check for prior redundancies.\n\t\t\t\tif ( countDelete + countInsert > 1 ) {\n\t\t\t\t\tif ( countDelete !== 0 && countInsert !== 0 ) {\n\n\t\t\t\t\t\t// Factor out any common prefixes.\n\t\t\t\t\t\tcommonlength = this.diffCommonPrefix( textInsert, textDelete );\n\t\t\t\t\t\tif ( commonlength !== 0 ) {\n\t\t\t\t\t\t\tif ( ( pointer - countDelete - countInsert ) > 0 &&\n\t\t\t\t\t\t\t\t\tdiffs[ pointer - countDelete - countInsert - 1 ][ 0 ] ===\n\t\t\t\t\t\t\t\t\tDIFF_EQUAL ) {\n\t\t\t\t\t\t\t\tdiffs[ pointer - countDelete - countInsert - 1 ][ 1 ] +=\n\t\t\t\t\t\t\t\t\ttextInsert.substring( 0, commonlength );\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdiffs.splice( 0, 0, [ DIFF_EQUAL,\n\t\t\t\t\t\t\t\t\ttextInsert.substring( 0, commonlength )\n\t\t\t\t\t\t\t\t] );\n\t\t\t\t\t\t\t\tpointer++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttextInsert = textInsert.substring( commonlength );\n\t\t\t\t\t\t\ttextDelete = textDelete.substring( commonlength );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Factor out any common suffixies.\n\t\t\t\t\t\tcommonlength = this.diffCommonSuffix( textInsert, textDelete );\n\t\t\t\t\t\tif ( commonlength !== 0 ) {\n\t\t\t\t\t\t\tdiffs[ pointer ][ 1 ] = textInsert.substring( textInsert.length -\n\t\t\t\t\t\t\t\t\tcommonlength ) + diffs[ pointer ][ 1 ];\n\t\t\t\t\t\t\ttextInsert = textInsert.substring( 0, textInsert.length -\n\t\t\t\t\t\t\t\tcommonlength );\n\t\t\t\t\t\t\ttextDelete = textDelete.substring( 0, textDelete.length -\n\t\t\t\t\t\t\t\tcommonlength );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Delete the offending records and add the merged ones.\n\t\t\t\t\tif ( countDelete === 0 ) {\n\t\t\t\t\t\tdiffs.splice( pointer - countInsert,\n\t\t\t\t\t\t\tcountDelete + countInsert, [ DIFF_INSERT, textInsert ] );\n\t\t\t\t\t} else if ( countInsert === 0 ) {\n\t\t\t\t\t\tdiffs.splice( pointer - countDelete,\n\t\t\t\t\t\t\tcountDelete + countInsert, [ DIFF_DELETE, textDelete ] );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\t\tpointer - countDelete - countInsert,\n\t\t\t\t\t\t\tcountDelete + countInsert,\n\t\t\t\t\t\t\t[ DIFF_DELETE, textDelete ], [ DIFF_INSERT, textInsert ]\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tpointer = pointer - countDelete - countInsert +\n\t\t\t\t\t\t( countDelete ? 1 : 0 ) + ( countInsert ? 1 : 0 ) + 1;\n\t\t\t\t} else if ( pointer !== 0 && diffs[ pointer - 1 ][ 0 ] === DIFF_EQUAL ) {\n\n\t\t\t\t\t// Merge this equality with the previous one.\n\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] += diffs[ pointer ][ 1 ];\n\t\t\t\t\tdiffs.splice( pointer, 1 );\n\t\t\t\t} else {\n\t\t\t\t\tpointer++;\n\t\t\t\t}\n\t\t\t\tcountInsert = 0;\n\t\t\t\tcountDelete = 0;\n\t\t\t\ttextDelete = "";\n\t\t\t\ttextInsert = "";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif ( diffs[ diffs.length - 1 ][ 1 ] === "" ) {\n\t\t\tdiffs.pop(); // Remove the dummy entry at the end.\n\t\t}\n\n\t\t// Second pass: look for single edits surrounded on both sides by equalities\n\t\t// which can be shifted sideways to eliminate an equality.\n\t\t// e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n\t\tchanges = false;\n\t\tpointer = 1;\n\n\t\t// Intentionally ignore the first and last element (don\'t need checking).\n\t\twhile ( pointer < diffs.length - 1 ) {\n\t\t\tif ( diffs[ pointer - 1 ][ 0 ] === DIFF_EQUAL &&\n\t\t\t\t\tdiffs[ pointer + 1 ][ 0 ] === DIFF_EQUAL ) {\n\n\t\t\t\tdiffPointer = diffs[ pointer ][ 1 ];\n\t\t\t\tposition = diffPointer.substring(\n\t\t\t\t\tdiffPointer.length - diffs[ pointer - 1 ][ 1 ].length\n\t\t\t\t);\n\n\t\t\t\t// This is a single edit surrounded by equalities.\n\t\t\t\tif ( position === diffs[ pointer - 1 ][ 1 ] ) {\n\n\t\t\t\t\t// Shift the edit over the previous equality.\n\t\t\t\t\tdiffs[ pointer ][ 1 ] = diffs[ pointer - 1 ][ 1 ] +\n\t\t\t\t\t\tdiffs[ pointer ][ 1 ].substring( 0, diffs[ pointer ][ 1 ].length -\n\t\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ].length );\n\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] =\n\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] + diffs[ pointer + 1 ][ 1 ];\n\t\t\t\t\tdiffs.splice( pointer - 1, 1 );\n\t\t\t\t\tchanges = true;\n\t\t\t\t} else if ( diffPointer.substring( 0, diffs[ pointer + 1 ][ 1 ].length ) ===\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] ) {\n\n\t\t\t\t\t// Shift the edit over the next equality.\n\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] += diffs[ pointer + 1 ][ 1 ];\n\t\t\t\t\tdiffs[ pointer ][ 1 ] =\n\t\t\t\t\t\tdiffs[ pointer ][ 1 ].substring( diffs[ pointer + 1 ][ 1 ].length ) +\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ];\n\t\t\t\t\tdiffs.splice( pointer + 1, 1 );\n\t\t\t\t\tchanges = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\n\t\t// If shifts were made, the diff needs reordering and another shift sweep.\n\t\tif ( changes ) {\n\t\t\tthis.diffCleanupMerge( diffs );\n\t\t}\n\t};\n\n\treturn function( o, n ) {\n\t\tvar diff, output, text;\n\t\tdiff = new DiffMatchPatch();\n\t\toutput = diff.DiffMain( o, n );\n\t\tdiff.diffCleanupEfficiency( output );\n\t\ttext = diff.diffPrettyHtml( output );\n\n\t\treturn text;\n\t};\n}() );\n\n}() );\n';
    loader.global.define = undefined;
    loader.global.module = undefined;
    loader.global.exports = undefined;
    loader.__exec({
        'source': source,
        'address': module.uri
    });
    loader.global.require = require;
    loader.global.define = define;
    return loader.get('@@global-helpers').retrieveGlobal(module.id, 'QUnit');
});
/*$css*/
define('$css', function (require, exports, module) {
    var loader = require('@loader');
    if (isProduction()) {
        exports.fetch = function (load) {
            var cssFile = load.address;
            var link = document.createElement('link');
            link.rel = 'stylesheet';
            link.href = cssFile;
            document.head.appendChild(link);
            return '';
        };
    } else {
        exports.instantiate = function (load) {
            var loader = this;
            load.metadata.deps = [];
            load.metadata.execute = function () {
                var source = load.source + '/*# sourceURL=' + load.address + ' */';
                source = source.replace(/url\(['"]?([^'"\)]*)['"]?\)/g, function (whole, part) {
                    return 'url(' + steal.joinURIs(load.address, part) + ')';
                });
                source = source.replace(/@import [^uU]['"]?([^'"\)]*)['"]?/g, function (whole, part) {
                    return '@import url(' + steal.joinURIs(load.address, part) + ')';
                });
                if (load.source && typeof document !== 'undefined') {
                    var doc = document.head ? document : document.getElementsByTagName ? document : document.documentElement;
                    var head = doc.head || doc.getElementsByTagName('head')[0], style = document.createElement('style');
                    if (!head) {
                        var docEl = doc.documentElement || doc;
                        head = document.createElement('head');
                        docEl.insertBefore(head, docEl.firstChild);
                    }
                    style.type = 'text/css';
                    if (style.styleSheet) {
                        style.styleSheet.cssText = source;
                    } else {
                        style.appendChild(document.createTextNode(source));
                    }
                    head.appendChild(style);
                    if (loader.has('live-reload')) {
                        var cssReload = loader['import']('live-reload', { name: '$css' });
                        Promise.resolve(cssReload).then(function (reload) {
                            loader['import'](load.name).then(function () {
                                reload.once(load.name, function () {
                                    head.removeChild(style);
                                });
                            });
                        });
                    }
                }
                return System.newModule({ source: source });
            };
            load.metadata.format = 'css';
        };
    }
    function isProduction() {
        return loader.isEnv && loader.isEnv('production') || loader.env === 'production';
    }
    exports.locateScheme = true;
    exports.buildType = 'css';
    exports.includeInBuild = true;
});
/*steal-qunit@0.1.4#steal-qunit*/
'format amd';
define('steal-qunit@0.1.4#steal-qunit', [
    '@loader',
    'qunitjs/qunit/qunit',
    'qunitjs/qunit/qunit.css!'
], function (loader, QUnit) {
    if (loader.has('live-reload')) {
        setupLiveReload();
    }
    setupSauceLabsReporting();
    function setupLiveReload() {
        QUnit.done(updateResults);
        function updateResults() {
            var tests = document.getElementById('qunit-tests').children;
            var node, passed = true;
            for (var i = 0, len = tests.length; i < len; i++) {
                node = tests.item(i);
                removeAllButLast(node, 'runtime');
                if (node.className !== 'pass') {
                    passed = false;
                    break;
                }
            }
            document.getElementById('qunit-banner').className = passed ? 'qunit-pass' : 'qunit-fail';
        }
        function removeAllButLast(parent, className) {
            var node, nodes = [];
            var children = parent.children;
            for (var i = 0, len = children.length; i < len; i++) {
                node = children.item(i);
                if (node.className === className)
                    nodes.push(node);
            }
            while (nodes.length > 1) {
                node = nodes.shift();
                parent.removeChild(node);
            }
        }
    }
    function setupSauceLabsReporting() {
        var log = [];
        QUnit.done(function (test_results) {
            var tests = [];
            for (var i = 0, len = log.length; i < len; i++) {
                var details = log[i];
                tests.push({
                    name: details.name,
                    result: details.result,
                    expected: details.expected,
                    actual: details.actual,
                    source: details.source
                });
            }
            test_results.tests = tests;
            window.global_test_results = test_results;
        });
        QUnit.testStart(function (testDetails) {
            QUnit.log(function (details) {
                if (!details.result) {
                    details.name = testDetails.name;
                    log.push(details);
                }
            });
        });
    }
    QUnit.config.autorun = false;
    steal.done().then(function () {
        if (window.Testee && window.Testee.init) {
            Testee.init();
        }
        QUnit.load();
    });
    return QUnit;
});
/*can-util@3.3.2#js/defaults/defaults*/
define('can-util@3.3.2#js/defaults/defaults', function (require, exports, module) {
    module.exports = function (target) {
        var length = arguments.length;
        for (var i = 1; i < length; i++) {
            for (var prop in arguments[i]) {
                if (target[prop] === undefined) {
                    target[prop] = arguments[i][prop];
                }
            }
        }
        return target;
    };
});
/*can-define@1.0.17#can-define*/
define('can-define@1.0.17#can-define', function (require, exports, module) {
    'use strict';
    'format cjs';
    var event = require('can-event');
    var eventLifecycle = require('can-event/lifecycle/lifecycle');
    var canBatch = require('can-event/batch/batch');
    var canEvent = require('can-event');
    var compute = require('can-compute');
    var Observation = require('can-observation');
    var isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');
    var assign = require('can-util/js/assign/assign');
    var dev = require('can-util/js/dev/dev');
    var CID = require('can-cid');
    var isPlainObject = require('can-util/js/is-plain-object/is-plain-object');
    var isArray = require('can-util/js/is-array/is-array');
    var types = require('can-types');
    var each = require('can-util/js/each/each');
    var defaults = require('can-util/js/defaults/defaults');
    var ns = require('can-namespace');
    var eventsProto, define, make, makeDefinition, replaceWith, getDefinitionsAndMethods, isDefineType, getDefinitionOrMethod;
    var defineConfigurableAndNotEnumerable = function (obj, prop, value) {
        Object.defineProperty(obj, prop, {
            configurable: true,
            enumerable: false,
            writable: true,
            value: value
        });
    };
    var eachPropertyDescriptor = function (map, cb) {
        for (var prop in map) {
            if (map.hasOwnProperty(prop)) {
                cb(prop, Object.getOwnPropertyDescriptor(map, prop));
            }
        }
    };
    module.exports = define = ns.define = function (objPrototype, defines, baseDefine) {
        var dataInitializers = Object.create(baseDefine ? baseDefine.dataInitializers : null), computedInitializers = Object.create(baseDefine ? baseDefine.computedInitializers : null);
        var result = getDefinitionsAndMethods(defines, baseDefine);
        result.dataInitializers = dataInitializers;
        result.computedInitializers = computedInitializers;
        each(result.definitions, function (definition, property) {
            define.property(objPrototype, property, definition, dataInitializers, computedInitializers);
        });
        replaceWith(objPrototype, '_data', function () {
            var map = this;
            var data = {};
            for (var prop in dataInitializers) {
                replaceWith(data, prop, dataInitializers[prop].bind(map), true);
            }
            return data;
        });
        replaceWith(objPrototype, '_computed', function () {
            var map = this;
            var data = {};
            for (var prop in computedInitializers) {
                replaceWith(data, prop, computedInitializers[prop].bind(map));
            }
            return data;
        });
        for (var prop in eventsProto) {
            Object.defineProperty(objPrototype, prop, {
                enumerable: false,
                value: eventsProto[prop],
                configurable: true,
                writable: true
            });
        }
        Object.defineProperty(objPrototype, '_define', {
            enumerable: false,
            value: result,
            configurable: true,
            writable: true
        });
        if (!objPrototype[types.iterator]) {
            defineConfigurableAndNotEnumerable(objPrototype, types.iterator, function () {
                return new define.Iterator(this);
            });
        }
        return result;
    };
    define.extensions = function () {
    };
    var onlyType = function (obj) {
        for (var prop in obj) {
            if (prop !== 'type') {
                return false;
            }
        }
        return true;
    };
    define.property = function (objPrototype, prop, definition, dataInitializers, computedInitializers) {
        var propertyDefinition = define.extensions.apply(this, arguments);
        if (propertyDefinition) {
            definition = propertyDefinition;
        }
        var type = definition.type;
        if (type && onlyType(definition) && type === define.types['*']) {
            Object.defineProperty(objPrototype, prop, {
                get: make.get.data(prop),
                set: make.set.events(prop, make.get.data(prop), make.set.data(prop), make.eventType.data(prop)),
                enumerable: true
            });
            return;
        }
        definition.type = type;
        var dataProperty = definition.get ? 'computed' : 'data', reader = make.read[dataProperty](prop), getter = make.get[dataProperty](prop), setter = make.set[dataProperty](prop), getInitialValue;
        var typeConvert = function (val) {
            return val;
        };
        if (definition.Type) {
            typeConvert = make.set.Type(prop, definition.Type, typeConvert);
        }
        if (type) {
            typeConvert = make.set.type(prop, type, typeConvert);
        }
        var eventsSetter = make.set.events(prop, reader, setter, make.eventType[dataProperty](prop));
        if (definition.value !== undefined || definition.Value !== undefined) {
            getInitialValue = make.get.defaultValue(prop, definition, typeConvert, eventsSetter);
        }
        if (definition.get) {
            computedInitializers[prop] = make.compute(prop, definition.get, getInitialValue);
        } else if (getInitialValue) {
            dataInitializers[prop] = getInitialValue;
        }
        if (definition.get && definition.set) {
            setter = make.set.setter(prop, definition.set, make.read.lastSet(prop), setter, true);
        } else if (definition.set) {
            setter = make.set.setter(prop, definition.set, reader, eventsSetter, false);
        } else if (!definition.get) {
            setter = eventsSetter;
        }
        if (type) {
            setter = make.set.type(prop, type, setter);
        }
        if (definition.Type) {
            setter = make.set.Type(prop, definition.Type, setter);
        }
        Object.defineProperty(objPrototype, prop, {
            get: getter,
            set: setter,
            enumerable: 'serialize' in definition ? !!definition.serialize : !definition.get
        });
    };
    define.Constructor = function (defines) {
        var constructor = function (props) {
            define.setup.call(this, props);
        };
        define(constructor.prototype, defines);
        return constructor;
    };
    make = {
        compute: function (prop, get, defaultValueFn) {
            return function () {
                var map = this, defaultValue = defaultValueFn && defaultValueFn.call(this), computeFn;
                if (defaultValue) {
                    computeFn = defaultValue.isComputed ? defaultValue : compute.async(defaultValue, get, map);
                } else {
                    computeFn = compute.async(defaultValue, get, map);
                }
                return {
                    compute: computeFn,
                    count: 0,
                    handler: function (ev, newVal, oldVal) {
                        canEvent.dispatch.call(map, {
                            type: prop,
                            target: map
                        }, [
                            newVal,
                            oldVal
                        ]);
                    }
                };
            };
        },
        set: {
            data: function (prop) {
                return function (newVal) {
                    this._data[prop] = newVal;
                };
            },
            computed: function (prop) {
                return function (val) {
                    this._computed[prop].compute(val);
                };
            },
            events: function (prop, getCurrent, setData, eventType) {
                return function (newVal) {
                    var current = getCurrent.call(this);
                    if (newVal !== current) {
                        setData.call(this, newVal);
                        canEvent.dispatch.call(this, {
                            type: prop,
                            target: this
                        }, [
                            newVal,
                            current
                        ]);
                    }
                };
            },
            setter: function (prop, setter, getCurrent, setEvents, hasGetter) {
                return function (value) {
                    var self = this;
                    canBatch.start();
                    var setterCalled = false, current = getCurrent.call(this), setValue = setter.call(this, value, function (value) {
                            setEvents.call(self, value);
                            setterCalled = true;
                        }, current);
                    if (setterCalled) {
                        canBatch.stop();
                    } else {
                        if (hasGetter) {
                            if (setValue !== undefined) {
                                if (current !== setValue) {
                                    setEvents.call(this, setValue);
                                }
                                canBatch.stop();
                            } else if (setter.length === 0) {
                                setEvents.call(this, value);
                                canBatch.stop();
                                return;
                            } else if (setter.length === 1) {
                                canBatch.stop();
                            } else {
                                canBatch.stop();
                                return;
                            }
                        } else {
                            if (setValue !== undefined) {
                                setEvents.call(this, setValue);
                                canBatch.stop();
                            } else if (setter.length === 0) {
                                setEvents.call(this, value);
                                canBatch.stop();
                                return;
                            } else if (setter.length === 1) {
                                setEvents.call(this, undefined);
                                canBatch.stop();
                            } else {
                                canBatch.stop();
                                return;
                            }
                        }
                    }
                };
            },
            type: function (prop, type, set) {
                if (typeof type === 'object') {
                    return make.set.Type(prop, type, set);
                } else {
                    return function (newValue) {
                        return set.call(this, type.call(this, newValue, prop));
                    };
                }
            },
            Type: function (prop, Type, set) {
                if (isArray(Type) && types.DefineList) {
                    Type = types.DefineList.extend({ '#': Type[0] });
                } else if (typeof Type === 'object') {
                    if (types.DefineMap) {
                        Type = types.DefineMap.extend(Type);
                    } else {
                        Type = define.constructor(Type);
                    }
                }
                return function (newValue) {
                    if (newValue instanceof Type || newValue == null) {
                        return set.call(this, newValue);
                    } else {
                        return set.call(this, new Type(newValue));
                    }
                };
            }
        },
        eventType: {
            data: function (prop) {
                return function (newVal, oldVal) {
                    return oldVal !== undefined || this._data.hasOwnProperty(prop) ? 'set' : 'add';
                };
            },
            computed: function () {
                return function () {
                    return 'set';
                };
            }
        },
        read: {
            data: function (prop) {
                return function () {
                    return this._data[prop];
                };
            },
            computed: function (prop) {
                return function () {
                    return this._computed[prop].compute();
                };
            },
            lastSet: function (prop) {
                return function () {
                    var lastSetValue = this._computed[prop].compute.computeInstance.lastSetValue;
                    return lastSetValue && lastSetValue.get();
                };
            }
        },
        get: {
            defaultValue: function (prop, definition, typeConvert, callSetter) {
                return function () {
                    var value = definition.value;
                    if (value !== undefined) {
                        if (typeof value === 'function') {
                            value = value.call(this);
                        }
                        value = typeConvert(value);
                    } else {
                        var Value = definition.Value;
                        if (Value) {
                            value = typeConvert(new Value());
                        }
                    }
                    if (definition.set) {
                        var VALUE;
                        var sync = true;
                        var setter = make.set.setter(prop, definition.set, function () {
                        }, function (value) {
                            if (sync) {
                                VALUE = value;
                            } else {
                                callSetter.call(this, value);
                            }
                        }, definition.get);
                        setter.call(this, value);
                        sync = false;
                        return VALUE;
                    }
                    return value;
                };
            },
            data: function (prop) {
                return function () {
                    Observation.add(this, prop);
                    return this._data[prop];
                };
            },
            computed: function (prop) {
                return function () {
                    return this._computed[prop].compute();
                };
            }
        }
    };
    define.behaviors = [
        'get',
        'set',
        'value',
        'Value',
        'type',
        'Type',
        'serialize'
    ];
    var addDefinition = function (definition, behavior, value) {
        if (behavior === 'type') {
            var behaviorDef = value;
            if (typeof behaviorDef === 'string') {
                behaviorDef = define.types[behaviorDef];
                if (typeof behaviorDef === 'object') {
                    assign(definition, behaviorDef);
                    behaviorDef = behaviorDef[behavior];
                }
            }
            definition[behavior] = behaviorDef;
        } else {
            definition[behavior] = value;
        }
    };
    makeDefinition = function (prop, def, defaultDefinition) {
        var definition = {};
        each(def, function (value, behavior) {
            addDefinition(definition, behavior, value);
        });
        each(defaultDefinition, function (value, prop) {
            if (definition[prop] === undefined) {
                if (prop !== 'type' && prop !== 'Type') {
                    definition[prop] = value;
                }
            }
        });
        if (!definition.type && !definition.Type) {
            defaults(definition, defaultDefinition);
        }
        if (isEmptyObject(definition)) {
            definition.type = define.types['*'];
        }
        return definition;
    };
    getDefinitionOrMethod = function (prop, value, defaultDefinition) {
        var definition;
        if (typeof value === 'string') {
            definition = { type: value };
        } else if (typeof value === 'function') {
            if (types.isConstructor(value)) {
                definition = { Type: value };
            } else if (isDefineType(value)) {
                definition = { type: value };
            }
        } else if (isArray(value)) {
            definition = { Type: value };
        } else if (isPlainObject(value)) {
            definition = value;
        }
        if (definition) {
            return makeDefinition(prop, definition, defaultDefinition);
        } else {
            return value;
        }
    };
    getDefinitionsAndMethods = function (defines, baseDefines) {
        var definitions = Object.create(baseDefines ? baseDefines.definitions : null);
        var methods = {};
        var defaults = defines['*'], defaultDefinition;
        if (defaults) {
            delete defines['*'];
            defaultDefinition = getDefinitionOrMethod('*', defaults, {});
        } else {
            defaultDefinition = {};
        }
        eachPropertyDescriptor(defines, function (prop, propertyDescriptor) {
            var value;
            if (propertyDescriptor.get || propertyDescriptor.set) {
                value = {
                    get: propertyDescriptor.get,
                    set: propertyDescriptor.set
                };
            } else {
                value = propertyDescriptor.value;
            }
            if (prop === 'constructor') {
                methods[prop] = value;
                return;
            } else {
                var result = getDefinitionOrMethod(prop, value, defaultDefinition);
                if (result && typeof result === 'object') {
                    definitions[prop] = result;
                } else {
                    methods[prop] = result;
                }
            }
        });
        if (defaults) {
            defines['*'] = defaults;
        }
        return {
            definitions: definitions,
            methods: methods,
            defaultDefinition: defaultDefinition
        };
    };
    replaceWith = function (obj, prop, cb, writable) {
        Object.defineProperty(obj, prop, {
            configurable: true,
            get: function () {
                Object.defineProperty(this, prop, {
                    value: undefined,
                    writable: true
                });
                var value = cb.call(this, obj, prop);
                Object.defineProperty(this, prop, {
                    value: value,
                    writable: !!writable
                });
                return value;
            }
        });
    };
    eventsProto = assign({}, event);
    assign(eventsProto, {
        _eventSetup: function () {
        },
        _eventTeardown: function () {
        },
        addEventListener: function (eventName, handler) {
            var computedBinding = this._computed && this._computed[eventName];
            if (computedBinding && computedBinding.compute) {
                if (!computedBinding.count) {
                    computedBinding.count = 1;
                    computedBinding.compute.addEventListener('change', computedBinding.handler);
                } else {
                    computedBinding.count++;
                }
            }
            return eventLifecycle.addAndSetup.apply(this, arguments);
        },
        removeEventListener: function (eventName, handler) {
            var computedBinding = this._computed && this._computed[eventName];
            if (computedBinding) {
                if (computedBinding.count === 1) {
                    computedBinding.count = 0;
                    computedBinding.compute.removeEventListener('change', computedBinding.handler);
                } else {
                    computedBinding.count--;
                }
            }
            return eventLifecycle.removeAndTeardown.apply(this, arguments);
        }
    });
    eventsProto.on = eventsProto.bind = eventsProto.addEventListener;
    eventsProto.off = eventsProto.unbind = eventsProto.removeEventListener;
    delete eventsProto.one;
    define.setup = function (props, sealed) {
        defineConfigurableAndNotEnumerable(this, '_cid');
        defineConfigurableAndNotEnumerable(this, '__bindEvents', {});
        defineConfigurableAndNotEnumerable(this, '_bindings', 0);
        CID(this);
        var definitions = this._define.definitions;
        var instanceDefinitions = {};
        var map = this;
        each(props, function (value, prop) {
            if (definitions[prop]) {
                map[prop] = value;
            } else {
                var def = define.makeSimpleGetterSetter(prop);
                instanceDefinitions[prop] = {};
                Object.defineProperty(map, prop, def);
                map[prop] = define.types.observable(value);
            }
        });
        if (!isEmptyObject(instanceDefinitions)) {
            defineConfigurableAndNotEnumerable(this, '_instanceDefinitions', instanceDefinitions);
        }
    };
    define.replaceWith = replaceWith;
    define.eventsProto = eventsProto;
    define.defineConfigurableAndNotEnumerable = defineConfigurableAndNotEnumerable;
    define.make = make;
    define.getDefinitionOrMethod = getDefinitionOrMethod;
    var simpleGetterSetters = {};
    define.makeSimpleGetterSetter = function (prop) {
        if (!simpleGetterSetters[prop]) {
            var setter = make.set.events(prop, make.get.data(prop), make.set.data(prop), make.eventType.data(prop));
            simpleGetterSetters[prop] = {
                get: make.get.data(prop),
                set: function (newVal) {
                    return setter.call(this, define.types.observable(newVal));
                },
                enumerable: true
            };
        }
        return simpleGetterSetters[prop];
    };
    define.Iterator = function (obj) {
        this.obj = obj;
        this.definitions = Object.keys(obj._define.definitions);
        this.instanceDefinitions = obj._instanceDefinitions ? Object.keys(obj._instanceDefinitions) : Object.keys(obj);
        this.hasGet = typeof obj.get === 'function';
    };
    define.Iterator.prototype.next = function () {
        var key;
        if (this.definitions.length) {
            key = this.definitions.shift();
            var def = this.obj._define.definitions[key];
            if (def.get) {
                return this.next();
            }
        } else if (this.instanceDefinitions.length) {
            key = this.instanceDefinitions.shift();
        } else {
            return {
                value: undefined,
                done: true
            };
        }
        return {
            value: [
                key,
                this.hasGet ? this.obj.get(key) : this.obj[key]
            ],
            done: false
        };
    };
    isDefineType = function (func) {
        return func && func.canDefineType === true;
    };
    define.types = {
        'date': function (str) {
            var type = typeof str;
            if (type === 'string') {
                str = Date.parse(str);
                return isNaN(str) ? null : new Date(str);
            } else if (type === 'number') {
                return new Date(str);
            } else {
                return str;
            }
        },
        'number': function (val) {
            if (val == null) {
                return val;
            }
            return +val;
        },
        'boolean': function (val) {
            if (val == null) {
                return val;
            }
            if (val === 'false' || val === '0' || !val) {
                return false;
            }
            return true;
        },
        'observable': function (newVal) {
            if (isArray(newVal) && types.DefineList) {
                newVal = new types.DefineList(newVal);
            } else if (isPlainObject(newVal) && types.DefineMap) {
                newVal = new types.DefineMap(newVal);
            }
            return newVal;
        },
        'stringOrObservable': function (newVal) {
            if (isArray(newVal)) {
                return new types.DefaultList(newVal);
            } else if (isPlainObject(newVal)) {
                return new types.DefaultMap(newVal);
            } else {
                return define.types.string(newVal);
            }
        },
        'htmlbool': function (val) {
            return typeof val === 'string' || !!val;
        },
        '*': function (val) {
            return val;
        },
        'any': function (val) {
            return val;
        },
        'string': function (val) {
            if (val == null) {
                return val;
            }
            return '' + val;
        },
        'compute': {
            set: function (newValue, setVal, setErr, oldValue) {
                if (newValue && newValue.isComputed) {
                    return newValue;
                }
                if (oldValue && oldValue.isComputed) {
                    oldValue(newValue);
                    return oldValue;
                }
                return newValue;
            },
            get: function (value) {
                return value && value.isComputed ? value() : value;
            }
        }
    };
});
/*can-define@1.0.17#define-helpers/define-helpers*/
define('can-define@1.0.17#define-helpers/define-helpers', function (require, exports, module) {
    var assign = require('can-util/js/assign/assign');
    var CID = require('can-cid');
    var define = require('can-define');
    var canBatch = require('can-event/batch/batch');
    var canEvent = require('can-event');
    var hasMethod = function (obj, method) {
        return obj && typeof obj === 'object' && method in obj;
    };
    var defineHelpers = {
        extendedSetup: function (props) {
            assign(this, props);
        },
        toObject: function (map, props, where, Type) {
            if (props instanceof Type) {
                props.each(function (value, prop) {
                    where[prop] = value;
                });
                return where;
            } else {
                return props;
            }
        },
        defineExpando: function (map, prop, value) {
            var constructorDefines = map._define.definitions;
            if (constructorDefines && constructorDefines[prop]) {
                return;
            }
            var instanceDefines = map._instanceDefinitions;
            if (!instanceDefines) {
                instanceDefines = map._instanceDefinitions = {};
            }
            if (!instanceDefines[prop]) {
                var defaultDefinition = map._define.defaultDefinition || { type: define.types.observable };
                define.property(map, prop, defaultDefinition, {}, {});
                map._data[prop] = defaultDefinition.type ? defaultDefinition.type(value) : define.types.observable(value);
                instanceDefines[prop] = defaultDefinition;
                canBatch.start();
                canEvent.dispatch.call(map, {
                    type: '__keys',
                    target: map
                });
                if (map._data[prop] !== undefined) {
                    canEvent.dispatch.call(map, {
                        type: prop,
                        target: map
                    }, [
                        map._data[prop],
                        undefined
                    ]);
                }
                canBatch.stop();
                return true;
            }
        },
        getValue: function (map, name, val, how) {
            if (how === 'serialize') {
                var constructorDefinitions = map._define.definitions;
                var propDef = constructorDefinitions[name];
                if (propDef && typeof propDef.serialize === 'function') {
                    return propDef.serialize.call(map, val, name);
                }
                var defaultDefinition = map._define.defaultDefinition;
                if (defaultDefinition && typeof defaultDefinition.serialize === 'function') {
                    return defaultDefinition.serialize.call(map, val, name);
                }
            }
            if (hasMethod(val, how)) {
                return val[how]();
            } else {
                return val;
            }
        },
        serialize: function () {
            var serializeMap = null;
            return function (map, how, where) {
                var cid = CID(map), firstSerialize = false;
                if (!serializeMap) {
                    firstSerialize = true;
                    serializeMap = {
                        get: {},
                        serialize: {}
                    };
                }
                serializeMap[how][cid] = where;
                map.each(function (val, name) {
                    var result, isObservable = hasMethod(val, how), serialized = isObservable && serializeMap[how][CID(val)];
                    if (serialized) {
                        result = serialized;
                    } else {
                        result = defineHelpers.getValue(map, name, val, how);
                    }
                    if (result !== undefined) {
                        where[name] = result;
                    }
                });
                if (firstSerialize) {
                    serializeMap = null;
                }
                return where;
            };
        }()
    };
    module.exports = defineHelpers;
});
/*can-define@1.0.17#map/map*/
define('can-define@1.0.17#map/map', function (require, exports, module) {
    var Construct = require('can-construct');
    var define = require('can-define');
    var assign = require('can-util/js/assign/assign');
    var isArray = require('can-util/js/is-array/is-array');
    var isPlainObject = require('can-util/js/is-plain-object/is-plain-object');
    var defineHelpers = require('../define-helpers/define-helpers');
    var Observation = require('can-observation');
    var types = require('can-types');
    var canBatch = require('can-event/batch/batch');
    var ns = require('can-namespace');
    var canLog = require('can-util/js/log/log');
    var readWithoutObserve = Observation.ignore(function (map, prop) {
        return map[prop];
    });
    var eachDefinition = function (map, cb, thisarg, definitions, observe) {
        for (var prop in definitions) {
            var definition = definitions[prop];
            if (typeof definition !== 'object' || ('serialize' in definition ? !!definition.serialize : !definition.get)) {
                var item = observe === false ? readWithoutObserve(map, prop) : map[prop];
                if (cb.call(thisarg || item, item, prop, map) === false) {
                    return false;
                }
            }
        }
    };
    var setProps = function (props, remove) {
        props = assign({}, props);
        var prop, self = this, newVal;
        canBatch.start();
        this.each(function (curVal, prop) {
            if (prop === '_cid') {
                return;
            }
            newVal = props[prop];
            if (newVal === undefined) {
                if (remove) {
                    self[prop] = undefined;
                }
                return;
            }
            if (typeof curVal !== 'object' || curVal === null) {
                self.set(prop, newVal);
            } else if ('replace' in curVal && isArray(newVal)) {
                curVal.replace(newVal);
            } else if ('set' in curVal && (isPlainObject(newVal) || isArray(newVal))) {
                curVal.set(newVal, remove);
            } else if ('attr' in curVal && (isPlainObject(newVal) || isArray(newVal))) {
                curVal.attr(newVal, remove);
            } else if (curVal !== newVal) {
                self.set(prop, newVal);
            }
            delete props[prop];
        }, this, false);
        for (prop in props) {
            if (prop !== '_cid') {
                newVal = props[prop];
                this.set(prop, newVal);
            }
        }
        canBatch.stop();
        return this;
    };
    var DefineMap = Construct.extend('DefineMap', {
        setup: function (base) {
            if (DefineMap) {
                var prototype = this.prototype;
                define(prototype, prototype, base.prototype._define);
                this.prototype.setup = function (props) {
                    define.setup.call(this, defineHelpers.toObject(this, props, {}, DefineMap), this.constructor.seal);
                };
            }
        }
    }, {
        setup: function (props, sealed) {
            if (!this._define) {
                Object.defineProperty(this, '_define', {
                    enumerable: false,
                    value: { definitions: {} }
                });
                Object.defineProperty(this, '_data', {
                    enumerable: false,
                    value: {}
                });
            }
            define.setup.call(this, defineHelpers.toObject(this, props, {}, DefineMap), sealed === true);
        },
        get: function (prop) {
            if (prop) {
                var value = this[prop];
                if (value !== undefined || prop in this || Object.isSealed(this)) {
                    return value;
                } else {
                    Observation.add(this, prop);
                    return this[prop];
                }
            } else {
                return defineHelpers.serialize(this, 'get', {});
            }
        },
        set: function (prop, value) {
            if (typeof prop === 'object') {
                return setProps.call(this, prop, value);
            }
            var defined = defineHelpers.defineExpando(this, prop, value);
            if (!defined) {
                this[prop] = value;
            }
            return this;
        },
        serialize: function () {
            return defineHelpers.serialize(this, 'serialize', {});
        },
        forEach: function (cb, thisarg, observe) {
            if (observe !== false) {
                Observation.add(this, '__keys');
            }
            var res;
            var constructorDefinitions = this._define.definitions;
            if (constructorDefinitions) {
                res = eachDefinition(this, cb, thisarg, constructorDefinitions, observe);
            }
            if (res === false) {
                return this;
            }
            if (this._instanceDefinitions) {
                eachDefinition(this, cb, thisarg, this._instanceDefinitions, observe);
            }
            return this;
        },
        '*': { type: define.types.observable }
    });
    for (var prop in define.eventsProto) {
        DefineMap[prop] = define.eventsProto[prop];
        Object.defineProperty(DefineMap.prototype, prop, {
            enumerable: false,
            value: define.eventsProto[prop],
            writable: true
        });
    }
    types.DefineMap = DefineMap;
    types.DefaultMap = DefineMap;
    DefineMap.prototype.toObject = function () {
        canLog.warn('Use DefineMap::get instead of DefineMap::toObject');
        return this.get();
    };
    DefineMap.prototype.each = DefineMap.prototype.forEach;
    var oldIsMapLike = types.isMapLike;
    types.isMapLike = function (obj) {
        return obj instanceof DefineMap || oldIsMapLike.apply(this, arguments);
    };
    module.exports = ns.DefineMap = DefineMap;
});
/*can-component@3.0.6#test/component-define-test*/
define('can-component@3.0.6#test/component-define-test', function (require, exports, module) {
    var Component = require('can-component');
    var stache = require('can-stache');
    var QUnit = require('steal-qunit');
    var define = require('can-define');
    var DefineMap = require('can-define/map/map');
    var viewModel = require('can-view-model');
    var types = require('can-types');
    QUnit.module('can-component with can-define');
    QUnit.test('Works with can-define', function () {
        var VM = define.Constructor({
            firstName: { type: 'string' },
            lastName: { type: 'string' },
            fullName: {
                get: function () {
                    return [
                        this.firstName,
                        this.lastName
                    ].join(' ');
                }
            }
        });
        Component.extend({
            tag: 'can-define-component',
            ViewModel: VM,
            template: stache('Name: {{fullName}}')
        });
        var frag = stache('<can-define-component {first-name}="firstName" {last-name}="lastName" />')({
            firstName: 'Chris',
            lastName: 'Gomez'
        });
        var vm = viewModel(frag.firstChild);
        QUnit.ok(vm instanceof VM, 'Constructor was called');
        QUnit.equal(vm.firstName, 'Chris', 'ViewModel was set from scope');
        QUnit.equal(vm.lastName, 'Gomez', 'ViewModel was set from scope');
        QUnit.equal(frag.firstChild.innerHTML, 'Name: Chris Gomez', 'Rendered fullName');
        vm.firstName = 'Justin';
        vm.lastName = 'Meyer';
        QUnit.equal(frag.firstChild.innerHTML, 'Name: Justin Meyer', 'Rendered fullName after change');
    });
    QUnit.test('scope method works', function () {
        Component.extend({
            tag: 'my-element',
            viewModel: function (properties, scope, element) {
                QUnit.deepEqual(properties, {
                    first: 'Justin',
                    last: 'Meyer'
                });
                return new types.DefaultMap(properties);
            }
        });
        stache('<my-element {first}=\'firstName\' last=\'Meyer\'/>')({
            firstName: 'Justin',
            middleName: 'Barry'
        });
    });
    QUnit.test('33 - works when instantiated with an object for ViewModel', function () {
        Component.extend({
            tag: 'test-element',
            template: stache('{{someMethod}}'),
            ViewModel: {
                someMethod: function () {
                    ok(true, 'Function got called');
                    return true;
                }
            }
        });
        var template = stache('<test-element>');
        template();
    });
});
/*can-map@3.0.6#bubble*/
define('can-map@3.0.6#bubble', function (require, exports, module) {
    var canEvent = require('can-event');
    var makeArray = require('can-util/js/make-array/make-array');
    var types = require('can-types');
    var isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');
    var bubble = {
        bind: function (parent, eventName) {
            if (!parent.__inSetup) {
                var bubbleEvents = bubble.events(parent, eventName), len = bubbleEvents.length, bubbleEvent;
                if (!parent._bubbleBindings) {
                    parent._bubbleBindings = {};
                }
                for (var i = 0; i < len; i++) {
                    bubbleEvent = bubbleEvents[i];
                    if (!parent._bubbleBindings[bubbleEvent]) {
                        parent._bubbleBindings[bubbleEvent] = 1;
                        bubble.childrenOf(parent, bubbleEvent);
                    } else {
                        parent._bubbleBindings[bubbleEvent]++;
                    }
                }
            }
        },
        unbind: function (parent, eventName) {
            var bubbleEvents = bubble.events(parent, eventName), len = bubbleEvents.length, bubbleEvent;
            for (var i = 0; i < len; i++) {
                bubbleEvent = bubbleEvents[i];
                if (parent._bubbleBindings) {
                    parent._bubbleBindings[bubbleEvent]--;
                }
                if (parent._bubbleBindings && !parent._bubbleBindings[bubbleEvent]) {
                    delete parent._bubbleBindings[bubbleEvent];
                    bubble.teardownChildrenFrom(parent, bubbleEvent);
                    if (isEmptyObject(parent._bubbleBindings)) {
                        delete parent._bubbleBindings;
                    }
                }
            }
        },
        add: function (parent, child, prop) {
            if (types.isMapLike(child) && parent._bubbleBindings) {
                for (var eventName in parent._bubbleBindings) {
                    if (parent._bubbleBindings[eventName]) {
                        bubble.teardownFromParent(parent, child, eventName);
                        bubble.toParent(child, parent, prop, eventName);
                    }
                }
            }
        },
        addMany: function (parent, children) {
            for (var i = 0, len = children.length; i < len; i++) {
                bubble.add(parent, children[i], i);
            }
        },
        remove: function (parent, child) {
            if (types.isMapLike(child) && parent._bubbleBindings) {
                for (var eventName in parent._bubbleBindings) {
                    if (parent._bubbleBindings[eventName]) {
                        bubble.teardownFromParent(parent, child, eventName);
                    }
                }
            }
        },
        removeMany: function (parent, children) {
            for (var i = 0, len = children.length; i < len; i++) {
                bubble.remove(parent, children[i]);
            }
        },
        set: function (parent, prop, value, current) {
            if (types.isMapLike(value)) {
                bubble.add(parent, value, prop);
            }
            if (types.isMapLike(current)) {
                bubble.remove(parent, current);
            }
            return value;
        },
        events: function (map, boundEventName) {
            return map.constructor._bubbleRule(boundEventName, map);
        },
        toParent: function (child, parent, prop, eventName) {
            canEvent.listenTo.call(parent, child, eventName, function () {
                var args = makeArray(arguments), ev = args.shift();
                args[0] = (types.isListLike(parent) ? parent.indexOf(child) : prop) + (args[0] ? '.' + args[0] : '');
                ev.triggeredNS = ev.triggeredNS || {};
                if (ev.triggeredNS[parent._cid]) {
                    return;
                }
                ev.triggeredNS[parent._cid] = true;
                canEvent.dispatch.call(parent, ev, args);
                if (eventName === 'change') {
                    canEvent.dispatch.call(parent, args[0], [
                        args[2],
                        args[3]
                    ]);
                }
            });
        },
        childrenOf: function (parent, eventName) {
            parent._each(function (child, prop) {
                if (child && child.bind) {
                    bubble.toParent(child, parent, prop, eventName);
                }
            });
        },
        teardownFromParent: function (parent, child, eventName) {
            if (child && child.unbind) {
                canEvent.stopListening.call(parent, child, eventName);
            }
        },
        teardownChildrenFrom: function (parent, eventName) {
            parent._each(function (child) {
                bubble.teardownFromParent(parent, child, eventName);
            });
        },
        isBubbling: function (parent, eventName) {
            return parent._bubbleBindings && parent._bubbleBindings[eventName];
        }
    };
    module.exports = bubble;
});
/*can-util@3.3.2#js/is-promise/is-promise*/
define('can-util@3.3.2#js/is-promise/is-promise', function (require, exports, module) {
    var types = require('can-types');
    module.exports = function (obj) {
        return types.isPromise(obj);
    };
});
/*can-map@3.0.6#map-helpers*/
define('can-map@3.0.6#map-helpers', function (require, exports, module) {
    var isPlainObject = require('can-util/js/is-plain-object/is-plain-object');
    var isArray = require('can-util/js/is-array/is-array');
    var isPromise = require('can-util/js/is-promise/is-promise');
    var CID = require('can-cid');
    var types = require('can-types');
    var assign = require('can-util/js/assign/assign');
    var madeMap = null;
    var teardownMap = function () {
        for (var cid in madeMap) {
            if (madeMap[cid].added) {
                delete madeMap[cid].obj._cid;
            }
        }
        madeMap = null;
    };
    var mapHelpers = {
        attrParts: function (attr, keepKey) {
            if (keepKey) {
                return [attr];
            }
            return typeof attr === 'object' ? attr : ('' + attr).split('.');
        },
        canMakeObserve: function (obj) {
            return obj && !isPromise(obj) && (isArray(obj) || isPlainObject(obj));
        },
        serialize: function () {
            var serializeMap = null;
            return function (map, how, where) {
                var cid = CID(map), firstSerialize = false;
                if (!serializeMap) {
                    firstSerialize = true;
                    serializeMap = {
                        attr: {},
                        serialize: {}
                    };
                }
                serializeMap[how][cid] = where;
                map.each(function (val, name) {
                    var result, isObservable = types.isMapLike(val), serialized = isObservable && serializeMap[how][CID(val)];
                    if (serialized) {
                        result = serialized;
                    } else {
                        if (map['___' + how]) {
                            result = map['___' + how](name, val);
                        } else {
                            result = mapHelpers.getValue(map, name, val, how);
                        }
                    }
                    if (result !== undefined) {
                        where[name] = result;
                    }
                });
                if (firstSerialize) {
                    serializeMap = null;
                }
                return where;
            };
        }(),
        getValue: function (map, name, val, how) {
            if (types.isMapLike(val)) {
                return val[how]();
            } else {
                return val;
            }
        },
        define: null,
        addComputedAttr: function (map, attrName, compute) {
            map._computedAttrs[attrName] = {
                compute: compute,
                count: 0,
                handler: function (ev, newVal, oldVal) {
                    map._triggerChange(attrName, 'set', newVal, oldVal, ev.batchNum);
                }
            };
        },
        addToMap: function addToMap(obj, instance) {
            var teardown;
            if (!madeMap) {
                teardown = teardownMap;
                madeMap = {};
            }
            var hasCid = obj._cid;
            var cid = CID(obj);
            if (!madeMap[cid]) {
                madeMap[cid] = {
                    obj: obj,
                    instance: instance,
                    added: !hasCid
                };
            }
            return teardown;
        },
        getMapFromObject: function (obj) {
            return madeMap && madeMap[obj._cid] && madeMap[obj._cid].instance;
        },
        twoLevelDeepExtend: function (destination, source) {
            for (var prop in source) {
                destination[prop] = destination[prop] || {};
                assign(destination[prop], source[prop]);
            }
        }
    };
    module.exports = exports = mapHelpers;
});
/*can-map@3.0.6#can-map*/
define('can-map@3.0.6#can-map', function (require, exports, module) {
    var bubble = require('./bubble');
    var mapHelpers = require('./map-helpers');
    var canEvent = require('can-event');
    var canBatch = require('can-event/batch/batch');
    var eventLifecycle = require('can-event/lifecycle/lifecycle');
    var Construct = require('can-construct');
    var Observation = require('can-observation');
    var ObserveReader = require('can-observation/reader/reader');
    var canCompute = require('can-compute');
    var namespace = require('can-namespace');
    var dev = require('can-util/js/dev/dev');
    var CID = require('can-cid');
    var deepAssign = require('can-util/js/deep-assign/deep-assign');
    var isFunction = require('can-util/js/is-function/is-function');
    var assign = require('can-util/js/assign/assign');
    var types = require('can-types');
    var isArray = require('can-util/js/is-array/is-array');
    var unobservable = { 'constructor': true };
    var Map = Construct.extend({
        setup: function (baseMap) {
            Construct.setup.apply(this, arguments);
            this._computedPropertyNames = [];
            if (Map) {
                if (!this.defaults) {
                    this.defaults = {};
                }
                for (var prop in this.prototype) {
                    if (prop !== 'define' && prop !== 'constructor' && (typeof this.prototype[prop] !== 'function' || this.prototype[prop].prototype instanceof Construct)) {
                        this.defaults[prop] = this.prototype[prop];
                    } else if (this.prototype[prop].isComputed) {
                        this._computedPropertyNames.push(prop);
                    }
                }
                if (mapHelpers.define) {
                    mapHelpers.define(this, baseMap.prototype.define);
                }
            }
        },
        shortName: 'Map',
        _bubbleRule: function (eventName) {
            return eventName === 'change' || eventName.indexOf('.') >= 0 ? ['change'] : [];
        },
        addEventListener: eventLifecycle.addAndSetup,
        removeEventListener: eventLifecycle.removeAndTeardown,
        keys: function (map) {
            var keys = [];
            Observation.add(map, '__keys');
            for (var keyName in map._data) {
                keys.push(keyName);
            }
            return keys;
        }
    }, {
        setup: function (obj) {
            if (obj instanceof Map) {
                obj = obj.serialize();
            }
            this._data = {};
            CID(this, '.map');
            this._setupComputedProperties();
            var teardownMapping = obj && mapHelpers.addToMap(obj, this);
            var defaultValues = this._setupDefaults(obj);
            var data = assign(deepAssign(true, {}, defaultValues), obj);
            this.attr(data);
            if (teardownMapping) {
                teardownMapping();
            }
        },
        _setupComputedProperties: function () {
            this._computedAttrs = {};
            var computes = this.constructor._computedPropertyNames;
            for (var i = 0, len = computes.length; i < len; i++) {
                var attrName = computes[i];
                mapHelpers.addComputedAttr(this, attrName, this[attrName].clone(this));
            }
        },
        _setupDefaults: function () {
            return this.constructor.defaults || {};
        },
        attr: function (attr, val) {
            var type = typeof attr;
            if (attr === undefined) {
                return this._getAttrs();
            } else if (type !== 'string' && type !== 'number') {
                return this._setAttrs(attr, val);
            } else if (arguments.length === 1) {
                return this._get(attr + '');
            } else {
                this._set(attr + '', val);
                return this;
            }
        },
        _get: function (attr) {
            var dotIndex = attr.indexOf('.');
            if (dotIndex >= 0) {
                var value = this.___get(attr);
                if (value !== undefined) {
                    Observation.add(this, attr);
                    return value;
                }
                var first = attr.substr(0, dotIndex), second = attr.substr(dotIndex + 1);
                var current = this.__get(first);
                return current && current._get ? current._get(second) : undefined;
            } else {
                return this.__get(attr);
            }
        },
        __get: function (attr) {
            if (!unobservable[attr] && !this._computedAttrs[attr]) {
                Observation.add(this, attr);
            }
            return this.___get(attr);
        },
        ___get: function (attr) {
            if (attr !== undefined) {
                var computedAttr = this._computedAttrs[attr];
                if (computedAttr && computedAttr.compute) {
                    return computedAttr.compute();
                } else {
                    return this._data.hasOwnProperty(attr) ? this._data[attr] : undefined;
                }
            } else {
                return this._data;
            }
        },
        _set: function (attr, value, keepKey) {
            var dotIndex = attr.indexOf('.'), current;
            if (dotIndex >= 0 && !keepKey) {
                var first = attr.substr(0, dotIndex), second = attr.substr(dotIndex + 1);
                current = this.__inSetup ? undefined : this.___get(first);
                if (types.isMapLike(current)) {
                    current._set(second, value);
                } else {
                    throw new Error('can-map: Object does not exist');
                }
            } else {
                current = this.__inSetup ? undefined : this.___get(attr);
                if (this.__convert) {
                    value = this.__convert(attr, value);
                }
                this.__set(attr, this.__type(value, attr), current);
            }
        },
        __type: function (value, prop) {
            if (typeof value === 'object' && !types.isMapLike(value) && mapHelpers.canMakeObserve(value) && !isArray(value)) {
                var cached = mapHelpers.getMapFromObject(value);
                if (cached) {
                    return cached;
                }
                var MapConstructor = this.constructor.Map || Map;
                return new MapConstructor(value);
            }
            return value;
        },
        __set: function (prop, value, current) {
            if (value !== current) {
                var computedAttr = this._computedAttrs[prop];
                var changeType = computedAttr || current !== undefined || this.___get().hasOwnProperty(prop) ? 'set' : 'add';
                this.___set(prop, typeof value === 'object' ? bubble.set(this, prop, value, current) : value);
                if (!computedAttr || !computedAttr.count) {
                    this._triggerChange(prop, changeType, value, current);
                }
                if (typeof current === 'object') {
                    bubble.teardownFromParent(this, current);
                }
            }
        },
        ___set: function (prop, val) {
            var computedAttr = this._computedAttrs[prop];
            if (computedAttr) {
                computedAttr.compute(val);
            } else {
                this._data[prop] = val;
            }
            if (typeof this.constructor.prototype[prop] !== 'function' && !computedAttr) {
                this[prop] = val;
            }
        },
        removeAttr: function (attr) {
            return this._remove(attr);
        },
        _remove: function (attr) {
            var parts = mapHelpers.attrParts(attr), prop = parts.shift(), current = this.___get(prop);
            if (parts.length && current) {
                return current.removeAttr(parts);
            } else {
                if (typeof attr === 'string' && !!~attr.indexOf('.')) {
                    prop = attr;
                }
                this.__remove(prop, current);
                return current;
            }
        },
        __remove: function (prop, current) {
            if (prop in this._data) {
                this.___remove(prop);
                this._triggerChange(prop, 'remove', undefined, current);
            }
        },
        ___remove: function (prop) {
            delete this._data[prop];
            if (!(prop in this.constructor.prototype)) {
                delete this[prop];
            }
        },
        ___serialize: function (name, val) {
            return mapHelpers.getValue(this, name, val, 'serialize');
        },
        _getAttrs: function () {
            return mapHelpers.serialize(this, 'attr', {});
        },
        _setAttrs: function (props, remove) {
            props = assign({}, props);
            var prop, self = this, newVal;
            canBatch.start();
            this._each(function (curVal, prop) {
                if (prop === '_cid') {
                    return;
                }
                newVal = props[prop];
                if (newVal === undefined) {
                    if (remove) {
                        self.removeAttr(prop);
                    }
                    return;
                }
                if (self.__convert) {
                    newVal = self.__convert(prop, newVal);
                }
                if (types.isMapLike(curVal) && mapHelpers.canMakeObserve(newVal)) {
                    curVal.attr(newVal, remove);
                } else if (curVal !== newVal) {
                    self.__set(prop, self.__type(newVal, prop), curVal);
                }
                delete props[prop];
            });
            for (prop in props) {
                if (prop !== '_cid') {
                    newVal = props[prop];
                    this._set(prop, newVal, true);
                }
            }
            canBatch.stop();
            return this;
        },
        serialize: function () {
            return mapHelpers.serialize(this, 'serialize', {});
        },
        _triggerChange: function (attr, how, newVal, oldVal, batchNum) {
            if (bubble.isBubbling(this, 'change')) {
                canEvent.dispatch.call(this, {
                    type: 'change',
                    target: this,
                    batchNum: batchNum
                }, [
                    attr,
                    how,
                    newVal,
                    oldVal
                ]);
            }
            canEvent.dispatch.call(this, {
                type: attr,
                target: this,
                batchNum: batchNum
            }, [
                newVal,
                oldVal
            ]);
            if (how === 'remove' || how === 'add') {
                canEvent.dispatch.call(this, {
                    type: '__keys',
                    target: this,
                    batchNum: batchNum
                });
            }
        },
        _eventSetup: function () {
        },
        _eventTeardown: function () {
        },
        one: canEvent.one,
        addEventListener: function (eventName, handler) {
            var computedBinding = this._computedAttrs && this._computedAttrs[eventName];
            if (computedBinding && computedBinding.compute) {
                if (!computedBinding.count) {
                    computedBinding.count = 1;
                    computedBinding.compute.addEventListener('change', computedBinding.handler);
                } else {
                    computedBinding.count++;
                }
            }
            bubble.bind(this, eventName);
            return eventLifecycle.addAndSetup.apply(this, arguments);
        },
        removeEventListener: function (eventName, handler) {
            var computedBinding = this._computedAttrs && this._computedAttrs[eventName];
            if (computedBinding) {
                if (computedBinding.count === 1) {
                    computedBinding.count = 0;
                    computedBinding.compute.removeEventListener('change', computedBinding.handler);
                } else {
                    computedBinding.count--;
                }
            }
            bubble.unbind(this, eventName);
            return eventLifecycle.removeAndTeardown.apply(this, arguments);
        },
        compute: function (prop) {
            if (isFunction(this.constructor.prototype[prop])) {
                return canCompute(this[prop], this);
            } else {
                var reads = ObserveReader.reads(prop);
                var last = reads.length - 1;
                return canCompute(function (newVal) {
                    if (arguments.length) {
                        ObserveReader.write(this, reads[last].key, newVal);
                    } else {
                        return ObserveReader.get(this, prop);
                    }
                }, this);
            }
        },
        each: function (callback, context) {
            var key, item;
            var keys = Map.keys(this);
            for (var i = 0, len = keys.length; i < len; i++) {
                key = keys[i];
                item = this.attr(key);
                if (callback.call(context || item, item, key, this) === false) {
                    break;
                }
            }
            return this;
        },
        _each: function (callback) {
            var data = this.___get();
            for (var prop in data) {
                if (data.hasOwnProperty(prop)) {
                    callback(data[prop], prop);
                }
            }
        },
        dispatch: canEvent.dispatch
    });
    Map.prototype.on = Map.prototype.bind = Map.prototype.addEventListener;
    Map.prototype.off = Map.prototype.unbind = Map.prototype.removeEventListener;
    Map.on = Map.bind = Map.addEventListener;
    Map.off = Map.unbind = Map.removeEventListener;
    var oldIsMapLike = types.isMapLike;
    types.isMapLike = function (obj) {
        if (obj instanceof Map) {
            return true;
        } else {
            return oldIsMapLike.call(this, obj);
        }
    };
    if (!types.DefaultMap) {
        types.DefaultMap = Map;
    }
    module.exports = namespace.Map = Map;
});
/*can-list@3.0.3#can-list*/
define('can-list@3.0.3#can-list', function (require, exports, module) {
    require('can-event');
    var namespace = require('can-namespace');
    var Map = require('can-map');
    var bubble = require('can-map/bubble');
    var mapHelpers = require('can-map/map-helpers');
    var canBatch = require('can-event/batch/batch');
    var canEvent = require('can-event');
    var Observation = require('can-observation');
    var CID = require('can-cid');
    var isPromise = require('can-util/js/is-promise/is-promise');
    var makeArray = require('can-util/js/make-array/make-array');
    var assign = require('can-util/js/assign/assign');
    var types = require('can-types');
    var each = require('can-util/js/each/each');
    var splice = [].splice, spliceRemovesProps = function () {
            var obj = {
                0: 'a',
                length: 1
            };
            splice.call(obj, 0, 1);
            return !obj[0];
        }();
    var serializeNonTypes = function (MapType, arg, args) {
        if (arg && arg.serialize && !(arg instanceof MapType)) {
            args.push(new MapType(arg.serialize()));
        } else {
            args.push(arg);
        }
    };
    var List = Map.extend({ Map: Map }, {
            setup: function (instances, options) {
                this.length = 0;
                CID(this, '.map');
                this._setupComputedProperties();
                instances = instances || [];
                var teardownMapping;
                if (isPromise(instances)) {
                    this.replace(instances);
                } else {
                    teardownMapping = instances.length && mapHelpers.addToMap(instances, this);
                    this.push.apply(this, makeArray(instances || []));
                }
                if (teardownMapping) {
                    teardownMapping();
                }
                assign(this, options);
            },
            _triggerChange: function (attr, how, newVal, oldVal) {
                Map.prototype._triggerChange.apply(this, arguments);
                var index = +attr;
                if (!~('' + attr).indexOf('.') && !isNaN(index)) {
                    if (how === 'add') {
                        canEvent.dispatch.call(this, how, [
                            newVal,
                            index
                        ]);
                        canEvent.dispatch.call(this, 'length', [this.length]);
                    } else if (how === 'remove') {
                        canEvent.dispatch.call(this, how, [
                            oldVal,
                            index
                        ]);
                        canEvent.dispatch.call(this, 'length', [this.length]);
                    } else {
                        canEvent.dispatch.call(this, how, [
                            newVal,
                            index
                        ]);
                    }
                }
            },
            ___get: function (attr) {
                if (attr) {
                    var computedAttr = this._computedAttrs[attr];
                    if (computedAttr && computedAttr.compute) {
                        return computedAttr.compute();
                    }
                    if (this[attr] && this[attr].isComputed && typeof this.constructor.prototype[attr] === 'function') {
                        return this[attr]();
                    } else {
                        return this[attr];
                    }
                } else {
                    return this;
                }
            },
            __set: function (prop, value, current) {
                prop = isNaN(+prop) || prop % 1 ? prop : +prop;
                if (typeof prop === 'number') {
                    if (prop > this.length - 1) {
                        var newArr = new Array(prop + 1 - this.length);
                        newArr[newArr.length - 1] = value;
                        this.push.apply(this, newArr);
                        return newArr;
                    } else {
                        this.splice(prop, 1, value);
                        return this;
                    }
                }
                return Map.prototype.__set.call(this, '' + prop, value, current);
            },
            ___set: function (attr, val) {
                this[attr] = val;
                if (+attr >= this.length) {
                    this.length = +attr + 1;
                }
            },
            __remove: function (prop, current) {
                if (isNaN(+prop)) {
                    delete this[prop];
                    this._triggerChange(prop, 'remove', undefined, current);
                } else {
                    this.splice(prop, 1);
                }
            },
            _each: function (callback) {
                var data = this.___get();
                for (var i = 0; i < data.length; i++) {
                    callback(data[i], i);
                }
            },
            serialize: function () {
                return mapHelpers.serialize(this, 'serialize', []);
            },
            splice: function (index, howMany) {
                var args = makeArray(arguments), added = [], i, len, listIndex, allSame = args.length > 2;
                index = index || 0;
                for (i = 0, len = args.length - 2; i < len; i++) {
                    listIndex = i + 2;
                    args[listIndex] = this.__type(args[listIndex], listIndex);
                    added.push(args[listIndex]);
                    if (this[i + index] !== args[listIndex]) {
                        allSame = false;
                    }
                }
                if (allSame && this.length <= added.length) {
                    return added;
                }
                if (howMany === undefined) {
                    howMany = args[1] = this.length - index;
                }
                var removed = splice.apply(this, args);
                if (!spliceRemovesProps) {
                    for (i = this.length; i < removed.length + this.length; i++) {
                        delete this[i];
                    }
                }
                canBatch.start();
                if (howMany > 0) {
                    bubble.removeMany(this, removed);
                    this._triggerChange('' + index, 'remove', undefined, removed);
                }
                if (args.length > 2) {
                    bubble.addMany(this, added);
                    this._triggerChange('' + index, 'add', added, removed);
                }
                canBatch.stop();
                return removed;
            },
            _getAttrs: function () {
                return mapHelpers.serialize(this, 'attr', []);
            },
            _setAttrs: function (items, remove) {
                items = makeArray(items);
                canBatch.start();
                this._updateAttrs(items, remove);
                canBatch.stop();
            },
            _updateAttrs: function (items, remove) {
                var len = Math.min(items.length, this.length);
                for (var prop = 0; prop < len; prop++) {
                    var curVal = this[prop], newVal = items[prop];
                    if (types.isMapLike(curVal) && mapHelpers.canMakeObserve(newVal)) {
                        curVal.attr(newVal, remove);
                    } else if (curVal !== newVal) {
                        this._set(prop + '', newVal);
                    } else {
                    }
                }
                if (items.length > this.length) {
                    this.push.apply(this, items.slice(this.length));
                } else if (items.length < this.length && remove) {
                    this.splice(items.length);
                }
            }
        }), getArgs = function (args) {
            return args[0] && Array.isArray(args[0]) ? args[0] : makeArray(args);
        };
    each({
        push: 'length',
        unshift: 0
    }, function (where, name) {
        var orig = [][name];
        List.prototype[name] = function () {
            var args = [], len = where ? this.length : 0, i = arguments.length, res, val;
            while (i--) {
                val = arguments[i];
                args[i] = bubble.set(this, i, this.__type(val, i));
            }
            res = orig.apply(this, args);
            if (!this.comparator || args.length) {
                this._triggerChange('' + len, 'add', args, undefined);
            }
            return res;
        };
    });
    each({
        pop: 'length',
        shift: 0
    }, function (where, name) {
        List.prototype[name] = function () {
            if (!this.length) {
                return undefined;
            }
            var args = getArgs(arguments), len = where && this.length ? this.length - 1 : 0;
            var res = [][name].apply(this, args);
            this._triggerChange('' + len, 'remove', undefined, [res]);
            if (res && res.removeEventListener) {
                bubble.remove(this, res);
            }
            return res;
        };
    });
    assign(List.prototype, {
        indexOf: function (item, fromIndex) {
            Observation.add(this, 'length');
            for (var i = fromIndex || 0, len = this.length; i < len; i++) {
                if (this.attr(i) === item) {
                    return i;
                }
            }
            return -1;
        },
        join: function () {
            Observation.add(this, 'length');
            return [].join.apply(this, arguments);
        },
        reverse: function () {
            var list = [].reverse.call(makeArray(this));
            return this.replace(list);
        },
        slice: function () {
            Observation.add(this, 'length');
            var temp = Array.prototype.slice.apply(this, arguments);
            return new this.constructor(temp);
        },
        concat: function () {
            var args = [], MapType = this.constructor.Map;
            each(arguments, function (arg) {
                if (types.isListLike(arg) || Array.isArray(arg)) {
                    var arr = types.isListLike(arg) ? makeArray(arg) : arg;
                    each(arr, function (innerArg) {
                        serializeNonTypes(MapType, innerArg, args);
                    });
                } else {
                    serializeNonTypes(MapType, arg, args);
                }
            });
            return new this.constructor(Array.prototype.concat.apply(makeArray(this), args));
        },
        forEach: function (cb, thisarg) {
            var item;
            for (var i = 0, len = this.attr('length'); i < len; i++) {
                item = this.attr(i);
                if (item !== undefined && cb.call(thisarg || item, item, i, this) === false) {
                    break;
                }
            }
            return this;
        },
        replace: function (newList) {
            if (isPromise(newList)) {
                if (this._promise) {
                    this._promise.__isCurrentPromise = false;
                }
                var promise = this._promise = newList;
                promise.__isCurrentPromise = true;
                var self = this;
                newList.then(function (newList) {
                    if (promise.__isCurrentPromise) {
                        self.replace(newList);
                    }
                });
            } else {
                this.splice.apply(this, [
                    0,
                    this.length
                ].concat(makeArray(newList || [])));
            }
            return this;
        },
        filter: function (callback, thisArg) {
            var filteredList = new this.constructor(), self = this, filtered;
            this.each(function (item, index, list) {
                filtered = callback.call(thisArg | self, item, index, self);
                if (filtered) {
                    filteredList.push(item);
                }
            });
            return filteredList;
        },
        map: function (callback, thisArg) {
            var filteredList = new List(), self = this;
            this.each(function (item, index, list) {
                var mapped = callback.call(thisArg | self, item, index, self);
                filteredList.push(mapped);
            });
            return filteredList;
        }
    });
    var oldIsListLike = types.isListLike;
    types.isListLike = function (obj) {
        return obj instanceof List || oldIsListLike.apply(this, arguments);
    };
    var oldType = Map.prototype.__type;
    Map.prototype.__type = function (value, prop) {
        if (typeof value === 'object' && Array.isArray(value)) {
            var cached = mapHelpers.getMapFromObject(value);
            if (cached) {
                return cached;
            }
            return new List(value);
        }
        return oldType.apply(this, arguments);
    };
    var oldSetup = Map.setup;
    Map.setup = function () {
        oldSetup.apply(this, arguments);
        if (!(this.prototype instanceof List)) {
            this.List = Map.List.extend({ Map: this }, {});
        }
    };
    if (!types.DefaultList) {
        types.DefaultList = List;
    }
    List.prototype.each = List.prototype.forEach;
    Map.List = List;
    module.exports = namespace.List = List;
});
/*can-simple-dom@0.4.8#simple-dom/document/node*/
define('can-simple-dom@0.4.8#simple-dom/document/node', [], function () {
    'use strict';
    function Node(nodeType, nodeName, nodeValue, ownerDocument) {
        this.nodeType = nodeType;
        this.nodeName = nodeName;
        this.nodeValue = nodeValue;
        this.ownerDocument = ownerDocument;
        this.childNodes = new ChildNodes(this);
        this.parentNode = null;
        this.previousSibling = null;
        this.nextSibling = null;
        this.firstChild = null;
        this.lastChild = null;
    }
    Node.prototype._cloneNode = function () {
        return new Node(this.nodeType, this.nodeName, this.nodeValue, this.ownerDocument);
    };
    Node.prototype.cloneNode = function (deep) {
        var node = this._cloneNode();
        if (deep) {
            var child = this.firstChild, nextChild = child;
            while (nextChild) {
                nextChild = child.nextSibling;
                node.appendChild(child.cloneNode(true));
                child = nextChild;
            }
        }
        return node;
    };
    Node.prototype.appendChild = function (node) {
        if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
            insertFragment(node, this, this.lastChild, null);
            return node;
        }
        if (node.parentNode) {
            node.parentNode.removeChild(node);
        }
        node.parentNode = this;
        var refNode = this.lastChild;
        if (refNode === null) {
            this.firstChild = node;
            this.lastChild = node;
        } else {
            node.previousSibling = refNode;
            refNode.nextSibling = node;
            this.lastChild = node;
        }
        return node;
    };
    function insertFragment(fragment, newParent, before, after) {
        if (!fragment.firstChild) {
            return;
        }
        var firstChild = fragment.firstChild;
        var lastChild = firstChild;
        var node = firstChild;
        firstChild.previousSibling = before;
        if (before) {
            before.nextSibling = firstChild;
        } else {
            newParent.firstChild = firstChild;
        }
        while (node) {
            node.parentNode = newParent;
            lastChild = node;
            node = node.nextSibling;
        }
        lastChild.nextSibling = after;
        if (after) {
            after.previousSibling = lastChild;
        } else {
            newParent.lastChild = lastChild;
        }
        fragment.firstChild = null;
        fragment.lastChild = null;
    }
    var nodeInsertBefore = Node.prototype.insertBefore = function (node, refNode) {
        if (refNode == null) {
            return this.appendChild(node);
        }
        if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
            insertFragment(node, this, refNode ? refNode.previousSibling : null, refNode);
            return node;
        }
        if (node.parentNode) {
            node.parentNode.removeChild(node);
        }
        node.parentNode = this;
        var previousSibling = refNode.previousSibling;
        if (previousSibling) {
            previousSibling.nextSibling = node;
            node.previousSibling = previousSibling;
        }
        refNode.previousSibling = node;
        node.nextSibling = refNode;
        if (this.firstChild === refNode) {
            this.firstChild = node;
        }
        return node;
    };
    var nodeRemoveChild = Node.prototype.removeChild = function (refNode) {
        if (this.firstChild === refNode) {
            this.firstChild = refNode.nextSibling;
        }
        if (this.lastChild === refNode) {
            this.lastChild = refNode.previousSibling;
        }
        if (refNode.previousSibling) {
            refNode.previousSibling.nextSibling = refNode.nextSibling;
        }
        if (refNode.nextSibling) {
            refNode.nextSibling.previousSibling = refNode.previousSibling;
        }
        refNode.parentNode = null;
        refNode.nextSibling = null;
        refNode.previousSibling = null;
        return refNode;
    };
    Node.prototype.replaceChild = function (newChild, oldChild) {
        nodeInsertBefore.call(this, newChild, oldChild);
        nodeRemoveChild.call(this, oldChild);
        return oldChild;
    };
    Node.prototype.addEventListener = function () {
    };
    Node.prototype.removeEventListener = function () {
    };
    Node.ELEMENT_NODE = 1;
    Node.ATTRIBUTE_NODE = 2;
    Node.TEXT_NODE = 3;
    Node.CDATA_SECTION_NODE = 4;
    Node.ENTITY_REFERENCE_NODE = 5;
    Node.ENTITY_NODE = 6;
    Node.PROCESSING_INSTRUCTION_NODE = 7;
    Node.COMMENT_NODE = 8;
    Node.DOCUMENT_NODE = 9;
    Node.DOCUMENT_TYPE_NODE = 10;
    Node.DOCUMENT_FRAGMENT_NODE = 11;
    Node.NOTATION_NODE = 12;
    function ChildNodes(node) {
        this.node = node;
    }
    ChildNodes.prototype.item = function (index) {
        var child = this.node.firstChild;
        for (var i = 0; child && index !== i; i++) {
            child = child.nextSibling;
        }
        return child;
    };
    var $__default = Node;
    return {
        get default() {
            return $__default;
        },
        __esModule: true
    };
});
/*can-simple-dom@0.4.8#simple-dom/document/element*/
define('can-simple-dom@0.4.8#simple-dom/document/element', ['./node'], function ($__0) {
    'use strict';
    if (!$__0 || !$__0.__esModule)
        $__0 = { default: $__0 };
    var Node = $__0.default;
    var attrSpecial = {
        'class': function (element, value) {
            element._className = value;
        }
    };
    function Element(tagName, ownerDocument) {
        tagName = tagName.toUpperCase();
        this.nodeConstructor(1, tagName, null, ownerDocument);
        this.style = new Style(this);
        this.attributes = [];
        this.tagName = tagName;
    }
    Element.prototype = Object.create(Node.prototype);
    Element.prototype.constructor = Element;
    Element.prototype.nodeConstructor = Node;
    Element.prototype._cloneNode = function () {
        var node = this.ownerDocument.createElement(this.tagName);
        node.attributes = this.attributes.map(function (attr) {
            return {
                name: attr.name,
                value: attr.value,
                specified: attr.specified
            };
        });
        return node;
    };
    Element.prototype.getAttribute = function (_name) {
        var attributes = this.attributes;
        var name = _name.toLowerCase();
        var attr;
        for (var i = 0, l = attributes.length; i < l; i++) {
            attr = attributes[i];
            if (attr.name === name) {
                return attr.value;
            }
        }
        return null;
    };
    Element.prototype.setAttribute = function () {
        return this._setAttribute.apply(this, arguments);
    };
    Element.prototype._setAttribute = function (_name, value) {
        var attributes = this.attributes;
        var name = _name.toLowerCase();
        var attr;
        for (var i = 0, l = attributes.length; i < l; i++) {
            attr = attributes[i];
            if (attr.name === name) {
                attr.value = value;
                return;
            }
        }
        attributes.push({
            name: name,
            value: value,
            specified: true
        });
        attributes[name] = value;
        var special = attrSpecial[name];
        if (special) {
            special(this, value);
        }
    };
    Element.prototype.hasAttribute = function (_name) {
        var attributes = this.attributes;
        var name = _name.toLowerCase();
        var attr;
        for (var i = 0, len = attributes.length; i < len; i++) {
            attr = attributes[i];
            if (attr.name === name) {
                return true;
            }
        }
        return false;
    };
    Element.prototype.removeAttribute = function (name) {
        var attributes = this.attributes;
        for (var i = 0, l = attributes.length; i < l; i++) {
            var attr = attributes[i];
            if (attr.name === name) {
                attributes.splice(i, 1);
                delete attributes[name];
                return;
            }
        }
    };
    Element.prototype.getElementsByTagName = function (name) {
        name = name.toUpperCase();
        var elements = [];
        var cur = this.firstChild;
        while (cur) {
            if (cur.nodeType === Node.ELEMENT_NODE) {
                if (cur.nodeName === name || name === '*') {
                    elements.push(cur);
                }
                elements.push.apply(elements, cur.getElementsByTagName(name));
            }
            cur = cur.nextSibling;
        }
        return elements;
    };
    Element.prototype.contains = function (child) {
        child = child.parentNode;
        while (child) {
            if (child === this) {
                return true;
            }
            child = child.parentNode;
        }
        return false;
    };
    Element.prototype.getElementById = function (id) {
        var cur = this.firstChild, child;
        while (cur) {
            if (cur.attributes && cur.attributes.length) {
                var attr = void 0;
                for (var i = 0, len = cur.attributes.length; i < len; i++) {
                    attr = cur.attributes[i];
                    if (attr.name === 'id' && attr.value === id) {
                        return cur;
                    }
                }
            }
            if (cur.getElementById) {
                child = cur.getElementById(id);
                if (child) {
                    return child;
                }
            }
            cur = cur.nextSibling;
        }
    };
    function Style(node) {
        this.__node = node;
    }
    if (Object.defineProperty) {
        Object.defineProperty(Element.prototype, 'className', {
            get: function () {
                return this._className || '';
            },
            set: function (val) {
                this._setAttribute('class', val);
                this._className = val;
            }
        });
        Object.defineProperty(Style.prototype, 'cssText', {
            get: function () {
                return this.__node.getAttribute('style') || '';
            },
            set: function (val) {
                this.__node._setAttribute('style', val);
            }
        });
        Object.defineProperty(Element.prototype, 'innerHTML', {
            get: function () {
                var html = '';
                var cur = this.firstChild;
                while (cur) {
                    html += this.ownerDocument.__serializer.serialize(cur);
                    cur = cur.nextSibling;
                }
                return html;
            },
            set: function (html) {
                this.lastChild = this.firstChild = null;
                var fragment;
                if (this.nodeName === 'SCRIPT' || this.nodeName === 'STYLE') {
                    fragment = this.ownerDocument.createTextNode(html);
                } else {
                    fragment = this.ownerDocument.__parser.parse(html);
                }
                this.appendChild(fragment);
            }
        });
        Object.defineProperty(Element.prototype, 'outerHTML', {
            get: function () {
                return this.ownerDocument.__serializer.serialize(this);
            },
            set: function (html) {
                this.parentNode.replaceChild(this.ownerDocument.__parser.parse(html), this);
            }
        });
    }
    var $__default = Element;
    return {
        get default() {
            return $__default;
        },
        __esModule: true
    };
});
/*can-simple-dom@0.4.8#simple-dom/document/text*/
define('can-simple-dom@0.4.8#simple-dom/document/text', ['./node'], function ($__0) {
    'use strict';
    if (!$__0 || !$__0.__esModule)
        $__0 = { default: $__0 };
    var Node = $__0.default;
    function Text(text, ownerDocument) {
        this.nodeConstructor(3, '#text', text, ownerDocument);
    }
    Text.prototype._cloneNode = function () {
        return this.ownerDocument.createTextNode(this.nodeValue);
    };
    Text.prototype = Object.create(Node.prototype);
    Text.prototype.constructor = Text;
    Text.prototype.nodeConstructor = Node;
    var $__default = Text;
    return {
        get default() {
            return $__default;
        },
        __esModule: true
    };
});
/*can-simple-dom@0.4.8#simple-dom/document/comment*/
define('can-simple-dom@0.4.8#simple-dom/document/comment', ['./node'], function ($__0) {
    'use strict';
    if (!$__0 || !$__0.__esModule)
        $__0 = { default: $__0 };
    var Node = $__0.default;
    function Comment(text, ownerDocument) {
        this.nodeConstructor(8, '#comment', text, ownerDocument);
    }
    Comment.prototype._cloneNode = function () {
        return this.ownerDocument.createComment(this.nodeValue);
    };
    Comment.prototype = Object.create(Node.prototype);
    Comment.prototype.constructor = Comment;
    Comment.prototype.nodeConstructor = Node;
    var $__default = Comment;
    return {
        get default() {
            return $__default;
        },
        __esModule: true
    };
});
/*can-simple-dom@0.4.8#simple-dom/document/document-fragment*/
define('can-simple-dom@0.4.8#simple-dom/document/document-fragment', ['./node'], function ($__0) {
    'use strict';
    if (!$__0 || !$__0.__esModule)
        $__0 = { default: $__0 };
    var Node = $__0.default;
    function DocumentFragment(ownerDocument) {
        this.nodeConstructor(11, '#document-fragment', null, ownerDocument);
    }
    DocumentFragment.prototype._cloneNode = function () {
        return this.ownerDocument.createDocumentFragment();
    };
    DocumentFragment.prototype = Object.create(Node.prototype);
    DocumentFragment.prototype.constructor = DocumentFragment;
    DocumentFragment.prototype.nodeConstructor = Node;
    var $__default = DocumentFragment;
    return {
        get default() {
            return $__default;
        },
        __esModule: true
    };
});
/*micro-location@0.1.5#lib/micro-location*/
function Location() {
    this.init.apply(this, arguments);
}
Location.prototype = {
    init: function (protocol, host, hostname, port, pathname, search, hash) {
        this.protocol = protocol;
        this.host = host;
        this.hostname = hostname;
        this.port = port || '';
        this.pathname = pathname || '';
        this.search = search || '';
        this.hash = hash || '';
        if (protocol) {
            with (this)
                this.href = protocol + '//' + host + pathname + search + hash;
        } else if (host) {
            with (this)
                this.href = '//' + host + pathname + search + hash;
        } else {
            with (this)
                this.href = pathname + search + hash;
        }
    },
    params: function (name) {
        if (!this._params) {
            var params = {};
            var pairs = this.search.substring(1).split(/[;&]/);
            for (var i = 0, len = pairs.length; i < len; i++) {
                if (!pairs[i])
                    continue;
                var pair = pairs[i].split(/=/);
                var key = decodeURIComponent(pair[0].replace(/\+/g, '%20'));
                var val = decodeURIComponent(pair[1].replace(/\+/g, '%20'));
                if (!params[key])
                    params[key] = [];
                params[key].push(val);
            }
            this._params = params;
        }
        switch (typeof name) {
        case 'undefined':
            return this._params;
        case 'object':
            return this.build(name);
        }
        return this._params[name] ? this._params[name][0] : null;
    },
    build: function (params) {
        if (!params)
            params = this._params;
        var ret = new Location();
        var _search = this.search;
        if (params) {
            var search = [];
            for (var key in params)
                if (params.hasOwnProperty(key)) {
                    var val = params[key];
                    switch (typeof val) {
                    case 'object':
                        for (var i = 0, len = val.length; i < len; i++) {
                            search.push(encodeURIComponent(key) + '=' + encodeURIComponent(val[i]));
                        }
                        break;
                    default:
                        search.push(encodeURIComponent(key) + '=' + encodeURIComponent(val));
                    }
                }
            _search = '?' + search.join('&');
        }
        with (this)
            ret.init.apply(ret, [
                protocol,
                host,
                hostname,
                port,
                pathname,
                _search,
                hash
            ]);
        return ret;
    }
};
Location.regexp = new RegExp('^(?:(https?:)//(([^:/]+)(:[^/]+)?))?([^#?]*)(\\?[^#]*)?(#.*)?$');
Location.parse = function (string) {
    var matched = String(string).match(this.regexp);
    var ret = new Location();
    ret.init.apply(ret, matched.slice(1));
    return ret;
};
(function (root, factory) {
    if (typeof module === 'object' && module.exports) {
        module.exports = { Location: factory() };
    } else if (typeof define === 'function' && define.amd) {
        define('micro-location@0.1.5#lib/micro-location', [], function () {
            return { Location: factory() };
        });
    } else {
        root.Location = factory();
    }
}(this, function () {
    return Location;
}));
/*can-simple-dom@0.4.8#simple-dom/extend*/
define('can-simple-dom@0.4.8#simple-dom/extend', [], function () {
    'use strict';
    var $__default = function (a, b) {
        for (var p in b) {
            a[p] = b[p];
        }
        return a;
    };
    ;
    return {
        get default() {
            return $__default;
        },
        __esModule: true
    };
});
/*can-simple-dom@0.4.8#simple-dom/document/anchor-element*/
define('can-simple-dom@0.4.8#simple-dom/document/anchor-element', [
    './element',
    'micro-location',
    '../extend'
], function ($__0, $__2, $__4) {
    'use strict';
    if (!$__0 || !$__0.__esModule)
        $__0 = { default: $__0 };
    if (!$__2 || !$__2.__esModule)
        $__2 = { default: $__2 };
    if (!$__4 || !$__4.__esModule)
        $__4 = { default: $__4 };
    var Element = $__0.default;
    var microLocation = $__2.default;
    var extend = $__4.default;
    var Location = microLocation.Location || microLocation;
    function AnchorElement(tagName, ownerDocument) {
        this.elementConstructor(tagName, ownerDocument);
        extend(this, Location.parse(''));
    }
    AnchorElement.prototype = Object.create(Element.prototype);
    AnchorElement.prototype.constructor = AnchorElement;
    AnchorElement.prototype.elementConstructor = Element;
    AnchorElement.prototype.setAttribute = function (_name, value) {
        Element.prototype.setAttribute.apply(this, arguments);
        if (_name.toLowerCase() === 'href') {
            extend(this, Location.parse(value));
        }
    };
    var $__default = AnchorElement;
    return {
        get default() {
            return $__default;
        },
        __esModule: true
    };
});
/*can-simple-dom@0.4.8#simple-dom/document/utils.js*/
define('can-simple-dom@0.4.8#simple-dom/document/utils.js', [], function () {
    'use strict';
    function propToAttr(Element, name) {
        Object.defineProperty(Element.prototype, name, {
            get: function () {
                return this.getAttribute(name);
            },
            set: function (val) {
                this.setAttribute(name, val);
            }
        });
    }
    ;
    return {
        get propToAttr() {
            return propToAttr;
        },
        __esModule: true
    };
});
/*can-simple-dom@0.4.8#simple-dom/document/input-element*/
define('can-simple-dom@0.4.8#simple-dom/document/input-element', [
    './element',
    './utils'
], function ($__0, $__2) {
    'use strict';
    if (!$__0 || !$__0.__esModule)
        $__0 = { default: $__0 };
    if (!$__2 || !$__2.__esModule)
        $__2 = { default: $__2 };
    var Element = $__0.default;
    var propToAttr = $__2.propToAttr;
    function InputElement(tagName, ownerDocument) {
        this.elementConstructor(tagName, ownerDocument);
    }
    InputElement.prototype = Object.create(Element.prototype);
    InputElement.prototype.constructor = InputElement;
    InputElement.prototype.elementConstructor = Element;
    propToAttr(InputElement, 'type');
    propToAttr(InputElement, 'value');
    Object.defineProperty(InputElement.prototype, 'checked', {
        get: function () {
            return this.hasAttribute('checked');
        },
        set: function (value) {
            if (value) {
                this.setAttribute('checked', '');
            } else {
                this.removeAttribute('checked');
            }
        }
    });
    var $__default = InputElement;
    return {
        get default() {
            return $__default;
        },
        __esModule: true
    };
});
/*can-simple-dom@0.4.8#simple-dom/document/utils*/
define('can-simple-dom@0.4.8#simple-dom/document/utils', [], function () {
    'use strict';
    function propToAttr(Element, name) {
        Object.defineProperty(Element.prototype, name, {
            get: function () {
                return this.getAttribute(name);
            },
            set: function (val) {
                this.setAttribute(name, val);
            }
        });
    }
    ;
    return {
        get propToAttr() {
            return propToAttr;
        },
        __esModule: true
    };
});
/*can-simple-dom@0.4.8#simple-dom/document/option-element*/
define('can-simple-dom@0.4.8#simple-dom/document/option-element', [
    './element',
    './utils'
], function ($__0, $__2) {
    'use strict';
    if (!$__0 || !$__0.__esModule)
        $__0 = { default: $__0 };
    if (!$__2 || !$__2.__esModule)
        $__2 = { default: $__2 };
    var Element = $__0.default;
    var propToAttr = $__2.propToAttr;
    function OptionElement(tagName, ownerDocument) {
        this.elementConstructor(tagName, ownerDocument);
    }
    OptionElement.prototype = Object.create(Element.prototype);
    OptionElement.prototype.constructor = OptionElement;
    OptionElement.prototype.elementConstructor = Element;
    propToAttr(OptionElement, 'value');
    Object.defineProperty(OptionElement.prototype, 'selected', {
        get: function () {
            var val = this.value || '';
            var parent = this.parentNode;
            return parent && parent.value == val;
        },
        set: function (val) {
            if (val) {
                var parent = this.parentNode;
                if (parent) {
                    parent.value = this.value;
                }
            }
        }
    });
    var $__default = OptionElement;
    return {
        get default() {
            return $__default;
        },
        __esModule: true
    };
});
/*can-simple-dom@0.4.8#simple-dom/document/select-element*/
define('can-simple-dom@0.4.8#simple-dom/document/select-element', [
    './element',
    './utils'
], function ($__0, $__2) {
    'use strict';
    if (!$__0 || !$__0.__esModule)
        $__0 = { default: $__0 };
    if (!$__2 || !$__2.__esModule)
        $__2 = { default: $__2 };
    var Element = $__0.default;
    var propToAttr = $__2.propToAttr;
    function SelectElement(tagName, ownerDocument) {
        this.elementConstructor(tagName, ownerDocument);
        this.selectedIndex = 0;
    }
    SelectElement.prototype = Object.create(Element.prototype);
    SelectElement.prototype.constructor = SelectElement;
    SelectElement.prototype.elementConstructor = Element;
    propToAttr(SelectElement, 'value');
    var $__default = SelectElement;
    return {
        get default() {
            return $__default;
        },
        __esModule: true
    };
});
/*can-simple-dom@0.4.8#simple-dom/document*/
define('can-simple-dom@0.4.8#simple-dom/document', [
    './document/node',
    './document/element',
    './document/text',
    './document/comment',
    './document/document-fragment',
    './document/anchor-element',
    './document/input-element',
    './document/option-element',
    './document/select-element'
], function ($__0, $__2, $__4, $__6, $__8, $__10, $__12, $__14, $__16) {
    'use strict';
    if (!$__0 || !$__0.__esModule)
        $__0 = { default: $__0 };
    if (!$__2 || !$__2.__esModule)
        $__2 = { default: $__2 };
    if (!$__4 || !$__4.__esModule)
        $__4 = { default: $__4 };
    if (!$__6 || !$__6.__esModule)
        $__6 = { default: $__6 };
    if (!$__8 || !$__8.__esModule)
        $__8 = { default: $__8 };
    if (!$__10 || !$__10.__esModule)
        $__10 = { default: $__10 };
    if (!$__12 || !$__12.__esModule)
        $__12 = { default: $__12 };
    if (!$__14 || !$__14.__esModule)
        $__14 = { default: $__14 };
    if (!$__16 || !$__16.__esModule)
        $__16 = { default: $__16 };
    var Node = $__0.default;
    var Element = $__2.default;
    var Text = $__4.default;
    var Comment = $__6.default;
    var DocumentFragment = $__8.default;
    var AnchorElement = $__10.default;
    var InputElement = $__12.default;
    var OptionElement = $__14.default;
    var SelectElement = $__16.default;
    function Document() {
        this.nodeConstructor(9, '#document', null, this);
        this.documentElement = new Element('html', this);
        this.body = new Element('body', this);
        this.documentElement.appendChild(this.body);
        this.appendChild(this.documentElement);
        var self = this;
        this.implementation = {
            createHTMLDocument: function (content) {
                var document = new Document();
                var frag = self.__parser.parse(content);
                var body = Element.prototype.getElementsByTagName.call(frag, 'body')[0];
                var head = Element.prototype.getElementsByTagName.call(frag, 'head')[0];
                if (!body && !head) {
                    document.body.appendChild(frag);
                } else {
                    if (body) {
                        document.documentElement.replaceChild(body, document.body);
                    }
                    if (head) {
                        document.documentElement.replaceChild(head, document.head);
                    }
                    document.documentElement.appendChild(frag);
                }
                document.__addSerializerAndParser(self.__serializer, self.__parser);
                return document;
            }
        };
    }
    Document.prototype = Object.create(Node.prototype);
    Document.prototype.constructor = Document;
    Document.prototype.nodeConstructor = Node;
    var specialElements = {
        'a': AnchorElement,
        'input': InputElement,
        'option': OptionElement,
        'select': SelectElement
    };
    Document.prototype.createElement = function (tagName) {
        var Special = specialElements[tagName.toLowerCase()];
        if (Special) {
            return new Special(tagName, this);
        }
        return new Element(tagName, this);
    };
    Document.prototype.createTextNode = function (text) {
        return new Text(text, this);
    };
    Document.prototype.createComment = function (text) {
        return new Comment(text, this);
    };
    Document.prototype.createDocumentFragment = function () {
        return new DocumentFragment(this);
    };
    Document.prototype.getElementsByTagName = function (name) {
        name = name.toUpperCase();
        var elements = [];
        var cur = this.firstChild;
        while (cur) {
            if (cur.nodeType === Node.ELEMENT_NODE) {
                if (cur.nodeName === name || name === '*') {
                    elements.push(cur);
                }
                elements.push.apply(elements, cur.getElementsByTagName(name));
            }
            cur = cur.nextSibling;
        }
        return elements;
    };
    Document.prototype.getElementById = function (id) {
        return Element.prototype.getElementById.apply(this.documentElement, arguments);
    };
    Document.prototype.__addSerializerAndParser = function (serializer, parser) {
        this.__parser = parser;
        this.__serializer = serializer;
    };
    if (Object.defineProperty) {
        Object.defineProperty(Document.prototype, 'currentScript', {
            get: function () {
                var scripts = this.getElementsByTagName('script');
                var first = scripts[scripts.length - 1];
                if (!first) {
                    first = this.createElement('script');
                }
                return first;
            }
        });
    }
    var $__default = Document;
    return {
        get default() {
            return $__default;
        },
        __esModule: true
    };
});
/*can-simple-dom@0.4.8#simple-dom/event*/
define('can-simple-dom@0.4.8#simple-dom/event', [
    './document/node',
    './document'
], function ($__0, $__2) {
    'use strict';
    if (!$__0 || !$__0.__esModule)
        $__0 = { default: $__0 };
    if (!$__2 || !$__2.__esModule)
        $__2 = { default: $__2 };
    var Node = $__0.default;
    var Document = $__2.default;
    var Event = function () {
    };
    Event.prototype.initEvent = function (type, bubbles, cancelable) {
        this.type = type;
        this.bubbles = !!bubbles;
        this.cancelable = !!cancelable;
    };
    Event.prototype.stopPropagation = function () {
        this.isPropagationStopped = true;
    };
    Event.prototype.preventDefault = function () {
        this.isDefaultPrevented = true;
    };
    Document.prototype.createEvent = function (type) {
        return new Event();
    };
    Node.prototype.addEventListener = function (event, handler, capture) {
        if (!this.__handlers) {
            Object.defineProperty(this, '__handlers', {
                value: {},
                enumerable: false
            });
        }
        var phase = capture ? 'capture' : 'bubble';
        var handlersByType = this.__handlers[event + ' ' + phase];
        if (!handlersByType) {
            handlersByType = this.__handlers[event + ' ' + phase] = [];
        }
        handlersByType.push(handler);
    };
    Node.prototype.removeEventListener = function (event, handler, capture) {
        if (this.__handlers) {
            var phase = capture ? 'capture' : 'bubble';
            var handlersByType = this.__handlers[event + ' ' + phase];
            if (handlersByType) {
                var index = 0;
                while (index < handlersByType.length) {
                    if (handlersByType[index] === handler) {
                        handlersByType.splice(index, 1);
                    } else {
                        index++;
                    }
                }
            }
        }
    };
    Node.prototype.dispatchEvent = function (event) {
        event.target = this;
        var cur = this;
        var dispatchHandlers = [];
        do {
            var handlers = cur.__handlers && cur.__handlers[event.type + ' bubble'];
            if (handlers) {
                dispatchHandlers.push({
                    node: cur,
                    handlers: handlers
                });
            }
            cur = cur.parentNode;
        } while (event.bubbles && cur);
        for (var i = 0; i < dispatchHandlers.length; i++) {
            var dispatches = dispatchHandlers[i];
            event.currentTarget = dispatches.node;
            for (var h = 0; h < dispatches.handlers.length; h++) {
                var handler = dispatches.handlers[h];
                var res = handler.call(this, event);
                if (res) {
                    event.stopPropagation();
                    event.preventDefault();
                }
                if (event.isImmediatePropagationStopped) {
                    return !event.isDefaultPrevented;
                }
            }
            if (event.isPropagationStopped) {
                return !event.isDefaultPrevented;
            }
        }
        return !event.isDefaultPrevented;
    };
    var $__default = Event;
    return {
        get default() {
            return $__default;
        },
        __esModule: true
    };
});
/*can-simple-dom@0.4.8#simple-dom/html-parser*/
define('can-simple-dom@0.4.8#simple-dom/html-parser', [], function () {
    'use strict';
    function HTMLParser(tokenize, document, voidMap) {
        this.tokenize = tokenize;
        this.document = document;
        this.voidMap = voidMap;
        this.parentStack = [];
    }
    HTMLParser.prototype.isVoid = function (element) {
        return this.voidMap[element.nodeName] === true;
    };
    HTMLParser.prototype.pushElement = function (token) {
        var el = this.document.createElement(token.tagName);
        for (var i = 0; i < token.attributes.length; i++) {
            var attr = token.attributes[i];
            el.setAttribute(attr[0], attr[1]);
        }
        if (this.isVoid(el) || token.selfClosing) {
            return this.appendChild(el);
        }
        this.parentStack.push(el);
    };
    HTMLParser.prototype.popElement = function (token) {
        var el = this.parentStack.pop();
        if (el.nodeName !== token.tagName.toUpperCase()) {
            throw new Error('unbalanced tag');
        }
        this.appendChild(el);
    };
    HTMLParser.prototype.appendText = function (token) {
        var text = this.document.createTextNode(token.chars);
        this.appendChild(text);
    };
    HTMLParser.prototype.appendComment = function (token) {
        var comment = this.document.createComment(token.chars);
        this.appendChild(comment);
    };
    HTMLParser.prototype.appendChild = function (node) {
        var parentNode = this.parentStack[this.parentStack.length - 1];
        parentNode.appendChild(node);
    };
    HTMLParser.prototype.parse = function (html) {
        var fragment = this.document.createDocumentFragment();
        this.parentStack.push(fragment);
        var tokens = this.tokenize(html);
        for (var i = 0, l = tokens.length; i < l; i++) {
            var token = tokens[i];
            switch (token.type) {
            case 'StartTag':
                this.pushElement(token);
                break;
            case 'EndTag':
                this.popElement(token);
                break;
            case 'Chars':
                this.appendText(token);
                break;
            case 'Comment':
                this.appendComment(token);
                break;
            }
        }
        return this.parentStack.pop();
    };
    var $__default = HTMLParser;
    return {
        get default() {
            return $__default;
        },
        __esModule: true
    };
});
/*can-simple-dom@0.4.8#simple-dom/html-serializer*/
define('can-simple-dom@0.4.8#simple-dom/html-serializer', [], function () {
    'use strict';
    function HTMLSerializer(voidMap) {
        this.voidMap = voidMap;
    }
    HTMLSerializer.prototype.openTag = function (element) {
        return '<' + element.nodeName.toLowerCase() + this.attributes(element.attributes) + '>';
    };
    HTMLSerializer.prototype.closeTag = function (element) {
        return '</' + element.nodeName.toLowerCase() + '>';
    };
    HTMLSerializer.prototype.isVoid = function (element) {
        return this.voidMap[element.nodeName] === true;
    };
    HTMLSerializer.prototype.attributes = function (namedNodeMap) {
        var buffer = '';
        for (var i = 0, l = namedNodeMap.length; i < l; i++) {
            buffer += this.attr(namedNodeMap[i]);
        }
        return buffer;
    };
    HTMLSerializer.prototype.escapeAttrValue = function (attrValue) {
        return attrValue.replace(/[&"]/g, function (match) {
            switch (match) {
            case '&':
                return '&amp;';
            case '"':
                return '&quot;';
            }
        });
    };
    HTMLSerializer.prototype.attr = function (attr) {
        if (!attr.specified) {
            return '';
        }
        if (attr.value) {
            return ' ' + attr.name + '="' + this.escapeAttrValue(attr.value) + '"';
        }
        return ' ' + attr.name;
    };
    HTMLSerializer.prototype.escapeText = function (textNodeValue) {
        return textNodeValue.replace(/[&<>]/g, function (match) {
            switch (match) {
            case '&':
                return '&amp;';
            case '<':
                return '&lt;';
            case '>':
                return '&gt;';
            }
        });
    };
    HTMLSerializer.prototype.text = function (text) {
        var parentNode = text.parentNode;
        if (parentNode && (parentNode.nodeName === 'STYLE' || parentNode.nodeName === 'SCRIPT')) {
            return text.nodeValue;
        }
        return this.escapeText(text.nodeValue);
    };
    HTMLSerializer.prototype.comment = function (comment) {
        return '<!--' + comment.nodeValue + '-->';
    };
    HTMLSerializer.prototype.serialize = function (node) {
        var buffer = '';
        var next;
        switch (node.nodeType) {
        case 1:
            buffer += this.openTag(node);
            break;
        case 3:
            buffer += this.text(node);
            break;
        case 8:
            buffer += this.comment(node);
            break;
        default:
            break;
        }
        next = node.firstChild;
        if (next) {
            while (next) {
                buffer += this.serialize(next);
                next = next.nextSibling;
            }
        } else if (node.nodeType === 1 && node.textContent) {
            buffer += node.textContent;
        }
        if (node.nodeType === 1 && !this.isVoid(node)) {
            buffer += this.closeTag(node);
        }
        return buffer;
    };
    var $__default = HTMLSerializer;
    return {
        get default() {
            return $__default;
        },
        __esModule: true
    };
});
/*can-simple-dom@0.4.8#simple-dom/void-map*/
define('can-simple-dom@0.4.8#simple-dom/void-map', [], function () {
    'use strict';
    var $__default = {
        AREA: true,
        BASE: true,
        BR: true,
        COL: true,
        COMMAND: true,
        EMBED: true,
        HR: true,
        IMG: true,
        INPUT: true,
        KEYGEN: true,
        LINK: true,
        META: true,
        PARAM: true,
        SOURCE: true,
        TRACK: true,
        WBR: true
    };
    return {
        get default() {
            return $__default;
        },
        __esModule: true
    };
});
/*can-simple-dom@0.4.8#simple-dom/dom*/
define('can-simple-dom@0.4.8#simple-dom/dom', [
    './document/node',
    './document/element',
    './document',
    './event',
    './html-parser',
    './html-serializer',
    './void-map'
], function ($__0, $__2, $__4, $__6, $__8, $__10, $__12) {
    'use strict';
    if (!$__0 || !$__0.__esModule)
        $__0 = { default: $__0 };
    if (!$__2 || !$__2.__esModule)
        $__2 = { default: $__2 };
    if (!$__4 || !$__4.__esModule)
        $__4 = { default: $__4 };
    if (!$__6 || !$__6.__esModule)
        $__6 = { default: $__6 };
    if (!$__8 || !$__8.__esModule)
        $__8 = { default: $__8 };
    if (!$__10 || !$__10.__esModule)
        $__10 = { default: $__10 };
    if (!$__12 || !$__12.__esModule)
        $__12 = { default: $__12 };
    var Node = $__0.default;
    var Element = $__2.default;
    var Document = $__4.default;
    var Event = $__6.default;
    var HTMLParser = $__8.default;
    var HTMLSerializer = $__10.default;
    var voidMap = $__12.default;
    function createDocument(serializer, parser) {
        var doc = new Document();
        doc.__serializer = serializer;
        doc.__parser = parser;
        return doc;
    }
    return {
        get Node() {
            return Node;
        },
        get Element() {
            return Element;
        },
        get Document() {
            return Document;
        },
        get Event() {
            return Event;
        },
        get HTMLParser() {
            return HTMLParser;
        },
        get HTMLSerializer() {
            return HTMLSerializer;
        },
        get voidMap() {
            return voidMap;
        },
        get createDocument() {
            return createDocument;
        },
        __esModule: true
    };
});
/*can-simple-dom@0.4.8#simple-dom*/
define('can-simple-dom@0.4.8#simple-dom', [
    './simple-dom/dom',
    './simple-dom/dom'
], function ($__0, $__1) {
    'use strict';
    if (!$__0 || !$__0.__esModule)
        $__0 = { default: $__0 };
    if (!$__1 || !$__1.__esModule)
        $__1 = { default: $__1 };
    var SimpleDOM = $__0;
    if (typeof window !== 'undefined') {
        window.SimpleDOM = SimpleDOM;
    }
    var $__simple_45_dom_47_dom__ = $__1;
    return $traceurRuntime.exportStar({ __esModule: true }, $__simple_45_dom_47_dom__);
});
/*can-vdom@3.0.2#make-parser/make-parser*/
define('can-vdom@3.0.2#make-parser/make-parser', function (require, exports, module) {
    var canParser = require('can-view-parser');
    var simpleDOM = require('can-simple-dom');
    module.exports = function (document) {
        return new simpleDOM.HTMLParser(function (string) {
            var tokens = [];
            var currentTag, currentAttr;
            canParser(string, {
                start: function (tagName, unary) {
                    currentTag = {
                        type: 'StartTag',
                        attributes: [],
                        tagName: tagName
                    };
                },
                end: function (tagName, unary) {
                    tokens.push(currentTag);
                    currentTag = undefined;
                },
                close: function (tagName) {
                    tokens.push({
                        type: 'EndTag',
                        tagName: tagName
                    });
                },
                attrStart: function (attrName) {
                    currentAttr = [
                        attrName,
                        ''
                    ];
                    currentTag.attributes.push(currentAttr);
                },
                attrEnd: function (attrName) {
                },
                attrValue: function (value) {
                    currentAttr[1] += value;
                },
                chars: function (value) {
                    tokens.push({
                        type: 'Chars',
                        chars: value
                    });
                },
                comment: function (value) {
                    tokens.push({
                        type: 'Comment',
                        chars: value
                    });
                },
                special: function (value) {
                },
                done: function () {
                }
            });
            return tokens;
        }, document, simpleDOM.voidMap);
    };
});
/*can-vdom@3.0.2#make-document/make-document*/
define('can-vdom@3.0.2#make-document/make-document', function (require, exports, module) {
    var simpleDOM = require('can-simple-dom');
    var makeParser = require('../make-parser/make-parser');
    function CanSimpleDocument() {
        simpleDOM.Document.apply(this, arguments);
        var serializer = new simpleDOM.HTMLSerializer(simpleDOM.voidMap);
        var parser = makeParser(this);
        this.__addSerializerAndParser(serializer, parser);
    }
    CanSimpleDocument.prototype = new simpleDOM.Document();
    CanSimpleDocument.prototype.constructor = CanSimpleDocument;
    module.exports = function () {
        return new CanSimpleDocument();
    };
});
/*can-component@3.0.6#test/component-map-test*/
define('can-component@3.0.6#test/component-map-test', function (require, exports, module) {
    (function (global) {
        require('./component-define-test');
        var Component = require('can-component');
        var stache = require('can-stache');
        var QUnit = require('steal-qunit');
        var Construct = require('can-construct');
        var canCompute = require('can-compute');
        var CanMap = require('can-map');
        var CanList = require('can-list');
        var canEvent = require('can-event');
        var canViewModel = require('can-view-model');
        var canBatch = require('can-event/batch/batch');
        var attr = require('can-util/dom/attr/attr');
        var className = require('can-util/dom/class-name/class-name');
        var domMutate = require('can-util/dom/mutate/mutate');
        var domData = require('can-util/dom/data/data');
        var types = require('can-types');
        var isPromise = require('can-util/js/is-promise/is-promise');
        var makeDocument = require('can-vdom/make-document/make-document');
        var MUTATION_OBSERVER = require('can-util/dom/mutation-observer/mutation-observer');
        var DOCUMENT = require('can-util/dom/document/document');
        var getFragment = require('can-util/dom/fragment/fragment');
        var Scope = require('can-view-scope');
        var viewCallbacks = require('can-view-callbacks');
        var canLog = require('can-util/js/log/log');
        var DOC = DOCUMENT();
        var MUT_OBS = MUTATION_OBSERVER();
        makeTest('can-component - map - dom', document, MUT_OBS);
        makeTest('can-component - map - vdom', makeDocument(), null);
        var innerHTML = function (node) {
            if (node && 'innerHTML' in node) {
                return node.innerHTML;
            }
        };
        var runTasks = function (tasks) {
            var nextTask = function () {
                var next = tasks.shift();
                next();
                if (tasks.length) {
                    setTimeout(nextTask, 100);
                } else {
                    start();
                }
            };
            setTimeout(nextTask, 100);
        };
        function makeTest(name, doc, mutObs) {
            var oldDoc, oldDefaultMap;
            QUnit.module(name, {
                setup: function () {
                    DOCUMENT(doc);
                    MUTATION_OBSERVER(mutObs);
                    oldDefaultMap = types.DefaultMap;
                    types.DefaultMap = CanMap;
                    if (doc) {
                        this.fixture = doc.createElement('div');
                        doc.body.appendChild(this.fixture);
                    } else {
                        this.fixture = doc.getElementById('qunit-fixture');
                    }
                },
                teardown: function () {
                    doc.body.removeChild(this.fixture);
                    stop();
                    setTimeout(function () {
                        types.DefaultMap = oldDefaultMap;
                        start();
                        DOCUMENT(DOC);
                        MUTATION_OBSERVER(MUT_OBS);
                    }, 100);
                }
            });
            var Paginate = CanMap.extend({
                count: Infinity,
                offset: 0,
                limit: 100,
                setCount: function (newCount, success, error) {
                    return newCount < 0 ? 0 : newCount;
                },
                setOffset: function (newOffset) {
                    return newOffset < 0 ? 0 : Math.min(newOffset, !isNaN(this.count - 1) ? this.count - 1 : Infinity);
                },
                next: function () {
                    this.attr('offset', this.offset + this.limit);
                },
                prev: function () {
                    this.attr('offset', this.offset - this.limit);
                },
                canNext: function () {
                    return this.attr('offset') < this.attr('count') - this.attr('limit');
                },
                canPrev: function () {
                    return this.attr('offset') > 0;
                },
                page: function (newVal) {
                    if (newVal === undefined) {
                        return Math.floor(this.attr('offset') / this.attr('limit')) + 1;
                    } else {
                        this.attr('offset', (parseInt(newVal) - 1) * this.attr('limit'));
                    }
                },
                pageCount: function () {
                    return this.attr('count') ? Math.ceil(this.attr('count') / this.attr('limit')) : null;
                }
            });
            test('lexical scoping', function () {
                Component.extend({
                    tag: 'hello-world',
                    template: stache('{{greeting}} <content>World</content>{{exclamation}}'),
                    viewModel: { greeting: 'Hello' }
                });
                var template = stache('<hello-world>{{greeting}}</hello-world>');
                var frag = template({
                    greeting: 'World',
                    exclamation: '!'
                });
                var hello = frag.firstChild;
                equal(innerHTML(hello).trim(), 'Hello World');
                Component.extend({
                    tag: 'hello-world-no-template',
                    leakScope: false,
                    viewModel: { greeting: 'Hello' }
                });
                template = stache('<hello-world-no-template>{{greeting}}</hello-world-no-template>');
                frag = template({
                    greeting: 'World',
                    exclamation: '!'
                });
                hello = frag.firstChild;
                equal(innerHTML(hello).trim(), 'Hello', 'If no template is provided to Component, treat <content> bindings as dynamic.');
            });
            test('dynamic scoping', function () {
                Component.extend({
                    tag: 'hello-world',
                    leakScope: true,
                    template: stache('{{greeting}} <content>World</content>{{exclamation}}'),
                    viewModel: { greeting: 'Hello' }
                });
                var template = stache('<hello-world>{{greeting}}</hello-world>');
                var frag = template({
                    greeting: 'World',
                    exclamation: '!'
                });
                var hello = frag.firstChild;
                equal(innerHTML(hello).trim(), 'Hello Hello!');
            });
            test('treecombo', function () {
                var TreeComboViewModel = CanMap.extend({
                    items: [],
                    breadcrumb: [],
                    selected: [],
                    selectableItems: function () {
                        var breadcrumb = this.attr('breadcrumb');
                        if (breadcrumb.attr('length')) {
                            return breadcrumb.attr('' + (breadcrumb.length - 1) + '.children');
                        } else {
                            return this.attr('items');
                        }
                    },
                    showChildren: function (item, el, ev) {
                        ev.stopPropagation();
                        this.attr('breadcrumb').push(item);
                    },
                    emptyBreadcrumb: function () {
                        this.attr('breadcrumb').attr([], true);
                    },
                    updateBreadcrumb: function (item) {
                        var breadcrumb = this.attr('breadcrumb'), index = breadcrumb.indexOf(item);
                        breadcrumb.splice(index + 1, breadcrumb.length - index - 1);
                    },
                    toggle: function (item) {
                        var selected = this.attr('selected'), index = selected.indexOf(item);
                        if (index === -1) {
                            selected.push(item);
                        } else {
                            selected.splice(index, 1);
                        }
                    },
                    isSelected: function (item) {
                        return this.attr('selected').indexOf(item) > -1;
                    }
                });
                Component.extend({
                    tag: 'treecombo',
                    template: stache('<ul class=\'breadcrumb\'>' + '<li can-click=\'emptyBreadcrumb\'>{{title}}</li>' + '{{#each breadcrumb}}' + '<li can-click=\'updateBreadcrumb\'>{{title}}</li>' + '{{/each}}' + '</ul>' + '<ul class=\'options\'>' + '<content>' + '{{#selectableItems}}' + '<li {{#isSelected(.)}}class=\'active\'{{/isSelected}} can-click=\'toggle\'>' + '<input type=\'checkbox\' {{#isSelected(.)}}checked{{/isSelected}}/>' + '{{title}}' + '{{#if children.length}}' + '<button class=\'showChildren\' can-click=\'showChildren\'>+</button>' + '{{/if}}' + '</li>' + '{{/selectableItems}}' + '</content>' + '</ul>'),
                    ViewModel: TreeComboViewModel
                });
                var template = stache('<treecombo {(items)}=\'locations\' title=\'Locations\'></treecombo>');
                var base = new CanMap({});
                var frag = template(base);
                var root = doc.createElement('div');
                root.appendChild(frag);
                var items = [
                    {
                        id: 1,
                        title: 'Midwest',
                        children: [
                            {
                                id: 5,
                                title: 'Illinois',
                                children: [
                                    {
                                        id: 23423,
                                        title: 'Chicago'
                                    },
                                    {
                                        id: 4563,
                                        title: 'Springfield'
                                    },
                                    {
                                        id: 4564,
                                        title: 'Naperville'
                                    }
                                ]
                            },
                            {
                                id: 6,
                                title: 'Wisconsin',
                                children: [
                                    {
                                        id: 232423,
                                        title: 'Milwaulkee'
                                    },
                                    {
                                        id: 45463,
                                        title: 'Green Bay'
                                    },
                                    {
                                        id: 45464,
                                        title: 'Madison'
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        id: 2,
                        title: 'East Coast',
                        children: [
                            {
                                id: 25,
                                title: 'New York',
                                children: [
                                    {
                                        id: 3413,
                                        title: 'New York'
                                    },
                                    {
                                        id: 4613,
                                        title: 'Rochester'
                                    },
                                    {
                                        id: 4516,
                                        title: 'Syracuse'
                                    }
                                ]
                            },
                            {
                                id: 6,
                                title: 'Pennsylvania',
                                children: [
                                    {
                                        id: 2362423,
                                        title: 'Philadelphia'
                                    },
                                    {
                                        id: 454663,
                                        title: 'Harrisburg'
                                    },
                                    {
                                        id: 454664,
                                        title: 'Scranton'
                                    }
                                ]
                            }
                        ]
                    }
                ];
                stop();
                setTimeout(function () {
                    base.attr('locations', items);
                    var itemsList = base.attr('locations');
                    var treecombo = root.firstChild, breadcrumb = treecombo.firstChild, breadcrumbLIs = function () {
                            return breadcrumb.getElementsByTagName('li');
                        }, options = treecombo.lastChild, optionsLis = function () {
                            return options.getElementsByTagName('li');
                        };
                    equal(breadcrumbLIs().length, 1, 'Only the default title is shown');
                    equal(innerHTML(breadcrumbLIs()[0]), 'Locations', 'The correct title from the attribute is shown');
                    equal(itemsList.length, optionsLis().length, 'first level items are displayed');
                    canEvent.trigger.call(optionsLis()[0], 'click');
                    equal(optionsLis()[0].className, 'active', 'toggling something not selected adds active');
                    ok(optionsLis()[0].getElementsByTagName('input')[0].checked, 'toggling something not selected checks checkbox');
                    equal(canViewModel(treecombo, 'selected').length, 1, 'there is one selected item');
                    equal(canViewModel(treecombo, 'selected.0'), itemsList.attr('0'), 'the midwest is in selected');
                    canViewModel(treecombo, 'selected').pop();
                    equal(optionsLis()[0].className, '', 'toggling something not selected adds active');
                    canEvent.trigger.call(optionsLis()[0].getElementsByTagName('button')[0], 'click');
                    equal(breadcrumbLIs().length, 2, 'Only the default title is shown');
                    equal(innerHTML(breadcrumbLIs()[1]), 'Midwest', 'The breadcrumb has an item in it');
                    ok(/Illinois/.test(innerHTML(optionsLis()[0])), 'A child of the top breadcrumb is displayed');
                    canEvent.trigger.call(optionsLis()[0].getElementsByTagName('button')[0], 'click');
                    ok(/Chicago/.test(innerHTML(optionsLis()[0])), 'A child of the top breadcrumb is displayed');
                    ok(!optionsLis()[0].getElementsByTagName('button').length, 'no show children button');
                    canEvent.trigger.call(breadcrumbLIs()[1], 'click');
                    equal(innerHTML(breadcrumbLIs()[1]), 'Midwest', 'The breadcrumb has an item in it');
                    ok(/Illinois/.test(innerHTML(optionsLis()[0])), 'A child of the top breadcrumb is displayed');
                    canEvent.trigger.call(breadcrumbLIs()[0], 'click');
                    equal(breadcrumbLIs().length, 1, 'Only the default title is shown');
                    equal(innerHTML(breadcrumbLIs()[0]), 'Locations', 'The correct title from the attribute is shown');
                    start();
                }, 100);
            });
            test('deferred grid', function () {
                var GridViewModel = CanMap.extend({
                    items: [],
                    waiting: true
                });
                Component.extend({
                    tag: 'grid',
                    ViewModel: GridViewModel,
                    template: stache('<table><tbody><content></content></tbody></table>'),
                    leakScope: true,
                    events: {
                        init: function () {
                            this.update();
                        },
                        '{viewModel} deferreddata': 'update',
                        update: function () {
                            var deferred = this.viewModel.attr('deferreddata'), viewModel = this.viewModel;
                            if (isPromise(deferred)) {
                                this.viewModel.attr('waiting', true);
                                deferred.then(function (items) {
                                    viewModel.attr('items').attr(items, true);
                                });
                            } else {
                                viewModel.attr('items').attr(deferred, true);
                            }
                        },
                        '{items} change': function () {
                            this.viewModel.attr('waiting', false);
                        }
                    }
                });
                var SimulatedScope = CanMap.extend({
                    set: 0,
                    deferredData: function () {
                        var deferred = {};
                        var promise = new Promise(function (resolve, reject) {
                            deferred.resolve = resolve;
                            deferred.reject = reject;
                        });
                        var set = this.attr('set');
                        if (set === 0) {
                            setTimeout(function () {
                                deferred.resolve([{
                                        first: 'Justin',
                                        last: 'Meyer'
                                    }]);
                            }, 100);
                        } else if (set === 1) {
                            setTimeout(function () {
                                deferred.resolve([{
                                        first: 'Brian',
                                        last: 'Moschel'
                                    }]);
                            }, 100);
                        }
                        return promise;
                    }
                });
                var viewModel = new SimulatedScope();
                var template = stache('<grid {(deferreddata)}=\'viewModel.deferredData\'>' + '{{#each items}}' + '<tr>' + '<td width=\'40%\'>{{first}}</td>' + '<td width=\'70%\'>{{last}}</td>' + '</tr>' + '{{/each}}' + '</grid>');
                domMutate.appendChild.call(this.fixture, template({ viewModel: viewModel }));
                var gridScope = canViewModel(this.fixture.firstChild);
                equal(gridScope.attr('waiting'), true, 'The grid is initially waiting on the deferreddata to resolve');
                stop();
                var self = this;
                var waitingHandler = function () {
                    gridScope.unbind('waiting', waitingHandler);
                    setTimeout(function () {
                        var tds = self.fixture.getElementsByTagName('td');
                        equal(tds.length, 2, 'there are 2 tds');
                        gridScope.bind('waiting', function (ev, newVal) {
                            if (newVal === false) {
                                setTimeout(function () {
                                    equal(innerHTML(tds[0]), 'Brian', 'td changed to brian');
                                    start();
                                }, 100);
                            }
                        });
                        viewModel.attr('set', 1);
                    }, 100);
                };
                gridScope.bind('waiting', waitingHandler);
            });
            test('nextprev', function () {
                Component.extend({
                    tag: 'next-prev',
                    template: stache('<a href="javascript://"' + 'class="prev {{#paginate.canPrev}}enabled{{/paginate.canPrev}}" ($click)="paginate.prev()">Prev</a>' + '<a href="javascript://"' + 'class="next {{#paginate.canNext}}enabled{{/paginate.canNext}}" ($click)="paginate.next()">Next</a>')
                });
                var paginator = new Paginate({
                    limit: 20,
                    offset: 0,
                    count: 100
                });
                var template = stache('<next-prev {(paginate)}=\'paginator\'></next-prev>');
                var frag = template({ paginator: paginator });
                var nextPrev = frag.firstChild;
                var prev = nextPrev.firstChild, next = nextPrev.lastChild;
                ok(!/enabled/.test(prev.className), 'prev is not enabled');
                ok(/enabled/.test(next.className), 'next is  enabled');
                canEvent.trigger.call(next, 'click');
                ok(/enabled/.test(prev.className), 'prev is enabled');
            });
            test('page-count', function () {
                Component.extend({
                    tag: 'page-count',
                    template: stache('Page <span>{{page}}</span>.')
                });
                var paginator = new Paginate({
                    limit: 20,
                    offset: 0,
                    count: 100
                });
                var template = stache('<page-count {(page)}=\'paginator.page\'></page-count>');
                var frag = template(new CanMap({ paginator: paginator }));
                var span = frag.firstChild.getElementsByTagName('span')[0];
                equal(span.firstChild.nodeValue, '1');
                paginator.next();
                equal(span.firstChild.nodeValue, '2');
                paginator.next();
                equal(span.firstChild.nodeValue, '3');
            });
            test('hello-world and whitespace around custom elements', function () {
                Component.extend({
                    tag: 'hello-world',
                    template: stache('{{#if visible}}{{message}}{{else}}Click me{{/if}}'),
                    viewModel: {
                        visible: false,
                        message: 'Hello There!'
                    },
                    events: {
                        click: function () {
                            this.viewModel.attr('visible', true);
                        }
                    }
                });
                var template = stache('  <hello-world></hello-world>  ');
                var frag = template({});
                var helloWorld = frag.childNodes.item(1);
                canEvent.trigger.call(helloWorld, 'click');
                equal(innerHTML(helloWorld), 'Hello There!');
            });
            test('self closing content tags', function () {
                Component.extend({
                    'tag': 'my-greeting',
                    template: stache('<h1><content/></h1>'),
                    viewModel: { title: 'Component' }
                });
                var template = stache('<my-greeting><span>{{site}} - {{title}}</span></my-greeting>');
                var frag = template({ site: 'CanJS' });
                equal(frag.firstChild.getElementsByTagName('span').length, 1, 'there is an h1');
            });
            test('canViewModel utility', function () {
                Component({
                    tag: 'my-taggy-tag',
                    template: stache('<h1>hello</h1>'),
                    viewModel: { foo: 'bar' }
                });
                var frag = stache('<my-taggy-tag id=\'x\'></my-taggy-tag>')();
                var el = frag.firstChild;
                equal(canViewModel(el), domData.get.call(el, 'viewModel'), 'one argument grabs the viewModel object');
                equal(canViewModel(el, 'foo'), 'bar', 'two arguments fetches a value');
                canViewModel(el, 'foo', 'baz');
                equal(canViewModel(el, 'foo'), 'baz', 'Three arguments sets the value');
            });
            test('canViewModel creates one if it doesn\'t exist', function () {
                var frag = stache('<div id=\'me\'></div>')();
                var el = frag.firstChild;
                var viewModel = canViewModel(el);
                ok(!!viewModel, 'viewModel created where it didn\'t exist.');
                equal(viewModel, domData.get.call(el, 'viewModel'), 'viewModel is in the data.');
            });
            test('setting passed variables - two way binding', function () {
                Component.extend({
                    tag: 'my-toggler',
                    template: stache('{{#if visible}}<content/>{{/if}}'),
                    leakScope: true,
                    viewModel: {
                        visible: true,
                        show: function () {
                            this.attr('visible', true);
                        },
                        hide: function () {
                            this.attr('visible', false);
                        }
                    }
                });
                Component.extend({
                    tag: 'my-app',
                    viewModel: {
                        visible: true,
                        show: function () {
                            this.attr('visible', true);
                        }
                    }
                });
                var template = stache('<my-app>' + '{{^visible}}<button can-click="show">show</button>{{/visible}}' + '<my-toggler {(visible)}="visible">' + 'content' + '<button can-click="hide">hide</button>' + '</my-toggler>' + '</my-app>');
                var frag = template({});
                var myApp = frag.firstChild, buttons = myApp.getElementsByTagName('button');
                equal(buttons.length, 1, 'there is one button');
                equal(innerHTML(buttons[0]), 'hide', 'the button\'s text is hide');
                canEvent.trigger.call(buttons[0], 'click');
                buttons = myApp.getElementsByTagName('button');
                equal(buttons.length, 1, 'there is one button');
                equal(innerHTML(buttons[0]), 'show', 'the button\'s text is show');
                canEvent.trigger.call(buttons[0], 'click');
                buttons = myApp.getElementsByTagName('button');
                equal(buttons.length, 1, 'there is one button');
                equal(innerHTML(buttons[0]), 'hide', 'the button\'s text is hide');
            });
            test('helpers reference the correct instance (#515)', function () {
                expect(2);
                Component({
                    tag: 'my-text',
                    template: stache('<p>{{valueHelper}}</p>'),
                    helpers: {
                        valueHelper: function () {
                            return this.attr('value');
                        }
                    }
                });
                var template = stache('<my-text value="value1"></my-text><my-text value="value2"></my-text>');
                var frag = template({});
                equal(frag.firstChild.firstChild.firstChild.nodeValue, 'value1');
                equal(frag.lastChild.firstChild.firstChild.nodeValue, 'value2');
            });
            test('access hypenated attributes via camelCase or hypenated', function () {
                Component({
                    tag: 'hyphen',
                    template: stache('<p>{{valueHelper}}</p>'),
                    helpers: {
                        valueHelper: function () {
                            return this.attr('camelCase');
                        }
                    }
                });
                var template = stache('<hyphen camel-case="value1"></hyphen>');
                var frag = template({});
                equal(frag.firstChild.firstChild.firstChild.nodeValue, 'value1');
            });
            test('a map as viewModel', function () {
                var me = new CanMap({ name: 'Justin' });
                Component.extend({
                    tag: 'my-viewmodel',
                    template: stache('{{name}}}'),
                    viewModel: me
                });
                var template = stache('<my-viewmodel></my-viewmodel>');
                equal(template().firstChild.firstChild.nodeValue, 'Justin');
            });
            test('a CanMap constructor as viewModel', function () {
                var MyMap = CanMap.extend({ name: 'Matthew' });
                Component.extend({
                    tag: 'can-map-viewmodel',
                    template: stache('{{name}}'),
                    viewModel: MyMap
                });
                var template = stache('<can-map-viewmodel></can-map-viewmodel>');
                equal(template().firstChild.firstChild.nodeValue, 'Matthew');
            });
            test('a CanMap constructor as scope', function () {
                var MyMap = CanMap.extend({ name: 'Matthew' });
                Component.extend({
                    tag: 'can-map-viewmodel',
                    template: stache('{{name}}'),
                    scope: MyMap
                });
                var template = stache('<can-map-viewmodel></can-map-viewmodel>');
                equal(template().firstChild.firstChild.nodeValue, 'Matthew');
            });
            test('an object is turned into a CanMap as viewModel', function () {
                Component.extend({
                    tag: 'can-map-viewmodel',
                    template: stache('{{name}}'),
                    viewModel: { name: 'Matthew' }
                });
                var template = stache('<can-map-viewmodel></can-map-viewmodel>');
                var fragOne = template();
                var vmOne = canViewModel(fragOne.firstChild);
                var fragTwo = template();
                var vmTwo = canViewModel(fragTwo.firstChild);
                vmOne.attr('name', 'Wilbur');
                equal(fragOne.firstChild.firstChild.nodeValue, 'Wilbur', 'The first map changed values');
                equal(fragTwo.firstChild.firstChild.nodeValue, 'Matthew', 'The second map did not change');
            });
            test('Providing viewModel and ViewModel throws', function () {
                try {
                    Component.extend({
                        tag: 'viewmodel-test',
                        template: stache('<div></div>'),
                        viewModel: {},
                        ViewModel: CanMap.extend({})
                    });
                    ok(false, 'Should have thrown because we provided both');
                } catch (er) {
                    ok(true, 'It threw because we provided both viewModel and ViewModel');
                }
            });
            test('content in a list', function () {
                var template = stache('<my-list>{{name}}</my-list>');
                Component.extend({
                    tag: 'my-list',
                    template: stache('{{#each items}}<li><content/></li>{{/each}}'),
                    leakScope: true,
                    viewModel: {
                        items: new CanList([
                            { name: 'one' },
                            { name: 'two' }
                        ])
                    }
                });
                var lis = template().firstChild.getElementsByTagName('li');
                equal(innerHTML(lis[0]), 'one', 'first li has correct content');
                equal(innerHTML(lis[1]), 'two', 'second li has correct content');
            });
            test('don\'t update computes unnecessarily', function () {
                var sourceAge = 30, timesComputeIsCalled = 0;
                var age = canCompute(function (newVal) {
                    timesComputeIsCalled++;
                    if (timesComputeIsCalled === 1) {
                        ok(true, 'reading initial value to set as years');
                    } else if (timesComputeIsCalled === 2) {
                        equal(newVal, 31, 'updating value to 31');
                    } else if (timesComputeIsCalled === 3) {
                        ok(true, 'called back another time after set to get the value');
                    } else {
                        ok(false, 'You\'ve called the callback ' + timesComputeIsCalled + ' times');
                    }
                    if (arguments.length) {
                        sourceAge = newVal;
                    } else {
                        return sourceAge;
                    }
                });
                Component.extend({ tag: 'age-er' });
                var template = stache('<age-er {(years)}=\'age\'></age-er>');
                template({ age: age });
                age(31);
            });
            test('component does not respect canCompute passed via attributes (#540)', function () {
                var data = { compute: canCompute(30) };
                Component.extend({
                    tag: 'my-component',
                    template: stache('<span>{{blocks}}</span>')
                });
                var template = stache('<my-component {(blocks)}=\'compute\'></my-component>');
                var frag = template(data);
                equal(innerHTML(frag.firstChild.firstChild), '30');
            });
            test('defined view models (#563)', function () {
                var HelloWorldModel = CanMap.extend({
                    visible: true,
                    toggle: function () {
                        this.attr('visible', !this.attr('visible'));
                    }
                });
                Component.extend({
                    tag: 'my-helloworld',
                    template: stache('<h1>{{#if visible}}visible{{else}}invisible{{/if}}</h1>'),
                    ViewModel: HelloWorldModel
                });
                var template = stache('<my-helloworld></my-helloworld>');
                var frag = template({});
                equal(innerHTML(frag.firstChild.firstChild), 'visible');
            });
            test('viewModel not rebound correctly (#550)', function () {
                var nameChanges = 0;
                Component.extend({
                    tag: 'viewmodel-rebinder',
                    events: {
                        '{name} change': function () {
                            nameChanges++;
                        }
                    }
                });
                var template = stache('<viewmodel-rebinder></viewmodel-rebinder>');
                var frag = template();
                var viewModel = canViewModel(frag.firstChild);
                var n1 = canCompute(), n2 = canCompute();
                viewModel.attr('name', n1);
                n1('updated');
                viewModel.attr('name', n2);
                n2('updated');
                equal(nameChanges, 2);
            });
            test('content extension stack overflow error', function () {
                Component({
                    tag: 'outer-tag',
                    template: stache('<inner-tag>inner-tag CONTENT <content/></inner-tag>')
                });
                Component({
                    tag: 'inner-tag',
                    template: stache('inner-tag TEMPLATE <content/>')
                });
                var template = stache('<outer-tag>outer-tag CONTENT</outer-tag>');
                var frag = template();
                equal(innerHTML(frag.firstChild.firstChild), 'inner-tag TEMPLATE inner-tag CONTENT outer-tag CONTENT');
            });
            test('inserted event fires twice if component inside live binding block', function () {
                var inited = 0, inserted = 0;
                Component.extend({
                    tag: 'child-tag',
                    ViewModel: CanMap.extend({
                        init: function () {
                            inited++;
                        }
                    }),
                    events: {
                        ' inserted': function () {
                            inserted++;
                        }
                    }
                });
                Component.extend({
                    tag: 'parent-tag',
                    template: stache('{{#shown}}<child-tag></child-tag>{{/shown}}'),
                    viewModel: { shown: false },
                    events: {
                        ' inserted': function () {
                            this.viewModel.attr('shown', true);
                        }
                    }
                });
                var frag = stache('<parent-tag id=\'pt\'></parent-tag>')({});
                domMutate.appendChild.call(this.fixture, frag);
                stop();
                setTimeout(function () {
                    equal(inited, 1, 'inited');
                    equal(inserted, 1, 'inserted');
                    start();
                }, 100);
            });
            test('@ keeps properties live now', function () {
                Component.extend({
                    tag: 'attr-fun',
                    template: stache('<h1>{{fullName}}</h1>'),
                    ViewModel: CanMap.extend({
                        fullName: function () {
                            return this.attr('firstName') + ' ' + this.attr('lastName');
                        }
                    })
                });
                var frag = stache('<attr-fun first-name=\'Justin\' last-name=\'Meyer\'></attr-fun>')();
                var attrFun = frag.firstChild;
                this.fixture.appendChild(attrFun);
                equal(innerHTML(attrFun.firstChild), 'Justin Meyer');
                attr.set(attrFun, 'first-name', 'Brian');
                stop();
                setTimeout(function () {
                    equal(attrFun.firstChild.firstChild.nodeValue, 'Brian Meyer');
                    start();
                }, 100);
            });
            test('id and class should work now (#694)', function () {
                Component.extend({
                    tag: 'stay-classy',
                    ViewModel: CanMap.extend({
                        notid: 'foo',
                        notclass: 5,
                        notdataviewid: {}
                    })
                });
                var data = {
                    idData: 'id-success',
                    classData: 'class-success'
                };
                var frag = stache('<stay-classy {(id)}=\'idData\'' + ' {(class)}=\'classData\'></stay-classy>')(data);
                var stayClassy = frag.firstChild;
                domMutate.appendChild.call(this.fixture, frag);
                var viewModel = canViewModel(stayClassy);
                equal(viewModel.attr('id'), 'id-success');
                equal(viewModel.attr('class'), 'class-success');
            });
            test('Component can-click method should be not called while component\'s init', function () {
                var called = false;
                Component.extend({ tag: 'child-tag' });
                Component.extend({
                    tag: 'parent-tag',
                    template: stache('<child-tag can-click="method"></child-tag>'),
                    viewModel: {
                        method: function () {
                            called = true;
                        }
                    }
                });
                stache('<parent-tag></parent-tag>')();
                equal(called, false);
            });
            test('Same component tag nested', function () {
                Component({
                    'tag': 'my-tag',
                    template: stache('<p><content/></p>')
                });
                var template = stache('<div><my-tag>Outter<my-tag>Inner</my-tag></my-tag></div>');
                var template2 = stache('<div><my-tag>3<my-tag>2<my-tag>1<my-tag>0</my-tag></my-tag></my-tag></my-tag></div>');
                var template3 = stache('<div><my-tag>First</my-tag><my-tag>Second</my-tag></div>');
                equal(template({}).firstChild.getElementsByTagName('p').length, 2, 'proper number of p tags');
                equal(template2({}).firstChild.getElementsByTagName('p').length, 4, 'proper number of p tags');
                equal(template3({}).firstChild.getElementsByTagName('p').length, 2, 'proper number of p tags');
            });
            test('Component events bind to window', function () {
                window.tempMap = new CanMap();
                Component.extend({
                    tag: 'window-events',
                    events: {
                        '{tempMap} prop': function () {
                            ok(true, 'called templated event');
                        }
                    }
                });
                var template = stache('<window-events></window-events>');
                template();
                window.tempMap.attr('prop', 'value');
                window.tempMap = undefined;
                try {
                    delete window.tempMap;
                } catch (e) {
                }
            });
            test('Construct are passed normally', function () {
                var Constructed = Construct.extend({ foo: 'bar' }, {});
                Component.extend({
                    tag: 'con-struct',
                    template: stache('{{con.foo}}')
                });
                var stached = stache('<con-struct {(con)}=\'Constructed\'></con-struct>');
                var res = stached({ Constructed: Constructed });
                equal(innerHTML(res.firstChild), 'bar');
            });
            test('passing id works now', function () {
                Component.extend({
                    tag: 'my-thing',
                    template: stache('hello')
                });
                var template = stache('<my-thing {(id)}=\'productId\'></my-tagged>');
                var frag = template(new CanMap({ productId: 123 }));
                equal(canViewModel(frag.firstChild).attr('id'), 123);
            });
            test('stache conditionally nested components calls inserted once (#967)', function () {
                expect(1);
                Component.extend({
                    tag: 'can-parent-stache',
                    viewModel: { shown: true },
                    template: stache('{{#if shown}}<can-child></can-child>{{/if}}')
                });
                Component.extend({
                    tag: 'can-child',
                    events: {
                        inserted: function () {
                            ok(true, 'called inserted once');
                        }
                    }
                });
                var template = stache('<can-parent-stache></can-parent-stache>');
                domMutate.appendChild.call(this.fixture, template());
                stop();
                setTimeout(start, 100);
            });
            test('hyphen-less tag names', function () {
                Component.extend({
                    tag: 'foobar',
                    template: stache('<div>{{name}}</div>'),
                    viewModel: { name: 'Brian' }
                });
                var template = stache('<span></span><foobar></foobar>');
                var frag = template();
                equal(frag.lastChild.firstChild.firstChild.nodeValue, 'Brian');
            });
            test('nested component within an #if is not live bound(#1025)', function () {
                Component.extend({
                    tag: 'parent-component',
                    template: stache('{{#if shown}}<child-component></child-component>{{/if}}'),
                    viewModel: { shown: false }
                });
                Component.extend({
                    tag: 'child-component',
                    template: stache('Hello world.')
                });
                var template = stache('<parent-component></parent-component>');
                var frag = template({});
                equal(innerHTML(frag.firstChild), '', 'child component is not inserted');
                canViewModel(frag.firstChild).attr('shown', true);
                equal(innerHTML(frag.firstChild.firstChild), 'Hello world.', 'child component is inserted');
                canViewModel(frag.firstChild).attr('shown', false);
                equal(innerHTML(frag.firstChild), '', 'child component is removed');
            });
            test('component does not update viewModel on id, class, and data-view-id attribute changes (#1079)', function () {
                Component.extend({ tag: 'x-app' });
                var frag = stache('<x-app></x-app>')({});
                var el = frag.firstChild;
                var viewModel = canViewModel(el);
                domMutate.appendChild.call(this.fixture, frag);
                className.add.call(el, 'foo');
                stop();
                setTimeout(function () {
                    equal(viewModel.attr('class'), undefined, 'the viewModel is not updated when the class attribute changes');
                    start();
                }, 100);
            });
            test('viewModel objects with Constructor functions as properties do not get converted (#1261)', 1, function () {
                stop();
                var Test = CanMap.extend({ test: 'Yeah' });
                Component.extend({
                    tag: 'my-app',
                    viewModel: { MyConstruct: Test },
                    events: {
                        '{MyConstruct} something': function () {
                            ok(true, 'Event got triggered');
                            start();
                        }
                    }
                });
                var frag = stache('<my-app></my-app>')();
                domMutate.appendChild.call(this.fixture, frag);
                canEvent.trigger.call(Test, 'something');
            });
            test('removing bound viewModel properties on destroy #1415', function () {
                var state = new CanMap({
                    product: {
                        id: 1,
                        name: 'Tom'
                    }
                });
                Component.extend({
                    tag: 'destroyable-component',
                    events: {
                        destroy: function () {
                            this.viewModel.attr('product', null);
                        }
                    }
                });
                var frag = stache('<destroyable-component {(product)}="product"></destroyable-component>')(state);
                domMutate.appendChild.call(this.fixture, frag);
                domMutate.removeChild.call(this.fixture, this.fixture.firstChild);
                stop();
                setTimeout(function () {
                    ok(state.attr('product') == null, 'product was removed');
                    start();
                }, 100);
            });
            test('changing viewModel property rebinds {viewModel.<...>} events (#1529)', 2, function () {
                Component.extend({
                    tag: 'rebind-viewmodel',
                    events: {
                        init: function () {
                            this.viewModel.attr('item', {});
                        },
                        '{scope.item} change': function () {
                            ok(true, 'Change event on scope');
                        },
                        '{viewModel.item} change': function () {
                            ok(true, 'Change event on viewModel');
                        }
                    }
                });
                var frag = stache('<rebind-viewmodel></rebind-viewmodel>')();
                var rebind = frag.firstChild;
                domMutate.appendChild.call(this.fixture, rebind);
                canViewModel(rebind).attr('item.name', 'CDN');
            });
            test('Component two way binding loop (#1579)', function () {
                var changeCount = 0;
                Component.extend({
                    tag: 'product-swatch-color',
                    viewModel: { tag: 'product-swatch-color' }
                });
                Component.extend({
                    tag: 'product-swatch',
                    template: stache('<product-swatch-color {(variations)}="variations"></product-swatch-color>'),
                    ViewModel: CanMap.extend({
                        tag: 'product-swatch',
                        define: {
                            variations: {
                                set: function (variations) {
                                    if (changeCount > 500) {
                                        return;
                                    }
                                    changeCount++;
                                    return new CanList(variations.attr());
                                }
                            }
                        }
                    })
                });
                var frag = stache('<product-swatch></product-swatch>')(), productSwatch = frag.firstChild;
                canBatch.start();
                canViewModel(productSwatch).attr('variations', new CanList());
                canBatch.stop();
                ok(changeCount < 500, 'more than 500 events');
            });
            test('references scopes are available to bindings nested in components (#2029)', function () {
                var template = stache('<export-er {^value}="*reference" />' + '<wrap-er><simple-example {key}="*reference"/></wrap-er>');
                Component.extend({ tag: 'wrap-er' });
                Component.extend({
                    tag: 'export-er',
                    events: {
                        'init': function () {
                            var self = this.viewModel;
                            stop();
                            setTimeout(function () {
                                self.attr('value', 100);
                                var wrapper = frag.lastChild, simpleExample = wrapper.firstChild, textNode = simpleExample.firstChild;
                                equal(textNode.nodeValue, '100', 'updated value with reference');
                                start();
                            }, 100);
                        }
                    }
                });
                Component.extend({
                    tag: 'simple-example',
                    template: stache('{{key}}'),
                    viewModel: {}
                });
                var frag = template({});
            });
            test('two-way binding syntax PRIOR to v2.3 shall NOT let a child property initialize an undefined parent property (#2020)', function () {
                var renderer = stache('<pa-rent/>');
                Component.extend({
                    tag: 'pa-rent',
                    template: stache('<chi-ld child-prop="{parentProp}" />')
                });
                Component.extend({
                    tag: 'chi-ld',
                    viewModel: { childProp: 'bar' }
                });
                var frag = renderer({});
                var parentVM = canViewModel(frag.firstChild);
                var childVM = canViewModel(frag.firstChild.firstChild);
                equal(parentVM.attr('parentProp'), undefined, 'parentProp is undefined');
                equal(childVM.attr('childProp'), 'bar', 'childProp is bar');
                parentVM.attr('parentProp', 'foo');
                equal(parentVM.attr('parentProp'), 'foo', 'parentProp is foo');
                equal(childVM.attr('childProp'), 'foo', 'childProp is foo');
                childVM.attr('childProp', 'baz');
                equal(parentVM.attr('parentProp'), 'baz', 'parentProp is baz');
                equal(childVM.attr('childProp'), 'baz', 'childProp is baz');
            });
            test('two-way binding syntax INTRODUCED in v2.3 ALLOWS a child property to initialize an undefined parent property', function () {
                var renderer = stache('<pa-rent/>');
                Component.extend({
                    tag: 'pa-rent',
                    template: stache('<chi-ld {(child-prop)}="parentProp" />')
                });
                Component.extend({
                    tag: 'chi-ld',
                    viewModel: { childProp: 'bar' }
                });
                var frag = renderer({});
                var parentVM = canViewModel(frag.firstChild);
                var childVM = canViewModel(frag.firstChild.firstChild);
                equal(parentVM.attr('parentProp'), 'bar', 'parentProp is bar');
                equal(childVM.attr('childProp'), 'bar', 'childProp is bar');
                parentVM.attr('parentProp', 'foo');
                equal(parentVM.attr('parentProp'), 'foo', 'parentProp is foo');
                equal(childVM.attr('childProp'), 'foo', 'childProp is foo');
                childVM.attr('childProp', 'baz');
                equal(parentVM.attr('parentProp'), 'baz', 'parentProp is baz');
                equal(childVM.attr('childProp'), 'baz', 'childProp is baz');
            });
            test('conditional attributes (#2077)', function () {
                Component.extend({ tag: 'some-comp' });
                var template = stache('<some-comp ' + '{{#if preview}}{next}=\'nextPage\'{{/if}} ' + '{swap}=\'{{swapName}}\' ' + '{{#preview}}checked{{/preview}} ' + '></some-comp>');
                var map = new CanMap({
                    preview: true,
                    nextPage: 2,
                    swapName: 'preview'
                });
                var frag = template(map);
                var vm = canViewModel(frag.firstChild);
                var threads = [
                    function () {
                        equal(vm.attr('next'), 2, 'has binidng');
                        equal(vm.attr('swap'), true, 'swap - has binding');
                        equal(vm.attr('checked'), '', 'attr - has binding');
                        map.attr('preview', false);
                    },
                    function () {
                        equal(vm.attr('swap'), false, 'swap - updated binidng');
                        ok(vm.attr('checked') === null, 'attr - value set to null');
                        map.attr('nextPage', 3);
                        equal(vm.attr('next'), 2, 'not updating after binding is torn down');
                        map.attr('preview', true);
                    },
                    function () {
                        equal(vm.attr('next'), 3, 're-initialized with binding');
                        equal(vm.attr('swap'), true, 'swap - updated binidng');
                        equal(vm.attr('checked'), '', 'attr - has binding set again');
                        map.attr('swapName', 'nextPage');
                    },
                    function () {
                        equal(vm.attr('swap'), 3, 'swap - updated binding key');
                        map.attr('nextPage', 4);
                        equal(vm.attr('swap'), 4, 'swap - updated binding');
                    }
                ];
                stop();
                var index = 0;
                var next = function () {
                    if (index < threads.length) {
                        threads[index]();
                        index++;
                        setTimeout(next, 100);
                    } else {
                        start();
                    }
                };
                setTimeout(next, 100);
            });
            test('<content> (#2151)', function () {
                var mapInstance = new CanMap({
                    items: [
                        {
                            id: 1,
                            context: 'Item 1',
                            render: false
                        },
                        {
                            id: 2,
                            context: 'Item 2',
                            render: false
                        }
                    ]
                });
                Component.extend({
                    tag: 'list-items',
                    template: stache('<ul>' + '{{#items}}' + '{{#if render}}' + '<li><content /></li>' + '{{/if}}' + '{{/items}}' + '</ul>'),
                    viewModel: mapInstance,
                    leakScope: true
                });
                Component.extend({
                    tag: 'list-item',
                    template: stache('{{item.context}}')
                });
                var template = stache('<list-items><list-item item=\'{.}\'/></list-items>');
                var frag = template();
                canBatch.start();
                canViewModel(frag.firstChild).attr('items').each(function (item, index) {
                    item.attr('render', true);
                });
                canBatch.stop();
                var lis = frag.firstChild.getElementsByTagName('li');
                ok(innerHTML(lis[0]).indexOf('Item 1') >= 0, 'Item 1 written out');
                ok(innerHTML(lis[1]).indexOf('Item 2') >= 0, 'Item 2 written out');
            });
            test('one-way - child to parent - parent that does not leak scope, but has no template', function () {
                Component.extend({
                    tag: 'outer-noleak',
                    viewModel: { isOuter: true },
                    leakScope: false
                });
                Component.extend({
                    tag: 'my-child',
                    viewModel: { isChild: true },
                    leakScope: false
                });
                var template = stache('<outer-noleak><my-child {^.}=\'myChild\'/></outer-noleak>');
                var frag = template();
                var vm = canViewModel(frag.firstChild);
                ok(vm.attr('myChild') instanceof CanMap, 'got instance');
            });
            test('two-way - reference - with <content> tag', function () {
                Component.extend({
                    tag: 'other-export',
                    viewModel: { name: 'OTHER-EXPORT' }
                });
                Component.extend({
                    tag: 'ref-export',
                    view: stache('<other-export {(name)}="*otherExport"/><content>{{*otherExport}}</content>')
                });
                var t1 = stache('<ref-export></ref-export>');
                var f1 = t1();
                equal(canViewModel(f1.firstChild.firstChild).attr('name'), 'OTHER-EXPORT', 'viewModel set correctly');
                equal(f1.firstChild.lastChild.nodeValue, 'OTHER-EXPORT', 'content');
            });
            test('custom renderer can provide setupBindings', function () {
                DOCUMENT(document);
                var renderer = function (tmpl) {
                    var frag = getFragment(tmpl);
                    return function (scope, options) {
                        scope = scope || new Scope();
                        options = options || new Scope.Options({});
                        if (frag.firstChild.nodeName === 'CUSTOM-RENDERER') {
                            viewCallbacks.tagHandler(frag.firstChild, 'custom-renderer', {
                                scope: scope,
                                options: options,
                                templateType: 'my-renderer',
                                setupBindings: function (el, callback, data) {
                                    callback({ foo: 'qux' });
                                }
                            });
                        } else {
                            var tn = frag.firstChild.firstChild;
                            tn.nodeValue = scope.read('foo').value;
                        }
                        return frag;
                    };
                };
                Component.extend({
                    tag: 'custom-renderer',
                    template: renderer('<div>{{foo}}</div>'),
                    ViewModel: CanMap.extend({})
                });
                var template = renderer('<custom-renderer foo=\'bar\'></custom-renderer>');
                var frag = template();
                var tn = frag.firstChild.firstChild.firstChild;
                equal(tn.nodeValue, 'qux', 'was bound!');
            });
            if (System.env !== 'canjs-test') {
                test('basic tabs', function () {
                    var TabsViewModel = CanMap.extend({
                        init: function () {
                            this.attr('panels', []);
                        },
                        addPanel: function (panel) {
                            if (this.attr('panels').length === 0) {
                                this.makeActive(panel);
                            }
                            this.attr('panels').push(panel);
                        },
                        removePanel: function (panel) {
                            var panels = this.attr('panels');
                            canBatch.start();
                            var index = panels.indexOf(panel);
                            canLog.log(index);
                            panels.splice(index, 1);
                            if (panel === this.attr('active')) {
                                if (panels.length) {
                                    this.makeActive(panels[0]);
                                } else {
                                    this.removeAttr('active');
                                }
                            }
                            canBatch.stop();
                        },
                        makeActive: function (panel) {
                            this.attr('active', panel);
                            this.attr('panels').each(function (panel) {
                                panel.attr('active', false);
                            });
                            panel.attr('active', true);
                        },
                        isActive: function (panel) {
                            return this.attr('active') === panel;
                        }
                    });
                    Component.extend({
                        tag: 'tabs',
                        ViewModel: TabsViewModel,
                        template: stache('<ul>' + '{{#panels}}' + '<li {{#isActive(.)}}class=\'active\'{{/isActive}} can-click=\'makeActive\'>{{title}}</li>' + '{{/panels}}' + '</ul>' + '<content></content>')
                    });
                    Component.extend({
                        template: stache('{{#if active}}<content></content>{{/if}}'),
                        tag: 'panel',
                        ViewModel: CanMap.extend({ active: false }),
                        events: {
                            ' inserted': function () {
                                canViewModel(this.element.parentNode).addPanel(this.viewModel);
                            },
                            ' beforeremove': function () {
                                canLog.log('I AM BEING REMOVED');
                                canViewModel(this.element.parentNode).removePanel(this.viewModel);
                            }
                        }
                    });
                    var template = stache('<tabs>{{#each foodTypes}}<panel title=\'{{title}}\'>{{content}}</panel>{{/each}}</tabs>');
                    var foodTypes = new CanList([
                        {
                            title: 'Fruits',
                            content: 'oranges, apples'
                        },
                        {
                            title: 'Breads',
                            content: 'pasta, cereal'
                        },
                        {
                            title: 'Sweets',
                            content: 'ice cream, candy'
                        }
                    ]);
                    var frag = template({ foodTypes: foodTypes });
                    domMutate.appendChild.call(this.fixture, frag);
                    var testArea = this.fixture;
                    stop();
                    runTasks([
                        function () {
                            var lis = testArea.getElementsByTagName('li');
                            equal(lis.length, 3, 'three lis added');
                            foodTypes.each(function (type, i) {
                                equal(innerHTML(lis[i]), type.attr('title'), 'li ' + i + ' has the right content');
                            });
                            foodTypes.push({
                                title: 'Vegies',
                                content: 'carrots, kale'
                            });
                        },
                        function () {
                            var lis = testArea.getElementsByTagName('li');
                            equal(lis.length, 4, 'li added');
                            foodTypes.each(function (type, i) {
                                equal(innerHTML(lis[i]), type.attr('title'), 'li ' + i + ' has the right content');
                            });
                            equal(testArea.getElementsByTagName('panel').length, 4, 'panel added');
                            canLog.log('SHIFTY');
                            foodTypes.shift();
                        },
                        function () {
                            var lis = testArea.getElementsByTagName('li');
                            equal(lis.length, 3, 'removed li after shifting a foodType');
                            foodTypes.each(function (type, i) {
                                equal(innerHTML(lis[i]), type.attr('title'), 'li ' + i + ' has the right content');
                            });
                            var panels = testArea.getElementsByTagName('panel');
                            equal(lis[0].className, 'active', 'the first element is active');
                            equal(innerHTML(panels[0]), 'pasta, cereal', 'the first content is shown');
                            equal(innerHTML(panels[1]), '', 'the second content is removed');
                            canEvent.trigger.call(lis[1], 'click');
                            lis = testArea.getElementsByTagName('li');
                            equal(lis[1].className, 'active', 'the second element is active');
                            equal(lis[0].className, '', 'the first element is not active');
                            equal(innerHTML(panels[0]), '', 'the second content is removed');
                            equal(innerHTML(panels[1]), 'ice cream, candy', 'the second content is shown');
                        }
                    ]);
                });
                test('DOM trees not releasing when referencing CanMap inside CanMap in template (#1593)', function () {
                    var baseTemplate = stache('{{#if show}}<my-outside></my-outside>{{/if}}'), show = canCompute(true), state = new CanMap({ inner: 1 });
                    var removeCount = 0;
                    Component.extend({
                        tag: 'my-inside',
                        events: {
                            removed: function () {
                                removeCount++;
                            }
                        },
                        leakScope: true
                    });
                    Component.extend({
                        tag: 'my-outside',
                        template: stache('{{#if state.inner}}<my-inside></my-inside>{{/if}}'),
                        leakScope: true
                    });
                    domMutate.appendChild.call(this.fixture, baseTemplate({
                        show: show,
                        state: state
                    }));
                    runTasks([
                        function () {
                            show(false);
                        },
                        function () {
                            state.removeAttr('inner');
                        },
                        function () {
                            equal(removeCount, 1, 'internal removed once');
                            show(true);
                        },
                        function () {
                            state.attr('inner', 2);
                        },
                        function () {
                            state.removeAttr('inner');
                        },
                        function () {
                            equal(removeCount, 2, 'internal removed twice');
                        }
                    ]);
                    stop();
                });
            }
        }
    }(function () {
        return this;
    }()));
});
/*can-component@3.0.6#test/component-test*/
define('can-component@3.0.6#test/component-test', function (require, exports, module) {
    require('./component-define-test');
    require('./component-map-test');
});
/*can@3.4.1#component/component_test*/
define('can@3.4.1#component/component_test', function (require, exports, module) {
    require('can-component/test/component-test');
});
/*can-event@3.1.1#async/async*/
define('can-event@3.1.1#async/async', function (require, exports, module) {
    (function (global) {
        var canEvent = require('can-event');
        var canBatch = require('can-event/batch/batch');
        var setImmediate = require('can-util/js/set-immediate/set-immediate');
        var GLOBAL = require('can-util/js/global/global')();
        var assign = require('can-util/js/assign/assign');
        var timeout;
        var clearImmediate = GLOBAL.clearImmediate || GLOBAL.clearTimeout;
        var syncBatchDispatch = canBatch.dispatch;
        var syncBatchQueue = canBatch.queue;
        var syncBatchFlush = canBatch.flush;
        var asyncMethods = {
            dispatch: function (ev) {
                var batchNum = typeof ev === 'object' && ev.batchNum;
                if (!canBatch.collecting() && (!batchNum || canBatch.batchNum !== batchNum)) {
                    canBatch.start();
                    timeout = setImmediate(canBatch.stop);
                }
                return syncBatchDispatch.apply(this, arguments);
            },
            queue: function () {
                if (!canBatch.collecting()) {
                    canBatch.start();
                    timeout = setImmediate(canBatch.stop);
                }
                return syncBatchQueue.apply(this, arguments);
            },
            flush: function () {
                if (isAsync && canBatch.collecting()) {
                    clearImmediate(timeout);
                    canBatch.stop();
                }
                canBatch.flush();
            }
        };
        var syncMethods = assign({ flush: syncBatchFlush }, canEvent);
        var isAsync = false;
        var eventAsync = {
            async: function () {
                assign(canEvent, asyncMethods);
                isAsync = true;
            },
            sync: function () {
                if (canBatch.collecting()) {
                    clearImmediate(timeout);
                    canBatch.stop();
                }
                assign(canEvent, syncMethods);
                isAsync = false;
            }
        };
        assign(eventAsync, asyncMethods);
        module.exports = eventAsync;
    }(function () {
        return this;
    }()));
});
/*can-compute@3.0.7#can-compute-async-test*/
define('can-compute@3.0.7#can-compute-async-test', function (require, exports, module) {
    var compute = require('can-compute');
    var QUnit = require('steal-qunit');
    require('can-event/batch/batch');
    var canAsync = require('can-event/async/async');
    QUnit.module('can-compute async', {
        setup: function () {
            canAsync.async();
        },
        teardown: function () {
            canAsync.sync();
        }
    });
    QUnit.asyncTest('async basics', 2, function () {
        var canAsync = require('can-event/async/async');
        canAsync.async();
        var first = compute('Justin');
        var last = compute('Meyer');
        var fullName = compute(function () {
            return first() + ' ' + last();
        });
        fullName.on('change', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'Payal Shah', 'newVal');
            QUnit.equal(oldVal, 'Justin Meyer', 'oldVal');
            QUnit.start();
        });
        first('Payal');
        last('Shah');
    });
    QUnit.asyncTest('async can immediately read', 4, function () {
        var canAsync = require('can-event/async/async');
        canAsync.async();
        var compute = require('can-compute');
        var first = compute('Justin');
        var last = compute('Meyer');
        var fullName = compute(function () {
            return first() + ' ' + last();
        });
        var firedEvents = false;
        fullName.on('change', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'Payal Shah', 'change newVal');
            QUnit.equal(oldVal, 'Justin Meyer', 'change oldVal');
            firedEvents = true;
            QUnit.start();
        });
        first('Payal');
        last('Shah');
        QUnit.equal(fullName(), 'Payal Shah');
        QUnit.ok(firedEvents, 'fired events');
    });
});
/*can-define@1.0.17#list/list*/
define('can-define@1.0.17#list/list', function (require, exports, module) {
    var Construct = require('can-construct');
    var define = require('can-define');
    var make = define.make;
    var canEvent = require('can-event');
    var canBatch = require('can-event/batch/batch');
    var Observation = require('can-observation');
    var canLog = require('can-util/js/log/log');
    var defineHelpers = require('../define-helpers/define-helpers');
    var assign = require('can-util/js/assign/assign');
    var each = require('can-util/js/each/each');
    var isArray = require('can-util/js/is-array/is-array');
    var makeArray = require('can-util/js/make-array/make-array');
    var types = require('can-types');
    var ns = require('can-namespace');
    var splice = [].splice;
    var identity = function (x) {
        return x;
    };
    var makeFilterCallback = function (props) {
        return function (item) {
            for (var prop in props) {
                if (item[prop] !== props[prop]) {
                    return false;
                }
            }
            return true;
        };
    };
    var DefineList = Construct.extend('DefineList', {
        setup: function (base) {
            if (DefineList) {
                var prototype = this.prototype;
                var result = define(prototype, prototype, base.prototype._define);
                var itemsDefinition = result.definitions['#'] || result.defaultDefinition;
                if (itemsDefinition) {
                    if (itemsDefinition.Type) {
                        this.prototype.__type = make.set.Type('*', itemsDefinition.Type, identity);
                    } else if (itemsDefinition.type) {
                        this.prototype.__type = make.set.type('*', itemsDefinition.type, identity);
                    }
                }
            }
        }
    }, {
        setup: function (items) {
            if (!this._define) {
                Object.defineProperty(this, '_define', {
                    enumerable: false,
                    value: { definitions: {} }
                });
                Object.defineProperty(this, '_data', {
                    enumerable: false,
                    value: {}
                });
            }
            define.setup.call(this, {}, false);
            this._length = 0;
            if (items) {
                this.splice.apply(this, [
                    0,
                    0
                ].concat(defineHelpers.toObject(this, items, [], DefineList)));
            }
        },
        __type: define.types.observable,
        _triggerChange: function (attr, how, newVal, oldVal) {
            canBatch.start();
            var index = +attr;
            if (!~('' + attr).indexOf('.') && !isNaN(index)) {
                var itemsDefinition = this._define.definitions['#'];
                if (how === 'add') {
                    if (itemsDefinition && typeof itemsDefinition.added === 'function') {
                        Observation.ignore(itemsDefinition.added).call(this, newVal, index);
                    }
                    canEvent.dispatch.call(this, how, [
                        newVal,
                        index
                    ]);
                    canEvent.dispatch.call(this, 'length', [this._length]);
                } else if (how === 'remove') {
                    if (itemsDefinition && typeof itemsDefinition.removed === 'function') {
                        Observation.ignore(itemsDefinition.removed).call(this, oldVal, index);
                    }
                    canEvent.dispatch.call(this, how, [
                        oldVal,
                        index
                    ]);
                    canEvent.dispatch.call(this, 'length', [this._length]);
                } else {
                    canEvent.dispatch.call(this, how, [
                        newVal,
                        index
                    ]);
                }
            } else {
                canEvent.dispatch.call(this, {
                    type: '' + attr,
                    target: this
                }, [
                    newVal,
                    oldVal
                ]);
            }
            canBatch.stop();
        },
        get: function (index) {
            if (arguments.length) {
                Observation.add(this, '' + index);
                return this[index];
            } else {
                return defineHelpers.serialize(this, 'get', []);
            }
        },
        set: function (prop, value) {
            if (typeof prop !== 'object') {
                prop = isNaN(+prop) || prop % 1 ? prop : +prop;
                if (typeof prop === 'number') {
                    if (typeof prop === 'number' && prop > this._length - 1) {
                        var newArr = new Array(prop + 1 - this._length);
                        newArr[newArr.length - 1] = value;
                        this.push.apply(this, newArr);
                        return newArr;
                    }
                    this.splice(prop, 1, value);
                } else {
                    var defined = defineHelpers.defineExpando(this, prop, value);
                    if (!defined) {
                        this[prop] = value;
                    }
                }
            } else {
                if (isArray(prop)) {
                    if (value) {
                        this.replace(prop);
                    } else {
                        this.splice.apply(this, [
                            0,
                            prop.length
                        ].concat(prop));
                    }
                } else {
                    each(prop, function (value, prop) {
                        this.set(prop, value);
                    }, this);
                }
            }
            return this;
        },
        _items: function () {
            var arr = [];
            this._each(function (item) {
                arr.push(item);
            });
            return arr;
        },
        _each: function (callback) {
            for (var i = 0, len = this._length; i < len; i++) {
                callback(this[i], i);
            }
        },
        splice: function (index, howMany) {
            var args = makeArray(arguments), added = [], i, len, listIndex, allSame = args.length > 2;
            index = index || 0;
            for (i = 0, len = args.length - 2; i < len; i++) {
                listIndex = i + 2;
                args[listIndex] = this.__type(args[listIndex], listIndex);
                added.push(args[listIndex]);
                if (this[i + index] !== args[listIndex]) {
                    allSame = false;
                }
            }
            if (allSame && this._length <= added.length) {
                return added;
            }
            if (howMany === undefined) {
                howMany = args[1] = this._length - index;
            }
            var removed = splice.apply(this, args);
            canBatch.start();
            if (howMany > 0) {
                this._triggerChange('' + index, 'remove', undefined, removed);
            }
            if (args.length > 2) {
                this._triggerChange('' + index, 'add', added, removed);
            }
            canBatch.stop();
            return removed;
        },
        serialize: function () {
            return defineHelpers.serialize(this, 'serialize', []);
        }
    });
    var getArgs = function (args) {
        return args[0] && Array.isArray(args[0]) ? args[0] : makeArray(args);
    };
    each({
        push: 'length',
        unshift: 0
    }, function (where, name) {
        var orig = [][name];
        DefineList.prototype[name] = function () {
            var args = [], len = where ? this._length : 0, i = arguments.length, res, val;
            while (i--) {
                val = arguments[i];
                args[i] = this.__type(val, i);
            }
            res = orig.apply(this, args);
            if (!this.comparator || args.length) {
                this._triggerChange('' + len, 'add', args, undefined);
            }
            return res;
        };
    });
    each({
        pop: 'length',
        shift: 0
    }, function (where, name) {
        DefineList.prototype[name] = function () {
            if (!this._length) {
                return undefined;
            }
            var args = getArgs(arguments), len = where && this._length ? this._length - 1 : 0;
            var res = [][name].apply(this, args);
            this._triggerChange('' + len, 'remove', undefined, [res]);
            return res;
        };
    });
    assign(DefineList.prototype, {
        indexOf: function (item, fromIndex) {
            for (var i = fromIndex || 0, len = this.length; i < len; i++) {
                if (this.get(i) === item) {
                    return i;
                }
            }
            return -1;
        },
        join: function () {
            Observation.add(this, 'length');
            return [].join.apply(this, arguments);
        },
        reverse: function () {
            var list = [].reverse.call(this._items());
            return this.replace(list);
        },
        slice: function () {
            Observation.add(this, 'length');
            var temp = Array.prototype.slice.apply(this, arguments);
            return new this.constructor(temp);
        },
        concat: function () {
            var args = [];
            each(arguments, function (arg) {
                if (types.isListLike(arg) || Array.isArray(arg)) {
                    var arr = types.isListLike(arg) ? makeArray(arg) : arg;
                    each(arr, function (innerArg) {
                        args.push(this.__type(innerArg));
                    }, this);
                } else {
                    args.push(this.__type(arg));
                }
            }, this);
            return new this.constructor(Array.prototype.concat.apply(makeArray(this), args));
        },
        forEach: function (cb, thisarg) {
            var item;
            for (var i = 0, len = this.length; i < len; i++) {
                item = this.get(i);
                if (cb.call(thisarg || item, item, i, this) === false) {
                    break;
                }
            }
            return this;
        },
        replace: function (newList) {
            this.splice.apply(this, [
                0,
                this._length
            ].concat(makeArray(newList || [])));
            return this;
        },
        filter: function (callback, thisArg) {
            var filteredList = [], self = this, filtered;
            if (typeof callback === 'object') {
                callback = makeFilterCallback(callback);
            }
            this.each(function (item, index, list) {
                filtered = callback.call(thisArg | self, item, index, self);
                if (filtered) {
                    filteredList.push(item);
                }
            });
            return new this.constructor(filteredList);
        },
        map: function (callback, thisArg) {
            var mappedList = [], self = this;
            this.each(function (item, index, list) {
                var mapped = callback.call(thisArg | self, item, index, self);
                mappedList.push(mapped);
            });
            return new this.constructor(mappedList);
        },
        sort: function (compareFunction) {
            var removed = Array.prototype.slice.call(this);
            Array.prototype.sort.call(this, compareFunction);
            var added = Array.prototype.slice.call(this);
            canBatch.start();
            canEvent.dispatch.call(this, 'remove', [
                removed,
                0
            ]);
            canEvent.dispatch.call(this, 'add', [
                added,
                0
            ]);
            canEvent.dispatch.call(this, 'length', [
                this._length,
                this._length
            ]);
            canBatch.stop();
            return this;
        }
    });
    for (var prop in define.eventsProto) {
        DefineList[prop] = define.eventsProto[prop];
        Object.defineProperty(DefineList.prototype, prop, {
            enumerable: false,
            value: define.eventsProto[prop],
            writable: true
        });
    }
    Object.defineProperty(DefineList.prototype, 'length', {
        get: function () {
            if (!this.__inSetup) {
                Observation.add(this, 'length');
            }
            return this._length;
        },
        set: function (newVal) {
            this._length = newVal;
        },
        enumerable: true
    });
    var oldIsListLike = types.isListLike;
    types.isListLike = function (obj) {
        return obj instanceof DefineList || oldIsListLike.apply(this, arguments);
    };
    DefineList.prototype.each = DefineList.prototype.forEach;
    DefineList.prototype.attr = function (prop, value) {
        canLog.warn('DefineMap::attr shouldn\'t be called');
        if (arguments.length === 0) {
            return this.get();
        } else if (prop && typeof prop === 'object') {
            return this.set.apply(this, arguments);
        } else if (arguments.length === 1) {
            return this.get(prop);
        } else {
            return this.set(prop, value);
        }
    };
    DefineList.prototype.item = function (index, value) {
        if (arguments.length === 1) {
            return this.get(index);
        } else {
            return this.set(index, value);
        }
    };
    DefineList.prototype.items = function () {
        canLog.warn('DefineList::get should should be used instead of DefineList::items');
        return this.get();
    };
    types.DefineList = DefineList;
    types.DefaultList = DefineList;
    module.exports = ns.DefineList = DefineList;
});
/*can-compute@3.0.7#can-compute_test*/
define('can-compute@3.0.7#can-compute_test', function (require, exports, module) {
    require('./can-compute-async-test');
    var compute = require('can-compute');
    var Compute = require('can-compute/proto-compute');
    var QUnit = require('steal-qunit');
    var canBatch = require('can-event/batch/');
    var Observation = require('can-observation');
    var DefineMap = require('can-define/map/map');
    var DefineList = require('can-define/list/list');
    var domDispatch = require('can-util/dom/dispatch/dispatch');
    QUnit.module('can/compute');
    test('single value compute', function () {
        var num = compute(1);
        num.on('change', function (ev, newVal, oldVal) {
            equal(newVal, 2, 'newVal');
            equal(oldVal, 1, 'oldVal');
        });
        num(2);
    });
    test('inner computes values are not bound to', function () {
        var num = compute(1);
        var outer = compute(function () {
            var inner = compute(function () {
                return num() + 1;
            });
            return 2 * inner();
        });
        var handler = function () {
        };
        outer.on('change', handler);
        stop();
        setTimeout(function () {
            equal(num.computeInstance._bindings, 1, 'inner compute only bound once');
            equal(outer.computeInstance._bindings, 1, 'outer compute only bound once');
            start();
        }, 50);
    });
    test('compute.truthy', function () {
        var result = 0;
        var numValue;
        var num = compute(numValue = 3);
        var truthy = compute.truthy(num);
        var tester = compute(function () {
            if (truthy()) {
                return ++result;
            } else {
                return ++result;
            }
        });
        tester.addEventListener('change', function (ev, newVal, oldVal) {
            if (num() === 0) {
                equal(newVal, 2, '2 is the new val');
            } else if (num() === -1) {
                equal(newVal, 3, '3 is the new val');
            } else {
                ok(false, 'change should not be called');
            }
        });
        equal(tester(), 1, 'on bind, we call tester once');
        num(numValue = 2);
        num(numValue = 1);
        num(numValue = 0);
        num(numValue = -1);
    });
    test('a binding compute does not double read', function () {
        var sourceAge = 30, timesComputeIsCalled = 0;
        var age = compute(function (newVal) {
            timesComputeIsCalled++;
            if (timesComputeIsCalled === 1) {
                ok(true, 'reading age to get value');
            } else if (timesComputeIsCalled === 2) {
                equal(newVal, 31, 'the second time should be an update');
            } else if (timesComputeIsCalled === 3) {
                ok(true, 'called after set to get the value');
            } else {
                ok(false, 'You\'ve called the callback ' + timesComputeIsCalled + ' times');
            }
            if (arguments.length) {
                sourceAge = newVal;
            } else {
                return sourceAge;
            }
        });
        var info = compute(function () {
            return 'I am ' + age();
        });
        var k = function () {
        };
        info.bind('change', k);
        equal(info(), 'I am 30');
        age(31);
        equal(info(), 'I am 31');
    });
    test('cloning a setter compute (#547)', function () {
        var name = compute('', function (newVal) {
            return this.txt + newVal;
        });
        var cloned = name.clone({ txt: '.' });
        cloned('-');
        equal(cloned(), '.-');
    });
    test('compute updated method uses get and old value (#732)', function () {
        expect(9);
        var input = { value: 1 };
        var value = compute('', {
            get: function () {
                return input.value;
            },
            set: function (newVal) {
                input.value = newVal;
            },
            on: function (update) {
                input.onchange = update;
            },
            off: function () {
                delete input.onchange;
            }
        });
        equal(value(), 1, 'original value');
        ok(!input.onchange, 'nothing bound');
        value(2);
        equal(value(), 2, 'updated value');
        equal(input.value, 2, 'updated input.value');
        value.bind('change', function (ev, newVal, oldVal) {
            equal(newVal, 3, 'newVal');
            equal(oldVal, 2, 'oldVal');
            value.unbind('change', this.Constructor);
        });
        ok(input.onchange, 'binding to onchange');
        input.value = 3;
        input.onchange({});
        ok(!input.onchange, 'removed binding');
        equal(value(), 3);
    });
    test('a compute updated by source changes within a batch is part of that batch', function () {
        var computeA = compute('a');
        var computeB = compute('b');
        var combined1 = compute(function () {
            return computeA() + ' ' + computeB();
        });
        var combined2 = compute(function () {
            return computeA() + ' ' + computeB();
        });
        var combo = compute(function () {
            return combined1() + ' ' + combined2();
        });
        var callbacks = 0;
        combo.bind('change', function () {
            if (callbacks === 0) {
                ok(true, 'called change once');
            } else {
                ok(false, 'called change multiple times');
            }
            callbacks++;
        });
        canBatch.start();
        computeA('A');
        computeB('B');
        canBatch.stop();
    });
    test('compute.async can be like a normal getter', function () {
        var first = compute('Justin'), last = compute('Meyer'), fullName = compute.async('', function () {
                return first() + ' ' + last();
            });
        equal(fullName(), 'Justin Meyer');
    });
    test('compute.async operate on single value', function () {
        var a = compute(1);
        var b = compute(2);
        var obj = compute.async({}, function (curVal) {
            if (a()) {
                curVal.a = a();
            } else {
                delete curVal.a;
            }
            if (b()) {
                curVal.b = b();
            } else {
                delete curVal.b;
            }
            return curVal;
        });
        obj.bind('change', function () {
        });
        deepEqual(obj(), {
            a: 1,
            b: 2
        }, 'object has all properties');
        a(0);
        deepEqual(obj(), { b: 2 }, 'removed a');
        b(0);
        deepEqual(obj(), {}, 'removed b');
    });
    test('compute.async async changing value', function () {
        var a = compute(1);
        var b = compute(2);
        var async = compute.async(undefined, function (curVal, setVal) {
            if (a()) {
                setTimeout(function () {
                    setVal('a');
                }, 10);
            } else if (b()) {
                setTimeout(function () {
                    setVal('b');
                }, 10);
            } else {
                return null;
            }
        });
        var changeArgs = [
                {
                    newVal: 'a',
                    oldVal: undefined,
                    run: function () {
                        a(0);
                    }
                },
                {
                    newVal: 'b',
                    oldVal: 'a',
                    run: function () {
                        b(0);
                    }
                },
                {
                    newVal: null,
                    oldVal: 'b',
                    run: function () {
                        start();
                    }
                }
            ], changeNum = 0;
        stop();
        async.bind('change', function (ev, newVal, oldVal) {
            var data = changeArgs[changeNum++];
            equal(newVal, data.newVal, 'newVal is correct');
            equal(oldVal, data.oldVal, 'oldVal is correct');
            setTimeout(data.run, 10);
        });
    });
    test('compute.async read without binding', function () {
        var source = compute(1);
        var async = compute.async([], function (curVal, setVal) {
            curVal.push(source());
            return curVal;
        });
        ok(async(), 'calling async worked');
    });
    QUnit.module('can/Compute');
    test('single value compute', function () {
        expect(2);
        var num = new Compute(1);
        num.bind('change', function (ev, newVal, oldVal) {
            equal(newVal, 2, 'newVal');
            equal(oldVal, 1, 'oldVal');
        });
        num.set(2);
    });
    test('inner computes values are not bound to', function () {
        var num = new Compute(1), numBind = num.addEventListener, numUnbind = num.removeEventListener;
        var bindCount = 0;
        num.addEventListener = function () {
            bindCount++;
            return numBind.apply(this, arguments);
        };
        num.removeEventListener = function () {
            bindCount--;
            return numUnbind.apply(this, arguments);
        };
        var outer = new Compute(function () {
            var inner = new Compute(function () {
                return num.get() + 1;
            });
            return 2 * inner.get();
        });
        var handler = function () {
        };
        outer.bind('change', handler);
        stop();
        setTimeout(function () {
            equal(bindCount, 1, 'compute only bound to once');
            start();
        }, 50);
    });
    test('compute.truthy', function () {
        var result = 0;
        var num = new Compute(3);
        var truthy = Compute.truthy(num);
        var tester = new Compute(function () {
            if (truthy.get()) {
                return ++result;
            } else {
                return ++result;
            }
        });
        tester.bind('change', function (ev, newVal, oldVal) {
            if (num.get() === 0) {
                equal(newVal, 2, '2 is the new val');
            } else if (num.get() === -1) {
                equal(newVal, 3, '3 is the new val');
            } else {
                ok(false, 'change should not be called');
            }
        });
        equal(tester.get(), 1, 'on bind, we call tester once');
        num.set(2);
        num.set(1);
        num.set(0);
        num.set(-1);
    });
    test('a binding compute does not double read', function () {
        var sourceAge = 30, timesComputeIsCalled = 0;
        var age = new Compute(function (newVal) {
            timesComputeIsCalled++;
            if (timesComputeIsCalled === 1) {
                ok(true, 'reading age to get value');
            } else if (timesComputeIsCalled === 2) {
                equal(newVal, 31, 'the second time should be an update');
            } else if (timesComputeIsCalled === 3) {
                ok(true, 'called after set to get the value');
            } else {
                ok(false, 'You\'ve called the callback ' + timesComputeIsCalled + ' times');
            }
            if (arguments.length) {
                sourceAge = newVal;
            } else {
                return sourceAge;
            }
        });
        var info = new Compute(function () {
            return 'I am ' + age.get();
        });
        var k = function () {
        };
        info.bind('change', k);
        equal(info.get(), 'I am 30');
        age.set(31);
        equal(info.get(), 'I am 31');
    });
    test('cloning a setter compute (#547)', function () {
        var name = new Compute('', function (newVal) {
            return this.txt + newVal;
        });
        var cloned = name.clone({ txt: '.' });
        cloned.set('-');
        equal(cloned.get(), '.-');
    });
    test('compute updated method uses get and old value (#732)', function () {
        expect(9);
        var input = { value: 1 };
        var value = new Compute('', {
            get: function () {
                return input.value;
            },
            set: function (newVal) {
                input.value = newVal;
            },
            on: function (update) {
                input.onchange = update;
            },
            off: function () {
                delete input.onchange;
            }
        });
        equal(value.get(), 1, 'original value');
        ok(!input.onchange, 'nothing bound');
        value.set(2);
        equal(value.get(), 2, 'updated value');
        equal(input.value, 2, 'updated input.value');
        value.bind('change', function (ev, newVal, oldVal) {
            equal(newVal, 3, 'newVal');
            equal(oldVal, 2, 'oldVal');
            value.unbind('change', this.Constructor);
        });
        ok(input.onchange, 'binding to onchange');
        input.value = 3;
        input.onchange({});
        ok(!input.onchange, 'removed binding');
        equal(value.get(), 3);
    });
    test('a compute updated by source changes within a batch is part of that batch', function () {
        var computeA = new Compute('a');
        var computeB = new Compute('b');
        var combined1 = new Compute(function () {
            return computeA.get() + ' ' + computeB.get();
        });
        var combined2 = new Compute(function () {
            return computeA.get() + ' ' + computeB.get();
        });
        var combo = new Compute(function () {
            return combined1.get() + ' ' + combined2.get();
        });
        var callbacks = 0;
        combo.bind('change', function () {
            if (callbacks === 0) {
                ok(true, 'called change once');
            } else {
                ok(false, 'called change multiple times');
            }
            callbacks++;
        });
        canBatch.start();
        computeA.set('A');
        computeB.set('B');
        canBatch.stop();
    });
    test('Compute.async can be like a normal getter', function () {
        var first = new Compute('Justin'), last = new Compute('Meyer'), fullName = Compute.async('', function () {
                return first.get() + ' ' + last.get();
            });
        equal(fullName.get(), 'Justin Meyer');
    });
    test('Compute.async operate on single value', function () {
        var a = new Compute(1);
        var b = new Compute(2);
        var obj = Compute.async({}, function (curVal) {
            if (a.get()) {
                curVal.a = a.get();
            } else {
                delete curVal.a;
            }
            if (b.get()) {
                curVal.b = b.get();
            } else {
                delete curVal.b;
            }
            return curVal;
        });
        obj.bind('change', function () {
        });
        deepEqual(obj.get(), {
            a: 1,
            b: 2
        }, 'object has all properties');
        a.set(0);
        deepEqual(obj.get(), { b: 2 }, 'removed a');
        b.set(0);
        deepEqual(obj.get(), {}, 'removed b');
    });
    test('Compute.async async changing value', function () {
        var a = new Compute(1);
        var b = new Compute(2);
        var async = Compute.async(undefined, function (curVal, setVal) {
            if (a.get()) {
                setTimeout(function () {
                    setVal('a');
                }, 10);
            } else if (b.get()) {
                setTimeout(function () {
                    setVal('b');
                }, 10);
            } else {
                return null;
            }
        });
        var changeArgs = [
                {
                    newVal: 'a',
                    oldVal: undefined,
                    run: function () {
                        a.set(0);
                    }
                },
                {
                    newVal: 'b',
                    oldVal: 'a',
                    run: function () {
                        b.set(0);
                    }
                },
                {
                    newVal: null,
                    oldVal: 'b',
                    run: function () {
                        start();
                    }
                }
            ], changeNum = 0;
        stop();
        async.bind('change', function (ev, newVal, oldVal) {
            var data = changeArgs[changeNum++];
            equal(newVal, data.newVal, 'newVal is correct');
            equal(oldVal, data.oldVal, 'oldVal is correct');
            setTimeout(data.run, 10);
        });
    });
    test('Compute.async read without binding', function () {
        var source = new Compute(1);
        var async = Compute.async([], function (curVal, setVal) {
            curVal.push(source.get());
            return curVal;
        });
        ok(async.get(), 'calling async worked');
    });
    test('Compute.async set uses last set or initial value', function () {
        var add = new Compute(1);
        var fnCount = 0;
        var async = Compute.async(10, function (curVal) {
            switch (fnCount++) {
            case 0:
                equal(curVal, 10);
                break;
            case 1:
                equal(curVal, 20);
                break;
            case 2:
                equal(curVal, 30, 'on bind');
                break;
            case 3:
                equal(curVal, 30, 'on bind');
                break;
            }
            return curVal + add.get();
        });
        equal(async.get(), 11, 'initial value');
        async.set(20);
        async.bind('change', function () {
        });
        async.set(20);
        async.set(30);
    });
    test('setting compute.async with a observable dependency gets a new value and can re-compute', 4, function () {
        var c = compute(1);
        var add;
        var async = compute.async(1, function (curVal) {
            add = curVal;
            return c() + add;
        });
        equal(async(), 2, 'can read unbound');
        async.bind('change', function (ev, newVal, oldVal) {
            equal(newVal, 3, 'change new val');
            equal(oldVal, 2, 'change old val');
        });
        async(2);
        equal(async(), 3, 'can read unbound');
    });
    test('compute.async getter has correct when length === 1', function () {
        var m = {};
        var getterCompute = compute.async(false, function (singleArg) {
            equal(this, m, 'getter has the right context');
        }, m);
        getterCompute.bind('change', function () {
        });
    });
    test('bug with nested computes and batch ordering (#1519)', function () {
        var root = compute('a');
        var isA = compute(function () {
            return root() === 'a';
        });
        var isB = compute(function () {
            return root() === 'b';
        });
        var combined = compute(function () {
            var valA = isA(), valB = isB();
            return valA || valB;
        });
        equal(combined(), true);
        combined.bind('change', function () {
        });
        canBatch.start();
        root('b');
        canBatch.stop();
        equal(combined(), true);
    });
    test('compute change handler context is set to the function not compute', function () {
        var comp = compute(null);
        comp.bind('change', function () {
            equal(typeof this, 'function');
        });
        comp('test');
    });
    test('Calling .unbind() on un-bound compute does not throw an error', function () {
        var count = compute(0);
        count.unbind('change');
        ok(true, 'No error was thrown');
    });
    test('dependent computes update in the right order (2093)', function () {
        var root = compute('a'), childB = compute(function () {
                return root();
            }), combine = compute(function () {
                return root() + childB();
            });
        combine.bind('change', function (ev, newVal) {
            equal(newVal, 'bb', 'concat changed');
        });
        root('b');
    });
    test('dependent computes update in the right order with a batch (#2093)', function () {
        var root = compute('a'), child = compute(function () {
                return root();
            }), child2 = compute(function () {
                return root();
            }), grandChild = compute(function () {
                return child();
            }), combine = compute(function () {
                return child2() + grandChild();
            });
        combine.bind('change', function (ev, newVal) {
            equal(newVal, 'bb', 'concat changed');
        });
        canBatch.start();
        root('b');
        canBatch.stop();
    });
    test('bug with nested computes and batch ordering (#1519)', function () {
        var root = compute('a');
        var isA = compute(function () {
            return root() === 'a';
        });
        var isB = compute(function () {
            return root() === 'b';
        });
        var combined = compute(function () {
            var valA = isA(), valB = isB();
            return valA || valB;
        });
        equal(combined(), true);
        combined.bind('change', function () {
        });
        canBatch.start();
        root('b');
        canBatch.stop();
        equal(combined(), true);
    });
    test('binding, unbinding, and rebinding works after a timeout (#2095)', function () {
        var root = compute(1), derived = compute(function () {
                return root();
            });
        var change = function () {
        };
        derived.bind('change', change);
        derived.unbind('change', change);
        stop();
        setTimeout(function () {
            derived.bind('change', function (ev, newVal, oldVal) {
                equal(newVal, 2, 'updated');
                start();
            });
            root(2);
        }, 10);
    });
    test('Observation.isRecording observes doesn\'t understand Observation.ignore (#2099)', function () {
        expect(0);
        var c = compute(1);
        c.computeInstance.bind = function () {
            ok(false);
        };
        var outer = compute(function () {
            Observation.ignore(function () {
                c();
            })();
        });
        outer.bind('change', function () {
        });
    });
    test('handles missing update order items (#2121)', function () {
        var root1 = compute('root1'), child1 = compute(function () {
                return root1();
            }), root2 = compute('root2'), child2 = compute(function () {
                return root2();
            }), gc2 = compute(function () {
                return child2();
            }), res = compute(function () {
                return child1() + gc2();
            });
        res.bind('change', function (ev, newVal) {
            equal(newVal, 'ROOT1root2');
        });
        canBatch.start();
        root1('ROOT1');
        canBatch.stop();
    });
    test('compute should not fire event when NaN is set multiple times #2128', function () {
        var c = compute(NaN);
        compute.bind('change', function () {
            ok(false, 'change event should not be fired');
        });
        ok(isNaN(c()));
        c(NaN);
    });
    test('canBatch.afterPreviousEvents firing too late (#2198)', function () {
        var compute1 = compute('a'), compute2 = compute('b');
        var derived = compute(function () {
            return compute1().toUpperCase();
        });
        derived.bind('change', function () {
            var afterPrevious = false;
            compute2.bind('change', function () {
                ok(afterPrevious, 'after previous should have fired so we would respond to this event');
            });
            canBatch.start();
            canBatch.stop();
            canBatch.afterPreviousEvents(function () {
                afterPrevious = true;
            });
            compute2('c');
        });
        canBatch.start();
        compute1('x');
        canBatch.stop();
    });
    test('Change propagation in a batch with late bindings (#2412)', function () {
        var rootA = new Compute('a');
        var rootB = new Compute('b');
        var childA = new Compute(function () {
            return 'childA' + rootA.get();
        });
        var grandChild = new Compute(function () {
            var b = rootB.get();
            if (b === 'b') {
                return 'grandChild->b';
            }
            var a = childA.get();
            return 'grandChild->' + a;
        });
        childA.bind('change', function (ev, newVal, oldVal) {
        });
        grandChild.bind('change', function (ev, newVal, oldVal) {
            equal(newVal, 'grandChild->childAA');
        });
        canBatch.start();
        rootA.set('A');
        rootB.set('B');
        canBatch.stop();
    });
    if (Compute.prototype.trace) {
        test('trace', function () {
            var rootA = new Compute('a');
            var rootB = new Compute('b');
            var childA = new Compute(function () {
                return 'childA' + rootA.get();
            });
            var fn = function () {
                var b = rootB.get();
                if (b === 'b') {
                    return 'grandChild->b';
                }
                var a = childA.get();
                return 'grandChild->' + a;
            };
            var grandChild = new Compute(fn);
            childA.bind('change', function (ev, newVal, oldVal) {
            });
            grandChild.bind('change', function (ev, newVal, oldVal) {
                equal(newVal, 'grandChild->childAA');
            });
            var out = grandChild.trace();
            equal(out.definition, fn, 'got the right function');
            equal(out.computeValue, 'grandChild->b');
            grandChild.log();
            canBatch.start();
            rootA.set('A');
            rootB.set('B');
            canBatch.stop();
            grandChild.log();
        });
    }
    test('compute(defineMap, \'property.names\') works (#20)', function () {
        var map = new DefineMap();
        var c = compute(map, 'foo.bar');
        c.on('change', function (ev, newVal) {
            QUnit.equal(newVal, 2);
        });
        map.set('foo', new DefineMap());
        map.foo.set('bar', 2);
    });
    test('compute(DefineList, 0) works (#17)', function (assert) {
        assert.expect(1);
        var list = new DefineList([
            1,
            2,
            3
        ]);
        var c = compute(list, 0);
        c.on('change', function (ev, newVal) {
            assert.equal(newVal, 5);
        });
        list.set(0, 5);
    });
    test('Async getter causes infinite loop (#28)', function () {
        var changeCount = 0;
        var idCompute = compute(1);
        stop();
        var comp = compute.async(undefined, function (last, resolve) {
            var id = idCompute();
            setTimeout(function () {
                resolve(changeCount + '|' + id);
            });
            resolve(changeCount + '|' + id);
        }, null);
        comp.bind('change', function (ev, newVal) {
            changeCount++;
            comp();
        });
        setTimeout(function () {
            idCompute(2);
        }, 50);
        setTimeout(function () {
            equal(changeCount, 4);
            start();
        }, 100);
    });
    test('Listening to input change', function () {
        var input = document.createElement('input');
        var comp = compute(input, 'value', 'input');
        comp.on('change', function () {
            ok(true, 'it changed');
        });
        input.value = 'foo';
        domDispatch.call(input, 'input');
    });
});
/*can@3.4.1#compute/compute_test*/
define('can@3.4.1#compute/compute_test', function (require, exports, module) {
    require('can-compute/can-compute_test');
});
/*can-set@1.1.0#src/helpers*/
define('can-set@1.1.0#src/helpers', function (require, exports, module) {
    var assign = require('can-util/js/assign/assign');
    var each = require('can-util/js/each/each');
    var last = require('can-util/js/last/last');
    var IgnoreType = function () {
    };
    var helpers;
    module.exports = helpers = {
        eachInUnique: function (a, acb, b, bcb, defaultReturn) {
            var bCopy = assign({}, b), res;
            for (var prop in a) {
                res = acb(a[prop], b[prop], a, b, prop);
                if (res !== undefined) {
                    return res;
                }
                delete bCopy[prop];
            }
            for (prop in bCopy) {
                res = bcb(undefined, b[prop], a, b, prop);
                if (res !== undefined) {
                    return res;
                }
            }
            return defaultReturn;
        },
        doubleLoop: function (arr, callbacks) {
            if (typeof callbacks === 'function') {
                callbacks = { iterate: callbacks };
            }
            var i = 0;
            while (i < arr.length) {
                if (callbacks.start) {
                    callbacks.start(arr[i]);
                }
                var j = i + 1;
                while (j < arr.length) {
                    if (callbacks.iterate(arr[j], j, arr[i], i) === false) {
                        arr.splice(j, 1);
                    } else {
                        j++;
                    }
                }
                if (callbacks.end) {
                    callbacks.end(arr[i]);
                }
                i++;
            }
        },
        identityMap: function (arr) {
            var map = {};
            each(arr, function (value) {
                map[value] = 1;
            });
            return map;
        },
        arrayUnionIntersectionDifference: function (arr1, arr2) {
            var map = {};
            var intersection = [];
            var union = [];
            var difference = arr1.slice(0);
            each(arr1, function (value) {
                map[value] = true;
                union.push(value);
            });
            each(arr2, function (value) {
                if (map[value]) {
                    intersection.push(value);
                    var index = helpers.indexOf.call(difference, value);
                    if (index !== -1) {
                        difference.splice(index, 1);
                    }
                } else {
                    union.push(value);
                }
            });
            return {
                intersection: intersection,
                union: union,
                difference: difference
            };
        },
        arraySame: function (arr1, arr2) {
            if (arr1.length !== arr2.length) {
                return false;
            }
            var map = helpers.identityMap(arr1);
            for (var i = 0; i < arr2.length; i++) {
                var val = map[arr2[i]];
                if (!val) {
                    return false;
                } else if (val > 1) {
                    return false;
                } else {
                    map[arr2[i]]++;
                }
            }
            return true;
        },
        indexOf: Array.prototype.indexOf || function (item) {
            for (var i = 0, thisLen = this.length; i < thisLen; i++) {
                if (this[i] === item) {
                    return i;
                }
            }
            return -1;
        },
        map: Array.prototype.map || function (cb) {
            var out = [];
            for (var i = 0, len = this.length; i < len; i++) {
                out.push(cb(this[i], i, this));
            }
            return out;
        },
        filter: Array.prototype.filter || function (cb) {
            var out = [];
            for (var i = 0, len = this.length; i < len; i++) {
                if (cb(this[i], i, this)) {
                    out.push(this[i]);
                }
            }
            return out;
        },
        ignoreType: new IgnoreType(),
        firstProp: function (set) {
            for (var prop in set) {
                return prop;
            }
        },
        index: function (compare, items, props) {
            if (!items || !items.length) {
                return undefined;
            }
            if (compare(props, items[0]) === -1) {
                return 0;
            } else if (compare(props, last(items)) === 1) {
                return items.length;
            }
            var low = 0, high = items.length;
            while (low < high) {
                var mid = low + high >>> 1, item = items[mid], computed = compare(props, item);
                if (computed === -1) {
                    high = mid;
                } else {
                    low = mid + 1;
                }
            }
            return high;
        },
        defaultSort: function (sortPropValue, item1, item2) {
            var parts = sortPropValue.split(' ');
            var sortProp = parts[0];
            var item1Value = item1[sortProp];
            var item2Value = item2[sortProp];
            var temp;
            var desc = parts[1] || '';
            desc = desc.toLowerCase() === 'desc';
            if (desc) {
                temp = item1Value;
                item1Value = item2Value;
                item2Value = temp;
            }
            if (item1Value < item2Value) {
                return -1;
            }
            if (item1Value > item2Value) {
                return 1;
            }
            return 0;
        }
    };
});
/*can-set@1.1.0#src/clause*/
define('can-set@1.1.0#src/clause', function (require, exports, module) {
    var assign = require('can-util/js/assign/assign');
    var each = require('can-util/js/each/each');
    var clause = {};
    module.exports = clause;
    clause.TYPES = [
        'where',
        'order',
        'paginate',
        'id'
    ];
    each(clause.TYPES, function (type) {
        var className = type.charAt(0).toUpperCase() + type.substr(1);
        clause[className] = function (compare) {
            assign(this, compare);
        };
        clause[className].type = type;
    });
});
/*can-set@1.1.0#src/compare*/
define('can-set@1.1.0#src/compare', function (require, exports, module) {
    var h = require('./helpers');
    var assign = require('can-util/js/assign/assign');
    var each = require('can-util/js/each/each');
    var makeArray = require('can-util/js/make-array/make-array');
    var compareHelpers;
    var loop = function (a, b, aParent, bParent, prop, compares, options) {
        var checks = options.checks;
        for (var i = 0; i < checks.length; i++) {
            var res = checks[i](a, b, aParent, bParent, prop, compares || {}, options);
            if (res !== undefined) {
                return res;
            }
        }
        return options['default'];
    };
    var addIntersectedPropertyToResult = function (a, b, aParent, bParent, prop, compares, options) {
        var subsetCheck;
        if (!(prop in aParent)) {
            subsetCheck = 'subsetB';
        } else if (prop in bParent) {
            return false;
        }
        if (!(prop in bParent)) {
            subsetCheck = 'subsetA';
        }
        if (subsetCheck === 'subsetB') {
            options.result[prop] = b;
        } else {
            options.result[prop] = a;
        }
        return undefined;
    };
    var addToResult = function (fn, name) {
        return function (a, b, aParent, bParent, prop, compares, options) {
            var res = fn.apply(this, arguments);
            if (res === true) {
                if (prop !== undefined && !(prop in options.result)) {
                    options.result[prop] = a;
                }
                return true;
            } else {
                return res;
            }
        };
    };
    module.exports = compareHelpers = {
        equal: function (a, b, aParent, bParent, prop, compares, options) {
            options.checks = [
                compareHelpers.equalComparesType,
                compareHelpers.equalBasicTypes,
                compareHelpers.equalArrayLike,
                compareHelpers.equalObject
            ];
            options['default'] = false;
            return loop(a, b, aParent, bParent, prop, compares, options);
        },
        equalComparesType: function (a, b, aParent, bParent, prop, compares, options) {
            if (typeof compares === 'function') {
                var compareResult = compares(a, b, aParent, bParent, prop, options);
                if (typeof compareResult === 'boolean') {
                    return compareResult;
                } else if (compareResult && typeof compareResult === 'object') {
                    if ('intersection' in compareResult && !('difference' in compareResult)) {
                        var reverseResult = compares(b, a, bParent, aParent, prop, options);
                        return 'intersection' in reverseResult && !('difference' in reverseResult);
                    }
                    return false;
                }
                return compareResult;
            }
        },
        equalBasicTypes: function (a, b, aParent, bParent, prop, compares, options) {
            if (a === null || b === null) {
                return a === b;
            }
            if (a instanceof Date && b instanceof Date) {
                return a.getTime() === b.getTime();
            }
            if (options.deep === -1) {
                return typeof a === 'object' || a === b;
            }
            if (typeof a !== typeof b || Array.isArray(a) !== Array.isArray(b)) {
                return false;
            }
            if (a === b) {
                return true;
            }
        },
        equalArrayLike: function (a, b, aParent, bParent, prop, compares, options) {
            if (Array.isArray(a) && Array.isArray(b)) {
                if (a.length !== b.length) {
                    return false;
                }
                for (var i = 0; i < a.length; i++) {
                    var compare = compares[i] === undefined ? compares['*'] : compares[i];
                    if (!loop(a[i], b[i], a, b, i, compare, options)) {
                        return false;
                    }
                }
                return true;
            }
        },
        equalObject: function (a, b, aParent, bParent, parentProp, compares, options) {
            var aType = typeof a;
            if (aType === 'object' || aType === 'function') {
                var bCopy = assign({}, b);
                if (options.deep === false) {
                    options.deep = -1;
                }
                for (var prop in a) {
                    var compare = compares[prop] === undefined ? compares['*'] : compares[prop];
                    if (!loop(a[prop], b[prop], a, b, prop, compare, options)) {
                        return false;
                    }
                    delete bCopy[prop];
                }
                for (prop in bCopy) {
                    if (compares[prop] === undefined || !loop(undefined, b[prop], a, b, prop, compares[prop], options)) {
                        return false;
                    }
                }
                return true;
            }
        },
        subset: function (a, b, aParent, bParent, prop, compares, options) {
            options.checks = [
                compareHelpers.subsetComparesType,
                compareHelpers.equalBasicTypes,
                compareHelpers.equalArrayLike,
                compareHelpers.subsetObject
            ];
            options.getSubsets = [];
            options['default'] = false;
            return loop(a, b, aParent, bParent, prop, compares, options);
        },
        subsetObject: function (a, b, aParent, bParent, parentProp, compares, options) {
            var aType = typeof a;
            if (aType === 'object' || aType === 'function') {
                return h.eachInUnique(a, function (a, b, aParent, bParent, prop) {
                    var compare = compares[prop] === undefined ? compares['*'] : compares[prop];
                    if (!loop(a, b, aParent, bParent, prop, compare, options) && prop in bParent) {
                        return false;
                    }
                }, b, function (a, b, aParent, bParent, prop) {
                    var compare = compares[prop] === undefined ? compares['*'] : compares[prop];
                    if (!loop(a, b, aParent, bParent, prop, compare, options)) {
                        return false;
                    }
                }, true);
            }
        },
        subsetComparesType: function (a, b, aParent, bParent, prop, compares, options) {
            if (typeof compares === 'function') {
                var compareResult = compares(a, b, aParent, bParent, prop, options);
                if (typeof compareResult === 'boolean') {
                    return compareResult;
                } else if (compareResult && typeof compareResult === 'object') {
                    if (compareResult.getSubset) {
                        if (h.indexOf.call(options.getSubsets, compareResult.getSubset) === -1) {
                            options.getSubsets.push(compareResult.getSubset);
                        }
                    }
                    if (compareResult.intersection === h.ignoreType || compareResult.difference === h.ignoreType) {
                        return true;
                    }
                    if ('intersection' in compareResult && !('difference' in compareResult)) {
                        var reverseResult = compares(b, a, bParent, aParent, prop, options);
                        return 'intersection' in reverseResult;
                    }
                    return false;
                }
                return compareResult;
            }
        },
        properSupersetObject: function (a, b, aParent, bParent, parentProp, compares, options) {
            var bType = typeof b;
            var hasAdditionalProp = false;
            if (bType === 'object' || bType === 'function') {
                var aCopy = assign({}, a);
                if (options.deep === false) {
                    options.deep = -1;
                }
                for (var prop in b) {
                    var compare = compares[prop] === undefined ? compares['*'] : compares[prop];
                    var compareResult = loop(a[prop], b[prop], a, b, prop, compare, options);
                    if (compareResult === h.ignoreType) {
                    } else if (!(prop in a) || options.performedDifference) {
                        hasAdditionalProp = true;
                    } else if (!compareResult) {
                        return false;
                    }
                    delete aCopy[prop];
                }
                for (prop in aCopy) {
                    if (compares[prop] === undefined || !loop(a[prop], undefined, a, b, prop, compares[prop], options)) {
                        return false;
                    }
                }
                return hasAdditionalProp;
            }
        },
        properSubsetComparesType: function (a, b, aParent, bParent, prop, compares, options) {
            if (typeof compares === 'function') {
                var compareResult = compares(a, b, aParent, bParent, prop, options);
                if (typeof compareResult === 'boolean') {
                    return compareResult;
                } else if (compareResult && typeof compareResult === 'object') {
                    if ('intersection' in compareResult && !('difference' in compareResult)) {
                        var reverseResult = compares(b, a, bParent, aParent, prop, options);
                        return 'intersection' in reverseResult && 'difference' in reverseResult;
                    }
                    return false;
                }
                return compareResult;
            }
        },
        difference: function (a, b, aParent, bParent, prop, compares, options) {
            options.result = {};
            options.performedDifference = 0;
            options.checks = [
                compareHelpers.differenceComparesType,
                addToResult(compareHelpers.equalBasicTypes, 'equalBasicTypes'),
                addToResult(compareHelpers.equalArrayLike, 'equalArrayLike'),
                addToResult(compareHelpers.properSupersetObject, 'properSubsetObject')
            ];
            options['default'] = true;
            var res = loop(a, b, aParent, bParent, prop, compares, options);
            if (res === true && options.performedDifference) {
                return options.result;
            }
            return res;
        },
        differenceComparesType: function (a, b, aParent, bParent, prop, compares, options) {
            if (typeof compares === 'function') {
                var compareResult = compares(a, b, aParent, bParent, prop, options);
                if (typeof compareResult === 'boolean') {
                    if (compareResult === true) {
                        options.result[prop] = a;
                        return true;
                    } else {
                        return compareResult;
                    }
                } else if (compareResult && typeof compareResult === 'object') {
                    if ('difference' in compareResult) {
                        if (compareResult.difference === h.ignoreType) {
                            return h.ignoreType;
                        } else if (compareResult.difference != null) {
                            options.result[prop] = compareResult.difference;
                            options.performedDifference++;
                            return true;
                        } else {
                            return true;
                        }
                    } else {
                        if (compareHelpers.equalComparesType.apply(this, arguments)) {
                            options.performedDifference++;
                            options.result[prop] = compareResult.union;
                        } else {
                            return false;
                        }
                    }
                }
            }
        },
        union: function (a, b, aParent, bParent, prop, compares, options) {
            options.result = {};
            options.performedUnion = 0;
            options.checks = [
                compareHelpers.unionComparesType,
                addToResult(compareHelpers.equalBasicTypes, 'equalBasicTypes'),
                addToResult(compareHelpers.unionArrayLike, 'unionArrayLike'),
                addToResult(compareHelpers.unionObject, 'unionObject')
            ];
            options.getUnions = [];
            options['default'] = false;
            var res = loop(a, b, aParent, bParent, prop, compares, options);
            if (res === true) {
                return options.result;
            }
            return false;
        },
        unionComparesType: function (a, b, aParent, bParent, prop, compares, options) {
            if (typeof compares === 'function') {
                var compareResult = compares(a, b, aParent, bParent, prop, options);
                if (typeof compareResult === 'boolean') {
                    if (compareResult === true) {
                        options.result[prop] = a;
                        return true;
                    } else {
                        return compareResult;
                    }
                } else if (compareResult && typeof compareResult === 'object') {
                    if (compareResult.getUnion) {
                        if (h.indexOf.call(options.getUnions, compareResult.getUnion) === -1) {
                            options.getUnions.push(compareResult.getUnion);
                        }
                    }
                    if ('union' in compareResult) {
                        if (compareResult.union === h.ignoreType) {
                            return compareResult.union;
                        }
                        if (compareResult.union !== undefined) {
                            options.result[prop] = compareResult.union;
                        }
                        options.performedUnion++;
                        return true;
                    }
                }
            }
        },
        unionObject: function (a, b, aParent, bParent, prop, compares, options) {
            var subsetCompare = function (a, b, aParent, bParent, prop) {
                var compare = compares[prop] === undefined ? compares['*'] : compares[prop];
                if (!loop(a, b, aParent, bParent, prop, compare, options)) {
                    var subsetCheck;
                    if (!(prop in aParent)) {
                        subsetCheck = 'subsetB';
                    }
                    if (!(prop in bParent)) {
                        subsetCheck = 'subsetA';
                    }
                    if (subsetCheck) {
                        if (!options.subset) {
                            options.subset = subsetCheck;
                        }
                        return options.subset === subsetCheck ? undefined : false;
                    }
                    return false;
                }
            };
            var aType = typeof a;
            if (aType === 'object' || aType === 'function') {
                return h.eachInUnique(a, subsetCompare, b, subsetCompare, true);
            }
        },
        unionArrayLike: function (a, b, aParent, bParent, prop, compares, options) {
            if (Array.isArray(a) && Array.isArray(b)) {
                var combined = makeArray(a).concat(makeArray(b));
                h.doubleLoop(combined, function (item, j, cur, i) {
                    var res = !compareHelpers.equal(cur, item, aParent, bParent, undefined, compares['*'], { 'default': false });
                    return res;
                });
                options.result[prop] = combined;
                return true;
            }
        },
        count: function (a, b, aParent, bParent, prop, compares, options) {
            options.checks = [
                compareHelpers.countComparesType,
                compareHelpers.equalBasicTypes,
                compareHelpers.equalArrayLike,
                compareHelpers.loopObject
            ];
            options['default'] = false;
            loop(a, b, aParent, bParent, prop, compares, options);
            if (typeof options.count === 'number') {
                return options.count;
            }
            return Infinity;
        },
        countComparesType: function (a, b, aParent, bParent, prop, compares, options) {
            if (typeof compares === 'function') {
                var compareResult = compares(a, b, aParent, bParent, prop, options);
                if (typeof compareResult === 'boolean') {
                    return true;
                } else if (compareResult && typeof compareResult === 'object') {
                    if (typeof compareResult.count === 'number') {
                        if (!('count' in options) || compareResult.count === options.count) {
                            options.count = compareResult.count;
                        } else {
                            options.count = Infinity;
                        }
                    }
                    return true;
                }
            }
        },
        loopObject: function (a, b, aParent, bParent, prop, compares, options) {
            var aType = typeof a;
            if (aType === 'object' || aType === 'function') {
                each(a, function (aValue, prop) {
                    var compare = compares[prop] === undefined ? compares['*'] : compares[prop];
                    loop(aValue, b[prop], a, b, prop, compare, options);
                });
                return true;
            }
        },
        intersection: function (a, b, aParent, bParent, prop, compares, options) {
            options.result = {};
            options.performedIntersection = 0;
            options.checks = [
                compareHelpers.intersectionComparesType,
                addToResult(compareHelpers.equalBasicTypes, 'equalBasicTypes'),
                addToResult(compareHelpers.intersectionArrayLike, 'intersectionArrayLike'),
                compareHelpers.intersectionObject
            ];
            options['default'] = false;
            var res = loop(a, b, aParent, bParent, prop, compares, options);
            if (res === true) {
                return options.result;
            }
            return false;
        },
        intersectionComparesType: function (a, b, aParent, bParent, prop, compares, options) {
            if (typeof compares === 'function') {
                var compareResult = compares(a, b, aParent, bParent, prop, options);
                if (typeof compareResult === 'boolean') {
                    if (compareResult === true) {
                        options.result[prop] = a;
                        return true;
                    } else {
                        return compareResult;
                    }
                } else if (compareResult && typeof compareResult === 'object') {
                    if ('intersection' in compareResult) {
                        if (compareResult.intersection !== undefined) {
                            options.result[prop] = compareResult.intersection;
                        }
                        options.performedIntersection++;
                        return true;
                    }
                }
            }
        },
        intersectionObject: function (a, b, aParent, bParent, prop, compares, options) {
            var subsetCompare = function (a, b, aParent, bParent, prop) {
                var compare = compares[prop] === undefined ? compares['*'] : compares[prop];
                if (!loop(a, b, aParent, bParent, prop, compare, options)) {
                    return addIntersectedPropertyToResult(a, b, aParent, bParent, prop, compares, options);
                }
            };
            var aType = typeof a;
            if (aType === 'object' || aType === 'function') {
                return h.eachInUnique(a, subsetCompare, b, subsetCompare, true);
            }
        },
        intersectionArrayLike: function (a, b, aParent, bParent, prop, compares, options) {
            if (Array.isArray(a) && Array.isArray(b)) {
                var intersection = [];
                each(makeArray(a), function (cur) {
                    for (var i = 0; i < b.length; i++) {
                        if (compareHelpers.equal(cur, b[i], aParent, bParent, undefined, compares['*'], { 'default': false })) {
                            intersection.push(cur);
                            break;
                        }
                    }
                });
                options.result[prop] = intersection;
                return true;
            }
        }
    };
});
/*can-set@1.1.0#src/get*/
define('can-set@1.1.0#src/get', function (require, exports, module) {
    var compare = require('./compare');
    var h = require('./helpers');
    var each = require('can-util/js/each/each');
    var filterData = function (data, clause, props) {
        return h.filter.call(data, function (item) {
            var isSubset = compare.subset(item, clause, undefined, undefined, undefined, props, {});
            return isSubset;
        });
    };
    module.exports = {
        subsetData: function (a, b, bData, algebra) {
            var aClauseProps = algebra.getClauseProperties(a);
            var bClauseProps = algebra.getClauseProperties(b);
            var options = {};
            var aData = filterData(bData, aClauseProps.where, algebra.clauses.where);
            if (aData.length && (aClauseProps.enabled.order || bClauseProps.enabled.order)) {
                options = {};
                var propName = h.firstProp(aClauseProps.order), compareOrder = algebra.clauses.order[propName];
                aData = aData.sort(function (aItem, bItem) {
                    return compareOrder(a[propName], aItem, bItem);
                });
            }
            if (aData.length && (aClauseProps.enabled.paginate || bClauseProps.enabled.paginate)) {
                options = {};
                compare.subset(aClauseProps.paginate, bClauseProps.paginate, undefined, undefined, undefined, algebra.clauses.paginate, options);
                each(options.getSubsets, function (filter) {
                    aData = filter(a, b, aData, algebra, options);
                });
            }
            return aData;
        }
    };
});
/*can-set@1.1.0#src/set-core*/
define('can-set@1.1.0#src/set-core', function (require, exports, module) {
    var h = require('./helpers');
    var clause = require('./clause');
    var compare = require('./compare');
    var get = require('./get');
    var assign = require('can-util/js/assign/assign');
    var each = require('can-util/js/each/each');
    var makeArray = require('can-util/js/make-array/make-array');
    var isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');
    function Translate(clause, options) {
        if (typeof options === 'string') {
            var path = options;
            options = {
                fromSet: function (set, setRemainder) {
                    return set[path] || {};
                },
                toSet: function (set, wheres) {
                    set[path] = wheres;
                    return set;
                }
            };
        }
        this.clause = clause;
        assign(this, options);
    }
    var Algebra = function () {
        var clauses = this.clauses = {
            where: {},
            order: {},
            paginate: {},
            id: {}
        };
        this.translators = {
            where: new Translate('where', {
                fromSet: function (set, setRemainder) {
                    return setRemainder;
                },
                toSet: function (set, wheres) {
                    return assign(set, wheres);
                }
            })
        };
        var self = this;
        each(arguments, function (arg) {
            if (arg) {
                if (arg instanceof Translate) {
                    self.translators[arg.clause] = arg;
                } else {
                    assign(clauses[arg.constructor.type || 'where'], arg);
                }
            }
        });
    };
    Algebra.make = function (compare, count) {
        if (compare instanceof Algebra) {
            return compare;
        } else {
            return new Algebra(compare, count);
        }
    };
    assign(Algebra.prototype, {
        getClauseProperties: function (set, options) {
            options = options || {};
            var setClone = assign({}, set);
            var clauses = this.clauses;
            var checkClauses = [
                'order',
                'paginate',
                'id'
            ];
            var clauseProps = {
                enabled: {
                    where: true,
                    order: false,
                    paginate: false,
                    id: false
                }
            };
            if (options.omitClauses) {
                checkClauses = h.arrayUnionIntersectionDifference(checkClauses, options.omitClauses).difference;
            }
            each(checkClauses, function (clauseName) {
                var valuesForClause = {};
                var prop;
                for (prop in clauses[clauseName]) {
                    if (prop in setClone) {
                        valuesForClause[prop] = setClone[prop];
                        delete setClone[prop];
                    }
                }
                clauseProps[clauseName] = valuesForClause;
                clauseProps.enabled[clauseName] = !isEmptyObject(valuesForClause);
            });
            clauseProps.where = options.isProperties ? setClone : this.translators.where.fromSet(set, setClone);
            return clauseProps;
        },
        getDifferentClauseTypes: function (aClauses, bClauses) {
            var self = this;
            var differentTypes = [];
            each(clause.TYPES, function (type) {
                if (!self.evaluateOperator(compare.equal, aClauses[type], bClauses[type], { isProperties: true }, { isProperties: true })) {
                    differentTypes.push(type);
                }
            });
            return differentTypes;
        },
        updateSet: function (set, clause, result, useSet) {
            if (result && typeof result === 'object' && useSet !== false) {
                if (this.translators[clause]) {
                    set = this.translators.where.toSet(set, result);
                } else {
                    set = assign(set, result);
                }
                return true;
            } else if (result) {
                return useSet === undefined ? undefined : false;
            } else {
                return false;
            }
        },
        evaluateOperator: function (operator, a, b, aOptions, bOptions, evaluateOptions) {
            aOptions = aOptions || {};
            bOptions = bOptions || {};
            evaluateOptions = assign({
                evaluateWhere: operator,
                evaluatePaginate: operator,
                evaluateOrder: operator,
                shouldEvaluatePaginate: function (aClauseProps, bClauseProps) {
                    return aClauseProps.enabled.paginate || bClauseProps.enabled.paginate;
                },
                shouldEvaluateOrder: function (aClauseProps, bClauseProps) {
                    return aClauseProps.enabled.order && compare.equal(aClauseProps.order, bClauseProps.order, undefined, undefined, undefined, {}, {});
                }
            }, evaluateOptions || {});
            var aClauseProps = this.getClauseProperties(a, aOptions), bClauseProps = this.getClauseProperties(b, bOptions), set = {}, useSet;
            var result = evaluateOptions.evaluateWhere(aClauseProps.where, bClauseProps.where, undefined, undefined, undefined, this.clauses.where, {});
            useSet = this.updateSet(set, 'where', result, useSet);
            if (result && evaluateOptions.shouldEvaluatePaginate(aClauseProps, bClauseProps)) {
                if (evaluateOptions.shouldEvaluateOrder(aClauseProps, bClauseProps)) {
                    result = evaluateOptions.evaluateOrder(aClauseProps.order, bClauseProps.order, undefined, undefined, undefined, {}, {});
                    useSet = this.updateSet(set, 'order', result, useSet);
                }
                if (result) {
                    result = evaluateOptions.evaluatePaginate(aClauseProps.paginate, bClauseProps.paginate, undefined, undefined, undefined, this.clauses.paginate, {});
                    useSet = this.updateSet(set, 'paginate', result, useSet);
                }
            } else if (result && evaluateOptions.shouldEvaluateOrder(aClauseProps, bClauseProps)) {
                result = operator(aClauseProps.order, bClauseProps.order, undefined, undefined, undefined, {}, {});
                useSet = this.updateSet(set, 'order', result, useSet);
            }
            return result && useSet ? set : result;
        },
        equal: function (a, b) {
            return this.evaluateOperator(compare.equal, a, b);
        },
        subset: function (a, b) {
            var aClauseProps = this.getClauseProperties(a);
            var bClauseProps = this.getClauseProperties(b);
            var compatibleSort = true;
            var result;
            if (bClauseProps.enabled.paginate && (aClauseProps.enabled.order || bClauseProps.enabled.order)) {
                compatibleSort = compare.equal(aClauseProps.order, bClauseProps.order, undefined, undefined, undefined, {}, {});
            }
            if (!compatibleSort) {
                result = false;
            } else {
                result = this.evaluateOperator(compare.subset, a, b);
            }
            return result;
        },
        properSubset: function (a, b) {
            return this.subset(a, b) && !this.equal(a, b);
        },
        difference: function (a, b) {
            var aClauseProps = this.getClauseProperties(a);
            var bClauseProps = this.getClauseProperties(b);
            var differentClauses = this.getDifferentClauseTypes(aClauseProps, bClauseProps);
            var result;
            switch (differentClauses.length) {
            case 0: {
                    result = false;
                    break;
                }
            case 1: {
                    var clause = differentClauses[0];
                    result = compare.difference(aClauseProps[clause], bClauseProps[clause], undefined, undefined, undefined, this.clauses[clause], {});
                    if (this.translators[clause] && typeof result === 'object') {
                        result = this.translators[clause].toSet({}, result);
                    }
                    break;
                }
            }
            return result;
        },
        union: function (a, b) {
            return this.evaluateOperator(compare.union, a, b);
        },
        intersection: function (a, b) {
            return this.evaluateOperator(compare.intersection, a, b);
        },
        count: function (set) {
            return this.evaluateOperator(compare.count, set, {});
        },
        has: function (set, props) {
            var aClauseProps = this.getClauseProperties(set);
            var propsClauseProps = this.getClauseProperties(props, { isProperties: true });
            var compatibleSort = true;
            var result;
            if ((propsClauseProps.enabled.paginate || aClauseProps.enabled.paginate) && (propsClauseProps.enabled.order || aClauseProps.enabled.order)) {
                compatibleSort = compare.equal(propsClauseProps.order, aClauseProps.order, undefined, undefined, undefined, {}, {});
            }
            if (!compatibleSort) {
                result = false;
            } else {
                result = this.evaluateOperator(compare.subset, props, set, { isProperties: true }, undefined);
            }
            return result;
        },
        index: function (set, items, item) {
            var aClauseProps = this.getClauseProperties(set);
            var propName = h.firstProp(aClauseProps.order), compare, orderValue;
            if (propName) {
                compare = this.clauses.order[propName];
                orderValue = set[propName];
                return h.index(function (itemA, itemB) {
                    return compare(orderValue, itemA, itemB);
                }, items, item);
            }
            propName = h.firstProp(this.clauses.id);
            if (propName) {
                compare = h.defaultSort;
                orderValue = propName;
                return h.index(function (itemA, itemB) {
                    return compare(orderValue, itemA, itemB);
                }, items, item);
            }
            return;
        },
        getSubset: function (a, b, bData) {
            var aClauseProps = this.getClauseProperties(a);
            var bClauseProps = this.getClauseProperties(b);
            var isSubset = this.subset(assign({}, aClauseProps.where, aClauseProps.paginate), assign({}, bClauseProps.where, bClauseProps.paginate));
            if (isSubset) {
                return get.subsetData(a, b, bData, this);
            }
        },
        getUnion: function (a, b, aItems, bItems) {
            var aClauseProps = this.getClauseProperties(a);
            var bClauseProps = this.getClauseProperties(b);
            var algebra = this;
            var options;
            if (this.subset(a, b)) {
                return bItems;
            } else if (this.subset(b, a)) {
                return aItems;
            }
            var combined;
            if (aClauseProps.enabled.paginate || bClauseProps.enabled.paginate) {
                options = {};
                var isUnion = compare.union(aClauseProps.paginate, bClauseProps.paginate, undefined, undefined, undefined, this.clauses.paginate, options);
                if (!isUnion) {
                    return;
                } else {
                    each(options.getUnions, function (filter) {
                        var items = filter(a, b, aItems, bItems, algebra, options);
                        aItems = items[0];
                        bItems = items[1];
                    });
                    combined = aItems.concat(bItems);
                }
            } else {
                combined = aItems.concat(bItems);
            }
            if (combined.length && aClauseProps.enabled.order && compare.equal(aClauseProps.order, bClauseProps.order, undefined, undefined, undefined, {}, {})) {
                options = {};
                var propName = h.firstProp(aClauseProps.order), compareOrder = algebra.clauses.order[propName];
                combined = combined.sort(function (aItem, bItem) {
                    return compareOrder(a[propName], aItem, bItem);
                });
            }
            return combined;
        },
        id: function (props) {
            var keys = Object.keys(this.clauses.id);
            if (keys.length === 1) {
                return props[keys[0]];
            } else {
                var id = {};
                keys.forEach(function (key) {
                    id[key] = props[key];
                });
                return JSON.stringify(id);
            }
        }
    });
    var callOnAlgebra = function (methodName, algebraArgNumber) {
        return function () {
            var args = makeArray(arguments).slice(0, algebraArgNumber);
            var algebra = Algebra.make(arguments[algebraArgNumber]);
            return algebra[methodName].apply(algebra, args);
        };
    };
    module.exports = {
        Algebra: Algebra,
        Translate: Translate,
        difference: callOnAlgebra('difference', 2),
        equal: callOnAlgebra('equal', 2),
        subset: callOnAlgebra('subset', 2),
        properSubset: callOnAlgebra('properSubset', 2),
        union: callOnAlgebra('union', 2),
        intersection: callOnAlgebra('intersection', 2),
        count: callOnAlgebra('count', 1),
        has: callOnAlgebra('has', 2),
        index: callOnAlgebra('index', 3),
        getSubset: callOnAlgebra('getSubset', 3),
        getUnion: callOnAlgebra('getUnion', 4)
    };
});
/*can-set@1.1.0#src/props*/
define('can-set@1.1.0#src/props', function (require, exports, module) {
    var h = require('./helpers');
    var clause = require('./clause');
    var each = require('can-util/js/each/each');
    var within = function (value, range) {
        return value >= range[0] && value <= range[1];
    };
    var numericProperties = function (setA, setB, property1, property2) {
        return {
            sAv1: +setA[property1],
            sAv2: +setA[property2],
            sBv1: +setB[property1],
            sBv2: +setB[property2]
        };
    };
    var diff = function (setA, setB, property1, property2) {
        var numProps = numericProperties(setA, setB, property1, property2);
        var sAv1 = numProps.sAv1, sAv2 = numProps.sAv2, sBv1 = numProps.sBv1, sBv2 = numProps.sBv2, count = sAv2 - sAv1 + 1;
        var after = {
            difference: [
                sBv2 + 1,
                sAv2
            ],
            intersection: [
                sAv1,
                sBv2
            ],
            union: [
                sBv1,
                sAv2
            ],
            count: count,
            meta: 'after'
        };
        var before = {
            difference: [
                sAv1,
                sBv1 - 1
            ],
            intersection: [
                sBv1,
                sAv2
            ],
            union: [
                sAv1,
                sBv2
            ],
            count: count,
            meta: 'before'
        };
        if (sAv1 === sBv1 && sAv2 === sBv2) {
            return {
                intersection: [
                    sAv1,
                    sAv2
                ],
                union: [
                    sAv1,
                    sAv2
                ],
                count: count,
                meta: 'equal'
            };
        } else if (sAv1 === sBv1 && sBv2 < sAv2) {
            return after;
        } else if (sAv2 === sBv2 && sBv1 > sAv1) {
            return before;
        } else if (within(sAv1, [
                sBv1,
                sBv2
            ]) && within(sAv2, [
                sBv1,
                sBv2
            ])) {
            return {
                intersection: [
                    sAv1,
                    sAv2
                ],
                union: [
                    sBv1,
                    sBv2
                ],
                count: count,
                meta: 'subset'
            };
        } else if (within(sBv1, [
                sAv1,
                sAv2
            ]) && within(sBv2, [
                sAv1,
                sAv2
            ])) {
            return {
                intersection: [
                    sBv1,
                    sBv2
                ],
                difference: [
                    null,
                    null
                ],
                union: [
                    sAv1,
                    sAv2
                ],
                count: count,
                meta: 'superset'
            };
        } else if (sAv1 < sBv1 && within(sAv2, [
                sBv1,
                sBv2
            ])) {
            return before;
        } else if (sBv1 < sAv1 && within(sBv2, [
                sAv1,
                sAv2
            ])) {
            return after;
        } else if (sAv2 === sBv1 - 1) {
            return {
                difference: [
                    sAv1,
                    sAv2
                ],
                union: [
                    sAv1,
                    sBv2
                ],
                count: count,
                meta: 'disjoint-before'
            };
        } else if (sBv2 === sAv1 - 1) {
            return {
                difference: [
                    sAv1,
                    sAv2
                ],
                union: [
                    sBv1,
                    sAv2
                ],
                count: count,
                meta: 'disjoint-after'
            };
        }
        if (!isNaN(count)) {
            return {
                count: count,
                meta: 'disjoint'
            };
        }
    };
    var cleanUp = function (value, enumData) {
        if (!value) {
            return enumData;
        }
        if (!Array.isArray(value)) {
            value = [value];
        }
        if (!value.length) {
            return enumData;
        }
        return value;
    };
    var stringConvert = {
        '0': false,
        'false': false,
        'null': undefined,
        'undefined': undefined
    };
    var convertToBoolean = function (value) {
        if (typeof value === 'string') {
            return value.toLowerCase() in stringConvert ? stringConvert[value.toLowerCase()] : true;
        }
        return value;
    };
    var props = {
        'enum': function (prop, enumData) {
            var compares = new clause.Where({});
            compares[prop] = function (vA, vB, A, B) {
                vA = cleanUp(vA, enumData);
                vB = cleanUp(vB, enumData);
                var data = h.arrayUnionIntersectionDifference(vA, vB);
                if (!data.difference.length) {
                    delete data.difference;
                }
                each(data, function (value, prop) {
                    if (Array.isArray(value)) {
                        if (h.arraySame(enumData, value)) {
                            data[prop] = undefined;
                        } else if (value.length === 1) {
                            data[prop] = value[0];
                        }
                    }
                });
                return data;
            };
            return compares;
        },
        paginate: function (propStart, propEnd, translateToStartEnd, reverseTranslate) {
            var compares = {};
            var makeResult = function (result, index) {
                var res = {};
                each([
                    'intersection',
                    'difference',
                    'union'
                ], function (prop) {
                    if (result[prop]) {
                        var set = {
                            start: result[prop][0],
                            end: result[prop][1]
                        };
                        res[prop] = reverseTranslate(set)[index === 0 ? propStart : propEnd];
                    }
                });
                if (result.count) {
                    res.count = result.count;
                }
                return res;
            };
            compares[propStart] = function (vA, vB, A, B) {
                if (vA === undefined) {
                    return;
                }
                var res = diff(translateToStartEnd(A), translateToStartEnd(B), 'start', 'end');
                var result = makeResult(res, 0);
                result.getSubset = function (a, b, bItems, algebra, options) {
                    return bItems;
                };
                result.getUnion = function (a, b, aItems, bItems, algebra, options) {
                    return [
                        aItems,
                        bItems
                    ];
                };
                return result;
            };
            compares[propEnd] = function (vA, vB, A, B) {
                if (vA === undefined) {
                    return;
                }
                var data = diff(translateToStartEnd(A), translateToStartEnd(B), 'start', 'end');
                var res = makeResult(data, 1);
                res.getSubset = function (a, b, bItems, algebra, options) {
                    var tA = translateToStartEnd(a);
                    var tB = translateToStartEnd(b);
                    var numProps = numericProperties(tA, tB, 'start', 'end');
                    var aStartValue = numProps.sAv1, aEndValue = numProps.sAv2;
                    var bStartValue = numProps.sBv1;
                    if (!('end' in tB) || !('end' in tA)) {
                        return bItems.slice(aStartValue, aEndValue + 1);
                    }
                    return bItems.slice(aStartValue - bStartValue, aEndValue - bStartValue + 1);
                };
                res.getUnion = function (a, b, aItems, bItems, algebra, options) {
                    var tA = translateToStartEnd(a);
                    var tB = translateToStartEnd(b);
                    if (data.meta.indexOf('after') >= 0) {
                        if (data.intersection) {
                            bItems = bItems.slice(0, data.intersection[0] - +tB.start);
                        }
                        return [
                            bItems,
                            aItems
                        ];
                    }
                    if (data.intersection) {
                        aItems = aItems.slice(0, data.intersection[0] - +tA.start);
                    }
                    return [
                        aItems,
                        bItems
                    ];
                };
                return res;
            };
            return new clause.Paginate(compares);
        },
        'boolean': function (propertyName) {
            var compares = new clause.Where({});
            compares[propertyName] = function (propA, propB) {
                propA = convertToBoolean(propA);
                propB = convertToBoolean(propB);
                var notA = !propA, notB = !propB;
                if (propA === notB && propB === notA) {
                    return {
                        difference: !propB,
                        union: undefined
                    };
                } else if (propA === undefined) {
                    return {
                        difference: !propB,
                        intersection: propB,
                        union: undefined
                    };
                } else if (propA === propB) {
                    return true;
                }
            };
            return compares;
        },
        'sort': function (prop, sortFunc) {
            if (!sortFunc) {
                sortFunc = h.defaultSort;
            }
            var compares = {};
            compares[prop] = sortFunc;
            return new clause.Order(compares);
        },
        'id': function (prop) {
            var compares = {};
            compares[prop] = prop;
            return new clause.Id(compares);
        }
    };
    var assignExcept = function (d, s, props) {
        for (var prop in s) {
            if (!props[prop]) {
                d[prop] = s[prop];
            }
        }
        return d;
    };
    var translateToOffsetLimit = function (set, offsetProp, limitProp) {
        var newSet = assignExcept({}, set, {
            start: 1,
            end: 1
        });
        if ('start' in set) {
            newSet[offsetProp] = set.start;
        }
        if ('end' in set) {
            newSet[limitProp] = set.end - set.start + 1;
        }
        return newSet;
    };
    var translateToStartEnd = function (set, offsetProp, limitProp) {
        var except = {};
        except[offsetProp] = except[limitProp] = 1;
        var newSet = assignExcept({}, set, except);
        if (offsetProp in set) {
            newSet.start = parseInt(set[offsetProp], 10);
        }
        if (limitProp in set) {
            newSet.end = newSet.start + parseInt(set[limitProp]) - 1;
        }
        return newSet;
    };
    props.offsetLimit = function (offsetProp, limitProp) {
        offsetProp = offsetProp || 'offset';
        limitProp = limitProp || 'limit';
        return props.paginate(offsetProp, limitProp, function (set) {
            return translateToStartEnd(set, offsetProp, limitProp);
        }, function (set) {
            return translateToOffsetLimit(set, offsetProp, limitProp);
        });
    };
    props.rangeInclusive = function (startIndexProperty, endIndexProperty) {
        startIndexProperty = startIndexProperty || 'start';
        endIndexProperty = endIndexProperty || 'end';
        return props.paginate(startIndexProperty, endIndexProperty, function (set) {
            var except = {};
            except[startIndexProperty] = except[endIndexProperty] = 1;
            var newSet = assignExcept({}, set, except);
            if (startIndexProperty in set) {
                newSet.start = set[startIndexProperty];
            }
            if (endIndexProperty in set) {
                newSet.end = set[endIndexProperty];
            }
            return newSet;
        }, function (set) {
            var except = {
                start: 1,
                end: 1
            };
            var newSet = assignExcept({}, set, except);
            newSet[startIndexProperty] = set.start;
            newSet[endIndexProperty] = set.end;
            return newSet;
        });
    };
    module.exports = props;
});
/*can-set@1.1.0#src/set*/
define('can-set@1.1.0#src/set', function (require, exports, module) {
    var set = require('./set-core');
    var ns = require('can-namespace');
    var props = require('./props');
    var clause = require('./clause');
    set.comparators = props;
    set.props = props;
    set.helpers = require('./helpers');
    set.clause = clause;
    module.exports = ns.set = set;
});
/*can-connect@1.3.8#connect*/
define('can-connect@1.3.8#connect', function (require, exports, module) {
    var assign = require('can-util/js/assign/assign');
    var connect = function (behaviors, options) {
        behaviors = behaviors.map(function (behavior, index) {
            var sortedIndex = -1;
            if (typeof behavior === 'string') {
                sortedIndex = connect.order.indexOf(behavior);
                behavior = behaviorsMap[behavior];
            } else if (behavior.isBehavior) {
                sortedIndex = connect.order.indexOf(behavior.behaviorName);
            } else {
                behavior = connect.behavior(behavior);
            }
            return {
                originalIndex: index,
                sortedIndex: sortedIndex,
                behavior: behavior
            };
        }).sort(function (b1, b2) {
            if (~b1.sortedIndex && ~b2.sortedIndex) {
                return b1.sortedIndex - b2.sortedIndex;
            }
            return b1.originalIndex - b2.originalIndex;
        });
        behaviors = behaviors.map(function (b) {
            return b.behavior;
        });
        var behavior = connect.base(connect.behavior('options', function () {
            return options;
        })());
        behaviors.forEach(function (behave) {
            behavior = behave(behavior);
        });
        if (behavior.init) {
            behavior.init();
        }
        return behavior;
    };
    connect.order = [
        'data/localstorage-cache',
        'data/url',
        'data/parse',
        'cache-requests',
        'data/combine-requests',
        'constructor',
        'constructor/store',
        'can/map',
        'can/ref',
        'fall-through-cache',
        'data/worker',
        'real-time',
        'data/callbacks-cache',
        'data/callbacks',
        'constructor/callbacks-once'
    ];
    connect.behavior = function (name, behavior) {
        if (typeof name !== 'string') {
            behavior = name;
            name = undefined;
        }
        var behaviorMixin = function (base) {
            var Behavior = function () {
            };
            Behavior.name = name;
            Behavior.prototype = base;
            var newBehavior = new Behavior();
            var res = typeof behavior === 'function' ? behavior.apply(newBehavior, arguments) : behavior;
            assign(newBehavior, res);
            newBehavior.__behaviorName = name;
            return newBehavior;
        };
        if (name) {
            behaviorMixin.behaviorName = name;
            behaviorsMap[name] = behaviorMixin;
        }
        behaviorMixin.isBehavior = true;
        return behaviorMixin;
    };
    var behaviorsMap = {};
    module.exports = connect;
});
/*can-connect@1.3.8#base/base*/
define('can-connect@1.3.8#base/base', function (require, exports, module) {
    var connect = require('can-connect/connect');
    module.exports = connect.behavior('base', function (baseConnection) {
        return {
            id: function (instance) {
                var ids = [], algebra = this.algebra;
                if (algebra && algebra.clauses && algebra.clauses.id) {
                    for (var prop in algebra.clauses.id) {
                        ids.push(instance[prop]);
                    }
                }
                if (this.idProp && !ids.length) {
                    ids.push(instance[this.idProp]);
                }
                if (!ids.length) {
                    ids.push(instance.id);
                }
                return ids.length > 1 ? ids.join('@|@') : ids[0];
            },
            idProp: baseConnection.idProp || 'id',
            listSet: function (list) {
                return list[this.listSetProp];
            },
            listSetProp: '__listSet',
            init: function () {
            }
        };
    });
});
/*can-connect@1.3.8#can-connect*/
define('can-connect@1.3.8#can-connect', function (require, exports, module) {
    var connect = require('can-connect/connect');
    var base = require('can-connect/base/base');
    var ns = require('can-namespace');
    connect.base = base;
    module.exports = ns.connect = connect;
});
/*can-fixture@1.0.13#helpers/getid*/
define('can-fixture@1.0.13#helpers/getid', function (require, exports, module) {
    module.exports = function (xhrSettings, fixtureSettings) {
        var id = xhrSettings.data.id;
        if (id === undefined && typeof xhrSettings.data === 'number') {
            id = xhrSettings.data;
        }
        if (id === undefined) {
            xhrSettings.url.replace(/\/(\d+)(\/|$|\.)/g, function (all, num) {
                id = num;
            });
        }
        if (id === undefined) {
            id = xhrSettings.url.replace(/\/(\w+)(\/|$|\.)/g, function (all, num) {
                if (num !== 'update') {
                    id = num;
                }
            });
        }
        if (id === undefined) {
            id = Math.round(Math.random() * 1000);
        }
        return id;
    };
});
/*can-fixture@1.0.13#helpers/legacyStore*/
define('can-fixture@1.0.13#helpers/legacyStore', function (require, exports, module) {
    var getId = require('./getid');
    var canSet = require('can-set');
    var isArrayLike = require('can-util/js/is-array-like/is-array-like');
    var each = require('can-util/js/each/each');
    var assign = require('can-util/js/assign/assign');
    module.exports = function (count, make, filter) {
        var currentId = 0, items, findOne = function (id) {
                for (var i = 0; i < items.length; i++) {
                    if (id == items[i].id) {
                        return items[i];
                    }
                }
            }, methods = {}, types, reset;
        if (isArrayLike(count) && typeof count[0] === 'string') {
            types = count;
            count = make;
            make = filter;
            filter = arguments[3];
        } else if (typeof count === 'string') {
            types = [
                count + 's',
                count
            ];
            count = make;
            make = filter;
            filter = arguments[3];
        }
        if (typeof count === 'number') {
            items = [];
            reset = function () {
                items = [];
                for (var i = 0; i < count; i++) {
                    var item = make(i, items);
                    if (!item.id) {
                        item.id = i;
                    }
                    currentId = Math.max(item.id + 1, currentId + 1) || items.length;
                    items.push(item);
                }
            };
        } else {
            filter = make;
            var initialItems = count;
            reset = function () {
                items = initialItems.slice(0);
            };
        }
        assign(methods, {
            getListData: function (request) {
                request = request || {};
                var retArr = items.slice(0);
                request.data = request.data || {};
                each((request.data.order || []).slice(0).reverse(), function (name) {
                    var split = name.split(' ');
                    retArr = retArr.sort(function (a, b) {
                        if (split[1].toUpperCase() !== 'ASC') {
                            if (a[split[0]] < b[split[0]]) {
                                return 1;
                            } else if (a[split[0]] === b[split[0]]) {
                                return 0;
                            } else {
                                return -1;
                            }
                        } else {
                            if (a[split[0]] < b[split[0]]) {
                                return -1;
                            } else if (a[split[0]] === b[split[0]]) {
                                return 0;
                            } else {
                                return 1;
                            }
                        }
                    });
                });
                each((request.data.group || []).slice(0).reverse(), function (name) {
                    var split = name.split(' ');
                    retArr = retArr.sort(function (a, b) {
                        return a[split[0]] > b[split[0]];
                    });
                });
                var offset = parseInt(request.data.offset, 10) || 0, limit = parseInt(request.data.limit, 10) || items.length - offset, i = 0;
                for (var param in request.data) {
                    i = 0;
                    if (request.data[param] !== undefined && (param.indexOf('Id') !== -1 || param.indexOf('_id') !== -1)) {
                        while (i < retArr.length) {
                            if (request.data[param] != retArr[i][param]) {
                                retArr.splice(i, 1);
                            } else {
                                i++;
                            }
                        }
                    }
                }
                if (typeof filter === 'function') {
                    i = 0;
                    while (i < retArr.length) {
                        if (!filter(retArr[i], request)) {
                            retArr.splice(i, 1);
                        } else {
                            i++;
                        }
                    }
                } else if (typeof filter === 'object') {
                    i = 0;
                    while (i < retArr.length) {
                        var subset = canSet.subset(retArr[i], request.data, filter);
                        if (!subset) {
                            retArr.splice(i, 1);
                        } else {
                            i++;
                        }
                    }
                }
                var responseData = {
                    'count': retArr.length,
                    'data': retArr.slice(offset, offset + limit)
                };
                each([
                    'limit',
                    'offset'
                ], function (prop) {
                    if (prop in request.data) {
                        responseData[prop] = request.data[prop];
                    }
                });
                return responseData;
            },
            getData: function (request, response) {
                var item = findOne(getId(request));
                if (typeof item === 'undefined') {
                    return response(404, 'Requested resource not found');
                }
                response(item);
            },
            updateData: function (request, response) {
                var id = getId(request), item = findOne(id);
                if (typeof item === 'undefined') {
                    return response(404, 'Requested resource not found');
                }
                assign(item, request.data);
                response({ id: id }, { location: request.url || '/' + getId(request) });
            },
            destroyData: function (request, response) {
                var id = getId(request), item = findOne(id);
                if (typeof item === 'undefined') {
                    return response(404, 'Requested resource not found');
                }
                for (var i = 0; i < items.length; i++) {
                    if (items[i].id == id) {
                        items.splice(i, 1);
                        break;
                    }
                }
                return {};
            },
            createData: function (settings, response) {
                var item = typeof make === 'function' ? make(items.length, items) : {};
                assign(item, settings.data);
                if (!item.id) {
                    item.id = currentId++;
                }
                items.push(item);
                response({ id: item.id }, { location: settings.url + '/' + item.id });
            }
        });
        reset();
        return assign({
            findAll: methods.getListData,
            findOne: methods.getData,
            create: methods.createData,
            update: methods.updateData,
            destroy: methods.destroyData,
            getId: getId,
            find: function (settings) {
                return findOne(getId(settings));
            },
            reset: reset
        }, methods);
    };
});
/*can-connect@1.3.8#helpers/get-items*/
define('can-connect@1.3.8#helpers/get-items', function (require, exports, module) {
    var isArray = require('can-util/js/is-array/is-array');
    module.exports = function (data) {
        if (isArray(data)) {
            return data;
        } else {
            return data.data;
        }
    };
});
/*can-connect@1.3.8#helpers/sorted-set-json*/
define('can-connect@1.3.8#helpers/sorted-set-json', function (require, exports, module) {
    var forEach = [].forEach;
    var keys = Object.keys;
    module.exports = function (set) {
        if (set == null) {
            return set;
        } else {
            var sorted = {};
            forEach.call(keys(set).sort(), function (prop) {
                sorted[prop] = set[prop];
            });
            return JSON.stringify(sorted);
        }
    };
});
/*can-connect@1.3.8#helpers/overwrite*/
define('can-connect@1.3.8#helpers/overwrite', function (require, exports, module) {
    module.exports = function (d, s, id) {
        for (var prop in d) {
            if (prop !== id && !(prop in s)) {
                delete d[prop];
            }
        }
        for (prop in s) {
            d[prop] = s[prop];
        }
        return d;
    };
});
/*can-connect@1.3.8#helpers/set-add*/
define('can-connect@1.3.8#helpers/set-add', function (require, exports, module) {
    var canSet = require('can-set');
    module.exports = function (connection, setItems, items, item, algebra) {
        var index = canSet.index(setItems, items, item, algebra);
        if (index === undefined) {
            index = items.length;
        }
        var copy = items.slice(0);
        copy.splice(index, 0, item);
        return copy;
    };
});
/*can-connect@1.3.8#helpers/get-index-by-id*/
define('can-connect@1.3.8#helpers/get-index-by-id', function (require, exports, module) {
    module.exports = function (connection, props, items) {
        var id = connection.id(props);
        for (var i = 0; i < items.length; i++) {
            var connId = connection.id(items[i]);
            if (id == connId) {
                return i;
            }
        }
        return -1;
    };
});
/*can-connect@1.3.8#helpers/clone-data*/
define('can-connect@1.3.8#helpers/clone-data', function (require, exports, module) {
    var isArray = require('can-util/js/is-array/is-array');
    var deepAssign = require('can-util/js/deep-assign/deep-assign');
    module.exports = function (data) {
        return isArray(data) ? data.slice(0) : deepAssign({}, data);
    };
});
/*can-connect@1.3.8#data/memory-cache/memory-cache*/
define('can-connect@1.3.8#data/memory-cache/memory-cache', function (require, exports, module) {
    var getItems = require('can-connect/helpers/get-items');
    var connect = require('can-connect');
    var sortedSetJSON = require('can-connect/helpers/sorted-set-json');
    var canSet = require('can-set');
    var overwrite = require('can-connect/helpers/overwrite');
    var setAdd = require('can-connect/helpers/set-add');
    var indexOf = require('can-connect/helpers/get-index-by-id');
    var assign = require('can-util/js/assign/assign');
    var cloneData = require('can-connect/helpers/clone-data');
    module.exports = connect.behavior('data/memory-cache', function (baseConnection) {
        var behavior = {
            _sets: {},
            getSetData: function () {
                return this._sets;
            },
            __getListData: function (set) {
                var setsData = this.getSetData();
                var setData = setsData[sortedSetJSON(set)];
                if (setData) {
                    return setData.items;
                }
            },
            _instances: {},
            getInstance: function (id) {
                return this._instances[id];
            },
            removeSet: function (setKey, noUpdate) {
                var sets = this.getSetData();
                delete sets[setKey];
                if (noUpdate !== true) {
                    this.updateSets();
                }
            },
            updateSets: function () {
            },
            updateInstance: function (props) {
                var id = this.id(props);
                if (!(id in this._instances)) {
                    this._instances[id] = props;
                } else {
                    overwrite(this._instances[id], props, this.idProp);
                }
                return this._instances[id];
            },
            updateSet: function (setDatum, items, newSet) {
                var newSetKey = newSet ? sortedSetJSON(newSet) : setDatum.setKey;
                if (newSet) {
                    if (newSetKey !== setDatum.setKey) {
                        var sets = this.getSetData();
                        var oldSetKey = setDatum.setKey;
                        sets[newSetKey] = setDatum;
                        setDatum.setKey = newSetKey;
                        setDatum.set = assign({}, newSet);
                        this.removeSet(oldSetKey);
                    }
                }
                setDatum.items = items;
                var self = this;
                items.forEach(function (item) {
                    self.updateInstance(item);
                });
            },
            addSet: function (set, data) {
                var items = getItems(data);
                var sets = this.getSetData();
                var setKey = sortedSetJSON(set);
                sets[setKey] = {
                    setKey: setKey,
                    items: items,
                    set: assign({}, set)
                };
                var self = this;
                items.forEach(function (item) {
                    self.updateInstance(item);
                });
                this.updateSets();
            },
            _eachSet: function (cb) {
                var sets = this.getSetData();
                var self = this;
                var loop = function (setDatum, setKey) {
                    return cb.call(self, setDatum, setKey, function () {
                        return setDatum.items;
                    });
                };
                for (var setKey in sets) {
                    var setDatum = sets[setKey];
                    var result = loop(setDatum, setKey);
                    if (result !== undefined) {
                        return result;
                    }
                }
            },
            _getSets: function () {
                var sets = [], setsData = this.getSetData();
                for (var prop in setsData) {
                    sets.push(setsData[prop].set);
                }
                return sets;
            },
            getSets: function () {
                return Promise.resolve(this._getSets());
            },
            clear: function () {
                this._instances = {};
                this._sets = {};
            },
            getListData: function (set) {
                set = set || {};
                var listData = this.getListDataSync(set);
                if (listData) {
                    return Promise.resolve(listData);
                }
                return Promise.reject({
                    message: 'no data',
                    error: 404
                });
            },
            getListDataSync: function (set) {
                var sets = this._getSets();
                for (var i = 0; i < sets.length; i++) {
                    var checkSet = sets[i];
                    if (canSet.subset(set, checkSet, this.algebra)) {
                        var source = this.__getListData(checkSet);
                        var items = canSet.getSubset(set, checkSet, source, this.algebra);
                        return {
                            data: items,
                            count: source.length
                        };
                    }
                }
            },
            _getListData: function (set) {
                return this.getListDataSync(set);
            },
            updateListData: function (data, set) {
                set = set || {};
                var clonedData = cloneData(data);
                var items = getItems(clonedData);
                var sets = this.getSetData();
                var self = this;
                for (var setKey in sets) {
                    var setDatum = sets[setKey];
                    var union = canSet.union(setDatum.set, set, this.algebra);
                    if (union) {
                        var getSet = assign({}, setDatum.set);
                        return this.getListData(getSet).then(function (setData) {
                            self.updateSet(setDatum, canSet.getUnion(getSet, set, getItems(setData), items, self.algebra), union);
                        });
                    }
                }
                this.addSet(set, clonedData);
                return Promise.resolve();
            },
            getData: function (params) {
                var id = this.id(params);
                var res = this.getInstance(id);
                if (res) {
                    return Promise.resolve(res);
                } else {
                    return Promise.reject({
                        message: 'no data',
                        error: 404
                    });
                }
            },
            createData: function (props) {
                var self = this;
                var instance = this.updateInstance(props);
                this._eachSet(function (setDatum, setKey, getItems) {
                    if (canSet.has(setDatum.set, instance, this.algebra)) {
                        self.updateSet(setDatum, setAdd(self, setDatum.set, getItems(), instance, self.algebra), setDatum.set);
                    }
                });
                return Promise.resolve(assign({}, instance));
            },
            updateData: function (props) {
                var self = this;
                var instance = this.updateInstance(props);
                this._eachSet(function (setDatum, setKey, getItems) {
                    var items = getItems();
                    var index = indexOf(self, instance, items);
                    if (canSet.subset(instance, setDatum.set, this.algebra)) {
                        if (index === -1) {
                            self.updateSet(setDatum, setAdd(self, setDatum.set, getItems(), instance, self.algebra));
                        } else {
                            items.splice(index, 1, instance);
                            self.updateSet(setDatum, items);
                        }
                    } else if (index !== -1) {
                        items.splice(index, 1);
                        self.updateSet(setDatum, items);
                    }
                });
                return Promise.resolve(assign({}, instance));
            },
            destroyData: function (props) {
                var self = this;
                this._eachSet(function (setDatum, setKey, getItems) {
                    var items = getItems();
                    var index = indexOf(self, props, items);
                    if (index !== -1) {
                        items.splice(index, 1);
                        self.updateSet(setDatum, items);
                    }
                });
                var id = this.id(props);
                delete this._instances[id];
                return Promise.resolve(assign({}, props));
            }
        };
        return behavior;
    });
});
/*can-fixture@1.0.13#store*/
define('can-fixture@1.0.13#store', function (require, exports, module) {
    var canSet = require('can-set');
    var connect = require('can-connect');
    var legacyStore = require('./helpers/legacyStore');
    var each = require('can-util/js/each/each');
    var assign = require('can-util/js/assign/assign');
    var isArrayLike = require('can-util/js/is-array-like/is-array-like');
    var dataMemoryCache = require('can-connect/data/memory-cache/memory-cache');
    var firstProp = function (obj) {
        for (var prop in obj) {
            return prop;
        }
    };
    var connectToConnection = function (method) {
        return function (req, res) {
            this.connection[method](req.data).then(function (data) {
                res(data);
            }, function (err) {
                res(403, err);
            });
        };
    };
    var makeMakeItems = function (baseItems, idProp) {
        return function () {
            var items = [], maxId = 0;
            each(baseItems, function (item) {
                items.push(JSON.parse(JSON.stringify(item)));
                maxId = Math.max(item[idProp] + 1, maxId + 1) || items.length;
            });
            return {
                maxId: maxId,
                items: items
            };
        };
    };
    var Store = function (connection, makeItems, idProp) {
        this.connection = connection;
        this.makeItems = makeItems;
        this.idProp = idProp;
        this.reset();
        for (var method in Store.prototype) {
            this[method] = this[method].bind(this);
        }
    };
    assign(Store.prototype, {
        getListData: connectToConnection('getListData'),
        getData: connectToConnection('getData'),
        createData: function (req, res) {
            var idProp = this.idProp;
            req.data[idProp] = ++this.maxId;
            this.connection.createData(req.data).then(function (data) {
                var responseData = {};
                responseData[idProp] = req.data[idProp];
                res(responseData);
            }, function (err) {
                res(403, err);
            });
        },
        updateData: connectToConnection('updateData'),
        destroyData: connectToConnection('destroyData'),
        reset: function (newItems) {
            if (newItems) {
                this.makeItems = makeMakeItems(newItems, this.idProp);
            }
            var itemData = this.makeItems();
            this.maxId = itemData.maxId;
            this.connection.addSet({}, { data: itemData.items });
        },
        get: function (params) {
            var id = this.connection.id(params);
            return this.connection.getInstance(id);
        },
        getList: function (set) {
            return this.connection._getListData(set);
        }
    });
    each({
        findAll: 'getListData',
        findOne: 'getData',
        create: 'createData',
        update: 'updateData',
        destroy: 'destroyData'
    }, function (method, prop) {
        Store.prototype[prop] = function () {
            return this[method].apply(this, arguments);
        };
    });
    Store.make = function (count, make, algebra) {
        var isNew = false;
        if (count instanceof canSet.Algebra || make instanceof canSet.Algebra || algebra instanceof canSet.Algebra) {
            isNew = true;
        }
        if (!isNew) {
            return legacyStore.apply(this, arguments);
        }
        var makeItems, idProp;
        if (typeof count === 'number') {
            idProp = firstProp(algebra.clauses.id || {}) || 'id';
            makeItems = function () {
                var items = [];
                var maxId = 0;
                for (var i = 0; i < count; i++) {
                    var item = make(i, items);
                    if (!item[idProp]) {
                        item[idProp] = i;
                    }
                    maxId = Math.max(item[idProp] + 1, maxId + 1) || items.length;
                    items.push(item);
                }
                return {
                    maxId: maxId,
                    items: items
                };
            };
        } else if (isArrayLike(count)) {
            algebra = make;
            idProp = firstProp(algebra.clauses.id || {}) || 'id';
            makeItems = makeMakeItems(count, idProp);
        }
        var connection = connect([dataMemoryCache], {
            algebra: algebra,
            idProp: idProp
        });
        return new Store(connection, makeItems, idProp);
    };
    module.exports = Store;
});
/*can-fixture@1.0.13#core*/
define('can-fixture@1.0.13#core', function (require, exports, module) {
    var canSet = require('can-set');
    var sub = require('can-util/js/string/string').sub;
    var each = require('can-util/js/each/each');
    var assign = require('can-util/js/assign/assign');
    var isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');
    var canLog = require('can-util/js/log/log');
    require('./store');
    var fixtures = [];
    exports.fixtures = fixtures;
    exports.add = function (settings, fixture) {
        if (fixture && (fixture.getData || fixture.getListData)) {
            var root = settings, store = fixture, idProp = store.idProp, itemRegex = new RegExp('\\/\\{' + idProp + '\\}.*'), rootIsItemUrl = itemRegex.test(root), getListUrl = rootIsItemUrl ? root.replace(itemRegex, '') : root, getItemUrl = rootIsItemUrl ? root : root.trim() + '/{' + idProp + '}';
            fixture = undefined;
            settings = {};
            settings['GET ' + getItemUrl] = store.getData;
            settings['DELETE ' + getItemUrl] = store.destroyData;
            settings['PUT ' + getItemUrl] = store.updateData;
            settings['GET ' + getListUrl] = store.getListData;
            settings['POST ' + getListUrl] = store.createData;
        }
        if (fixture !== undefined) {
            if (typeof settings === 'string') {
                var matches = settings.match(/(GET|POST|PUT|DELETE|PATCH) (.+)/i);
                if (!matches) {
                    settings = { url: settings };
                } else {
                    settings = {
                        url: matches[2],
                        type: matches[1]
                    };
                }
            }
            var index = exports.index(settings, true);
            if (index > -1) {
                fixtures.splice(index, 1);
            }
            if (fixture == null) {
                return;
            }
            if (typeof fixture === 'object') {
                var data = fixture;
                fixture = function () {
                    return data;
                };
            }
            settings.fixture = fixture;
            fixtures.unshift(settings);
        } else {
            each(settings, function (fixture, url) {
                exports.add(url, fixture);
            });
        }
    };
    var $fixture = exports.add;
    $fixture.on = true;
    $fixture.delay = 10;
    exports.callDynamicFixture = function (xhrSettings, fixtureSettings, cb) {
        xhrSettings.data = fixtureSettings.data;
        var response = function () {
            var res = exports.extractResponse.apply(xhrSettings, arguments);
            return cb.apply(this, res);
        };
        var callFixture = function () {
            var result = fixtureSettings.fixture(xhrSettings, response, xhrSettings.headers, fixtureSettings);
            if (result !== undefined) {
                response(200, result);
            }
        };
        if (!xhrSettings.async) {
            callFixture();
            return null;
        } else {
            return setTimeout(callFixture, $fixture.delay);
        }
    };
    exports.index = function (settings, exact) {
        for (var i = 0; i < fixtures.length; i++) {
            if (exports.matches(settings, fixtures[i], exact)) {
                return i;
            }
        }
        return -1;
    };
    exports.get = function (xhrSettings) {
        if (!$fixture.on) {
            return;
        }
        var index = exports.index(xhrSettings, true);
        if (index === -1) {
            index = exports.index(xhrSettings, false);
        }
        var fixtureSettings = index >= 0 ? assign({}, fixtures[index]) : undefined;
        if (fixtureSettings) {
            var url = fixtureSettings.fixture, data = exports.dataFromUrl(fixtureSettings.url, xhrSettings.url);
            if (typeof fixtureSettings.fixture === 'string') {
                if (data) {
                    url = sub(url, data);
                }
                fixtureSettings.url = url;
                fixtureSettings.data = null;
                fixtureSettings.type = 'GET';
                if (!fixtureSettings.error) {
                    fixtureSettings.error = function (xhr, error, message) {
                        throw 'fixtures.js Error ' + error + ' ' + message;
                    };
                }
            } else {
                var xhrData = assign({}, xhrSettings.data || {});
                fixtureSettings.data = assign(xhrData, data);
            }
        }
        return fixtureSettings;
    };
    exports.matches = function (settings, fixture, exact) {
        if (exact) {
            return canSet.equal(settings, fixture, {
                fixture: function () {
                    return true;
                }
            });
        } else {
            return canSet.subset(settings, fixture, exports.defaultCompare);
        }
    };
    var isEmptyOrNull = function (a, b) {
        if (a == null && isEmptyObject(b)) {
            return true;
        } else if (b == null && isEmptyObject(a)) {
            return true;
        } else {
            return canSet.equal(a, b);
        }
    };
    var isEmptyOrSubset = function (a, b) {
        if (a == null && isEmptyObject(b)) {
            return true;
        } else if (b == null && isEmptyObject(a)) {
            return true;
        } else {
            return canSet.subset(a, b);
        }
    };
    exports.defaultCompare = {
        url: function (a, b) {
            return !!exports.dataFromUrl(b, a);
        },
        fixture: function () {
            return true;
        },
        xhr: function () {
            return true;
        },
        type: function (a, b) {
            return b && a ? a.toLowerCase() === b.toLowerCase() : b === a;
        },
        method: function (a, b) {
            return b && a ? a.toLowerCase() === b.toLowerCase() : b === a;
        },
        helpers: function () {
            return true;
        },
        headers: isEmptyOrNull,
        data: isEmptyOrSubset
    };
    var replacer = /\{([^\}]+)\}/g;
    exports.dataFromUrl = function (fixtureUrl, url) {
        if (!fixtureUrl) {
            return {};
        }
        var order = [], fixtureUrlAdjusted = fixtureUrl.replace('.', '\\.').replace('?', '\\?'), res = new RegExp(fixtureUrlAdjusted.replace(replacer, function (whole, part) {
                order.push(part);
                return '([^/]+)';
            }) + '$').exec(url), data = {};
        if (!res) {
            return null;
        }
        res.shift();
        each(order, function (name) {
            data[name] = res.shift();
        });
        return data;
    };
    exports.extractResponse = function (status, response, headers, statusText) {
        if (typeof status !== 'number') {
            headers = response;
            response = status;
            status = 200;
        }
        if (typeof headers === 'string') {
            statusText = headers;
            headers = {};
        }
        return [
            status,
            response,
            headers,
            statusText
        ];
    };
});
/*can-fixture@1.0.13#helpers/deparam*/
define('can-fixture@1.0.13#helpers/deparam', function (require, exports, module) {
    var each = require('can-util/js/each/each');
    var digitTest = /^\d+$/, keyBreaker = /([^\[\]]+)|(\[\])/g, paramTest = /([^?#]*)(#.*)?$/, prep = function (str) {
            return decodeURIComponent(str.replace(/\+/g, ' '));
        };
    module.exports = function (params) {
        var data = {}, pairs, lastPart;
        if (params && paramTest.test(params)) {
            pairs = params.split('&');
            each(pairs, function (pair) {
                var parts = pair.split('='), key = prep(parts.shift()), value = prep(parts.join('=')), current = data;
                if (key) {
                    parts = key.match(keyBreaker);
                    for (var j = 0, l = parts.length - 1; j < l; j++) {
                        if (!current[parts[j]]) {
                            current[parts[j]] = digitTest.test(parts[j + 1]) || parts[j + 1] === '[]' ? [] : {};
                        }
                        current = current[parts[j]];
                    }
                    lastPart = parts.pop();
                    if (lastPart === '[]') {
                        current.push(value);
                    } else {
                        current[lastPart] = value;
                    }
                }
            });
        }
        return data;
    };
});
/*can-fixture@1.0.13#xhr*/
define('can-fixture@1.0.13#xhr', function (require, exports, module) {
    (function (global) {
        var fixtureCore = require('./core');
        var deparam = require('./helpers/deparam');
        var assign = require('can-util/js/assign/assign');
        var each = require('can-util/js/each/each');
        var canLog = require('can-util/js/log/log');
        var XHR = XMLHttpRequest, GLOBAL = typeof global !== 'undefined' ? global : window;
        var props = [
            'type',
            'url',
            'async',
            'response',
            'responseText',
            'responseType',
            'responseXML',
            'responseURL',
            'status',
            'statusText',
            'readyState'
        ];
        var events = [
            'abort',
            'error',
            'load',
            'loadend',
            'loadstart',
            'progress',
            'readystatechange'
        ];
        (function () {
            var x = new XHR();
            for (var prop in x) {
                if (prop.indexOf('on') === 0) {
                    if (events.indexOf(prop.substr(2)) === -1) {
                        events.push(prop.substr(2));
                    }
                } else if (props.indexOf(prop) === -1 && typeof x[prop] !== 'function') {
                    props.push(prop);
                }
            }
        }());
        function callEvents(xhr, ev) {
            var evs = xhr.__events[ev] || [], fn;
            for (var i = 0, len = evs.length; i < len; i++) {
                fn = evs[i];
                fn.call(xhr);
            }
        }
        GLOBAL.XMLHttpRequest = function () {
            var mockXHR = this;
            var realXHR = new XHR();
            this._xhr = realXHR;
            this._requestHeaders = {};
            this.__events = {};
            each(events, function (eventName) {
                realXHR['on' + eventName] = function () {
                    callEvents(mockXHR, eventName);
                    if (mockXHR['on' + eventName]) {
                        return mockXHR['on' + eventName].apply(mockXHR, arguments);
                    }
                };
            });
            this.onload = null;
        };
        GLOBAL.XMLHttpRequest._XHR = XHR;
        assign(XMLHttpRequest.prototype, {
            setRequestHeader: function (name, value) {
                this._requestHeaders[name] = value;
            },
            open: function (type, url, async) {
                this.type = type;
                this.url = url;
                this.async = async === false ? false : true;
            },
            getAllResponseHeaders: function () {
                return this._xhr.getAllResponseHeaders.apply(this._xhr, arguments);
            },
            addEventListener: function (ev, fn) {
                var evs = this.__events[ev] = this.__events[ev] || [];
                evs.push(fn);
            },
            removeEventListener: function (ev, fn) {
                var evs = this.__events[ev] = this.__events[ev] || [];
                var idx = evs.indexOf(fn);
                if (idx >= 0) {
                    evs.splice(idx, 1);
                }
            },
            setDisableHeaderCheck: function (val) {
                this._disableHeaderCheck = !!val;
            },
            getResponseHeader: function (key) {
                return this._xhr.getResponseHeader(key);
            },
            abort: function () {
                var xhr = this._xhr;
                if (this.timeoutId !== undefined) {
                    clearTimeout(this.timeoutId);
                    xhr.open(this.type, this.url, this.async === false ? false : true);
                    xhr.send();
                }
                return xhr.abort();
            },
            send: function (data) {
                var type = this.type.toLowerCase() || 'get';
                var xhrSettings = {
                    url: this.url,
                    data: data,
                    headers: this._requestHeaders,
                    type: type,
                    method: type,
                    async: this.async,
                    xhr: this
                };
                if (!xhrSettings.data && xhrSettings.type === 'get' || xhrSettings.type === 'delete') {
                    xhrSettings.data = deparam(xhrSettings.url.split('?')[1]);
                    xhrSettings.url = xhrSettings.url.split('?')[0];
                }
                if (typeof xhrSettings.data === 'string') {
                    try {
                        xhrSettings.data = JSON.parse(xhrSettings.data);
                    } catch (e) {
                        xhrSettings.data = deparam(xhrSettings.data);
                    }
                }
                var fixtureSettings = fixtureCore.get(xhrSettings);
                var mockXHR = this;
                if (fixtureSettings && typeof fixtureSettings.fixture === 'function') {
                    this.timeoutId = fixtureCore.callDynamicFixture(xhrSettings, fixtureSettings, function (status, body, headers, statusText) {
                        body = typeof body === 'string' ? body : JSON.stringify(body);
                        mockXHR._xhr = {
                            open: function () {
                            },
                            send: function () {
                            },
                            abort: function () {
                            },
                            getResponseHeader: function () {
                            }
                        };
                        assign(mockXHR, {
                            readyState: 4,
                            status: status
                        });
                        var success = status >= 200 && status < 300 || status === 304;
                        if (success) {
                            assign(mockXHR, {
                                statusText: statusText || 'OK',
                                responseText: body
                            });
                        } else {
                            assign(mockXHR, {
                                statusText: statusText || 'error',
                                responseText: body
                            });
                        }
                        mockXHR.getAllResponseHeaders = function () {
                            var ret = [];
                            each(headers || {}, function (value, name) {
                                Array.prototype.push.apply(ret, [
                                    name,
                                    ': ',
                                    value,
                                    '\r\n'
                                ]);
                            });
                            return ret.join('');
                        };
                        if (mockXHR.onreadystatechange) {
                            mockXHR.onreadystatechange({ target: mockXHR });
                        }
                        callEvents(mockXHR, 'progress');
                        if (mockXHR.onprogress) {
                            mockXHR.onprogress();
                        }
                        callEvents(mockXHR, 'load');
                        if (mockXHR.onload) {
                            mockXHR.onload();
                        }
                        callEvents(mockXHR, 'loadend');
                        if (mockXHR.onloadend) {
                            mockXHR.onloadend();
                        }
                    });
                    return;
                }
                var makeRequest = function () {
                    mockXHR._xhr.open(mockXHR._xhr.type, mockXHR._xhr.url, mockXHR._xhr.async);
                    if (mockXHR._requestHeaders) {
                        Object.keys(mockXHR._requestHeaders).forEach(function (key) {
                            mockXHR._xhr.setRequestHeader(key, mockXHR._requestHeaders[key]);
                        });
                    }
                    return mockXHR._xhr.send(data);
                };
                if (fixtureSettings && typeof fixtureSettings.fixture === 'number') {
                    canLog.log(xhrSettings.url + ' -> delay ' + fixtureSettings.fixture + 'ms');
                    this.timeoutId = setTimeout(makeRequest, fixtureSettings.fixture);
                    return;
                }
                if (fixtureSettings) {
                    canLog.log(xhrSettings.url + ' -> ' + fixtureSettings.url);
                    assign(mockXHR, fixtureSettings);
                }
                return makeRequest();
            }
        });
        each(props, function (prop) {
            Object.defineProperty(XMLHttpRequest.prototype, prop, {
                get: function () {
                    return this._xhr[prop];
                },
                set: function (newVal) {
                    try {
                        this._xhr[prop] = newVal;
                    } catch (e) {
                    }
                }
            });
        });
    }(function () {
        return this;
    }()));
});
/*can-fixture@1.0.13#fixture*/
define('can-fixture@1.0.13#fixture', function (require, exports, module) {
    var core = require('./core');
    var fixture = core.add;
    var Store = require('./store');
    require('./xhr');
    var assign = require('can-util/js/assign/assign');
    var ns = require('can-namespace');
    var noop = function () {
    };
    assign(fixture, {
        rand: function randomize(arr, min, max) {
            if (typeof arr === 'number') {
                if (typeof min === 'number') {
                    return arr + Math.floor(Math.random() * (min - arr + 1));
                } else {
                    return Math.floor(Math.random() * (arr + 1));
                }
            }
            var choices = arr.slice(0);
            if (min === undefined) {
                min = 1;
                max = choices.length;
            } else if (max === undefined) {
                max = min;
            }
            var result = [];
            var selectedCount = min + Math.round(randomize(max - min));
            for (var i = 0; i < selectedCount; i++) {
                var selectedIndex = randomize(choices.length - 1), selected = choices.splice(selectedIndex, 1)[0];
                result.push(selected);
            }
            return result;
        },
        xhr: function (xhr) {
            return assign({}, {
                abort: noop,
                getAllResponseHeaders: function () {
                    return '';
                },
                getResponseHeader: function () {
                    return '';
                },
                open: noop,
                overrideMimeType: noop,
                readyState: 4,
                responseText: '',
                responseXML: null,
                send: noop,
                setRequestHeader: noop,
                status: 200,
                statusText: 'OK'
            }, xhr);
        },
        store: Store.make,
        fixtures: core.fixtures
    });
    if (typeof window !== 'undefined' && typeof require.resolve !== 'function') {
        window.fixture = fixture;
    }
    module.exports = ns.fixture = fixture;
});
/*can-connect@1.3.8#can/map/map*/
define('can-connect@1.3.8#can/map/map', function (require, exports, module) {
    'use strict';
    var each = require('can-util/js/each/each');
    var connect = require('can-connect');
    var canBatch = require('can-event/batch/batch');
    var canEvent = require('can-event');
    var Observation = require('can-observation');
    var isPlainObject = require('can-util/js/is-plain-object/is-plain-object');
    var isArray = require('can-util/js/is-array/is-array');
    var types = require('can-types');
    var each = require('can-util/js/each/each');
    var isFunction = require('can-util/js/is-function/is-function');
    var dev = require('can-util/js/dev/dev');
    var setExpando = function (map, prop, value) {
        if ('attr' in map) {
            map[prop] = value;
        } else {
            map._data[prop] = value;
        }
    };
    var getExpando = function (map, prop) {
        if ('attr' in map) {
            return map[prop];
        } else {
            return map._data[prop];
        }
    };
    var canMapBehavior = connect.behavior('can/map', function (baseConnection) {
        var behavior = {
            init: function () {
                this.Map = this.Map || types.DefaultMap.extend({});
                this.List = this.List || types.DefaultList.extend({});
                overwrite(this, this.Map, mapOverwrites, mapStaticOverwrites);
                overwrite(this, this.List, listPrototypeOverwrites, listStaticOverwrites);
                baseConnection.init.apply(this, arguments);
            },
            id: function (instance) {
                if (!isPlainObject(instance)) {
                    var ids = [], algebra = this.algebra;
                    if (algebra && algebra.clauses && algebra.clauses.id) {
                        for (var prop in algebra.clauses.id) {
                            ids.push(readObservabe(instance, prop));
                        }
                    }
                    if (this.idProp && !ids.length) {
                        ids.push(readObservabe(instance, this.idProp));
                    }
                    if (!ids.length) {
                        ids.push(readObservabe(instance, 'id'));
                    }
                    return ids.length > 1 ? ids.join('@|@') : ids[0];
                } else {
                    return baseConnection.id(instance);
                }
            },
            serializeInstance: function (instance) {
                return instance.serialize();
            },
            serializeList: function (list) {
                return list.serialize();
            },
            instance: function (props) {
                var _Map = this.Map || types.DefaultMap;
                return new _Map(props);
            },
            list: function (listData, set) {
                var _List = this.List || this.Map && this.Map.List || types.DefaultList;
                var list = new _List(listData.data);
                each(listData, function (val, prop) {
                    if (prop !== 'data') {
                        list[list.set ? 'set' : 'attr'](prop, val);
                    }
                });
                list.__listSet = set;
                return list;
            },
            updatedList: function () {
                canBatch.start();
                var res = baseConnection.updatedList.apply(this, arguments);
                canBatch.stop();
                return res;
            },
            save: function (instance) {
                setExpando(instance, '_saving', true);
                canEvent.dispatch.call(instance, '_saving', [
                    true,
                    false
                ]);
                var done = function () {
                    setExpando(instance, '_saving', false);
                    canEvent.dispatch.call(instance, '_saving', [
                        false,
                        true
                    ]);
                };
                var base = baseConnection.save.apply(this, arguments);
                base.then(done, done);
                return base;
            },
            destroy: function (instance) {
                setExpando(instance, '_destroying', true);
                canEvent.dispatch.call(instance, '_destroying', [
                    true,
                    false
                ]);
                var done = function () {
                    setExpando(instance, '_destroying', false);
                    canEvent.dispatch.call(instance, '_destroying', [
                        false,
                        true
                    ]);
                };
                var base = baseConnection.destroy.apply(this, arguments);
                base.then(done, done);
                return base;
            }
        };
        each([
            'created',
            'updated',
            'destroyed'
        ], function (funcName) {
            behavior[funcName + 'Instance'] = function (instance, props) {
                if (props && typeof props === 'object') {
                    if ('set' in instance) {
                        instance.set(isFunction(props.get) ? props.get() : props, this.constructor.removeAttr || false);
                    } else if ('attr' in instance) {
                        instance.attr(isFunction(props.attr) ? props.attr() : props, this.constructor.removeAttr || false);
                    } else {
                        canBatch.start();
                        each(props, function (value, prop) {
                            instance[prop] = value;
                        });
                        canBatch.stop();
                    }
                }
                canMapBehavior.callbackInstanceEvents(funcName, instance);
            };
        });
        return behavior;
    });
    canMapBehavior.callbackInstanceEvents = function (funcName, instance) {
        var constructor = instance.constructor;
        canEvent.dispatch.call(instance, {
            type: funcName,
            target: instance
        });
        canEvent.dispatch.call(constructor, funcName, [instance]);
    };
    var callCanReadingOnIdRead = true;
    var mapStaticOverwrites = {
        getList: function (base, connection) {
            return function (set) {
                return connection.getList(set);
            };
        },
        findAll: function (base, connection) {
            return function (set) {
                return connection.getList(set);
            };
        },
        get: function (base, connection) {
            return function (params) {
                return connection.get(params);
            };
        },
        findOne: function (base, connection) {
            return function (params) {
                return connection.get(params);
            };
        }
    };
    var mapOverwrites = {
        _eventSetup: function (base, connection) {
            return function () {
                callCanReadingOnIdRead = false;
                connection.addInstanceReference(this);
                callCanReadingOnIdRead = true;
                return base.apply(this, arguments);
            };
        },
        _eventTeardown: function (base, connection) {
            return function () {
                callCanReadingOnIdRead = false;
                connection.deleteInstanceReference(this);
                callCanReadingOnIdRead = true;
                return base.apply(this, arguments);
            };
        },
        ___set: function (base, connection) {
            return function (prop, val) {
                base.apply(this, arguments);
                if (prop === connection.idProp && this._bindings) {
                    connection.addInstanceReference(this);
                }
            };
        },
        isNew: function (base, connection) {
            return function () {
                var id = connection.id(this);
                return !(id || id === 0);
            };
        },
        isSaving: function (base, connection) {
            return function () {
                Observation.add(this, '_saving');
                return !!getExpando(this, '_saving');
            };
        },
        isDestroying: function (base, connection) {
            return function () {
                Observation.add(this, '_destroying');
                return !!getExpando(this, '_destroying');
            };
        },
        save: function (base, connection) {
            return function (success, error) {
                var promise = connection.save(this);
                promise.then(success, error);
                return promise;
            };
        },
        destroy: function (base, connection) {
            return function (success, error) {
                var promise;
                if (this.isNew()) {
                    promise = Promise.resolve(this);
                    connection.destroyedInstance(this, {});
                } else {
                    promise = connection.destroy(this);
                }
                promise.then(success, error);
                return promise;
            };
        }
    };
    var listPrototypeOverwrites = {
        setup: function (base, connection) {
            return function (params) {
                if (isPlainObject(params) && !isArray(params)) {
                    this.__listSet = params;
                    base.apply(this);
                    this.replace(types.isPromise(params) ? params : connection.getList(params));
                } else {
                    base.apply(this, arguments);
                }
            };
        },
        _eventSetup: function (base, connection) {
            return function () {
                connection.addListReference(this);
                if (base) {
                    return base.apply(this, arguments);
                }
            };
        },
        _eventTeardown: function (base, connection) {
            return function () {
                connection.deleteListReference(this);
                if (base) {
                    return base.apply(this, arguments);
                }
            };
        }
    };
    var listStaticOverwrites = {
        _bubbleRule: function (base, connection) {
            return function (eventName, list) {
                var bubbleRules = base(eventName, list);
                bubbleRules.push('destroyed');
                return bubbleRules;
            };
        }
    };
    var readObservabe = function (instance, prop) {
        if ('__get' in instance) {
            if (callCanReadingOnIdRead) {
                Observation.add(instance, prop);
            }
            return instance.__get(prop);
        } else {
            if (callCanReadingOnIdRead) {
                return instance[prop];
            } else {
                return Observation.ignore(function () {
                    return instance[prop];
                })();
            }
        }
    };
    var overwrite = function (connection, Constructor, prototype, statics) {
        var prop;
        for (prop in prototype) {
            Constructor.prototype[prop] = prototype[prop](Constructor.prototype[prop], connection);
        }
        if (statics) {
            for (prop in statics) {
                Constructor[prop] = statics[prop](Constructor[prop], connection);
            }
        }
    };
    module.exports = canMapBehavior;
});
/*can-util@3.3.2#js/param/param*/
define('can-util@3.3.2#js/param/param', function (require, exports, module) {
    var isArray = require('../is-array/is-array');
    var namespace = require('can-namespace');
    function buildParam(prefix, obj, add) {
        if (isArray(obj)) {
            for (var i = 0, l = obj.length; i < l; ++i) {
                add(prefix + '[]', obj[i]);
            }
        } else if (obj && typeof obj === 'object') {
            for (var name in obj) {
                buildParam(prefix + '[' + name + ']', obj[name], add);
            }
        } else {
            add(prefix, obj);
        }
    }
    module.exports = namespace.param = function param(object) {
        var pairs = [], add = function (key, value) {
                pairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
            };
        for (var name in object) {
            buildParam(name, object[name], add);
        }
        return pairs.join('&').replace(/%20/g, '+');
    };
});
/*can-util@3.3.2#dom/ajax/ajax*/
define('can-util@3.3.2#dom/ajax/ajax', function (require, exports, module) {
    (function (global) {
        var Global = require('../../js/global/global');
        var assign = require('../../js/assign/assign');
        var namespace = require('can-namespace');
        var parseURI = require('../../js/parse-uri/parse-uri');
        var param = require('../../js/param/param');
        var xhrs = [
                function () {
                    return new XMLHttpRequest();
                },
                function () {
                    return new ActiveXObject('Microsoft.XMLHTTP');
                },
                function () {
                    return new ActiveXObject('MSXML2.XMLHTTP.3.0');
                },
                function () {
                    return new ActiveXObject('MSXML2.XMLHTTP');
                }
            ], _xhrf = null;
        var originUrl = parseURI(Global().location.href);
        var makeXhr = function () {
            if (_xhrf != null) {
                return _xhrf();
            }
            for (var i = 0, l = xhrs.length; i < l; i++) {
                try {
                    var f = xhrs[i], req = f();
                    if (req != null) {
                        _xhrf = f;
                        return req;
                    }
                } catch (e) {
                    continue;
                }
            }
            return function () {
            };
        };
        var _xhrResp = function (xhr, options) {
            switch (options.dataType || xhr.getResponseHeader('Content-Type').split(';')[0]) {
            case 'text/xml':
            case 'xml':
                return xhr.responseXML;
            case 'text/json':
            case 'application/json':
            case 'text/javascript':
            case 'application/javascript':
            case 'application/x-javascript':
            case 'json':
                return JSON.parse(xhr.responseText);
            default:
                return xhr.responseText;
            }
        };
        module.exports = namespace.ajax = function (o) {
            var xhr = makeXhr(), timer, n = 0;
            var deferred = {};
            var promise = new Promise(function (resolve, reject) {
                deferred.resolve = resolve;
                deferred.reject = reject;
            });
            var requestUrl;
            promise.abort = function () {
                xhr.abort();
            };
            o = assign({
                userAgent: 'XMLHttpRequest',
                lang: 'en',
                type: 'GET',
                data: null,
                dataType: 'json'
            }, o);
            if (o.crossDomain == null) {
                try {
                    requestUrl = parseURI(o.url);
                    o.crossDomain = !!(requestUrl.protocol && requestUrl.protocol !== originUrl.protocol || requestUrl.host && requestUrl.host !== originUrl.host);
                } catch (e) {
                    o.crossDomain = true;
                }
            }
            if (o.timeout) {
                timer = setTimeout(function () {
                    xhr.abort();
                    if (o.timeoutFn) {
                        o.timeoutFn(o.url);
                    }
                }, o.timeout);
            }
            xhr.onreadystatechange = function () {
                try {
                    if (xhr.readyState === 4) {
                        if (timer) {
                            clearTimeout(timer);
                        }
                        if (xhr.status < 300) {
                            if (o.success) {
                                o.success(_xhrResp(xhr, o));
                            }
                        } else if (o.error) {
                            o.error(xhr, xhr.status, xhr.statusText);
                        }
                        if (o.complete) {
                            o.complete(xhr, xhr.statusText);
                        }
                        if (xhr.status >= 200 && xhr.status < 300) {
                            deferred.resolve(_xhrResp(xhr, o));
                        } else {
                            deferred.reject(xhr);
                        }
                    } else if (o.progress) {
                        o.progress(++n);
                    }
                } catch (e) {
                    deferred.reject(e);
                }
            };
            var url = o.url, data = null, type = o.type.toUpperCase();
            var isPost = type === 'POST' || type === 'PUT';
            if (!isPost && o.data) {
                url += '?' + param(o.data);
            }
            xhr.open(type, url);
            var isSimpleCors = o.crossDomain && [
                'GET',
                'POST',
                'HEAD'
            ].indexOf(type) !== -1;
            if (isPost) {
                var isJson = o.dataType.indexOf('json') >= 0;
                data = isJson && !isSimpleCors ? typeof o.data === 'object' ? JSON.stringify(o.data) : o.data : param(o.data);
                xhr.setRequestHeader('Content-Type', isJson && !isSimpleCors ? 'application/json' : 'application/x-www-form-urlencoded');
            }
            if (!isSimpleCors) {
                xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
            }
            xhr.send(data);
            return promise;
        };
    }(function () {
        return this;
    }()));
});
/*can-connect@1.3.8#helpers/get-id-props*/
define('can-connect@1.3.8#helpers/get-id-props', function (require, exports, module) {
    module.exports = function (connection) {
        var ids = [], algebra = connection.algebra;
        if (algebra && algebra.clauses && algebra.clauses.id) {
            for (var prop in algebra.clauses.id) {
                ids.push(prop);
            }
        }
        if (connection.idProp && !ids.length) {
            ids.push(connection.idProp);
        }
        if (!ids.length) {
            ids.push('id');
        }
        return ids;
    };
});
/*can-util@3.3.2#js/is-promise-like/is-promise-like*/
define('can-util@3.3.2#js/is-promise-like/is-promise-like', function (require, exports, module) {
    module.exports = function (obj) {
        return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';
    };
});
/*can-util@3.3.2#js/make-promise/make-promise*/
define('can-util@3.3.2#js/make-promise/make-promise', function (require, exports, module) {
    var isPromiseLike = require('../is-promise-like/is-promise-like');
    var isPromise = require('../is-promise/is-promise');
    module.exports = function (obj) {
        if (isPromiseLike(obj) && !isPromise(obj)) {
            return new Promise(function (resolve, reject) {
                obj.then(resolve, reject);
            });
        } else {
            return obj;
        }
    };
});
/*can-connect@1.3.8#data/url/url*/
define('can-connect@1.3.8#data/url/url', function (require, exports, module) {
    var isArray = require('can-util/js/is-array/is-array');
    var assign = require('can-util/js/assign/assign');
    var each = require('can-util/js/each/each');
    var ajax = require('can-util/dom/ajax/ajax');
    var string = require('can-util/js/string/string');
    var getIdProps = require('../../helpers/get-id-props');
    var dev = require('can-util/js/dev/dev');
    var connect = require('can-connect');
    var makePromise = require('can-util/js/make-promise/make-promise');
    module.exports = connect.behavior('data/url', function (baseConnection) {
        var behavior = {};
        each(pairs, function (reqOptions, name) {
            behavior[name] = function (params) {
                if (typeof this.url === 'object') {
                    if (typeof this.url[reqOptions.prop] === 'function') {
                        return makePromise(this.url[reqOptions.prop](params));
                    } else if (this.url[reqOptions.prop]) {
                        return makePromise(makeAjax(this.url[reqOptions.prop], params, reqOptions.type, this.ajax || ajax, findContentType(this.url), reqOptions));
                    }
                }
                var resource = typeof this.url === 'string' ? this.url : this.url.resource;
                if (resource) {
                    var idProps = getIdProps(this);
                    return makePromise(makeAjax(createURLFromResource(resource, idProps[0], reqOptions.prop), params, reqOptions.type, this.ajax || ajax, findContentType(this.url), reqOptions));
                }
                return baseConnection[name].call(this, params);
            };
        });
        return behavior;
    });
    var pairs = {
        getListData: {
            prop: 'getListData',
            type: 'GET'
        },
        getData: {
            prop: 'getData',
            type: 'GET'
        },
        createData: {
            prop: 'createData',
            type: 'POST'
        },
        updateData: {
            prop: 'updateData',
            type: 'PUT'
        },
        destroyData: {
            prop: 'destroyData',
            type: 'DELETE',
            includeData: false
        }
    };
    var findContentType = function (url) {
        if (typeof url === 'object' && url.contentType) {
            var acceptableType = url.contentType === 'application/x-www-form-urlencoded' || url.contentType === 'application/json';
            if (acceptableType) {
                return url.contentType;
            } else {
            }
        }
        return 'application/json';
    };
    var makeAjax = function (ajaxOb, data, type, ajax, contentType, reqOptions) {
        var params = {};
        if (typeof ajaxOb === 'string') {
            var parts = ajaxOb.split(/\s+/);
            params.url = parts.pop();
            if (parts.length) {
                params.type = parts.pop();
            }
        } else {
            assign(params, ajaxOb);
        }
        params.data = typeof data === 'object' && !isArray(data) ? assign(params.data || {}, data) : data;
        params.url = string.sub(params.url, params.data, true);
        var encodeJSON = contentType !== 'application/x-www-form-urlencoded' && (type && (type === 'POST' || type === 'PUT'));
        if (encodeJSON) {
            params.data = JSON.stringify(params.data);
            params.contentType = contentType;
        }
        if (reqOptions.includeData === false) {
            delete params.data;
        }
        return ajax(assign({
            type: type || 'post',
            dataType: 'json'
        }, params));
    };
    var createURLFromResource = function (resource, idProp, name) {
        var url = resource.replace(/\/+$/, '');
        if (name === 'getListData' || name === 'createData') {
            return url;
        } else {
            return url + '/{' + idProp + '}';
        }
    };
});
/*can-connect@1.3.8#helpers/weak-reference-map*/
define('can-connect@1.3.8#helpers/weak-reference-map', function (require, exports, module) {
    var assign = require('can-util/js/assign/assign');
    var WeakReferenceMap = function () {
        this.set = {};
    };
    assign(WeakReferenceMap.prototype, {
        has: function (key) {
            return !!this.set[key];
        },
        addReference: function (key, item) {
            if (typeof key === 'undefined') {
                return;
            }
            var data = this.set[key];
            if (!data) {
                data = this.set[key] = {
                    item: item,
                    referenceCount: 0,
                    key: key
                };
            }
            data.referenceCount++;
        },
        deleteReference: function (key) {
            var data = this.set[key];
            if (data) {
                data.referenceCount--;
                if (data.referenceCount === 0) {
                    delete this.set[key];
                }
            }
        },
        get: function (key) {
            var data = this.set[key];
            if (data) {
                return data.item;
            }
        },
        forEach: function (cb) {
            for (var id in this.set) {
                cb(this.set[id].item, id);
            }
        }
    });
    module.exports = WeakReferenceMap;
});
/*can-connect@1.3.8#helpers/id-merge*/
define('can-connect@1.3.8#helpers/id-merge', function (require, exports, module) {
    var map = [].map;
    module.exports = function (list, update, id, make) {
        var listIndex = 0, updateIndex = 0;
        while (listIndex < list.length && updateIndex < update.length) {
            var listItem = list[listIndex], updateItem = update[updateIndex], lID = id(listItem), uID = id(updateItem);
            if (id(listItem) === id(updateItem)) {
                listIndex++;
                updateIndex++;
                continue;
            }
            if (updateIndex + 1 < update.length && id(update[updateIndex + 1]) === lID) {
                list.splice(listIndex, 0, make(update[updateIndex]));
                listIndex++;
                updateIndex++;
                continue;
            } else if (listIndex + 1 < list.length && id(list[listIndex + 1]) === uID) {
                list.splice(listIndex, 1);
                listIndex++;
                updateIndex++;
                continue;
            } else {
                list.splice.apply(list, [
                    listIndex,
                    list.length - listIndex
                ].concat(map.call(update.slice(updateIndex), make)));
                return list;
            }
        }
        if (updateIndex === update.length && listIndex === list.length) {
            return;
        }
        list.splice.apply(list, [
            listIndex,
            list.length - listIndex
        ].concat(map.call(update.slice(updateIndex), make)));
        return;
    };
});
/*can-connect@1.3.8#constructor/constructor*/
define('can-connect@1.3.8#constructor/constructor', function (require, exports, module) {
    var isArray = require('can-util/js/is-array/is-array');
    var makeArray = require('can-util/js/make-array/make-array');
    var assign = require('can-util/js/assign/assign');
    var connect = require('can-connect');
    var WeakReferenceMap = require('can-connect/helpers/weak-reference-map');
    var overwrite = require('can-connect/helpers/overwrite');
    var idMerge = require('can-connect/helpers/id-merge');
    module.exports = connect.behavior('constructor', function (baseConnection) {
        var behavior = {
            cidStore: new WeakReferenceMap(),
            _cid: 0,
            get: function (params) {
                var self = this;
                return this.getData(params).then(function (data) {
                    return self.hydrateInstance(data);
                });
            },
            getList: function (set) {
                set = set || {};
                var self = this;
                return this.getListData(set).then(function (data) {
                    return self.hydrateList(data, set);
                });
            },
            hydrateList: function (listData, set) {
                if (isArray(listData)) {
                    listData = { data: listData };
                }
                var arr = [];
                for (var i = 0; i < listData.data.length; i++) {
                    arr.push(this.hydrateInstance(listData.data[i]));
                }
                listData.data = arr;
                if (this.list) {
                    return this.list(listData, set);
                } else {
                    var list = listData.data.slice(0);
                    list[this.listSetProp || '__listSet'] = set;
                    copyMetadata(listData, list);
                    return list;
                }
            },
            hydrateInstance: function (props) {
                if (this.instance) {
                    return this.instance(props);
                } else {
                    return assign({}, props);
                }
            },
            save: function (instance) {
                var serialized = this.serializeInstance(instance);
                var id = this.id(instance);
                var self = this;
                if (id === undefined) {
                    var cid = this._cid++;
                    this.cidStore.addReference(cid, instance);
                    return this.createData(serialized, cid).then(function (data) {
                        if (data !== undefined) {
                            self.createdInstance(instance, data);
                        }
                        self.cidStore.deleteReference(cid, instance);
                        return instance;
                    });
                } else {
                    return this.updateData(serialized).then(function (data) {
                        if (data !== undefined) {
                            self.updatedInstance(instance, data);
                        }
                        return instance;
                    });
                }
            },
            destroy: function (instance) {
                var serialized = this.serializeInstance(instance), self = this;
                return this.destroyData(serialized).then(function (data) {
                    if (data !== undefined) {
                        self.destroyedInstance(instance, data);
                    }
                    return instance;
                });
            },
            createdInstance: function (instance, props) {
                assign(instance, props);
            },
            updatedInstance: function (instance, data) {
                overwrite(instance, data, this.idProp);
            },
            updatedList: function (list, listData, set) {
                var instanceList = [];
                for (var i = 0; i < listData.data.length; i++) {
                    instanceList.push(this.hydrateInstance(listData.data[i]));
                }
                idMerge(list, instanceList, this.id.bind(this), this.hydrateInstance.bind(this));
                copyMetadata(listData, list);
            },
            destroyedInstance: function (instance, data) {
                overwrite(instance, data, this.idProp);
            },
            serializeInstance: function (instance) {
                return assign({}, instance);
            },
            serializeList: function (list) {
                var self = this;
                return makeArray(list).map(function (instance) {
                    return self.serializeInstance(instance);
                });
            },
            isNew: function (instance) {
                var id = this.id(instance);
                return !(id || id === 0);
            }
        };
        return behavior;
    });
    function copyMetadata(listData, list) {
        for (var prop in listData) {
            if (prop !== 'data') {
                if (typeof list.set === 'function') {
                    list.set(prop, listData[prop]);
                } else if (typeof list.attr === 'function') {
                    list.attr(prop, listData[prop]);
                } else {
                    list[prop] = listData[prop];
                }
            }
        }
    }
});
/*can-connect@1.3.8#constructor/store/store*/
define('can-connect@1.3.8#constructor/store/store', function (require, exports, module) {
    var connect = require('can-connect');
    var WeakReferenceMap = require('can-connect/helpers/weak-reference-map');
    var sortedSetJSON = require('can-connect/helpers/sorted-set-json');
    var canEvent = require('can-event');
    var assign = require('can-util/js/assign/assign');
    var pendingRequests = 0;
    var noRequestsTimer = null;
    var requests = {
        increment: function (connection) {
            pendingRequests++;
            clearTimeout(noRequestsTimer);
        },
        decrement: function (connection) {
            pendingRequests--;
            if (pendingRequests === 0) {
                noRequestsTimer = setTimeout(function () {
                    requests.dispatch('end');
                }, 10);
            }
        },
        count: function () {
            return pendingRequests;
        }
    };
    assign(requests, canEvent);
    var constructorStore = connect.behavior('constructor/store', function (baseConnection) {
        var behavior = {
            instanceStore: new WeakReferenceMap(),
            listStore: new WeakReferenceMap(),
            _requestInstances: {},
            _requestLists: {},
            _finishedRequest: function () {
                var id;
                requests.decrement(this);
                if (requests.count() === 0) {
                    for (id in this._requestInstances) {
                        this.instanceStore.deleteReference(id);
                    }
                    this._requestInstances = {};
                    for (id in this._requestLists) {
                        this.listStore.deleteReference(id);
                    }
                    this._requestLists = {};
                }
            },
            addInstanceReference: function (instance, id) {
                this.instanceStore.addReference(id || this.id(instance), instance);
            },
            addInstanceMetaData: function (instance, name, value) {
                var data = this.instanceStore.set[this.id(instance)];
                if (data) {
                    data[name] = value;
                }
            },
            getInstanceMetaData: function (instance, name) {
                var data = this.instanceStore.set[this.id(instance)];
                if (data) {
                    return data[name];
                }
            },
            deleteInstanceMetaData: function (instance, name) {
                var data = this.instanceStore.set[this.id(instance)];
                delete data[name];
            },
            deleteInstanceReference: function (instance) {
                this.instanceStore.deleteReference(this.id(instance), instance);
            },
            addListReference: function (list, set) {
                var id = sortedSetJSON(set || this.listSet(list));
                if (id) {
                    this.listStore.addReference(id, list);
                }
            },
            deleteListReference: function (list, set) {
                var id = sortedSetJSON(set || this.listSet(list));
                if (id) {
                    this.listStore.deleteReference(id, list);
                }
            },
            hydratedInstance: function (instance) {
                if (requests.count() > 0) {
                    var id = this.id(instance);
                    if (!this._requestInstances[id]) {
                        this.addInstanceReference(instance);
                        this._requestInstances[id] = instance;
                    }
                }
            },
            hydrateInstance: function (props) {
                var id = this.id(props);
                if ((id || id === 0) && this.instanceStore.has(id)) {
                    var storeInstance = this.instanceStore.get(id);
                    this.updatedInstance(storeInstance, props);
                    return storeInstance;
                }
                var instance = baseConnection.hydrateInstance.call(this, props);
                this.hydratedInstance(instance);
                return instance;
            },
            hydratedList: function (list, set) {
                if (requests.count() > 0) {
                    var id = sortedSetJSON(set || this.listSet(list));
                    if (id) {
                        if (!this._requestLists[id]) {
                            this.addListReference(list, set);
                            this._requestLists[id] = list;
                        }
                    }
                }
            },
            hydrateList: function (listData, set) {
                set = set || this.listSet(listData);
                var id = sortedSetJSON(set);
                if (id && this.listStore.has(id)) {
                    var storeList = this.listStore.get(id);
                    this.updatedList(storeList, listData, set);
                    return storeList;
                }
                var list = baseConnection.hydrateList.call(this, listData, set);
                this.hydratedList(list, set);
                return list;
            },
            getList: function (params) {
                var self = this;
                requests.increment(this);
                var promise = baseConnection.getList.call(this, params);
                promise.then(function (instances) {
                    self._finishedRequest();
                }, function () {
                    self._finishedRequest();
                });
                return promise;
            },
            get: function (params) {
                var self = this;
                requests.increment(this);
                var promise = baseConnection.get.call(this, params);
                promise.then(function (instance) {
                    self._finishedRequest();
                }, function () {
                    self._finishedRequest();
                });
                return promise;
            },
            save: function (instance) {
                var self = this;
                requests.increment(this);
                var updating = !this.isNew(instance);
                if (updating) {
                    this.addInstanceReference(instance);
                }
                var promise = baseConnection.save.call(this, instance);
                promise.then(function (instances) {
                    if (updating) {
                        self.deleteInstanceReference(instance);
                    }
                    self._finishedRequest();
                }, function () {
                    self._finishedRequest();
                });
                return promise;
            },
            destroy: function (instance) {
                var self = this;
                requests.increment(this);
                var promise = baseConnection.destroy.call(this, instance);
                promise.then(function (instance) {
                    self._finishedRequest();
                }, function () {
                    self._finishedRequest();
                });
                return promise;
            }
        };
        return behavior;
    });
    constructorStore.requests = requests;
    module.exports = constructorStore;
});
/*can-connect@1.3.8#helpers/map-deep-merge*/
define('can-connect@1.3.8#helpers/map-deep-merge', function (require, exports, module) {
    var DefineMap = require('can-define/map/map');
    var DefineList = require('can-define/list/list');
    var diff = require('can-util/js/diff/diff');
    var assign = require('can-util/js/assign/assign');
    var each = require('can-util/js/each/each');
    var isPlainObject = require('can-util/js/is-plain-object/is-plain-object');
    function smartMerge(instance, props) {
        if (instance instanceof DefineList) {
            mergeList(instance, props);
        } else {
            mergeInstance(instance, props);
        }
    }
    function mergeInstance(instance, data) {
        data = assign({}, data);
        instance.forEach(function (value, prop) {
            var newValue = data[prop];
            delete data[prop];
            var newValueIsArray = Array.isArray(newValue);
            if (value instanceof DefineList && newValueIsArray) {
                mergeList(value, newValue);
            } else if (value instanceof DefineMap && isPlainObject(newValue) && !newValueIsArray) {
                var Type = value.constructor;
                var id = idFromType(Type);
                var hydrate = hydratorFromType(Type);
                if (id && id(value) === id(newValue)) {
                    mergeInstance(value, newValue);
                } else {
                    instance.set(prop, hydrate(newValue));
                }
            } else {
                instance.set(prop, newValue);
            }
        });
        each(data, function (value, prop) {
            if (prop !== '_cid') {
                instance.set(prop, value);
            }
        });
    }
    function mergeList(list, data) {
        var Type = typeFromList(list);
        var id = idFromType(Type);
        var identity = function (a, b) {
            var eq = id(a) === id(b);
            if (eq) {
                mergeInstance(a, b);
            }
            return eq;
        };
        var hydrate = hydratorFromType(Type);
        var patches = diff(list, data, identity);
        if (!patches.length) {
            return list;
        }
        patches.forEach(function (patch) {
            applyPatch(list, patch, hydrate);
        });
    }
    function typeFromList(list) {
        return list && list._define && list._define.definitions['#'] && list._define.definitions['#'].Type;
    }
    function idFromType(Type) {
        return Type && Type.connection && function (o) {
            return Type.connection.id(o);
        } || Type && Type.algebra && Type.algebra.clauses && Type.algebra.clauses.id && function (o) {
            var idProp = Object.keys(Type.algebra.clauses.id)[0];
            return o[idProp];
        } || function (o) {
            return o.id || o._id;
        };
    }
    function hydratorFromType(Type) {
        return Type && Type.connection && Type.connection.makeInstance || function (data) {
            return new Type(data);
        };
    }
    function applyPatch(list, patch, makeInstance) {
        var insert = makeInstance && patch.insert.map(makeInstance) || patch.insert;
        var args = [
            patch.index,
            patch.deleteCount
        ].concat(insert);
        list.splice.apply(list, args);
        return list;
    }
    function applyPatchPure(list, patch, makeInstance) {
        var copy = list.slice();
        return applyPatch(copy, patch, makeInstance);
    }
    module.exports = smartMerge;
    smartMerge.mergeInstance = mergeInstance;
    smartMerge.mergeList = mergeList;
    smartMerge.applyPatch = applyPatch;
    smartMerge.applyPatchPure = applyPatchPure;
    smartMerge.idFromType = idFromType;
});
/*can-connect@1.3.8#helpers/map-deep-merge-test.js*/
define('can-connect@1.3.8#helpers/map-deep-merge-test.js', function (require, exports, module) {
    var DefineMap = require('can-define/map/map');
    var DefineList = require('can-define/list/list');
    var set = require('can-set');
    var fixture = require('can-fixture');
    var canEvent = require('can-event');
    var canLog = require('can-util/js/log/log');
    var connect = require('can-connect');
    var canMap = require('can-connect/can/map/map');
    var dataUrl = require('can-connect/data/url/url');
    var constructor = require('can-connect/constructor/constructor');
    var constructorStore = require('can-connect/constructor/store/store');
    var smartMerge = require('./map-deep-merge');
    var applyPatch = require('./map-deep-merge').applyPatch;
    var applyPatchPure = smartMerge.applyPatchPure;
    var mergeInstance = smartMerge.mergeInstance;
    var mergeList = smartMerge.mergeList;
    var idFromType = smartMerge.idFromType;
    var QUnit = require('steal-qunit');
    QUnit.noop = function () {
    };
    var OSProject, Author, ContributionMonth, origEventDispatch, events;
    Author = DefineMap.extend({
        id: { type: 'number' },
        name: { type: 'string' }
    });
    Author.algebra = new set.Algebra(set.props.id('id'));
    OSProject = DefineMap.extend({
        id: { type: 'number' },
        title: { type: 'string' }
    });
    OSProject.List = DefineList.extend({ '#': OSProject });
    OSProject.algebra = new set.Algebra(set.props.id('id'));
    ContributionMonth = DefineMap.extend({
        author: Author,
        osProjects: OSProject.List
    });
    QUnit.module('helpers map-deep-merge', {
        setup: function () {
            events = [];
            origEventDispatch = canEvent.dispatch;
            canEvent.dispatch = function (ev) {
                var eventInfo = {
                    type: ev.type || ev,
                    target: ev.target && ev.target.serialize()
                };
                events.push(eventInfo);
                return origEventDispatch.apply(this, arguments);
            };
        },
        teardown: function () {
            canEvent.dispatch = origEventDispatch;
        }
    });
    QUnit.test('smartMerge simple object', function (assert) {
        var item = new ContributionMonth({
            id: 1,
            month: 'feb'
        });
        var data = {
            id: 1,
            month: 'February'
        };
        events = [];
        smartMerge(item, data);
        assert.deepEqual(item.serialize(), data, 'updated data should be correct');
        assert.equal(events.length, 1, 'should dispatch only one event');
        assert.deepEqual(events[0].type, 'month', 'should dispatch only "month" event: ' + JSON.stringify(events));
    });
    QUnit.test('smartMerge nested objects', function (assert) {
        var item = new ContributionMonth({
            id: 1,
            author: {
                id: 6,
                name: 'ily'
            }
        });
        var data1 = {
            id: 1,
            author: {
                id: 6,
                name: 'Ilya'
            }
        };
        var data2 = {
            id: 1,
            author: {
                id: 7,
                name: 'Peter'
            }
        };
        events = [];
        smartMerge(item, data1);
        assert.deepEqual(item.serialize(), data1, 'nested object MERGE');
        assert.deepEqual(events.map(prop('type')), ['name'], 'should dispatch only "name" event');
        events = [];
        smartMerge(item, data2);
        assert.deepEqual(item.serialize(), data2, 'nested object REPLACE');
        assert.deepEqual(events.map(prop('type')), [
            'id',
            'name',
            'author'
        ], 'should dispatch 3 events: id, name (for the new author), and author: ' + JSON.stringify(events));
        canLog.log('events::', events);
    });
    QUnit.test('smartMerge list of maps', function (assert) {
        var item = new ContributionMonth({
            osProjects: [
                {
                    id: 1,
                    title: 'can'
                },
                {
                    id: 2,
                    title: 'jQuery++'
                }
            ]
        });
        var data = {
            osProjects: [
                {
                    id: 1,
                    title: 'CanJS'
                },
                {
                    id: 2,
                    title: 'jQuery++'
                }
            ]
        };
        events = [];
        smartMerge(item, data);
        assert.deepEqual(item.serialize(), data, 'updated data should be correct for the UPDATE');
        assert.deepEqual(events.map(prop('type')), ['title'], 'should dispatch only "title" event');
        item = new ContributionMonth({
            osProjects: [
                {
                    id: 1,
                    title: 'can'
                },
                {
                    id: 2,
                    title: 'jQuery++'
                }
            ]
        });
        data = {
            osProjects: [
                {
                    id: 1,
                    title: 'can'
                },
                {
                    id: 3,
                    title: 'StealJS'
                },
                {
                    id: 2,
                    title: 'jQuery++'
                }
            ]
        };
        events = [];
        smartMerge(item, data);
        canLog.log('events after smartMerge: ', events);
        assert.deepEqual(item.serialize(), data, 'updated data should be correct for the INSERT');
        assert.deepEqual(events.map(prop('type')), [
            'id',
            'title',
            'add',
            'length'
        ], 'should dispatch correct events: id, title (for the new item); add, length (for insertion)');
    });
    QUnit.test('smartMerge can-connect behaviour', function (assert) {
        var done = assert.async();
        fixture('PUT /contribution-month/{id}', function () {
            canLog.log('fixture here');
            return updatedData;
        });
        var canMapMergeBehaviour = {
            updatedInstance: function (instance, props) {
                smartMerge(instance, props);
                canMap.callbackInstanceEvents('updated', instance);
            }
        };
        var origData = {
            id: 1,
            name: 'Feb',
            osProjects: [
                {
                    id: 1,
                    name: 'canjs'
                },
                {
                    id: 2,
                    name: 'jQuery++'
                }
            ],
            author: {
                id: 5,
                name: 'ilya'
            }
        };
        var updatedData = {
            id: 1,
            name: 'February',
            osProjects: [
                {
                    id: 1,
                    name: 'CanJS'
                },
                {
                    id: 3,
                    name: 'StealJS'
                },
                {
                    id: 2,
                    name: 'jQuery++'
                }
            ],
            author: {
                id: 6,
                name: 'ilya'
            }
        };
        connect([
            dataUrl,
            constructor,
            constructorStore,
            canMap,
            canMapMergeBehaviour
        ], {
            Map: ContributionMonth,
            url: 'localhost:8080/contribution-month'
        });
        var item = new ContributionMonth(origData);
        events = [];
        item.save().then(function (updated) {
            assert.deepEqual(updated.serialize(), updatedData, 'updated data should be correct');
            var eventTypes = events.map(prop('type')).filter(notEq('_saving')).filter(notEq('updated')).sort();
            assert.equal(eventTypes.length, 9, 'Should dispatch 9 events');
            assert.deepEqual(eventTypes, [
                'id',
                'name',
                'name',
                'author',
                'name',
                'id',
                'name',
                'add',
                'length'
            ].sort(), 'should dispatch the correct events: ' + 'id, name (new Author); ' + 'name, author (month update); ' + 'name (project update); ' + 'id, name (new project); ' + 'add, length (projects) ' + JSON.stringify(eventTypes));
            done();
        }).catch(function (e) {
            canLog.log('Error: ', e);
            assert.ok(false, 'should not throw an exception');
            done();
        });
    });
    QUnit.test('smartMerge a list of items which type has a connection', function (assert) {
        var Car = DefineMap.extend({
            vin: 'number',
            brand: 'string'
        });
        Car.algebra = new set.Algebra(set.props.id('vin'));
        Car.List = DefineList.extend({ '#': Car });
        Car.connection = connect([
            constructor,
            constructorStore,
            canMap
        ]);
        var list = new Car.List([
            {
                id: 100,
                name: 'Feb'
            },
            {
                id: 200,
                name: 'March'
            }
        ]);
        var data = [
            {
                id: 100,
                name: 'February'
            },
            {
                id: 200,
                name: 'March'
            }
        ];
        smartMerge(list, data);
        assert.deepEqual(list.serialize(), data, 'List with a connection should be merged');
    });
    QUnit.test('applyPatch', function (assert) {
        assert.deepEqual(applyPatch([
            1,
            2,
            3
        ], {
            index: 1,
            deleteCount: 0,
            insert: [4]
        }), [
            1,
            4,
            2,
            3
        ], 'Patch insert');
        assert.deepEqual(applyPatch([
            1,
            2,
            3
        ], {
            index: 1,
            deleteCount: 2,
            insert: [4]
        }), [
            1,
            4
        ], 'Patch delete/insert');
        assert.deepEqual(applyPatch([
            1,
            2,
            3
        ], {
            index: 1,
            deleteCount: 0,
            insert: [4]
        }, function (a) {
            return a * 10;
        }), [
            1,
            40,
            2,
            3
        ], 'Patch with makeInstance');
    });
    QUnit.test('applyPatchPure', function (assert) {
        var list = [
            1,
            2,
            3
        ];
        var patch = {
            index: 1,
            deleteCount: 2,
            insert: [4]
        };
        var patchedList = applyPatchPure(list, patch);
        assert.deepEqual(patchedList, [
            1,
            4
        ], 'Patched correctly');
        assert.notEqual(list, patchedList, 'Patched list does not reference orig list');
        assert.deepEqual(list, [
            1,
            2,
            3
        ], 'Original list was not mutated');
    });
    function notEq(a) {
        return function (b) {
            return a !== b;
        };
    }
    function prop(prop) {
        return function (o) {
            return o[prop];
        };
    }
    QUnit.test('mergeInstance when properties are removed and added', function () {
        var map = new DefineMap({ a: 'A' });
        mergeInstance(map, { b: 'B' });
        QUnit.deepEqual(map.get(), { b: 'B' });
    });
    QUnit.test('Merging non-defined, but object, types', function () {
        var first = new Date();
        var last = new Date();
        var map = new DefineMap({ a: first });
        mergeInstance(map, { a: last });
        QUnit.equal(map.a, last);
    });
    QUnit.test('idFromType', function (assert) {
        var Car = DefineMap.extend({
            vin: { type: 'string' },
            color: { type: 'string' }
        });
        Car.algebra = new set.Algebra(set.props.id('vin'));
        var id = idFromType(Car);
        var myCar = new Car({
            vin: '1',
            color: 'black'
        });
        assert.equal(id(myCar), '1', 'id is retrieved from algebra with a custom id prop');
    });
    QUnit.test('custom id prop for instance store', function (assert) {
        var Car = DefineMap.extend({
            vin: { type: 'string' },
            color: { type: 'string' }
        });
        Car.algebra = new set.Algebra(set.props.id('vin'));
        Car.List = DefineList.extend({ '#': Car });
        var id = idFromType(Car);
        var items = new Car.List([
            {
                vin: '1',
                color: 'black'
            },
            {
                vin: '2',
                color: 'blue'
            }
        ]);
        var toStore = function (map, item) {
            map[item.vin] = item;
            return map;
        };
        var instanceStore = [].reduce.call(items, toStore, {});
        var data = [
            {
                vin: '2',
                color: 'blue'
            },
            {
                vin: '1',
                color: 'red'
            }
        ];
        assert.ok(items[0].vin === '1', 'The 1st item is with id 1');
        assert.deepEqual(instanceStore['1'].serialize(), {
            vin: '1',
            color: 'black'
        }, 'The item with id=1 is what we want it to be');
        smartMerge(items, data);
        assert.deepEqual(instanceStore['1'].serialize(), {
            vin: '1',
            color: 'red'
        }, 'The item with id=1 was updated correctly');
        assert.ok(items[0].vin === '2', 'items were swapped in the list which is what we expected');
    });
});
/*can-connect@1.3.8#helpers/helpers_test*/
define('can-connect@1.3.8#helpers/helpers_test', function (require, exports, module) {
    require('can-connect/helpers/map-deep-merge-test.js');
    var idMerge = require('can-connect/helpers/id-merge');
    var QUnit = require('steal-qunit');
    QUnit.module('helpers');
    QUnit.test('id-merge', function () {
        var onSplice = function (arr, fn) {
            var splice = arr.splice;
            arr.splice = function () {
                fn.apply(this, arguments);
                return splice.apply(this, arguments);
            };
            return arr;
        };
        var returnArg = function (arg) {
            return arg;
        };
        var list;
        idMerge(list = [], [
            1,
            2,
            3
        ], returnArg, returnArg);
        deepEqual(list, [
            1,
            2,
            3
        ]);
        list = onSplice([
            1,
            2,
            3
        ], function () {
            ok(false, 'splice called');
        });
        idMerge(list, [
            1,
            2,
            3
        ], returnArg, returnArg);
        deepEqual(list, [
            1,
            2,
            3
        ]);
        list = onSplice([
            1,
            2,
            4
        ], function (index, howMany, insert) {
            equal(index, 2);
            equal(howMany, 0);
            equal(insert, 3);
        });
        idMerge(list, [
            1,
            2,
            3,
            4
        ], returnArg, returnArg);
        deepEqual(list, [
            1,
            2,
            3,
            4
        ]);
        list = onSplice([
            1,
            2,
            3,
            4
        ], function (index, howMany, insert) {
            equal(index, 2);
            equal(howMany, 1);
            equal(insert, undefined);
        });
        idMerge(list, [
            1,
            2,
            4
        ], returnArg, returnArg);
        deepEqual(list, [
            1,
            2,
            4
        ]);
        idMerge(list = [
            'a',
            'b',
            'z',
            'f',
            'x'
        ], [
            'a',
            'b',
            'f',
            'w',
            'z'
        ], returnArg, returnArg);
        deepEqual(list, [
            'a',
            'b',
            'f',
            'w',
            'z'
        ]);
    });
});
/*can-connect@1.3.8#cache-requests/cache-requests*/
define('can-connect@1.3.8#cache-requests/cache-requests', function (require, exports, module) {
    var connect = require('can-connect');
    var getItems = require('can-connect/helpers/get-items');
    var canSet = require('can-set');
    var forEach = [].forEach;
    module.exports = connect.behavior('cache-requests', function (baseConnection) {
        return {
            getDiff: function (params, availableSets) {
                var minSets, self = this;
                forEach.call(availableSets, function (set) {
                    var curSets;
                    var difference = canSet.difference(params, set, self.algebra);
                    if (typeof difference === 'object') {
                        curSets = {
                            needed: difference,
                            cached: canSet.intersection(params, set, self.algebra),
                            count: canSet.count(difference, self.algebra)
                        };
                    } else if (canSet.subset(params, set, self.algebra)) {
                        curSets = {
                            cached: params,
                            count: 0
                        };
                    }
                    if (curSets) {
                        if (!minSets || curSets.count < minSets.count) {
                            minSets = curSets;
                        }
                    }
                });
                if (!minSets) {
                    return { needed: params };
                } else {
                    return {
                        needed: minSets.needed,
                        cached: minSets.cached
                    };
                }
            },
            getUnion: function (params, diff, neededItems, cachedItems) {
                return { data: canSet.getUnion(diff.needed, diff.cached, getItems(neededItems), getItems(cachedItems), this.algebra) };
            },
            getListData: function (set) {
                set = set || {};
                var self = this;
                return this.cacheConnection.getSets(set).then(function (sets) {
                    var diff = self.getDiff(set, sets);
                    if (!diff.needed) {
                        return self.cacheConnection.getListData(diff.cached);
                    } else if (!diff.cached) {
                        return baseConnection.getListData(diff.needed).then(function (data) {
                            return self.cacheConnection.updateListData(getItems(data), diff.needed).then(function () {
                                return data;
                            });
                        });
                    } else {
                        var cachedPromise = self.cacheConnection.getListData(diff.cached);
                        var needsPromise = baseConnection.getListData(diff.needed);
                        var savedPromise = needsPromise.then(function (data) {
                            return self.cacheConnection.updateListData(getItems(data), diff.needed).then(function () {
                                return data;
                            });
                        });
                        var combinedPromise = Promise.all([
                            cachedPromise,
                            needsPromise
                        ]).then(function (result) {
                            var cached = result[0], needed = result[1];
                            return self.getUnion(set, diff, needed, cached);
                        });
                        return Promise.all([
                            combinedPromise,
                            savedPromise
                        ]).then(function (data) {
                            return data[0];
                        });
                    }
                });
            }
        };
    });
});
/*can-connect@1.3.8#constructor/callbacks-once/callbacks-once*/
define('can-connect@1.3.8#constructor/callbacks-once/callbacks-once', function (require, exports, module) {
    var connect = require('can-connect');
    var sortedSetJSON = require('can-connect/helpers/sorted-set-json');
    var forEach = [].forEach;
    var callbacks = [
        'createdInstance',
        'updatedInstance',
        'destroyedInstance'
    ];
    module.exports = connect.behavior('constructor/callbacks-once', function (baseConnection) {
        var behavior = {};
        forEach.call(callbacks, function (name) {
            behavior[name] = function (instance, data) {
                var lastSerialized = this.getInstanceMetaData(instance, 'last-data-' + name);
                var serialize = sortedSetJSON(data);
                if (lastSerialized !== serialize) {
                    var result = baseConnection[name].apply(this, arguments);
                    this.addInstanceMetaData(instance, 'last-data-' + name, serialize);
                    return result;
                }
            };
        });
        return behavior;
    });
});
/*can-connect@1.3.8#data/callbacks/callbacks*/
define('can-connect@1.3.8#data/callbacks/callbacks', function (require, exports, module) {
    var connect = require('can-connect');
    var each = require('can-util/js/each/each');
    var pairs = {
        getListData: 'gotListData',
        createData: 'createdData',
        updateData: 'updatedData',
        destroyData: 'destroyedData'
    };
    module.exports = connect.behavior('data/callbacks', function (baseConnection) {
        var behavior = {};
        each(pairs, function (callbackName, name) {
            behavior[name] = function (params, cid) {
                var self = this;
                return baseConnection[name].call(this, params).then(function (data) {
                    if (self[callbackName]) {
                        return self[callbackName].call(self, data, params, cid);
                    } else {
                        return data;
                    }
                });
            };
        });
        return behavior;
    });
});
/*can-connect@1.3.8#data/callbacks-cache/callbacks-cache*/
define('can-connect@1.3.8#data/callbacks-cache/callbacks-cache', function (require, exports, module) {
    var connect = require('can-connect');
    var assign = require('can-util/js/assign/assign');
    var each = require('can-util/js/each/each');
    var pairs = {
        createdData: 'createData',
        updatedData: 'updateData',
        destroyedData: 'destroyData'
    };
    module.exports = connect.behavior('data/callbacks-cache', function (baseConnection) {
        var behavior = {};
        each(pairs, function (cacheCallback, dataCallbackName) {
            behavior[dataCallbackName] = function (data, set, cid) {
                this.cacheConnection[cacheCallback](assign(assign({}, set), data));
                return baseConnection[dataCallbackName].call(this, data, set, cid);
            };
        });
        return behavior;
    });
});
/*can-connect@1.3.8#helpers/deferred*/
define('can-connect@1.3.8#helpers/deferred', function (require, exports, module) {
    module.exports = function () {
        var def = {};
        def.promise = new Promise(function (resolve, reject) {
            def.resolve = resolve;
            def.reject = reject;
        });
        return def;
    };
});
/*can-connect@1.3.8#data/combine-requests/combine-requests*/
define('can-connect@1.3.8#data/combine-requests/combine-requests', function (require, exports, module) {
    var connect = require('can-connect');
    var canSet = require('can-set');
    var getItems = require('can-connect/helpers/get-items');
    var deepAssign = require('can-util/js/deep-assign/deep-assign');
    var makeDeferred = require('can-connect/helpers/deferred');
    var forEach = [].forEach;
    module.exports = connect.behavior('data/combine-requests', function (baseConnection) {
        var pendingRequests;
        return {
            unionPendingRequests: function (pendingRequests) {
                var self = this;
                pendingRequests.sort(function (pReq1, pReq2) {
                    if (canSet.subset(pReq1.set, pReq2.set, self.algebra)) {
                        return 1;
                    } else if (canSet.subset(pReq2.set, pReq1.set, self.algebra)) {
                        return -1;
                    } else {
                        return 0;
                    }
                });
                var combineData = [];
                var current;
                doubleLoop(pendingRequests, {
                    start: function (pendingRequest) {
                        current = {
                            set: pendingRequest.set,
                            pendingRequests: [pendingRequest]
                        };
                        combineData.push(current);
                    },
                    iterate: function (pendingRequest) {
                        var combined = canSet.union(current.set, pendingRequest.set, self.algebra);
                        if (combined) {
                            current.set = combined;
                            current.pendingRequests.push(pendingRequest);
                            return true;
                        }
                    }
                });
                return Promise.resolve(combineData);
            },
            getSubset: function (set, unionSet, data) {
                return canSet.getSubset(set, unionSet, data, this.algebra);
            },
            time: 1,
            getListData: function (set) {
                set = set || {};
                var self = this;
                if (!pendingRequests) {
                    pendingRequests = [];
                    setTimeout(function () {
                        var combineDataPromise = self.unionPendingRequests(pendingRequests);
                        pendingRequests = null;
                        combineDataPromise.then(function (combinedData) {
                            forEach.call(combinedData, function (combined) {
                                var combinedSet = deepAssign({}, combined.set);
                                baseConnection.getListData(combinedSet).then(function (data) {
                                    if (combined.pendingRequests.length === 1) {
                                        combined.pendingRequests[0].deferred.resolve(data);
                                    } else {
                                        forEach.call(combined.pendingRequests, function (pending) {
                                            pending.deferred.resolve({ data: self.getSubset(pending.set, combined.set, getItems(data)) });
                                        });
                                    }
                                }, function (err) {
                                    if (combined.pendingRequests.length === 1) {
                                        combined.pendingRequests[0].deferred.reject(err);
                                    } else {
                                        forEach.call(combined.pendingRequests, function (pending) {
                                            pending.deferred.reject(err);
                                        });
                                    }
                                });
                            });
                        });
                    }, this.time || 1);
                }
                var deferred = makeDeferred();
                pendingRequests.push({
                    deferred: deferred,
                    set: set
                });
                return deferred.promise;
            }
        };
    });
    var doubleLoop = function (arr, callbacks) {
        var i = 0;
        while (i < arr.length) {
            callbacks.start(arr[i]);
            var j = i + 1;
            while (j < arr.length) {
                if (callbacks.iterate(arr[j]) === true) {
                    arr.splice(j, 1);
                } else {
                    j++;
                }
            }
            i++;
        }
    };
});
/*can-connect@1.3.8#data/localstorage-cache/localstorage-cache*/
define('can-connect@1.3.8#data/localstorage-cache/localstorage-cache', function (require, exports, module) {
    var getItems = require('can-connect/helpers/get-items');
    var connect = require('can-connect');
    var sortedSetJSON = require('can-connect/helpers/sorted-set-json');
    var canSet = require('can-set');
    var forEach = [].forEach;
    var map = [].map;
    var setAdd = require('can-connect/helpers/set-add');
    var indexOf = require('can-connect/helpers/get-index-by-id');
    var assign = require('can-util/js/assign/assign');
    var overwrite = require('can-connect/helpers/overwrite');
    module.exports = connect.behavior('data/localstorage-cache', function (baseConnection) {
        var behavior = {
            _instances: {},
            getSetData: function () {
                var sets = {};
                var self = this;
                forEach.call(JSON.parse(localStorage.getItem(this.name + '-sets')) || [], function (set) {
                    var setKey = sortedSetJSON(set);
                    if (localStorage.getItem(self.name + '/set/' + setKey)) {
                        sets[setKey] = {
                            set: set,
                            setKey: setKey
                        };
                    }
                });
                return sets;
            },
            _getSets: function (setData) {
                var sets = [];
                setData = setData || this.getSetData();
                for (var setKey in setData) {
                    sets.push(JSON.parse(setKey));
                }
                return sets;
            },
            getInstance: function (id) {
                var res = localStorage.getItem(this.name + '/instance/' + id);
                if (res) {
                    return JSON.parse(res);
                }
            },
            updateInstance: function (props) {
                var id = this.id(props);
                var instance = this.getInstance(id);
                if (!instance) {
                    instance = props;
                } else {
                    overwrite(instance, props, this.idProp);
                }
                localStorage.setItem(this.name + '/instance/' + id, JSON.stringify(instance));
                return instance;
            },
            getInstances: function (ids) {
                var self = this;
                return map.call(ids, function (id) {
                    return self.getInstance(id);
                });
            },
            removeSet: function (setKey) {
                var sets = this.getSetData();
                localStorage.removeItem(this.name + '/set/' + setKey);
                delete sets[setKey];
            },
            updateSets: function (sets) {
                var setData = this._getSets(sets);
                localStorage.setItem(this.name + '-sets', JSON.stringify(setData));
            },
            updateSet: function (setDatum, items, newSet) {
                var newSetKey = newSet ? sortedSetJSON(newSet) : setDatum.setKey;
                if (newSet) {
                    if (newSetKey !== setDatum.setKey) {
                        var sets = this.getSetData();
                        localStorage.removeItem(this.name + '/set/' + setDatum.setKey);
                        delete sets[setDatum.setKey];
                        sets[newSetKey] = {
                            setKey: newSetKey,
                            set: newSet
                        };
                        this.updateSets(sets);
                    }
                }
                setDatum.items = items;
                var self = this;
                var ids = map.call(items, function (item) {
                    var id = self.id(item);
                    localStorage.setItem(self.name + '/instance/' + id, JSON.stringify(item));
                    return id;
                });
                localStorage.setItem(this.name + '/set/' + newSetKey, JSON.stringify(ids));
            },
            addSet: function (set, data) {
                var items = getItems(data);
                var sets = this.getSetData();
                var setKey = sortedSetJSON(set);
                sets[setKey] = {
                    setKey: setKey,
                    items: items,
                    set: set
                };
                var self = this;
                var ids = map.call(items, function (item) {
                    var id = self.id(item);
                    localStorage.setItem(self.name + '/instance/' + id, JSON.stringify(item));
                    return id;
                });
                localStorage.setItem(this.name + '/set/' + setKey, JSON.stringify(ids));
                this.updateSets(sets);
            },
            _eachSet: function (cb) {
                var sets = this.getSetData();
                var self = this;
                var loop = function (setDatum, setKey) {
                    return cb.call(self, setDatum, setKey, function () {
                        if (!('items' in setDatum)) {
                            var ids = JSON.parse(localStorage.getItem(self.name + '/set/' + setKey));
                            setDatum.items = self.getInstances(ids);
                        }
                        return setDatum.items;
                    });
                };
                for (var setKey in sets) {
                    var setDatum = sets[setKey];
                    var result = loop(setDatum, setKey);
                    if (result !== undefined) {
                        return result;
                    }
                }
            },
            clear: function () {
                var sets = this.getSetData();
                for (var setKey in sets) {
                    localStorage.removeItem(this.name + '/set/' + setKey);
                }
                localStorage.removeItem(this.name + '-sets');
                var keys = [];
                for (var i = 0, len = localStorage.length; i < len; ++i) {
                    if (localStorage.key(i).indexOf(this.name + '/instance/') === 0) {
                        keys.push(localStorage.key(i));
                    }
                }
                forEach.call(keys, function (key) {
                    localStorage.removeItem(key);
                });
                this._instances = {};
            },
            getSets: function () {
                return Promise.resolve(this._getSets());
            },
            getListData: function (set) {
                set = set || {};
                var listData = this.getListDataSync(set);
                if (listData) {
                    return Promise.resolve(listData);
                }
                return Promise.reject({
                    message: 'no data',
                    error: 404
                });
            },
            getListDataSync: function (set) {
                var sets = this._getSets();
                for (var i = 0; i < sets.length; i++) {
                    var checkSet = sets[i];
                    if (canSet.subset(set, checkSet, this.algebra)) {
                        var items = canSet.getSubset(set, checkSet, this.__getListData(checkSet), this.algebra);
                        return { data: items };
                    }
                }
            },
            __getListData: function (set) {
                var setKey = sortedSetJSON(set);
                var setDatum = this.getSetData()[setKey];
                if (setDatum) {
                    var localData = localStorage.getItem(this.name + '/set/' + setKey);
                    if (localData) {
                        return this.getInstances(JSON.parse(localData));
                    }
                }
            },
            getData: function (params) {
                var id = this.id(params);
                var res = localStorage.getItem(this.name + '/instance/' + id);
                if (res) {
                    return Promise.resolve(JSON.parse(res));
                } else {
                    return Promise.reject({
                        message: 'no data',
                        error: 404
                    });
                }
            },
            updateListData: function (data, set) {
                set = set || {};
                var items = getItems(data);
                var sets = this.getSetData();
                var self = this;
                for (var setKey in sets) {
                    var setDatum = sets[setKey];
                    var union = canSet.union(setDatum.set, set, this.algebra);
                    if (union) {
                        return this.getListData(setDatum.set).then(function (setData) {
                            self.updateSet(setDatum, canSet.getUnion(setDatum.set, set, getItems(setData), items, this.algebra), union);
                        });
                    }
                }
                this.addSet(set, data);
                return Promise.resolve();
            },
            createData: function (props) {
                var self = this;
                var instance = this.updateInstance(props);
                this._eachSet(function (setDatum, setKey, getItems) {
                    if (canSet.has(setDatum.set, instance, this.algebra)) {
                        self.updateSet(setDatum, setAdd(self, setDatum.set, getItems(), instance, self.algebra), setDatum.set);
                    }
                });
                return Promise.resolve(assign({}, instance));
            },
            updateData: function (props) {
                var self = this;
                var instance = this.updateInstance(props);
                this._eachSet(function (setDatum, setKey, getItems) {
                    var items = getItems();
                    var index = indexOf(self, instance, items);
                    if (canSet.has(setDatum.set, instance, this.algebra)) {
                        if (index === -1) {
                            self.updateSet(setDatum, setAdd(self, setDatum.set, getItems(), instance, self.algebra));
                        } else {
                            items.splice(index, 1, instance);
                            self.updateSet(setDatum, items);
                        }
                    } else if (index !== -1) {
                        items.splice(index, 1);
                        self.updateSet(setDatum, items);
                    }
                });
                return Promise.resolve(assign({}, instance));
            },
            destroyData: function (props) {
                var self = this;
                var instance = this.updateInstance(props);
                this._eachSet(function (setDatum, setKey, getItems) {
                    var items = getItems();
                    var index = indexOf(self, instance, items);
                    if (index !== -1) {
                        items.splice(index, 1);
                        self.updateSet(setDatum, items);
                    }
                });
                var id = this.id(instance);
                localStorage.removeItem(this.name + '/instance/' + id);
                return Promise.resolve(assign({}, instance));
            }
        };
        return behavior;
    });
});
/*can-connect@1.3.8#data/parse/parse*/
define('can-connect@1.3.8#data/parse/parse', function (require, exports, module) {
    var connect = require('can-connect');
    var each = require('can-util/js/each/each');
    var isArray = require('can-util/js/is-array/is-array');
    var getObject = require('can-util/js/get/get');
    module.exports = connect.behavior('data/parse', function (baseConnection) {
        var behavior = {
            parseListData: function (responseData) {
                if (baseConnection.parseListData) {
                    responseData = baseConnection.parseListData.apply(this, arguments);
                }
                var result;
                if (isArray(responseData)) {
                    result = { data: responseData };
                } else {
                    var prop = this.parseListProp || 'data';
                    responseData.data = getObject(responseData, prop);
                    result = responseData;
                    if (prop !== 'data') {
                        delete responseData[prop];
                    }
                    if (!isArray(result.data)) {
                        throw new Error('Could not get any raw data while converting using .parseListData');
                    }
                }
                var arr = [];
                for (var i = 0; i < result.data.length; i++) {
                    arr.push(this.parseInstanceData(result.data[i]));
                }
                result.data = arr;
                return result;
            },
            parseInstanceData: function (props) {
                if (baseConnection.parseInstanceData) {
                    props = baseConnection.parseInstanceData.apply(this, arguments) || props;
                }
                return this.parseInstanceProp ? getObject(props, this.parseInstanceProp) || props : props;
            }
        };
        each(pairs, function (parseFunction, name) {
            behavior[name] = function (params) {
                var self = this;
                return baseConnection[name].call(this, params).then(function () {
                    return self[parseFunction].apply(self, arguments);
                });
            };
        });
        return behavior;
    });
    var pairs = {
        getListData: 'parseListData',
        getData: 'parseInstanceData',
        createData: 'parseInstanceData',
        updateData: 'parseInstanceData',
        destroyData: 'parseInstanceData'
    };
});
/*can-connect@1.3.8#fall-through-cache/fall-through-cache*/
define('can-connect@1.3.8#fall-through-cache/fall-through-cache', function (require, exports, module) {
    var connect = require('can-connect');
    var sortedSetJSON = require('../helpers/sorted-set-json');
    var canLog = require('can-util/js/log/log');
    module.exports = connect.behavior('fall-through-cache', function (baseConnection) {
        var behavior = {
            hydrateList: function (listData, set) {
                set = set || this.listSet(listData);
                var id = sortedSetJSON(set);
                var list = baseConnection.hydrateList.call(this, listData, set);
                if (this._getHydrateListCallbacks[id]) {
                    this._getHydrateListCallbacks[id].shift()(list);
                    if (!this._getHydrateListCallbacks[id].length) {
                        delete this._getHydrateListCallbacks[id];
                    }
                }
                return list;
            },
            _getHydrateListCallbacks: {},
            _getHydrateList: function (set, callback) {
                var id = sortedSetJSON(set);
                if (!this._getHydrateListCallbacks[id]) {
                    this._getHydrateListCallbacks[id] = [];
                }
                this._getHydrateListCallbacks[id].push(callback);
            },
            getListData: function (set) {
                set = set || {};
                var self = this;
                return this.cacheConnection.getListData(set).then(function (data) {
                    self._getHydrateList(set, function (list) {
                        self.addListReference(list, set);
                        setTimeout(function () {
                            baseConnection.getListData.call(self, set).then(function (listData) {
                                self.cacheConnection.updateListData(listData, set);
                                self.updatedList(list, listData, set);
                                self.deleteListReference(list, set);
                            }, function (e) {
                                canLog.log('REJECTED', e);
                            });
                        }, 1);
                    });
                    return data;
                }, function () {
                    var listData = baseConnection.getListData.call(self, set);
                    listData.then(function (listData) {
                        self.cacheConnection.updateListData(listData, set);
                    });
                    return listData;
                });
            },
            hydrateInstance: function (props) {
                var id = this.id(props);
                var instance = baseConnection.hydrateInstance.apply(this, arguments);
                if (this._getMakeInstanceCallbacks[id]) {
                    this._getMakeInstanceCallbacks[id].shift()(instance);
                    if (!this._getMakeInstanceCallbacks[id].length) {
                        delete this._getMakeInstanceCallbacks[id];
                    }
                }
                return instance;
            },
            _getMakeInstanceCallbacks: {},
            _getMakeInstance: function (id, callback) {
                if (!this._getMakeInstanceCallbacks[id]) {
                    this._getMakeInstanceCallbacks[id] = [];
                }
                this._getMakeInstanceCallbacks[id].push(callback);
            },
            getData: function (params) {
                var self = this;
                return this.cacheConnection.getData(params).then(function (instanceData) {
                    self._getMakeInstance(self.id(instanceData) || self.id(params), function (instance) {
                        self.addInstanceReference(instance);
                        setTimeout(function () {
                            baseConnection.getData.call(self, params).then(function (instanceData2) {
                                self.cacheConnection.updateData(instanceData2);
                                self.updatedInstance(instance, instanceData2);
                                self.deleteInstanceReference(instance);
                            }, function (e) {
                                canLog.log('REJECTED', e);
                            });
                        }, 1);
                    });
                    return instanceData;
                }, function () {
                    var listData = baseConnection.getData.call(self, params);
                    listData.then(function (instanceData) {
                        self.cacheConnection.updateData(instanceData);
                    });
                    return listData;
                });
            }
        };
        return behavior;
    });
});
/*can-connect@1.3.8#real-time/real-time*/
define('can-connect@1.3.8#real-time/real-time', function (require, exports, module) {
    var connect = require('../can-connect');
    var canSet = require('can-set');
    var setAdd = require('can-connect/helpers/set-add');
    var indexOf = require('can-connect/helpers/get-index-by-id');
    var canDev = require('can-util/js/dev/dev');
    module.exports = connect.behavior('real-time', function (baseConnection) {
        return {
            createInstance: function (props) {
                var id = this.id(props);
                var instance = this.instanceStore.get(id);
                var serialized;
                if (instance) {
                    return this.updateInstance(props);
                } else {
                    instance = this.hydrateInstance(props);
                    serialized = this.serializeInstance(instance);
                    var self = this;
                    this.addInstanceReference(instance);
                    return Promise.resolve(this.createdData(props, serialized)).then(function () {
                        self.deleteInstanceReference(instance);
                        return instance;
                    });
                }
            },
            createdData: function (props, params, cid) {
                var instance;
                if (cid !== undefined) {
                    instance = this.cidStore.get(cid);
                } else {
                    instance = this.instanceStore.get(this.id(props));
                }
                this.addInstanceReference(instance, this.id(props));
                this.createdInstance(instance, props);
                create.call(this, this.serializeInstance(instance));
                this.deleteInstanceReference(instance);
                return undefined;
            },
            updatedData: function (props, params) {
                var instance = this.instanceStore.get(this.id(params));
                this.updatedInstance(instance, props);
                update.call(this, this.serializeInstance(instance));
                return undefined;
            },
            updateInstance: function (props) {
                var id = this.id(props);
                var instance = this.instanceStore.get(id);
                if (!instance) {
                    instance = this.hydrateInstance(props);
                }
                this.addInstanceReference(instance);
                var serialized = this.serializeInstance(instance), self = this;
                return Promise.resolve(this.updatedData(props, serialized)).then(function () {
                    self.deleteInstanceReference(instance);
                    return instance;
                });
            },
            destroyedData: function (props, params) {
                var id = this.id(params || props);
                var instance = this.instanceStore.get(id);
                if (!instance) {
                    instance = this.hydrateInstance(props);
                }
                var serialized = this.serializeInstance(instance);
                this.destroyedInstance(instance, props);
                destroy.call(this, serialized);
                return undefined;
            },
            destroyInstance: function (props) {
                var id = this.id(props);
                var instance = this.instanceStore.get(id);
                if (!instance) {
                    instance = this.hydrateInstance(props);
                }
                this.addInstanceReference(instance);
                var serialized = this.serializeInstance(instance), self = this;
                return Promise.resolve(this.destroyedData(props, serialized)).then(function () {
                    self.deleteInstanceReference(instance);
                    return instance;
                });
            }
        };
    });
    var create = function (props) {
        var self = this;
        this.listStore.forEach(function (list, id) {
            var set = JSON.parse(id);
            var index = indexOf(self, props, list);
            if (canSet.has(set, props, self.algebra)) {
                if (index === -1) {
                    var items = self.serializeList(list);
                    self.updatedList(list, { data: setAdd(self, set, items, props, self.algebra) }, set);
                } else {
                }
            }
        });
    };
    var update = function (props) {
        var self = this;
        this.listStore.forEach(function (list, id) {
            var items;
            var set = JSON.parse(id);
            var index = indexOf(self, props, list);
            if (canSet.has(set, props, self.algebra)) {
                items = self.serializeList(list);
                if (index === -1) {
                    self.updatedList(list, { data: setAdd(self, set, items, props, self.algebra) }, set);
                } else {
                    var sortedIndex = canSet.index(set, items, props, self.algebra);
                    if (sortedIndex !== undefined && sortedIndex !== index) {
                        var copy = items.slice(0);
                        if (index < sortedIndex) {
                            copy.splice(sortedIndex, 0, props);
                            copy.splice(index, 1);
                        } else {
                            copy.splice(index, 1);
                            copy.splice(sortedIndex, 0, props);
                        }
                        self.updatedList(list, { data: copy }, set);
                    }
                }
            } else if (index !== -1) {
                items = self.serializeList(list);
                items.splice(index, 1);
                self.updatedList(list, { data: items }, set);
            }
        });
    };
    var destroy = function (props) {
        var self = this;
        this.listStore.forEach(function (list, id) {
            var set = JSON.parse(id);
            var index = indexOf(self, props, list);
            if (index !== -1) {
                var items = self.serializeList(list);
                items.splice(index, 1);
                self.updatedList(list, { data: items }, set);
            }
        });
    };
});
/*can-connect@1.3.8#can/ref/ref*/
define('can-connect@1.3.8#can/ref/ref', function (require, exports, module) {
    var connect = require('can-connect');
    var getIdProps = require('can-connect/helpers/get-id-props');
    var WeakReferenceMap = require('can-connect/helpers/weak-reference-map');
    var Observation = require('can-observation');
    var constructorStore = require('can-connect/constructor/store/store');
    var define = require('can-define');
    var makeRef = function (connection) {
        var idProp = getIdProps(connection)[0];
        var Ref = function (id, value) {
            if (typeof id === 'object') {
                value = id;
                id = value[idProp];
            }
            var storeRef = Ref.store.get(id);
            if (storeRef) {
                if (value && !storeRef._value) {
                    if (value instanceof connection.Map) {
                        storeRef._value = value;
                    } else {
                        storeRef._value = connection.hydrateInstance(value);
                    }
                }
                return storeRef;
            }
            this[idProp] = id;
            if (value) {
                if (value instanceof connection.Map) {
                    this._value = value;
                } else {
                    this._value = connection.hydrateInstance(value);
                }
            }
            if (constructorStore.requests.count() > 0) {
                if (!Ref._requestInstances[id]) {
                    Ref.store.addReference(id, this);
                    Ref._requestInstances[id] = this;
                }
            }
        };
        Ref.store = new WeakReferenceMap();
        Ref._requestInstances = {};
        Ref.type = function (ref) {
            if (ref && typeof ref !== 'object') {
                return new Ref(ref);
            } else {
                return new Ref(ref[idProp], ref);
            }
        };
        var defs = {
            promise: {
                get: function () {
                    if (this._value) {
                        return Promise.resolve(this._value);
                    } else {
                        var props = {};
                        props[idProp] = this[idProp];
                        return connection.Map.get(props);
                    }
                }
            },
            _state: {
                get: function (lastSet, resolve) {
                    if (resolve) {
                        this.promise.then(function () {
                            resolve('resolved');
                        }, function () {
                            resolve('rejected');
                        });
                    }
                    return 'pending';
                }
            },
            value: {
                get: function (lastSet, resolve) {
                    if (this._value) {
                        return this._value;
                    } else if (resolve) {
                        this.promise.then(function (value) {
                            resolve(value);
                        });
                    }
                }
            },
            reason: {
                get: function (lastSet, resolve) {
                    if (this._value) {
                        return undefined;
                    } else {
                        this.promise.catch(function (value) {
                            resolve(value);
                        });
                    }
                }
            }
        };
        defs[idProp] = {
            type: '*',
            set: function () {
                this._value = undefined;
            }
        };
        define(Ref.prototype, defs);
        Ref.prototype.unobservedId = Observation.ignore(function () {
            return this[idProp];
        });
        Ref.prototype.isResolved = function () {
            return !!this._value || this._state === 'resolved';
        };
        Ref.prototype.isRejected = function () {
            return this._state === 'rejected';
        };
        Ref.prototype.isPending = function () {
            return !this._value && (this._state !== 'resolved' || this._state !== 'rejected');
        };
        Ref.prototype.serialize = function () {
            return this[idProp];
        };
        var baseEventSetup = Ref.prototype._eventSetup;
        Ref.prototype._eventSetup = function () {
            Ref.store.addReference(this.unobservedId(), this);
            return baseEventSetup.apply(this, arguments);
        };
        var baseTeardown = Ref.prototype._eventTeardown;
        Ref.prototype._eventTeardown = function () {
            Ref.store.deleteReference(this.unobservedId(), this);
            return baseTeardown.apply(this, arguments);
        };
        constructorStore.requests.on('end', function () {
            for (var id in Ref._requestInstances) {
                Ref.store.deleteReference(id);
            }
            Ref._requestInstances = {};
        });
        return Ref;
    };
    module.exports = connect.behavior('can/ref', function (baseConnection) {
        return {
            init: function () {
                baseConnection.init.apply(this, arguments);
                this.Map.Ref = makeRef(this);
            }
        };
    });
});
/*jquery@3.1.1#dist/jquery*/
(function (global, factory) {
    'use strict';
    if (typeof module === 'object' && typeof module.exports === 'object') {
        module.exports = global.document ? factory(global, true) : function (w) {
            if (!w.document) {
                throw new Error('jQuery requires a window with a document');
            }
            return factory(w);
        };
    } else {
        factory(global);
    }
}(typeof window !== 'undefined' ? window : this, function (window, noGlobal) {
    'use strict';
    var arr = [];
    var document = window.document;
    var getProto = Object.getPrototypeOf;
    var slice = arr.slice;
    var concat = arr.concat;
    var push = arr.push;
    var indexOf = arr.indexOf;
    var class2type = {};
    var toString = class2type.toString;
    var hasOwn = class2type.hasOwnProperty;
    var fnToString = hasOwn.toString;
    var ObjectFunctionString = fnToString.call(Object);
    var support = {};
    function DOMEval(code, doc) {
        doc = doc || document;
        var script = doc.createElement('script');
        script.text = code;
        doc.head.appendChild(script).parentNode.removeChild(script);
    }
    var version = '3.1.1', jQuery = function (selector, context) {
            return new jQuery.fn.init(selector, context);
        }, rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, rmsPrefix = /^-ms-/, rdashAlpha = /-([a-z])/g, fcamelCase = function (all, letter) {
            return letter.toUpperCase();
        };
    jQuery.fn = jQuery.prototype = {
        jquery: version,
        constructor: jQuery,
        length: 0,
        toArray: function () {
            return slice.call(this);
        },
        get: function (num) {
            if (num == null) {
                return slice.call(this);
            }
            return num < 0 ? this[num + this.length] : this[num];
        },
        pushStack: function (elems) {
            var ret = jQuery.merge(this.constructor(), elems);
            ret.prevObject = this;
            return ret;
        },
        each: function (callback) {
            return jQuery.each(this, callback);
        },
        map: function (callback) {
            return this.pushStack(jQuery.map(this, function (elem, i) {
                return callback.call(elem, i, elem);
            }));
        },
        slice: function () {
            return this.pushStack(slice.apply(this, arguments));
        },
        first: function () {
            return this.eq(0);
        },
        last: function () {
            return this.eq(-1);
        },
        eq: function (i) {
            var len = this.length, j = +i + (i < 0 ? len : 0);
            return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
        },
        end: function () {
            return this.prevObject || this.constructor();
        },
        push: push,
        sort: arr.sort,
        splice: arr.splice
    };
    jQuery.extend = jQuery.fn.extend = function () {
        var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
        if (typeof target === 'boolean') {
            deep = target;
            target = arguments[i] || {};
            i++;
        }
        if (typeof target !== 'object' && !jQuery.isFunction(target)) {
            target = {};
        }
        if (i === length) {
            target = this;
            i--;
        }
        for (; i < length; i++) {
            if ((options = arguments[i]) != null) {
                for (name in options) {
                    src = target[name];
                    copy = options[name];
                    if (target === copy) {
                        continue;
                    }
                    if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
                        if (copyIsArray) {
                            copyIsArray = false;
                            clone = src && jQuery.isArray(src) ? src : [];
                        } else {
                            clone = src && jQuery.isPlainObject(src) ? src : {};
                        }
                        target[name] = jQuery.extend(deep, clone, copy);
                    } else if (copy !== undefined) {
                        target[name] = copy;
                    }
                }
            }
        }
        return target;
    };
    jQuery.extend({
        expando: 'jQuery' + (version + Math.random()).replace(/\D/g, ''),
        isReady: true,
        error: function (msg) {
            throw new Error(msg);
        },
        noop: function () {
        },
        isFunction: function (obj) {
            return jQuery.type(obj) === 'function';
        },
        isArray: Array.isArray,
        isWindow: function (obj) {
            return obj != null && obj === obj.window;
        },
        isNumeric: function (obj) {
            var type = jQuery.type(obj);
            return (type === 'number' || type === 'string') && !isNaN(obj - parseFloat(obj));
        },
        isPlainObject: function (obj) {
            var proto, Ctor;
            if (!obj || toString.call(obj) !== '[object Object]') {
                return false;
            }
            proto = getProto(obj);
            if (!proto) {
                return true;
            }
            Ctor = hasOwn.call(proto, 'constructor') && proto.constructor;
            return typeof Ctor === 'function' && fnToString.call(Ctor) === ObjectFunctionString;
        },
        isEmptyObject: function (obj) {
            var name;
            for (name in obj) {
                return false;
            }
            return true;
        },
        type: function (obj) {
            if (obj == null) {
                return obj + '';
            }
            return typeof obj === 'object' || typeof obj === 'function' ? class2type[toString.call(obj)] || 'object' : typeof obj;
        },
        globalEval: function (code) {
            DOMEval(code);
        },
        camelCase: function (string) {
            return string.replace(rmsPrefix, 'ms-').replace(rdashAlpha, fcamelCase);
        },
        nodeName: function (elem, name) {
            return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
        },
        each: function (obj, callback) {
            var length, i = 0;
            if (isArrayLike(obj)) {
                length = obj.length;
                for (; i < length; i++) {
                    if (callback.call(obj[i], i, obj[i]) === false) {
                        break;
                    }
                }
            } else {
                for (i in obj) {
                    if (callback.call(obj[i], i, obj[i]) === false) {
                        break;
                    }
                }
            }
            return obj;
        },
        trim: function (text) {
            return text == null ? '' : (text + '').replace(rtrim, '');
        },
        makeArray: function (arr, results) {
            var ret = results || [];
            if (arr != null) {
                if (isArrayLike(Object(arr))) {
                    jQuery.merge(ret, typeof arr === 'string' ? [arr] : arr);
                } else {
                    push.call(ret, arr);
                }
            }
            return ret;
        },
        inArray: function (elem, arr, i) {
            return arr == null ? -1 : indexOf.call(arr, elem, i);
        },
        merge: function (first, second) {
            var len = +second.length, j = 0, i = first.length;
            for (; j < len; j++) {
                first[i++] = second[j];
            }
            first.length = i;
            return first;
        },
        grep: function (elems, callback, invert) {
            var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert;
            for (; i < length; i++) {
                callbackInverse = !callback(elems[i], i);
                if (callbackInverse !== callbackExpect) {
                    matches.push(elems[i]);
                }
            }
            return matches;
        },
        map: function (elems, callback, arg) {
            var length, value, i = 0, ret = [];
            if (isArrayLike(elems)) {
                length = elems.length;
                for (; i < length; i++) {
                    value = callback(elems[i], i, arg);
                    if (value != null) {
                        ret.push(value);
                    }
                }
            } else {
                for (i in elems) {
                    value = callback(elems[i], i, arg);
                    if (value != null) {
                        ret.push(value);
                    }
                }
            }
            return concat.apply([], ret);
        },
        guid: 1,
        proxy: function (fn, context) {
            var tmp, args, proxy;
            if (typeof context === 'string') {
                tmp = fn[context];
                context = fn;
                fn = tmp;
            }
            if (!jQuery.isFunction(fn)) {
                return undefined;
            }
            args = slice.call(arguments, 2);
            proxy = function () {
                return fn.apply(context || this, args.concat(slice.call(arguments)));
            };
            proxy.guid = fn.guid = fn.guid || jQuery.guid++;
            return proxy;
        },
        now: Date.now,
        support: support
    });
    if (typeof Symbol === 'function') {
        jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
    }
    jQuery.each('Boolean Number String Function Array Date RegExp Object Error Symbol'.split(' '), function (i, name) {
        class2type['[object ' + name + ']'] = name.toLowerCase();
    });
    function isArrayLike(obj) {
        var length = !!obj && 'length' in obj && obj.length, type = jQuery.type(obj);
        if (type === 'function' || jQuery.isWindow(obj)) {
            return false;
        }
        return type === 'array' || length === 0 || typeof length === 'number' && length > 0 && length - 1 in obj;
    }
    var Sizzle = function (window) {
        var i, support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = 'sizzle' + 1 * new Date(), preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), sortOrder = function (a, b) {
                if (a === b) {
                    hasDuplicate = true;
                }
                return 0;
            }, hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push = arr.push, slice = arr.slice, indexOf = function (list, elem) {
                var i = 0, len = list.length;
                for (; i < len; i++) {
                    if (list[i] === elem) {
                        return i;
                    }
                }
                return -1;
            }, booleans = 'checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped', whitespace = '[\\x20\\t\\r\\n\\f]', identifier = '(?:\\\\.|[\\w-]|[^\0-\\xa0])+', attributes = '\\[' + whitespace + '*(' + identifier + ')(?:' + whitespace + '*([*^$|!~]?=)' + whitespace + '*(?:\'((?:\\\\.|[^\\\\\'])*)\'|"((?:\\\\.|[^\\\\"])*)"|(' + identifier + '))|)' + whitespace + '*\\]', pseudos = ':(' + identifier + ')(?:\\((' + '(\'((?:\\\\.|[^\\\\\'])*)\'|"((?:\\\\.|[^\\\\"])*)")|' + '((?:\\\\.|[^\\\\()[\\]]|' + attributes + ')*)|' + '.*' + ')\\)|)', rwhitespace = new RegExp(whitespace + '+', 'g'), rtrim = new RegExp('^' + whitespace + '+|((?:^|[^\\\\])(?:\\\\.)*)' + whitespace + '+$', 'g'), rcomma = new RegExp('^' + whitespace + '*,' + whitespace + '*'), rcombinators = new RegExp('^' + whitespace + '*([>+~]|' + whitespace + ')' + whitespace + '*'), rattributeQuotes = new RegExp('=' + whitespace + '*([^\\]\'"]*?)' + whitespace + '*\\]', 'g'), rpseudo = new RegExp(pseudos), ridentifier = new RegExp('^' + identifier + '$'), matchExpr = {
                'ID': new RegExp('^#(' + identifier + ')'),
                'CLASS': new RegExp('^\\.(' + identifier + ')'),
                'TAG': new RegExp('^(' + identifier + '|[*])'),
                'ATTR': new RegExp('^' + attributes),
                'PSEUDO': new RegExp('^' + pseudos),
                'CHILD': new RegExp('^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(' + whitespace + '*(even|odd|(([+-]|)(\\d*)n|)' + whitespace + '*(?:([+-]|)' + whitespace + '*(\\d+)|))' + whitespace + '*\\)|)', 'i'),
                'bool': new RegExp('^(?:' + booleans + ')$', 'i'),
                'needsContext': new RegExp('^' + whitespace + '*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(' + whitespace + '*((?:-\\d)?\\d*)' + whitespace + '*\\)|)(?=[^-]|$)', 'i')
            }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, runescape = new RegExp('\\\\([\\da-f]{1,6}' + whitespace + '?|(' + whitespace + ')|.)', 'ig'), funescape = function (_, escaped, escapedWhitespace) {
                var high = '0x' + escaped - 65536;
                return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
            }, rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g, fcssescape = function (ch, asCodePoint) {
                if (asCodePoint) {
                    if (ch === '\0') {
                        return '\uFFFD';
                    }
                    return ch.slice(0, -1) + '\\' + ch.charCodeAt(ch.length - 1).toString(16) + ' ';
                }
                return '\\' + ch;
            }, unloadHandler = function () {
                setDocument();
            }, disabledAncestor = addCombinator(function (elem) {
                return elem.disabled === true && ('form' in elem || 'label' in elem);
            }, {
                dir: 'parentNode',
                next: 'legend'
            });
        try {
            push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
            arr[preferredDoc.childNodes.length].nodeType;
        } catch (e) {
            push = {
                apply: arr.length ? function (target, els) {
                    push_native.apply(target, slice.call(els));
                } : function (target, els) {
                    var j = target.length, i = 0;
                    while (target[j++] = els[i++]) {
                    }
                    target.length = j - 1;
                }
            };
        }
        function Sizzle(selector, context, results, seed) {
            var m, i, elem, nid, match, groups, newSelector, newContext = context && context.ownerDocument, nodeType = context ? context.nodeType : 9;
            results = results || [];
            if (typeof selector !== 'string' || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
                return results;
            }
            if (!seed) {
                if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
                    setDocument(context);
                }
                context = context || document;
                if (documentIsHTML) {
                    if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
                        if (m = match[1]) {
                            if (nodeType === 9) {
                                if (elem = context.getElementById(m)) {
                                    if (elem.id === m) {
                                        results.push(elem);
                                        return results;
                                    }
                                } else {
                                    return results;
                                }
                            } else {
                                if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {
                                    results.push(elem);
                                    return results;
                                }
                            }
                        } else if (match[2]) {
                            push.apply(results, context.getElementsByTagName(selector));
                            return results;
                        } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
                            push.apply(results, context.getElementsByClassName(m));
                            return results;
                        }
                    }
                    if (support.qsa && !compilerCache[selector + ' '] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                        if (nodeType !== 1) {
                            newContext = context;
                            newSelector = selector;
                        } else if (context.nodeName.toLowerCase() !== 'object') {
                            if (nid = context.getAttribute('id')) {
                                nid = nid.replace(rcssescape, fcssescape);
                            } else {
                                context.setAttribute('id', nid = expando);
                            }
                            groups = tokenize(selector);
                            i = groups.length;
                            while (i--) {
                                groups[i] = '#' + nid + ' ' + toSelector(groups[i]);
                            }
                            newSelector = groups.join(',');
                            newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                        }
                        if (newSelector) {
                            try {
                                push.apply(results, newContext.querySelectorAll(newSelector));
                                return results;
                            } catch (qsaError) {
                            } finally {
                                if (nid === expando) {
                                    context.removeAttribute('id');
                                }
                            }
                        }
                    }
                }
            }
            return select(selector.replace(rtrim, '$1'), context, results, seed);
        }
        function createCache() {
            var keys = [];
            function cache(key, value) {
                if (keys.push(key + ' ') > Expr.cacheLength) {
                    delete cache[keys.shift()];
                }
                return cache[key + ' '] = value;
            }
            return cache;
        }
        function markFunction(fn) {
            fn[expando] = true;
            return fn;
        }
        function assert(fn) {
            var el = document.createElement('fieldset');
            try {
                return !!fn(el);
            } catch (e) {
                return false;
            } finally {
                if (el.parentNode) {
                    el.parentNode.removeChild(el);
                }
                el = null;
            }
        }
        function addHandle(attrs, handler) {
            var arr = attrs.split('|'), i = arr.length;
            while (i--) {
                Expr.attrHandle[arr[i]] = handler;
            }
        }
        function siblingCheck(a, b) {
            var cur = b && a, diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex;
            if (diff) {
                return diff;
            }
            if (cur) {
                while (cur = cur.nextSibling) {
                    if (cur === b) {
                        return -1;
                    }
                }
            }
            return a ? 1 : -1;
        }
        function createInputPseudo(type) {
            return function (elem) {
                var name = elem.nodeName.toLowerCase();
                return name === 'input' && elem.type === type;
            };
        }
        function createButtonPseudo(type) {
            return function (elem) {
                var name = elem.nodeName.toLowerCase();
                return (name === 'input' || name === 'button') && elem.type === type;
            };
        }
        function createDisabledPseudo(disabled) {
            return function (elem) {
                if ('form' in elem) {
                    if (elem.parentNode && elem.disabled === false) {
                        if ('label' in elem) {
                            if ('label' in elem.parentNode) {
                                return elem.parentNode.disabled === disabled;
                            } else {
                                return elem.disabled === disabled;
                            }
                        }
                        return elem.isDisabled === disabled || elem.isDisabled !== !disabled && disabledAncestor(elem) === disabled;
                    }
                    return elem.disabled === disabled;
                } else if ('label' in elem) {
                    return elem.disabled === disabled;
                }
                return false;
            };
        }
        function createPositionalPseudo(fn) {
            return markFunction(function (argument) {
                argument = +argument;
                return markFunction(function (seed, matches) {
                    var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length;
                    while (i--) {
                        if (seed[j = matchIndexes[i]]) {
                            seed[j] = !(matches[j] = seed[j]);
                        }
                    }
                });
            });
        }
        function testContext(context) {
            return context && typeof context.getElementsByTagName !== 'undefined' && context;
        }
        support = Sizzle.support = {};
        isXML = Sizzle.isXML = function (elem) {
            var documentElement = elem && (elem.ownerDocument || elem).documentElement;
            return documentElement ? documentElement.nodeName !== 'HTML' : false;
        };
        setDocument = Sizzle.setDocument = function (node) {
            var hasCompare, subWindow, doc = node ? node.ownerDocument || node : preferredDoc;
            if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
                return document;
            }
            document = doc;
            docElem = document.documentElement;
            documentIsHTML = !isXML(document);
            if (preferredDoc !== document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {
                if (subWindow.addEventListener) {
                    subWindow.addEventListener('unload', unloadHandler, false);
                } else if (subWindow.attachEvent) {
                    subWindow.attachEvent('onunload', unloadHandler);
                }
            }
            support.attributes = assert(function (el) {
                el.className = 'i';
                return !el.getAttribute('className');
            });
            support.getElementsByTagName = assert(function (el) {
                el.appendChild(document.createComment(''));
                return !el.getElementsByTagName('*').length;
            });
            support.getElementsByClassName = rnative.test(document.getElementsByClassName);
            support.getById = assert(function (el) {
                docElem.appendChild(el).id = expando;
                return !document.getElementsByName || !document.getElementsByName(expando).length;
            });
            if (support.getById) {
                Expr.filter['ID'] = function (id) {
                    var attrId = id.replace(runescape, funescape);
                    return function (elem) {
                        return elem.getAttribute('id') === attrId;
                    };
                };
                Expr.find['ID'] = function (id, context) {
                    if (typeof context.getElementById !== 'undefined' && documentIsHTML) {
                        var elem = context.getElementById(id);
                        return elem ? [elem] : [];
                    }
                };
            } else {
                Expr.filter['ID'] = function (id) {
                    var attrId = id.replace(runescape, funescape);
                    return function (elem) {
                        var node = typeof elem.getAttributeNode !== 'undefined' && elem.getAttributeNode('id');
                        return node && node.value === attrId;
                    };
                };
                Expr.find['ID'] = function (id, context) {
                    if (typeof context.getElementById !== 'undefined' && documentIsHTML) {
                        var node, i, elems, elem = context.getElementById(id);
                        if (elem) {
                            node = elem.getAttributeNode('id');
                            if (node && node.value === id) {
                                return [elem];
                            }
                            elems = context.getElementsByName(id);
                            i = 0;
                            while (elem = elems[i++]) {
                                node = elem.getAttributeNode('id');
                                if (node && node.value === id) {
                                    return [elem];
                                }
                            }
                        }
                        return [];
                    }
                };
            }
            Expr.find['TAG'] = support.getElementsByTagName ? function (tag, context) {
                if (typeof context.getElementsByTagName !== 'undefined') {
                    return context.getElementsByTagName(tag);
                } else if (support.qsa) {
                    return context.querySelectorAll(tag);
                }
            } : function (tag, context) {
                var elem, tmp = [], i = 0, results = context.getElementsByTagName(tag);
                if (tag === '*') {
                    while (elem = results[i++]) {
                        if (elem.nodeType === 1) {
                            tmp.push(elem);
                        }
                    }
                    return tmp;
                }
                return results;
            };
            Expr.find['CLASS'] = support.getElementsByClassName && function (className, context) {
                if (typeof context.getElementsByClassName !== 'undefined' && documentIsHTML) {
                    return context.getElementsByClassName(className);
                }
            };
            rbuggyMatches = [];
            rbuggyQSA = [];
            if (support.qsa = rnative.test(document.querySelectorAll)) {
                assert(function (el) {
                    docElem.appendChild(el).innerHTML = '<a id=\'' + expando + '\'></a>' + '<select id=\'' + expando + '-\r\\\' msallowcapture=\'\'>' + '<option selected=\'\'></option></select>';
                    if (el.querySelectorAll('[msallowcapture^=\'\']').length) {
                        rbuggyQSA.push('[*^$]=' + whitespace + '*(?:\'\'|"")');
                    }
                    if (!el.querySelectorAll('[selected]').length) {
                        rbuggyQSA.push('\\[' + whitespace + '*(?:value|' + booleans + ')');
                    }
                    if (!el.querySelectorAll('[id~=' + expando + '-]').length) {
                        rbuggyQSA.push('~=');
                    }
                    if (!el.querySelectorAll(':checked').length) {
                        rbuggyQSA.push(':checked');
                    }
                    if (!el.querySelectorAll('a#' + expando + '+*').length) {
                        rbuggyQSA.push('.#.+[+~]');
                    }
                });
                assert(function (el) {
                    el.innerHTML = '<a href=\'\' disabled=\'disabled\'></a>' + '<select disabled=\'disabled\'><option/></select>';
                    var input = document.createElement('input');
                    input.setAttribute('type', 'hidden');
                    el.appendChild(input).setAttribute('name', 'D');
                    if (el.querySelectorAll('[name=d]').length) {
                        rbuggyQSA.push('name' + whitespace + '*[*^$|!~]?=');
                    }
                    if (el.querySelectorAll(':enabled').length !== 2) {
                        rbuggyQSA.push(':enabled', ':disabled');
                    }
                    docElem.appendChild(el).disabled = true;
                    if (el.querySelectorAll(':disabled').length !== 2) {
                        rbuggyQSA.push(':enabled', ':disabled');
                    }
                    el.querySelectorAll('*,:x');
                    rbuggyQSA.push(',.*:');
                });
            }
            if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
                assert(function (el) {
                    support.disconnectedMatch = matches.call(el, '*');
                    matches.call(el, '[s!=\'\']:x');
                    rbuggyMatches.push('!=', pseudos);
                });
            }
            rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join('|'));
            rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join('|'));
            hasCompare = rnative.test(docElem.compareDocumentPosition);
            contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {
                var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
                return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
            } : function (a, b) {
                if (b) {
                    while (b = b.parentNode) {
                        if (b === a) {
                            return true;
                        }
                    }
                }
                return false;
            };
            sortOrder = hasCompare ? function (a, b) {
                if (a === b) {
                    hasDuplicate = true;
                    return 0;
                }
                var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                if (compare) {
                    return compare;
                }
                compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;
                if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
                    if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
                        return -1;
                    }
                    if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
                        return 1;
                    }
                    return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
                }
                return compare & 4 ? -1 : 1;
            } : function (a, b) {
                if (a === b) {
                    hasDuplicate = true;
                    return 0;
                }
                var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [a], bp = [b];
                if (!aup || !bup) {
                    return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
                } else if (aup === bup) {
                    return siblingCheck(a, b);
                }
                cur = a;
                while (cur = cur.parentNode) {
                    ap.unshift(cur);
                }
                cur = b;
                while (cur = cur.parentNode) {
                    bp.unshift(cur);
                }
                while (ap[i] === bp[i]) {
                    i++;
                }
                return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
            };
            return document;
        };
        Sizzle.matches = function (expr, elements) {
            return Sizzle(expr, null, null, elements);
        };
        Sizzle.matchesSelector = function (elem, expr) {
            if ((elem.ownerDocument || elem) !== document) {
                setDocument(elem);
            }
            expr = expr.replace(rattributeQuotes, '=\'$1\']');
            if (support.matchesSelector && documentIsHTML && !compilerCache[expr + ' '] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
                try {
                    var ret = matches.call(elem, expr);
                    if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
                        return ret;
                    }
                } catch (e) {
                }
            }
            return Sizzle(expr, document, null, [elem]).length > 0;
        };
        Sizzle.contains = function (context, elem) {
            if ((context.ownerDocument || context) !== document) {
                setDocument(context);
            }
            return contains(context, elem);
        };
        Sizzle.attr = function (elem, name) {
            if ((elem.ownerDocument || elem) !== document) {
                setDocument(elem);
            }
            var fn = Expr.attrHandle[name.toLowerCase()], val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
            return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        };
        Sizzle.escape = function (sel) {
            return (sel + '').replace(rcssescape, fcssescape);
        };
        Sizzle.error = function (msg) {
            throw new Error('Syntax error, unrecognized expression: ' + msg);
        };
        Sizzle.uniqueSort = function (results) {
            var elem, duplicates = [], j = 0, i = 0;
            hasDuplicate = !support.detectDuplicates;
            sortInput = !support.sortStable && results.slice(0);
            results.sort(sortOrder);
            if (hasDuplicate) {
                while (elem = results[i++]) {
                    if (elem === results[i]) {
                        j = duplicates.push(i);
                    }
                }
                while (j--) {
                    results.splice(duplicates[j], 1);
                }
            }
            sortInput = null;
            return results;
        };
        getText = Sizzle.getText = function (elem) {
            var node, ret = '', i = 0, nodeType = elem.nodeType;
            if (!nodeType) {
                while (node = elem[i++]) {
                    ret += getText(node);
                }
            } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
                if (typeof elem.textContent === 'string') {
                    return elem.textContent;
                } else {
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                        ret += getText(elem);
                    }
                }
            } else if (nodeType === 3 || nodeType === 4) {
                return elem.nodeValue;
            }
            return ret;
        };
        Expr = Sizzle.selectors = {
            cacheLength: 50,
            createPseudo: markFunction,
            match: matchExpr,
            attrHandle: {},
            find: {},
            relative: {
                '>': {
                    dir: 'parentNode',
                    first: true
                },
                ' ': { dir: 'parentNode' },
                '+': {
                    dir: 'previousSibling',
                    first: true
                },
                '~': { dir: 'previousSibling' }
            },
            preFilter: {
                'ATTR': function (match) {
                    match[1] = match[1].replace(runescape, funescape);
                    match[3] = (match[3] || match[4] || match[5] || '').replace(runescape, funescape);
                    if (match[2] === '~=') {
                        match[3] = ' ' + match[3] + ' ';
                    }
                    return match.slice(0, 4);
                },
                'CHILD': function (match) {
                    match[1] = match[1].toLowerCase();
                    if (match[1].slice(0, 3) === 'nth') {
                        if (!match[3]) {
                            Sizzle.error(match[0]);
                        }
                        match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === 'even' || match[3] === 'odd'));
                        match[5] = +(match[7] + match[8] || match[3] === 'odd');
                    } else if (match[3]) {
                        Sizzle.error(match[0]);
                    }
                    return match;
                },
                'PSEUDO': function (match) {
                    var excess, unquoted = !match[6] && match[2];
                    if (matchExpr['CHILD'].test(match[0])) {
                        return null;
                    }
                    if (match[3]) {
                        match[2] = match[4] || match[5] || '';
                    } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(')', unquoted.length - excess) - unquoted.length)) {
                        match[0] = match[0].slice(0, excess);
                        match[2] = unquoted.slice(0, excess);
                    }
                    return match.slice(0, 3);
                }
            },
            filter: {
                'TAG': function (nodeNameSelector) {
                    var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                    return nodeNameSelector === '*' ? function () {
                        return true;
                    } : function (elem) {
                        return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                    };
                },
                'CLASS': function (className) {
                    var pattern = classCache[className + ' '];
                    return pattern || (pattern = new RegExp('(^|' + whitespace + ')' + className + '(' + whitespace + '|$)')) && classCache(className, function (elem) {
                        return pattern.test(typeof elem.className === 'string' && elem.className || typeof elem.getAttribute !== 'undefined' && elem.getAttribute('class') || '');
                    });
                },
                'ATTR': function (name, operator, check) {
                    return function (elem) {
                        var result = Sizzle.attr(elem, name);
                        if (result == null) {
                            return operator === '!=';
                        }
                        if (!operator) {
                            return true;
                        }
                        result += '';
                        return operator === '=' ? result === check : operator === '!=' ? result !== check : operator === '^=' ? check && result.indexOf(check) === 0 : operator === '*=' ? check && result.indexOf(check) > -1 : operator === '$=' ? check && result.slice(-check.length) === check : operator === '~=' ? (' ' + result.replace(rwhitespace, ' ') + ' ').indexOf(check) > -1 : operator === '|=' ? result === check || result.slice(0, check.length + 1) === check + '-' : false;
                    };
                },
                'CHILD': function (type, what, argument, first, last) {
                    var simple = type.slice(0, 3) !== 'nth', forward = type.slice(-4) !== 'last', ofType = what === 'of-type';
                    return first === 1 && last === 0 ? function (elem) {
                        return !!elem.parentNode;
                    } : function (elem, context, xml) {
                        var cache, uniqueCache, outerCache, node, nodeIndex, start, dir = simple !== forward ? 'nextSibling' : 'previousSibling', parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = false;
                        if (parent) {
                            if (simple) {
                                while (dir) {
                                    node = elem;
                                    while (node = node[dir]) {
                                        if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                                            return false;
                                        }
                                    }
                                    start = dir = type === 'only' && !start && 'nextSibling';
                                }
                                return true;
                            }
                            start = [forward ? parent.firstChild : parent.lastChild];
                            if (forward && useCache) {
                                node = parent;
                                outerCache = node[expando] || (node[expando] = {});
                                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                                cache = uniqueCache[type] || [];
                                nodeIndex = cache[0] === dirruns && cache[1];
                                diff = nodeIndex && cache[2];
                                node = nodeIndex && parent.childNodes[nodeIndex];
                                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                                    if (node.nodeType === 1 && ++diff && node === elem) {
                                        uniqueCache[type] = [
                                            dirruns,
                                            nodeIndex,
                                            diff
                                        ];
                                        break;
                                    }
                                }
                            } else {
                                if (useCache) {
                                    node = elem;
                                    outerCache = node[expando] || (node[expando] = {});
                                    uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                                    cache = uniqueCache[type] || [];
                                    nodeIndex = cache[0] === dirruns && cache[1];
                                    diff = nodeIndex;
                                }
                                if (diff === false) {
                                    while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                                        if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                                            if (useCache) {
                                                outerCache = node[expando] || (node[expando] = {});
                                                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                                                uniqueCache[type] = [
                                                    dirruns,
                                                    diff
                                                ];
                                            }
                                            if (node === elem) {
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                            diff -= last;
                            return diff === first || diff % first === 0 && diff / first >= 0;
                        }
                    };
                },
                'PSEUDO': function (pseudo, argument) {
                    var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error('unsupported pseudo: ' + pseudo);
                    if (fn[expando]) {
                        return fn(argument);
                    }
                    if (fn.length > 1) {
                        args = [
                            pseudo,
                            pseudo,
                            '',
                            argument
                        ];
                        return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
                            var idx, matched = fn(seed, argument), i = matched.length;
                            while (i--) {
                                idx = indexOf(seed, matched[i]);
                                seed[idx] = !(matches[idx] = matched[i]);
                            }
                        }) : function (elem) {
                            return fn(elem, 0, args);
                        };
                    }
                    return fn;
                }
            },
            pseudos: {
                'not': markFunction(function (selector) {
                    var input = [], results = [], matcher = compile(selector.replace(rtrim, '$1'));
                    return matcher[expando] ? markFunction(function (seed, matches, context, xml) {
                        var elem, unmatched = matcher(seed, null, xml, []), i = seed.length;
                        while (i--) {
                            if (elem = unmatched[i]) {
                                seed[i] = !(matches[i] = elem);
                            }
                        }
                    }) : function (elem, context, xml) {
                        input[0] = elem;
                        matcher(input, null, xml, results);
                        input[0] = null;
                        return !results.pop();
                    };
                }),
                'has': markFunction(function (selector) {
                    return function (elem) {
                        return Sizzle(selector, elem).length > 0;
                    };
                }),
                'contains': markFunction(function (text) {
                    text = text.replace(runescape, funescape);
                    return function (elem) {
                        return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
                    };
                }),
                'lang': markFunction(function (lang) {
                    if (!ridentifier.test(lang || '')) {
                        Sizzle.error('unsupported lang: ' + lang);
                    }
                    lang = lang.replace(runescape, funescape).toLowerCase();
                    return function (elem) {
                        var elemLang;
                        do {
                            if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute('xml:lang') || elem.getAttribute('lang')) {
                                elemLang = elemLang.toLowerCase();
                                return elemLang === lang || elemLang.indexOf(lang + '-') === 0;
                            }
                        } while ((elem = elem.parentNode) && elem.nodeType === 1);
                        return false;
                    };
                }),
                'target': function (elem) {
                    var hash = window.location && window.location.hash;
                    return hash && hash.slice(1) === elem.id;
                },
                'root': function (elem) {
                    return elem === docElem;
                },
                'focus': function (elem) {
                    return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                },
                'enabled': createDisabledPseudo(false),
                'disabled': createDisabledPseudo(true),
                'checked': function (elem) {
                    var nodeName = elem.nodeName.toLowerCase();
                    return nodeName === 'input' && !!elem.checked || nodeName === 'option' && !!elem.selected;
                },
                'selected': function (elem) {
                    if (elem.parentNode) {
                        elem.parentNode.selectedIndex;
                    }
                    return elem.selected === true;
                },
                'empty': function (elem) {
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                        if (elem.nodeType < 6) {
                            return false;
                        }
                    }
                    return true;
                },
                'parent': function (elem) {
                    return !Expr.pseudos['empty'](elem);
                },
                'header': function (elem) {
                    return rheader.test(elem.nodeName);
                },
                'input': function (elem) {
                    return rinputs.test(elem.nodeName);
                },
                'button': function (elem) {
                    var name = elem.nodeName.toLowerCase();
                    return name === 'input' && elem.type === 'button' || name === 'button';
                },
                'text': function (elem) {
                    var attr;
                    return elem.nodeName.toLowerCase() === 'input' && elem.type === 'text' && ((attr = elem.getAttribute('type')) == null || attr.toLowerCase() === 'text');
                },
                'first': createPositionalPseudo(function () {
                    return [0];
                }),
                'last': createPositionalPseudo(function (matchIndexes, length) {
                    return [length - 1];
                }),
                'eq': createPositionalPseudo(function (matchIndexes, length, argument) {
                    return [argument < 0 ? argument + length : argument];
                }),
                'even': createPositionalPseudo(function (matchIndexes, length) {
                    var i = 0;
                    for (; i < length; i += 2) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),
                'odd': createPositionalPseudo(function (matchIndexes, length) {
                    var i = 1;
                    for (; i < length; i += 2) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),
                'lt': createPositionalPseudo(function (matchIndexes, length, argument) {
                    var i = argument < 0 ? argument + length : argument;
                    for (; --i >= 0;) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),
                'gt': createPositionalPseudo(function (matchIndexes, length, argument) {
                    var i = argument < 0 ? argument + length : argument;
                    for (; ++i < length;) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                })
            }
        };
        Expr.pseudos['nth'] = Expr.pseudos['eq'];
        for (i in {
                radio: true,
                checkbox: true,
                file: true,
                password: true,
                image: true
            }) {
            Expr.pseudos[i] = createInputPseudo(i);
        }
        for (i in {
                submit: true,
                reset: true
            }) {
            Expr.pseudos[i] = createButtonPseudo(i);
        }
        function setFilters() {
        }
        setFilters.prototype = Expr.filters = Expr.pseudos;
        Expr.setFilters = new setFilters();
        tokenize = Sizzle.tokenize = function (selector, parseOnly) {
            var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + ' '];
            if (cached) {
                return parseOnly ? 0 : cached.slice(0);
            }
            soFar = selector;
            groups = [];
            preFilters = Expr.preFilter;
            while (soFar) {
                if (!matched || (match = rcomma.exec(soFar))) {
                    if (match) {
                        soFar = soFar.slice(match[0].length) || soFar;
                    }
                    groups.push(tokens = []);
                }
                matched = false;
                if (match = rcombinators.exec(soFar)) {
                    matched = match.shift();
                    tokens.push({
                        value: matched,
                        type: match[0].replace(rtrim, ' ')
                    });
                    soFar = soFar.slice(matched.length);
                }
                for (type in Expr.filter) {
                    if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                        matched = match.shift();
                        tokens.push({
                            value: matched,
                            type: type,
                            matches: match
                        });
                        soFar = soFar.slice(matched.length);
                    }
                }
                if (!matched) {
                    break;
                }
            }
            return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
        };
        function toSelector(tokens) {
            var i = 0, len = tokens.length, selector = '';
            for (; i < len; i++) {
                selector += tokens[i].value;
            }
            return selector;
        }
        function addCombinator(matcher, combinator, base) {
            var dir = combinator.dir, skip = combinator.next, key = skip || dir, checkNonElements = base && key === 'parentNode', doneName = done++;
            return combinator.first ? function (elem, context, xml) {
                while (elem = elem[dir]) {
                    if (elem.nodeType === 1 || checkNonElements) {
                        return matcher(elem, context, xml);
                    }
                }
                return false;
            } : function (elem, context, xml) {
                var oldCache, uniqueCache, outerCache, newCache = [
                        dirruns,
                        doneName
                    ];
                if (xml) {
                    while (elem = elem[dir]) {
                        if (elem.nodeType === 1 || checkNonElements) {
                            if (matcher(elem, context, xml)) {
                                return true;
                            }
                        }
                    }
                } else {
                    while (elem = elem[dir]) {
                        if (elem.nodeType === 1 || checkNonElements) {
                            outerCache = elem[expando] || (elem[expando] = {});
                            uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});
                            if (skip && skip === elem.nodeName.toLowerCase()) {
                                elem = elem[dir] || elem;
                            } else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                                return newCache[2] = oldCache[2];
                            } else {
                                uniqueCache[key] = newCache;
                                if (newCache[2] = matcher(elem, context, xml)) {
                                    return true;
                                }
                            }
                        }
                    }
                }
                return false;
            };
        }
        function elementMatcher(matchers) {
            return matchers.length > 1 ? function (elem, context, xml) {
                var i = matchers.length;
                while (i--) {
                    if (!matchers[i](elem, context, xml)) {
                        return false;
                    }
                }
                return true;
            } : matchers[0];
        }
        function multipleContexts(selector, contexts, results) {
            var i = 0, len = contexts.length;
            for (; i < len; i++) {
                Sizzle(selector, contexts[i], results);
            }
            return results;
        }
        function condense(unmatched, map, filter, context, xml) {
            var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = map != null;
            for (; i < len; i++) {
                if (elem = unmatched[i]) {
                    if (!filter || filter(elem, context, xml)) {
                        newUnmatched.push(elem);
                        if (mapped) {
                            map.push(i);
                        }
                    }
                }
            }
            return newUnmatched;
        }
        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
            if (postFilter && !postFilter[expando]) {
                postFilter = setMatcher(postFilter);
            }
            if (postFinder && !postFinder[expando]) {
                postFinder = setMatcher(postFinder, postSelector);
            }
            return markFunction(function (seed, results, context, xml) {
                var temp, i, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(selector || '*', context.nodeType ? [context] : context, []), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems, matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
                if (matcher) {
                    matcher(matcherIn, matcherOut, context, xml);
                }
                if (postFilter) {
                    temp = condense(matcherOut, postMap);
                    postFilter(temp, [], context, xml);
                    i = temp.length;
                    while (i--) {
                        if (elem = temp[i]) {
                            matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
                        }
                    }
                }
                if (seed) {
                    if (postFinder || preFilter) {
                        if (postFinder) {
                            temp = [];
                            i = matcherOut.length;
                            while (i--) {
                                if (elem = matcherOut[i]) {
                                    temp.push(matcherIn[i] = elem);
                                }
                            }
                            postFinder(null, matcherOut = [], temp, xml);
                        }
                        i = matcherOut.length;
                        while (i--) {
                            if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
                                seed[temp] = !(results[temp] = elem);
                            }
                        }
                    }
                } else {
                    matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
                    if (postFinder) {
                        postFinder(null, results, matcherOut, xml);
                    } else {
                        push.apply(results, matcherOut);
                    }
                }
            });
        }
        function matcherFromTokens(tokens) {
            var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[' '], i = leadingRelative ? 1 : 0, matchContext = addCombinator(function (elem) {
                    return elem === checkContext;
                }, implicitRelative, true), matchAnyContext = addCombinator(function (elem) {
                    return indexOf(checkContext, elem) > -1;
                }, implicitRelative, true), matchers = [function (elem, context, xml) {
                        var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
                        checkContext = null;
                        return ret;
                    }];
            for (; i < len; i++) {
                if (matcher = Expr.relative[tokens[i].type]) {
                    matchers = [addCombinator(elementMatcher(matchers), matcher)];
                } else {
                    matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
                    if (matcher[expando]) {
                        j = ++i;
                        for (; j < len; j++) {
                            if (Expr.relative[tokens[j].type]) {
                                break;
                            }
                        }
                        return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === ' ' ? '*' : '' })).replace(rtrim, '$1'), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
                    }
                    matchers.push(matcher);
                }
            }
            return elementMatcher(matchers);
        }
        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
            var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function (seed, context, xml, results, outermost) {
                    var elem, j, matcher, matchedCount = 0, i = '0', unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find['TAG']('*', outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
                    if (outermost) {
                        outermostContext = context === document || context || outermost;
                    }
                    for (; i !== len && (elem = elems[i]) != null; i++) {
                        if (byElement && elem) {
                            j = 0;
                            if (!context && elem.ownerDocument !== document) {
                                setDocument(elem);
                                xml = !documentIsHTML;
                            }
                            while (matcher = elementMatchers[j++]) {
                                if (matcher(elem, context || document, xml)) {
                                    results.push(elem);
                                    break;
                                }
                            }
                            if (outermost) {
                                dirruns = dirrunsUnique;
                            }
                        }
                        if (bySet) {
                            if (elem = !matcher && elem) {
                                matchedCount--;
                            }
                            if (seed) {
                                unmatched.push(elem);
                            }
                        }
                    }
                    matchedCount += i;
                    if (bySet && i !== matchedCount) {
                        j = 0;
                        while (matcher = setMatchers[j++]) {
                            matcher(unmatched, setMatched, context, xml);
                        }
                        if (seed) {
                            if (matchedCount > 0) {
                                while (i--) {
                                    if (!(unmatched[i] || setMatched[i])) {
                                        setMatched[i] = pop.call(results);
                                    }
                                }
                            }
                            setMatched = condense(setMatched);
                        }
                        push.apply(results, setMatched);
                        if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                            Sizzle.uniqueSort(results);
                        }
                    }
                    if (outermost) {
                        dirruns = dirrunsUnique;
                        outermostContext = contextBackup;
                    }
                    return unmatched;
                };
            return bySet ? markFunction(superMatcher) : superMatcher;
        }
        compile = Sizzle.compile = function (selector, match) {
            var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + ' '];
            if (!cached) {
                if (!match) {
                    match = tokenize(selector);
                }
                i = match.length;
                while (i--) {
                    cached = matcherFromTokens(match[i]);
                    if (cached[expando]) {
                        setMatchers.push(cached);
                    } else {
                        elementMatchers.push(cached);
                    }
                }
                cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
                cached.selector = selector;
            }
            return cached;
        };
        select = Sizzle.select = function (selector, context, results, seed) {
            var i, tokens, token, type, find, compiled = typeof selector === 'function' && selector, match = !seed && tokenize(selector = compiled.selector || selector);
            results = results || [];
            if (match.length === 1) {
                tokens = match[0] = match[0].slice(0);
                if (tokens.length > 2 && (token = tokens[0]).type === 'ID' && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
                    context = (Expr.find['ID'](token.matches[0].replace(runescape, funescape), context) || [])[0];
                    if (!context) {
                        return results;
                    } else if (compiled) {
                        context = context.parentNode;
                    }
                    selector = selector.slice(tokens.shift().value.length);
                }
                i = matchExpr['needsContext'].test(selector) ? 0 : tokens.length;
                while (i--) {
                    token = tokens[i];
                    if (Expr.relative[type = token.type]) {
                        break;
                    }
                    if (find = Expr.find[type]) {
                        if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
                            tokens.splice(i, 1);
                            selector = seed.length && toSelector(tokens);
                            if (!selector) {
                                push.apply(results, seed);
                                return results;
                            }
                            break;
                        }
                    }
                }
            }
            (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
            return results;
        };
        support.sortStable = expando.split('').sort(sortOrder).join('') === expando;
        support.detectDuplicates = !!hasDuplicate;
        setDocument();
        support.sortDetached = assert(function (el) {
            return el.compareDocumentPosition(document.createElement('fieldset')) & 1;
        });
        if (!assert(function (el) {
                el.innerHTML = '<a href=\'#\'></a>';
                return el.firstChild.getAttribute('href') === '#';
            })) {
            addHandle('type|href|height|width', function (elem, name, isXML) {
                if (!isXML) {
                    return elem.getAttribute(name, name.toLowerCase() === 'type' ? 1 : 2);
                }
            });
        }
        if (!support.attributes || !assert(function (el) {
                el.innerHTML = '<input/>';
                el.firstChild.setAttribute('value', '');
                return el.firstChild.getAttribute('value') === '';
            })) {
            addHandle('value', function (elem, name, isXML) {
                if (!isXML && elem.nodeName.toLowerCase() === 'input') {
                    return elem.defaultValue;
                }
            });
        }
        if (!assert(function (el) {
                return el.getAttribute('disabled') == null;
            })) {
            addHandle(booleans, function (elem, name, isXML) {
                var val;
                if (!isXML) {
                    return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
                }
            });
        }
        return Sizzle;
    }(window);
    jQuery.find = Sizzle;
    jQuery.expr = Sizzle.selectors;
    jQuery.expr[':'] = jQuery.expr.pseudos;
    jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
    jQuery.text = Sizzle.getText;
    jQuery.isXMLDoc = Sizzle.isXML;
    jQuery.contains = Sizzle.contains;
    jQuery.escapeSelector = Sizzle.escape;
    var dir = function (elem, dir, until) {
        var matched = [], truncate = until !== undefined;
        while ((elem = elem[dir]) && elem.nodeType !== 9) {
            if (elem.nodeType === 1) {
                if (truncate && jQuery(elem).is(until)) {
                    break;
                }
                matched.push(elem);
            }
        }
        return matched;
    };
    var siblings = function (n, elem) {
        var matched = [];
        for (; n; n = n.nextSibling) {
            if (n.nodeType === 1 && n !== elem) {
                matched.push(n);
            }
        }
        return matched;
    };
    var rneedsContext = jQuery.expr.match.needsContext;
    var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
    var risSimple = /^.[^:#\[\.,]*$/;
    function winnow(elements, qualifier, not) {
        if (jQuery.isFunction(qualifier)) {
            return jQuery.grep(elements, function (elem, i) {
                return !!qualifier.call(elem, i, elem) !== not;
            });
        }
        if (qualifier.nodeType) {
            return jQuery.grep(elements, function (elem) {
                return elem === qualifier !== not;
            });
        }
        if (typeof qualifier !== 'string') {
            return jQuery.grep(elements, function (elem) {
                return indexOf.call(qualifier, elem) > -1 !== not;
            });
        }
        if (risSimple.test(qualifier)) {
            return jQuery.filter(qualifier, elements, not);
        }
        qualifier = jQuery.filter(qualifier, elements);
        return jQuery.grep(elements, function (elem) {
            return indexOf.call(qualifier, elem) > -1 !== not && elem.nodeType === 1;
        });
    }
    jQuery.filter = function (expr, elems, not) {
        var elem = elems[0];
        if (not) {
            expr = ':not(' + expr + ')';
        }
        if (elems.length === 1 && elem.nodeType === 1) {
            return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];
        }
        return jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
            return elem.nodeType === 1;
        }));
    };
    jQuery.fn.extend({
        find: function (selector) {
            var i, ret, len = this.length, self = this;
            if (typeof selector !== 'string') {
                return this.pushStack(jQuery(selector).filter(function () {
                    for (i = 0; i < len; i++) {
                        if (jQuery.contains(self[i], this)) {
                            return true;
                        }
                    }
                }));
            }
            ret = this.pushStack([]);
            for (i = 0; i < len; i++) {
                jQuery.find(selector, self[i], ret);
            }
            return len > 1 ? jQuery.uniqueSort(ret) : ret;
        },
        filter: function (selector) {
            return this.pushStack(winnow(this, selector || [], false));
        },
        not: function (selector) {
            return this.pushStack(winnow(this, selector || [], true));
        },
        is: function (selector) {
            return !!winnow(this, typeof selector === 'string' && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
        }
    });
    var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/, init = jQuery.fn.init = function (selector, context, root) {
            var match, elem;
            if (!selector) {
                return this;
            }
            root = root || rootjQuery;
            if (typeof selector === 'string') {
                if (selector[0] === '<' && selector[selector.length - 1] === '>' && selector.length >= 3) {
                    match = [
                        null,
                        selector,
                        null
                    ];
                } else {
                    match = rquickExpr.exec(selector);
                }
                if (match && (match[1] || !context)) {
                    if (match[1]) {
                        context = context instanceof jQuery ? context[0] : context;
                        jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));
                        if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                            for (match in context) {
                                if (jQuery.isFunction(this[match])) {
                                    this[match](context[match]);
                                } else {
                                    this.attr(match, context[match]);
                                }
                            }
                        }
                        return this;
                    } else {
                        elem = document.getElementById(match[2]);
                        if (elem) {
                            this[0] = elem;
                            this.length = 1;
                        }
                        return this;
                    }
                } else if (!context || context.jquery) {
                    return (context || root).find(selector);
                } else {
                    return this.constructor(context).find(selector);
                }
            } else if (selector.nodeType) {
                this[0] = selector;
                this.length = 1;
                return this;
            } else if (jQuery.isFunction(selector)) {
                return root.ready !== undefined ? root.ready(selector) : selector(jQuery);
            }
            return jQuery.makeArray(selector, this);
        };
    init.prototype = jQuery.fn;
    rootjQuery = jQuery(document);
    var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
            children: true,
            contents: true,
            next: true,
            prev: true
        };
    jQuery.fn.extend({
        has: function (target) {
            var targets = jQuery(target, this), l = targets.length;
            return this.filter(function () {
                var i = 0;
                for (; i < l; i++) {
                    if (jQuery.contains(this, targets[i])) {
                        return true;
                    }
                }
            });
        },
        closest: function (selectors, context) {
            var cur, i = 0, l = this.length, matched = [], targets = typeof selectors !== 'string' && jQuery(selectors);
            if (!rneedsContext.test(selectors)) {
                for (; i < l; i++) {
                    for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
                        if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
                            matched.push(cur);
                            break;
                        }
                    }
                }
            }
            return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
        },
        index: function (elem) {
            if (!elem) {
                return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
            }
            if (typeof elem === 'string') {
                return indexOf.call(jQuery(elem), this[0]);
            }
            return indexOf.call(this, elem.jquery ? elem[0] : elem);
        },
        add: function (selector, context) {
            return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
        },
        addBack: function (selector) {
            return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
        }
    });
    function sibling(cur, dir) {
        while ((cur = cur[dir]) && cur.nodeType !== 1) {
        }
        return cur;
    }
    jQuery.each({
        parent: function (elem) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function (elem) {
            return dir(elem, 'parentNode');
        },
        parentsUntil: function (elem, i, until) {
            return dir(elem, 'parentNode', until);
        },
        next: function (elem) {
            return sibling(elem, 'nextSibling');
        },
        prev: function (elem) {
            return sibling(elem, 'previousSibling');
        },
        nextAll: function (elem) {
            return dir(elem, 'nextSibling');
        },
        prevAll: function (elem) {
            return dir(elem, 'previousSibling');
        },
        nextUntil: function (elem, i, until) {
            return dir(elem, 'nextSibling', until);
        },
        prevUntil: function (elem, i, until) {
            return dir(elem, 'previousSibling', until);
        },
        siblings: function (elem) {
            return siblings((elem.parentNode || {}).firstChild, elem);
        },
        children: function (elem) {
            return siblings(elem.firstChild);
        },
        contents: function (elem) {
            return elem.contentDocument || jQuery.merge([], elem.childNodes);
        }
    }, function (name, fn) {
        jQuery.fn[name] = function (until, selector) {
            var matched = jQuery.map(this, fn, until);
            if (name.slice(-5) !== 'Until') {
                selector = until;
            }
            if (selector && typeof selector === 'string') {
                matched = jQuery.filter(selector, matched);
            }
            if (this.length > 1) {
                if (!guaranteedUnique[name]) {
                    jQuery.uniqueSort(matched);
                }
                if (rparentsprev.test(name)) {
                    matched.reverse();
                }
            }
            return this.pushStack(matched);
        };
    });
    var rnothtmlwhite = /[^\x20\t\r\n\f]+/g;
    function createOptions(options) {
        var object = {};
        jQuery.each(options.match(rnothtmlwhite) || [], function (_, flag) {
            object[flag] = true;
        });
        return object;
    }
    jQuery.Callbacks = function (options) {
        options = typeof options === 'string' ? createOptions(options) : jQuery.extend({}, options);
        var firing, memory, fired, locked, list = [], queue = [], firingIndex = -1, fire = function () {
                locked = options.once;
                fired = firing = true;
                for (; queue.length; firingIndex = -1) {
                    memory = queue.shift();
                    while (++firingIndex < list.length) {
                        if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
                            firingIndex = list.length;
                            memory = false;
                        }
                    }
                }
                if (!options.memory) {
                    memory = false;
                }
                firing = false;
                if (locked) {
                    if (memory) {
                        list = [];
                    } else {
                        list = '';
                    }
                }
            }, self = {
                add: function () {
                    if (list) {
                        if (memory && !firing) {
                            firingIndex = list.length - 1;
                            queue.push(memory);
                        }
                        (function add(args) {
                            jQuery.each(args, function (_, arg) {
                                if (jQuery.isFunction(arg)) {
                                    if (!options.unique || !self.has(arg)) {
                                        list.push(arg);
                                    }
                                } else if (arg && arg.length && jQuery.type(arg) !== 'string') {
                                    add(arg);
                                }
                            });
                        }(arguments));
                        if (memory && !firing) {
                            fire();
                        }
                    }
                    return this;
                },
                remove: function () {
                    jQuery.each(arguments, function (_, arg) {
                        var index;
                        while ((index = jQuery.inArray(arg, list, index)) > -1) {
                            list.splice(index, 1);
                            if (index <= firingIndex) {
                                firingIndex--;
                            }
                        }
                    });
                    return this;
                },
                has: function (fn) {
                    return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
                },
                empty: function () {
                    if (list) {
                        list = [];
                    }
                    return this;
                },
                disable: function () {
                    locked = queue = [];
                    list = memory = '';
                    return this;
                },
                disabled: function () {
                    return !list;
                },
                lock: function () {
                    locked = queue = [];
                    if (!memory && !firing) {
                        list = memory = '';
                    }
                    return this;
                },
                locked: function () {
                    return !!locked;
                },
                fireWith: function (context, args) {
                    if (!locked) {
                        args = args || [];
                        args = [
                            context,
                            args.slice ? args.slice() : args
                        ];
                        queue.push(args);
                        if (!firing) {
                            fire();
                        }
                    }
                    return this;
                },
                fire: function () {
                    self.fireWith(this, arguments);
                    return this;
                },
                fired: function () {
                    return !!fired;
                }
            };
        return self;
    };
    function Identity(v) {
        return v;
    }
    function Thrower(ex) {
        throw ex;
    }
    function adoptValue(value, resolve, reject) {
        var method;
        try {
            if (value && jQuery.isFunction(method = value.promise)) {
                method.call(value).done(resolve).fail(reject);
            } else if (value && jQuery.isFunction(method = value.then)) {
                method.call(value, resolve, reject);
            } else {
                resolve.call(undefined, value);
            }
        } catch (value) {
            reject.call(undefined, value);
        }
    }
    jQuery.extend({
        Deferred: function (func) {
            var tuples = [
                    [
                        'notify',
                        'progress',
                        jQuery.Callbacks('memory'),
                        jQuery.Callbacks('memory'),
                        2
                    ],
                    [
                        'resolve',
                        'done',
                        jQuery.Callbacks('once memory'),
                        jQuery.Callbacks('once memory'),
                        0,
                        'resolved'
                    ],
                    [
                        'reject',
                        'fail',
                        jQuery.Callbacks('once memory'),
                        jQuery.Callbacks('once memory'),
                        1,
                        'rejected'
                    ]
                ], state = 'pending', promise = {
                    state: function () {
                        return state;
                    },
                    always: function () {
                        deferred.done(arguments).fail(arguments);
                        return this;
                    },
                    'catch': function (fn) {
                        return promise.then(null, fn);
                    },
                    pipe: function () {
                        var fns = arguments;
                        return jQuery.Deferred(function (newDefer) {
                            jQuery.each(tuples, function (i, tuple) {
                                var fn = jQuery.isFunction(fns[tuple[4]]) && fns[tuple[4]];
                                deferred[tuple[1]](function () {
                                    var returned = fn && fn.apply(this, arguments);
                                    if (returned && jQuery.isFunction(returned.promise)) {
                                        returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                                    } else {
                                        newDefer[tuple[0] + 'With'](this, fn ? [returned] : arguments);
                                    }
                                });
                            });
                            fns = null;
                        }).promise();
                    },
                    then: function (onFulfilled, onRejected, onProgress) {
                        var maxDepth = 0;
                        function resolve(depth, deferred, handler, special) {
                            return function () {
                                var that = this, args = arguments, mightThrow = function () {
                                        var returned, then;
                                        if (depth < maxDepth) {
                                            return;
                                        }
                                        returned = handler.apply(that, args);
                                        if (returned === deferred.promise()) {
                                            throw new TypeError('Thenable self-resolution');
                                        }
                                        then = returned && (typeof returned === 'object' || typeof returned === 'function') && returned.then;
                                        if (jQuery.isFunction(then)) {
                                            if (special) {
                                                then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special));
                                            } else {
                                                maxDepth++;
                                                then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith));
                                            }
                                        } else {
                                            if (handler !== Identity) {
                                                that = undefined;
                                                args = [returned];
                                            }
                                            (special || deferred.resolveWith)(that, args);
                                        }
                                    }, process = special ? mightThrow : function () {
                                        try {
                                            mightThrow();
                                        } catch (e) {
                                            if (jQuery.Deferred.exceptionHook) {
                                                jQuery.Deferred.exceptionHook(e, process.stackTrace);
                                            }
                                            if (depth + 1 >= maxDepth) {
                                                if (handler !== Thrower) {
                                                    that = undefined;
                                                    args = [e];
                                                }
                                                deferred.rejectWith(that, args);
                                            }
                                        }
                                    };
                                if (depth) {
                                    process();
                                } else {
                                    if (jQuery.Deferred.getStackHook) {
                                        process.stackTrace = jQuery.Deferred.getStackHook();
                                    }
                                    window.setTimeout(process);
                                }
                            };
                        }
                        return jQuery.Deferred(function (newDefer) {
                            tuples[0][3].add(resolve(0, newDefer, jQuery.isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith));
                            tuples[1][3].add(resolve(0, newDefer, jQuery.isFunction(onFulfilled) ? onFulfilled : Identity));
                            tuples[2][3].add(resolve(0, newDefer, jQuery.isFunction(onRejected) ? onRejected : Thrower));
                        }).promise();
                    },
                    promise: function (obj) {
                        return obj != null ? jQuery.extend(obj, promise) : promise;
                    }
                }, deferred = {};
            jQuery.each(tuples, function (i, tuple) {
                var list = tuple[2], stateString = tuple[5];
                promise[tuple[1]] = list.add;
                if (stateString) {
                    list.add(function () {
                        state = stateString;
                    }, tuples[3 - i][2].disable, tuples[0][2].lock);
                }
                list.add(tuple[3].fire);
                deferred[tuple[0]] = function () {
                    deferred[tuple[0] + 'With'](this === deferred ? undefined : this, arguments);
                    return this;
                };
                deferred[tuple[0] + 'With'] = list.fireWith;
            });
            promise.promise(deferred);
            if (func) {
                func.call(deferred, deferred);
            }
            return deferred;
        },
        when: function (singleValue) {
            var remaining = arguments.length, i = remaining, resolveContexts = Array(i), resolveValues = slice.call(arguments), master = jQuery.Deferred(), updateFunc = function (i) {
                    return function (value) {
                        resolveContexts[i] = this;
                        resolveValues[i] = arguments.length > 1 ? slice.call(arguments) : value;
                        if (!--remaining) {
                            master.resolveWith(resolveContexts, resolveValues);
                        }
                    };
                };
            if (remaining <= 1) {
                adoptValue(singleValue, master.done(updateFunc(i)).resolve, master.reject);
                if (master.state() === 'pending' || jQuery.isFunction(resolveValues[i] && resolveValues[i].then)) {
                    return master.then();
                }
            }
            while (i--) {
                adoptValue(resolveValues[i], updateFunc(i), master.reject);
            }
            return master.promise();
        }
    });
    var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
    jQuery.Deferred.exceptionHook = function (error, stack) {
        if (window.console && window.console.warn && error && rerrorNames.test(error.name)) {
            window.console.warn('jQuery.Deferred exception: ' + error.message, error.stack, stack);
        }
    };
    jQuery.readyException = function (error) {
        window.setTimeout(function () {
            throw error;
        });
    };
    var readyList = jQuery.Deferred();
    jQuery.fn.ready = function (fn) {
        readyList.then(fn).catch(function (error) {
            jQuery.readyException(error);
        });
        return this;
    };
    jQuery.extend({
        isReady: false,
        readyWait: 1,
        holdReady: function (hold) {
            if (hold) {
                jQuery.readyWait++;
            } else {
                jQuery.ready(true);
            }
        },
        ready: function (wait) {
            if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
                return;
            }
            jQuery.isReady = true;
            if (wait !== true && --jQuery.readyWait > 0) {
                return;
            }
            readyList.resolveWith(document, [jQuery]);
        }
    });
    jQuery.ready.then = readyList.then;
    function completed() {
        document.removeEventListener('DOMContentLoaded', completed);
        window.removeEventListener('load', completed);
        jQuery.ready();
    }
    if (document.readyState === 'complete' || document.readyState !== 'loading' && !document.documentElement.doScroll) {
        window.setTimeout(jQuery.ready);
    } else {
        document.addEventListener('DOMContentLoaded', completed);
        window.addEventListener('load', completed);
    }
    var access = function (elems, fn, key, value, chainable, emptyGet, raw) {
        var i = 0, len = elems.length, bulk = key == null;
        if (jQuery.type(key) === 'object') {
            chainable = true;
            for (i in key) {
                access(elems, fn, i, key[i], true, emptyGet, raw);
            }
        } else if (value !== undefined) {
            chainable = true;
            if (!jQuery.isFunction(value)) {
                raw = true;
            }
            if (bulk) {
                if (raw) {
                    fn.call(elems, value);
                    fn = null;
                } else {
                    bulk = fn;
                    fn = function (elem, key, value) {
                        return bulk.call(jQuery(elem), value);
                    };
                }
            }
            if (fn) {
                for (; i < len; i++) {
                    fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
                }
            }
        }
        if (chainable) {
            return elems;
        }
        if (bulk) {
            return fn.call(elems);
        }
        return len ? fn(elems[0], key) : emptyGet;
    };
    var acceptData = function (owner) {
        return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
    };
    function Data() {
        this.expando = jQuery.expando + Data.uid++;
    }
    Data.uid = 1;
    Data.prototype = {
        cache: function (owner) {
            var value = owner[this.expando];
            if (!value) {
                value = {};
                if (acceptData(owner)) {
                    if (owner.nodeType) {
                        owner[this.expando] = value;
                    } else {
                        Object.defineProperty(owner, this.expando, {
                            value: value,
                            configurable: true
                        });
                    }
                }
            }
            return value;
        },
        set: function (owner, data, value) {
            var prop, cache = this.cache(owner);
            if (typeof data === 'string') {
                cache[jQuery.camelCase(data)] = value;
            } else {
                for (prop in data) {
                    cache[jQuery.camelCase(prop)] = data[prop];
                }
            }
            return cache;
        },
        get: function (owner, key) {
            return key === undefined ? this.cache(owner) : owner[this.expando] && owner[this.expando][jQuery.camelCase(key)];
        },
        access: function (owner, key, value) {
            if (key === undefined || key && typeof key === 'string' && value === undefined) {
                return this.get(owner, key);
            }
            this.set(owner, key, value);
            return value !== undefined ? value : key;
        },
        remove: function (owner, key) {
            var i, cache = owner[this.expando];
            if (cache === undefined) {
                return;
            }
            if (key !== undefined) {
                if (jQuery.isArray(key)) {
                    key = key.map(jQuery.camelCase);
                } else {
                    key = jQuery.camelCase(key);
                    key = key in cache ? [key] : key.match(rnothtmlwhite) || [];
                }
                i = key.length;
                while (i--) {
                    delete cache[key[i]];
                }
            }
            if (key === undefined || jQuery.isEmptyObject(cache)) {
                if (owner.nodeType) {
                    owner[this.expando] = undefined;
                } else {
                    delete owner[this.expando];
                }
            }
        },
        hasData: function (owner) {
            var cache = owner[this.expando];
            return cache !== undefined && !jQuery.isEmptyObject(cache);
        }
    };
    var dataPriv = new Data();
    var dataUser = new Data();
    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /[A-Z]/g;
    function getData(data) {
        if (data === 'true') {
            return true;
        }
        if (data === 'false') {
            return false;
        }
        if (data === 'null') {
            return null;
        }
        if (data === +data + '') {
            return +data;
        }
        if (rbrace.test(data)) {
            return JSON.parse(data);
        }
        return data;
    }
    function dataAttr(elem, key, data) {
        var name;
        if (data === undefined && elem.nodeType === 1) {
            name = 'data-' + key.replace(rmultiDash, '-$&').toLowerCase();
            data = elem.getAttribute(name);
            if (typeof data === 'string') {
                try {
                    data = getData(data);
                } catch (e) {
                }
                dataUser.set(elem, key, data);
            } else {
                data = undefined;
            }
        }
        return data;
    }
    jQuery.extend({
        hasData: function (elem) {
            return dataUser.hasData(elem) || dataPriv.hasData(elem);
        },
        data: function (elem, name, data) {
            return dataUser.access(elem, name, data);
        },
        removeData: function (elem, name) {
            dataUser.remove(elem, name);
        },
        _data: function (elem, name, data) {
            return dataPriv.access(elem, name, data);
        },
        _removeData: function (elem, name) {
            dataPriv.remove(elem, name);
        }
    });
    jQuery.fn.extend({
        data: function (key, value) {
            var i, name, data, elem = this[0], attrs = elem && elem.attributes;
            if (key === undefined) {
                if (this.length) {
                    data = dataUser.get(elem);
                    if (elem.nodeType === 1 && !dataPriv.get(elem, 'hasDataAttrs')) {
                        i = attrs.length;
                        while (i--) {
                            if (attrs[i]) {
                                name = attrs[i].name;
                                if (name.indexOf('data-') === 0) {
                                    name = jQuery.camelCase(name.slice(5));
                                    dataAttr(elem, name, data[name]);
                                }
                            }
                        }
                        dataPriv.set(elem, 'hasDataAttrs', true);
                    }
                }
                return data;
            }
            if (typeof key === 'object') {
                return this.each(function () {
                    dataUser.set(this, key);
                });
            }
            return access(this, function (value) {
                var data;
                if (elem && value === undefined) {
                    data = dataUser.get(elem, key);
                    if (data !== undefined) {
                        return data;
                    }
                    data = dataAttr(elem, key);
                    if (data !== undefined) {
                        return data;
                    }
                    return;
                }
                this.each(function () {
                    dataUser.set(this, key, value);
                });
            }, null, value, arguments.length > 1, null, true);
        },
        removeData: function (key) {
            return this.each(function () {
                dataUser.remove(this, key);
            });
        }
    });
    jQuery.extend({
        queue: function (elem, type, data) {
            var queue;
            if (elem) {
                type = (type || 'fx') + 'queue';
                queue = dataPriv.get(elem, type);
                if (data) {
                    if (!queue || jQuery.isArray(data)) {
                        queue = dataPriv.access(elem, type, jQuery.makeArray(data));
                    } else {
                        queue.push(data);
                    }
                }
                return queue || [];
            }
        },
        dequeue: function (elem, type) {
            type = type || 'fx';
            var queue = jQuery.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem, type), next = function () {
                    jQuery.dequeue(elem, type);
                };
            if (fn === 'inprogress') {
                fn = queue.shift();
                startLength--;
            }
            if (fn) {
                if (type === 'fx') {
                    queue.unshift('inprogress');
                }
                delete hooks.stop;
                fn.call(elem, next, hooks);
            }
            if (!startLength && hooks) {
                hooks.empty.fire();
            }
        },
        _queueHooks: function (elem, type) {
            var key = type + 'queueHooks';
            return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
                empty: jQuery.Callbacks('once memory').add(function () {
                    dataPriv.remove(elem, [
                        type + 'queue',
                        key
                    ]);
                })
            });
        }
    });
    jQuery.fn.extend({
        queue: function (type, data) {
            var setter = 2;
            if (typeof type !== 'string') {
                data = type;
                type = 'fx';
                setter--;
            }
            if (arguments.length < setter) {
                return jQuery.queue(this[0], type);
            }
            return data === undefined ? this : this.each(function () {
                var queue = jQuery.queue(this, type, data);
                jQuery._queueHooks(this, type);
                if (type === 'fx' && queue[0] !== 'inprogress') {
                    jQuery.dequeue(this, type);
                }
            });
        },
        dequeue: function (type) {
            return this.each(function () {
                jQuery.dequeue(this, type);
            });
        },
        clearQueue: function (type) {
            return this.queue(type || 'fx', []);
        },
        promise: function (type, obj) {
            var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function () {
                    if (!--count) {
                        defer.resolveWith(elements, [elements]);
                    }
                };
            if (typeof type !== 'string') {
                obj = type;
                type = undefined;
            }
            type = type || 'fx';
            while (i--) {
                tmp = dataPriv.get(elements[i], type + 'queueHooks');
                if (tmp && tmp.empty) {
                    count++;
                    tmp.empty.add(resolve);
                }
            }
            resolve();
            return defer.promise(obj);
        }
    });
    var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
    var rcssNum = new RegExp('^(?:([+-])=|)(' + pnum + ')([a-z%]*)$', 'i');
    var cssExpand = [
        'Top',
        'Right',
        'Bottom',
        'Left'
    ];
    var isHiddenWithinTree = function (elem, el) {
        elem = el || elem;
        return elem.style.display === 'none' || elem.style.display === '' && jQuery.contains(elem.ownerDocument, elem) && jQuery.css(elem, 'display') === 'none';
    };
    var swap = function (elem, options, callback, args) {
        var ret, name, old = {};
        for (name in options) {
            old[name] = elem.style[name];
            elem.style[name] = options[name];
        }
        ret = callback.apply(elem, args || []);
        for (name in options) {
            elem.style[name] = old[name];
        }
        return ret;
    };
    function adjustCSS(elem, prop, valueParts, tween) {
        var adjusted, scale = 1, maxIterations = 20, currentValue = tween ? function () {
                return tween.cur();
            } : function () {
                return jQuery.css(elem, prop, '');
            }, initial = currentValue(), unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? '' : 'px'), initialInUnit = (jQuery.cssNumber[prop] || unit !== 'px' && +initial) && rcssNum.exec(jQuery.css(elem, prop));
        if (initialInUnit && initialInUnit[3] !== unit) {
            unit = unit || initialInUnit[3];
            valueParts = valueParts || [];
            initialInUnit = +initial || 1;
            do {
                scale = scale || '.5';
                initialInUnit = initialInUnit / scale;
                jQuery.style(elem, prop, initialInUnit + unit);
            } while (scale !== (scale = currentValue() / initial) && scale !== 1 && --maxIterations);
        }
        if (valueParts) {
            initialInUnit = +initialInUnit || +initial || 0;
            adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
            if (tween) {
                tween.unit = unit;
                tween.start = initialInUnit;
                tween.end = adjusted;
            }
        }
        return adjusted;
    }
    var defaultDisplayMap = {};
    function getDefaultDisplay(elem) {
        var temp, doc = elem.ownerDocument, nodeName = elem.nodeName, display = defaultDisplayMap[nodeName];
        if (display) {
            return display;
        }
        temp = doc.body.appendChild(doc.createElement(nodeName));
        display = jQuery.css(temp, 'display');
        temp.parentNode.removeChild(temp);
        if (display === 'none') {
            display = 'block';
        }
        defaultDisplayMap[nodeName] = display;
        return display;
    }
    function showHide(elements, show) {
        var display, elem, values = [], index = 0, length = elements.length;
        for (; index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
                continue;
            }
            display = elem.style.display;
            if (show) {
                if (display === 'none') {
                    values[index] = dataPriv.get(elem, 'display') || null;
                    if (!values[index]) {
                        elem.style.display = '';
                    }
                }
                if (elem.style.display === '' && isHiddenWithinTree(elem)) {
                    values[index] = getDefaultDisplay(elem);
                }
            } else {
                if (display !== 'none') {
                    values[index] = 'none';
                    dataPriv.set(elem, 'display', display);
                }
            }
        }
        for (index = 0; index < length; index++) {
            if (values[index] != null) {
                elements[index].style.display = values[index];
            }
        }
        return elements;
    }
    jQuery.fn.extend({
        show: function () {
            return showHide(this, true);
        },
        hide: function () {
            return showHide(this);
        },
        toggle: function (state) {
            if (typeof state === 'boolean') {
                return state ? this.show() : this.hide();
            }
            return this.each(function () {
                if (isHiddenWithinTree(this)) {
                    jQuery(this).show();
                } else {
                    jQuery(this).hide();
                }
            });
        }
    });
    var rcheckableType = /^(?:checkbox|radio)$/i;
    var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]+)/i;
    var rscriptType = /^$|\/(?:java|ecma)script/i;
    var wrapMap = {
        option: [
            1,
            '<select multiple=\'multiple\'>',
            '</select>'
        ],
        thead: [
            1,
            '<table>',
            '</table>'
        ],
        col: [
            2,
            '<table><colgroup>',
            '</colgroup></table>'
        ],
        tr: [
            2,
            '<table><tbody>',
            '</tbody></table>'
        ],
        td: [
            3,
            '<table><tbody><tr>',
            '</tr></tbody></table>'
        ],
        _default: [
            0,
            '',
            ''
        ]
    };
    wrapMap.optgroup = wrapMap.option;
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;
    function getAll(context, tag) {
        var ret;
        if (typeof context.getElementsByTagName !== 'undefined') {
            ret = context.getElementsByTagName(tag || '*');
        } else if (typeof context.querySelectorAll !== 'undefined') {
            ret = context.querySelectorAll(tag || '*');
        } else {
            ret = [];
        }
        if (tag === undefined || tag && jQuery.nodeName(context, tag)) {
            return jQuery.merge([context], ret);
        }
        return ret;
    }
    function setGlobalEval(elems, refElements) {
        var i = 0, l = elems.length;
        for (; i < l; i++) {
            dataPriv.set(elems[i], 'globalEval', !refElements || dataPriv.get(refElements[i], 'globalEval'));
        }
    }
    var rhtml = /<|&#?\w+;/;
    function buildFragment(elems, context, scripts, selection, ignored) {
        var elem, tmp, tag, wrap, contains, j, fragment = context.createDocumentFragment(), nodes = [], i = 0, l = elems.length;
        for (; i < l; i++) {
            elem = elems[i];
            if (elem || elem === 0) {
                if (jQuery.type(elem) === 'object') {
                    jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
                } else if (!rhtml.test(elem)) {
                    nodes.push(context.createTextNode(elem));
                } else {
                    tmp = tmp || fragment.appendChild(context.createElement('div'));
                    tag = (rtagName.exec(elem) || [
                        '',
                        ''
                    ])[1].toLowerCase();
                    wrap = wrapMap[tag] || wrapMap._default;
                    tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];
                    j = wrap[0];
                    while (j--) {
                        tmp = tmp.lastChild;
                    }
                    jQuery.merge(nodes, tmp.childNodes);
                    tmp = fragment.firstChild;
                    tmp.textContent = '';
                }
            }
        }
        fragment.textContent = '';
        i = 0;
        while (elem = nodes[i++]) {
            if (selection && jQuery.inArray(elem, selection) > -1) {
                if (ignored) {
                    ignored.push(elem);
                }
                continue;
            }
            contains = jQuery.contains(elem.ownerDocument, elem);
            tmp = getAll(fragment.appendChild(elem), 'script');
            if (contains) {
                setGlobalEval(tmp);
            }
            if (scripts) {
                j = 0;
                while (elem = tmp[j++]) {
                    if (rscriptType.test(elem.type || '')) {
                        scripts.push(elem);
                    }
                }
            }
        }
        return fragment;
    }
    (function () {
        var fragment = document.createDocumentFragment(), div = fragment.appendChild(document.createElement('div')), input = document.createElement('input');
        input.setAttribute('type', 'radio');
        input.setAttribute('checked', 'checked');
        input.setAttribute('name', 't');
        div.appendChild(input);
        support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
        div.innerHTML = '<textarea>x</textarea>';
        support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
    }());
    var documentElement = document.documentElement;
    var rkeyEvent = /^key/, rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
    function returnTrue() {
        return true;
    }
    function returnFalse() {
        return false;
    }
    function safeActiveElement() {
        try {
            return document.activeElement;
        } catch (err) {
        }
    }
    function on(elem, types, selector, data, fn, one) {
        var origFn, type;
        if (typeof types === 'object') {
            if (typeof selector !== 'string') {
                data = data || selector;
                selector = undefined;
            }
            for (type in types) {
                on(elem, type, selector, data, types[type], one);
            }
            return elem;
        }
        if (data == null && fn == null) {
            fn = selector;
            data = selector = undefined;
        } else if (fn == null) {
            if (typeof selector === 'string') {
                fn = data;
                data = undefined;
            } else {
                fn = data;
                data = selector;
                selector = undefined;
            }
        }
        if (fn === false) {
            fn = returnFalse;
        } else if (!fn) {
            return elem;
        }
        if (one === 1) {
            origFn = fn;
            fn = function (event) {
                jQuery().off(event);
                return origFn.apply(this, arguments);
            };
            fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
        }
        return elem.each(function () {
            jQuery.event.add(this, types, fn, data, selector);
        });
    }
    jQuery.event = {
        global: {},
        add: function (elem, types, handler, data, selector) {
            var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get(elem);
            if (!elemData) {
                return;
            }
            if (handler.handler) {
                handleObjIn = handler;
                handler = handleObjIn.handler;
                selector = handleObjIn.selector;
            }
            if (selector) {
                jQuery.find.matchesSelector(documentElement, selector);
            }
            if (!handler.guid) {
                handler.guid = jQuery.guid++;
            }
            if (!(events = elemData.events)) {
                events = elemData.events = {};
            }
            if (!(eventHandle = elemData.handle)) {
                eventHandle = elemData.handle = function (e) {
                    return typeof jQuery !== 'undefined' && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
                };
            }
            types = (types || '').match(rnothtmlwhite) || [''];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || '').split('.').sort();
                if (!type) {
                    continue;
                }
                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                special = jQuery.event.special[type] || {};
                handleObj = jQuery.extend({
                    type: type,
                    origType: origType,
                    data: data,
                    handler: handler,
                    guid: handler.guid,
                    selector: selector,
                    needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                    namespace: namespaces.join('.')
                }, handleObjIn);
                if (!(handlers = events[type])) {
                    handlers = events[type] = [];
                    handlers.delegateCount = 0;
                    if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                        if (elem.addEventListener) {
                            elem.addEventListener(type, eventHandle);
                        }
                    }
                }
                if (special.add) {
                    special.add.call(elem, handleObj);
                    if (!handleObj.handler.guid) {
                        handleObj.handler.guid = handler.guid;
                    }
                }
                if (selector) {
                    handlers.splice(handlers.delegateCount++, 0, handleObj);
                } else {
                    handlers.push(handleObj);
                }
                jQuery.event.global[type] = true;
            }
        },
        remove: function (elem, types, handler, selector, mappedTypes) {
            var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
            if (!elemData || !(events = elemData.events)) {
                return;
            }
            types = (types || '').match(rnothtmlwhite) || [''];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || '').split('.').sort();
                if (!type) {
                    for (type in events) {
                        jQuery.event.remove(elem, type + types[t], handler, selector, true);
                    }
                    continue;
                }
                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                handlers = events[type] || [];
                tmp = tmp[2] && new RegExp('(^|\\.)' + namespaces.join('\\.(?:.*\\.|)') + '(\\.|$)');
                origCount = j = handlers.length;
                while (j--) {
                    handleObj = handlers[j];
                    if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === '**' && handleObj.selector)) {
                        handlers.splice(j, 1);
                        if (handleObj.selector) {
                            handlers.delegateCount--;
                        }
                        if (special.remove) {
                            special.remove.call(elem, handleObj);
                        }
                    }
                }
                if (origCount && !handlers.length) {
                    if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                        jQuery.removeEvent(elem, type, elemData.handle);
                    }
                    delete events[type];
                }
            }
            if (jQuery.isEmptyObject(events)) {
                dataPriv.remove(elem, 'handle events');
            }
        },
        dispatch: function (nativeEvent) {
            var event = jQuery.event.fix(nativeEvent);
            var i, j, ret, matched, handleObj, handlerQueue, args = new Array(arguments.length), handlers = (dataPriv.get(this, 'events') || {})[event.type] || [], special = jQuery.event.special[event.type] || {};
            args[0] = event;
            for (i = 1; i < arguments.length; i++) {
                args[i] = arguments[i];
            }
            event.delegateTarget = this;
            if (special.preDispatch && special.preDispatch.call(this, event) === false) {
                return;
            }
            handlerQueue = jQuery.event.handlers.call(this, event, handlers);
            i = 0;
            while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
                event.currentTarget = matched.elem;
                j = 0;
                while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
                    if (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) {
                        event.handleObj = handleObj;
                        event.data = handleObj.data;
                        ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                        if (ret !== undefined) {
                            if ((event.result = ret) === false) {
                                event.preventDefault();
                                event.stopPropagation();
                            }
                        }
                    }
                }
            }
            if (special.postDispatch) {
                special.postDispatch.call(this, event);
            }
            return event.result;
        },
        handlers: function (event, handlers) {
            var i, handleObj, sel, matchedHandlers, matchedSelectors, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
            if (delegateCount && cur.nodeType && !(event.type === 'click' && event.button >= 1)) {
                for (; cur !== this; cur = cur.parentNode || this) {
                    if (cur.nodeType === 1 && !(event.type === 'click' && cur.disabled === true)) {
                        matchedHandlers = [];
                        matchedSelectors = {};
                        for (i = 0; i < delegateCount; i++) {
                            handleObj = handlers[i];
                            sel = handleObj.selector + ' ';
                            if (matchedSelectors[sel] === undefined) {
                                matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
                            }
                            if (matchedSelectors[sel]) {
                                matchedHandlers.push(handleObj);
                            }
                        }
                        if (matchedHandlers.length) {
                            handlerQueue.push({
                                elem: cur,
                                handlers: matchedHandlers
                            });
                        }
                    }
                }
            }
            cur = this;
            if (delegateCount < handlers.length) {
                handlerQueue.push({
                    elem: cur,
                    handlers: handlers.slice(delegateCount)
                });
            }
            return handlerQueue;
        },
        addProp: function (name, hook) {
            Object.defineProperty(jQuery.Event.prototype, name, {
                enumerable: true,
                configurable: true,
                get: jQuery.isFunction(hook) ? function () {
                    if (this.originalEvent) {
                        return hook(this.originalEvent);
                    }
                } : function () {
                    if (this.originalEvent) {
                        return this.originalEvent[name];
                    }
                },
                set: function (value) {
                    Object.defineProperty(this, name, {
                        enumerable: true,
                        configurable: true,
                        writable: true,
                        value: value
                    });
                }
            });
        },
        fix: function (originalEvent) {
            return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);
        },
        special: {
            load: { noBubble: true },
            focus: {
                trigger: function () {
                    if (this !== safeActiveElement() && this.focus) {
                        this.focus();
                        return false;
                    }
                },
                delegateType: 'focusin'
            },
            blur: {
                trigger: function () {
                    if (this === safeActiveElement() && this.blur) {
                        this.blur();
                        return false;
                    }
                },
                delegateType: 'focusout'
            },
            click: {
                trigger: function () {
                    if (this.type === 'checkbox' && this.click && jQuery.nodeName(this, 'input')) {
                        this.click();
                        return false;
                    }
                },
                _default: function (event) {
                    return jQuery.nodeName(event.target, 'a');
                }
            },
            beforeunload: {
                postDispatch: function (event) {
                    if (event.result !== undefined && event.originalEvent) {
                        event.originalEvent.returnValue = event.result;
                    }
                }
            }
        }
    };
    jQuery.removeEvent = function (elem, type, handle) {
        if (elem.removeEventListener) {
            elem.removeEventListener(type, handle);
        }
    };
    jQuery.Event = function (src, props) {
        if (!(this instanceof jQuery.Event)) {
            return new jQuery.Event(src, props);
        }
        if (src && src.type) {
            this.originalEvent = src;
            this.type = src.type;
            this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && src.returnValue === false ? returnTrue : returnFalse;
            this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
            this.currentTarget = src.currentTarget;
            this.relatedTarget = src.relatedTarget;
        } else {
            this.type = src;
        }
        if (props) {
            jQuery.extend(this, props);
        }
        this.timeStamp = src && src.timeStamp || jQuery.now();
        this[jQuery.expando] = true;
    };
    jQuery.Event.prototype = {
        constructor: jQuery.Event,
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,
        isSimulated: false,
        preventDefault: function () {
            var e = this.originalEvent;
            this.isDefaultPrevented = returnTrue;
            if (e && !this.isSimulated) {
                e.preventDefault();
            }
        },
        stopPropagation: function () {
            var e = this.originalEvent;
            this.isPropagationStopped = returnTrue;
            if (e && !this.isSimulated) {
                e.stopPropagation();
            }
        },
        stopImmediatePropagation: function () {
            var e = this.originalEvent;
            this.isImmediatePropagationStopped = returnTrue;
            if (e && !this.isSimulated) {
                e.stopImmediatePropagation();
            }
            this.stopPropagation();
        }
    };
    jQuery.each({
        altKey: true,
        bubbles: true,
        cancelable: true,
        changedTouches: true,
        ctrlKey: true,
        detail: true,
        eventPhase: true,
        metaKey: true,
        pageX: true,
        pageY: true,
        shiftKey: true,
        view: true,
        'char': true,
        charCode: true,
        key: true,
        keyCode: true,
        button: true,
        buttons: true,
        clientX: true,
        clientY: true,
        offsetX: true,
        offsetY: true,
        pointerId: true,
        pointerType: true,
        screenX: true,
        screenY: true,
        targetTouches: true,
        toElement: true,
        touches: true,
        which: function (event) {
            var button = event.button;
            if (event.which == null && rkeyEvent.test(event.type)) {
                return event.charCode != null ? event.charCode : event.keyCode;
            }
            if (!event.which && button !== undefined && rmouseEvent.test(event.type)) {
                if (button & 1) {
                    return 1;
                }
                if (button & 2) {
                    return 3;
                }
                if (button & 4) {
                    return 2;
                }
                return 0;
            }
            return event.which;
        }
    }, jQuery.event.addProp);
    jQuery.each({
        mouseenter: 'mouseover',
        mouseleave: 'mouseout',
        pointerenter: 'pointerover',
        pointerleave: 'pointerout'
    }, function (orig, fix) {
        jQuery.event.special[orig] = {
            delegateType: fix,
            bindType: fix,
            handle: function (event) {
                var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
                if (!related || related !== target && !jQuery.contains(target, related)) {
                    event.type = handleObj.origType;
                    ret = handleObj.handler.apply(this, arguments);
                    event.type = fix;
                }
                return ret;
            }
        };
    });
    jQuery.fn.extend({
        on: function (types, selector, data, fn) {
            return on(this, types, selector, data, fn);
        },
        one: function (types, selector, data, fn) {
            return on(this, types, selector, data, fn, 1);
        },
        off: function (types, selector, fn) {
            var handleObj, type;
            if (types && types.preventDefault && types.handleObj) {
                handleObj = types.handleObj;
                jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + '.' + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
                return this;
            }
            if (typeof types === 'object') {
                for (type in types) {
                    this.off(type, selector, types[type]);
                }
                return this;
            }
            if (selector === false || typeof selector === 'function') {
                fn = selector;
                selector = undefined;
            }
            if (fn === false) {
                fn = returnFalse;
            }
            return this.each(function () {
                jQuery.event.remove(this, types, fn, selector);
            });
        }
    });
    var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi, rnoInnerhtml = /<script|<style|<link/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rscriptTypeMasked = /^true\/(.*)/, rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
    function manipulationTarget(elem, content) {
        if (jQuery.nodeName(elem, 'table') && jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, 'tr')) {
            return elem.getElementsByTagName('tbody')[0] || elem;
        }
        return elem;
    }
    function disableScript(elem) {
        elem.type = (elem.getAttribute('type') !== null) + '/' + elem.type;
        return elem;
    }
    function restoreScript(elem) {
        var match = rscriptTypeMasked.exec(elem.type);
        if (match) {
            elem.type = match[1];
        } else {
            elem.removeAttribute('type');
        }
        return elem;
    }
    function cloneCopyEvent(src, dest) {
        var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
        if (dest.nodeType !== 1) {
            return;
        }
        if (dataPriv.hasData(src)) {
            pdataOld = dataPriv.access(src);
            pdataCur = dataPriv.set(dest, pdataOld);
            events = pdataOld.events;
            if (events) {
                delete pdataCur.handle;
                pdataCur.events = {};
                for (type in events) {
                    for (i = 0, l = events[type].length; i < l; i++) {
                        jQuery.event.add(dest, type, events[type][i]);
                    }
                }
            }
        }
        if (dataUser.hasData(src)) {
            udataOld = dataUser.access(src);
            udataCur = jQuery.extend({}, udataOld);
            dataUser.set(dest, udataCur);
        }
    }
    function fixInput(src, dest) {
        var nodeName = dest.nodeName.toLowerCase();
        if (nodeName === 'input' && rcheckableType.test(src.type)) {
            dest.checked = src.checked;
        } else if (nodeName === 'input' || nodeName === 'textarea') {
            dest.defaultValue = src.defaultValue;
        }
    }
    function domManip(collection, args, callback, ignored) {
        args = concat.apply([], args);
        var fragment, first, scripts, hasScripts, node, doc, i = 0, l = collection.length, iNoClone = l - 1, value = args[0], isFunction = jQuery.isFunction(value);
        if (isFunction || l > 1 && typeof value === 'string' && !support.checkClone && rchecked.test(value)) {
            return collection.each(function (index) {
                var self = collection.eq(index);
                if (isFunction) {
                    args[0] = value.call(this, index, self.html());
                }
                domManip(self, args, callback, ignored);
            });
        }
        if (l) {
            fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
            first = fragment.firstChild;
            if (fragment.childNodes.length === 1) {
                fragment = first;
            }
            if (first || ignored) {
                scripts = jQuery.map(getAll(fragment, 'script'), disableScript);
                hasScripts = scripts.length;
                for (; i < l; i++) {
                    node = fragment;
                    if (i !== iNoClone) {
                        node = jQuery.clone(node, true, true);
                        if (hasScripts) {
                            jQuery.merge(scripts, getAll(node, 'script'));
                        }
                    }
                    callback.call(collection[i], node, i);
                }
                if (hasScripts) {
                    doc = scripts[scripts.length - 1].ownerDocument;
                    jQuery.map(scripts, restoreScript);
                    for (i = 0; i < hasScripts; i++) {
                        node = scripts[i];
                        if (rscriptType.test(node.type || '') && !dataPriv.access(node, 'globalEval') && jQuery.contains(doc, node)) {
                            if (node.src) {
                                if (jQuery._evalUrl) {
                                    jQuery._evalUrl(node.src);
                                }
                            } else {
                                DOMEval(node.textContent.replace(rcleanScript, ''), doc);
                            }
                        }
                    }
                }
            }
        }
        return collection;
    }
    function remove(elem, selector, keepData) {
        var node, nodes = selector ? jQuery.filter(selector, elem) : elem, i = 0;
        for (; (node = nodes[i]) != null; i++) {
            if (!keepData && node.nodeType === 1) {
                jQuery.cleanData(getAll(node));
            }
            if (node.parentNode) {
                if (keepData && jQuery.contains(node.ownerDocument, node)) {
                    setGlobalEval(getAll(node, 'script'));
                }
                node.parentNode.removeChild(node);
            }
        }
        return elem;
    }
    jQuery.extend({
        htmlPrefilter: function (html) {
            return html.replace(rxhtmlTag, '<$1></$2>');
        },
        clone: function (elem, dataAndEvents, deepDataAndEvents) {
            var i, l, srcElements, destElements, clone = elem.cloneNode(true), inPage = jQuery.contains(elem.ownerDocument, elem);
            if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
                destElements = getAll(clone);
                srcElements = getAll(elem);
                for (i = 0, l = srcElements.length; i < l; i++) {
                    fixInput(srcElements[i], destElements[i]);
                }
            }
            if (dataAndEvents) {
                if (deepDataAndEvents) {
                    srcElements = srcElements || getAll(elem);
                    destElements = destElements || getAll(clone);
                    for (i = 0, l = srcElements.length; i < l; i++) {
                        cloneCopyEvent(srcElements[i], destElements[i]);
                    }
                } else {
                    cloneCopyEvent(elem, clone);
                }
            }
            destElements = getAll(clone, 'script');
            if (destElements.length > 0) {
                setGlobalEval(destElements, !inPage && getAll(elem, 'script'));
            }
            return clone;
        },
        cleanData: function (elems) {
            var data, elem, type, special = jQuery.event.special, i = 0;
            for (; (elem = elems[i]) !== undefined; i++) {
                if (acceptData(elem)) {
                    if (data = elem[dataPriv.expando]) {
                        if (data.events) {
                            for (type in data.events) {
                                if (special[type]) {
                                    jQuery.event.remove(elem, type);
                                } else {
                                    jQuery.removeEvent(elem, type, data.handle);
                                }
                            }
                        }
                        elem[dataPriv.expando] = undefined;
                    }
                    if (elem[dataUser.expando]) {
                        elem[dataUser.expando] = undefined;
                    }
                }
            }
        }
    });
    jQuery.fn.extend({
        detach: function (selector) {
            return remove(this, selector, true);
        },
        remove: function (selector) {
            return remove(this, selector);
        },
        text: function (value) {
            return access(this, function (value) {
                return value === undefined ? jQuery.text(this) : this.empty().each(function () {
                    if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                        this.textContent = value;
                    }
                });
            }, null, value, arguments.length);
        },
        append: function () {
            return domManip(this, arguments, function (elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.appendChild(elem);
                }
            });
        },
        prepend: function () {
            return domManip(this, arguments, function (elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.insertBefore(elem, target.firstChild);
                }
            });
        },
        before: function () {
            return domManip(this, arguments, function (elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this);
                }
            });
        },
        after: function () {
            return domManip(this, arguments, function (elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this.nextSibling);
                }
            });
        },
        empty: function () {
            var elem, i = 0;
            for (; (elem = this[i]) != null; i++) {
                if (elem.nodeType === 1) {
                    jQuery.cleanData(getAll(elem, false));
                    elem.textContent = '';
                }
            }
            return this;
        },
        clone: function (dataAndEvents, deepDataAndEvents) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
            return this.map(function () {
                return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
            });
        },
        html: function (value) {
            return access(this, function (value) {
                var elem = this[0] || {}, i = 0, l = this.length;
                if (value === undefined && elem.nodeType === 1) {
                    return elem.innerHTML;
                }
                if (typeof value === 'string' && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || [
                        '',
                        ''
                    ])[1].toLowerCase()]) {
                    value = jQuery.htmlPrefilter(value);
                    try {
                        for (; i < l; i++) {
                            elem = this[i] || {};
                            if (elem.nodeType === 1) {
                                jQuery.cleanData(getAll(elem, false));
                                elem.innerHTML = value;
                            }
                        }
                        elem = 0;
                    } catch (e) {
                    }
                }
                if (elem) {
                    this.empty().append(value);
                }
            }, null, value, arguments.length);
        },
        replaceWith: function () {
            var ignored = [];
            return domManip(this, arguments, function (elem) {
                var parent = this.parentNode;
                if (jQuery.inArray(this, ignored) < 0) {
                    jQuery.cleanData(getAll(this));
                    if (parent) {
                        parent.replaceChild(elem, this);
                    }
                }
            }, ignored);
        }
    });
    jQuery.each({
        appendTo: 'append',
        prependTo: 'prepend',
        insertBefore: 'before',
        insertAfter: 'after',
        replaceAll: 'replaceWith'
    }, function (name, original) {
        jQuery.fn[name] = function (selector) {
            var elems, ret = [], insert = jQuery(selector), last = insert.length - 1, i = 0;
            for (; i <= last; i++) {
                elems = i === last ? this : this.clone(true);
                jQuery(insert[i])[original](elems);
                push.apply(ret, elems.get());
            }
            return this.pushStack(ret);
        };
    });
    var rmargin = /^margin/;
    var rnumnonpx = new RegExp('^(' + pnum + ')(?!px)[a-z%]+$', 'i');
    var getStyles = function (elem) {
        var view = elem.ownerDocument.defaultView;
        if (!view || !view.opener) {
            view = window;
        }
        return view.getComputedStyle(elem);
    };
    (function () {
        function computeStyleTests() {
            if (!div) {
                return;
            }
            div.style.cssText = 'box-sizing:border-box;' + 'position:relative;display:block;' + 'margin:auto;border:1px;padding:1px;' + 'top:1%;width:50%';
            div.innerHTML = '';
            documentElement.appendChild(container);
            var divStyle = window.getComputedStyle(div);
            pixelPositionVal = divStyle.top !== '1%';
            reliableMarginLeftVal = divStyle.marginLeft === '2px';
            boxSizingReliableVal = divStyle.width === '4px';
            div.style.marginRight = '50%';
            pixelMarginRightVal = divStyle.marginRight === '4px';
            documentElement.removeChild(container);
            div = null;
        }
        var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal, container = document.createElement('div'), div = document.createElement('div');
        if (!div.style) {
            return;
        }
        div.style.backgroundClip = 'content-box';
        div.cloneNode(true).style.backgroundClip = '';
        support.clearCloneStyle = div.style.backgroundClip === 'content-box';
        container.style.cssText = 'border:0;width:8px;height:0;top:0;left:-9999px;' + 'padding:0;margin-top:1px;position:absolute';
        container.appendChild(div);
        jQuery.extend(support, {
            pixelPosition: function () {
                computeStyleTests();
                return pixelPositionVal;
            },
            boxSizingReliable: function () {
                computeStyleTests();
                return boxSizingReliableVal;
            },
            pixelMarginRight: function () {
                computeStyleTests();
                return pixelMarginRightVal;
            },
            reliableMarginLeft: function () {
                computeStyleTests();
                return reliableMarginLeftVal;
            }
        });
    }());
    function curCSS(elem, name, computed) {
        var width, minWidth, maxWidth, ret, style = elem.style;
        computed = computed || getStyles(elem);
        if (computed) {
            ret = computed.getPropertyValue(name) || computed[name];
            if (ret === '' && !jQuery.contains(elem.ownerDocument, elem)) {
                ret = jQuery.style(elem, name);
            }
            if (!support.pixelMarginRight() && rnumnonpx.test(ret) && rmargin.test(name)) {
                width = style.width;
                minWidth = style.minWidth;
                maxWidth = style.maxWidth;
                style.minWidth = style.maxWidth = style.width = ret;
                ret = computed.width;
                style.width = width;
                style.minWidth = minWidth;
                style.maxWidth = maxWidth;
            }
        }
        return ret !== undefined ? ret + '' : ret;
    }
    function addGetHookIf(conditionFn, hookFn) {
        return {
            get: function () {
                if (conditionFn()) {
                    delete this.get;
                    return;
                }
                return (this.get = hookFn).apply(this, arguments);
            }
        };
    }
    var rdisplayswap = /^(none|table(?!-c[ea]).+)/, cssShow = {
            position: 'absolute',
            visibility: 'hidden',
            display: 'block'
        }, cssNormalTransform = {
            letterSpacing: '0',
            fontWeight: '400'
        }, cssPrefixes = [
            'Webkit',
            'Moz',
            'ms'
        ], emptyStyle = document.createElement('div').style;
    function vendorPropName(name) {
        if (name in emptyStyle) {
            return name;
        }
        var capName = name[0].toUpperCase() + name.slice(1), i = cssPrefixes.length;
        while (i--) {
            name = cssPrefixes[i] + capName;
            if (name in emptyStyle) {
                return name;
            }
        }
    }
    function setPositiveNumber(elem, value, subtract) {
        var matches = rcssNum.exec(value);
        return matches ? Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || 'px') : value;
    }
    function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
        var i, val = 0;
        if (extra === (isBorderBox ? 'border' : 'content')) {
            i = 4;
        } else {
            i = name === 'width' ? 1 : 0;
        }
        for (; i < 4; i += 2) {
            if (extra === 'margin') {
                val += jQuery.css(elem, extra + cssExpand[i], true, styles);
            }
            if (isBorderBox) {
                if (extra === 'content') {
                    val -= jQuery.css(elem, 'padding' + cssExpand[i], true, styles);
                }
                if (extra !== 'margin') {
                    val -= jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles);
                }
            } else {
                val += jQuery.css(elem, 'padding' + cssExpand[i], true, styles);
                if (extra !== 'padding') {
                    val += jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles);
                }
            }
        }
        return val;
    }
    function getWidthOrHeight(elem, name, extra) {
        var val, valueIsBorderBox = true, styles = getStyles(elem), isBorderBox = jQuery.css(elem, 'boxSizing', false, styles) === 'border-box';
        if (elem.getClientRects().length) {
            val = elem.getBoundingClientRect()[name];
        }
        if (val <= 0 || val == null) {
            val = curCSS(elem, name, styles);
            if (val < 0 || val == null) {
                val = elem.style[name];
            }
            if (rnumnonpx.test(val)) {
                return val;
            }
            valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]);
            val = parseFloat(val) || 0;
        }
        return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? 'border' : 'content'), valueIsBorderBox, styles) + 'px';
    }
    jQuery.extend({
        cssHooks: {
            opacity: {
                get: function (elem, computed) {
                    if (computed) {
                        var ret = curCSS(elem, 'opacity');
                        return ret === '' ? '1' : ret;
                    }
                }
            }
        },
        cssNumber: {
            'animationIterationCount': true,
            'columnCount': true,
            'fillOpacity': true,
            'flexGrow': true,
            'flexShrink': true,
            'fontWeight': true,
            'lineHeight': true,
            'opacity': true,
            'order': true,
            'orphans': true,
            'widows': true,
            'zIndex': true,
            'zoom': true
        },
        cssProps: { 'float': 'cssFloat' },
        style: function (elem, name, value, extra) {
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
                return;
            }
            var ret, type, hooks, origName = jQuery.camelCase(name), style = elem.style;
            name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName);
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            if (value !== undefined) {
                type = typeof value;
                if (type === 'string' && (ret = rcssNum.exec(value)) && ret[1]) {
                    value = adjustCSS(elem, name, ret);
                    type = 'number';
                }
                if (value == null || value !== value) {
                    return;
                }
                if (type === 'number') {
                    value += ret && ret[3] || (jQuery.cssNumber[origName] ? '' : 'px');
                }
                if (!support.clearCloneStyle && value === '' && name.indexOf('background') === 0) {
                    style[name] = 'inherit';
                }
                if (!hooks || !('set' in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
                    style[name] = value;
                }
            } else {
                if (hooks && 'get' in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
                    return ret;
                }
                return style[name];
            }
        },
        css: function (elem, name, extra, styles) {
            var val, num, hooks, origName = jQuery.camelCase(name);
            name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName);
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            if (hooks && 'get' in hooks) {
                val = hooks.get(elem, true, extra);
            }
            if (val === undefined) {
                val = curCSS(elem, name, styles);
            }
            if (val === 'normal' && name in cssNormalTransform) {
                val = cssNormalTransform[name];
            }
            if (extra === '' || extra) {
                num = parseFloat(val);
                return extra === true || isFinite(num) ? num || 0 : val;
            }
            return val;
        }
    });
    jQuery.each([
        'height',
        'width'
    ], function (i, name) {
        jQuery.cssHooks[name] = {
            get: function (elem, computed, extra) {
                if (computed) {
                    return rdisplayswap.test(jQuery.css(elem, 'display')) && (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function () {
                        return getWidthOrHeight(elem, name, extra);
                    }) : getWidthOrHeight(elem, name, extra);
                }
            },
            set: function (elem, value, extra) {
                var matches, styles = extra && getStyles(elem), subtract = extra && augmentWidthOrHeight(elem, name, extra, jQuery.css(elem, 'boxSizing', false, styles) === 'border-box', styles);
                if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || 'px') !== 'px') {
                    elem.style[name] = value;
                    value = jQuery.css(elem, name);
                }
                return setPositiveNumber(elem, value, subtract);
            }
        };
    });
    jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function (elem, computed) {
        if (computed) {
            return (parseFloat(curCSS(elem, 'marginLeft')) || elem.getBoundingClientRect().left - swap(elem, { marginLeft: 0 }, function () {
                return elem.getBoundingClientRect().left;
            })) + 'px';
        }
    });
    jQuery.each({
        margin: '',
        padding: '',
        border: 'Width'
    }, function (prefix, suffix) {
        jQuery.cssHooks[prefix + suffix] = {
            expand: function (value) {
                var i = 0, expanded = {}, parts = typeof value === 'string' ? value.split(' ') : [value];
                for (; i < 4; i++) {
                    expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
                }
                return expanded;
            }
        };
        if (!rmargin.test(prefix)) {
            jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
        }
    });
    jQuery.fn.extend({
        css: function (name, value) {
            return access(this, function (elem, name, value) {
                var styles, len, map = {}, i = 0;
                if (jQuery.isArray(name)) {
                    styles = getStyles(elem);
                    len = name.length;
                    for (; i < len; i++) {
                        map[name[i]] = jQuery.css(elem, name[i], false, styles);
                    }
                    return map;
                }
                return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
            }, name, value, arguments.length > 1);
        }
    });
    function Tween(elem, options, prop, end, easing) {
        return new Tween.prototype.init(elem, options, prop, end, easing);
    }
    jQuery.Tween = Tween;
    Tween.prototype = {
        constructor: Tween,
        init: function (elem, options, prop, end, easing, unit) {
            this.elem = elem;
            this.prop = prop;
            this.easing = easing || jQuery.easing._default;
            this.options = options;
            this.start = this.now = this.cur();
            this.end = end;
            this.unit = unit || (jQuery.cssNumber[prop] ? '' : 'px');
        },
        cur: function () {
            var hooks = Tween.propHooks[this.prop];
            return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
        },
        run: function (percent) {
            var eased, hooks = Tween.propHooks[this.prop];
            if (this.options.duration) {
                this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
            } else {
                this.pos = eased = percent;
            }
            this.now = (this.end - this.start) * eased + this.start;
            if (this.options.step) {
                this.options.step.call(this.elem, this.now, this);
            }
            if (hooks && hooks.set) {
                hooks.set(this);
            } else {
                Tween.propHooks._default.set(this);
            }
            return this;
        }
    };
    Tween.prototype.init.prototype = Tween.prototype;
    Tween.propHooks = {
        _default: {
            get: function (tween) {
                var result;
                if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
                    return tween.elem[tween.prop];
                }
                result = jQuery.css(tween.elem, tween.prop, '');
                return !result || result === 'auto' ? 0 : result;
            },
            set: function (tween) {
                if (jQuery.fx.step[tween.prop]) {
                    jQuery.fx.step[tween.prop](tween);
                } else if (tween.elem.nodeType === 1 && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
                    jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
                } else {
                    tween.elem[tween.prop] = tween.now;
                }
            }
        }
    };
    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function (tween) {
            if (tween.elem.nodeType && tween.elem.parentNode) {
                tween.elem[tween.prop] = tween.now;
            }
        }
    };
    jQuery.easing = {
        linear: function (p) {
            return p;
        },
        swing: function (p) {
            return 0.5 - Math.cos(p * Math.PI) / 2;
        },
        _default: 'swing'
    };
    jQuery.fx = Tween.prototype.init;
    jQuery.fx.step = {};
    var fxNow, timerId, rfxtypes = /^(?:toggle|show|hide)$/, rrun = /queueHooks$/;
    function raf() {
        if (timerId) {
            window.requestAnimationFrame(raf);
            jQuery.fx.tick();
        }
    }
    function createFxNow() {
        window.setTimeout(function () {
            fxNow = undefined;
        });
        return fxNow = jQuery.now();
    }
    function genFx(type, includeWidth) {
        var which, i = 0, attrs = { height: type };
        includeWidth = includeWidth ? 1 : 0;
        for (; i < 4; i += 2 - includeWidth) {
            which = cssExpand[i];
            attrs['margin' + which] = attrs['padding' + which] = type;
        }
        if (includeWidth) {
            attrs.opacity = attrs.width = type;
        }
        return attrs;
    }
    function createTween(value, prop, animation) {
        var tween, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners['*']), index = 0, length = collection.length;
        for (; index < length; index++) {
            if (tween = collection[index].call(animation, prop, value)) {
                return tween;
            }
        }
    }
    function defaultPrefilter(elem, props, opts) {
        var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display, isBox = 'width' in props || 'height' in props, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHiddenWithinTree(elem), dataShow = dataPriv.get(elem, 'fxshow');
        if (!opts.queue) {
            hooks = jQuery._queueHooks(elem, 'fx');
            if (hooks.unqueued == null) {
                hooks.unqueued = 0;
                oldfire = hooks.empty.fire;
                hooks.empty.fire = function () {
                    if (!hooks.unqueued) {
                        oldfire();
                    }
                };
            }
            hooks.unqueued++;
            anim.always(function () {
                anim.always(function () {
                    hooks.unqueued--;
                    if (!jQuery.queue(elem, 'fx').length) {
                        hooks.empty.fire();
                    }
                });
            });
        }
        for (prop in props) {
            value = props[prop];
            if (rfxtypes.test(value)) {
                delete props[prop];
                toggle = toggle || value === 'toggle';
                if (value === (hidden ? 'hide' : 'show')) {
                    if (value === 'show' && dataShow && dataShow[prop] !== undefined) {
                        hidden = true;
                    } else {
                        continue;
                    }
                }
                orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
            }
        }
        propTween = !jQuery.isEmptyObject(props);
        if (!propTween && jQuery.isEmptyObject(orig)) {
            return;
        }
        if (isBox && elem.nodeType === 1) {
            opts.overflow = [
                style.overflow,
                style.overflowX,
                style.overflowY
            ];
            restoreDisplay = dataShow && dataShow.display;
            if (restoreDisplay == null) {
                restoreDisplay = dataPriv.get(elem, 'display');
            }
            display = jQuery.css(elem, 'display');
            if (display === 'none') {
                if (restoreDisplay) {
                    display = restoreDisplay;
                } else {
                    showHide([elem], true);
                    restoreDisplay = elem.style.display || restoreDisplay;
                    display = jQuery.css(elem, 'display');
                    showHide([elem]);
                }
            }
            if (display === 'inline' || display === 'inline-block' && restoreDisplay != null) {
                if (jQuery.css(elem, 'float') === 'none') {
                    if (!propTween) {
                        anim.done(function () {
                            style.display = restoreDisplay;
                        });
                        if (restoreDisplay == null) {
                            display = style.display;
                            restoreDisplay = display === 'none' ? '' : display;
                        }
                    }
                    style.display = 'inline-block';
                }
            }
        }
        if (opts.overflow) {
            style.overflow = 'hidden';
            anim.always(function () {
                style.overflow = opts.overflow[0];
                style.overflowX = opts.overflow[1];
                style.overflowY = opts.overflow[2];
            });
        }
        propTween = false;
        for (prop in orig) {
            if (!propTween) {
                if (dataShow) {
                    if ('hidden' in dataShow) {
                        hidden = dataShow.hidden;
                    }
                } else {
                    dataShow = dataPriv.access(elem, 'fxshow', { display: restoreDisplay });
                }
                if (toggle) {
                    dataShow.hidden = !hidden;
                }
                if (hidden) {
                    showHide([elem], true);
                }
                anim.done(function () {
                    if (!hidden) {
                        showHide([elem]);
                    }
                    dataPriv.remove(elem, 'fxshow');
                    for (prop in orig) {
                        jQuery.style(elem, prop, orig[prop]);
                    }
                });
            }
            propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
            if (!(prop in dataShow)) {
                dataShow[prop] = propTween.start;
                if (hidden) {
                    propTween.end = propTween.start;
                    propTween.start = 0;
                }
            }
        }
    }
    function propFilter(props, specialEasing) {
        var index, name, easing, value, hooks;
        for (index in props) {
            name = jQuery.camelCase(index);
            easing = specialEasing[name];
            value = props[index];
            if (jQuery.isArray(value)) {
                easing = value[1];
                value = props[index] = value[0];
            }
            if (index !== name) {
                props[name] = value;
                delete props[index];
            }
            hooks = jQuery.cssHooks[name];
            if (hooks && 'expand' in hooks) {
                value = hooks.expand(value);
                delete props[name];
                for (index in value) {
                    if (!(index in props)) {
                        props[index] = value[index];
                        specialEasing[index] = easing;
                    }
                }
            } else {
                specialEasing[name] = easing;
            }
        }
    }
    function Animation(elem, properties, options) {
        var result, stopped, index = 0, length = Animation.prefilters.length, deferred = jQuery.Deferred().always(function () {
                delete tick.elem;
            }), tick = function () {
                if (stopped) {
                    return false;
                }
                var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0, length = animation.tweens.length;
                for (; index < length; index++) {
                    animation.tweens[index].run(percent);
                }
                deferred.notifyWith(elem, [
                    animation,
                    percent,
                    remaining
                ]);
                if (percent < 1 && length) {
                    return remaining;
                } else {
                    deferred.resolveWith(elem, [animation]);
                    return false;
                }
            }, animation = deferred.promise({
                elem: elem,
                props: jQuery.extend({}, properties),
                opts: jQuery.extend(true, {
                    specialEasing: {},
                    easing: jQuery.easing._default
                }, options),
                originalProperties: properties,
                originalOptions: options,
                startTime: fxNow || createFxNow(),
                duration: options.duration,
                tweens: [],
                createTween: function (prop, end) {
                    var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
                    animation.tweens.push(tween);
                    return tween;
                },
                stop: function (gotoEnd) {
                    var index = 0, length = gotoEnd ? animation.tweens.length : 0;
                    if (stopped) {
                        return this;
                    }
                    stopped = true;
                    for (; index < length; index++) {
                        animation.tweens[index].run(1);
                    }
                    if (gotoEnd) {
                        deferred.notifyWith(elem, [
                            animation,
                            1,
                            0
                        ]);
                        deferred.resolveWith(elem, [
                            animation,
                            gotoEnd
                        ]);
                    } else {
                        deferred.rejectWith(elem, [
                            animation,
                            gotoEnd
                        ]);
                    }
                    return this;
                }
            }), props = animation.props;
        propFilter(props, animation.opts.specialEasing);
        for (; index < length; index++) {
            result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
            if (result) {
                if (jQuery.isFunction(result.stop)) {
                    jQuery._queueHooks(animation.elem, animation.opts.queue).stop = jQuery.proxy(result.stop, result);
                }
                return result;
            }
        }
        jQuery.map(props, createTween, animation);
        if (jQuery.isFunction(animation.opts.start)) {
            animation.opts.start.call(elem, animation);
        }
        jQuery.fx.timer(jQuery.extend(tick, {
            elem: elem,
            anim: animation,
            queue: animation.opts.queue
        }));
        return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
    }
    jQuery.Animation = jQuery.extend(Animation, {
        tweeners: {
            '*': [function (prop, value) {
                    var tween = this.createTween(prop, value);
                    adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
                    return tween;
                }]
        },
        tweener: function (props, callback) {
            if (jQuery.isFunction(props)) {
                callback = props;
                props = ['*'];
            } else {
                props = props.match(rnothtmlwhite);
            }
            var prop, index = 0, length = props.length;
            for (; index < length; index++) {
                prop = props[index];
                Animation.tweeners[prop] = Animation.tweeners[prop] || [];
                Animation.tweeners[prop].unshift(callback);
            }
        },
        prefilters: [defaultPrefilter],
        prefilter: function (callback, prepend) {
            if (prepend) {
                Animation.prefilters.unshift(callback);
            } else {
                Animation.prefilters.push(callback);
            }
        }
    });
    jQuery.speed = function (speed, easing, fn) {
        var opt = speed && typeof speed === 'object' ? jQuery.extend({}, speed) : {
            complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
            duration: speed,
            easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
        };
        if (jQuery.fx.off || document.hidden) {
            opt.duration = 0;
        } else {
            if (typeof opt.duration !== 'number') {
                if (opt.duration in jQuery.fx.speeds) {
                    opt.duration = jQuery.fx.speeds[opt.duration];
                } else {
                    opt.duration = jQuery.fx.speeds._default;
                }
            }
        }
        if (opt.queue == null || opt.queue === true) {
            opt.queue = 'fx';
        }
        opt.old = opt.complete;
        opt.complete = function () {
            if (jQuery.isFunction(opt.old)) {
                opt.old.call(this);
            }
            if (opt.queue) {
                jQuery.dequeue(this, opt.queue);
            }
        };
        return opt;
    };
    jQuery.fn.extend({
        fadeTo: function (speed, to, easing, callback) {
            return this.filter(isHiddenWithinTree).css('opacity', 0).show().end().animate({ opacity: to }, speed, easing, callback);
        },
        animate: function (prop, speed, easing, callback) {
            var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function () {
                    var anim = Animation(this, jQuery.extend({}, prop), optall);
                    if (empty || dataPriv.get(this, 'finish')) {
                        anim.stop(true);
                    }
                };
            doAnimation.finish = doAnimation;
            return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
        },
        stop: function (type, clearQueue, gotoEnd) {
            var stopQueue = function (hooks) {
                var stop = hooks.stop;
                delete hooks.stop;
                stop(gotoEnd);
            };
            if (typeof type !== 'string') {
                gotoEnd = clearQueue;
                clearQueue = type;
                type = undefined;
            }
            if (clearQueue && type !== false) {
                this.queue(type || 'fx', []);
            }
            return this.each(function () {
                var dequeue = true, index = type != null && type + 'queueHooks', timers = jQuery.timers, data = dataPriv.get(this);
                if (index) {
                    if (data[index] && data[index].stop) {
                        stopQueue(data[index]);
                    }
                } else {
                    for (index in data) {
                        if (data[index] && data[index].stop && rrun.test(index)) {
                            stopQueue(data[index]);
                        }
                    }
                }
                for (index = timers.length; index--;) {
                    if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                        timers[index].anim.stop(gotoEnd);
                        dequeue = false;
                        timers.splice(index, 1);
                    }
                }
                if (dequeue || !gotoEnd) {
                    jQuery.dequeue(this, type);
                }
            });
        },
        finish: function (type) {
            if (type !== false) {
                type = type || 'fx';
            }
            return this.each(function () {
                var index, data = dataPriv.get(this), queue = data[type + 'queue'], hooks = data[type + 'queueHooks'], timers = jQuery.timers, length = queue ? queue.length : 0;
                data.finish = true;
                jQuery.queue(this, type, []);
                if (hooks && hooks.stop) {
                    hooks.stop.call(this, true);
                }
                for (index = timers.length; index--;) {
                    if (timers[index].elem === this && timers[index].queue === type) {
                        timers[index].anim.stop(true);
                        timers.splice(index, 1);
                    }
                }
                for (index = 0; index < length; index++) {
                    if (queue[index] && queue[index].finish) {
                        queue[index].finish.call(this);
                    }
                }
                delete data.finish;
            });
        }
    });
    jQuery.each([
        'toggle',
        'show',
        'hide'
    ], function (i, name) {
        var cssFn = jQuery.fn[name];
        jQuery.fn[name] = function (speed, easing, callback) {
            return speed == null || typeof speed === 'boolean' ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
        };
    });
    jQuery.each({
        slideDown: genFx('show'),
        slideUp: genFx('hide'),
        slideToggle: genFx('toggle'),
        fadeIn: { opacity: 'show' },
        fadeOut: { opacity: 'hide' },
        fadeToggle: { opacity: 'toggle' }
    }, function (name, props) {
        jQuery.fn[name] = function (speed, easing, callback) {
            return this.animate(props, speed, easing, callback);
        };
    });
    jQuery.timers = [];
    jQuery.fx.tick = function () {
        var timer, i = 0, timers = jQuery.timers;
        fxNow = jQuery.now();
        for (; i < timers.length; i++) {
            timer = timers[i];
            if (!timer() && timers[i] === timer) {
                timers.splice(i--, 1);
            }
        }
        if (!timers.length) {
            jQuery.fx.stop();
        }
        fxNow = undefined;
    };
    jQuery.fx.timer = function (timer) {
        jQuery.timers.push(timer);
        if (timer()) {
            jQuery.fx.start();
        } else {
            jQuery.timers.pop();
        }
    };
    jQuery.fx.interval = 13;
    jQuery.fx.start = function () {
        if (!timerId) {
            timerId = window.requestAnimationFrame ? window.requestAnimationFrame(raf) : window.setInterval(jQuery.fx.tick, jQuery.fx.interval);
        }
    };
    jQuery.fx.stop = function () {
        if (window.cancelAnimationFrame) {
            window.cancelAnimationFrame(timerId);
        } else {
            window.clearInterval(timerId);
        }
        timerId = null;
    };
    jQuery.fx.speeds = {
        slow: 600,
        fast: 200,
        _default: 400
    };
    jQuery.fn.delay = function (time, type) {
        time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
        type = type || 'fx';
        return this.queue(type, function (next, hooks) {
            var timeout = window.setTimeout(next, time);
            hooks.stop = function () {
                window.clearTimeout(timeout);
            };
        });
    };
    (function () {
        var input = document.createElement('input'), select = document.createElement('select'), opt = select.appendChild(document.createElement('option'));
        input.type = 'checkbox';
        support.checkOn = input.value !== '';
        support.optSelected = opt.selected;
        input = document.createElement('input');
        input.value = 't';
        input.type = 'radio';
        support.radioValue = input.value === 't';
    }());
    var boolHook, attrHandle = jQuery.expr.attrHandle;
    jQuery.fn.extend({
        attr: function (name, value) {
            return access(this, jQuery.attr, name, value, arguments.length > 1);
        },
        removeAttr: function (name) {
            return this.each(function () {
                jQuery.removeAttr(this, name);
            });
        }
    });
    jQuery.extend({
        attr: function (elem, name, value) {
            var ret, hooks, nType = elem.nodeType;
            if (nType === 3 || nType === 8 || nType === 2) {
                return;
            }
            if (typeof elem.getAttribute === 'undefined') {
                return jQuery.prop(elem, name, value);
            }
            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
            }
            if (value !== undefined) {
                if (value === null) {
                    jQuery.removeAttr(elem, name);
                    return;
                }
                if (hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret;
                }
                elem.setAttribute(name, value + '');
                return value;
            }
            if (hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null) {
                return ret;
            }
            ret = jQuery.find.attr(elem, name);
            return ret == null ? undefined : ret;
        },
        attrHooks: {
            type: {
                set: function (elem, value) {
                    if (!support.radioValue && value === 'radio' && jQuery.nodeName(elem, 'input')) {
                        var val = elem.value;
                        elem.setAttribute('type', value);
                        if (val) {
                            elem.value = val;
                        }
                        return value;
                    }
                }
            }
        },
        removeAttr: function (elem, value) {
            var name, i = 0, attrNames = value && value.match(rnothtmlwhite);
            if (attrNames && elem.nodeType === 1) {
                while (name = attrNames[i++]) {
                    elem.removeAttribute(name);
                }
            }
        }
    });
    boolHook = {
        set: function (elem, value, name) {
            if (value === false) {
                jQuery.removeAttr(elem, name);
            } else {
                elem.setAttribute(name, name);
            }
            return name;
        }
    };
    jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
        var getter = attrHandle[name] || jQuery.find.attr;
        attrHandle[name] = function (elem, name, isXML) {
            var ret, handle, lowercaseName = name.toLowerCase();
            if (!isXML) {
                handle = attrHandle[lowercaseName];
                attrHandle[lowercaseName] = ret;
                ret = getter(elem, name, isXML) != null ? lowercaseName : null;
                attrHandle[lowercaseName] = handle;
            }
            return ret;
        };
    });
    var rfocusable = /^(?:input|select|textarea|button)$/i, rclickable = /^(?:a|area)$/i;
    jQuery.fn.extend({
        prop: function (name, value) {
            return access(this, jQuery.prop, name, value, arguments.length > 1);
        },
        removeProp: function (name) {
            return this.each(function () {
                delete this[jQuery.propFix[name] || name];
            });
        }
    });
    jQuery.extend({
        prop: function (elem, name, value) {
            var ret, hooks, nType = elem.nodeType;
            if (nType === 3 || nType === 8 || nType === 2) {
                return;
            }
            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                name = jQuery.propFix[name] || name;
                hooks = jQuery.propHooks[name];
            }
            if (value !== undefined) {
                if (hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret;
                }
                return elem[name] = value;
            }
            if (hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null) {
                return ret;
            }
            return elem[name];
        },
        propHooks: {
            tabIndex: {
                get: function (elem) {
                    var tabindex = jQuery.find.attr(elem, 'tabindex');
                    if (tabindex) {
                        return parseInt(tabindex, 10);
                    }
                    if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
                        return 0;
                    }
                    return -1;
                }
            }
        },
        propFix: {
            'for': 'htmlFor',
            'class': 'className'
        }
    });
    if (!support.optSelected) {
        jQuery.propHooks.selected = {
            get: function (elem) {
                var parent = elem.parentNode;
                if (parent && parent.parentNode) {
                    parent.parentNode.selectedIndex;
                }
                return null;
            },
            set: function (elem) {
                var parent = elem.parentNode;
                if (parent) {
                    parent.selectedIndex;
                    if (parent.parentNode) {
                        parent.parentNode.selectedIndex;
                    }
                }
            }
        };
    }
    jQuery.each([
        'tabIndex',
        'readOnly',
        'maxLength',
        'cellSpacing',
        'cellPadding',
        'rowSpan',
        'colSpan',
        'useMap',
        'frameBorder',
        'contentEditable'
    ], function () {
        jQuery.propFix[this.toLowerCase()] = this;
    });
    function stripAndCollapse(value) {
        var tokens = value.match(rnothtmlwhite) || [];
        return tokens.join(' ');
    }
    function getClass(elem) {
        return elem.getAttribute && elem.getAttribute('class') || '';
    }
    jQuery.fn.extend({
        addClass: function (value) {
            var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;
            if (jQuery.isFunction(value)) {
                return this.each(function (j) {
                    jQuery(this).addClass(value.call(this, j, getClass(this)));
                });
            }
            if (typeof value === 'string' && value) {
                classes = value.match(rnothtmlwhite) || [];
                while (elem = this[i++]) {
                    curValue = getClass(elem);
                    cur = elem.nodeType === 1 && ' ' + stripAndCollapse(curValue) + ' ';
                    if (cur) {
                        j = 0;
                        while (clazz = classes[j++]) {
                            if (cur.indexOf(' ' + clazz + ' ') < 0) {
                                cur += clazz + ' ';
                            }
                        }
                        finalValue = stripAndCollapse(cur);
                        if (curValue !== finalValue) {
                            elem.setAttribute('class', finalValue);
                        }
                    }
                }
            }
            return this;
        },
        removeClass: function (value) {
            var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;
            if (jQuery.isFunction(value)) {
                return this.each(function (j) {
                    jQuery(this).removeClass(value.call(this, j, getClass(this)));
                });
            }
            if (!arguments.length) {
                return this.attr('class', '');
            }
            if (typeof value === 'string' && value) {
                classes = value.match(rnothtmlwhite) || [];
                while (elem = this[i++]) {
                    curValue = getClass(elem);
                    cur = elem.nodeType === 1 && ' ' + stripAndCollapse(curValue) + ' ';
                    if (cur) {
                        j = 0;
                        while (clazz = classes[j++]) {
                            while (cur.indexOf(' ' + clazz + ' ') > -1) {
                                cur = cur.replace(' ' + clazz + ' ', ' ');
                            }
                        }
                        finalValue = stripAndCollapse(cur);
                        if (curValue !== finalValue) {
                            elem.setAttribute('class', finalValue);
                        }
                    }
                }
            }
            return this;
        },
        toggleClass: function (value, stateVal) {
            var type = typeof value;
            if (typeof stateVal === 'boolean' && type === 'string') {
                return stateVal ? this.addClass(value) : this.removeClass(value);
            }
            if (jQuery.isFunction(value)) {
                return this.each(function (i) {
                    jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
                });
            }
            return this.each(function () {
                var className, i, self, classNames;
                if (type === 'string') {
                    i = 0;
                    self = jQuery(this);
                    classNames = value.match(rnothtmlwhite) || [];
                    while (className = classNames[i++]) {
                        if (self.hasClass(className)) {
                            self.removeClass(className);
                        } else {
                            self.addClass(className);
                        }
                    }
                } else if (value === undefined || type === 'boolean') {
                    className = getClass(this);
                    if (className) {
                        dataPriv.set(this, '__className__', className);
                    }
                    if (this.setAttribute) {
                        this.setAttribute('class', className || value === false ? '' : dataPriv.get(this, '__className__') || '');
                    }
                }
            });
        },
        hasClass: function (selector) {
            var className, elem, i = 0;
            className = ' ' + selector + ' ';
            while (elem = this[i++]) {
                if (elem.nodeType === 1 && (' ' + stripAndCollapse(getClass(elem)) + ' ').indexOf(className) > -1) {
                    return true;
                }
            }
            return false;
        }
    });
    var rreturn = /\r/g;
    jQuery.fn.extend({
        val: function (value) {
            var hooks, ret, isFunction, elem = this[0];
            if (!arguments.length) {
                if (elem) {
                    hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
                    if (hooks && 'get' in hooks && (ret = hooks.get(elem, 'value')) !== undefined) {
                        return ret;
                    }
                    ret = elem.value;
                    if (typeof ret === 'string') {
                        return ret.replace(rreturn, '');
                    }
                    return ret == null ? '' : ret;
                }
                return;
            }
            isFunction = jQuery.isFunction(value);
            return this.each(function (i) {
                var val;
                if (this.nodeType !== 1) {
                    return;
                }
                if (isFunction) {
                    val = value.call(this, i, jQuery(this).val());
                } else {
                    val = value;
                }
                if (val == null) {
                    val = '';
                } else if (typeof val === 'number') {
                    val += '';
                } else if (jQuery.isArray(val)) {
                    val = jQuery.map(val, function (value) {
                        return value == null ? '' : value + '';
                    });
                }
                hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
                if (!hooks || !('set' in hooks) || hooks.set(this, val, 'value') === undefined) {
                    this.value = val;
                }
            });
        }
    });
    jQuery.extend({
        valHooks: {
            option: {
                get: function (elem) {
                    var val = jQuery.find.attr(elem, 'value');
                    return val != null ? val : stripAndCollapse(jQuery.text(elem));
                }
            },
            select: {
                get: function (elem) {
                    var value, option, i, options = elem.options, index = elem.selectedIndex, one = elem.type === 'select-one', values = one ? null : [], max = one ? index + 1 : options.length;
                    if (index < 0) {
                        i = max;
                    } else {
                        i = one ? index : 0;
                    }
                    for (; i < max; i++) {
                        option = options[i];
                        if ((option.selected || i === index) && !option.disabled && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, 'optgroup'))) {
                            value = jQuery(option).val();
                            if (one) {
                                return value;
                            }
                            values.push(value);
                        }
                    }
                    return values;
                },
                set: function (elem, value) {
                    var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length;
                    while (i--) {
                        option = options[i];
                        if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
                            optionSet = true;
                        }
                    }
                    if (!optionSet) {
                        elem.selectedIndex = -1;
                    }
                    return values;
                }
            }
        }
    });
    jQuery.each([
        'radio',
        'checkbox'
    ], function () {
        jQuery.valHooks[this] = {
            set: function (elem, value) {
                if (jQuery.isArray(value)) {
                    return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
                }
            }
        };
        if (!support.checkOn) {
            jQuery.valHooks[this].get = function (elem) {
                return elem.getAttribute('value') === null ? 'on' : elem.value;
            };
        }
    });
    var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;
    jQuery.extend(jQuery.event, {
        trigger: function (event, data, elem, onlyHandlers) {
            var i, cur, tmp, bubbleType, ontype, handle, special, eventPath = [elem || document], type = hasOwn.call(event, 'type') ? event.type : event, namespaces = hasOwn.call(event, 'namespace') ? event.namespace.split('.') : [];
            cur = tmp = elem = elem || document;
            if (elem.nodeType === 3 || elem.nodeType === 8) {
                return;
            }
            if (rfocusMorph.test(type + jQuery.event.triggered)) {
                return;
            }
            if (type.indexOf('.') > -1) {
                namespaces = type.split('.');
                type = namespaces.shift();
                namespaces.sort();
            }
            ontype = type.indexOf(':') < 0 && 'on' + type;
            event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === 'object' && event);
            event.isTrigger = onlyHandlers ? 2 : 3;
            event.namespace = namespaces.join('.');
            event.rnamespace = event.namespace ? new RegExp('(^|\\.)' + namespaces.join('\\.(?:.*\\.|)') + '(\\.|$)') : null;
            event.result = undefined;
            if (!event.target) {
                event.target = elem;
            }
            data = data == null ? [event] : jQuery.makeArray(data, [event]);
            special = jQuery.event.special[type] || {};
            if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
                return;
            }
            if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
                bubbleType = special.delegateType || type;
                if (!rfocusMorph.test(bubbleType + type)) {
                    cur = cur.parentNode;
                }
                for (; cur; cur = cur.parentNode) {
                    eventPath.push(cur);
                    tmp = cur;
                }
                if (tmp === (elem.ownerDocument || document)) {
                    eventPath.push(tmp.defaultView || tmp.parentWindow || window);
                }
            }
            i = 0;
            while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
                event.type = i > 1 ? bubbleType : special.bindType || type;
                handle = (dataPriv.get(cur, 'events') || {})[event.type] && dataPriv.get(cur, 'handle');
                if (handle) {
                    handle.apply(cur, data);
                }
                handle = ontype && cur[ontype];
                if (handle && handle.apply && acceptData(cur)) {
                    event.result = handle.apply(cur, data);
                    if (event.result === false) {
                        event.preventDefault();
                    }
                }
            }
            event.type = type;
            if (!onlyHandlers && !event.isDefaultPrevented()) {
                if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
                    if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {
                        tmp = elem[ontype];
                        if (tmp) {
                            elem[ontype] = null;
                        }
                        jQuery.event.triggered = type;
                        elem[type]();
                        jQuery.event.triggered = undefined;
                        if (tmp) {
                            elem[ontype] = tmp;
                        }
                    }
                }
            }
            return event.result;
        },
        simulate: function (type, elem, event) {
            var e = jQuery.extend(new jQuery.Event(), event, {
                type: type,
                isSimulated: true
            });
            jQuery.event.trigger(e, null, elem);
        }
    });
    jQuery.fn.extend({
        trigger: function (type, data) {
            return this.each(function () {
                jQuery.event.trigger(type, data, this);
            });
        },
        triggerHandler: function (type, data) {
            var elem = this[0];
            if (elem) {
                return jQuery.event.trigger(type, data, elem, true);
            }
        }
    });
    jQuery.each(('blur focus focusin focusout resize scroll click dblclick ' + 'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave ' + 'change select submit keydown keypress keyup contextmenu').split(' '), function (i, name) {
        jQuery.fn[name] = function (data, fn) {
            return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
        };
    });
    jQuery.fn.extend({
        hover: function (fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
        }
    });
    support.focusin = 'onfocusin' in window;
    if (!support.focusin) {
        jQuery.each({
            focus: 'focusin',
            blur: 'focusout'
        }, function (orig, fix) {
            var handler = function (event) {
                jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
            };
            jQuery.event.special[fix] = {
                setup: function () {
                    var doc = this.ownerDocument || this, attaches = dataPriv.access(doc, fix);
                    if (!attaches) {
                        doc.addEventListener(orig, handler, true);
                    }
                    dataPriv.access(doc, fix, (attaches || 0) + 1);
                },
                teardown: function () {
                    var doc = this.ownerDocument || this, attaches = dataPriv.access(doc, fix) - 1;
                    if (!attaches) {
                        doc.removeEventListener(orig, handler, true);
                        dataPriv.remove(doc, fix);
                    } else {
                        dataPriv.access(doc, fix, attaches);
                    }
                }
            };
        });
    }
    var location = window.location;
    var nonce = jQuery.now();
    var rquery = /\?/;
    jQuery.parseXML = function (data) {
        var xml;
        if (!data || typeof data !== 'string') {
            return null;
        }
        try {
            xml = new window.DOMParser().parseFromString(data, 'text/xml');
        } catch (e) {
            xml = undefined;
        }
        if (!xml || xml.getElementsByTagName('parsererror').length) {
            jQuery.error('Invalid XML: ' + data);
        }
        return xml;
    };
    var rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
    function buildParams(prefix, obj, traditional, add) {
        var name;
        if (jQuery.isArray(obj)) {
            jQuery.each(obj, function (i, v) {
                if (traditional || rbracket.test(prefix)) {
                    add(prefix, v);
                } else {
                    buildParams(prefix + '[' + (typeof v === 'object' && v != null ? i : '') + ']', v, traditional, add);
                }
            });
        } else if (!traditional && jQuery.type(obj) === 'object') {
            for (name in obj) {
                buildParams(prefix + '[' + name + ']', obj[name], traditional, add);
            }
        } else {
            add(prefix, obj);
        }
    }
    jQuery.param = function (a, traditional) {
        var prefix, s = [], add = function (key, valueOrFunction) {
                var value = jQuery.isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;
                s[s.length] = encodeURIComponent(key) + '=' + encodeURIComponent(value == null ? '' : value);
            };
        if (jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
            jQuery.each(a, function () {
                add(this.name, this.value);
            });
        } else {
            for (prefix in a) {
                buildParams(prefix, a[prefix], traditional, add);
            }
        }
        return s.join('&');
    };
    jQuery.fn.extend({
        serialize: function () {
            return jQuery.param(this.serializeArray());
        },
        serializeArray: function () {
            return this.map(function () {
                var elements = jQuery.prop(this, 'elements');
                return elements ? jQuery.makeArray(elements) : this;
            }).filter(function () {
                var type = this.type;
                return this.name && !jQuery(this).is(':disabled') && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
            }).map(function (i, elem) {
                var val = jQuery(this).val();
                if (val == null) {
                    return null;
                }
                if (jQuery.isArray(val)) {
                    return jQuery.map(val, function (val) {
                        return {
                            name: elem.name,
                            value: val.replace(rCRLF, '\r\n')
                        };
                    });
                }
                return {
                    name: elem.name,
                    value: val.replace(rCRLF, '\r\n')
                };
            }).get();
        }
    });
    var r20 = /%20/g, rhash = /#.*$/, rantiCache = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/gm, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, prefilters = {}, transports = {}, allTypes = '*/'.concat('*'), originAnchor = document.createElement('a');
    originAnchor.href = location.href;
    function addToPrefiltersOrTransports(structure) {
        return function (dataTypeExpression, func) {
            if (typeof dataTypeExpression !== 'string') {
                func = dataTypeExpression;
                dataTypeExpression = '*';
            }
            var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
            if (jQuery.isFunction(func)) {
                while (dataType = dataTypes[i++]) {
                    if (dataType[0] === '+') {
                        dataType = dataType.slice(1) || '*';
                        (structure[dataType] = structure[dataType] || []).unshift(func);
                    } else {
                        (structure[dataType] = structure[dataType] || []).push(func);
                    }
                }
            }
        };
    }
    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
        var inspected = {}, seekingTransport = structure === transports;
        function inspect(dataType) {
            var selected;
            inspected[dataType] = true;
            jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
                var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                if (typeof dataTypeOrTransport === 'string' && !seekingTransport && !inspected[dataTypeOrTransport]) {
                    options.dataTypes.unshift(dataTypeOrTransport);
                    inspect(dataTypeOrTransport);
                    return false;
                } else if (seekingTransport) {
                    return !(selected = dataTypeOrTransport);
                }
            });
            return selected;
        }
        return inspect(options.dataTypes[0]) || !inspected['*'] && inspect('*');
    }
    function ajaxExtend(target, src) {
        var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
        for (key in src) {
            if (src[key] !== undefined) {
                (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
            }
        }
        if (deep) {
            jQuery.extend(true, target, deep);
        }
        return target;
    }
    function ajaxHandleResponses(s, jqXHR, responses) {
        var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes;
        while (dataTypes[0] === '*') {
            dataTypes.shift();
            if (ct === undefined) {
                ct = s.mimeType || jqXHR.getResponseHeader('Content-Type');
            }
        }
        if (ct) {
            for (type in contents) {
                if (contents[type] && contents[type].test(ct)) {
                    dataTypes.unshift(type);
                    break;
                }
            }
        }
        if (dataTypes[0] in responses) {
            finalDataType = dataTypes[0];
        } else {
            for (type in responses) {
                if (!dataTypes[0] || s.converters[type + ' ' + dataTypes[0]]) {
                    finalDataType = type;
                    break;
                }
                if (!firstDataType) {
                    firstDataType = type;
                }
            }
            finalDataType = finalDataType || firstDataType;
        }
        if (finalDataType) {
            if (finalDataType !== dataTypes[0]) {
                dataTypes.unshift(finalDataType);
            }
            return responses[finalDataType];
        }
    }
    function ajaxConvert(s, response, jqXHR, isSuccess) {
        var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s.dataTypes.slice();
        if (dataTypes[1]) {
            for (conv in s.converters) {
                converters[conv.toLowerCase()] = s.converters[conv];
            }
        }
        current = dataTypes.shift();
        while (current) {
            if (s.responseFields[current]) {
                jqXHR[s.responseFields[current]] = response;
            }
            if (!prev && isSuccess && s.dataFilter) {
                response = s.dataFilter(response, s.dataType);
            }
            prev = current;
            current = dataTypes.shift();
            if (current) {
                if (current === '*') {
                    current = prev;
                } else if (prev !== '*' && prev !== current) {
                    conv = converters[prev + ' ' + current] || converters['* ' + current];
                    if (!conv) {
                        for (conv2 in converters) {
                            tmp = conv2.split(' ');
                            if (tmp[1] === current) {
                                conv = converters[prev + ' ' + tmp[0]] || converters['* ' + tmp[0]];
                                if (conv) {
                                    if (conv === true) {
                                        conv = converters[conv2];
                                    } else if (converters[conv2] !== true) {
                                        current = tmp[0];
                                        dataTypes.unshift(tmp[1]);
                                    }
                                    break;
                                }
                            }
                        }
                    }
                    if (conv !== true) {
                        if (conv && s.throws) {
                            response = conv(response);
                        } else {
                            try {
                                response = conv(response);
                            } catch (e) {
                                return {
                                    state: 'parsererror',
                                    error: conv ? e : 'No conversion from ' + prev + ' to ' + current
                                };
                            }
                        }
                    }
                }
            }
        }
        return {
            state: 'success',
            data: response
        };
    }
    jQuery.extend({
        active: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: {
            url: location.href,
            type: 'GET',
            isLocal: rlocalProtocol.test(location.protocol),
            global: true,
            processData: true,
            async: true,
            contentType: 'application/x-www-form-urlencoded; charset=UTF-8',
            accepts: {
                '*': allTypes,
                text: 'text/plain',
                html: 'text/html',
                xml: 'application/xml, text/xml',
                json: 'application/json, text/javascript'
            },
            contents: {
                xml: /\bxml\b/,
                html: /\bhtml/,
                json: /\bjson\b/
            },
            responseFields: {
                xml: 'responseXML',
                text: 'responseText',
                json: 'responseJSON'
            },
            converters: {
                '* text': String,
                'text html': true,
                'text json': JSON.parse,
                'text xml': jQuery.parseXML
            },
            flatOptions: {
                url: true,
                context: true
            }
        },
        ajaxSetup: function (target, settings) {
            return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
        },
        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),
        ajax: function (url, options) {
            if (typeof url === 'object') {
                options = url;
                url = undefined;
            }
            options = options || {};
            var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, urlAnchor, completed, fireGlobals, i, uncached, s = jQuery.ajaxSetup({}, options), callbackContext = s.context || s, globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks('once memory'), statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, strAbort = 'canceled', jqXHR = {
                    readyState: 0,
                    getResponseHeader: function (key) {
                        var match;
                        if (completed) {
                            if (!responseHeaders) {
                                responseHeaders = {};
                                while (match = rheaders.exec(responseHeadersString)) {
                                    responseHeaders[match[1].toLowerCase()] = match[2];
                                }
                            }
                            match = responseHeaders[key.toLowerCase()];
                        }
                        return match == null ? null : match;
                    },
                    getAllResponseHeaders: function () {
                        return completed ? responseHeadersString : null;
                    },
                    setRequestHeader: function (name, value) {
                        if (completed == null) {
                            name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
                            requestHeaders[name] = value;
                        }
                        return this;
                    },
                    overrideMimeType: function (type) {
                        if (completed == null) {
                            s.mimeType = type;
                        }
                        return this;
                    },
                    statusCode: function (map) {
                        var code;
                        if (map) {
                            if (completed) {
                                jqXHR.always(map[jqXHR.status]);
                            } else {
                                for (code in map) {
                                    statusCode[code] = [
                                        statusCode[code],
                                        map[code]
                                    ];
                                }
                            }
                        }
                        return this;
                    },
                    abort: function (statusText) {
                        var finalText = statusText || strAbort;
                        if (transport) {
                            transport.abort(finalText);
                        }
                        done(0, finalText);
                        return this;
                    }
                };
            deferred.promise(jqXHR);
            s.url = ((url || s.url || location.href) + '').replace(rprotocol, location.protocol + '//');
            s.type = options.method || options.type || s.method || s.type;
            s.dataTypes = (s.dataType || '*').toLowerCase().match(rnothtmlwhite) || [''];
            if (s.crossDomain == null) {
                urlAnchor = document.createElement('a');
                try {
                    urlAnchor.href = s.url;
                    urlAnchor.href = urlAnchor.href;
                    s.crossDomain = originAnchor.protocol + '//' + originAnchor.host !== urlAnchor.protocol + '//' + urlAnchor.host;
                } catch (e) {
                    s.crossDomain = true;
                }
            }
            if (s.data && s.processData && typeof s.data !== 'string') {
                s.data = jQuery.param(s.data, s.traditional);
            }
            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
            if (completed) {
                return jqXHR;
            }
            fireGlobals = jQuery.event && s.global;
            if (fireGlobals && jQuery.active++ === 0) {
                jQuery.event.trigger('ajaxStart');
            }
            s.type = s.type.toUpperCase();
            s.hasContent = !rnoContent.test(s.type);
            cacheURL = s.url.replace(rhash, '');
            if (!s.hasContent) {
                uncached = s.url.slice(cacheURL.length);
                if (s.data) {
                    cacheURL += (rquery.test(cacheURL) ? '&' : '?') + s.data;
                    delete s.data;
                }
                if (s.cache === false) {
                    cacheURL = cacheURL.replace(rantiCache, '$1');
                    uncached = (rquery.test(cacheURL) ? '&' : '?') + '_=' + nonce++ + uncached;
                }
                s.url = cacheURL + uncached;
            } else if (s.data && s.processData && (s.contentType || '').indexOf('application/x-www-form-urlencoded') === 0) {
                s.data = s.data.replace(r20, '+');
            }
            if (s.ifModified) {
                if (jQuery.lastModified[cacheURL]) {
                    jqXHR.setRequestHeader('If-Modified-Since', jQuery.lastModified[cacheURL]);
                }
                if (jQuery.etag[cacheURL]) {
                    jqXHR.setRequestHeader('If-None-Match', jQuery.etag[cacheURL]);
                }
            }
            if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
                jqXHR.setRequestHeader('Content-Type', s.contentType);
            }
            jqXHR.setRequestHeader('Accept', s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== '*' ? ', ' + allTypes + '; q=0.01' : '') : s.accepts['*']);
            for (i in s.headers) {
                jqXHR.setRequestHeader(i, s.headers[i]);
            }
            if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) {
                return jqXHR.abort();
            }
            strAbort = 'abort';
            completeDeferred.add(s.complete);
            jqXHR.done(s.success);
            jqXHR.fail(s.error);
            transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
            if (!transport) {
                done(-1, 'No Transport');
            } else {
                jqXHR.readyState = 1;
                if (fireGlobals) {
                    globalEventContext.trigger('ajaxSend', [
                        jqXHR,
                        s
                    ]);
                }
                if (completed) {
                    return jqXHR;
                }
                if (s.async && s.timeout > 0) {
                    timeoutTimer = window.setTimeout(function () {
                        jqXHR.abort('timeout');
                    }, s.timeout);
                }
                try {
                    completed = false;
                    transport.send(requestHeaders, done);
                } catch (e) {
                    if (completed) {
                        throw e;
                    }
                    done(-1, e);
                }
            }
            function done(status, nativeStatusText, responses, headers) {
                var isSuccess, success, error, response, modified, statusText = nativeStatusText;
                if (completed) {
                    return;
                }
                completed = true;
                if (timeoutTimer) {
                    window.clearTimeout(timeoutTimer);
                }
                transport = undefined;
                responseHeadersString = headers || '';
                jqXHR.readyState = status > 0 ? 4 : 0;
                isSuccess = status >= 200 && status < 300 || status === 304;
                if (responses) {
                    response = ajaxHandleResponses(s, jqXHR, responses);
                }
                response = ajaxConvert(s, response, jqXHR, isSuccess);
                if (isSuccess) {
                    if (s.ifModified) {
                        modified = jqXHR.getResponseHeader('Last-Modified');
                        if (modified) {
                            jQuery.lastModified[cacheURL] = modified;
                        }
                        modified = jqXHR.getResponseHeader('etag');
                        if (modified) {
                            jQuery.etag[cacheURL] = modified;
                        }
                    }
                    if (status === 204 || s.type === 'HEAD') {
                        statusText = 'nocontent';
                    } else if (status === 304) {
                        statusText = 'notmodified';
                    } else {
                        statusText = response.state;
                        success = response.data;
                        error = response.error;
                        isSuccess = !error;
                    }
                } else {
                    error = statusText;
                    if (status || !statusText) {
                        statusText = 'error';
                        if (status < 0) {
                            status = 0;
                        }
                    }
                }
                jqXHR.status = status;
                jqXHR.statusText = (nativeStatusText || statusText) + '';
                if (isSuccess) {
                    deferred.resolveWith(callbackContext, [
                        success,
                        statusText,
                        jqXHR
                    ]);
                } else {
                    deferred.rejectWith(callbackContext, [
                        jqXHR,
                        statusText,
                        error
                    ]);
                }
                jqXHR.statusCode(statusCode);
                statusCode = undefined;
                if (fireGlobals) {
                    globalEventContext.trigger(isSuccess ? 'ajaxSuccess' : 'ajaxError', [
                        jqXHR,
                        s,
                        isSuccess ? success : error
                    ]);
                }
                completeDeferred.fireWith(callbackContext, [
                    jqXHR,
                    statusText
                ]);
                if (fireGlobals) {
                    globalEventContext.trigger('ajaxComplete', [
                        jqXHR,
                        s
                    ]);
                    if (!--jQuery.active) {
                        jQuery.event.trigger('ajaxStop');
                    }
                }
            }
            return jqXHR;
        },
        getJSON: function (url, data, callback) {
            return jQuery.get(url, data, callback, 'json');
        },
        getScript: function (url, callback) {
            return jQuery.get(url, undefined, callback, 'script');
        }
    });
    jQuery.each([
        'get',
        'post'
    ], function (i, method) {
        jQuery[method] = function (url, data, callback, type) {
            if (jQuery.isFunction(data)) {
                type = type || callback;
                callback = data;
                data = undefined;
            }
            return jQuery.ajax(jQuery.extend({
                url: url,
                type: method,
                dataType: type,
                data: data,
                success: callback
            }, jQuery.isPlainObject(url) && url));
        };
    });
    jQuery._evalUrl = function (url) {
        return jQuery.ajax({
            url: url,
            type: 'GET',
            dataType: 'script',
            cache: true,
            async: false,
            global: false,
            'throws': true
        });
    };
    jQuery.fn.extend({
        wrapAll: function (html) {
            var wrap;
            if (this[0]) {
                if (jQuery.isFunction(html)) {
                    html = html.call(this[0]);
                }
                wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
                if (this[0].parentNode) {
                    wrap.insertBefore(this[0]);
                }
                wrap.map(function () {
                    var elem = this;
                    while (elem.firstElementChild) {
                        elem = elem.firstElementChild;
                    }
                    return elem;
                }).append(this);
            }
            return this;
        },
        wrapInner: function (html) {
            if (jQuery.isFunction(html)) {
                return this.each(function (i) {
                    jQuery(this).wrapInner(html.call(this, i));
                });
            }
            return this.each(function () {
                var self = jQuery(this), contents = self.contents();
                if (contents.length) {
                    contents.wrapAll(html);
                } else {
                    self.append(html);
                }
            });
        },
        wrap: function (html) {
            var isFunction = jQuery.isFunction(html);
            return this.each(function (i) {
                jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
            });
        },
        unwrap: function (selector) {
            this.parent(selector).not('body').each(function () {
                jQuery(this).replaceWith(this.childNodes);
            });
            return this;
        }
    });
    jQuery.expr.pseudos.hidden = function (elem) {
        return !jQuery.expr.pseudos.visible(elem);
    };
    jQuery.expr.pseudos.visible = function (elem) {
        return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
    };
    jQuery.ajaxSettings.xhr = function () {
        try {
            return new window.XMLHttpRequest();
        } catch (e) {
        }
    };
    var xhrSuccessStatus = {
            0: 200,
            1223: 204
        }, xhrSupported = jQuery.ajaxSettings.xhr();
    support.cors = !!xhrSupported && 'withCredentials' in xhrSupported;
    support.ajax = xhrSupported = !!xhrSupported;
    jQuery.ajaxTransport(function (options) {
        var callback, errorCallback;
        if (support.cors || xhrSupported && !options.crossDomain) {
            return {
                send: function (headers, complete) {
                    var i, xhr = options.xhr();
                    xhr.open(options.type, options.url, options.async, options.username, options.password);
                    if (options.xhrFields) {
                        for (i in options.xhrFields) {
                            xhr[i] = options.xhrFields[i];
                        }
                    }
                    if (options.mimeType && xhr.overrideMimeType) {
                        xhr.overrideMimeType(options.mimeType);
                    }
                    if (!options.crossDomain && !headers['X-Requested-With']) {
                        headers['X-Requested-With'] = 'XMLHttpRequest';
                    }
                    for (i in headers) {
                        xhr.setRequestHeader(i, headers[i]);
                    }
                    callback = function (type) {
                        return function () {
                            if (callback) {
                                callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;
                                if (type === 'abort') {
                                    xhr.abort();
                                } else if (type === 'error') {
                                    if (typeof xhr.status !== 'number') {
                                        complete(0, 'error');
                                    } else {
                                        complete(xhr.status, xhr.statusText);
                                    }
                                } else {
                                    complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, (xhr.responseType || 'text') !== 'text' || typeof xhr.responseText !== 'string' ? { binary: xhr.response } : { text: xhr.responseText }, xhr.getAllResponseHeaders());
                                }
                            }
                        };
                    };
                    xhr.onload = callback();
                    errorCallback = xhr.onerror = callback('error');
                    if (xhr.onabort !== undefined) {
                        xhr.onabort = errorCallback;
                    } else {
                        xhr.onreadystatechange = function () {
                            if (xhr.readyState === 4) {
                                window.setTimeout(function () {
                                    if (callback) {
                                        errorCallback();
                                    }
                                });
                            }
                        };
                    }
                    callback = callback('abort');
                    try {
                        xhr.send(options.hasContent && options.data || null);
                    } catch (e) {
                        if (callback) {
                            throw e;
                        }
                    }
                },
                abort: function () {
                    if (callback) {
                        callback();
                    }
                }
            };
        }
    });
    jQuery.ajaxPrefilter(function (s) {
        if (s.crossDomain) {
            s.contents.script = false;
        }
    });
    jQuery.ajaxSetup({
        accepts: { script: 'text/javascript, application/javascript, ' + 'application/ecmascript, application/x-ecmascript' },
        contents: { script: /\b(?:java|ecma)script\b/ },
        converters: {
            'text script': function (text) {
                jQuery.globalEval(text);
                return text;
            }
        }
    });
    jQuery.ajaxPrefilter('script', function (s) {
        if (s.cache === undefined) {
            s.cache = false;
        }
        if (s.crossDomain) {
            s.type = 'GET';
        }
    });
    jQuery.ajaxTransport('script', function (s) {
        if (s.crossDomain) {
            var script, callback;
            return {
                send: function (_, complete) {
                    script = jQuery('<script>').prop({
                        charset: s.scriptCharset,
                        src: s.url
                    }).on('load error', callback = function (evt) {
                        script.remove();
                        callback = null;
                        if (evt) {
                            complete(evt.type === 'error' ? 404 : 200, evt.type);
                        }
                    });
                    document.head.appendChild(script[0]);
                },
                abort: function () {
                    if (callback) {
                        callback();
                    }
                }
            };
        }
    });
    var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
    jQuery.ajaxSetup({
        jsonp: 'callback',
        jsonpCallback: function () {
            var callback = oldCallbacks.pop() || jQuery.expando + '_' + nonce++;
            this[callback] = true;
            return callback;
        }
    });
    jQuery.ajaxPrefilter('json jsonp', function (s, originalSettings, jqXHR) {
        var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? 'url' : typeof s.data === 'string' && (s.contentType || '').indexOf('application/x-www-form-urlencoded') === 0 && rjsonp.test(s.data) && 'data');
        if (jsonProp || s.dataTypes[0] === 'jsonp') {
            callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
            if (jsonProp) {
                s[jsonProp] = s[jsonProp].replace(rjsonp, '$1' + callbackName);
            } else if (s.jsonp !== false) {
                s.url += (rquery.test(s.url) ? '&' : '?') + s.jsonp + '=' + callbackName;
            }
            s.converters['script json'] = function () {
                if (!responseContainer) {
                    jQuery.error(callbackName + ' was not called');
                }
                return responseContainer[0];
            };
            s.dataTypes[0] = 'json';
            overwritten = window[callbackName];
            window[callbackName] = function () {
                responseContainer = arguments;
            };
            jqXHR.always(function () {
                if (overwritten === undefined) {
                    jQuery(window).removeProp(callbackName);
                } else {
                    window[callbackName] = overwritten;
                }
                if (s[callbackName]) {
                    s.jsonpCallback = originalSettings.jsonpCallback;
                    oldCallbacks.push(callbackName);
                }
                if (responseContainer && jQuery.isFunction(overwritten)) {
                    overwritten(responseContainer[0]);
                }
                responseContainer = overwritten = undefined;
            });
            return 'script';
        }
    });
    support.createHTMLDocument = function () {
        var body = document.implementation.createHTMLDocument('').body;
        body.innerHTML = '<form></form><form></form>';
        return body.childNodes.length === 2;
    }();
    jQuery.parseHTML = function (data, context, keepScripts) {
        if (typeof data !== 'string') {
            return [];
        }
        if (typeof context === 'boolean') {
            keepScripts = context;
            context = false;
        }
        var base, parsed, scripts;
        if (!context) {
            if (support.createHTMLDocument) {
                context = document.implementation.createHTMLDocument('');
                base = context.createElement('base');
                base.href = document.location.href;
                context.head.appendChild(base);
            } else {
                context = document;
            }
        }
        parsed = rsingleTag.exec(data);
        scripts = !keepScripts && [];
        if (parsed) {
            return [context.createElement(parsed[1])];
        }
        parsed = buildFragment([data], context, scripts);
        if (scripts && scripts.length) {
            jQuery(scripts).remove();
        }
        return jQuery.merge([], parsed.childNodes);
    };
    jQuery.fn.load = function (url, params, callback) {
        var selector, type, response, self = this, off = url.indexOf(' ');
        if (off > -1) {
            selector = stripAndCollapse(url.slice(off));
            url = url.slice(0, off);
        }
        if (jQuery.isFunction(params)) {
            callback = params;
            params = undefined;
        } else if (params && typeof params === 'object') {
            type = 'POST';
        }
        if (self.length > 0) {
            jQuery.ajax({
                url: url,
                type: type || 'GET',
                dataType: 'html',
                data: params
            }).done(function (responseText) {
                response = arguments;
                self.html(selector ? jQuery('<div>').append(jQuery.parseHTML(responseText)).find(selector) : responseText);
            }).always(callback && function (jqXHR, status) {
                self.each(function () {
                    callback.apply(this, response || [
                        jqXHR.responseText,
                        status,
                        jqXHR
                    ]);
                });
            });
        }
        return this;
    };
    jQuery.each([
        'ajaxStart',
        'ajaxStop',
        'ajaxComplete',
        'ajaxError',
        'ajaxSuccess',
        'ajaxSend'
    ], function (i, type) {
        jQuery.fn[type] = function (fn) {
            return this.on(type, fn);
        };
    });
    jQuery.expr.pseudos.animated = function (elem) {
        return jQuery.grep(jQuery.timers, function (fn) {
            return elem === fn.elem;
        }).length;
    };
    function getWindow(elem) {
        return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
    }
    jQuery.offset = {
        setOffset: function (elem, options, i) {
            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, 'position'), curElem = jQuery(elem), props = {};
            if (position === 'static') {
                elem.style.position = 'relative';
            }
            curOffset = curElem.offset();
            curCSSTop = jQuery.css(elem, 'top');
            curCSSLeft = jQuery.css(elem, 'left');
            calculatePosition = (position === 'absolute' || position === 'fixed') && (curCSSTop + curCSSLeft).indexOf('auto') > -1;
            if (calculatePosition) {
                curPosition = curElem.position();
                curTop = curPosition.top;
                curLeft = curPosition.left;
            } else {
                curTop = parseFloat(curCSSTop) || 0;
                curLeft = parseFloat(curCSSLeft) || 0;
            }
            if (jQuery.isFunction(options)) {
                options = options.call(elem, i, jQuery.extend({}, curOffset));
            }
            if (options.top != null) {
                props.top = options.top - curOffset.top + curTop;
            }
            if (options.left != null) {
                props.left = options.left - curOffset.left + curLeft;
            }
            if ('using' in options) {
                options.using.call(elem, props);
            } else {
                curElem.css(props);
            }
        }
    };
    jQuery.fn.extend({
        offset: function (options) {
            if (arguments.length) {
                return options === undefined ? this : this.each(function (i) {
                    jQuery.offset.setOffset(this, options, i);
                });
            }
            var docElem, win, rect, doc, elem = this[0];
            if (!elem) {
                return;
            }
            if (!elem.getClientRects().length) {
                return {
                    top: 0,
                    left: 0
                };
            }
            rect = elem.getBoundingClientRect();
            if (rect.width || rect.height) {
                doc = elem.ownerDocument;
                win = getWindow(doc);
                docElem = doc.documentElement;
                return {
                    top: rect.top + win.pageYOffset - docElem.clientTop,
                    left: rect.left + win.pageXOffset - docElem.clientLeft
                };
            }
            return rect;
        },
        position: function () {
            if (!this[0]) {
                return;
            }
            var offsetParent, offset, elem = this[0], parentOffset = {
                    top: 0,
                    left: 0
                };
            if (jQuery.css(elem, 'position') === 'fixed') {
                offset = elem.getBoundingClientRect();
            } else {
                offsetParent = this.offsetParent();
                offset = this.offset();
                if (!jQuery.nodeName(offsetParent[0], 'html')) {
                    parentOffset = offsetParent.offset();
                }
                parentOffset = {
                    top: parentOffset.top + jQuery.css(offsetParent[0], 'borderTopWidth', true),
                    left: parentOffset.left + jQuery.css(offsetParent[0], 'borderLeftWidth', true)
                };
            }
            return {
                top: offset.top - parentOffset.top - jQuery.css(elem, 'marginTop', true),
                left: offset.left - parentOffset.left - jQuery.css(elem, 'marginLeft', true)
            };
        },
        offsetParent: function () {
            return this.map(function () {
                var offsetParent = this.offsetParent;
                while (offsetParent && jQuery.css(offsetParent, 'position') === 'static') {
                    offsetParent = offsetParent.offsetParent;
                }
                return offsetParent || documentElement;
            });
        }
    });
    jQuery.each({
        scrollLeft: 'pageXOffset',
        scrollTop: 'pageYOffset'
    }, function (method, prop) {
        var top = 'pageYOffset' === prop;
        jQuery.fn[method] = function (val) {
            return access(this, function (elem, method, val) {
                var win = getWindow(elem);
                if (val === undefined) {
                    return win ? win[prop] : elem[method];
                }
                if (win) {
                    win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);
                } else {
                    elem[method] = val;
                }
            }, method, val, arguments.length);
        };
    });
    jQuery.each([
        'top',
        'left'
    ], function (i, prop) {
        jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {
            if (computed) {
                computed = curCSS(elem, prop);
                return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + 'px' : computed;
            }
        });
    });
    jQuery.each({
        Height: 'height',
        Width: 'width'
    }, function (name, type) {
        jQuery.each({
            padding: 'inner' + name,
            content: type,
            '': 'outer' + name
        }, function (defaultExtra, funcName) {
            jQuery.fn[funcName] = function (margin, value) {
                var chainable = arguments.length && (defaultExtra || typeof margin !== 'boolean'), extra = defaultExtra || (margin === true || value === true ? 'margin' : 'border');
                return access(this, function (elem, type, value) {
                    var doc;
                    if (jQuery.isWindow(elem)) {
                        return funcName.indexOf('outer') === 0 ? elem['inner' + name] : elem.document.documentElement['client' + name];
                    }
                    if (elem.nodeType === 9) {
                        doc = elem.documentElement;
                        return Math.max(elem.body['scroll' + name], doc['scroll' + name], elem.body['offset' + name], doc['offset' + name], doc['client' + name]);
                    }
                    return value === undefined ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra);
                }, type, chainable ? margin : undefined, chainable);
            };
        });
    });
    jQuery.fn.extend({
        bind: function (types, data, fn) {
            return this.on(types, null, data, fn);
        },
        unbind: function (types, fn) {
            return this.off(types, null, fn);
        },
        delegate: function (selector, types, data, fn) {
            return this.on(types, selector, data, fn);
        },
        undelegate: function (selector, types, fn) {
            return arguments.length === 1 ? this.off(selector, '**') : this.off(types, selector || '**', fn);
        }
    });
    jQuery.parseJSON = JSON.parse;
    if (typeof define === 'function' && define.amd) {
        define('jquery@3.1.1#dist/jquery', [], function () {
            return jQuery;
        });
    }
    var _jQuery = window.jQuery, _$ = window.$;
    jQuery.noConflict = function (deep) {
        if (window.$ === jQuery) {
            window.$ = _$;
        }
        if (deep && window.jQuery === jQuery) {
            window.jQuery = _jQuery;
        }
        return jQuery;
    };
    if (!noGlobal) {
        window.jQuery = window.$ = jQuery;
    }
    return jQuery;
}));
/*can-connect@1.3.8#can/super-map/super-map*/
define('can-connect@1.3.8#can/super-map/super-map', function (require, exports, module) {
    var connect = require('can-connect');
    var constructor = require('../../constructor/constructor');
    var canMap = require('../map/map');
    var canRef = require('../ref/ref');
    var constructorStore = require('../../constructor/store/store');
    var dataCallbacks = require('../../data/callbacks/callbacks');
    var callbacksCache = require('../../data/callbacks-cache/callbacks-cache');
    var combineRequests = require('../../data/combine-requests/combine-requests');
    var localCache = require('../../data/localstorage-cache/localstorage-cache');
    var dataParse = require('../../data/parse/parse');
    var dataUrl = require('../../data/url/url');
    var fallThroughCache = require('../../fall-through-cache/fall-through-cache');
    var realTime = require('../../real-time/real-time');
    var callbacksOnce = require('../../constructor/callbacks-once/callbacks-once');
    var $ = require('jquery');
    connect.superMap = function (options) {
        var behaviors = [
            constructor,
            canMap,
            canRef,
            constructorStore,
            dataCallbacks,
            combineRequests,
            dataParse,
            dataUrl,
            realTime,
            callbacksOnce
        ];
        if (typeof localStorage !== 'undefined') {
            if (!options.cacheConnection) {
                options.cacheConnection = connect([localCache], {
                    name: options.name + 'Cache',
                    idProp: options.idProp,
                    algebra: options.algebra
                });
            }
            behaviors.push(callbacksCache, fallThroughCache);
        }
        if ($ && $.ajax) {
            options.ajax = $.ajax;
        }
        return connect(behaviors, options);
    };
    module.exports = connect.superMap;
});
/*can-connect@1.3.8#can/tag/tag*/
define('can-connect@1.3.8#can/tag/tag', function (require, exports, module) {
    require('can-stache-bindings');
    var connect = require('can-connect');
    var compute = require('can-compute');
    var expression = require('can-stache/src/expression');
    var viewCallbacks = require('can-view-callbacks');
    var Observation = require('can-observation');
    var nodeLists = require('can-view-nodelist');
    var canEvent = require('can-event');
    var each = require('can-util/js/each/each');
    var domMutate = require('can-util/dom/mutate/mutate');
    var domData = require('can-util/dom/data/data');
    require('can-util/dom/events/removed/removed');
    var convertToValue = function (arg) {
        if (typeof arg === 'function') {
            return convertToValue(arg());
        } else {
            return arg;
        }
    };
    connect.tag = function (tagName, connection) {
        var removeBrackets = function (value, open, close) {
            open = open || '{';
            close = close || '}';
            if (value[0] === open && value[value.length - 1] === close) {
                return value.substr(1, value.length - 2);
            }
            return value;
        };
        viewCallbacks.tag(tagName, function (el, tagData) {
            var getList = el.getAttribute('getList') || el.getAttribute('get-list');
            var getInstance = el.getAttribute('get');
            var attrValue = getList || getInstance;
            var method = getList ? 'getList' : 'get';
            var attrInfo = expression.parse('tmp(' + removeBrackets(attrValue) + ')', { baseMethodType: 'Call' });
            var addedToPageData = false;
            var addToPageData = Observation.ignore(function (set, promise) {
                if (!addedToPageData) {
                    var root = tagData.scope.peek('%root') || tagData.scope.peek('@root');
                    if (root && root.pageData) {
                        if (method === 'get') {
                            set = connection.id(set);
                        }
                        root.pageData(connection.name, set, promise);
                    }
                }
                addedToPageData = true;
            });
            var request = compute(function () {
                var hash = {};
                if (typeof attrInfo.hash === 'object') {
                    each(attrInfo.hash, function (val, key) {
                        if (val && val.hasOwnProperty('get')) {
                            hash[key] = tagData.scope.read(val.get, {}).value;
                        } else {
                            hash[key] = val;
                        }
                    });
                } else if (typeof attrInfo.hash === 'function') {
                    var getHash = attrInfo.hash(tagData.scope, tagData.options, {});
                    each(getHash(), function (val, key) {
                        hash[key] = convertToValue(val);
                    });
                } else {
                    hash = attrInfo.argExprs.length ? attrInfo.argExprs[0].value(tagData.scope, tagData.options)() : {};
                }
                var promise = connection[method](hash);
                addToPageData(hash, promise);
                return promise;
            });
            domData.set.call(el, 'viewModel', request);
            var nodeList = nodeLists.register([], undefined, tagData.parentNodeList || true);
            var frag = tagData.subtemplate ? tagData.subtemplate(tagData.scope.add(request), tagData.options, nodeList) : document.createDocumentFragment();
            domMutate.appendChild.call(el, frag);
            nodeLists.update(nodeList, el.childNodes);
            canEvent.one.call(el, 'removed', function () {
                nodeLists.unregister(nodeList);
            });
        });
    };
    module.exports = connect.tag;
});
/*can-connect@1.3.8#can/base-map/base-map*/
define('can-connect@1.3.8#can/base-map/base-map', function (require, exports, module) {
    var connect = require('can-connect');
    var constructor = require('../../constructor/constructor');
    var canMap = require('../map/map');
    var canRef = require('../ref/ref');
    var constructorStore = require('../../constructor/store/store');
    var dataCallbacks = require('../../data/callbacks/callbacks');
    var callbacksCache = require('../../data/callbacks-cache/callbacks-cache');
    var dataParse = require('../../data/parse/parse');
    var dataUrl = require('../../data/url/url');
    var realTime = require('../../real-time/real-time');
    var callbacksOnce = require('../../constructor/callbacks-once/callbacks-once');
    var $ = require('jquery');
    connect.baseMap = function (options) {
        var behaviors = [
            constructor,
            canMap,
            canRef,
            constructorStore,
            dataCallbacks,
            dataParse,
            dataUrl,
            realTime,
            callbacksOnce
        ];
        if ($ && $.ajax) {
            options.ajax = $.ajax;
        }
        return connect(behaviors, options);
    };
    module.exports = connect.baseMap;
});
/*can-connect@1.3.8#all*/
define('can-connect@1.3.8#all', function (require, exports, module) {
    var connect = require('./can-connect');
    connect.cacheRequests = require('./cache-requests/cache-requests');
    connect.constructor = require('./constructor/constructor');
    connect.constructorCallbacksOnce = require('./constructor/callbacks-once/callbacks-once');
    connect.constructorStore = require('./constructor/store/store');
    connect.dataCallbacks = require('./data/callbacks/callbacks');
    connect.dataCallbacksCache = require('./data/callbacks-cache/callbacks-cache');
    connect.dataCombineRequests = require('./data/combine-requests/combine-requests');
    connect.dataLocalStorageCache = require('./data/localstorage-cache/localstorage-cache');
    connect.dataMemoryCache = require('./data/memory-cache/memory-cache');
    connect.dataParse = require('./data/parse/parse');
    connect.dataUrl = require('./data/url/url');
    connect.fallThroughCache = require('./fall-through-cache/fall-through-cache');
    connect.realTime = require('./real-time/real-time');
    connect.superMap = require('./can/super-map/super-map');
    connect.tag = require('./can/tag/tag');
    connect.baseMap = require('./can/base-map/base-map');
    module.exports = connect;
});
/*can-connect@1.3.8#core_test*/
define('can-connect@1.3.8#core_test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var connect = require('can-connect');
    var set = require('can-set');
    QUnit.module('can-connect/core test', {
        setup: function () {
        }
    });
    QUnit.test('Determine .id() from algebra (#82)', function () {
        var algebra = new set.Algebra(set.comparators.id('_id'));
        var connection = connect([], { algebra: algebra });
        QUnit.equal(connection.id({ _id: 'foo' }), 'foo', 'got id from algebra');
        QUnit.equal(connection.id({ _id: 1 }), 1, 'got id from algebra');
    });
    QUnit.test('Everything available at can-connect/all', function () {
        var all = require('can-connect/all');
        var expectedBehaviors = [
            'cacheRequests',
            'constructor',
            'constructorCallbacksOnce',
            'constructorStore',
            'dataCallbacks',
            'dataCallbacksCache',
            'dataCombineRequests',
            'dataLocalStorageCache',
            'dataMemoryCache',
            'dataParse',
            'dataUrl',
            'fallThroughCache',
            'realTime',
            'superMap',
            'tag',
            'baseMap'
        ];
        expectedBehaviors.forEach(function (behaviorName) {
            QUnit.ok(all[behaviorName], 'behavior in place: ' + behaviorName);
        });
    });
});
/*can-connect@1.3.8#cache-requests/cache-requests_test*/
define('can-connect@1.3.8#cache-requests/cache-requests_test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var cacheRequests = require('can-connect/cache-requests/');
    var memCache = require('can-connect/data/memory-cache/');
    var connect = require('can-connect');
    var map = [].map;
    var set = require('can-set');
    var getId = function (d) {
        return d.id;
    };
    QUnit.module('can-connect/cache-requests/', {
        setup: function () {
        }
    });
    QUnit.test('Get everything and all future requests should hit cache', function (assert) {
        var count = 0;
        var done = assert.async();
        var res = cacheRequests({
            getListData: function (params) {
                deepEqual(params, {}, 'called for everything');
                count++;
                equal(count, 1, 'only called once');
                return Promise.resolve([
                    {
                        id: 1,
                        type: 'critical',
                        due: 'today'
                    },
                    {
                        id: 2,
                        type: 'notcritical',
                        due: 'today'
                    },
                    {
                        id: 3,
                        type: 'critical',
                        due: 'yesterday'
                    },
                    { id: 4 },
                    {
                        id: 5,
                        type: 'critical'
                    },
                    {
                        id: 6,
                        due: 'yesterday'
                    }
                ]);
            },
            cacheConnection: memCache(connect.base({}))
        });
        res.getListData({}).then(function (list) {
            assert.deepEqual(map.call(list, getId), [
                1,
                2,
                3,
                4,
                5,
                6
            ]);
            return res.getListData({ type: 'critical' });
        }).then(function (list) {
            assert.deepEqual(map.call(list.data, getId), [
                1,
                3,
                5
            ]);
            return res.getListData({ due: 'today' });
        }).then(function (list) {
            deepEqual(map.call(list.data, getId), [
                1,
                2
            ]);
            done();
        }).then(null, function (error) {
            assert.ok(false, error);
        });
    });
    QUnit.test('Incrementally load data', function () {
        stop();
        var count = 0;
        var algebra = set.comparators.rangeInclusive('start', 'end');
        var behavior = cacheRequests({
            getListData: function (params) {
                equal(params.start, count * 10 + 1, 'start is right ' + params.start);
                count++;
                equal(params.end, count * 10, 'end is right ' + params.end);
                var items = [];
                for (var i = +params.start; i <= +params.end; i++) {
                    items.push({ id: i });
                }
                return Promise.resolve({ data: items });
            },
            algebra: algebra,
            cacheConnection: memCache(connect.base({ algebra: algebra }))
        });
        behavior.getListData({
            start: 1,
            end: 10
        }).then(function (listData) {
            var list = listData.data;
            equal(list.length, 10, 'got 10 items');
            equal(list[0].id, 1);
            equal(list[9].id, 10);
            behavior.getListData({
                start: 1,
                end: 20
            }).then(function (listData) {
                var list = listData.data;
                equal(list.length, 20, 'got 20 items');
                equal(list[0].id, 1, '0th object\'s id\'');
                equal(list[19].id, 20, '19th object\'s id');
                behavior.getListData({
                    start: 9,
                    end: 12
                }).then(function (listData) {
                    var list = listData.data;
                    equal(list.length, 4, 'got 4 items');
                    equal(list[0].id, 9);
                    equal(list[3].id, 12);
                    start();
                });
            });
        });
    });
});
/*can-connect@1.3.8#test-helpers*/
define('can-connect@1.3.8#test-helpers', function (require, exports, module) {
    module.exports = {
        makeStateChecker: function (QUnit, names) {
            return {
                check: function (value) {
                    var state = names.shift();
                    QUnit.equal(state, value, 'state check ' + state);
                    if (state !== value) {
                        QUnit.start();
                    }
                    return state;
                },
                get: function () {
                    return names[0];
                },
                next: function () {
                    return names.shift();
                },
                toString: function () {
                    return this.get();
                }
            };
        },
        later: function (fn) {
            return function () {
                setTimeout(fn, 1);
            };
        },
        logErrorAndStart: function (e) {
            ok(false, 'Error ' + e);
            start();
        },
        getId: function (o) {
            return o.id;
        },
        asyncResolve: function (data) {
            var def = new Promise(function (resolve) {
                setTimeout(function () {
                    resolve(data);
                }, 1);
            });
            return def;
        },
        asyncReject: function (data) {
            var def = new Promise(function (resolve, reject) {
                setTimeout(function () {
                    reject(data);
                }, 1);
            });
            return def;
        }
    };
});
/*can-connect@1.3.8#can/map/map_test*/
define('can-connect@1.3.8#can/map/map_test', function (require, exports, module) {
    var set = require('can-set');
    var $ = require('jquery');
    var Map = require('can-map');
    var List = require('can-list');
    var compute = require('can-compute');
    var constructor = require('can-connect/constructor/');
    var canMap = require('can-connect/can/map/');
    var constructorStore = require('can-connect/constructor/store/');
    var dataCallbacks = require('can-connect/data/callbacks/');
    var callbacksCache = require('can-connect/data/callbacks-cache/');
    var combineRequests = require('can-connect/data/combine-requests/');
    var localCache = require('can-connect/data/localstorage-cache/');
    var dataParse = require('can-connect/data/parse/');
    var dataUrl = require('can-connect/data/url/');
    var fallThroughCache = require('can-connect/fall-through-cache/');
    var realTime = require('can-connect/real-time/');
    var connect = require('can-connect/can-connect');
    var QUnit = require('steal-qunit');
    var fixture = require('can-fixture');
    var testHelpers = require('can-connect/test-helpers');
    var map = [].map;
    var assign = require('can-util/js/assign/assign');
    var later = testHelpers.later;
    var logErrorAndStart = function (e) {
        ok(false, 'Error ' + e);
        start();
    };
    QUnit.module('can-connect/can/map/map', {
        setup: function () {
            var Todo = Map.extend({});
            var TodoList = List.extend({ Map: Todo });
            this.Todo = Todo;
            this.TodoList = TodoList;
            var cacheConnection = connect([localCache], { name: 'todos' });
            cacheConnection.clear();
            this.cacheConnection = cacheConnection;
            this.Todo = Todo;
            this.todoConnection = connect([
                constructor,
                canMap,
                constructorStore,
                dataCallbacks,
                callbacksCache,
                combineRequests,
                dataParse,
                dataUrl,
                fallThroughCache,
                realTime
            ], {
                url: '/services/todos',
                cacheConnection: cacheConnection,
                Map: Todo,
                List: TodoList,
                ajax: $.ajax
            });
        }
    });
    QUnit.test('real-time super model', function () {
        var firstItems = [
            {
                id: 0,
                type: 'important'
            },
            {
                id: 1,
                type: 'important'
            }
        ];
        var secondItems = [
            {
                id: 2,
                due: 'today'
            },
            {
                id: 3,
                due: 'today'
            }
        ];
        var state = testHelpers.makeStateChecker(QUnit, [
            'getListData-important',
            'getListData-today',
            'createData-today+important',
            'updateData-important',
            'updateData-today',
            'destroyData-important-1',
            'getListData-today-2'
        ]);
        stop();
        fixture({
            'GET /services/todos': function () {
                if (state.get() === 'getListData-important') {
                    state.next();
                    return { data: firstItems.slice(0) };
                } else if (state.get() === 'getListData-today') {
                    state.next();
                    return { data: secondItems.slice(0) };
                } else {
                    state.check('getListData-today-2');
                    return { data: secondItems.slice(1) };
                }
            },
            'POST /services/todos': function (request) {
                if (state.get() === 'createData-today+important') {
                    state.next();
                    return assign({ id: 10 }, request.data);
                }
            },
            'PUT /services/todos/{id}': function (request) {
                if (state.get() === 'updateData-important' || state.get() === 'updateData-today') {
                    state.next();
                    return assign({}, request.data);
                } else {
                    ok(false, 'bad state!');
                    start();
                }
            },
            'DELETE /services/todos/{id}': function (request) {
                if (state.get() === 'destroyData-important-1') {
                    state.next();
                    return assign({ destroyed: 1 }, request.data);
                } else {
                    ok(false, 'bad state!');
                    start();
                }
            }
        });
        function checkCache(name, set, expectData, next) {
            cacheConnection.getListData(set).then(function (data) {
                deepEqual(map.call(data.data, testHelpers.getId), map.call(expectData, testHelpers.getId), name);
                setTimeout(next, 1);
            });
        }
        var connection = this.todoConnection, cacheConnection = this.cacheConnection, Todo = this.Todo;
        var importantList, todayList, bindFunc = function () {
            };
        Promise.all([
            connection.getList({ type: 'important' }),
            connection.getList({ due: 'today' })
        ]).then(function (result) {
            importantList = result[0];
            todayList = result[1];
            importantList.bind('length', bindFunc);
            todayList.bind('length', bindFunc);
            setTimeout(createImportantToday, 1);
        }, logErrorAndStart);
        var created;
        function createImportantToday() {
            connection.save(new Todo({
                type: 'important',
                due: 'today',
                createId: 1
            })).then(function (task) {
                created = task;
                setTimeout(checkLists, 1);
            }, logErrorAndStart);
        }
        function checkLists() {
            ok(importantList.indexOf(created) >= 0, 'in important');
            ok(todayList.indexOf(created) >= 0, 'in today');
            checkCache('cache looks right', { type: 'important' }, firstItems.concat(created.serialize()), serverSideDuplicateCreate);
        }
        function serverSideDuplicateCreate() {
            connection.createInstance({
                id: 10,
                due: 'today',
                createdId: 1,
                type: 'important'
            }).then(function (createdInstance) {
                equal(createdInstance, created, 'created instance returned from SSE is the same as what we created earlier');
                ok(importantList.indexOf(created) >= 0, 'in important');
                ok(todayList.indexOf(created) >= 0, 'in today');
                equal(importantList.length, 3, 'items stays the same');
                checkCache('cache looks right', { type: 'important' }, firstItems.concat(created.serialize()), serverSideCreate);
            });
        }
        var serverCreatedInstance;
        function serverSideCreate() {
            connection.createInstance({
                id: 11,
                due: 'today',
                createdId: 2,
                type: 'important'
            }).then(function (createdInstance) {
                serverCreatedInstance = createdInstance;
                ok(importantList.indexOf(createdInstance) >= 0, 'in important');
                ok(todayList.indexOf(createdInstance) >= 0, 'in today');
                checkCache('cache looks right afer SS create', { type: 'important' }, firstItems.concat(created.serialize(), serverCreatedInstance.serialize()), update1);
            });
        }
        function update1() {
            created.removeAttr('due');
            connection.save(created).then(later(checkLists2), logErrorAndStart);
        }
        function checkLists2() {
            ok(importantList.indexOf(created) >= 0, 'still in important');
            equal(todayList.indexOf(created), -1, 'removed from today');
            update2();
        }
        function update2() {
            created.removeAttr('type');
            created.attr('due', 'today');
            connection.save(created).then(later(checkLists3), logErrorAndStart);
        }
        function checkLists3() {
            equal(importantList.indexOf(created), -1, 'removed from important');
            ok(todayList.indexOf(created) >= 1, 'added to today');
            checkCache('cache looks right after update2', { type: 'important' }, firstItems.concat(serverCreatedInstance.serialize()), serverSideUpdate);
        }
        function serverSideUpdate() {
            connection.updateInstance({
                type: 'important',
                due: 'today',
                createId: 1,
                id: 10
            }).then(function (instance) {
                equal(created, instance);
                ok(importantList.indexOf(created) >= 0, 'in important');
                ok(todayList.indexOf(created) >= 0, 'in today');
                checkCache('cache looks right afer SS update', { type: 'important' }, importantList.serialize(), destroyItem);
            });
        }
        var firstImportant;
        function destroyItem() {
            firstImportant = importantList[0];
            connection.destroy(firstImportant).then(later(checkLists4), logErrorAndStart);
        }
        function checkLists4() {
            equal(importantList.indexOf(firstImportant), -1, 'in important');
            checkCache('cache looks right afer destroy', { type: 'important' }, importantList.serialize(), serverSideDestroy);
        }
        function serverSideDestroy() {
            connection.destroyInstance({
                type: 'important',
                due: 'today',
                createId: 1,
                id: 10
            }).then(function (instance) {
                equal(instance, created, 'got back deleted instance');
                equal(importantList.indexOf(created), -1, 'still in important');
                equal(todayList.indexOf(created), -1, 'removed from today');
                checkCache('cache looks right afer ss destroy', { type: 'important' }, importantList.serialize(), function () {
                    checkCache('cache looks right afer SS destroy', { due: 'today' }, todayList.serialize(), getListDueTodayAgainstCache);
                });
            });
        }
        function getListDueTodayAgainstCache() {
            connection.getList({ due: 'today' }).then(function (updatedTodayList) {
                var added = serverCreatedInstance.serialize();
                equal(todayList, updatedTodayList, 'same todo list returned');
                deepEqual(updatedTodayList.serialize(), secondItems.concat([added]), 'got initial items from cache');
                var batchNum;
                todayList.bind('length', function (ev) {
                    if (!ev.batchNum || ev.batchNum !== batchNum) {
                        deepEqual(updatedTodayList.serialize(), secondItems.slice(1), 'updated cache');
                        start();
                        batchNum = ev.batchNum;
                    }
                });
            });
        }
    });
    test('isSaving and isDestroying', function () {
        stop();
        fixture({
            'POST /services/todos': function (request) {
                return assign({ id: 10 }, request.data);
            },
            'PUT /services/todos/{id}': function (request) {
                return assign({}, request.data);
            },
            'DELETE /services/todos/{id}': function (request) {
                return assign({ destroyed: 1 }, request.data);
            }
        });
        var todo = new this.Todo({ foo: 'bar' });
        var todoConnection = this.todoConnection;
        var state = 'hydrated', isSavingCalls = 0, isDestroyingCalls = 0;
        var isSaving = compute(function () {
            return todo.isSaving();
        });
        var isDestroying = compute(function () {
            return todo.isDestroying();
        });
        isSaving.bind('change', function (ev, newVal, oldVal) {
            isSavingCalls++;
            if (isSavingCalls === 1) {
                equal(state, 'hydrated');
                equal(newVal, true);
                equal(todo.isNew(), true);
            } else if (isSavingCalls === 2) {
                equal(state, 'hydrated');
                equal(newVal, false);
                equal(todo.isNew(), false);
            } else if (isSavingCalls === 3) {
                equal(state, 'created');
                equal(newVal, true);
                equal(todo.isNew(), false);
            } else if (isSavingCalls === 4) {
                equal(state, 'created');
                equal(newVal, false);
            } else {
                ok(false, 'extra saving call');
            }
        });
        isDestroying.bind('change', function (ev, newVal, oldVal) {
            isDestroyingCalls++;
            if (isSavingCalls === 1) {
                equal(state, 'updated');
                equal(newVal, true);
            } else if (isSavingCalls === 2) {
                equal(state, 'updated');
                equal(newVal, false);
            }
        });
        todoConnection.save(todo).then(function () {
            state = 'created';
            equal(todo.isSaving(), false, 'isSaving is false');
            todoConnection.save(todo).then(function () {
                state = 'updated';
                equal(todo.isSaving(), false, 'isSaving is false');
                todoConnection.destroy(todo).then(function () {
                    equal(todo.isDestroying(), false, 'isDestroying is false');
                    start();
                });
                equal(todo.isSaving(), false, 'isSaving is false');
                equal(todo.isDestroying(), true, 'isDestroying is true');
            });
            equal(todo.isSaving(), true, 'isSaving is true');
        });
        equal(todo.isSaving(), true, 'isSaving is true');
    });
    test('listSet works', function () {
        fixture({
            'GET /services/todos': function () {
                return { data: [] };
            }
        });
        var Todo = this.Todo;
        var TodoList = this.TodoList;
        var todoConnection = this.todoConnection;
        stop();
        Promise.all([
            todoConnection.getList({ foo: 'bar' }).then(function (list) {
                deepEqual(todoConnection.listSet(list), { foo: 'bar' });
            }),
            Todo.getList({ zed: 'ted' }).then(function (list) {
                deepEqual(todoConnection.listSet(list), { zed: 'ted' });
            })
        ]).then(function () {
            var list = new TodoList({ 'zak': 'ack' });
            deepEqual(todoConnection.listSet(list), { zak: 'ack' });
            start();
        });
    });
    test('findAll and findOne alias', function () {
        fixture({
            'GET /services/todos': function () {
                return {
                    data: [{
                            id: 1,
                            name: 'findAll'
                        }]
                };
            },
            'GET /services/todos/{id}': function () {
                return {
                    id: 2,
                    name: 'findOne'
                };
            }
        });
        var Todo = this.Todo;
        stop();
        Promise.all([
            Todo.findOne({ id: 1 }).then(function (todo) {
                equal(todo.name, 'findOne');
            }),
            Todo.findAll({}).then(function (todos) {
                equal(todos.length, 1);
                equal(todos[0].name, 'findAll');
            })
        ]).then(function () {
            start();
        });
    });
    QUnit.test('reads id from set algebra (#82)', function () {
        var Todo = Map.extend({});
        var TodoList = List.extend({ Map: Todo });
        var todoConnection = connect([
            constructor,
            canMap,
            constructorStore,
            dataCallbacks,
            callbacksCache,
            combineRequests,
            dataParse,
            dataUrl,
            fallThroughCache,
            realTime
        ], {
            url: '/services/todos',
            Map: Todo,
            List: TodoList,
            ajax: $.ajax,
            algebra: new set.Algebra(set.comparators.id('_id'))
        });
        QUnit.equal(todoConnection.id(new Todo({ _id: 5 })), 5, 'got the right id');
    });
});
/*can-connect@1.3.8#can/map/define-map-test*/
define('can-connect@1.3.8#can/map/define-map-test', function (require, exports, module) {
    var set = require('can-set');
    var $ = require('jquery');
    var Map = require('can-define/map/map');
    var List = require('can-define/list/list');
    var compute = require('can-compute');
    var canLog = require('can-util/js/log/log');
    var constructor = require('can-connect/constructor/');
    var canMap = require('can-connect/can/map/');
    var canRef = require('can-connect/can/ref/');
    var constructorStore = require('can-connect/constructor/store/');
    var dataCallbacks = require('can-connect/data/callbacks/');
    var callbacksCache = require('can-connect/data/callbacks-cache/');
    var combineRequests = require('can-connect/data/combine-requests/');
    var localCache = require('can-connect/data/localstorage-cache/');
    var dataParse = require('can-connect/data/parse/');
    var dataUrl = require('can-connect/data/url/');
    var fallThroughCache = require('can-connect/fall-through-cache/');
    var realTime = require('can-connect/real-time/');
    var connect = require('can-connect/can-connect');
    var QUnit = require('steal-qunit');
    var fixture = require('can-fixture');
    var testHelpers = require('can-connect/test-helpers');
    var map = [].map;
    var assign = require('can-util/js/assign/assign');
    var later = testHelpers.later;
    var logErrorAndStart = function (e) {
        ok(false, 'Error ' + e);
        start();
    };
    var cleanUndefineds = function (obj) {
        if (Array.isArray(obj)) {
            return obj.map(cleanUndefineds);
        } else {
            var res = {};
            for (var prop in obj) {
                if (obj[prop] !== undefined) {
                    res[prop] = obj[prop];
                }
            }
            return res;
        }
    };
    QUnit.module('can-connect/can/map/map with define', {
        setup: function () {
            var Todo = Map.extend({
                id: '*',
                name: '*',
                type: '*',
                due: '*',
                createdId: '*'
            });
            var TodoList = List.extend({ '*': Todo });
            this.Todo = Todo;
            this.TodoList = TodoList;
            var cacheConnection = connect([localCache], { name: 'todos' });
            cacheConnection.clear();
            this.cacheConnection = cacheConnection;
            this.Todo = Todo;
            this.todoConnection = connect([
                constructor,
                canMap,
                constructorStore,
                dataCallbacks,
                callbacksCache,
                combineRequests,
                dataParse,
                dataUrl,
                fallThroughCache,
                realTime
            ], {
                url: '/services/todos',
                cacheConnection: cacheConnection,
                Map: Todo,
                List: TodoList,
                ajax: $.ajax
            });
        }
    });
    QUnit.test('real-time super model', function () {
        var firstItems = [
            {
                id: 0,
                type: 'important'
            },
            {
                id: 1,
                type: 'important'
            }
        ];
        var secondItems = [
            {
                id: 2,
                due: 'today'
            },
            {
                id: 3,
                due: 'today'
            }
        ];
        var state = testHelpers.makeStateChecker(QUnit, [
            'getListData-important',
            'getListData-today',
            'createData-today+important',
            'updateData-important',
            'updateData-today',
            'destroyData-important-1',
            'getListData-today-2'
        ]);
        stop();
        fixture({
            'GET /services/todos': function () {
                if (state.get() === 'getListData-important') {
                    state.next();
                    return { data: firstItems.slice(0) };
                } else if (state.get() === 'getListData-today') {
                    state.next();
                    return { data: secondItems.slice(0) };
                } else {
                    state.check('getListData-today-2');
                    return { data: secondItems.slice(1) };
                }
            },
            'POST /services/todos': function (request) {
                if (state.get() === 'createData-today+important') {
                    state.next();
                    return assign({ id: 10 }, request.data);
                }
            },
            'PUT /services/todos/{id}': function (request) {
                if (state.get() === 'updateData-important' || state.get() === 'updateData-today') {
                    state.next();
                    return assign({}, request.data);
                } else {
                    ok(false, 'bad state!');
                    start();
                }
            },
            'DELETE /services/todos/{id}': function (request) {
                if (state.get() === 'destroyData-important-1') {
                    state.next();
                    return assign({ destroyed: 1 }, request.data);
                }
            }
        });
        function checkCache(name, set, expectData, next) {
            cacheConnection.getListData(set).then(function (data) {
                deepEqual(map.call(data.data, testHelpers.getId), map.call(expectData, testHelpers.getId), name);
                setTimeout(next, 1);
            });
        }
        var connection = this.todoConnection, cacheConnection = this.cacheConnection, Todo = this.Todo;
        var importantList, todayList, bindFunc = function () {
                canLog.log('length changing');
            };
        Promise.all([
            connection.getList({ type: 'important' }),
            connection.getList({ due: 'today' })
        ]).then(function (result) {
            importantList = result[0];
            todayList = result[1];
            importantList.bind('length', bindFunc);
            todayList.bind('length', bindFunc);
            setTimeout(createImportantToday, 1);
        }, logErrorAndStart);
        var created;
        function createImportantToday() {
            connection.save(new Todo({
                type: 'important',
                due: 'today',
                createId: 1
            })).then(function (task) {
                created = task;
                task.bind('type', bindFunc);
                setTimeout(checkLists, 1);
            }, logErrorAndStart);
        }
        function checkLists() {
            ok(importantList.indexOf(created) >= 0, 'in important');
            ok(todayList.indexOf(created) >= 0, 'in today');
            checkCache('cache looks right', { type: 'important' }, firstItems.concat(created.serialize()), serverSideDuplicateCreate);
        }
        function serverSideDuplicateCreate() {
            connection.createInstance({
                id: 10,
                due: 'today',
                createdId: 1,
                type: 'important'
            }).then(function (createdInstance) {
                equal(createdInstance, created, 'created instance returned from SSE is the same as what we created earlier');
                ok(importantList.indexOf(created) >= 0, 'in important');
                ok(todayList.indexOf(created) >= 0, 'in today');
                equal(importantList.length, 3, 'items stays the same');
                checkCache('cache looks right', { type: 'important' }, firstItems.concat(created.serialize()), serverSideCreate);
            });
        }
        var serverCreatedInstance;
        function serverSideCreate() {
            connection.createInstance({
                id: 11,
                due: 'today',
                createdId: 2,
                type: 'important'
            }).then(function (createdInstance) {
                serverCreatedInstance = createdInstance;
                ok(importantList.indexOf(createdInstance) >= 0, 'ss in important');
                ok(todayList.indexOf(createdInstance) >= 0, 'ss in today');
                checkCache('cache looks right afer SS create', { type: 'important' }, firstItems.concat(created.serialize(), serverCreatedInstance.serialize()), update1);
            });
        }
        function update1() {
            created.due = undefined;
            connection.save(created).then(later(checkLists2), logErrorAndStart);
        }
        function checkLists2() {
            ok(importantList.indexOf(created) >= 0, 'still in important');
            equal(todayList.indexOf(created), -1, 'removed from today');
            update2();
        }
        function update2() {
            created.type = undefined;
            created.due = 'today';
            connection.save(created).then(later(checkLists3), logErrorAndStart);
        }
        function checkLists3() {
            equal(importantList.indexOf(created), -1, 'removed from important');
            ok(todayList.indexOf(created) >= 1, 'added to today');
            checkCache('cache looks right after update2', { type: 'important' }, firstItems.concat(serverCreatedInstance.serialize()), serverSideUpdate);
        }
        function serverSideUpdate() {
            connection.updateInstance({
                type: 'important',
                due: 'today',
                createId: 1,
                id: 10
            }).then(function (instance) {
                equal(created, instance);
                ok(importantList.indexOf(created) >= 0, 'in important');
                ok(todayList.indexOf(created) >= 0, 'in today');
                checkCache('cache looks right afer SS update', { type: 'important' }, importantList.serialize(), destroyItem);
            });
        }
        var firstImportant;
        function destroyItem() {
            firstImportant = importantList[0];
            connection.destroy(firstImportant).then(later(checkLists4), logErrorAndStart);
        }
        function checkLists4() {
            equal(importantList.indexOf(firstImportant), -1, 'in important');
            checkCache('cache looks right afer destroy', { type: 'important' }, importantList.serialize(), serverSideDestroy);
        }
        function serverSideDestroy() {
            connection.destroyInstance({
                type: 'important',
                due: 'today',
                createId: 1,
                id: 10
            }).then(function (instance) {
                equal(instance, created, 'got back deleted instance');
                equal(importantList.indexOf(created), -1, 'even still in important');
                equal(todayList.indexOf(created), -1, 'removed from today');
                checkCache('cache looks right afer ss destroy', { type: 'important' }, importantList.serialize(), function () {
                    checkCache('cache looks right afer SS destroy', { due: 'today' }, todayList.serialize(), getListDueTodayAgainstCache);
                });
            });
        }
        function getListDueTodayAgainstCache() {
            connection.getList({ due: 'today' }).then(function (updatedTodayList) {
                var added = serverCreatedInstance.serialize();
                equal(todayList, updatedTodayList, 'same todo list returned');
                deepEqual(cleanUndefineds(updatedTodayList.serialize()), cleanUndefineds(secondItems.concat([added])), 'got initial items from cache');
                var batchNum;
                todayList.bind('length', function (ev) {
                    if (!ev.batchNum || ev.batchNum !== batchNum) {
                        deepEqual(cleanUndefineds(updatedTodayList.serialize()), secondItems.slice(1), 'updated cache');
                        start();
                        batchNum = ev.batchNum;
                    }
                });
            });
        }
    });
    test('isSaving and isDestroying', function () {
        stop();
        fixture({
            'POST /services/todos': function (request) {
                return assign({ id: 10 }, request.data);
            },
            'PUT /services/todos/{id}': function (request) {
                return assign({}, request.data);
            },
            'DELETE /services/todos/{id}': function (request) {
                return assign({ destroyed: 1 }, request.data);
            }
        });
        var todo = new this.Todo({ foo: 'bar' });
        var todoConnection = this.todoConnection;
        var state = 'hydrated', isSavingCalls = 0, isDestroyingCalls = 0;
        var isSaving = compute(function () {
            return todo.isSaving();
        });
        var isDestroying = compute(function () {
            return todo.isDestroying();
        });
        isSaving.bind('change', function (ev, newVal, oldVal) {
            isSavingCalls++;
            if (isSavingCalls === 1) {
                equal(state, 'hydrated', 'hydrated call');
                equal(newVal, true, 'is saving');
                equal(todo.isNew(), true, 'is new');
            } else if (isSavingCalls === 2) {
                equal(state, 'hydrated', 'still hydrated but no longer saving');
                equal(newVal, false);
                equal(todo.isNew(), false);
            } else if (isSavingCalls === 3) {
                equal(state, 'created');
                equal(newVal, true);
                equal(todo.isNew(), false);
            } else if (isSavingCalls === 4) {
                equal(state, 'created');
                equal(newVal, false);
            } else {
                ok(false, 'extra saving call');
            }
        });
        isDestroying.bind('change', function (ev, newVal, oldVal) {
            isDestroyingCalls++;
            if (isSavingCalls === 1) {
                equal(state, 'updated');
                equal(newVal, true);
            } else if (isSavingCalls === 2) {
                equal(state, 'updated');
                equal(newVal, false);
            }
        });
        todoConnection.save(todo).then(function () {
            state = 'created';
            equal(todo.isSaving(), false, 'isSaving is false');
            todoConnection.save(todo).then(function () {
                state = 'updated';
                equal(todo.isSaving(), false, 'isSaving is false');
                todoConnection.destroy(todo).then(function () {
                    equal(todo.isDestroying(), false, 'isDestroying is false');
                    start();
                });
                equal(todo.isSaving(), false, 'isSaving is false');
                equal(todo.isDestroying(), true, 'isDestroying is true');
            });
            equal(todo.isSaving(), true, 'isSaving is true');
        });
        equal(todo.isSaving(), true, 'isSaving is true');
    });
    test('listSet works', function () {
        fixture({
            'GET /services/todos': function () {
                return { data: [] };
            }
        });
        var Todo = this.Todo;
        var TodoList = this.TodoList;
        var todoConnection = this.todoConnection;
        stop();
        Promise.all([
            todoConnection.getList({ foo: 'bar' }).then(function (list) {
                deepEqual(todoConnection.listSet(list), { foo: 'bar' });
            }),
            Todo.getList({ zed: 'ted' }).then(function (list) {
                deepEqual(todoConnection.listSet(list), { zed: 'ted' });
            })
        ]).then(function () {
            var list = new TodoList({ 'zak': 'ack' });
            deepEqual(todoConnection.listSet(list), { zak: 'ack' });
            start();
        });
    });
    test('findAll and findOne alias', function () {
        fixture({
            'GET /services/todos': function () {
                return {
                    data: [{
                            id: 1,
                            name: 'findAll'
                        }]
                };
            },
            'GET /services/todos/{id}': function () {
                return {
                    id: 2,
                    name: 'findOne'
                };
            }
        });
        var Todo = this.Todo;
        stop();
        Promise.all([
            Todo.findOne({ id: 1 }).then(function (todo) {
                equal(todo.name, 'findOne');
            }),
            Todo.findAll({}).then(function (todos) {
                equal(todos.length, 1);
                equal(todos[0].name, 'findAll');
            })
        ]).then(function () {
            start();
        });
    });
    QUnit.test('reads id from set algebra (#82)', function () {
        var Todo = Map.extend({ _id: '*' });
        var TodoList = List.extend({ '*': Todo });
        var todoConnection = connect([
            constructor,
            canMap,
            constructorStore,
            dataCallbacks,
            callbacksCache,
            combineRequests,
            dataParse,
            dataUrl,
            fallThroughCache,
            realTime
        ], {
            url: '/services/todos',
            Map: Todo,
            List: TodoList,
            ajax: $.ajax,
            algebra: new set.Algebra(set.comparators.id('_id'))
        });
        QUnit.equal(todoConnection.id(new Todo({ _id: 5 })), 5, 'got the right id');
    });
});
/*can-connect@1.3.8#can/model/model*/
define('can-connect@1.3.8#can/model/model', function (require, exports, module) {
    var $ = require('jquery'), connect = require('can-connect'), persist = require('../../data/url/url'), constructor = require('../../constructor/constructor'), instanceStore = require('../../constructor/store/store'), parseData = require('../../data/parse/parse'), CanMap = require('can-map'), CanList = require('can-list'), Observation = require('can-observation'), canEvent = require('can-event'), ns = require('can-namespace');
    var each = require('can-util/js/each/each');
    var dev = require('can-util/js/dev/dev');
    var makeArray = require('can-util/js/make-array/make-array');
    var types = require('can-types');
    var isPlainObject = require('can-util/js/is-plain-object/is-plain-object');
    var callCanReadingOnIdRead = true;
    var getBaseValue = function (prop) {
        if (typeof prop === 'function' && 'base' in prop) {
            return prop.base;
        } else {
            return prop;
        }
    };
    var resolveSingleExport = function (originalPromise) {
        var promise = originalPromise.then(function (first) {
            return first;
        });
        promise.abort = function () {
            originalPromise.abort();
        };
        return promise;
    };
    var mapBehavior = connect.behavior(function (baseConnection) {
        var behavior = {
            id: function (inst) {
                var idProp = inst.constructor.id || 'id';
                if (inst instanceof CanMap) {
                    if (callCanReadingOnIdRead) {
                        Observation.add(inst, idProp);
                    }
                    return inst.__get(idProp);
                } else {
                    if (callCanReadingOnIdRead) {
                        return inst[idProp];
                    } else {
                        return Observation.ignore(function () {
                            return inst[idProp];
                        });
                    }
                }
            },
            listSet: function () {
                return undefined;
            },
            idProp: baseConnection.constructor.id || 'id',
            serializeInstance: function (instance) {
                return instance.serialize();
            },
            findAll: function (params, success, error) {
                var promise = resolveSingleExport(baseConnection.getList.call(this, params));
                promise.then(success, error);
                return promise;
            },
            findOne: function (params, success, error) {
                var promise = resolveSingleExport(baseConnection.get.call(this, params));
                promise.then(success, error);
                return promise;
            },
            parseInstanceData: function (props) {
                if (typeof this.parseModel === 'function') {
                    return this.parseModel.apply(this.constructor, arguments);
                } else {
                    return baseConnection.parseInstanceData.apply(baseConnection, arguments);
                }
            },
            parseListData: function (props) {
                if (typeof this.parseModels === 'function') {
                    return this.parseModels.apply(this.constructor, arguments);
                } else {
                    return baseConnection.parseListData.apply(baseConnection, arguments);
                }
            }
        };
        each([
            'created',
            'updated',
            'destroyed'
        ], function (funcName) {
            behavior[funcName + 'Instance'] = function (instance, attrs) {
                var constructor = instance.constructor;
                if (attrs && typeof attrs === 'object') {
                    instance.attr(typeof attrs.attr === 'function' ? attrs.attr() : attrs, this.constructor.removeAttr || false);
                }
                canEvent.dispatch.call(instance, {
                    type: funcName,
                    target: instance
                });
                canEvent.dispatch.call(constructor, funcName, [instance]);
            };
        });
        return behavior;
    });
    var CanModel = CanMap.extend({
        setup: function (base, fullName, staticProps, protoProps) {
            if (typeof fullName !== 'string') {
                protoProps = staticProps;
                staticProps = fullName;
            }
            if (!protoProps) {
                protoProps = staticProps;
            }
            this.store = {};
            CanMap.setup.apply(this, arguments);
            if (!CanModel) {
                return;
            }
            if (staticProps && staticProps.List) {
                this.List = staticProps.List;
                this.List.Map = this;
            } else {
                this.List = base.List.extend({ Map: this }, {});
            }
            var self = this;
            var staticMethods = [
                'findAll',
                'findOne',
                'create',
                'update',
                'destroy'
            ];
            var parseMethods = {
                parseModel: 'parseInstanceData',
                parseModels: 'parseListData'
            };
            var connectionOptions = {
                url: {
                    getListData: getBaseValue(this.findAll),
                    getData: getBaseValue(this.findOne),
                    createData: getBaseValue(this.create),
                    updateData: getBaseValue(this.update),
                    destroyData: getBaseValue(this.destroy),
                    resource: this.resource
                },
                idProp: this.id,
                parseInstanceProp: typeof getBaseValue(this.parseModel) === 'string' ? getBaseValue(this.parseModel) : undefined,
                parseListProp: typeof getBaseValue(this.parseModels) === 'string' ? getBaseValue(this.parseModels) : undefined,
                instance: function (values) {
                    return new self(values);
                },
                list: function (listData) {
                    var list = new self.List(listData.data);
                    each(listData, function (val, prop) {
                        if (prop !== 'data') {
                            list.attr(prop, val);
                        }
                    });
                    return list;
                },
                constructor: this,
                parseModel: getBaseValue(this.parseModel),
                parseModels: getBaseValue(this.parseModels),
                ajax: function () {
                    var promiseLike = $.ajax.apply($, arguments);
                    return new Promise(function (resolve, reject) {
                        promiseLike.then(resolve, reject);
                    });
                }
            };
            this.connection = mapBehavior(instanceStore(constructor(parseData(persist(connectionOptions)))));
            this.store = this.connection.instanceStore;
            each(staticMethods, function (name) {
                if (self.connection[name]) {
                    var fn = self.connection[name].bind(self.connection);
                    fn.base = self[name];
                    CanMap._overwrite(self, base, name, fn);
                }
            });
            each(parseMethods, function (connectionName, name) {
                var fn = self.connection[connectionName].bind(self.connection);
                fn.base = self[name];
                CanMap._overwrite(self, base, name, fn);
            });
        },
        models: function (raw, oldList) {
            var args = makeArray(arguments);
            args[0] = this.connection.parseListData.apply(this.connection, arguments);
            var list = this.connection.hydrateList.apply(this.connection, args);
            if (oldList instanceof CanList) {
                return oldList.replace(list);
            } else {
                return list;
            }
        },
        model: function (raw) {
            var args = makeArray(arguments);
            args[0] = this.connection.parseInstanceData.apply(this.connection, arguments);
            var instance = this.connection.hydrateInstance.apply(this.connection, arguments);
            return instance;
        }
    }, {
        isNew: function () {
            var id = this.constructor.connection.id(this);
            return !(id || id === 0);
        },
        save: function (success, error) {
            var promise = resolveSingleExport(this.constructor.connection.save(this));
            promise.then(success, error);
            return promise;
        },
        destroy: function (success, error) {
            var promise;
            if (this.isNew()) {
                promise = Promise.resolve(this);
                this.constructor.connection.destroyedInstance(this, {});
            } else {
                promise = this.constructor.connection.destroy(this);
            }
            promise.then(success, error);
            return promise;
        },
        _eventSetup: function () {
            callCanReadingOnIdRead = false;
            this.constructor.connection.addInstanceReference(this);
            callCanReadingOnIdRead = true;
            return CanMap.prototype._eventSetup.apply(this, arguments);
        },
        _eventTeardown: function () {
            callCanReadingOnIdRead = false;
            this.constructor.connection.deleteInstanceReference(this);
            callCanReadingOnIdRead = true;
            return CanMap.prototype._eventTeardown.apply(this, arguments);
        },
        ___set: function (prop, val) {
            CanMap.prototype.___set.call(this, prop, val);
            if (prop === (this.constructor.id || 'id') && this._bindings) {
                this.constructor.connection.addInstanceReference(this);
            }
        }
    });
    CanModel.List = CanList.extend({
        _bubbleRule: function (eventName, list) {
            var bubbleRules = CanList._bubbleRule(eventName, list);
            bubbleRules.push('destroyed');
            return bubbleRules;
        }
    }, {
        setup: function (params) {
            if (isPlainObject(params) && !Array.isArray(params)) {
                CanList.prototype.setup.apply(this);
                this.replace(types.isPromise(params) ? params : this.constructor.Map.findAll(params));
            } else {
                CanList.prototype.setup.apply(this, arguments);
            }
            this._init = 1;
            this.bind('destroyed', this._destroyed.bind(this));
            delete this._init;
        },
        _destroyed: function (ev, attr) {
            if (/\w+/.test(attr)) {
                var index;
                while ((index = this.indexOf(ev.target)) > -1) {
                    this.splice(index, 1);
                }
            }
        }
    });
    if (!ns.Model) {
        ns.Model = CanModel;
    }
    module.exports = CanModel;
});
/*can-connect@1.3.8#can/model/model_test*/
define('can-connect@1.3.8#can/model/model_test', function (require, exports, module) {
    var CanModel = require('can-connect/can/model/');
    var QUnit = require('steal-qunit');
    var fixture = require('can-fixture');
    var canFixture = fixture;
    var ajax = require('can-util/dom/ajax/ajax');
    var makeDeferred = require('can-connect/helpers/deferred');
    var canEvent = require('can-event');
    var CanMap = require('can-map');
    var CanList = require('can-list');
    var Observation = require('can-observation');
    var assign = require('can-util/js/assign/assign');
    var logErrorAndStart = function (e) {
        ok(false, 'Error ' + e);
        start();
    };
    (function () {
        QUnit.module('can-connect/can/model', {
            setup: function () {
            }
        });
        var isDojo = typeof dojo !== 'undefined';
        test('shadowed id', function () {
            var MyModel = CanModel.extend({ id: 'foo' }, {
                foo: function () {
                    return this.attr('foo');
                }
            });
            var newModel = new MyModel({});
            ok(newModel.isNew(), 'new model is isNew');
            var oldModel = new MyModel({ foo: 'bar' });
            ok(!oldModel.isNew(), 'old model is not new');
            equal(oldModel.foo(), 'bar', 'method can coexist with attribute');
        });
        test('findAll deferred', function () {
            fixture('model/test/people.json', function () {
                return [{
                        'id': 5,
                        'name': 'Justin'
                    }];
            });
            var Person = CanModel.extend({
                findAll: function (params) {
                    return ajax({
                        url: 'model/test/people.json',
                        data: params,
                        dataType: 'json'
                    });
                }
            }, {});
            stop();
            var people = Person.findAll({});
            people.then(function (people) {
                equal(people.length, 1, 'we got a person back');
                equal(people[0].name, 'Justin', 'Got a name back');
                ok(people[0] instanceof Person, 'Person got a class back');
                start();
            });
        });
        test('findAll rejects non-array (#384)', function () {
            var Person = CanModel.extend({
                findAll: function (params, success, error) {
                    return new Promise(function (resolve) {
                        setTimeout(function () {
                            resolve({ stuff: {} });
                        }, 10);
                    });
                }
            }, {});
            stop();
            Person.findAll({}).then(function () {
                ok(false, 'This should not succeed');
                start();
            }, function (err) {
                ok(err instanceof Error, 'Got an error');
                equal(err.message, 'Could not get any raw data while converting using .parseListData');
                start();
            });
        });
        asyncTest('findAll deferred reject', function () {
            function rejectDeferred(df) {
                setTimeout(function () {
                    df.reject();
                }, 1);
            }
            function resolveDeferred(df) {
                setTimeout(function () {
                    df.resolve([]);
                }, 1);
            }
            var Person = CanModel({
                findAll: function (params, success, error) {
                    var df = makeDeferred();
                    if (params.resolve) {
                        resolveDeferred(df);
                    } else {
                        rejectDeferred(df);
                    }
                    return df.promise;
                }
            }, {});
            var people_reject = Person.findAll({ resolve: false });
            var people_resolve = Person.findAll({ resolve: true });
            people_reject.then(function () {
                ok(false, 'This deferred should be rejected');
            });
            people_reject.catch(function () {
                ok(true, 'The deferred is rejected');
            });
            people_resolve.then(function () {
                ok(true, 'This deferred is resolved');
            });
            people_resolve.catch(function () {
                ok(false, 'The deferred should be resolved');
            });
            setTimeout(function () {
                start();
            }, 20);
        });
        test('findOne deferred', function () {
            fixture('model/test/person.json', function () {
                return { name: 'Justin' };
            });
            var Person = CanModel({ findOne: 'model/test/person.json' }, {});
            stop();
            var person = Person.findOne({});
            person.then(function (person) {
                equal(person.name, 'Justin', 'Got a name back');
                ok(person instanceof Person, 'Person got a class back');
                start();
            }, logErrorAndStart);
        });
        test('save deferred', function () {
            var Person = CanModel({
                create: function (attrs, success, error) {
                    return Promise.resolve({ id: 5 });
                }
            }, {});
            var person = new Person({ name: 'Justin' }), personD = person.save();
            stop();
            personD.then(function (person) {
                start();
                equal(person.id, 5, 'we got an id');
            });
        });
        test('update deferred', function () {
            var Person = CanModel({
                update: function (id, attrs, success, error) {
                    return Promise.resolve({ thing: 'er' });
                }
            }, {});
            var person = new Person({
                    name: 'Justin',
                    id: 5
                }), personD = person.save();
            stop();
            personD.then(function (person) {
                start();
                equal(person.thing, 'er', 'we got updated');
            });
        });
        test('destroy deferred', function () {
            var Person = CanModel({
                destroy: function (id, success, error) {
                    return Promise.resolve({ thing: 'er' });
                }
            }, {});
            var person = new Person({
                    name: 'Justin',
                    id: 5
                }), personD = person.destroy();
            stop();
            personD.then(function (person) {
                start();
                equal(person.thing, 'er', 'we got destroyed');
            });
        });
        test('models', function () {
            var Person = CanModel({
                prettyName: function () {
                    return 'Mr. ' + this.name;
                }
            });
            var people = Person.models([{
                    id: 1,
                    name: 'Justin'
                }]);
            equal(people[0].prettyName(), 'Mr. Justin', 'wraps wrapping works');
        });
        test('.models with custom id', function () {
            var CustomId = CanModel({ id: '_id' }, {});
            var results = CustomId.models([
                {
                    '_id': 1,
                    'name': 'Justin'
                },
                {
                    '_id': 2,
                    'name': 'Brian'
                }
            ]);
            equal(results.length, 2, 'Got two items back');
            equal(results[0].name, 'Justin', 'First name right');
            equal(results[1].name, 'Brian', 'Second name right');
        });
        test('binding', 2, function () {
            var Person = CanModel({}, {});
            var inst = new Person({ foo: 'bar' });
            inst.bind('foo', function (ev, val) {
                ok(true, 'updated');
                equal(val, 'baz', 'values match');
            });
            inst.attr('foo', 'baz');
        });
        test('isNew', function () {
            var Person = CanModel({}, {});
            var p = new Person();
            ok(p.isNew(), 'nothing provided is new');
            var p2 = new Person({ id: null });
            ok(p2.isNew(), 'null id is new');
            var p3 = new Person({ id: 0 });
            ok(!p3.isNew(), '0 is not new');
        });
        test('Model events', function () {
            expect(12);
            var order = 0;
            var Event = CanModel({
                create: function () {
                    var def = isDojo ? new dojo.Deferred() : makeDeferred();
                    def.resolve({ id: 1 });
                    return def.promise;
                },
                update: function (attrs) {
                    var def = isDojo ? new dojo.Deferred() : makeDeferred();
                    def.resolve(attrs);
                    return def.promise;
                },
                destroy: function () {
                    var def = isDojo ? new dojo.Deferred() : makeDeferred();
                    def.resolve({});
                    return def.promise;
                }
            }, {});
            stop();
            Event.bind('created', function (ev, passedItem) {
                ok(this === Event, 'got model');
                ok(passedItem === item, 'got instance');
                equal(++order, 1, 'order created');
                passedItem.save();
            }).bind('updated', function (ev, passedItem) {
                equal(++order, 2, 'order updated');
                ok(this === Event, 'got model');
                ok(passedItem === item, 'got instance');
                passedItem.destroy();
            }).bind('destroyed', function (ev, passedItem) {
                equal(++order, 3, 'order destroyed');
                ok(this === Event, 'got model');
                ok(passedItem === item, 'got instance');
                start();
            });
            var item = new Event();
            item.bind('created', function () {
                ok(true, 'created');
            }).bind('updated', function () {
                ok(true, 'updated');
            }).bind('destroyed', function () {
                ok(true, 'destroyed');
            });
            item.save().then(undefined, logErrorAndStart);
        });
        test('removeAttr test', function () {
            var Person = CanModel({}, {});
            var person = new Person({ foo: 'bar' });
            equal(person.foo, 'bar', 'property set');
            person.removeAttr('foo');
            equal(person.foo, undefined, 'property removed');
            var attrs = person.attr();
            equal(attrs.foo, undefined, 'attrs removed');
        });
        test('save error args', function () {
            var Foo = CanModel.extend({ create: '/testinmodelsfoos.json' }, {});
            var st = '{type: "unauthorized"}';
            fixture('/testinmodelsfoos.json', function (request, response) {
                response(401, st);
            });
            stop();
            new Foo({}).save(function () {
                ok(false, 'success should not be called');
                start();
            }, function (jQXHR) {
                ok(true, 'error called');
                ok(jQXHR.getResponseHeader, 'jQXHR object');
                start();
            });
        });
        test('object definitions', function () {
            var ObjectDef = CanModel.extend({
                findAll: {
                    url: '/test/place',
                    dataType: 'json'
                },
                findOne: {
                    url: '/objectdef/{id}',
                    type: 'POST'
                },
                create: {},
                update: {},
                destroy: {}
            }, {});
            canFixture('POST /objectdef/{id}', function (req) {
                equal(req.type, 'post', 'made post');
                return { yes: true };
            });
            canFixture('GET /test/place', function (original) {
                return [original.data];
            });
            stop();
            ObjectDef.findOne({ id: 5 }, function () {
                start();
            }, function () {
                ok(false, 'rejected');
                start();
            });
        });
        test('store binding', function () {
            var Storage = CanModel.extend({}, {});
            var s = new Storage({
                id: 1,
                thing: { foo: 'bar' }
            });
            ok(!Storage.store[1], 'not stored');
            var func = function () {
            };
            s.bind('foo', func);
            ok(Storage.store.has(1), 'stored');
            s.unbind('foo', func);
            ok(!Storage.store.has(1), 'not stored');
            var s2 = new Storage({});
            s2.bind('foo', func);
            s2.attr('id', 5);
            ok(Storage.store.has(5), 'stored');
            s2.unbind('foo', func);
            ok(!Storage.store.has(5), 'not stored');
        });
        test('store ajax binding', function () {
            var Guy = CanModel.extend({
                findAll: '/guys',
                findOne: '/guy/{id}'
            }, {});
            fixture('GET /guys', function () {
                return [{ id: 1 }];
            });
            fixture('GET /guy/{id}', function () {
                return { id: 1 };
            });
            stop();
            Promise.all([
                Guy.findOne({ id: 1 }),
                Guy.findAll()
            ]).then(function (result) {
                var guyRes = result[0], guysRes2 = result[1];
                equal(guyRes.id, 1, 'got a guy id 1 back');
                equal(guysRes2[0].id, 1, 'got guys w/ id 1 back');
                ok(guyRes === guysRes2[0], 'guys are the same');
                setTimeout(function () {
                    var id;
                    start();
                    for (id in Guy.store.set) {
                        ok(false, 'there should be nothing in the store');
                    }
                }, 1);
            });
        });
        test('store instance updates', function () {
            var Guy, updateCount;
            Guy = CanModel.extend({ findAll: 'GET /guys' }, {});
            updateCount = 0;
            canFixture('GET /guys', function () {
                var guys = [{
                        id: 1,
                        updateCount: updateCount,
                        nested: { count: updateCount }
                    }];
                updateCount++;
                return guys;
            });
            stop();
            Guy.findAll({}, function (guys) {
                guys[0].bind('updated', function () {
                });
                ok(Guy.store.has(1), 'instance stored');
                equal(Guy.store.get(1).updateCount, 0, 'updateCount is 0');
                equal(Guy.store.get(1).nested.count, 0, 'nested.count is 0');
                Guy.findAll({}, function (guys) {
                    equal(Guy.store.get(1).updateCount, 1, 'updateCount is 1');
                    equal(Guy.store.get(1).nested.count, 1, 'nested.count is 1');
                    start();
                }, function () {
                    ok(false, 'error');
                });
            }, function () {
                ok(false, 'error');
            });
        });
        test('templated destroy that inherits id', function () {
            var MyModel = CanModel.extend({ destroy: '/destroyplace/{id}' }, {});
            fixture('/destroyplace/{id}', function (original) {
                ok(true, 'fixture called');
                equal(original.url, '/destroyplace/5', 'urls match');
                return {};
            });
            stop();
            new MyModel({ id: 5 }).destroy(function () {
                start();
            });
            fixture('/product/{id}', function (original) {
                equal(original.data.id, 9001, 'Changed ID is correctly set.');
                return {};
            });
            var Base = CanModel.extend({ id: '_id' }, {});
            var Product = Base.extend({ destroy: 'DELETE /product/{_id}' }, {});
            var p = new Product({ _id: 9001 });
            p.destroy().then(function () {
                start();
            }, function (e) {
                ok(false, 'error' + e);
                start();
            });
            stop();
        });
        test('extended templated destroy', function () {
            var MyModel = CanModel({ destroy: '/destroyplace/{attr1}/{attr2}/{id}' }, {});
            fixture('/destroyplace/{attr1}/{attr2}/{id}', function (original) {
                ok(true, 'fixture called');
                equal(original.url, '/destroyplace/foo/bar/5', 'urls match');
                return {};
            });
            stop();
            new MyModel({
                id: 5,
                attr1: 'foo',
                attr2: 'bar'
            }).destroy(function () {
                start();
            });
            fixture('/product/{attr3}/{id}', function (original) {
                equal(original.data.id, 9001, 'Changed ID is correctly set.');
                start();
                return {};
            });
            var Base = CanModel({ id: '_id' }, {});
            var Product = Base({ destroy: 'DELETE /product/{attr3}/{_id}' }, {});
            new Product({
                _id: 9001,
                attr3: 'great'
            }).destroy();
            stop();
        });
        test('model list attr', function () {
            var Person = CanModel({}, {});
            var list1 = new Person.List(), list2 = new Person.List([
                    new Person({ id: 1 }),
                    new Person({ id: 2 })
                ]);
            equal(list1.length, 0, 'Initial empty list has length of 0');
            list1.attr(list2);
            equal(list1.length, 2, 'Merging using attr yields length of 2');
        });
        test('destroying a model impact the right list', function () {
            var Person = CanModel.extend({
                destroy: function (id, success) {
                    var def = makeDeferred();
                    def.resolve({});
                    return def.promise;
                }
            }, {});
            var Organisation = CanModel.extend({
                destroy: function (id, success) {
                    var def = makeDeferred();
                    def.resolve({});
                    return def.promise;
                }
            }, {});
            var people = new Person.List([
                    new Person({ id: 1 }),
                    new Person({ id: 2 })
                ]), orgs = new Organisation.List([
                    new Organisation({ id: 1 }),
                    new Organisation({ id: 2 })
                ]);
            people.bind('length', function () {
            });
            orgs.bind('length', function () {
            });
            people[0].attr('organisation', orgs[0]);
            people[1].attr('organisation', orgs[1]);
            equal(people.length, 2, 'Initial Person.List has length of 2');
            equal(orgs.length, 2, 'Initial Organisation.List has length of 2');
            orgs[0].destroy();
            stop();
            setTimeout(function () {
                start();
                equal(people.length, 2, 'After destroying orgs[0] Person.List has length of 2');
                equal(orgs.length, 1, 'After destroying orgs[0] Organisation.List has length of 1');
            }, 10);
        });
        test('uses attr with isNew', function () {
            var old = Observation.add;
            Observation.add = function (object, attribute) {
                if (attribute === 'id') {
                    ok(true, 'used attr');
                }
            };
            var M = CanModel.extend({}, {});
            var m = new M({ id: 4 });
            m.isNew();
            Observation.add = old;
        });
        test('extends defaults by calling base method', function () {
            var M1 = CanModel.extend({ defaults: { foo: 'bar' } }, {});
            var M2 = M1({});
            equal(M2.defaults.foo, 'bar');
        });
        test('.models updates existing list if passed', 4, function () {
            var Model = CanModel.extend({}, {});
            var list = Model.models([
                {
                    id: 1,
                    name: 'first'
                },
                {
                    id: 2,
                    name: 'second'
                }
            ]);
            list.bind('add', function (ev, newData) {
                equal(newData.length, 3, 'Got all new items at once');
            });
            var newList = Model.models([
                {
                    id: 3,
                    name: 'third'
                },
                {
                    id: 4,
                    name: 'fourth'
                },
                {
                    id: 5,
                    name: 'fifth'
                }
            ], list);
            equal(list, newList, 'Lists are the same');
            equal(newList.attr('length'), 3, 'List has new items');
            equal(list[0].name, 'third', 'New item is the first one');
        });
        test('calling destroy with unsaved model triggers destroyed event (#181)', function () {
            var MyModel = CanModel.extend({}, {}), newModel = new MyModel(), list = new MyModel.List(), deferred;
            list.bind('length', function () {
            });
            list.push(newModel);
            equal(list.attr('length'), 1, 'List length as expected');
            deferred = newModel.destroy();
            ok(deferred, '.destroy returned a Deferred');
            equal(list.attr('length'), 0, 'Unsaved model removed from list');
            deferred.then(function (data) {
                ok(data === newModel, 'Resolved with destroyed model as described in docs');
            });
        });
        test('model removeAttr (#245)', function () {
            var MyModel = CanModel.extend({}), model;
            model = MyModel.model({
                id: 0,
                index: 2,
                name: 'test'
            });
            MyModel.connection.addInstanceReference(model);
            model = MyModel.model({
                id: 0,
                name: 'text updated'
            });
            equal(model.attr('name'), 'text updated', 'attribute updated');
            equal(model.attr('index'), 2, 'Index attribute still remains');
            MyModel = CanModel.extend({ removeAttr: true }, {});
            model = MyModel.model({
                id: 0,
                index: 2,
                name: 'test'
            });
            MyModel.connection.addInstanceReference(model);
            model = MyModel.model({
                id: 0,
                name: 'text updated'
            });
            equal(model.attr('name'), 'text updated', 'attribute updated');
            deepEqual(model.attr(), {
                id: 0,
                name: 'text updated'
            }, 'Index attribute got removed');
        });
        test('.parseModel on create and update (#301)', function () {
            var MyModel = CanModel.extend({
                    create: 'POST /todo',
                    update: 'PUT /todo',
                    parseModel: function (data) {
                        return data.item;
                    }
                }, {}), id = 0, updateTime;
            fixture('POST /todo', function (original, respondWith, settings) {
                id++;
                return { item: assign(original.data, { id: id }) };
            });
            fixture('PUT /todo', function (original, respondWith, settings) {
                updateTime = new Date().getTime();
                return { item: { updatedAt: updateTime } };
            });
            stop();
            MyModel.bind('created', function (ev, created) {
                start();
                deepEqual(created.attr(), {
                    id: 1,
                    name: 'Dishes'
                }, '.model works for create');
            }).bind('updated', function (ev, updated) {
                start();
                deepEqual(updated.attr(), {
                    id: 1,
                    name: 'Laundry',
                    updatedAt: updateTime
                }, '.model works for update');
            });
            var instance = new MyModel({ name: 'Dishes' }), saveD = instance.save();
            stop();
            saveD.then(function () {
                instance.attr('name', 'Laundry').save(undefined, logErrorAndStart);
            }, logErrorAndStart);
        });
        test('List params uses findAll', function () {
            stop();
            fixture('/things', function (request) {
                equal(request.data.param, 'value', 'params passed');
                return [{
                        id: 1,
                        name: 'Thing One'
                    }];
            });
            var Model = CanModel.extend({ findAll: '/things' }, {});
            var items = new Model.List({ param: 'value' });
            items.bind('add', function (ev, items, index) {
                equal(items[0].name, 'Thing One', 'items added');
                start();
            });
        });
        test('destroy not calling callback for new instances (#403)', function () {
            var Recipe = CanModel.extend({}, {});
            expect(1);
            stop();
            new Recipe({ name: 'mow grass' }).destroy(function (recipe) {
                ok(true, 'Destroy called');
                start();
            });
        });
        test('.model should always serialize Observes (#444)', function () {
            var ConceptualDuck = CanModel.extend({ defaults: { sayeth: 'Abstractly \'quack\'' } }, {});
            var ObserveableDuck = CanMap({}, {});
            equal('quack', ConceptualDuck.model(new ObserveableDuck({ sayeth: 'quack' })).sayeth);
        });
        test('string configurable model and models functions (#128)', function () {
            var StrangeProp = CanModel.extend({
                parseModel: 'foo',
                parseModels: 'bar'
            }, {});
            var strangers = StrangeProp.models({
                bar: [
                    {
                        foo: {
                            id: 1,
                            name: 'one'
                        }
                    },
                    {
                        foo: {
                            id: 2,
                            name: 'two'
                        }
                    }
                ]
            });
            deepEqual(strangers.attr(), [
                {
                    id: 1,
                    name: 'one'
                },
                {
                    id: 2,
                    name: 'two'
                }
            ]);
        });
        test('create deferred does not resolve to the same instance', function () {
            var Todo = CanModel.extend({
                create: function () {
                    var def = makeDeferred();
                    def.resolve({ id: 5 });
                    return def.promise;
                }
            }, {});
            var handler = function () {
            };
            var t = new Todo({ name: 'Justin' });
            t.bind('name', handler);
            var def = t.save();
            stop();
            def.then(function (todo) {
                ok(todo === t, 'same instance');
                start();
                ok(Todo.store.get(5) === t, 'instance put in store');
                t.unbind('name', handler);
            });
        });
        test('Model#save should not replace attributes with their default values (#560)', function () {
            fixture('POST /person.json', function (request, response) {
                return { createdAt: 'now' };
            });
            var Person = CanModel.extend({ update: 'POST /person.json' }, { name: 'Example name' });
            var person = new Person({
                    id: 5,
                    name: 'Justin'
                }), personD = person.save();
            stop();
            personD.then(function (person) {
                start();
                equal(person.name, 'Justin', 'Model name attribute value is preserved after save');
            });
        });
        test('.parseModel as function on create and update (#560)', function () {
            var MyModel = CanModel.extend({
                    create: 'POST /todo',
                    update: 'PUT /todo',
                    parseModel: function (data) {
                        return data.item;
                    }
                }, { aDefault: 'foo' }), id = 0, updateTime;
            fixture('POST /todo', function (original, respondWith, settings) {
                id++;
                return { item: assign(original.data, { id: id }) };
            });
            fixture('PUT /todo', function (original, respondWith, settings) {
                updateTime = new Date().getTime();
                return { item: { updatedAt: updateTime } };
            });
            stop();
            MyModel.bind('created', function (ev, created) {
                start();
                deepEqual(created.attr(), {
                    id: 1,
                    name: 'Dishes',
                    aDefault: 'bar'
                }, '.model works for create');
            }).bind('updated', function (ev, updated) {
                start();
                deepEqual(updated.attr(), {
                    id: 1,
                    name: 'Laundry',
                    updatedAt: updateTime
                }, '.model works for update');
            });
            var instance = new MyModel({
                    name: 'Dishes',
                    aDefault: 'bar'
                }), saveD = instance.save();
            stop();
            saveD.then(function () {
                instance.attr('name', 'Laundry');
                instance.removeAttr('aDefault');
                instance.save();
            });
        });
        test('.parseModel as string on create and update (#560)', function () {
            var MyModel = CanModel.extend({
                    create: 'POST /todo',
                    update: 'PUT /todo',
                    parseModel: 'item'
                }, { aDefault: 'foo' }), id = 0, updateTime;
            fixture('POST /todo', function (original, respondWith, settings) {
                id++;
                return { item: assign(original.data, { id: id }) };
            });
            fixture('PUT /todo', function (original, respondWith, settings) {
                updateTime = new Date().getTime();
                return { item: { updatedAt: updateTime } };
            });
            stop();
            MyModel.bind('created', function (ev, created) {
                start();
                deepEqual(created.attr(), {
                    id: 1,
                    name: 'Dishes',
                    aDefault: 'bar'
                }, '.model works for create');
            }).bind('updated', function (ev, updated) {
                start();
                deepEqual(updated.attr(), {
                    id: 1,
                    name: 'Laundry',
                    updatedAt: updateTime
                }, '.model works for update');
            });
            var instance = new MyModel({
                    name: 'Dishes',
                    aDefault: 'bar'
                }), saveD = instance.save();
            stop();
            saveD.then(function () {
                instance.attr('name', 'Laundry');
                instance.removeAttr('aDefault');
                instance.save();
            });
        });
        test('parseModels and findAll', function () {
            var array = [{
                    id: 1,
                    name: 'first'
                }];
            canFixture('/mymodels', function () {
                return array;
            });
            var MyModel = CanModel.extend({
                findAll: '/mymodels',
                parseModels: function (raw, xhr) {
                    deepEqual(array, raw, 'got passed raw data');
                    return {
                        data: raw,
                        count: 1000
                    };
                }
            }, {});
            stop();
            MyModel.findAll({}, function (models) {
                equal(models.count, 1000);
                start();
            });
        });
        test('parseModels and parseModel and findAll', function () {
            fixture('/mymodels', function () {
                return {
                    myModels: [{
                            myModel: {
                                id: 1,
                                name: 'first'
                            }
                        }]
                };
            });
            var MyModel = CanModel.extend({
                findAll: '/mymodels',
                parseModels: 'myModels',
                parseModel: 'myModel'
            }, {});
            stop();
            MyModel.findAll({}, function (models) {
                deepEqual(models.attr(), [{
                        id: 1,
                        name: 'first'
                    }], 'correct models returned');
                start();
            });
        });
        test('Nested lists', function () {
            var Teacher = CanModel.extend({});
            var teacher = new Teacher();
            teacher.attr('locations', [
                {
                    id: 1,
                    name: 'Chicago'
                },
                {
                    id: 2,
                    name: 'LA'
                }
            ]);
            ok(!(teacher.attr('locations') instanceof Teacher.List), 'nested list is not an instance of Teacher.List');
            ok(!(teacher.attr('locations')[0] instanceof Teacher), 'nested map is not an instance of Teacher');
        });
        test('#501 - resource definition - create', function () {
            fixture('/foods', function () {
                return [];
            });
            var FoodModel = CanModel.extend({ resource: '/foods' }, {});
            stop();
            var steak = new FoodModel({ name: 'steak' });
            steak.save(function (food) {
                equal(food.name, 'steak', 'create created the correct model');
                start();
            });
        });
        test('#501 - resource definition - findAll', function () {
            fixture('/drinks', function () {
                return [{
                        id: 1,
                        name: 'coke'
                    }];
            });
            var DrinkModel = CanModel.extend({ resource: '/drinks' }, {});
            stop();
            DrinkModel.findAll({}, function (drinks) {
                deepEqual(drinks.attr(), [{
                        id: 1,
                        name: 'coke'
                    }], 'findAll returned the correct models');
                start();
            });
        });
        test('#501 - resource definition - findOne', function () {
            fixture('GET /clothes/{id}', function () {
                return [{
                        id: 1,
                        name: 'pants'
                    }];
            });
            var ClothingModel = CanModel.extend({ resource: '/clothes' }, {});
            stop();
            ClothingModel.findOne({ id: 1 }, function (item) {
                equal(item[0].name, 'pants', 'findOne returned the correct model');
                start();
            }, logErrorAndStart);
        });
        test('#501 - resource definition - remove trailing slash(es)', function () {
            fixture('POST /foods', function () {
                return [];
            });
            var FoodModel = CanModel.extend({ resource: '/foods//////' }, {});
            stop();
            var steak = new FoodModel({ name: 'steak' });
            steak.save(function (food) {
                equal(food.name, 'steak', 'removed trailing \'/\' and created the correct model');
                start();
            });
        });
        test('model list destroy after calling replace', function () {
            expect(2);
            var MyModel = CanModel.extend({}, {});
            var map = new MyModel({ name: 'map1' });
            var map2 = new MyModel({ name: 'map2' });
            var list = new MyModel.List([
                map,
                map2
            ]);
            list.bind('destroyed', function (ev) {
                ok(true, 'trigger destroyed');
            });
            canEvent.trigger.call(map, 'destroyed');
            list.replace([map2]);
            canEvent.trigger.call(map2, 'destroyed');
        });
        test('a model defined with a fullName has findAll working (#1034)', function () {
            var List = CanList.extend();
            var My = {};
            My.Model = CanModel.extend('Model', { List: List }, {});
            equal(List.Map, My.Model, 'list\'s Map points to My.Model');
        });
        test('providing parseModels works', function () {
            var MyModel = CanModel.extend({ parseModel: 'modelData' }, {});
            var data = MyModel.parseModel({ modelData: { id: 1 } });
            equal(data.id, 1, 'correctly used parseModel');
        });
        test('#1089 - resource definition - inheritance', function () {
            fixture('GET /things/{id}', function () {
                return {
                    id: 0,
                    name: 'foo'
                };
            });
            var Base = CanModel.extend();
            var Thing = Base.extend({ resource: '/things' }, {});
            stop();
            Thing.findOne({ id: 0 }, function (thing) {
                equal(thing.name, 'foo', 'found model in inherited model');
                start();
            }, function (e, msg) {
                ok(false, msg);
                start();
            });
        });
        test('#1089 - resource definition - CRUD overrides', function () {
            canFixture('GET /foos/{id}', function () {
                return {
                    id: 0,
                    name: 'foo'
                };
            });
            canFixture('POST /foos', function () {
                return { id: 1 };
            });
            canFixture('PUT /foos/{id}', function () {
                return {
                    id: 1,
                    updated: true
                };
            });
            canFixture('GET /bars', function () {
                return [{}];
            });
            var Thing = CanModel.extend({
                resource: '/foos',
                findAll: 'GET /bars',
                update: {
                    url: '/foos/{id}',
                    type: 'PUT'
                },
                create: function () {
                    return ajax({
                        url: '/foos',
                        type: 'POST'
                    });
                }
            }, {});
            var alldfd = Thing.findAll();
            var onedfd = Thing.findOne({ id: 0 });
            var postdfd = new Thing().save();
            stop();
            Promise.all([
                alldfd,
                onedfd,
                postdfd
            ]).then(function (result) {
                var things = result[0], thing = result[1], newthing = result[2];
                equal(things.length, 1, 'findAll override called');
                equal(thing.name, 'foo', 'resource findOne called');
                equal(newthing.id, 1, 'post override called with function');
                newthing.save(function (res) {
                    ok(res.updated, 'put override called with object');
                    start();
                });
            }, logErrorAndStart)['catch'](function () {
                ok(false, 'override request failed');
                start();
            });
        });
        test('findAll not called if List constructor argument is deferred (#1074)', function () {
            var count = 0;
            var Foo = CanModel.extend({
                findAll: function () {
                    count++;
                    var def = makeDeferred();
                    def.resolve([
                        { id: 1 },
                        { id: 2 }
                    ]);
                    return def.promise;
                }
            }, {});
            new Foo.List(Foo.findAll());
            equal(count, 1, 'findAll called only once.');
        });
        test('static methods do not get overwritten with resource property set (#1309)', function () {
            var Base = CanModel.extend({
                resource: '/path',
                findOne: function () {
                    var dfd = makeDeferred();
                    dfd.resolve({ text: 'Base findAll' });
                    return dfd.promise;
                }
            }, {});
            stop();
            Base.findOne({}).then(function (model) {
                ok(model instanceof Base);
                deepEqual(model.attr(), { text: 'Base findAll' });
                start();
            }, function () {
                ok(false, 'Failed handler should not be called.');
            });
        });
        test('parseModels does not get overwritten if already implemented in base class (#1246, #1272)', 5, function () {
            var Base = CanModel.extend({
                findOne: function () {
                    var dfd = makeDeferred();
                    dfd.resolve({ text: 'Base findOne' });
                    return dfd.promise;
                },
                parseModel: function (attributes) {
                    deepEqual(attributes, { text: 'Base findOne' }, 'parseModel called');
                    attributes.parsed = true;
                    return attributes;
                }
            }, {});
            var Extended = Base.extend({}, {});
            stop();
            Extended.findOne({}).then(function (model) {
                ok(model instanceof Base);
                ok(model instanceof Extended);
                deepEqual(model.attr(), {
                    text: 'Base findOne',
                    parsed: true
                });
                start();
            }, function () {
                ok(false, 'Failed handler should not be called.');
            });
            var Third = Extended.extend({
                findOne: function () {
                    var dfd = makeDeferred();
                    dfd.resolve({ nested: { text: 'Third findOne' } });
                    return dfd.promise;
                },
                parseModel: 'nested'
            }, {});
            Third.findOne({}).then(function (model) {
                equal(model.attr('text'), 'Third findOne', 'correct findOne used');
            });
        });
        test('Models with no id (undefined or null) are not placed in store (#1358)', function () {
            var MyStandardModel = CanModel.extend({});
            var MyCustomModel = CanModel.extend({ id: 'ID' }, {});
            var myID = null;
            var instanceNull = new MyStandardModel({ id: myID });
            var instanceUndefined = new MyStandardModel({});
            var instanceCustom = new MyCustomModel({ ID: myID });
            instanceNull.bind('change', function () {
            });
            instanceUndefined.bind('change', function () {
            });
            instanceCustom.bind('change', function () {
            });
            ok(typeof MyStandardModel.store[instanceNull.id] === 'undefined', 'Model should not be added to store when id is null');
            ok(typeof MyStandardModel.store[instanceUndefined.id] === 'undefined', 'Model should not be added to store when id is undefined');
            ok(typeof MyCustomModel.store[instanceCustom[instanceCustom.constructor.id]] === 'undefined', 'Model should not be added to store when id is null');
        });
        test('Models should be removed from store when instance.removeAttr(\'id\') is called', function () {
            var Task = CanModel.extend({}, {});
            var t1 = new Task({
                id: 1,
                name: 'MyTask'
            });
            t1.bind('change', function () {
            });
            ok(Task.store.get(t1.id).name === 'MyTask', 'Model should be in store');
            t1.removeAttr('id');
            ok(typeof Task.store.get(t1.id) === 'undefined', 'Model should be removed from store when `id` is removed');
        });
    }());
});
/*can-connect@1.3.8#can/ref/ref-test*/
define('can-connect@1.3.8#can/ref/ref-test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var DefineMap = require('can-define/map/');
    var DefineList = require('can-define/list/');
    var constructorStore = require('can-connect/constructor/store/');
    var constructor = require('can-connect/constructor/');
    var canMap = require('can-connect/can/map/');
    var canRef = require('can-connect/can/ref/');
    var connect = require('can-connect');
    QUnit.module('can-connect/can/ref', {
        setup: function () {
        }
    });
    QUnit.asyncTest('basics', function () {
        var Team = DefineMap.extend({ id: 'string' });
        Team.connection = connect([
            constructor,
            constructorStore,
            canMap,
            canRef,
            {
                getData: function () {
                    return Promise.resolve({
                        id: 3,
                        name: 'Bears'
                    });
                }
            }
        ], { Map: Team });
        var Game = DefineMap.extend({
            id: 'string',
            teamRef: { type: Team.Ref.type },
            score: 'number'
        });
        Game.connection = connect([
            constructor,
            constructorStore,
            canMap,
            canRef,
            {
                getListData: function () {
                    return Promise.resolve({
                        data: [
                            {
                                id: 1,
                                score: 50,
                                teamRef: 2
                            },
                            {
                                id: 2,
                                score: 100,
                                teamRef: 3
                            },
                            {
                                id: 3,
                                score: 200,
                                teamRef: 2
                            }
                        ]
                    });
                },
                getData: function (params) {
                    return Promise.resolve({
                        id: 1,
                        score: 50,
                        teamRef: {
                            id: 2,
                            name: 'Cubs'
                        }
                    });
                }
            }
        ], { Map: Game });
        var handler = function () {
        };
        Game.get({
            id: 1,
            populate: 'teamRef'
        }).then(function (game) {
            game.on('teamRef', handler);
            game.teamRef.on('value', handler);
            var teamRef = game.teamRef;
            QUnit.ok(teamRef.value instanceof Team);
            QUnit.equal(teamRef.value.name, 'Cubs');
            QUnit.equal(teamRef.id, 2);
            Game.getList({}).then(function (games) {
                QUnit.ok(games[0].teamRef === teamRef, 'same team ref');
                QUnit.ok(games[2].teamRef === teamRef, 'same team ref on a different object');
                QUnit.ok(teamRef.value instanceof Team);
                QUnit.equal(teamRef.id, 2);
                QUnit.equal(teamRef.value.name, 'Cubs');
                QUnit.equal(games[1].teamRef.id, 3);
                QUnit.equal(games[0].teamRef.isResolved(), true);
                games[1].teamRef.on('value', function (ev, newVal) {
                    QUnit.ok(newVal instanceof Team);
                    QUnit.equal(newVal.name, 'Bears');
                    QUnit.start();
                });
                QUnit.equal(games[1].teamRef.isResolved(), false);
            });
        }, function (error) {
            QUnit.ok(false, 'error');
            QUnit.start();
        });
    });
    QUnit.asyncTest('using Ref as type', function () {
        var Team = DefineMap.extend({ id: 'string' });
        connect([
            constructor,
            constructorStore,
            canMap,
            canRef,
            {
                getData: function () {
                    return Promise.resolve({
                        id: 3,
                        name: 'Bears'
                    });
                }
            }
        ], { Map: Team });
        var Game = DefineMap.extend({
            id: 'string',
            teamRef: Team.Ref,
            score: 'number'
        });
        connect([
            constructor,
            constructorStore,
            canMap,
            canRef,
            {
                getListData: function () {
                    return Promise.resolve({
                        data: [
                            {
                                id: 1,
                                score: 50,
                                teamRef: 2
                            },
                            {
                                id: 2,
                                score: 100,
                                teamRef: 3
                            },
                            {
                                id: 3,
                                score: 200,
                                teamRef: 2
                            }
                        ]
                    });
                },
                getData: function (params) {
                    return Promise.resolve({
                        id: 1,
                        score: 50,
                        teamRef: {
                            id: 2,
                            name: 'Cubs'
                        }
                    });
                }
            }
        ], { Map: Game });
        var handler = function () {
        };
        Game.get({
            id: 1,
            populate: 'teamRef'
        }).then(function (game) {
            game.on('teamRef', handler);
            game.teamRef.on('value', handler);
            var teamRef = game.teamRef;
            QUnit.ok(teamRef.value instanceof Team);
            QUnit.equal(teamRef.value.name, 'Cubs');
            QUnit.equal(teamRef.id, 2);
            Game.getList({}).then(function (games) {
                QUnit.ok(games[0].teamRef === teamRef, 'same team ref');
                QUnit.ok(games[2].teamRef === teamRef, 'same team ref on a different object');
                QUnit.ok(teamRef.value instanceof Team);
                QUnit.equal(teamRef.id, 2);
                QUnit.equal(teamRef.value.name, 'Cubs');
                QUnit.equal(games[1].teamRef.id, 3);
                QUnit.equal(games[0].teamRef.isResolved(), true);
                games[1].teamRef.on('value', function (ev, newVal) {
                    QUnit.ok(newVal instanceof Team);
                    QUnit.equal(newVal.name, 'Bears');
                    QUnit.start();
                });
                QUnit.equal(games[1].teamRef.isResolved(), false);
            });
        }, function (error) {
            QUnit.ok(false, 'error');
            QUnit.start();
        });
    });
    QUnit.test('Ref can be passed an instance of what it references (#236)', function () {
        var Team = DefineMap.extend({ id: 'string' });
        connect([
            constructor,
            constructorStore,
            canMap,
            canRef
        ], { Map: Team });
        var Game = DefineMap.extend({
            id: 'string',
            teamRef: Team.Ref,
            score: 'number'
        });
        connect([
            constructor,
            constructorStore,
            canMap,
            canRef
        ], { Map: Game });
        var team = new Team({ id: 5 });
        var game = new Game({
            id: 6,
            teamRef: team,
            score: 22
        });
        QUnit.ok(game.teamRef.value instanceof Team, 'is an instance');
        QUnit.equal(game.teamRef.value, team, 'same instance');
    });
    QUnit.asyncTest('populate Ref that was already created without a value', function () {
        var Team = DefineMap.extend({ id: 'string' });
        var getDataCallCounter = 0;
        Team.connection = connect([
            constructor,
            constructorStore,
            canMap,
            canRef,
            {
                getData: function () {
                    getDataCallCounter++;
                    return Promise.resolve({
                        id: 3,
                        name: 'Bears'
                    });
                }
            }
        ], { Map: Team });
        var Game = DefineMap.extend({
            id: 'string',
            teamRef: { type: Team.Ref.type },
            score: 'number'
        });
        Game.connection = connect([
            constructor,
            constructorStore,
            canMap,
            canRef,
            {
                getData: function (params) {
                    return Promise.resolve({
                        id: 1,
                        score: 50,
                        teamRef: params.populate ? {
                            id: 3,
                            name: 'Cubs'
                        } : 3
                    });
                }
            }
        ], { Map: Game });
        var handler = function () {
        };
        Game.get({ id: 1 }).then(function (game) {
            game.on('teamRef', handler);
            var teamRef = game.teamRef;
            QUnit.ok(typeof teamRef.value === 'undefined', 'Value should be undefined');
            QUnit.equal(teamRef.id, 3, 'Id should be the correct one');
            QUnit.equal(getDataCallCounter, 0, 'Team getData should NOT be called');
            Game.get({
                id: 1,
                populate: 'teamRef'
            }).then(function (game) {
                game.teamRef.on('value', handler);
                QUnit.ok(teamRef.value instanceof Team, 'Value should be a Team');
                QUnit.equal(teamRef.value.name, 'Cubs', 'Name should be Cubs');
                QUnit.equal(teamRef.id, 3, 'Id should be the correct one');
                QUnit.equal(getDataCallCounter, 0, 'Team getData should still NOT be called');
                QUnit.start();
            });
        }, function (error) {
            QUnit.ok(false, 'error');
            QUnit.start();
        });
    });
});
/*can-connect@1.3.8#can/super-map/super-map_test*/
define('can-connect@1.3.8#can/super-map/super-map_test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var fixture = require('can-fixture');
    var Map = require('can-map');
    var superMap = require('can-connect/can/super-map/');
    var set = require('can-set');
    QUnit.module('can-connect/can/super-map');
    QUnit.test('uses idProp', function () {
        var Restaurant = Map.extend({});
        var connection = superMap({
            url: '/api/restaurants',
            idProp: '_id',
            Map: Restaurant,
            List: Restaurant.List,
            name: 'restaurant'
        });
        fixture({
            'GET /api/restaurants/{_id}': function (request) {
                return { id: 5 };
            }
        });
        stop();
        connection.getData({ _id: 5 }).then(function (data) {
            deepEqual(data, { id: 5 }, 'findOne');
            start();
        });
    });
    QUnit.test('creates map if none is provided (#8)', function () {
        var connection = superMap({
            url: '/api/restaurants',
            idProp: '_id',
            name: 'restaurant'
        });
        fixture({
            'GET /api/restaurants/{_id}': function (request) {
                return { id: 5 };
            }
        });
        stop();
        connection.getData({ _id: 5 }).then(function (data) {
            deepEqual(data, { id: 5 }, 'findOne');
            start();
        });
    });
    QUnit.test('allow other caches (#59)', function () {
        var cacheConnection = {
            getData: function () {
                ok(true, 'called this cacheConnection');
                return Promise.resolve({ id: 5 });
            }
        };
        var connection = superMap({
            url: '/api/restaurants',
            name: 'restaurant',
            cacheConnection: cacheConnection
        });
        fixture({
            'GET /api/restaurants/{_id}': function (request) {
                return { id: 5 };
            }
        });
        stop();
        connection.getData({ _id: 5 }).then(function (data) {
            start();
        });
    });
    QUnit.test('uses idProp from algebra (#255)', function () {
        var Restaurant = Map.extend({});
        var connection = superMap({
            url: '/api/restaurants',
            Map: Restaurant,
            List: Restaurant.List,
            name: 'restaurant',
            algebra: new set.Algebra(set.comparators.id('_id'))
        });
        fixture({
            'GET /api/restaurants/{_id}': function (request) {
                return { id: 5 };
            }
        });
        stop();
        connection.getData({ _id: 5 }).then(function (data) {
            deepEqual(data, { id: 5 }, 'findOne');
            start();
        });
    });
});
/*can-connect@1.3.8#can/base-map/base-map_test*/
define('can-connect@1.3.8#can/base-map/base-map_test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var fixture = require('can-fixture');
    var Map = require('can-map');
    var baseMap = require('can-connect/can/base-map/');
    QUnit.module('can-connect/can/base-map');
    QUnit.test('uses idProp', function () {
        var Restaurant = Map.extend({});
        var connection = baseMap({
            url: '/api/restaurants',
            idProp: '_id',
            Map: Restaurant,
            List: Restaurant.List,
            name: 'restaurant'
        });
        fixture({
            'GET /api/restaurants/{_id}': function (request) {
                return { id: 5 };
            }
        });
        stop();
        connection.getData({ _id: 5 }).then(function (data) {
            deepEqual(data, { id: 5 }, 'findOne');
            start();
        });
    });
    QUnit.test('creates map if none is provided (#8)', function () {
        var connection = baseMap({
            url: '/api/restaurants',
            idProp: '_id',
            name: 'restaurant'
        });
        fixture({
            'GET /api/restaurants/{_id}': function (request) {
                return { id: 5 };
            }
        });
        stop();
        connection.getData({ _id: 5 }).then(function (data) {
            deepEqual(data, { id: 5 }, 'findOne');
            start();
        });
    });
});
/*can-view-import@3.0.6#can-view-import*/
define('can-view-import@3.0.6#can-view-import', function (require, exports, module) {
    var assign = require('can-util/js/assign/assign');
    var canData = require('can-util/dom/data/data');
    var importer = require('can-util/js/import/import');
    var nodeLists = require('can-view-nodelist');
    var tag = require('can-view-callbacks').tag;
    var events = require('can-event');
    var canLog = require('can-util/js/log/log');
    tag('can-import', function (el, tagData) {
        var moduleName = el.getAttribute('from');
        var templateModule = tagData.options.get('helpers.module');
        var parentName = templateModule ? templateModule.id : undefined;
        if (!moduleName) {
            return Promise.reject('No module name provided');
        }
        var importPromise = importer(moduleName, parentName);
        importPromise.catch(function (err) {
            canLog.error(err);
        });
        canData.set.call(el, 'viewModel', importPromise);
        canData.set.call(el, 'scope', importPromise);
        var scope = tagData.scope.add(importPromise);
        var handOffTag = el.getAttribute('can-tag');
        if (handOffTag) {
            var callback = tag(handOffTag);
            canData.set.call(el, 'preventDataBindings', true);
            callback(el, assign(tagData, { scope: scope }));
            canData.set.call(el, 'preventDataBindings', false);
            canData.set.call(el, 'viewModel', importPromise);
            canData.set.call(el, 'scope', importPromise);
        } else {
            var frag = tagData.subtemplate ? tagData.subtemplate(scope, tagData.options) : document.createDocumentFragment();
            var nodeList = nodeLists.register([], undefined, true);
            events.one.call(el, 'removed', function () {
                nodeLists.unregister(nodeList);
            });
            el.appendChild(frag);
            nodeLists.update(nodeList, el.childNodes);
        }
    });
});
/*steal-stache@3.0.5#add-bundles*/
define('steal-stache@3.0.5#add-bundles', [], function(){ return {}; });
/*steal-stache@3.0.5#steal-stache*/
define('steal-stache@3.0.5#steal-stache', [], function(){ return {}; });
/*can-connect@1.3.8#can/tag/tag_find_all_test.stache!steal-stache@3.0.5#steal-stache*/
define('can-connect@1.3.8#can/tag/tag_find_all_test.stache!steal-stache@3.0.5#steal-stache', [
    'module',
    'can-stache',
    'can-stache/src/mustache_core',
    'can-view-import@3.0.6#can-view-import',
    'can-stache-bindings@3.0.12#can-stache-bindings'
], function (module, stache, mustacheCore) {
    var renderer = stache([
        {
            'tokenType': 'start',
            'args': [
                'person-model',
                false
            ]
        },
        {
            'tokenType': 'attrStart',
            'args': ['get-list']
        },
        {
            'tokenType': 'attrValue',
            'args': ['{type=type}']
        },
        {
            'tokenType': 'attrEnd',
            'args': ['get-list']
        },
        {
            'tokenType': 'end',
            'args': [
                'person-model',
                false
            ]
        },
        {
            'tokenType': 'chars',
            'args': ['\n\t']
        },
        {
            'tokenType': 'special',
            'args': ['#isPending']
        },
        {
            'tokenType': 'start',
            'args': [
                'span',
                false
            ]
        },
        {
            'tokenType': 'attrStart',
            'args': ['class']
        },
        {
            'tokenType': 'attrValue',
            'args': ['pending']
        },
        {
            'tokenType': 'attrEnd',
            'args': ['class']
        },
        {
            'tokenType': 'attrStart',
            'args': ['($inserted)']
        },
        {
            'tokenType': 'attrValue',
            'args': ['pending']
        },
        {
            'tokenType': 'attrEnd',
            'args': ['($inserted)']
        },
        {
            'tokenType': 'end',
            'args': [
                'span',
                false
            ]
        },
        {
            'tokenType': 'close',
            'args': ['span']
        },
        {
            'tokenType': 'special',
            'args': ['/isPending']
        },
        {
            'tokenType': 'chars',
            'args': ['\n\t']
        },
        {
            'tokenType': 'special',
            'args': ['#isResolved']
        },
        {
            'tokenType': 'start',
            'args': [
                'span',
                false
            ]
        },
        {
            'tokenType': 'attrStart',
            'args': ['class']
        },
        {
            'tokenType': 'attrValue',
            'args': ['resolved']
        },
        {
            'tokenType': 'attrEnd',
            'args': ['class']
        },
        {
            'tokenType': 'attrStart',
            'args': ['($inserted)']
        },
        {
            'tokenType': 'attrValue',
            'args': ['resolved']
        },
        {
            'tokenType': 'attrEnd',
            'args': ['($inserted)']
        },
        {
            'tokenType': 'end',
            'args': [
                'span',
                false
            ]
        },
        {
            'tokenType': 'special',
            'args': ['#each value']
        },
        {
            'tokenType': 'start',
            'args': [
                'span',
                false
            ]
        },
        {
            'tokenType': 'end',
            'args': [
                'span',
                false
            ]
        },
        {
            'tokenType': 'special',
            'args': ['id']
        },
        {
            'tokenType': 'close',
            'args': ['span']
        },
        {
            'tokenType': 'special',
            'args': ['/each']
        },
        {
            'tokenType': 'close',
            'args': ['span']
        },
        {
            'tokenType': 'special',
            'args': ['/isResolved']
        },
        {
            'tokenType': 'chars',
            'args': ['\n']
        },
        {
            'tokenType': 'close',
            'args': ['person-model']
        },
        {
            'tokenType': 'chars',
            'args': ['\n']
        },
        {
            'tokenType': 'done',
            'args': []
        }
    ]);
    return function (scope, options, nodeList) {
        var moduleOptions = { module: module };
        if (!(options instanceof mustacheCore.Options)) {
            options = new mustacheCore.Options(options || {});
        }
        return renderer(scope, options.add(moduleOptions), nodeList);
    };
});
/*can-connect@1.3.8#can/tag/tag_find_one_test.stache!steal-stache@3.0.5#steal-stache*/
define('can-connect@1.3.8#can/tag/tag_find_one_test.stache!steal-stache@3.0.5#steal-stache', [
    'module',
    'can-stache',
    'can-stache/src/mustache_core',
    'can-view-import@3.0.6#can-view-import',
    'can-stache-bindings@3.0.12#can-stache-bindings'
], function (module, stache, mustacheCore) {
    var renderer = stache([
        {
            'tokenType': 'start',
            'args': [
                'person-model',
                false
            ]
        },
        {
            'tokenType': 'attrStart',
            'args': ['get']
        },
        {
            'tokenType': 'attrValue',
            'args': ['{id=personId}']
        },
        {
            'tokenType': 'attrEnd',
            'args': ['get']
        },
        {
            'tokenType': 'end',
            'args': [
                'person-model',
                false
            ]
        },
        {
            'tokenType': 'chars',
            'args': ['\n\t']
        },
        {
            'tokenType': 'special',
            'args': ['#isPending']
        },
        {
            'tokenType': 'start',
            'args': [
                'span',
                false
            ]
        },
        {
            'tokenType': 'attrStart',
            'args': ['class']
        },
        {
            'tokenType': 'attrValue',
            'args': ['pending']
        },
        {
            'tokenType': 'attrEnd',
            'args': ['class']
        },
        {
            'tokenType': 'attrStart',
            'args': ['can-inserted']
        },
        {
            'tokenType': 'attrValue',
            'args': ['{pending}']
        },
        {
            'tokenType': 'attrEnd',
            'args': ['can-inserted']
        },
        {
            'tokenType': 'end',
            'args': [
                'span',
                false
            ]
        },
        {
            'tokenType': 'close',
            'args': ['span']
        },
        {
            'tokenType': 'special',
            'args': ['/isPending']
        },
        {
            'tokenType': 'chars',
            'args': ['\n\t']
        },
        {
            'tokenType': 'special',
            'args': ['#isResolved']
        },
        {
            'tokenType': 'start',
            'args': [
                'span',
                false
            ]
        },
        {
            'tokenType': 'attrStart',
            'args': ['class']
        },
        {
            'tokenType': 'attrValue',
            'args': ['resolved']
        },
        {
            'tokenType': 'attrEnd',
            'args': ['class']
        },
        {
            'tokenType': 'attrStart',
            'args': ['can-inserted']
        },
        {
            'tokenType': 'attrValue',
            'args': ['{resolved}']
        },
        {
            'tokenType': 'attrEnd',
            'args': ['can-inserted']
        },
        {
            'tokenType': 'attrStart',
            'args': ['pid']
        },
        {
            'tokenType': 'special',
            'args': ['value.id']
        },
        {
            'tokenType': 'attrEnd',
            'args': ['pid']
        },
        {
            'tokenType': 'end',
            'args': [
                'span',
                false
            ]
        },
        {
            'tokenType': 'special',
            'args': ['value.type']
        },
        {
            'tokenType': 'close',
            'args': ['span']
        },
        {
            'tokenType': 'special',
            'args': ['/isResolved']
        },
        {
            'tokenType': 'chars',
            'args': ['\n']
        },
        {
            'tokenType': 'close',
            'args': ['person-model']
        },
        {
            'tokenType': 'done',
            'args': []
        }
    ]);
    return function (scope, options, nodeList) {
        var moduleOptions = { module: module };
        if (!(options instanceof mustacheCore.Options)) {
            options = new mustacheCore.Options(options || {});
        }
        return renderer(scope, options.add(moduleOptions), nodeList);
    };
});
/*can-connect@1.3.8#can/tag/tag_test*/
define('can-connect@1.3.8#can/tag/tag_test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var CanMap = require('can-map');
    var CanList = require('can-list');
    var compute = require('can-compute');
    var $ = require('jquery');
    var superMap = require('can-connect/can/super-map/');
    var tag = require('can-connect/can/tag/');
    var fixture = require('can-fixture');
    var findAllTemplate = require('./tag_find_all_test.stache!');
    var findOneTemplate = require('./tag_find_one_test.stache!');
    require('can-util/dom/events/inserted/inserted');
    QUnit.module('can-connect/can/tag');
    QUnit.test('getList', function () {
        var Person = CanMap.extend({});
        Person.List = CanList.extend({ Map: Person }, {});
        var options = {
            url: '/api/people',
            Map: Person,
            List: Person.List,
            name: 'person'
        };
        var connection = superMap(options);
        options.cacheConnection.clear();
        tag('person-model', connection);
        fixture({
            'GET /api/people': function (request) {
                if (request.data.type === 'first') {
                    return {
                        data: [
                            {
                                id: 1,
                                type: 'first'
                            },
                            {
                                id: 2,
                                type: 'first'
                            }
                        ]
                    };
                } else {
                    return {
                        data: [
                            {
                                id: 3,
                                type: 'second'
                            },
                            {
                                id: 4,
                                type: 'second'
                            }
                        ]
                    };
                }
            }
        });
        var type = compute('first');
        stop();
        var resolvedCalls = 0;
        var frag = findAllTemplate({
            pending: function () {
                ok(true, 'called pending');
            },
            resolved: function (context, el) {
                resolvedCalls++;
                ok(true, 'called resolved');
                if (resolvedCalls === 1) {
                    ok(true, 'called resolved');
                    equal(el.childNodes[1].innerHTML, '1', 'added id');
                    setTimeout(function () {
                        type('second');
                    }, 1);
                } else {
                    ok(true, 'called resolved');
                    equal(el.childNodes[1].innerHTML, '3', 'added id');
                    $('#qunit-fixture').empty();
                    start();
                }
            },
            type: type
        });
        $('<div>').appendTo('#qunit-fixture').append(frag);
    });
    QUnit.test('get', function () {
        var Person = CanMap.extend({});
        Person.List = CanList.extend({ Map: Person }, {});
        var options = {
            url: '/api/people',
            Map: Person,
            List: Person.List,
            name: 'person'
        };
        var connection = superMap(options);
        options.cacheConnection.clear();
        tag('person-model', connection);
        fixture({
            'GET /api/people/{id}': function (request) {
                if (request.data.id === '1') {
                    return {
                        id: 1,
                        type: 'first'
                    };
                } else {
                    return {
                        id: 2,
                        type: 'second'
                    };
                }
            }
        });
        var personId = compute(1);
        stop();
        var resolvedCalls = 0;
        var frag = findOneTemplate({
            pending: function () {
                ok(true, 'called pending');
            },
            resolved: function (context, el) {
                resolvedCalls++;
                ok(true, 'called resolved');
                if (resolvedCalls === 1) {
                    ok(true, 'called resolved');
                    equal(el.innerHTML, 'first', 'added id');
                    setTimeout(function () {
                        personId(2);
                    }, 1);
                } else {
                    ok(true, 'called resolved');
                    equal(el.innerHTML, 'second', 'added id');
                    $('#qunit-fixture').empty();
                    start();
                }
            },
            personId: personId,
            rejected: function () {
                ok(false, 'rejected');
                start();
            }
        });
        $('<div>').appendTo('#qunit-fixture').append(frag);
    });
    if (System.env !== 'canjs-test') {
        QUnit.test('get fullCache', function (assert) {
            var done = assert.async();
            var resolvedCalls = 0;
            var Person = CanMap.extend({});
            Person.List = CanList.extend({ Map: Person }, {});
            var options = {
                url: '/api/people',
                Map: Person,
                List: Person.List,
                name: 'person'
            };
            var connection = superMap(options);
            connection.cacheConnection.clear();
            tag('person-model', connection);
            fixture({
                'GET /api/people/{id}': function (request) {
                    if (request.data.id === '1') {
                        ok(resolvedCalls >= 1, 'got data we already resolved from cache');
                        return {
                            id: 1,
                            type: 'first'
                        };
                    } else {
                        ok(resolvedCalls >= 2, 'got data we already resolved from cache');
                        setTimeout(function () {
                            done();
                        }, 100);
                        return {
                            id: 2,
                            type: 'second'
                        };
                    }
                },
                'GET /api/people': function (request) {
                    return {
                        data: [
                            {
                                id: 1,
                                type: 'first'
                            },
                            {
                                id: 2,
                                type: 'second'
                            }
                        ]
                    };
                }
            });
            connection.getList({}).then(function () {
                var personId = compute(1);
                var frag = findOneTemplate({
                    pending: function () {
                        ok(true, 'called pending');
                    },
                    resolved: function (context, el) {
                        resolvedCalls++;
                        ok(true, 'called resolved');
                        if (resolvedCalls === 1) {
                            equal(el.innerHTML, 'first', 'first id');
                            setTimeout(function () {
                                personId(2);
                                setTimeout(function () {
                                    equal($('person-model .resolved').text(), 'second', 'updated id');
                                    $('#qunit-fixture').empty();
                                }, 20);
                            }, 1);
                        } else {
                            ok(true, 'not called immediately, because .then cant be with Promises');
                        }
                    },
                    personId: personId,
                    rejected: function () {
                        ok(false, 'rejected');
                        start();
                    }
                });
                $('<div>').appendTo('#qunit-fixture').append(frag);
            });
        });
    }
});
/*can-connect@1.3.8#can/constructor-hydrate/constructor-hydrate*/
define('can-connect@1.3.8#can/constructor-hydrate/constructor-hydrate', function (require, exports, module) {
    var connect = require('can-connect');
    var Construct = require('can-construct');
    module.exports = connect.behavior('can-connect/can/construct-hydrate', function (baseConnect) {
        return {
            init: function () {
                var oldSetup = this.Map.prototype.setup;
                var connection = this;
                this.Map.prototype.setup = function (props) {
                    if (connection.instanceStore.has(connection.id(props))) {
                        return new Construct.ReturnValue(connection.hydrateInstance(props));
                    }
                    return oldSetup.apply(this, arguments);
                };
                baseConnect.init.apply(this, arguments);
            }
        };
    });
});
/*can-connect@1.3.8#can/constructor-hydrate/constructor-hydrate-test*/
define('can-connect@1.3.8#can/constructor-hydrate/constructor-hydrate-test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var DefineMap = require('can-define/map/map');
    var DefineList = require('can-define/list/list');
    var connect = require('can-connect');
    var constructorBehavior = require('can-connect/constructor/constructor');
    var constructorStore = require('can-connect/constructor/store/store');
    var mapBehavior = require('can-connect/can/map/map');
    var hydrateBehavior = require('can-connect/can/constructor-hydrate/constructor-hydrate');
    QUnit.module('can-connect/can/constructor-hydrate');
    QUnit.test('basics', function () {
        var Hub = DefineMap.extend({});
        Hub.List = DefineList.extend({ '#': { Type: Hub } });
        var HubConnection = connect([
            constructorBehavior,
            constructorStore,
            mapBehavior,
            hydrateBehavior
        ], {
            Map: Hub,
            List: Hub.List
        });
        var myPage = new (DefineMap.extend({
            hub: { Type: Hub },
            hub2: { Type: Hub }
        }))();
        myPage.hub = {
            id: 1,
            name: 'One'
        };
        HubConnection.addInstanceReference(myPage.hub);
        QUnit.equal(myPage.hub, HubConnection.instanceStore.get(1), 'Should be the same instance');
        myPage.hub2 = {
            id: 1,
            name: 'OnePlus'
        };
        QUnit.equal(myPage.hub2, HubConnection.instanceStore.get(1), 'Should also be the same instance');
        QUnit.equal(myPage.hub2, myPage.hub, 'Both properties refer to the same instance');
        QUnit.equal(myPage.hub.name, 'OnePlus', 'The name of the 1st property should be changed since its the same instance now');
    });
    QUnit.test('Two objects with no id', function () {
        var Hub = DefineMap.extend({});
        Hub.List = DefineList.extend({ '#': { Type: Hub } });
        var HubConnection = connect([
            constructorBehavior,
            constructorStore,
            mapBehavior,
            hydrateBehavior
        ], {
            Map: Hub,
            List: Hub.List
        });
        var hub1 = new Hub({ name: 'One' });
        HubConnection.addInstanceReference(hub1);
        QUnit.ok(!HubConnection.instanceStore.has(undefined), 'The instanceStore should not have an "undefined" key item');
        var hub2 = new Hub({ name: 'One' });
        QUnit.ok(true, 'Should allow to create two instances without an id (no Max Call Stack error)');
    });
});
/*can-connect@1.3.8#can/test*/
define('can-connect@1.3.8#can/test', function (require, exports, module) {
    require('./map/map_test');
    require('./map/define-map-test');
    require('./model/model_test');
    require('./ref/ref-test');
    require('./super-map/super-map_test');
    require('./base-map/base-map_test');
    require('./tag/tag_test');
    require('./constructor-hydrate/constructor-hydrate-test');
});
/*can-connect@1.3.8#constructor/callbacks-once/callbacks-once_test*/
define('can-connect@1.3.8#constructor/callbacks-once/callbacks-once_test', function (require, exports, module) {
    var connect = require('can-connect/can-connect');
    var QUnit = require('steal-qunit');
    var realTime = require('can-connect/real-time/');
    var constructor = require('can-connect/constructor/');
    var constructorStore = require('can-connect/constructor/store/');
    var canMap = require('can-connect/can/map/');
    var dataCallbacks = require('can-connect/data/callbacks/');
    var callbacksOnce = require('can-connect/constructor/callbacks-once/');
    var DefineMap = require('can-define/map/');
    require('can-define/list/list');
    QUnit.module('can-connect/callbacks-once');
    QUnit.test('createInstance triggers a "created" event', function (assert) {
        var done = assert.async();
        var Session = DefineMap.extend({
            id: 'any',
            email: 'string'
        });
        var connection = connect([
            constructor,
            canMap,
            constructorStore,
            dataCallbacks,
            realTime,
            callbacksOnce
        ], { Map: Session });
        Session.on('created', function (event) {
            assert.ok(event, 'createInstance triggered the "created" event');
            done();
        });
        connection.createInstance({
            id: 5,
            email: 'marshall@bitovi.com'
        });
    });
    QUnit.test('different methods should not refer to the same last item', function () {
        function Session(data) {
            this.id = data.id;
            this.email = data.email;
        }
        var createdCalled = 0;
        var destroyedCalled = 0;
        Session.connection = connect([
            constructorStore,
            {
                id: function (instance) {
                    return instance.id;
                },
                createdInstance: function (instance, data) {
                    this.addInstanceReference(instance);
                    createdCalled++;
                },
                destroyedInstance: function (instance, data) {
                    destroyedCalled++;
                }
            },
            callbacksOnce
        ], { Map: Session });
        var data = {
            id: 100,
            email: 'ilya@bitovi.com'
        };
        var instance = new Session(data);
        Session.connection.createdInstance(instance, data);
        Session.connection.createdInstance(instance, data);
        Session.connection.destroyedInstance(instance, data);
        Session.connection.destroyedInstance(instance, data);
        QUnit.equal(createdCalled, 1, 'created event should be called once');
        QUnit.equal(destroyedCalled, 1, 'destroyed event should be called once');
    });
});
/*can-connect@1.3.8#constructor/constructor_test*/
define('can-connect@1.3.8#constructor/constructor_test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var fixture = require('can-fixture');
    var persist = require('can-connect/data/url/');
    var connect = require('can-connect/can-connect');
    var constructor = require('can-connect/constructor/');
    var assign = require('can-util/js/assign/assign');
    var logErrorAndStart = function (e) {
        ok(false, 'Error ' + e);
        start();
    };
    var makeIframe = function (src) {
        var iframe = document.createElement('iframe');
        window.removeMyself = function () {
            delete window.removeMyself;
            document.body.removeChild(iframe);
            QUnit.start();
        };
        document.body.appendChild(iframe);
        iframe.src = src;
    };
    QUnit.module('can-connect/constructor', {
        setup: function () {
            fixture({
                'GET /constructor/people': function () {
                    return [{ id: 1 }];
                },
                'GET /constructor/people/{id}': function (request) {
                    return { id: +request.data.id };
                },
                'POST /constructor/people': function () {
                    return { id: 3 };
                },
                'PUT /constructor/people/{id}': function (request) {
                    equal(request.data.id, 3, 'update id!');
                    return { update: true };
                },
                'DELETE /constructor/people/{id}': function (request) {
                    equal(request.data.id, 3, 'update id');
                    return { destroy: true };
                }
            });
            fixture.delay = 1;
        }
    });
    QUnit.test('basics', function () {
        var Person = function (values) {
            assign(this, values);
        };
        var PersonList = function (people) {
            var listed = people.slice(0);
            listed.isList = true;
            return listed;
        };
        var peopleConnection = constructor(persist(connect.base({
            instance: function (values) {
                return new Person(values);
            },
            list: function (arr) {
                return new PersonList(arr.data);
            },
            url: '/constructor/people'
        })));
        stop();
        peopleConnection.getList().then(function (people) {
            ok(people.isList, 'is a list');
            equal(people.length, 1, 'got a list');
            ok(people[0] instanceof Person);
            start();
        }, logErrorAndStart);
        stop();
        peopleConnection.get({ id: 5 }).then(function (person) {
            equal(person.id, 5, 'got a list');
            ok(person instanceof Person);
            start();
        }, logErrorAndStart);
        var p = new Person({ name: 'justin' });
        stop();
        peopleConnection.save(p).then(function (updatedP) {
            equal(p, updatedP, 'same instances');
            equal(p.id, 3);
            start();
        });
        var p2 = new Person({
            name: 'justin',
            id: 3
        });
        stop();
        peopleConnection.save(p2).then(function (updatedP) {
            equal(p2, updatedP, 'same instances');
            equal(p2.update, true);
            start();
        }, logErrorAndStart);
        var p3 = new Person({
            name: 'justin',
            id: 3
        });
        stop();
        peopleConnection.destroy(p3).then(function (updatedP) {
            equal(p3, updatedP, 'same instances');
            equal(p3.destroy, true);
            start();
        }, logErrorAndStart);
    });
});
/*can-connect@1.3.8#constructor/store/store_test*/
define('can-connect@1.3.8#constructor/store/store_test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var fixture = require('can-fixture');
    var persist = require('can-connect/data/url/');
    var constructor = require('can-connect/constructor/');
    var instanceStore = require('can-connect/constructor/store/');
    var connect = require('can-connect/can-connect');
    var testHelpers = require('can-connect/test-helpers');
    var assign = require('can-util/js/assign/assign');
    QUnit.module('can-connect/constructor/store', {
        setup: function () {
        }
    });
    QUnit.test('instance reference is updated and then discarded after reference is deleted', function () {
        fixture({
            'GET /constructor/people': function () {
                return [{
                        id: 1,
                        age: 32
                    }];
            },
            'GET /constructor/people/{id}': function (request) {
                return { id: +request.data.id };
            },
            'POST /constructor/people': function () {
                return { id: 3 };
            },
            'PUT /constructor/people/{id}': function (request) {
                equal(request.data.id, 3, 'update id!');
                return { update: true };
            },
            'DELETE /constructor/people/{id}': function (request) {
                equal(request.data.id, 3, 'update id');
                return { destroy: true };
            }
        });
        fixture.delay = 1;
        var Person = function (values) {
            assign(this, values);
        };
        var PersonList = function (people) {
            var listed = people.slice(0);
            listed.isList = true;
            return listed;
        };
        var peopleConnection = connect([
            persist,
            constructor,
            instanceStore
        ], {
            url: {
                getListData: '/constructor/people',
                getData: '/constructor/people/{id}',
                createData: '/constructor/people',
                updateData: '/constructor/people/{id}',
                destroyData: '/constructor/people/{id}'
            },
            instance: function (values) {
                return new Person(values);
            },
            list: function (arr) {
                return new PersonList(arr.data);
            },
            updatedList: function (list, updatedList, set) {
                list.splice(0, list.length, updatedList.data);
            }
        });
        var person = new Person({
            id: 1,
            name: 'Justin'
        });
        peopleConnection.addInstanceReference(person);
        stop();
        peopleConnection.getList({}).then(function (people) {
            equal(people[0], person, 'same instances');
            equal(person.age, 32, 'age property added');
            setTimeout(function () {
                peopleConnection.deleteInstanceReference(person);
                peopleConnection.getList({}).then(function (people) {
                    ok(people[0] !== person, 'not the same instances');
                    equal(people[0].age, 32, 'age property from data');
                    ok(!people[0].name, 'does not have name');
                    start();
                }, testHelpers.logErrorAndStart);
            }, 1);
        }, testHelpers.logErrorAndStart);
    });
    QUnit.test('list store is kept and re-used and possibly discarded', function () {
        var Person = function (values) {
            assign(this, values);
        };
        var PersonList = function (people, sets) {
            var listed = people.slice(0);
            listed.isList = true;
            listed.__listSet = sets;
            return listed;
        };
        var connection = connect([
            function () {
                var calls = 0;
                return {
                    getListData: function () {
                        calls++;
                        if (calls === 1) {
                            return testHelpers.asyncResolve({
                                data: [
                                    { id: 0 },
                                    { id: 1 }
                                ]
                            });
                        } else if (calls === 2) {
                            return testHelpers.asyncResolve({
                                data: [
                                    { id: 1 },
                                    { id: 2 }
                                ]
                            });
                        } else {
                            return testHelpers.asyncResolve({ data: [] });
                        }
                    },
                    updatedList: function (list, updatedList, set) {
                        list.splice.apply(list, [
                            0,
                            list.length
                        ].concat(updatedList.data));
                    }
                };
            },
            instanceStore,
            constructor
        ], {
            instance: function (values) {
                return new Person(values);
            },
            list: function (arr, sets) {
                return new PersonList(arr.data, sets);
            }
        });
        var resolvedList;
        connection.getList({}).then(function (list) {
            resolvedList = list;
            connection.addListReference(list);
            setTimeout(checkStore, 1);
        }, testHelpers.logErrorAndStart);
        stop();
        function checkStore() {
            connection.getList({}).then(function (list) {
                equal(list, resolvedList);
                equal(list.length, 2);
                equal(list[0].id, 1);
                equal(list[1].id, 2);
                connection.deleteListReference(list);
                setTimeout(checkEmpty, 1);
            }, testHelpers.logErrorAndStart);
        }
        function checkEmpty() {
            connection.getList({}).then(function (list) {
                ok(list !== resolvedList);
                start();
            }, testHelpers.logErrorAndStart);
        }
    });
    QUnit.test('list\'s without a listSet are not added to the store', function () {
        var Person = function (values) {
            assign(this, values);
        };
        var PersonList = function (people, sets) {
            var listed = people.slice(0);
            listed.isList = true;
            listed.__listSet = sets;
            return listed;
        };
        var connection = connect([
            function () {
                var calls = 0;
                return {
                    getListData: function () {
                        calls++;
                        if (calls === 1) {
                            return testHelpers.asyncResolve({
                                data: [
                                    { id: 0 },
                                    { id: 1 }
                                ]
                            });
                        } else if (calls === 2) {
                            return testHelpers.asyncResolve({
                                data: [
                                    { id: 1 },
                                    { id: 2 }
                                ]
                            });
                        } else {
                            return testHelpers.asyncResolve({ data: [] });
                        }
                    },
                    updatedList: function (list, updatedList, set) {
                        list.splice.apply(list, [
                            0,
                            list.length
                        ].concat(updatedList.data));
                    }
                };
            },
            instanceStore,
            constructor
        ], {
            instance: function (values) {
                return new Person(values);
            },
            list: function (arr, sets) {
                return new PersonList(arr.data, sets);
            }
        });
        connection.addListReference([]);
        connection.listStore.forEach(function () {
            ok(false);
        });
        QUnit.expect(0);
    });
    QUnit.test('pending requests should be shared by all connections (#115)', function () {
        var Address = function (values) {
            assign(this, values);
        };
        var addressConnection = connect([
            persist,
            constructor,
            instanceStore
        ], {
            instance: function (values) {
                return new Address(values);
            }
        });
        var Person = function (values) {
            values.address = addressConnection.hydrateInstance(values.address);
            assign(this, values);
        };
        var peopleConnection = connect([
            persist,
            constructor,
            instanceStore
        ], {
            url: {
                getListData: function () {
                    return Promise.resolve({
                        data: [
                            {
                                id: 1,
                                name: 'Justin Meyer',
                                address: {
                                    id: 5,
                                    street: '2060 stave'
                                }
                            },
                            {
                                id: 2,
                                name: 'Ramiya Meyer',
                                address: {
                                    id: 5,
                                    street: '2060 stave'
                                }
                            }
                        ]
                    });
                }
            },
            instance: function (values) {
                return new Person(values);
            }
        });
        QUnit.stop();
        peopleConnection.getList({}).then(function (people) {
            QUnit.ok(people[0].address === people[1].address);
            QUnit.start();
        });
    });
});
/*can-connect@1.3.8#data/url/data-url_test*/
define('can-connect@1.3.8#data/url/data-url_test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var fixture = require('can-fixture');
    var persist = require('can-connect/data/url/');
    var $ = require('jquery');
    QUnit.module('can-connect/data/url', {
        setup: function () {
            fixture.delay = 1;
        }
    });
    QUnit.test('basics', function (assert) {
        var connection = persist({
            url: {
                getListData: 'POST /getList',
                getData: 'DELETE /getInstance',
                createData: 'GET /create',
                updateData: 'GET /update/{id}',
                destroyData: 'GET /delete/{id}'
            }
        });
        fixture({
            'POST /getList': function () {
                return [{ id: 1 }];
            },
            'DELETE /getInstance': function () {
                return { id: 2 };
            },
            'GET /create': function () {
                return { id: 3 };
            },
            'GET /update/{id}': function (request) {
                equal(request.data.id, 3, 'update id');
                return { update: true };
            },
            'GET /delete/{id}': function (request) {
                equal(request.data.id, 3, 'update id');
                return { destroy: true };
            }
        });
        stop();
        connection.getListData({ foo: 'bar' }).then(function (items) {
            deepEqual(items, [{ id: 1 }], 'getList');
            start();
        });
        stop();
        connection.getData({ foo: 'bar' }).then(function (data) {
            deepEqual(data, { id: 2 }, 'getInstance');
            start();
        });
        stop();
        connection.createData({ foo: 'bar' }).then(function (data) {
            deepEqual(data, { id: 3 }, 'create');
            start();
        });
        stop();
        connection.destroyData({
            foo: 'bar',
            id: 3
        }).then(function (data) {
            deepEqual(data, { destroy: true }, 'update');
            start();
        });
    });
    QUnit.test('idProp is not part of the parameters', function () {
        var connection = persist({
            idProp: 'id',
            url: 'api/todos/'
        });
        fixture({
            'GET api/todos/2': function (req) {
                ok(!req.data.id);
                deepEqual(req.data, { other: 'prop' });
                return [{ id: 1 }];
            }
        });
        stop();
        connection.getData({
            id: 2,
            other: 'prop'
        }).then(function () {
            start();
        });
    });
    QUnit.test('destroyData()', function () {
        var connection = persist({
            idProp: 'id',
            url: '/api/todos'
        });
        fixture('DELETE /api/todos/3', function (req) {
            notEqual(req.data.other, 'prop', 'don\'t include it');
            return {};
        });
        stop();
        connection.destroyData({
            id: 3,
            other: 'prop'
        }).then(function () {
            start();
        });
    });
    QUnit.test('Ajax requests should default to \'application/json\' (#134)', function () {
        var connection = persist({
            url: '/api/restaurants',
            idProp: '_id'
        });
        fixture({
            'POST /api/restaurants': function (request) {
                if (typeof request.data === 'object') {
                    ok(true);
                } else {
                    ok(false);
                }
                return request.data;
            }
        });
        stop();
        connection.createData({ foo: 'bar' }).then(function () {
            start();
        });
    });
    QUnit.test('contentType can be form-urlencoded (#134)', function () {
        var connection = persist({
            url: {
                createData: 'POST /api/restaurants',
                contentType: 'application/x-www-form-urlencoded'
            }
        });
        fixture({
            'POST /api/restaurants': function (request) {
                if (typeof request.data === 'object') {
                    ok(true);
                } else {
                    ok(false);
                }
                return request.data;
            }
        });
        stop();
        connection.createData({ foo: 'bar' }).then(function () {
            start();
        });
    });
    QUnit.test('getting a real Promise back with functions', function () {
        var connection = persist({
            url: {
                getListData: function () {
                    return $.get('GET /getList');
                },
                getData: function () {
                    return $.get('GET /getInstance/{id}');
                }
            }
        });
        fixture({
            'GET /getList': function () {
                return [{ id: 1 }];
            },
            'GET /getInstance/{id}': function () {
                return { id: 2 };
            }
        });
        ok(connection.getListData({ foo: 'bar' }).catch, 'getListData Promise has a catch method');
        ok(!connection.getListData({ foo: 'bar' }).fail, 'getListData Promise does not have a fail method');
        ok(connection.getData({
            foo: 'bar',
            id: 2
        }).catch, 'getData Promise has a catch method');
        ok(!connection.getData({
            foo: 'bar',
            id: 2
        }).fail, 'getData Promise does not have a fail method');
    });
    QUnit.test('getting a real Promise back with object using makeAjax', function () {
        var connection = persist({
            url: {
                getListData: {
                    type: 'get',
                    url: '/getList'
                },
                getData: {
                    type: 'get',
                    url: '/getList'
                }
            }
        });
        fixture({
            'GET /getList': function () {
                return [{ id: 1 }];
            },
            'GET /getInstance/{id}': function () {
                return { id: 2 };
            }
        });
        ok(connection.getListData({ foo: 'bar' }).catch, 'getListData Promise has a catch method');
        ok(!connection.getListData({ foo: 'bar' }).fail, 'getListData Promise does not have a fail method');
        ok(connection.getData({
            foo: 'bar',
            id: 2
        }).catch, 'getData Promise has a catch method');
        ok(!connection.getData({
            foo: 'bar',
            id: 2
        }).fail, 'getData Promise does not have a fail method');
    });
    QUnit.test('getting a real Promise back with objects using makeAjax setting this.ajax', function () {
        var connection = persist({
            url: {
                getListData: {
                    type: 'get',
                    url: '/getList'
                },
                getData: {
                    type: 'get',
                    url: '/getList'
                }
            },
            ajax: $.ajax
        });
        fixture({
            'GET /getList': function () {
                return [{ id: 1 }];
            },
            'GET /getInstance/{id}': function () {
                return { id: 2 };
            }
        });
        ok(connection.getListData({ foo: 'bar' }).catch, 'getListData Promise has a catch method');
        ok(!connection.getListData({ foo: 'bar' }).fail, 'getListData Promise does not have a fail method');
        ok(connection.getData({
            foo: 'bar',
            id: 2
        }).catch, 'getData Promise has a catch method');
        ok(!connection.getData({
            foo: 'bar',
            id: 2
        }).fail, 'getData Promise does not have a fail method');
    });
});
/*can-connect@1.3.8#data/parse/parse_test*/
define('can-connect@1.3.8#data/parse/parse_test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var fixture = require('can-fixture');
    var connect = require('can-connect');
    var dataUrl = require('can-connect/data/url/'), dataParse = require('can-connect/data/parse/');
    QUnit.module('can-connect/data-parse', {
        setup: function () {
            fixture.delay = 1;
        }
    });
    var logErrorAndStart = function (e) {
        ok(false, 'Error ' + e);
        start();
    };
    QUnit.test('basics', function (assert) {
        var connection = connect([
            dataUrl,
            dataParse
        ], {
            url: {
                getListData: 'POST /getList',
                getData: 'DELETE /getInstance',
                createData: 'GET /create',
                updateData: 'GET /update/{id}',
                destroyData: 'GET /delete/{id}'
            },
            parseListProp: 'items',
            parseInstanceProp: 'datas'
        });
        fixture({
            'POST /getList': function () {
                return { items: [{ id: 1 }] };
            },
            'DELETE /getInstance': function () {
                return { datas: { id: 2 } };
            },
            'GET /create': function () {
                return { datas: { id: 3 } };
            },
            'GET /update/{id}': function (request) {
                equal(request.data.id, 3, 'update id');
                return { datas: { update: true } };
            },
            'GET /delete/{id}': function (request) {
                equal(request.data.id, 3, 'update id');
                return { datas: { destroy: true } };
            }
        });
        stop();
        connection.getListData({ foo: 'bar' }).then(function (items) {
            deepEqual(items, { data: [{ id: 1 }] }, 'getList');
            start();
        }, logErrorAndStart);
        stop();
        connection.getData({ foo: 'bar' }).then(function (data) {
            deepEqual(data, { id: 2 }, 'getInstance');
            start();
        }, logErrorAndStart);
        stop();
        connection.createData({ foo: 'bar' }).then(function (data) {
            deepEqual(data, { id: 3 }, 'create');
            start();
        }, logErrorAndStart);
        stop();
        connection.destroyData({
            foo: 'bar',
            id: 3
        }).then(function (data) {
            deepEqual(data, { destroy: true }, 'update');
            start();
        }, logErrorAndStart);
    });
    test('parseListData and parseInstanceData don\'t use options correctly (#27)', function () {
        var connection = connect([
            dataUrl,
            dataParse
        ], {
            url: {
                getListData: 'POST /getList',
                getData: 'DELETE /getInstance',
                createData: 'GET /create',
                updateData: 'GET /update/{id}',
                destroyData: 'GET /delete/{id}'
            },
            parseListData: function (responseData) {
                return responseData.items;
            },
            parseInstanceData: function (responseData) {
                return responseData.datas;
            }
        });
        fixture({
            'POST /getList': function () {
                return { items: [{ id: 1 }] };
            },
            'DELETE /getInstance': function () {
                return { datas: { id: 2 } };
            },
            'GET /create': function () {
                return { datas: { id: 3 } };
            },
            'GET /update/{id}': function (request) {
                equal(request.data.id, 3, 'update id');
                return { datas: { update: true } };
            },
            'GET /delete/{id}': function (request) {
                equal(request.data.id, 3, 'update id');
                return { datas: { destroy: true } };
            }
        });
        stop();
        connection.getListData({ foo: 'bar' }).then(function (items) {
            deepEqual(items, { data: [{ id: 1 }] }, 'getList');
            start();
        }, logErrorAndStart);
        stop();
        connection.getData({ foo: 'bar' }).then(function (data) {
            deepEqual(data, { id: 2 }, 'getInstance');
            start();
        }, logErrorAndStart);
    });
});
/*can-connect@1.3.8#data/callbacks-cache/callbacks-cache-test*/
define('can-connect@1.3.8#data/callbacks-cache/callbacks-cache-test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var callbacksCache = require('can-connect/data/callbacks-cache/');
    QUnit.module('can-connect/data/callbacks-cache', {
        setup: function () {
        }
    });
    QUnit.test('if the server responds with success, the callbacks still get passed the original object', function () {
        var cacheConnection = {
            createData: function (data) {
                QUnit.deepEqual(data, {
                    id: 1,
                    foo: 'bar'
                });
            },
            updateData: function (data) {
                QUnit.deepEqual(data, {
                    foo: 'bar',
                    id: 1,
                    createdAt: 3
                });
            },
            destroyData: function (data) {
                QUnit.deepEqual(data, {
                    foo: 'bar',
                    id: 1,
                    createdAt: 4
                });
            }
        };
        var connection = callbacksCache({
            cacheConnection: cacheConnection,
            keepMissingProperties: true,
            createdData: function () {
            },
            updatedData: function () {
            },
            destroyedData: function () {
            }
        });
        connection.createdData({ id: 1 }, { foo: 'bar' });
        connection.updatedData({ createdAt: 3 }, {
            foo: 'bar',
            id: 1,
            createdAt: 2
        });
        connection.destroyedData({ createdAt: 4 }, {
            foo: 'bar',
            id: 1,
            createdAt: 3
        });
    });
});
/*can-connect@1.3.8#data/combine-requests/combine-requests_test*/
define('can-connect@1.3.8#data/combine-requests/combine-requests_test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var combineRequests = require('can-connect/data/combine-requests/');
    var set = require('can-set');
    var map = [].map;
    var getId = function (d) {
        return d.id;
    };
    QUnit.module('can-connect', {
        setup: function () {
        }
    });
    QUnit.test('basics', function () {
        stop();
        var count = 0;
        var res = combineRequests({
            getListData: function (params) {
                deepEqual(params, {}, 'called for everything');
                count++;
                equal(count, 1, 'only called once');
                return Promise.resolve([
                    {
                        id: 1,
                        type: 'critical',
                        due: 'today'
                    },
                    {
                        id: 2,
                        type: 'notcritical',
                        due: 'today'
                    },
                    {
                        id: 3,
                        type: 'critical',
                        due: 'yesterday'
                    },
                    { id: 4 },
                    {
                        id: 5,
                        type: 'critical'
                    },
                    {
                        id: 6,
                        due: 'yesterday'
                    }
                ]);
            }
        });
        var p1 = res.getListData({ type: 'critical' });
        var p2 = res.getListData({ due: 'today' });
        var p3 = res.getListData();
        Promise.all([
            p1,
            p2,
            p3
        ]).then(function (result) {
            var res1 = result[0], res2 = result[1], res3 = result[2];
            deepEqual(map.call(res1.data, getId), [
                1,
                3,
                5
            ]);
            deepEqual(map.call(res2.data, getId), [
                1,
                2
            ]);
            deepEqual(map.call(res3.data, getId), [
                1,
                2,
                3,
                4,
                5,
                6
            ]);
            start();
        }, function (error) {
            ok(false, error);
            start();
        });
    });
    QUnit.test('ranges', function () {
        stop();
        var count = 0;
        var res = combineRequests({
            getListData: function (params) {
                deepEqual(params, {
                    start: 0,
                    end: 5
                }, 'called for everything');
                count++;
                equal(count, 1, 'only called once');
                return Promise.resolve([
                    {
                        id: 1,
                        type: 'critical',
                        due: 'today'
                    },
                    {
                        id: 2,
                        type: 'notcritical',
                        due: 'today'
                    },
                    {
                        id: 3,
                        type: 'critical',
                        due: 'yesterday'
                    },
                    { id: 4 },
                    {
                        id: 5,
                        type: 'critical'
                    },
                    {
                        id: 6,
                        due: 'yesterday'
                    }
                ]);
            },
            algebra: set.comparators.rangeInclusive('start', 'end')
        });
        var p1 = res.getListData({
            start: 0,
            end: 3
        });
        var p2 = res.getListData({
            start: 2,
            end: 5
        });
        Promise.all([
            p1,
            p2
        ]).then(function (result) {
            var res1 = result[0], res2 = result[1];
            deepEqual(map.call(res1.data, getId), [
                1,
                2,
                3,
                4
            ]);
            deepEqual(map.call(res2.data, getId), [
                3,
                4,
                5,
                6
            ]);
            start();
        });
    });
    QUnit.test('Rejects when getListData rejects', function () {
        stop();
        var res = combineRequests({
            getListData: function () {
                return Promise.reject(new Error('didn\'t work'));
            }
        });
        var promise = res.getListData({
            start: 0,
            end: 3
        });
        promise.then(null, function (err) {
            equal(err.message, 'didn\'t work', 'promise was rejected');
            start();
        });
    });
    QUnit.test('getListData mutates the set #139', function (assert) {
        var count = 0;
        var done = assert.async();
        var res = combineRequests({
            getListData: function (set) {
                if (!set.$sort) {
                    set.$sort = { type: 'critical' };
                }
                count += 1;
                assert.equal(count, 1, 'should be called only once');
                return Promise.resolve([
                    {
                        id: 1,
                        type: 'critical',
                        due: 'today'
                    },
                    {
                        id: 3,
                        type: 'critical',
                        due: 'yesterday'
                    },
                    {
                        id: 5,
                        type: 'critical'
                    }
                ]);
            }
        });
        var p1 = res.getListData({});
        var p2 = res.getListData({});
        Promise.all([
            p1,
            p2
        ]).then(function (result) {
            var p1Data = result[0].data;
            var p2Data = result[1].data;
            assert.ok(Array.isArray(p1Data), 'should be an array');
            assert.ok(Array.isArray(p2Data), 'should be an array');
        }).then(done, done);
    });
});
/*can-connect@1.3.8#data/localstorage-cache/localstorage-cache_test*/
define('can-connect@1.3.8#data/localstorage-cache/localstorage-cache_test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var dataLocalStorage = require('can-connect/data/localstorage-cache/');
    var connect = require('can-connect');
    var canSet = require('can-set');
    var logErrorAndStart = function (e) {
        ok(false, 'Error ' + e);
        start();
    };
    var items = [
        {
            id: 1,
            foo: 'bar'
        },
        {
            id: 2,
            foo: 'bar'
        },
        {
            id: 3,
            foo: 'bar'
        }
    ];
    var aItems = [
        {
            id: 10,
            name: 'A'
        },
        {
            id: 11,
            name: 'A'
        },
        {
            id: 12,
            name: 'A'
        }
    ];
    QUnit.module('can-connect/data-localstorage-cache', {
        setup: function () {
            this.connection = connect([dataLocalStorage], { name: 'todos' });
            this.connection.clear();
        }
    });
    QUnit.test('updateListData', function () {
        var items = [
            {
                id: 1,
                foo: 'bar'
            },
            {
                id: 2,
                foo: 'bar'
            },
            {
                id: 3,
                foo: 'bar'
            }
        ];
        var connection = this.connection;
        stop();
        connection.getListData({ foo: 'bar' }).then(function () {
            ok(false, 'should have rejected, nothing there');
            start();
        }, function () {
            connection.updateListData({ data: items.slice(0) }, { foo: 'bar' }).then(function () {
                connection.getListData({ foo: 'bar' }).then(function (listData) {
                    deepEqual(listData.data, items);
                    start();
                }, logErrorAndStart);
            }, logErrorAndStart);
        });
    });
    QUnit.test('updateData', function () {
        var connection = this.connection;
        stop();
        var a1 = connection.updateListData({ data: items.slice(0) }, { foo: 'bar' });
        var a2 = connection.updateListData({ data: aItems.slice(0) }, { name: 'A' });
        Promise.all([
            a1,
            a2
        ]).then(updateItem, logErrorAndStart);
        function updateItem() {
            connection.updateData({
                id: 4,
                foo: 'bar'
            }).then(checkItems, logErrorAndStart);
        }
        function checkItems() {
            connection.getListData({ foo: 'bar' }).then(function (listData) {
                deepEqual(listData.data, items.concat({
                    id: 4,
                    foo: 'bar'
                }), 'updateData added item 4');
                updateItem2();
            }, logErrorAndStart);
        }
        function updateItem2() {
            connection.updateData({
                id: 4,
                name: 'A'
            }).then(checkItems2, logErrorAndStart);
        }
        function checkItems2() {
            connection.getListData({ foo: 'bar' }).then(function (listData) {
                deepEqual(listData.data, items, 'item 4 no longer in foo');
                checkItems3();
            }, logErrorAndStart);
        }
        function checkItems3() {
            connection.getListData({ name: 'A' }).then(function (listData) {
                deepEqual(listData.data, aItems.concat([{
                        id: 4,
                        name: 'A'
                    }]), 'id 4 should now have name A');
                start();
            }, logErrorAndStart);
        }
    });
    QUnit.test('createData', function () {
        var connection = this.connection;
        stop();
        var a1 = connection.updateListData({ data: items.slice(0) }, { foo: 'bar' });
        var a2 = connection.updateListData({ data: aItems.slice(0) }, { name: 'A' });
        Promise.all([
            a1,
            a2
        ]).then(createItem, logErrorAndStart);
        function createItem() {
            connection.createData({
                id: 4,
                foo: 'bar'
            }).then(checkItems, logErrorAndStart);
        }
        function checkItems() {
            connection.getListData({ foo: 'bar' }).then(function (listData) {
                deepEqual(listData.data, items.concat({
                    id: 4,
                    foo: 'bar'
                }), 'updateData added item 4');
                createItem2();
            }, logErrorAndStart);
        }
        function createItem2() {
            connection.updateData({
                id: 5,
                name: 'A'
            }).then(checkItems2, logErrorAndStart);
        }
        function checkItems2() {
            connection.getListData({ foo: 'bar' }).then(function (listData) {
                deepEqual(listData.data, items.concat({
                    id: 4,
                    foo: 'bar'
                }), 'item 4 sill in foo');
                checkItems3();
            }, logErrorAndStart);
        }
        function checkItems3() {
            connection.getListData({ name: 'A' }).then(function (listData) {
                deepEqual(listData.data, aItems.concat([{
                        id: 5,
                        name: 'A'
                    }]));
                start();
            }, logErrorAndStart);
        }
    });
    QUnit.test('destroyData', function () {
        var connection = this.connection;
        stop();
        var a1 = connection.updateListData({ data: items.slice(0) }, { foo: 'bar' });
        var a2 = connection.updateListData({ data: aItems.slice(0) }, { name: 'A' });
        Promise.all([
            a1,
            a2
        ]).then(destroyItem, logErrorAndStart);
        function destroyItem() {
            connection.destroyData({
                id: 1,
                foo: 'bar'
            }).then(checkItems, logErrorAndStart);
        }
        function checkItems() {
            connection.getListData({ foo: 'bar' }).then(function (listData) {
                deepEqual(listData.data, items.slice(1), 'updateData removed 1st item');
                destroyItem2();
            }, logErrorAndStart);
        }
        function destroyItem2() {
            connection.destroyData({
                id: 10,
                name: 'A'
            }).then(checkItems2, logErrorAndStart);
        }
        function checkItems2() {
            connection.getListData({ foo: 'bar' }).then(function (listData) {
                deepEqual(listData.data, items.slice(1), 'item 4 sill in foo');
                checkItems3();
            }, logErrorAndStart);
        }
        function checkItems3() {
            connection.getListData({ name: 'A' }).then(function (listData) {
                deepEqual(listData.data, aItems.slice(1));
                start();
            }, logErrorAndStart);
        }
    });
    QUnit.test('getData can pull from updateListData', function () {
        var items = [
            {
                id: 1,
                foo: 'bar'
            },
            {
                id: 2,
                foo: 'bar'
            },
            {
                id: 3,
                foo: 'bar'
            }
        ];
        var connection = this.connection;
        stop();
        connection.getData({ id: 1 }).then(function () {
            ok(false, 'should have rejected, nothing there');
            start();
        }, updateListData);
        function updateListData() {
            connection.updateListData({ data: items.slice(0) }, { foo: 'bar' }).then(function () {
                connection.getData({ id: 1 }).then(function (instanceData) {
                    deepEqual(instanceData, items[0]);
                    updateData();
                }, logErrorAndStart);
            }, logErrorAndStart);
        }
        function updateData() {
            connection.updateData({
                id: 1,
                foo: 'BAR'
            }).then(function () {
                connection.getData({ id: 1 }).then(function (instanceData) {
                    deepEqual(instanceData, {
                        id: 1,
                        foo: 'BAR'
                    });
                    setTimeout(destroyData, 1);
                }, logErrorAndStart);
            }, logErrorAndStart);
        }
        function destroyData() {
            connection.destroyData({
                id: 1,
                foo: 'BAR'
            }).then(function () {
                connection.getData({ id: 1 }).then(logErrorAndStart, function () {
                    ok(true, 'nothing there!');
                    start();
                });
            }, logErrorAndStart);
        }
    });
    QUnit.test('clearing localStorage clears set info', function () {
        var connection = this.connection;
        QUnit.stop();
        connection.updateListData({ data: items.slice(0) }, { foo: 'bar' }).then(function () {
            connection.getListData({ foo: 'bar' }).then(function () {
                localStorage.clear();
                connection.getSets().then(function (sets) {
                    QUnit.deepEqual(sets, []);
                    QUnit.start();
                });
            });
        });
    });
    QUnit.test('using algebra (#72)', function () {
        var connection = this.connection;
        connection.algebra = new canSet.Algebra(new canSet.Translate('where', '$where'));
        QUnit.stop();
        connection.updateListData({
            data: [{
                    id: 1,
                    placeId: 2,
                    name: 'J'
                }]
        }, { $where: { placeId: 2 } }).then(function () {
            connection.updateData({
                id: 1,
                placeId: 2,
                name: 'B'
            }).then(function () {
                connection.getListData({ $where: { placeId: 2 } }).then(function (items) {
                    QUnit.equal(items.data.length, 1, 'still have the item');
                    QUnit.start();
                });
            });
        });
    });
    QUnit.test('Support passing undefined as a set to mean passing {} (#54)', function () {
        var connection = this.connection;
        QUnit.stop();
        connection.updateListData({ data: items.slice(0) }, undefined).then(function () {
            QUnit.equal(localStorage.getItem('todos-sets'), '[{}]', 'contains universal set');
            QUnit.equal(localStorage.getItem('todos/set/{}'), '[1,2,3]', 'has set to id');
            QUnit.start();
        });
    });
    QUnit.test('subset data (#96)', function () {
        var connection = this.connection;
        QUnit.stop();
        connection.updateListData({
            data: [
                {
                    id: 1,
                    completed: true
                },
                {
                    id: 2,
                    completed: false
                }
            ]
        }, {}).then(function () {
            connection.getListData({ completed: true }).then(function (items) {
                QUnit.equal(items.data.length, 1, 'should get completed items from cache');
                QUnit.start();
            }, function () {
                ok(false, 'should have gotten completed items from cache');
                QUnit.start();
            });
        });
    });
    QUnit.asyncTest('pagination loses the bigger set (#126)', function () {
        var todosAlgebra = new canSet.Algebra(canSet.props.offsetLimit('offset', 'limit'));
        var connection = connect([dataLocalStorage], {
            name: 'todos',
            algebra: todosAlgebra
        });
        connection.updateListData({
            data: [
                { id: 0 },
                { id: 1 }
            ]
        }, {
            offset: 0,
            limit: 2
        }).then(function () {
            return connection.updateListData({
                data: [
                    { id: 2 },
                    { id: 3 }
                ]
            }, {
                offset: 2,
                limit: 2
            });
        }).then(function () {
            connection.getListData({
                offset: 0,
                limit: 2
            }).then(function (listData) {
                QUnit.deepEqual(listData, {
                    data: [
                        { id: 0 },
                        { id: 1 }
                    ]
                });
                QUnit.start();
            }, function () {
                QUnit.ok(false, 'no data');
                QUnit.start();
            });
        }).catch(function (e) {
            QUnit.ok(false, 'something broke');
            QUnit.start();
        });
    });
});
/*can-connect@1.3.8#data/memory-cache/memory-cache_test*/
define('can-connect@1.3.8#data/memory-cache/memory-cache_test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var memoryCache = require('can-connect/data/memory-cache/');
    var connect = require('can-connect');
    var canSet = require('can-set');
    var logErrorAndStart = function (e) {
        ok(false, 'Error ' + e);
        start();
    };
    var items = [
        {
            id: 1,
            foo: 'bar'
        },
        {
            id: 2,
            foo: 'bar'
        },
        {
            id: 3,
            foo: 'bar'
        }
    ];
    var aItems = [
        {
            id: 10,
            name: 'A'
        },
        {
            id: 11,
            name: 'A'
        },
        {
            id: 12,
            name: 'A'
        }
    ];
    QUnit.module('can-connect/data-memory-cache', {
        setup: function () {
            this.connection = connect([memoryCache], {});
            this.connection.clear();
        }
    });
    QUnit.test('updateListData', function () {
        var items = [
            {
                id: 1,
                foo: 'bar'
            },
            {
                id: 2,
                foo: 'bar'
            },
            {
                id: 3,
                foo: 'bar'
            }
        ];
        var connection = this.connection;
        stop();
        connection.getListData({ foo: 'bar' }).then(function () {
            ok(false, 'should have rejected, nothing there');
            start();
        }, function () {
            connection.updateListData({ data: items.slice(0) }, { foo: 'bar' }).then(function () {
                connection.getListData({ foo: 'bar' }).then(function (listData) {
                    deepEqual(listData.data, items);
                    start();
                }, logErrorAndStart);
            }, logErrorAndStart);
        });
    });
    QUnit.test('updateData', function () {
        var connection = this.connection;
        stop();
        var a1 = connection.updateListData({ data: items.slice(0) }, { foo: 'bar' });
        var a2 = connection.updateListData({ data: aItems.slice(0) }, { name: 'A' });
        Promise.all([
            a1,
            a2
        ]).then(updateItem, logErrorAndStart);
        function updateItem() {
            connection.updateData({
                id: 4,
                foo: 'bar'
            }).then(checkItems, logErrorAndStart);
        }
        function checkItems() {
            connection.getListData({ foo: 'bar' }).then(function (listData) {
                deepEqual(listData.data, items.concat({
                    id: 4,
                    foo: 'bar'
                }), 'updateData added item 4');
                updateItem2();
            }, logErrorAndStart);
        }
        function updateItem2() {
            connection.updateData({
                id: 4,
                name: 'A'
            }).then(checkItems2, logErrorAndStart);
        }
        function checkItems2() {
            connection.getListData({ foo: 'bar' }).then(function (listData) {
                deepEqual(listData.data, items, 'item 4 no longer in foo');
                checkItems3();
            }, logErrorAndStart);
        }
        function checkItems3() {
            connection.getListData({ name: 'A' }).then(function (listData) {
                deepEqual(listData.data, aItems.concat([{
                        id: 4,
                        name: 'A'
                    }]), 'id 4 should now have name A');
                start();
            }, logErrorAndStart);
        }
    });
    QUnit.test('createData', function () {
        var connection = this.connection;
        stop();
        var a1 = connection.updateListData({ data: items.slice(0) }, { foo: 'bar' });
        var a2 = connection.updateListData({ data: aItems.slice(0) }, { name: 'A' });
        Promise.all([
            a1,
            a2
        ]).then(createItem, logErrorAndStart);
        function createItem() {
            connection.createData({
                id: 4,
                foo: 'bar'
            }).then(checkItems, logErrorAndStart);
        }
        function checkItems() {
            connection.getListData({ foo: 'bar' }).then(function (listData) {
                deepEqual(listData.data, items.concat({
                    id: 4,
                    foo: 'bar'
                }), 'updateData added item 4');
                createItem2();
            }, logErrorAndStart);
        }
        function createItem2() {
            connection.updateData({
                id: 5,
                name: 'A'
            }).then(checkItems2, logErrorAndStart);
        }
        function checkItems2() {
            connection.getListData({ foo: 'bar' }).then(function (listData) {
                deepEqual(listData.data, items.concat({
                    id: 4,
                    foo: 'bar'
                }), 'item 4 sill in foo');
                checkItems3();
            }, logErrorAndStart);
        }
        function checkItems3() {
            connection.getListData({ name: 'A' }).then(function (listData) {
                deepEqual(listData.data, aItems.concat([{
                        id: 5,
                        name: 'A'
                    }]));
                start();
            }, logErrorAndStart);
        }
    });
    QUnit.test('destroyData', function () {
        var connection = this.connection;
        stop();
        var a1 = connection.updateListData({ data: items.slice(0) }, { foo: 'bar' });
        var a2 = connection.updateListData({ data: aItems.slice(0) }, { name: 'A' });
        Promise.all([
            a1,
            a2
        ]).then(destroyItem, logErrorAndStart);
        function destroyItem() {
            connection.destroyData({
                id: 1,
                foo: 'bar'
            }).then(checkItems, logErrorAndStart);
        }
        function checkItems() {
            connection.getListData({ foo: 'bar' }).then(function (listData) {
                deepEqual(listData.data, items.slice(1), 'updateData removed 1st item');
                destroyItem2();
            }, logErrorAndStart);
        }
        function destroyItem2() {
            connection.destroyData({
                id: 10,
                name: 'A'
            }).then(checkItems2, logErrorAndStart);
        }
        function checkItems2() {
            connection.getListData({ foo: 'bar' }).then(function (listData) {
                deepEqual(listData.data, items.slice(1), 'item 4 sill in foo');
                checkItems3();
            }, logErrorAndStart);
        }
        function checkItems3() {
            connection.getListData({ name: 'A' }).then(function (listData) {
                deepEqual(listData.data, aItems.slice(1));
                start();
            }, logErrorAndStart);
        }
    });
    QUnit.test('getData can pull from updateListData', function () {
        var items = [
            {
                id: 1,
                foo: 'bar'
            },
            {
                id: 2,
                foo: 'bar'
            },
            {
                id: 3,
                foo: 'bar'
            }
        ];
        var connection = this.connection;
        stop();
        connection.getData({ id: 1 }).then(function () {
            ok(false, 'should have rejected, nothing there');
            start();
        }, updateListData);
        function updateListData() {
            connection.updateListData({ data: items.slice(0) }, { foo: 'bar' }).then(function () {
                connection.getData({ id: 1 }).then(function (instanceData) {
                    deepEqual(instanceData, items[0]);
                    updateData();
                }, logErrorAndStart);
            }, logErrorAndStart);
        }
        function updateData() {
            connection.updateData({
                id: 1,
                foo: 'BAR'
            }).then(function () {
                connection.getData({ id: 1 }).then(function (instanceData) {
                    deepEqual(instanceData, {
                        id: 1,
                        foo: 'BAR'
                    });
                    setTimeout(destroyData, 1);
                }, logErrorAndStart);
            }, logErrorAndStart);
        }
        function destroyData() {
            connection.destroyData({
                id: 1,
                foo: 'BAR'
            }).then(function () {
                connection.getData({ id: 1 }).then(logErrorAndStart, function () {
                    ok(true, 'nothing there!');
                    start();
                });
            }, logErrorAndStart);
        }
    });
    QUnit.test('respect sort order (#80)', function () {
        var items = [
            {
                id: 1,
                name: 'zed'
            },
            {
                id: 2,
                name: 'bar'
            },
            {
                id: 3,
                name: 'foo'
            }
        ];
        stop();
        var connection = connect([memoryCache], { algebra: new canSet.Algebra(canSet.comparators.sort('sortBy')) });
        connection.updateListData({ data: items.slice(0) }, {}).then(function () {
            return connection.getListData({ sortBy: 'name' });
        }).then(function (res) {
            QUnit.deepEqual(res.data, [
                {
                    id: 2,
                    name: 'bar'
                },
                {
                    id: 3,
                    name: 'foo'
                },
                {
                    id: 1,
                    name: 'zed'
                }
            ]);
            QUnit.start();
        });
    });
    QUnit.test('non numeric ids (#79)', function () {
        var items = [
            {
                id: 'a',
                name: 'zed'
            },
            {
                id: 'b',
                name: 'bar'
            },
            {
                id: 'c',
                name: 'foo'
            }
        ];
        stop();
        var connection = connect([memoryCache], {});
        connection.updateListData({ data: items.slice(0) }, {}).then(function () {
            return connection.destroyData({
                id: 'b',
                name: 'bar'
            });
        }).then(function () {
            return connection.getListData({});
        }).then(function (res) {
            QUnit.deepEqual(res.data, [
                {
                    id: 'a',
                    name: 'zed'
                },
                {
                    id: 'c',
                    name: 'foo'
                }
            ]);
            QUnit.start();
        });
    });
    QUnit.asyncTest('pagination loses the bigger set (#126)', function () {
        var todosAlgebra = new canSet.Algebra(canSet.props.offsetLimit('offset', 'limit'));
        var connection = connect([memoryCache], {
            name: 'todos',
            algebra: todosAlgebra
        });
        connection.updateListData({
            data: [
                { id: 0 },
                { id: 1 }
            ]
        }, {
            offset: 0,
            limit: 2
        }).then(function () {
            return connection.updateListData({
                data: [
                    { id: 2 },
                    { id: 3 }
                ]
            }, {
                offset: 2,
                limit: 2
            });
        }).then(function () {
            connection.getListData({
                offset: 0,
                limit: 2
            }).then(function (listData) {
                QUnit.deepEqual(listData, {
                    data: [
                        { id: 0 },
                        { id: 1 }
                    ],
                    count: 4
                });
                QUnit.start();
            }, function () {
                QUnit.ok(false, 'no data');
                QUnit.start();
            });
        }).catch(function (e) {
            QUnit.ok(false, 'something broke');
            QUnit.start();
        });
    });
    QUnit.asyncTest('pagination loses the bigger set (#128)', function () {
        var todosAlgebra = new canSet.Algebra(canSet.props.offsetLimit('offset', 'limit'));
        var connection = connect([memoryCache], {
            name: 'todos',
            algebra: todosAlgebra
        });
        connection.updateListData({
            data: [
                { id: 0 },
                { id: 1 },
                { id: 2 },
                { id: 3 }
            ]
        }, {}).then(function () {
            return connection.getListData({
                offset: 1,
                limit: 2
            });
        }).then(function (listData) {
            QUnit.deepEqual(listData, {
                data: [
                    { id: 1 },
                    { id: 2 }
                ],
                count: 4
            });
            QUnit.start();
        }).catch(function (e) {
            QUnit.ok(false, 'something broke');
            QUnit.start();
        });
    });
    QUnit.test('should not mutate data passed from the outside', function (assert) {
        var done = assert.async();
        var connection = this.connection;
        assert.expect(1);
        var items = [
            {
                '_id': 1,
                role: 'admin'
            },
            {
                '_id': 2,
                role: 'editor'
            },
            {
                '_id': 3,
                role: 'nurse'
            }
        ];
        connection.updateListData({ data: items }, {}).then(function (listData) {
            return connection.updateListData({
                data: [
                    {
                        '_id': 1,
                        role: 'nurse'
                    },
                    {
                        '_id': 2,
                        role: 'admin'
                    }
                ]
            });
        }).then(function () {
            assert.deepEqual(items, [
                {
                    '_id': 1,
                    role: 'admin'
                },
                {
                    '_id': 2,
                    role: 'editor'
                },
                {
                    '_id': 3,
                    role: 'nurse'
                }
            ], 'outside data should not be mutated');
            done();
        }).then(null, function (error) {
            assert.ok(false, error);
        });
    });
});
/*can-connect@1.3.8#data/worker/worker*/
define('can-connect@1.3.8#data/worker/worker', function (require, exports, module) {
    var connect = require('can-connect');
    var makeDeferred = require('can-connect/helpers/deferred');
    var canLog = require('can-util/js/log/log');
    module.exports = connect.behavior('data/worker', function (baseConnection) {
        if (typeof document !== 'undefined') {
            var requestId = 0;
            var requestDeferreds = {};
            var isReady = makeDeferred();
            var behavior = {
                _workerRequest: function (data) {
                    data.type = 'can-connect:data-worker:' + this.name + ':request';
                    data.requestId = requestId++;
                    var def = makeDeferred(), worker = this.worker;
                    requestDeferreds[data.requestId] = def;
                    isReady.promise.then(function () {
                        worker.postMessage(data);
                    });
                    return def.promise;
                },
                init: function () {
                    if (!this.worker) {
                        canLog.warn('No worker provided, defaulting to base behavior');
                        return;
                    }
                    var worker = this.worker, connection = this;
                    worker.onmessage = function (ev) {
                        var data = ev.data;
                        if (!data.type || data.type.indexOf('can-connect:data-worker:' + connection.name) !== 0) {
                            return;
                        }
                        canLog.log('MAIN - message:', connection.name, ev.data.method);
                        var method = ev.data.method;
                        if (method === 'ready' || method === 'pong') {
                            isReady.resolve();
                        } else {
                            requestDeferreds[ev.data.requestId].resolve(ev.data.response);
                        }
                    };
                    worker.postMessage({
                        type: 'can-connect:data-worker:' + connection.name + ':response',
                        connectionName: connection.name,
                        method: 'ping'
                    });
                }
            };
            [
                'getListData',
                'updateListData',
                'getSets',
                'clear',
                'getData',
                'createData',
                'updateData',
                'destroyData'
            ].forEach(function (name) {
                behavior[name] = function () {
                    return this._workerRequest({
                        method: name,
                        args: [].slice.call(arguments, 0)
                    });
                };
            });
            return behavior;
        } else {
            return {
                init: function () {
                    var connection = this;
                    addEventListener('message', function (ev) {
                        var data = ev.data;
                        if (!data.type || data.type.indexOf('can-connect:data-worker:' + connection.name) !== 0) {
                            return;
                        }
                        var method = data.method;
                        canLog.log('WORKER - message:', connection.name, method);
                        if (method === 'ping') {
                            return postMessage({
                                type: 'can-connect:data-worker:' + connection.name + ':response',
                                connectionName: connection.name,
                                requestId: data.requestId,
                                method: 'pong'
                            });
                        }
                        if (!connection[method]) {
                            return canLog.warn('There\'s no method named ' + method + ' on connection ' + connection.name);
                        }
                        connection[method].call(connection, data.args).then(function (response) {
                            postMessage({
                                type: 'can-connect:data-worker:' + connection.name + ':response',
                                requestId: data.requestId,
                                response: response,
                                method: method
                            });
                        });
                    });
                    postMessage({
                        type: 'can-connect:data-worker:' + connection.name + ':ready',
                        connectionName: connection.name,
                        method: 'ready'
                    });
                }
            };
        }
    });
});
/*can-connect@1.3.8#data/worker/worker_test*/
define('can-connect@1.3.8#data/worker/worker_test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var workerBehavior = require('can-connect/data/worker/');
    var connect = require('can-connect');
    var logErrorAndStart = function (e) {
        ok(false, 'Error ' + e);
        start();
    };
    if (typeof Worker !== 'undefined' && !System.isEnv('production')) {
        QUnit.module('can-connect/data-worker');
        QUnit.test('getListData', function () {
            var connection = connect([workerBehavior], {
                name: 'todos',
                worker: new Worker(System.stealURL + '?main=can-connect/data/worker/worker-main_test')
            });
            stop();
            connection.getListData({ foo: 'bar' }).then(function (listData) {
                deepEqual(listData, {
                    data: [
                        { id: 1 },
                        { id: 2 }
                    ]
                }, 'got back data');
                start();
            }, logErrorAndStart);
        });
    }
});
/*can-connect@1.3.8#fall-through-cache/fall-through-cache_test*/
define('can-connect@1.3.8#fall-through-cache/fall-through-cache_test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var connect = require('can-connect');
    var map = [].map;
    var testHelpers = require('can-connect/test-helpers');
    var constructor = require('can-connect/constructor/constructor');
    var fallThroughCache = require('can-connect/fall-through-cache/fall-through-cache');
    var constructorStore = require('can-connect/constructor/store/store');
    var dataCallbacks = require('can-connect/data/callbacks/');
    var getId = function (d) {
        return d.id;
    };
    QUnit.module('can-connect/fall-through-cache');
    QUnit.test('basics', function () {
        stop();
        var firstItems = [
            {
                id: 0,
                foo: 'bar'
            },
            {
                id: 1,
                foo: 'bar'
            }
        ];
        var secondItems = [
            {
                id: 1,
                foo: 'BAZ'
            },
            {
                id: 2,
                foo: 'bar'
            }
        ];
        var state = testHelpers.makeStateChecker(QUnit, [
            'cache-getListData-empty',
            'base-getListData',
            'cache-updateListData',
            'connection-foundAll',
            'connection-getList-2',
            'cache-getListData-items',
            'connection-foundAll-2',
            'base-getListData-2',
            'cache-updateListData-2',
            'updatedList'
        ]);
        var cacheConnection = connect([function () {
                return {
                    getListData: function () {
                        if (state.get() === 'cache-getListData-empty') {
                            state.next();
                            return testHelpers.asyncReject();
                        } else {
                            state.check('cache-getListData-items');
                            return testHelpers.asyncResolve({ data: firstItems.slice(0) });
                        }
                    },
                    updateListData: function (data, set) {
                        if (state.get() === 'cache-updateListData') {
                            state.next();
                            deepEqual(set, {}, 'got the right set');
                            deepEqual(data.data, firstItems, 'updateListData items are right');
                            return testHelpers.asyncResolve();
                        } else {
                            deepEqual(data.data, secondItems, 'updateListData 2 items are right');
                            state.check('cache-updateListData-2');
                            return testHelpers.asyncResolve();
                        }
                    }
                };
            }], {});
        var base = function (base, options) {
            return {
                getListData: function () {
                    if (state.get() === 'base-getListData') {
                        state.next();
                        return testHelpers.asyncResolve({ data: firstItems.slice(0) });
                    } else {
                        state.check('base-getListData-2');
                        return testHelpers.asyncResolve({ data: secondItems.slice(0) });
                    }
                }
            };
        };
        var updater = function () {
            return {
                updatedList: function (list, updated) {
                    state.check('updatedList');
                    deepEqual(map.call(updated.data, getId), map.call(secondItems, getId));
                    start();
                }
            };
        };
        var connection = connect([
            base,
            constructor,
            fallThroughCache,
            constructorStore,
            dataCallbacks,
            updater
        ], { cacheConnection: cacheConnection });
        connection.getList({}).then(function (list) {
            state.check('connection-foundAll');
            deepEqual(map.call(list, getId), map.call(firstItems, getId));
            setTimeout(secondCall, 1);
        }, testHelpers.logErrorAndStart);
        function secondCall() {
            state.check('connection-getList-2');
            connection.getList({}).then(function (list) {
                state.check('connection-foundAll-2');
                deepEqual(map.call(list, getId), map.call(firstItems, getId));
            }, testHelpers.logErrorAndStart);
        }
    });
    QUnit.test('getInstance and getData', function () {
        stop();
        var firstData = {
            id: 0,
            foo: 'bar'
        };
        var secondData = {
            id: 0,
            foo: 'BAR'
        };
        var state = testHelpers.makeStateChecker(QUnit, [
            'cache-getData-empty',
            'base-getData',
            'cache-updateData',
            'connection-foundOne',
            'connection-getInstance-2',
            'cache-getData-item',
            'connection-foundOne-2',
            'base-getData-2',
            'cache-updateData-2',
            'updatedInstance'
        ]);
        var cacheConnection = connect([function () {
                return {
                    getData: function () {
                        if (state.get() === 'cache-getData-empty') {
                            state.next();
                            return testHelpers.asyncReject();
                        } else {
                            state.check('cache-getData-item');
                            return testHelpers.asyncResolve(firstData);
                        }
                    },
                    updateData: function (data) {
                        if (state.get() === 'cache-updateData') {
                            state.next();
                            deepEqual(data, firstData, 'updateData items are right');
                            return testHelpers.asyncResolve();
                        } else {
                            deepEqual(data, secondData, 'updateData 2 items are right');
                            state.check('cache-updateData-2');
                            return testHelpers.asyncResolve();
                        }
                    }
                };
            }], {});
        var base = function (base, options) {
            return {
                getData: function () {
                    if (state.get() === 'base-getData') {
                        state.next();
                        return testHelpers.asyncResolve({
                            id: 0,
                            foo: 'bar'
                        });
                    } else {
                        state.check('base-getData-2');
                        return testHelpers.asyncResolve({
                            id: 0,
                            foo: 'BAR'
                        });
                    }
                }
            };
        };
        var updater = function () {
            return {
                updatedInstance: function (instance, data) {
                    state.check('updatedInstance');
                    deepEqual(data, secondData);
                    start();
                }
            };
        };
        var connection = connect([
            base,
            constructor,
            fallThroughCache,
            constructorStore,
            dataCallbacks,
            updater
        ], { cacheConnection: cacheConnection });
        connection.get({ id: 0 }).then(function (instance) {
            state.check('connection-foundOne');
            deepEqual(instance, {
                id: 0,
                foo: 'bar'
            });
            setTimeout(secondCall, 1);
        }, testHelpers.logErrorAndStart);
        function secondCall() {
            state.check('connection-getInstance-2');
            connection.get({ id: 0 }).then(function (instance) {
                state.check('connection-foundOne-2');
                deepEqual(instance, {
                    id: 0,
                    foo: 'bar'
                });
            }, testHelpers.logErrorAndStart);
        }
    });
    asyncTest('metadata transfered through fall through cache (#125)', function () {
        var getDataBehaviorDataPromise;
        var cacheConnection = {
            getListData: function () {
                return testHelpers.asyncResolve({ data: [{ id: 1 }] });
            },
            updateListData: function () {
            }
        };
        var getDataBehavior = function (base, options) {
            return {
                getListData: function () {
                    getDataBehaviorDataPromise = testHelpers.asyncResolve({
                        data: [{ id: 1 }],
                        count: 5
                    });
                    return getDataBehaviorDataPromise;
                }
            };
        };
        var connection = connect([
            getDataBehavior,
            constructor,
            fallThroughCache,
            constructorStore,
            dataCallbacks
        ], { cacheConnection: cacheConnection });
        connection.getList({}).then(function (list) {
            setTimeout(function () {
                getDataBehaviorDataPromise.then(function () {
                    QUnit.equal(list.count, 5, 'expando added');
                    QUnit.start();
                });
            }, 50);
        });
    });
});
/*can-connect@1.3.8#real-time/real-time_test*/
define('can-connect@1.3.8#real-time/real-time_test', function (require, exports, module) {
    var connect = require('can-connect/can-connect');
    var set = require('can-set');
    var realTime = require('can-connect/real-time/');
    var constructor = require('can-connect/constructor/');
    var constructorStore = require('can-connect/constructor/store/');
    var dataCallbacks = require('can-connect/data/callbacks/');
    var callbacksOnce = require('can-connect/constructor/callbacks-once/');
    var testHelpers = require('can-connect/test-helpers');
    var QUnit = require('steal-qunit');
    var assign = require('can-util/js/assign/assign');
    var canDev = require('can-util/js/dev/dev');
    QUnit.module('can-connect/real-time', {});
    var later = function (fn) {
        return function () {
            setTimeout(fn, 1);
        };
    };
    var logErrorAndStart = function (e) {
        ok(false, 'Error ' + e);
        start();
    };
    QUnit.test('basics', function () {
        stop();
        var state = testHelpers.makeStateChecker(QUnit, [
            'getListData-important',
            'getListData-today',
            'createData-today+important',
            'createdInstance-1',
            'updateData-important',
            'updateData-today',
            'destroyData-important-1'
        ]);
        var firstItems = [
            {
                id: 0,
                type: 'important'
            },
            {
                id: 1,
                type: 'important'
            }
        ];
        var secondItems = [
            {
                id: 2,
                due: 'today'
            },
            {
                id: 3,
                due: 'today'
            }
        ];
        var callbackBehavior = function (base) {
            return {
                createdInstance: function () {
                    state.check('createdInstance-1');
                    return base.createdInstance.apply(this, arguments);
                },
                updatedInstance: function () {
                    return base.updatedInstance.apply(this, arguments);
                },
                destroyedInstance: function () {
                    return base.destroyedInstance.apply(this, arguments);
                },
                updatedList: function (list, updated) {
                    return base.updatedList.apply(this, arguments);
                }
            };
        };
        var dataBehavior = function () {
            return {
                getListData: function () {
                    if (state.get() === 'getListData-important') {
                        state.next();
                        return testHelpers.asyncResolve({ data: firstItems.slice(0) });
                    } else {
                        state.check('getListData-today');
                        return testHelpers.asyncResolve({ data: secondItems.slice(0) });
                    }
                },
                createData: function (props) {
                    if (state.get() === 'createData-today+important') {
                        state.next();
                        return testHelpers.asyncResolve({ id: 10 });
                    } else {
                        ok(false, 'bad state!');
                        start();
                    }
                },
                updateData: function (props) {
                    if (state.get() === 'updateData-important' || state.get() === 'updateData-today') {
                        state.next();
                        return testHelpers.asyncResolve(assign({}, props));
                    } else {
                        ok(false, 'bad state!');
                        start();
                    }
                },
                destroyData: function (props) {
                    if (state.get() === 'destroyData-important-1') {
                        state.next();
                        return testHelpers.asyncResolve(assign({ destroyed: 1 }, props));
                    }
                }
            };
        };
        var connection = connect([
            dataBehavior,
            realTime,
            constructor,
            constructorStore,
            dataCallbacks,
            callbackBehavior,
            callbacksOnce
        ], {});
        var importantList, todayList;
        Promise.all([
            connection.getList({ type: 'important' }),
            connection.getList({ due: 'today' })
        ]).then(function (result) {
            importantList = result[0];
            todayList = result[1];
            connection.addListReference(importantList);
            connection.addListReference(todayList);
            setTimeout(createImportantToday, 1);
        }, logErrorAndStart);
        function createImportantToday() {
            connection.save({
                type: 'important',
                due: 'today',
                createId: 1
            }).then(function (task) {
                connection.addInstanceReference(task);
                setTimeout(checkLists, 1);
            }, logErrorAndStart);
        }
        var created;
        function checkLists() {
            created = connection.instanceStore.get(10);
            ok(importantList.indexOf(created) >= 0, 'in important');
            ok(todayList.indexOf(created) >= 0, 'in today');
            setTimeout(serverSideDuplicateCreate, 1);
        }
        function serverSideDuplicateCreate() {
            connection.createInstance({
                id: 10,
                due: 'today',
                type: 'important'
            }).then(function (createdInstance) {
                equal(createdInstance, created);
                ok(importantList.indexOf(created) >= 0, 'in important');
                ok(todayList.indexOf(created) >= 0, 'in today');
                equal(importantList.length, 3, 'items stays the same');
                setTimeout(update1, 1);
            });
        }
        function update1() {
            delete created.due;
            connection.save(created).then(later(checkLists2), logErrorAndStart);
        }
        function checkLists2() {
            ok(importantList.indexOf(created) >= 0, 'still in important');
            equal(todayList.indexOf(created), -1, 'removed from today');
            update2();
        }
        function update2() {
            delete created.type;
            created.due = 'today';
            connection.save(created).then(later(checkLists3), logErrorAndStart);
        }
        function checkLists3() {
            equal(importantList.indexOf(created), -1, 'removed from important');
            ok(todayList.indexOf(created) >= 1, 'added to today');
            serverSideUpdate();
        }
        function serverSideUpdate() {
            connection.updateInstance({
                type: 'important',
                due: 'today',
                createId: 1,
                id: 10
            }).then(function (instance) {
                equal(created, instance);
                ok(importantList.indexOf(created) >= 0, 'in important');
                ok(todayList.indexOf(created) >= 0, 'in today');
                destroyItem();
            });
        }
        var firstImportant;
        function destroyItem() {
            firstImportant = importantList[0];
            connection.addInstanceReference(firstImportant);
            connection.destroy(firstImportant).then(later(checkLists4), logErrorAndStart);
        }
        function checkLists4() {
            equal(importantList.indexOf(firstImportant), -1, 'in important');
            serverSideDestroy();
        }
        function serverSideDestroy() {
            connection.destroyInstance({
                type: 'important',
                due: 'today',
                createId: 1,
                id: 10
            }).then(function (instance) {
                equal(importantList.indexOf(created), -1, 'still in important');
                equal(todayList.indexOf(created), -1, 'removed from today');
                start();
            });
        }
    });
    QUnit.test('sorting by id works', function () {
        var algebra = new set.Algebra(set.comparators.id('id'), set.comparators.sort('sortBy'));
        var items = [
            {
                id: 1,
                name: 'g'
            },
            {
                id: 3,
                name: 'j'
            },
            {
                id: 4,
                name: 'm'
            },
            {
                id: 5,
                name: 's'
            }
        ];
        var dataBehavior = function () {
            return {
                getListData: function () {
                    return testHelpers.asyncResolve({ data: items.slice(0) });
                }
            };
        };
        var connection = connect([
            dataBehavior,
            realTime,
            constructor,
            constructorStore,
            dataCallbacks,
            callbacksOnce
        ], { algebra: algebra });
        stop();
        var listItems;
        connection.getList({}).then(function (list) {
            listItems = list;
            connection.addListReference(list);
            setTimeout(createInstance, 1);
        });
        function createInstance() {
            connection.createInstance({
                id: 2,
                name: 'a'
            }).then(function () {
                setTimeout(checkList, 1);
            });
        }
        function checkList() {
            var itemsCopy = items.slice(0);
            itemsCopy.splice(1, 0, {
                id: 2,
                name: 'a'
            });
            deepEqual(listItems, itemsCopy);
            start();
        }
    });
    QUnit.test('sorting by sort clause works with updates', function () {
        var algebra = new set.Algebra(set.comparators.id('id'), set.comparators.sort('sortBy'));
        var items = [
            {
                id: 1,
                name: 'd'
            },
            {
                id: 3,
                name: 'j'
            },
            {
                id: 4,
                name: 'm'
            },
            {
                id: 5,
                name: 's'
            }
        ];
        var dataBehavior = function () {
            return {
                getListData: function () {
                    return testHelpers.asyncResolve({ data: items.slice(0) });
                }
            };
        };
        var connection = connect([
            dataBehavior,
            realTime,
            constructor,
            constructorStore,
            dataCallbacks,
            callbacksOnce
        ], { algebra: algebra });
        stop();
        var listItems;
        connection.getList({ sortBy: 'name' }).then(function (list) {
            listItems = list;
            connection.addListReference(list);
            list.forEach(function (instance) {
                connection.addInstanceReference(instance);
            });
            setTimeout(updateInstance, 1);
        });
        function updateInstance() {
            connection.updateInstance({
                id: 3,
                name: 'p'
            }).then(function () {
                setTimeout(checkList, 1);
            });
        }
        function checkList() {
            deepEqual(listItems, [
                {
                    id: 1,
                    name: 'd'
                },
                {
                    id: 4,
                    name: 'm'
                },
                {
                    id: 3,
                    name: 'p'
                },
                {
                    id: 5,
                    name: 's'
                }
            ]);
            start();
        }
    });
    QUnit.test('destroyInstance calls destroyedInstance', function (assert) {
        var destructionForeman = function () {
            return {
                destroyedInstance: function (instance, props) {
                    assert.ok(instance, 'destroyedInstance was called.');
                    return testHelpers.asyncResolve({});
                }
            };
        };
        var connection = connect([
            realTime,
            constructor,
            constructorStore,
            dataCallbacks,
            destructionForeman,
            callbacksOnce
        ], {});
        connection.destroyInstance({ id: 1 });
    });
});
/*can-connect@1.3.8#service-worker/service-worker*/
define('can-connect@1.3.8#service-worker/service-worker', function (require, exports, module) {
    var connect = require('can-connect');
    var makeDeferred = require('can-connect/helpers/deferred');
    module.exports = connect.behavior('service-worker', function (baseConnection) {
        var worker = new Worker(this.workerURL);
        var requestId = 0;
        var requestDeferreds = {};
        var isReady = makeDeferred();
        var makeRequest = function (data) {
            var reqId = requestId++;
            var def = makeDeferred();
            requestDeferreds[reqId] = def;
            isReady.promise.then(function () {
                worker.postMessage({
                    request: data,
                    requestId: reqId
                });
            });
            return def.promise;
        };
        worker.onmessage = function (ev) {
            console.log('MAIN - got message', ev.data.type);
            if (ev.data.type === 'ready') {
                isReady.resolve();
            } else if (ev.data.type === 'response') {
                requestDeferreds[ev.data.requestId].resolve(ev.data.response);
            }
        };
        return {
            getListData: function (params) {
                return makeRequest({ params: params });
            }
        };
    });
});
/*can-connect@1.3.8#service-worker/service-worker_test*/
define('can-connect@1.3.8#service-worker/service-worker_test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var serviceWorkerCache = require('can-connect/service-worker/');
    var connect = require('can-connect');
    var logErrorAndStart = function (e) {
        ok(false, 'Error ' + e);
        start();
    };
    if (typeof Worker !== 'undefined' && !System.isEnv('production')) {
        QUnit.module('can-connect/service-worker', {
            setup: function () {
                this.connection = connect([serviceWorkerCache], {
                    name: 'todos',
                    workerURL: System.stealURL + '?main=can-connect/service-worker/service-worker-main_test'
                });
            }
        });
        QUnit.test('updateListData', function () {
            var connection = this.connection;
            stop();
            connection.getListData({ foo: 'bar' }).then(function (listData) {
                deepEqual(listData, {
                    data: [
                        { id: 1 },
                        { id: 2 }
                    ]
                }, 'got back data');
                start();
            }, logErrorAndStart);
        });
    }
});
/*can-connect@1.3.8#test/test*/
define('can-connect@1.3.8#test/test', function (require, exports, module) {
    require('can-connect/helpers/helpers_test');
    require('../core_test');
    require('../cache-requests/cache-requests_test');
    require('../can/test');
    require('../constructor/callbacks-once/callbacks-once_test');
    require('../constructor/constructor_test');
    require('../constructor/store/store_test');
    require('../data/url/data-url_test');
    require('../data/parse/parse_test');
    require('../data/callbacks-cache/callbacks-cache-test');
    require('../data/combine-requests/combine-requests_test');
    require('../data/localstorage-cache/localstorage-cache_test');
    require('../data/memory-cache/memory-cache_test');
    require('../data/worker/worker_test');
    require('../fall-through-cache/fall-through-cache_test');
    require('../real-time/real-time_test');
    require('../service-worker/service-worker_test');
});
/*can-construct@3.1.1#can-construct_test*/
define('can-construct@3.1.1#can-construct_test', function (require, exports, module) {
    (function (global) {
        QUnit = require('steal-qunit');
        var Construct = require('can-construct');
        var dev = require('can-util/js/dev/');
        var makeArray = require('can-util/js/make-array/');
        QUnit.module('can-construct', {
            setup: function () {
                var Animal = this.Animal = Construct.extend({
                    count: 0,
                    test: function () {
                        return this.match ? true : false;
                    }
                }, {
                    init: function () {
                        this.constructor.count++;
                        this.eyes = false;
                    }
                });
                var Dog = this.Dog = this.Animal.extend({ match: /abc/ }, {
                    init: function () {
                        Animal.prototype.init.apply(this, arguments);
                    },
                    talk: function () {
                        return 'Woof';
                    }
                });
                this.Ajax = this.Dog.extend({ count: 0 }, {
                    init: function (hairs) {
                        Dog.prototype.init.apply(this, arguments);
                        this.hairs = hairs;
                        this.setEyes();
                    },
                    setEyes: function () {
                        this.eyes = true;
                    }
                });
            }
        });
        test('inherit', function () {
            var Base = Construct({});
            ok(new Base() instanceof Construct);
            var Inherit = Base({});
            ok(new Inherit() instanceof Base);
        });
        test('Creating', function () {
            new this.Dog();
            var a1 = new this.Animal();
            new this.Animal();
            var ajax = new this.Ajax(1000);
            equal(2, this.Animal.count, 'right number of animals');
            equal(1, this.Dog.count, 'right number of animals');
            ok(this.Dog.match, 'right number of animals');
            ok(!this.Animal.match, 'right number of animals');
            ok(this.Dog.test(), 'right number of animals');
            ok(!this.Animal.test(), 'right number of animals');
            equal(1, this.Ajax.count, 'right number of animals');
            equal(2, this.Animal.count, 'right number of animals');
            equal(true, ajax.eyes, 'right number of animals');
            equal(1000, ajax.hairs, 'right number of animals');
            ok(a1 instanceof this.Animal);
            ok(a1 instanceof Construct);
        });
        test('new instance', function () {
            var d = this.Ajax.newInstance(6);
            equal(6, d.hairs);
        });
        test('namespaces', function () {
            var fb = Construct.extend('Bar');
            ok(!window.Bar, 'not added to global namespace');
            equal(fb.shortName, 'Bar', 'short name is right');
        });
        test('setups', function () {
            var order = 0, staticSetup, staticSetupArgs, staticInit, staticInitArgs, protoSetup, protoInitArgs, protoInit, staticProps = {
                    setup: function () {
                        staticSetup = ++order;
                        staticSetupArgs = arguments;
                        return ['something'];
                    },
                    init: function () {
                        staticInit = ++order;
                        staticInitArgs = arguments;
                    }
                }, protoProps = {
                    setup: function (name) {
                        protoSetup = ++order;
                        return ['Ford: ' + name];
                    },
                    init: function () {
                        protoInit = ++order;
                        protoInitArgs = arguments;
                    }
                };
            var Car = Construct.extend('Car', staticProps, protoProps);
            new Car('geo');
            equal(staticSetup, 1);
            equal(staticInit, 2);
            equal(protoSetup, 3);
            equal(protoInit, 4);
            deepEqual(makeArray(staticInitArgs), ['something']);
            deepEqual(makeArray(protoInitArgs), ['Ford: geo']);
            deepEqual(makeArray(staticSetupArgs), [
                Construct,
                'Car',
                staticProps,
                protoProps
            ], 'static construct');
            Car.extend('Truck');
            equal(staticSetup, 5, 'Static setup is called if overwriting');
        });
        test('Creating without extend', function () {
            var Bar = Construct('Bar', {
                ok: function () {
                    ok(true, 'ok called');
                }
            });
            new Bar().ok();
            var Foo = Bar('Foo', {
                dude: function () {
                    ok(true, 'dude called');
                }
            });
            new Foo().dude(true);
        });
        test('setup called with original arguments', function () {
            var o2 = {};
            var o1 = {
                setup: function (base, arg1, arg2) {
                    equal(o1, arg1, 'first argument is correct');
                    equal(o2, arg2, 'second argument is correct');
                }
            };
            Construct.extend(o1, o2);
        });
        test('legacy namespace strings (A.B.C) accepted', function () {
            var Type = Construct.extend('Foo.Bar.Baz');
            var expectedValue = ~steal.config('env').indexOf('production') ? '' : 'Foo_Bar_Baz';
            ok(new Type() instanceof Construct, 'No unexpected behavior in the prototype chain');
            if (Function.prototype.name) {
                equal(Type.name, expectedValue, 'Name becomes underscored');
            }
        });
        test('reserved words accepted', function () {
            var Type = Construct.extend('const');
            var expectedValue = ~steal.config('env').indexOf('production') ? '' : 'Const';
            ok(new Type() instanceof Construct, 'No unexpected behavior in the prototype chain');
            if (Function.prototype.name) {
                equal(Type.name, expectedValue, 'Name becomes capitalized');
            }
        });
        test('basic injection attacks thwarted', function () {
            var rootToken = typeof window === 'undefined' ? 'global' : 'window';
            var rootObject = typeof window === 'undefined' ? global : window;
            var expando = 'foo' + Math.random().toString(10).slice(2);
            var MalignantType;
            try {
                MalignantType = Construct.extend('(){};' + rootToken + '.' + expando + '=\'bar\';var f=function');
            } catch (e) {
            } finally {
                equal(rootObject[expando], undefined, 'Injected code doesn\'t run');
            }
            delete rootObject[expando];
            try {
                MalignantType = Construct.extend('(){},' + rootToken + '.' + expando + '=\'baz\',function');
            } catch (e) {
            } finally {
                equal(rootObject[expando], undefined, 'Injected code doesn\'t run');
            }
        });
        QUnit.test('setters not invoked on extension (#28)', function () {
            var extending = true;
            var Base = Construct.extend('Base', {
                set something(value) {
                    QUnit.ok(!extending, 'called when not extending');
                },
                get something() {
                }
            });
            Base.extend('Extended', { something: 'value' });
            extending = false;
            new Base().something = 'foo';
        });
        QUnit.test('return alternative value simple', function () {
            var Alternative = function () {
            };
            var Base = Construct.extend({
                setup: function () {
                    return new Construct.ReturnValue(new Alternative());
                }
            });
            QUnit.ok(new Base() instanceof Alternative, 'Should create an instance of Alternative');
        });
        QUnit.test('return alternative value on setup (full case)', function () {
            var Student = function (name, school) {
                this.name = name;
                this.school = school;
                this.isStudent = true;
            };
            var Person = Construct.extend({
                setup: function (opts) {
                    if (opts.age >= 16) {
                        return new Construct.ReturnValue(new Student(opts.name, opts.school));
                    }
                    opts.isStudent = false;
                    return [opts];
                },
                init: function (params) {
                    this.age = params.age;
                    this.name = params.name;
                    this.isStudent = params.isStudent;
                }
            });
            QUnit.equal(new Person({ age: 12 }).isStudent, false, 'Age 12 cannot be a student');
            QUnit.equal(new Person({ age: 30 }).isStudent, true, 'Age 20 can be a student');
            QUnit.ok(new Person({ age: 30 }) instanceof Student, 'Should return an instance of Student');
        });
    }(function () {
        return this;
    }()));
});
/*can@3.4.1#construct/construct_test*/
define('can@3.4.1#construct/construct_test', function (require, exports, module) {
    require('can-construct/can-construct_test');
});
/*can-util@3.3.2#js/omit/omit*/
define('can-util@3.3.2#js/omit/omit', function (require, exports, module) {
    module.exports = function (source, propsToOmit) {
        var result = {};
        for (var prop in source) {
            if (propsToOmit.indexOf(prop) < 0) {
                result[prop] = source[prop];
            }
        }
        return result;
    };
});
/*can-util@3.3.2#dom/dom*/
define('can-util@3.3.2#dom/dom', function (require, exports, module) {
    (function (global) {
        module.exports = {
            ajax: require('./ajax/ajax'),
            attr: require('./attr/attr'),
            childNodes: require('./child-nodes/child-nodes'),
            className: require('./class-name/class-name'),
            contains: require('./contains/contains'),
            data: require('./data/data'),
            dispatch: require('./dispatch/dispatch'),
            document: require('./document/document'),
            events: require('./events/events'),
            frag: require('./frag/frag'),
            fragment: require('./fragment/fragment'),
            isOfGlobalDocument: require('./is-of-global-document/is-of-global-document'),
            matches: require('./matches/matches'),
            mutate: require('./mutate/mutate'),
            mutationObserver: require('./mutation-observer/mutation-observer')
        };
    }(function () {
        return this;
    }()));
});
/*can-util@3.3.2#js/cid/cid*/
define('can-util@3.3.2#js/cid/cid', function (require, exports, module) {
    module.exports = require('can-cid');
});
/*can-util@3.3.2#js/is-browser-window/is-browser-window*/
define('can-util@3.3.2#js/is-browser-window/is-browser-window', function (require, exports, module) {
    (function (global) {
        module.exports = function () {
            return typeof window !== 'undefined' && typeof document !== 'undefined' && typeof SimpleDOM === 'undefined';
        };
    }(function () {
        return this;
    }()));
});
/*can-util@3.3.2#js/is-node/is-node*/
define('can-util@3.3.2#js/is-node/is-node', function (require, exports, module) {
    (function (global) {
        module.exports = function () {
            return typeof process === 'object' && {}.toString.call(process) === '[object process]';
        };
    }(function () {
        return this;
    }()));
});
/*can-util@3.3.2#js/is-string/is-string*/
define('can-util@3.3.2#js/is-string/is-string', function (require, exports, module) {
    module.exports = function isString(obj) {
        return typeof obj === 'string';
    };
});
/*can-util@3.3.2#js/is-web-worker/is-web-worker*/
define('can-util@3.3.2#js/is-web-worker/is-web-worker', function (require, exports, module) {
    (function (global) {
        module.exports = function () {
            return typeof WorkerGlobalScope !== 'undefined' && this instanceof WorkerGlobalScope;
        };
    }(function () {
        return this;
    }()));
});
/*can-util@3.3.2#js/types/types*/
define('can-util@3.3.2#js/types/types', function (require, exports, module) {
    module.exports = require('can-types');
});
/*can-util@3.3.2#js/js*/
define('can-util@3.3.2#js/js', function (require, exports, module) {
    (function (global) {
        module.exports = {
            assign: require('./assign/assign'),
            cid: require('./cid/cid'),
            deepAssign: require('./deep-assign/deep-assign'),
            dev: require('./dev/dev'),
            diff: require('./diff/diff'),
            each: require('./each/each'),
            global: require('./global/global'),
            'import': require('./import/import'),
            isArray: require('./is-array/is-array'),
            isArrayLike: require('./is-array-like/is-array-like'),
            isBrowserWindow: require('./is-browser-window/is-browser-window'),
            isEmptyObject: require('./is-empty-object/is-empty-object'),
            isFunction: require('./is-function/is-function'),
            isNode: require('./is-node/is-node'),
            isPlainObject: require('./is-plain-object/is-plain-object'),
            isPromise: require('./is-promise/is-promise'),
            isString: require('./is-string/is-string'),
            isWebWorker: require('./is-web-worker/is-web-worker'),
            joinURIs: require('./join-uris/join-uris'),
            last: require('./last/last'),
            makeArray: require('./make-array/make-array'),
            omit: require('./omit/omit'),
            setImmediate: require('./set-immediate/set-immediate'),
            string: require('./string/string'),
            types: require('./types/types')
        };
    }(function () {
        return this;
    }()));
});
/*can-util@3.3.2#can-util*/
define('can-util@3.3.2#can-util', function (require, exports, module) {
    var deepAssign = require('./js/deep-assign/deep-assign');
    var omit = require('./js/omit/omit');
    var namespace = require('can-namespace');
    module.exports = deepAssign(namespace, require('./dom/dom'), omit(require('./js/js'), [
        'cid',
        'types'
    ]));
});
/*can-construct-super@3.0.3#can-construct-super*/
define('can-construct-super@3.0.3#can-construct-super', function (require, exports, module) {
    (function (global) {
        var can = require('can-util');
        var Construct = require('can-construct');
        var isFunction = can.isFunction, fnTest = /xyz/.test(function () {
                return this.xyz;
            }) ? /\b_super\b/ : /.*/, getset = [
                'get',
                'set'
            ], getSuper = function (base, name, fn) {
                return function () {
                    var tmp = this._super, ret;
                    this._super = base[name];
                    ret = fn.apply(this, arguments);
                    this._super = tmp;
                    return ret;
                };
            };
        Construct._defineProperty = function (addTo, base, name, descriptor) {
            var _super = Object.getOwnPropertyDescriptor(base, name);
            if (_super) {
                can.each(getset, function (method) {
                    if (isFunction(_super[method]) && isFunction(descriptor[method])) {
                        descriptor[method] = getSuper(_super, method, descriptor[method]);
                    } else if (!isFunction(descriptor[method])) {
                        descriptor[method] = _super[method];
                    }
                });
            }
            Object.defineProperty(addTo, name, descriptor);
        };
        var getPrototypeOf = Object.getPrototypeOf || function (obj) {
            return obj.__proto__;
        };
        var getPropertyDescriptor = Object.getPropertyDescriptor || function (subject, name) {
            if (name in subject) {
                var pd = Object.getOwnPropertyDescriptor(subject, name);
                var proto = getPrototypeOf(subject);
                while (pd === undefined && proto !== null) {
                    pd = Object.getOwnPropertyDescriptor(proto, name);
                    proto = getPrototypeOf(proto);
                }
                return pd;
            }
        };
        Construct._overwrite = function (addTo, base, name, val) {
            var baseDescriptor = getPropertyDescriptor(base, name);
            var baseValue = baseDescriptor && baseDescriptor.value;
            Object.defineProperty(addTo, name, {
                value: isFunction(val) && isFunction(baseValue) && fnTest.test(val) ? getSuper(base, name, val) : val,
                configurable: true,
                enumerable: true,
                writable: true
            });
        };
        module.exports = Construct;
    }(function () {
        return this;
    }()));
});
/*can-construct-super@3.0.3#test/can-construct-super_test*/
define('can-construct-super@3.0.3#test/can-construct-super_test', function (require, exports, module) {
    (function (global) {
        var Construct = require('can-construct-super');
        var QUnit = require('steal-qunit');
        QUnit.module('can-construct-super');
        test('prototype super', function () {
            var A = Construct.extend({
                init: function (arg) {
                    this.arg = arg + 1;
                },
                add: function (num) {
                    return this.arg + num;
                }
            });
            var B = A({
                init: function (arg) {
                    this._super(arg + 2);
                },
                add: function (arg) {
                    return this._super(arg + 1);
                }
            });
            var b = new B(1);
            equal(b.arg, 4);
            equal(b.add(2), 7);
        });
        test('static super', function () {
            var First = Construct.extend({
                raise: function (num) {
                    return num;
                }
            }, {});
            var Second = First.extend({
                raise: function (num) {
                    return this._super(num) * num;
                }
            }, {});
            equal(Second.raise(2), 4);
        });
        test('findAll super', function () {
            var Parent = Construct.extend({
                findAll: function () {
                    equal(this.shortName, 'child');
                    return Promise.resolve();
                },
                shortName: 'parent'
            }, {});
            var Child = Parent.extend({
                findAll: function () {
                    return this._super();
                },
                shortName: 'child'
            }, {});
            stop();
            expect(1);
            Child.findAll({});
            start();
        });
        if (Object.getOwnPropertyDescriptor) {
            test('_super supports getters and setters', function () {
                var Person = Construct.extend({
                    get age() {
                        return 42;
                    },
                    set name(value) {
                        this._name = value;
                    },
                    get name() {
                        return this._name;
                    }
                });
                var OtherPerson = Person.extend({
                    get age() {
                        return this._super() + 8;
                    },
                    set name(value) {
                        this._super(value + '_super');
                    }
                });
                var test = new OtherPerson();
                test.base = 2;
                equal(test.age, 50, 'Getter and _super works');
                test.name = 'David';
                equal(test.name, 'David_super', 'Setter ran');
            });
        }
        QUnit.test('setters not invoked on extension (#9)', function () {
            var extending = true;
            var Base = Construct.extend('Base', {
                set something(value) {
                    QUnit.ok(!extending, 'set not called when not extending');
                },
                get something() {
                    QUnit.ok(!extending, 'get not called when not extending');
                }
            });
            Base.extend('Extended', { something: 'value' });
            extending = false;
            new Base().something = 'foo';
        });
        QUnit.test('_super isn\'t always available (#11)', function () {
            var Parent = Construct.extend({});
            var Child = Parent.extend({
                init: function () {
                    this._super();
                    ok(true);
                }
            });
            new Child();
        });
    }(function () {
        return this;
    }()));
});
/*can-define@1.0.17#list/list-test*/
define('can-define@1.0.17#list/list-test', function (require, exports, module) {
    'use strict';
    var QUnit = require('steal-qunit');
    var DefineList = require('can-define/list/list');
    var DefineMap = require('can-define/map/map');
    var Observation = require('can-observation');
    var define = require('can-define');
    var assign = require('can-util/js/assign/assign');
    var CID = require('can-cid');
    var types = require('can-types');
    var stache = require('can-stache');
    QUnit.module('can-define/list/list');
    QUnit.test('List is an event emitter', function (assert) {
        var Base = DefineList.extend({});
        assert.ok(Base.on, 'Base has event methods.');
        var List = Base.extend({});
        assert.ok(List.on, 'List has event methods.');
    });
    QUnit.test('creating an instance', function () {
        var list = new DefineList([
            'a',
            'b',
            'c'
        ]);
        list.on('add', function (ev, newVals, index) {
            QUnit.deepEqual(newVals, ['d']);
            QUnit.equal(index, 3);
        });
        list.push('d');
    });
    test('list attr changes length', function () {
        var l = new DefineList([
            0,
            1,
            2
        ]);
        l.set(3, 3);
        equal(l.length, 4);
    });
    test('remove on pop', function () {
        var l = new DefineList([
            0,
            1,
            2
        ]);
        l.pop();
        equal(l.length, 2);
        deepEqual(l.get(), [
            0,
            1
        ]);
    });
    test('list splice', function () {
        var l = new DefineList([
            0,
            1,
            2,
            3
        ]);
        l.on('add', function (ev, newVals, index) {
            deepEqual(newVals, [
                'a',
                'b'
            ], 'got the right newVals');
            equal(index, 1, 'adding items');
        });
        l.on('remove', function (ev, oldVals, index) {
            deepEqual(oldVals, [
                1,
                2
            ], 'got the right oldVals');
            equal(index, 1, 'no new Vals');
        });
        l.splice(1, 2, 'a', 'b');
        deepEqual(l.get(), [
            0,
            'a',
            'b',
            3
        ], 'serialized');
    });
    test('Array accessor methods', 11, function () {
        var l = new DefineList([
                'a',
                'b',
                'c'
            ]), sliced = l.slice(2), joined = l.join(' | '), concatenated = l.concat([
                2,
                1
            ], new DefineList([0]));
        ok(sliced instanceof DefineList, 'Slice is an Observable list');
        equal(sliced.length, 1, 'Sliced off two elements');
        equal(sliced[0], 'c', 'Single element as expected');
        equal(joined, 'a | b | c', 'Joined list properly');
        ok(concatenated instanceof DefineList, 'Concatenated is an Observable list');
        deepEqual(concatenated.serialize(), [
            'a',
            'b',
            'c',
            2,
            1,
            0
        ], 'DefineList concatenated properly');
        l.forEach(function (letter, index) {
            ok(true, 'Iteration');
            if (index === 0) {
                equal(letter, 'a', 'First letter right');
            }
            if (index === 2) {
                equal(letter, 'c', 'Last letter right');
            }
        });
    });
    test('Concatenated list items Equal original', function () {
        var l = new DefineList([
                { firstProp: 'Some data' },
                { secondProp: 'Next data' }
            ]), concatenated = l.concat([
                { hello: 'World' },
                { foo: 'Bar' }
            ]);
        ok(l[0] === concatenated[0], 'They are Equal');
        ok(l[1] === concatenated[1], 'They are Equal');
    });
    test('Lists with maps concatenate properly', function () {
        var Person = DefineMap.extend();
        var People = DefineList.extend({ '#': Person });
        var Genius = Person.extend();
        var Animal = DefineMap.extend();
        var me = new Person({ name: 'John' });
        var animal = new Animal({ name: 'Tak' });
        var genius = new Genius({ name: 'Einstein' });
        var hero = { name: 'Ghandi' };
        var people = new People([]);
        var specialPeople = new People([
            genius,
            hero
        ]);
        people = people.concat([
            me,
            animal,
            specialPeople
        ], specialPeople, [
            1,
            2
        ], 3);
        ok(people.length === 8, 'List length is right');
        ok(people[0] === me, 'Map in list === vars created before concat');
        ok(people[1] instanceof Person, 'Animal got serialized to Person');
    });
    test('splice removes items in IE (#562)', function () {
        var l = new DefineList(['a']);
        l.splice(0, 1);
        ok(!l.get(0), 'all props are removed');
    });
    test('reverse triggers add/remove events (#851)', function () {
        expect(5);
        var l = new DefineList([
            1,
            2,
            3
        ]);
        l.on('add', function () {
            ok(true, 'add called');
        });
        l.on('remove', function () {
            ok(true, 'remove called');
        });
        l.on('length', function () {
            ok(true, 'length should be called');
        });
        l.reverse();
        deepEqual(l.get(), [
            3,
            2,
            1
        ], 'reversed');
    });
    test('filter', function () {
        var l = new DefineList([
            {
                id: 1,
                name: 'John'
            },
            {
                id: 2,
                name: 'Mary'
            }
        ]);
        var filtered = l.filter(function (item) {
            return item.name === 'Mary';
        });
        notEqual(filtered._cid, l._cid, 'not same object');
        equal(filtered.length, 1, 'one item');
        equal(filtered[0].name, 'Mary', 'filter works');
    });
    test('No Add Events if DefineList Splice adds the same items that it is removing. (#1277, #1399)', function () {
        var list = new DefineList([
            'a',
            'b'
        ]);
        list.bind('add', function () {
            ok(false, 'Add callback should not be called.');
        });
        list.bind('remove', function () {
            ok(false, 'Remove callback should not be called.');
        });
        var result = list.splice(0, 2, 'a', 'b');
        deepEqual(result, [
            'a',
            'b'
        ]);
    });
    test('add event always returns an array as the value (#998)', function () {
        var list = new DefineList([]), msg;
        list.bind('add', function (ev, newElements, index) {
            deepEqual(newElements, [4], msg);
        });
        msg = 'works on push';
        list.push(4);
        list.pop();
        msg = 'works on attr()';
        list.set(0, 4);
        list.pop();
        msg = 'works on replace()';
        list.replace([4]);
    });
    test('Setting with .set() out of bounds of length triggers add event with leading undefineds', function () {
        var list = new DefineList([1]);
        list.bind('add', function (ev, newElements, index) {
            deepEqual(newElements, [
                undefined,
                undefined,
                4
            ], 'Leading undefineds are included');
            equal(index, 1, 'Index takes into account the leading undefineds from a .set()');
        });
        list.set(3, 4);
    });
    test('No events should fire if removals happened on empty arrays', function () {
        var list = new DefineList([]), msg;
        list.bind('remove', function (ev, removed, index) {
            ok(false, msg);
        });
        msg = 'works on pop';
        list.pop();
        msg = 'works on shift';
        list.shift();
        ok(true, 'No events were fired.');
    });
    test('setting an index out of bounds does not create an array', function () {
        expect(1);
        var l = new DefineList();
        l.set('1', 'foo');
        equal(l.get('1'), 'foo');
    });
    test('splice with similar but less items works (#1606)', function () {
        var list = new DefineList([
            'aa',
            'bb',
            'cc'
        ]);
        list.splice(0, list.length, 'aa', 'cc', 'dd');
        deepEqual(list.get(), [
            'aa',
            'cc',
            'dd'
        ]);
        list.splice(0, list.length, 'aa', 'cc');
        deepEqual(list.get(), [
            'aa',
            'cc'
        ]);
    });
    test('filter returns same list type (#1744)', function () {
        var ParentList = DefineList.extend();
        var ChildList = ParentList.extend();
        var children = new ChildList([
            1,
            2,
            3
        ]);
        ok(children.filter(function () {
        }) instanceof ChildList);
    });
    test('reverse returns the same list instance (#1744)', function () {
        var ParentList = DefineList.extend();
        var ChildList = ParentList.extend();
        var children = new ChildList([
            1,
            2,
            3
        ]);
        ok(children.reverse() === children);
    });
    test('slice and join are observable by a compute (#1884)', function () {
        expect(2);
        var list = new DefineList([
            1,
            2,
            3
        ]);
        var sliced = new Observation(function () {
            return list.slice(0, 1);
        }, null, {
            updater: function (newVal) {
                deepEqual(newVal.get(), [2], 'got a new DefineList');
            }
        });
        sliced.start();
        var joined = new Observation(function () {
            return list.join(',');
        }, null, {
            updater: function (newVal) {
                equal(newVal, '2,3', 'joined is observable');
            }
        });
        joined.start();
        list.shift();
    });
    test('list.replace', function () {
        var firstArray = [
            {
                id: 1,
                name: 'Marshall'
            },
            {
                id: 2,
                name: 'Austin'
            },
            {
                id: 3,
                name: 'Hyrum'
            }
        ];
        var myList = new DefineList(firstArray);
        var newArray = [
            {
                id: 4,
                name: 'Aubree'
            },
            {
                id: 5,
                name: 'Leah'
            },
            {
                id: 6,
                name: 'Lily'
            }
        ];
        myList.replace(newArray);
        equal(myList.length, 3);
        equal(myList[0].name, 'Aubree');
        equal(myList[1].name, 'Leah');
        equal(myList[2].name, 'Lily', 'Can replace a List with an Array.');
        myList.replace(firstArray);
        equal(myList.length, 3);
        equal(myList[0].name, 'Marshall');
        equal(myList[1].name, 'Austin');
        equal(myList[2].name, 'Hyrum', 'Can replace a List with another List.');
    });
    test('list.map', function () {
        var myArray = [
            {
                id: 1,
                name: 'Marshall'
            },
            {
                id: 2,
                name: 'Austin'
            },
            {
                id: 3,
                name: 'Hyrum'
            }
        ];
        var myList = new DefineList(myArray);
        var newList = myList.map(function (person) {
            person.lastName = 'Thompson';
            return person;
        });
        equal(newList.length, 3);
        equal(newList[0].name, 'Marshall');
        equal(newList[0].lastName, 'Thompson');
        equal(newList[1].name, 'Austin');
        equal(newList[1].lastName, 'Thompson');
        equal(newList[2].name, 'Hyrum');
        equal(newList[2].lastName, 'Thompson');
        var ExtendedList = DefineList.extend({
            testMe: function () {
                return 'It Worked!';
            }
        });
        var myExtendedList = new ExtendedList(myArray);
        var newExtendedList = myExtendedList.map(function (person) {
            person.lastName = 'Thompson';
            return person;
        });
        QUnit.equal('It Worked!', newExtendedList.testMe(), 'Returns the same type of list.');
    });
    test('list.sort a simple list', function () {
        var myList = new DefineList([
            'Marshall',
            'Austin',
            'Hyrum'
        ]);
        myList.sort();
        equal(myList.length, 3);
        equal(myList[0], 'Austin');
        equal(myList[1], 'Hyrum');
        equal(myList[2], 'Marshall', 'Basic list was properly sorted.');
    });
    test('list.sort a list of objects', function () {
        var objList = new DefineList([
            {
                id: 1,
                name: 'Marshall'
            },
            {
                id: 2,
                name: 'Austin'
            },
            {
                id: 3,
                name: 'Hyrum'
            }
        ]);
        objList.sort(function (a, b) {
            if (a.name < b.name) {
                return -1;
            } else if (a.name > b.name) {
                return 1;
            } else {
                return 0;
            }
        });
        equal(objList.length, 3);
        equal(objList[0].name, 'Austin');
        equal(objList[1].name, 'Hyrum');
        equal(objList[2].name, 'Marshall', 'List of objects was properly sorted.');
    });
    test('list.sort a list of DefineMaps', function () {
        var Account = DefineMap.extend({
            name: 'string',
            amount: 'number',
            slug: {
                serialize: true,
                get: function () {
                    return this.name.toLowerCase().replace(/ /g, '-').replace(/[^\w-]+/g, '');
                }
            }
        });
        Account.List = DefineList.extend({
            '*': Account,
            limit: 'number',
            skip: 'number',
            total: 'number'
        });
        var accounts = new Account.List([
            {
                name: 'Savings',
                amount: 20
            },
            {
                name: 'Checking',
                amount: 103.24
            },
            {
                name: 'Kids Savings',
                amount: 48155.13
            }
        ]);
        accounts.limit = 3;
        var template = stache('{{#each accounts}}{{name}},{{/each}}')({ accounts: accounts });
        equal(template.textContent, 'Savings,Checking,Kids Savings,', 'template rendered properly.');
        accounts.sort(function (a, b) {
            if (a.name < b.name) {
                return -1;
            } else if (a.name > b.name) {
                return 1;
            } else {
                return 0;
            }
        });
        equal(accounts.length, 3);
        equal(template.textContent, 'Checking,Kids Savings,Savings,', 'template updated properly.');
        accounts.sort(function (a, b) {
            if (a.slug < b.slug) {
                return 1;
            } else if (a.slug > b.slug) {
                return -1;
            } else {
                return 0;
            }
        });
        equal(accounts.length, 3);
        equal(accounts.limit, 3, 'expandos still present after sorting/replacing.');
        equal(template.textContent, 'Savings,Kids Savings,Checking,', 'template updated properly.');
    });
    test('list.sort a list of objects without losing reference (#137)', function () {
        var unSorted = new DefineList([
            { id: 3 },
            { id: 2 },
            { id: 1 }
        ]);
        var sorted = unSorted.slice(0).sort(function (a, b) {
            return a.id > b.id ? 1 : a.id < b.id ? -1 : 0;
        });
        equal(unSorted[0], sorted[2], 'items should be equal');
    });
    test('list defines', 6, function () {
        var Todo = function (props) {
            assign(this, props);
            CID(this);
        };
        define(Todo.prototype, {
            completed: 'boolean',
            destroyed: { value: false }
        });
        Todo.prototype.destroy = function () {
            this.destroyed = true;
        };
        var TodoList = DefineList.extend({
            '*': Todo,
            remaining: {
                get: function () {
                    return this.filter({ completed: false });
                }
            },
            completed: {
                get: function () {
                    return this.filter({ completed: true });
                }
            },
            destroyCompleted: function () {
                this.completed.forEach(function (todo) {
                    todo.destroy();
                });
            },
            setCompletedTo: function (value) {
                this.forEach(function (todo) {
                    todo.completed = value;
                });
            }
        });
        var todos = new TodoList([
            { completed: true },
            { completed: false }
        ]);
        ok(todos.item(0) instanceof Todo, 'correct instance');
        equal(todos.completed.length, 1, 'only one todo');
        todos.on('completed', function (ev, newVal, oldVal) {
            ok(newVal instanceof TodoList, 'right type');
            equal(newVal.length, 2, 'all items');
            ok(oldVal instanceof TodoList, 'right type');
            equal(oldVal.length, 1, 'all items');
        });
        todos.setCompletedTo(true);
    });
    QUnit.test('extending the base supports overwriting _eventSetup', function () {
        var L = DefineList.extend({});
        Object.getOwnPropertyDescriptor(DefineMap.prototype, '_eventSetup');
        L.prototype.arbitraryProp = true;
        ok(true, 'set arbitraryProp');
        L.prototype._eventSetup = function () {
        };
        ok(true, 'worked');
    });
    QUnit.test('setting expandos on a DefineList', function () {
        var DL = DefineList.extend({ count: 'number' });
        var dl = new DL();
        dl.set({
            count: 5,
            skip: 2
        });
        QUnit.equal(dl.get('count'), 5, 'read with .get defined');
        QUnit.equal(dl.count, 5, 'read with . defined');
        QUnit.equal(dl.get('skip'), 2, 'read with .get expando');
        QUnit.equal(dl.skip, 2, 'read with . expando');
        QUnit.equal(dl.get('limit'), undefined, 'read with .get undefined');
    });
    QUnit.test('passing a DefineList to DefineList (#33)', function () {
        var m = new DefineList([
            {},
            {}
        ]);
        var m2 = new DefineList(m);
        QUnit.deepEqual(m.get(), m2.get());
        QUnit.ok(m[0] === m2[0], 'index the same');
        QUnit.ok(m[1] === m2[1], 'index the same');
    });
    QUnit.test('reading and setting expandos', function () {
        var list = new DefineList();
        var countObservation = new Observation(function () {
            return list.get('count');
        }, null, function (newValue) {
            QUnit.equal(newValue, 1000, 'got new value');
        });
        countObservation.start();
        list.set('count', 1000);
        QUnit.equal(countObservation.value, 1000);
        var list2 = new DefineList();
        list2.on('count', function (ev, newVal) {
            QUnit.equal(newVal, 5);
        });
        list2.set('count', 5);
    });
    QUnit.test('is list like', function () {
        var list = new DefineList();
        QUnit.ok(types.isListLike(list));
    });
    QUnit.test('extending DefineList constructor functions (#61)', function () {
        var AList = DefineList.extend('AList', {
            aProp: {},
            aMethod: function () {
            }
        });
        var BList = AList.extend('BList', {
            bProp: {},
            bMethod: function () {
            }
        });
        var CList = BList.extend('CList', {
            cProp: {},
            cMethod: function () {
            }
        });
        var list = new CList([
            {},
            {}
        ]);
        list.on('aProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'PROP');
            QUnit.equal(oldVal, undefined);
        });
        list.on('bProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'FOO');
            QUnit.equal(oldVal, undefined);
        });
        list.on('cProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'BAR');
            QUnit.equal(oldVal, undefined);
        });
        list.aProp = 'PROP';
        list.bProp = 'FOO';
        list.cProp = 'BAR';
        QUnit.ok(list.aMethod);
        QUnit.ok(list.bMethod);
        QUnit.ok(list.cMethod);
    });
    QUnit.test('extending DefineList constructor functions more than once (#61)', function () {
        var AList = DefineList.extend('AList', {
            aProp: {},
            aMethod: function () {
            }
        });
        var BList = AList.extend('BList', {
            bProp: {},
            bMethod: function () {
            }
        });
        var CList = AList.extend('CList', {
            cProp: {},
            cMethod: function () {
            }
        });
        var list1 = new BList([
            {},
            {}
        ]);
        var list2 = new CList([
            {},
            {},
            {}
        ]);
        list1.on('aProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'PROP', 'aProp newVal on list1');
            QUnit.equal(oldVal, undefined);
        });
        list1.on('bProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'FOO', 'bProp newVal on list1');
            QUnit.equal(oldVal, undefined);
        });
        list2.on('aProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'PROP', 'aProp newVal on list2');
            QUnit.equal(oldVal, undefined);
        });
        list2.on('cProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'BAR', 'cProp newVal on list2');
            QUnit.equal(oldVal, undefined);
        });
        list1.aProp = 'PROP';
        list1.bProp = 'FOO';
        list2.aProp = 'PROP';
        list2.cProp = 'BAR';
        QUnit.ok(list1.aMethod, 'list1 aMethod');
        QUnit.ok(list1.bMethod);
        QUnit.ok(list2.aMethod);
        QUnit.ok(list2.cMethod, 'list2 cMethod');
    });
    QUnit.test('extending DefineList constructor functions - value (#61)', function () {
        var AList = DefineList.extend('AList', { aProp: { value: 1 } });
        var BList = AList.extend('BList', {});
        var CList = BList.extend('CList', {});
        var c = new CList([]);
        QUnit.equal(c.aProp, 1, 'got initial value');
    });
    QUnit.test('\'*\' inheritance works (#61)', function () {
        var Account = DefineMap.extend({
            name: 'string',
            amount: 'number',
            slug: {
                serialize: true,
                get: function () {
                    return this.name.toLowerCase().replace(/ /g, '-').replace(/[^\w-]+/g, '');
                }
            }
        });
        var BaseList = DefineList.extend({ '*': Account });
        var ExtendedList = BaseList.extend({});
        var xl = new ExtendedList([{}]);
        QUnit.ok(xl[0] instanceof Account);
    });
    QUnit.test('shorthand getter setter (#56)', function () {
        var People = DefineList.extend({
            first: '*',
            last: '*',
            get fullName() {
                return this.first + ' ' + this.last;
            },
            set fullName(newVal) {
                var parts = newVal.split(' ');
                this.first = parts[0];
                this.last = parts[1];
            }
        });
        var p = new People([]);
        p.fullName = 'Mohamed Cherif';
        p.on('fullName', function (ev, newVal, oldVal) {
            QUnit.equal(oldVal, 'Mohamed Cherif');
            QUnit.equal(newVal, 'Justin Meyer');
        });
        equal(p.fullName, 'Mohamed Cherif', 'fullName initialized right');
        p.fullName = 'Justin Meyer';
    });
    QUnit.test('added and removed are called after items are added/removed (#14)', function () {
        var Person = DefineMap.extend({
            id: 'number',
            name: 'string'
        });
        var addedFuncCalled, removedFuncCalled, theList;
        var People = DefineList.extend({
            '#': {
                added: function (items, index) {
                    addedFuncCalled = true;
                    ok(items, 'items added got passed to added');
                    ok(typeof index === 'number', 'index of items was passed to added and is a number');
                    ok(items[0].name === 'John', 'Name was correct');
                    theList = this;
                },
                removed: function (items, index) {
                    removedFuncCalled = true;
                    ok(items, 'items added got passed to removed');
                    ok(typeof index === 'number', 'index of items was passed to removed and is a number');
                    theList = this;
                },
                Type: Person
            },
            outsideProp: {
                type: 'boolean',
                value: true
            }
        });
        var people = new People([]);
        var me = new Person();
        me.name = 'John';
        me.id = '1234';
        ok(!addedFuncCalled, 'added function has not been called yet');
        people.push(me);
        ok(addedFuncCalled, 'added function was called');
        ok(theList.outsideProp === true && theList instanceof People, 'the list was passed correctly as this to added');
        theList = null;
        ok(!removedFuncCalled, 'removed function has not been called yet');
        people.splice(people.indexOf(me), 1);
        ok(removedFuncCalled, 'removed function was called');
        ok(theList.outsideProp === true && theList instanceof People, 'the list was passed correctly as this to removed');
    });
    QUnit.test('* vs # (#78)', function () {
        var MyList = DefineList.extend({
            '*': 'number',
            '#': {
                added: function () {
                    ok(true, 'called on init');
                },
                removed: function () {
                },
                type: 'string'
            }
        });
        var list = new MyList([
            1,
            2,
            3
        ]);
        QUnit.ok(list[0] === '1', 'converted to string');
        list.set('prop', '4');
        QUnit.ok(list.prop === 4, 'type converted');
    });
    QUnit.test('Array shorthand uses #', function () {
        var MyMap = DefineMap.extend({ 'numbers': ['number'] });
        var map = new MyMap({
            numbers: [
                '1',
                '2'
            ]
        });
        QUnit.ok(map.numbers[0] === 1, 'converted to number');
        map.numbers.set('prop', '4');
        QUnit.ok(map.numbers.prop === '4', 'type left alone');
    });
});
/*can-define@1.0.17#map/map-test*/
define('can-define@1.0.17#map/map-test', function (require, exports, module) {
    'use strict';
    var QUnit = require('steal-qunit');
    var DefineMap = require('can-define/map/map');
    var Observation = require('can-observation');
    var canTypes = require('can-types');
    var each = require('can-util/js/each/each');
    var sealWorks = function () {
        try {
            var o = {};
            Object.seal(o);
            o.prop = true;
            return false;
        } catch (e) {
            return true;
        }
    }();
    QUnit.module('can-define/map/map');
    QUnit.test('Map is an event emitter', function (assert) {
        var Base = DefineMap.extend({});
        assert.ok(Base.on, 'Base has event methods.');
        var Map = Base.extend({});
        assert.ok(Map.on, 'Map has event methods.');
    });
    QUnit.test('creating an instance', function () {
        var map = new DefineMap({ prop: 'foo' });
        map.on('prop', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'BAR');
            QUnit.equal(oldVal, 'foo');
        });
        map.prop = 'BAR';
    });
    QUnit.test('creating an instance with nested prop', function () {
        var map = new DefineMap({ name: { first: 'Justin' } });
        map.name.on('first', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'David');
            QUnit.equal(oldVal, 'Justin');
        });
        map.name.first = 'David';
    });
    QUnit.test('extending', function () {
        var MyMap = DefineMap.extend({ prop: {} });
        var map = new MyMap();
        map.on('prop', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'BAR');
            QUnit.equal(oldVal, undefined);
        });
        map.prop = 'BAR';
    });
    QUnit.test('loop only through defined serializable props', function () {
        var MyMap = DefineMap.extend({
            propA: {},
            propB: { serialize: false },
            propC: {
                get: function () {
                    return this.propA;
                }
            }
        });
        var inst = new MyMap({
            propA: 1,
            propB: 2
        });
        QUnit.deepEqual(Object.keys(inst.get()), ['propA']);
    });
    QUnit.test('get and set can setup expandos', function () {
        var map = new DefineMap();
        var oi = new Observation(function () {
            return map.get('foo');
        }, null, {
            updater: function (newVal) {
                QUnit.equal(newVal, 'bar', 'updated to bar');
            }
        });
        oi.start();
        map.set('foo', 'bar');
    });
    QUnit.test('default settings', function () {
        var MyMap = DefineMap.extend({
            '*': 'string',
            foo: {}
        });
        var m = new MyMap();
        m.set('foo', 123);
        QUnit.ok(m.get('foo') === '123');
    });
    QUnit.test('default settings on unsealed', function () {
        var MyMap = DefineMap.extend({ seal: false }, { '*': 'string' });
        var m = new MyMap();
        m.set('foo', 123);
        QUnit.ok(m.get('foo') === '123');
    });
    if (!System.isEnv('production')) {
        QUnit.test('extends sealed objects (#48)', function () {
            var Map1 = DefineMap.extend({ seal: true }, {
                name: {
                    get: function (curVal) {
                        return 'computed ' + curVal;
                    }
                }
            });
            var Map2 = Map1.extend({ seal: false }, {});
            var Map3 = Map2.extend({ seal: true }, {});
            var map1 = new Map1({ name: 'Justin' });
            try {
                map1.foo = 'bar';
                if (map1.foo) {
                    QUnit.ok(false, 'map1 not sealed');
                } else {
                    QUnit.ok(true, 'map1 sealed - silent failure');
                }
            } catch (ex) {
                QUnit.ok(true, 'map1 sealed');
            }
            QUnit.equal(map1.name, 'computed Justin', 'map1.name property is computed');
            var map2 = new Map2({ name: 'Brian' });
            try {
                map2.foo = 'bar';
                if (map2.foo) {
                    QUnit.ok(true, 'map2 not sealed');
                } else {
                    QUnit.ok(false, 'map2 sealed');
                }
            } catch (ex) {
                QUnit.ok(false, 'map2 sealed');
            }
            QUnit.equal(map2.name, 'computed Brian', 'map2.name property is computed');
            var map3 = new Map3({ name: 'Curtis' });
            try {
                map3.foo = 'bar';
                if (map3.foo) {
                    QUnit.ok(false, 'map3 not sealed');
                } else {
                    QUnit.ok(true, 'map3 sealed');
                }
            } catch (ex) {
                QUnit.ok(true, 'map3 sealed');
            }
            QUnit.equal(map3.name, 'computed Curtis', 'map3.name property is computed');
        });
    }
    QUnit.test('get with dynamically added properties', function () {
        var map = new DefineMap();
        map.set('a', 1);
        map.set('b', 2);
        QUnit.deepEqual(map.get(), {
            a: 1,
            b: 2
        });
    });
    QUnit.test('set multiple props', function () {
        var map = new DefineMap();
        map.set({
            a: 0,
            b: 2
        });
        QUnit.deepEqual(map.get(), {
            a: 0,
            b: 2
        });
        map.set({ a: 2 }, true);
        QUnit.deepEqual(map.get(), { a: 2 });
        map.set({ foo: { bar: 'VALUE' } });
        QUnit.deepEqual(map.get(), {
            foo: { bar: 'VALUE' },
            a: 2
        });
    });
    QUnit.test('serialize responds to added props', function () {
        var map = new DefineMap();
        var oi = new Observation(function () {
            return map.serialize();
        }, null, {
            updater: function (newVal) {
                QUnit.deepEqual(newVal, {
                    a: 1,
                    b: 2
                }, 'updated right');
            }
        });
        oi.start();
        map.set({
            a: 1,
            b: 2
        });
    });
    QUnit.test('initialize an undefined property', function () {
        var MyMap = DefineMap.extend({ seal: false }, {});
        var instance = new MyMap({ foo: 'bar' });
        equal(instance.foo, 'bar');
    });
    QUnit.test('set an already initialized null property', function () {
        var map = new DefineMap({ foo: null });
        map.set({ foo: null });
        equal(map.foo, null);
    });
    QUnit.test('creating a new key doesn\'t cause two changes', 1, function () {
        var map = new DefineMap();
        var oi = new Observation(function () {
            return map.serialize();
        }, null, {
            updater: function (newVal) {
                QUnit.deepEqual(newVal, { a: 1 }, 'updated right');
            }
        });
        oi.start();
        map.set('a', 1);
    });
    QUnit.test('setting nested object', function () {
        var m = new DefineMap({});
        m.set({ foo: {} });
        m.set({ foo: {} });
        QUnit.deepEqual(m.get(), { foo: {} });
    });
    QUnit.test('passing a DefineMap to DefineMap (#33)', function () {
        var MyMap = DefineMap.extend({ foo: 'observable' });
        var m = new MyMap({
            foo: {},
            bar: {}
        });
        var m2 = new MyMap(m);
        QUnit.deepEqual(m.get(), m2.get());
        QUnit.ok(m.foo === m2.foo, 'defined props the same');
        QUnit.ok(m.bar === m2.bar, 'expando props the same');
    });
    QUnit.test('serialize: function works (#38)', function () {
        var Something = DefineMap.extend({});
        var MyMap = DefineMap.extend({
            somethingRef: {
                type: function (val) {
                    return new Something({ id: val });
                },
                serialize: function (val) {
                    return val.id;
                }
            },
            somethingElseRef: {
                type: function (val) {
                    return new Something({ id: val });
                },
                serialize: false
            }
        });
        var myMap = new MyMap({
            somethingRef: 2,
            somethingElseRef: 3
        });
        QUnit.ok(myMap.somethingRef instanceof Something);
        QUnit.deepEqual(myMap.serialize(), { somethingRef: 2 }, 'serialize: function and serialize: false works');
        var MyMap2 = DefineMap.extend({
            '*': {
                serialize: function (value) {
                    return '' + value;
                }
            }
        });
        var myMap2 = new MyMap2({
            foo: 1,
            bar: 2
        });
        QUnit.deepEqual(myMap2.serialize(), {
            foo: '1',
            bar: '2'
        }, 'serialize: function on default works');
    });
    QUnit.test('isMapLike', function () {
        var map = new DefineMap({});
        ok(canTypes.isMapLike(map), 'is map like');
    });
    QUnit.test('get will not create properties', function () {
        var method = function () {
        };
        var MyMap = DefineMap.extend({ method: method });
        var m = new MyMap();
        m.get('foo');
        QUnit.equal(m.get('method'), method);
    });
    QUnit.test('Properties are enumerable', function () {
        QUnit.expect(4);
        var VM = DefineMap.extend({ foo: 'string' });
        var vm = new VM({
            foo: 'bar',
            baz: 'qux'
        });
        var i = 0;
        each(vm, function (value, key) {
            if (i === 0) {
                QUnit.equal(key, 'foo');
                QUnit.equal(value, 'bar');
            } else {
                QUnit.equal(key, 'baz');
                QUnit.equal(value, 'qux');
            }
            i++;
        });
    });
    QUnit.test('Getters are not enumerable', function () {
        QUnit.expect(2);
        var MyMap = DefineMap.extend({
            foo: 'string',
            baz: {
                get: function () {
                    return this.foo;
                }
            }
        });
        var map = new MyMap({ foo: 'bar' });
        each(map, function (value, key) {
            QUnit.equal(key, 'foo');
            QUnit.equal(value, 'bar');
        });
    });
    QUnit.test('extending DefineMap constructor functions (#18)', function () {
        var AType = DefineMap.extend('AType', {
            aProp: {},
            aMethod: function () {
            }
        });
        var BType = AType.extend('BType', {
            bProp: {},
            bMethod: function () {
            }
        });
        var CType = BType.extend('CType', {
            cProp: {},
            cMethod: function () {
            }
        });
        var map = new CType();
        map.on('aProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'PROP');
            QUnit.equal(oldVal, undefined);
        });
        map.on('bProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'FOO');
            QUnit.equal(oldVal, undefined);
        });
        map.on('cProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'BAR');
            QUnit.equal(oldVal, undefined);
        });
        map.aProp = 'PROP';
        map.bProp = 'FOO';
        map.cProp = 'BAR';
        QUnit.ok(map.aMethod);
        QUnit.ok(map.bMethod);
        QUnit.ok(map.cMethod);
    });
    QUnit.test('extending DefineMap constructor functions more than once (#18)', function () {
        var AType = DefineMap.extend('AType', {
            aProp: {},
            aMethod: function () {
            }
        });
        var BType = AType.extend('BType', {
            bProp: {},
            bMethod: function () {
            }
        });
        var CType = AType.extend('CType', {
            cProp: {},
            cMethod: function () {
            }
        });
        var map1 = new BType();
        var map2 = new CType();
        map1.on('aProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'PROP', 'aProp newVal on map1');
            QUnit.equal(oldVal, undefined);
        });
        map1.on('bProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'FOO', 'bProp newVal on map1');
            QUnit.equal(oldVal, undefined);
        });
        map2.on('aProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'PROP', 'aProp newVal on map2');
            QUnit.equal(oldVal, undefined);
        });
        map2.on('cProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'BAR', 'cProp newVal on map2');
            QUnit.equal(oldVal, undefined);
        });
        map1.aProp = 'PROP';
        map1.bProp = 'FOO';
        map2.aProp = 'PROP';
        map2.cProp = 'BAR';
        QUnit.ok(map1.aMethod, 'map1 aMethod');
        QUnit.ok(map1.bMethod);
        QUnit.ok(map2.aMethod);
        QUnit.ok(map2.cMethod, 'map2 cMethod');
    });
    QUnit.test('extending DefineMap constructor functions - value (#18)', function () {
        var AType = DefineMap.extend('AType', { aProp: { value: 1 } });
        var BType = AType.extend('BType', {});
        var CType = BType.extend('CType', {});
        var c = new CType();
        QUnit.equal(c.aProp, 1, 'got initial value');
    });
    QUnit.test('shorthand getter setter (#56)', function () {
        var Person = DefineMap.extend({
            first: '*',
            last: '*',
            get fullName() {
                return this.first + ' ' + this.last;
            },
            set fullName(newVal) {
                var parts = newVal.split(' ');
                this.first = parts[0];
                this.last = parts[1];
            }
        });
        var p = new Person({
            first: 'Mohamed',
            last: 'Cherif'
        });
        p.on('fullName', function (ev, newVal, oldVal) {
            QUnit.equal(oldVal, 'Mohamed Cherif');
            QUnit.equal(newVal, 'Justin Meyer');
        });
        equal(p.fullName, 'Mohamed Cherif', 'fullName initialized right');
        p.fullName = 'Justin Meyer';
    });
    QUnit.test('compute props can be set to null or undefined (#2372)', function () {
        var VM = DefineMap.extend({ computeProp: { type: 'compute' } });
        var vmNull = new VM({ computeProp: null });
        QUnit.equal(vmNull.get('computeProp'), null, 'computeProp is null, no error thrown');
        var vmUndef = new VM({ computeProp: undefined });
        QUnit.equal(vmUndef.get('computeProp'), undefined, 'computeProp is undefined, no error thrown');
    });
    QUnit.test('Inheriting DefineMap .set doesn\'t work if prop is on base map (#74)', function () {
        var Base = DefineMap.extend({ baseProp: 'string' });
        var Inheriting = Base.extend();
        var inherting = new Inheriting();
        inherting.set('baseProp', 'value');
        QUnit.equal(inherting.baseProp, 'value', 'set prop');
    });
    if (sealWorks && System.env.indexOf('production') < 0) {
        QUnit.test('setting not defined property', function () {
            var MyMap = DefineMap.extend({ prop: {} });
            var mymap = new MyMap();
            try {
                mymap.notdefined = 'value';
                ok(false, 'no error');
            } catch (e) {
                ok(true, 'error thrown');
            }
        });
    }
    QUnit.test('.extend errors when re-defining a property (#117)', function () {
        var A = DefineMap.extend('A', {
            foo: {
                type: 'string',
                value: 'blah'
            }
        });
        A.extend('B', {
            foo: {
                type: 'string',
                value: 'flub'
            }
        });
        var C = DefineMap.extend('C', {
            foo: {
                get: function () {
                    return 'blah';
                }
            }
        });
        C.extend('D', {
            foo: {
                get: function () {
                    return 'flub';
                }
            }
        });
        QUnit.ok(true, 'extended without errors');
    });
});
/*can-define@1.0.17#define-test*/
define('can-define@1.0.17#define-test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var compute = require('can-compute');
    var define = require('can-define');
    var stache = require('can-stache');
    var CanList = require('can-list');
    var canBatch = require('can-event/batch/batch');
    var isArray = require('can-util/js/is-array/is-array');
    var each = require('can-util/js/each/each');
    var types = require('can-types');
    QUnit.module('can-define');
    QUnit.test('basics on a prototype', 5, function () {
        var Person = function (first, last) {
            this.first = first;
            this.last = last;
        };
        define(Person.prototype, {
            first: '*',
            last: '*',
            fullName: {
                get: function () {
                    return this.first + ' ' + this.last;
                }
            }
        });
        var p = new Person('Mohamed', 'Cherif');
        p.bind('fullName', function (ev, newVal, oldVal) {
            QUnit.equal(oldVal, 'Mohamed Cherif');
            QUnit.equal(newVal, 'Justin Meyer');
        });
        equal(p.fullName, 'Mohamed Cherif', 'fullName initialized right');
        p.bind('first', function (el, newVal, oldVal) {
            QUnit.equal(newVal, 'Justin', 'first new value');
            QUnit.equal(oldVal, 'Mohamed', 'first old value');
        });
        canBatch.start();
        p.first = 'Justin';
        p.last = 'Meyer';
        canBatch.stop();
    });
    QUnit.test('basics set', 2, function () {
        var Defined = function (prop) {
            this.prop = prop;
        };
        define(Defined.prototype, {
            prop: {
                set: function (newVal) {
                    return 'foo' + newVal;
                }
            }
        });
        var def = new Defined();
        def.prop = 'bar';
        QUnit.equal(def.prop, 'foobar', 'setter works');
        var DefinedCB = function (prop) {
            this.prop = prop;
        };
        define(DefinedCB.prototype, {
            prop: {
                set: function (newVal, setter) {
                    setter('foo' + newVal);
                }
            }
        });
        var defCallback = new DefinedCB();
        defCallback.prop = 'bar';
        QUnit.equal(defCallback.prop, 'foobar', 'setter callback works');
    });
    QUnit.test('basic type', function () {
        QUnit.expect(6);
        var Typer = function (arrayWithAddedItem, listWithAddedItem) {
            this.arrayWithAddedItem = arrayWithAddedItem;
            this.listWithAddedItem = listWithAddedItem;
        };
        define(Typer.prototype, {
            arrayWithAddedItem: {
                type: function (value) {
                    if (value && value.push) {
                        value.push('item');
                    }
                    return value;
                }
            },
            listWithAddedItem: {
                type: function (value) {
                    if (value && value.push) {
                        value.push('item');
                    }
                    return value;
                },
                Type: CanList
            }
        });
        var t = new Typer();
        deepEqual(Object.keys(t), [], 'no keys');
        var array = [];
        t.arrayWithAddedItem = array;
        deepEqual(array, ['item'], 'updated array');
        QUnit.equal(t.arrayWithAddedItem, array, 'leave value as array');
        t.listWithAddedItem = [];
        QUnit.ok(t.listWithAddedItem instanceof CanList, 'convert to CanList');
        QUnit.equal(t.listWithAddedItem[0], 'item', 'has item in it');
        compute(function () {
            return t.listWithAddedItem.attr('length');
        }).addEventListener('change', function (ev, newVal) {
            QUnit.equal(newVal, 2, 'got a length change');
        });
        t.listWithAddedItem.push('another item');
    });
    QUnit.test('basic Type', function () {
        var Foo = function (name) {
            this.name = name;
        };
        Foo.prototype.getName = function () {
            return this.name;
        };
        var Typer = function (foo) {
            this.foo = foo;
        };
        define(Typer.prototype, { foo: { Type: Foo } });
        var t = new Typer('Justin');
        QUnit.equal(t.foo.getName(), 'Justin', 'correctly created an instance');
        var brian = new Foo('brian');
        t.foo = brian;
        QUnit.equal(t.foo, brian, 'same instances');
    });
    QUnit.test('type converters', function () {
        var Typer = function (date, string, number, bool, htmlbool, leaveAlone) {
            this.date = date;
            this.string = string;
            this.number = number;
            this.bool = bool;
            this.htmlbool = htmlbool;
            this.leaveAlone = leaveAlone;
        };
        define(Typer.prototype, {
            date: { type: 'date' },
            string: { type: 'string' },
            number: { type: 'number' },
            bool: { type: 'boolean' },
            htmlbool: { type: 'htmlbool' },
            leaveAlone: { type: '*' }
        });
        var obj = {};
        var t = new Typer(1395896701516, 5, '5', 'false', '', obj);
        QUnit.ok(t.date instanceof Date, 'converted to date');
        QUnit.equal(t.string, '5', 'converted to string');
        QUnit.equal(t.number, 5, 'converted to number');
        QUnit.equal(t.bool, false, 'converted to boolean');
        QUnit.equal(t.htmlbool, true, 'converted to htmlbool');
        QUnit.equal(t.leaveAlone, obj, 'left as object');
        t.number = '15';
        QUnit.ok(t.number === 15, 'converted to number');
    });
    QUnit.test('basics value', function () {
        var Typer = function (prop) {
            if (prop !== undefined) {
                this.prop = prop;
            }
        };
        define(Typer.prototype, { prop: { value: 'foo' } });
        var t = new Typer();
        QUnit.equal(t.prop, 'foo', 'value is used as default value');
        var Typer2 = function (prop) {
            if (prop !== undefined) {
                this.prop = prop;
            }
        };
        define(Typer2.prototype, {
            prop: {
                value: function () {
                    return [];
                },
                type: '*'
            }
        });
        var t1 = new Typer2(), t2 = new Typer2();
        QUnit.ok(t1.prop !== t2.prop, 'different array instances');
        QUnit.ok(isArray(t1.prop), 'its an array');
    });
    test('basics Value', function () {
        var Typer = function (prop) {
        };
        define(Typer.prototype, {
            prop: {
                Value: Array,
                type: '*'
            }
        });
        var t1 = new Typer(), t2 = new Typer();
        QUnit.ok(t1.prop !== t2.prop, 'different array instances');
        QUnit.ok(isArray(t1.prop), 'its an array');
    });
    test('setter with no arguments and returns undefined does the default behavior, the setter is for side effects only', function () {
        var Typer = function (prop) {
        };
        define(Typer.prototype, {
            prop: {
                set: function () {
                    this.foo = 'bar';
                }
            },
            foo: '*'
        });
        var t = new Typer();
        t.prop = false;
        deepEqual({
            foo: t.foo,
            prop: t.prop
        }, {
            foo: 'bar',
            prop: false
        }, 'got the right props');
    });
    test('type happens before the set', 2, function () {
        var Typer = function () {
        };
        define(Typer.prototype, {
            prop: {
                type: 'number',
                set: function (newValue) {
                    equal(typeof newValue, 'number', 'got a number');
                    return newValue + 1;
                }
            }
        });
        var map = new Typer();
        map.prop = '5';
        equal(map.prop, 6, 'number');
    });
    test('getter and setter work', function () {
        expect(5);
        var Paginate = define.Constructor({
            limit: '*',
            offset: '*',
            page: {
                set: function (newVal) {
                    this.offset = (parseInt(newVal) - 1) * this.limit;
                },
                get: function () {
                    return Math.floor(this.offset / this.limit) + 1;
                }
            }
        });
        var p = new Paginate({
            limit: 10,
            offset: 20
        });
        equal(p.page, 3, 'page get right');
        p.bind('page', function (ev, newValue, oldValue) {
            equal(newValue, 2, 'got new value event');
            equal(oldValue, 3, 'got old value event');
        });
        p.page = 2;
        equal(p.page, 2, 'page set right');
        equal(p.offset, 10, 'page offset set');
    });
    test('getter with initial value', function () {
        var comp = compute(1);
        var Grabber = define.Constructor({
            vals: {
                type: '*',
                Value: Array,
                get: function (current, setVal) {
                    if (setVal) {
                        current.push(comp());
                    }
                    return current;
                }
            }
        });
        var g = new Grabber();
        equal(g.vals.length, 0, 'zero items in array');
    });
    test('Value generator can read other properties', function () {
        var Map = define.Constructor({
            letters: { value: 'ABC' },
            numbers: {
                value: [
                    1,
                    2,
                    3
                ]
            },
            definedLetters: { value: 'DEF' },
            definedNumbers: {
                value: [
                    4,
                    5,
                    6
                ]
            },
            generatedLetters: {
                value: function () {
                    return 'GHI';
                }
            },
            generatedNumbers: {
                value: function () {
                    return new CanList([
                        7,
                        8,
                        9
                    ]);
                }
            },
            firstLetter: {
                value: function () {
                    return this.letters.substr(0, 1);
                }
            },
            firstNumber: {
                value: function () {
                    return this.numbers[0];
                }
            },
            middleLetter: {
                value: function () {
                    return this.definedLetters.substr(1, 1);
                }
            },
            middleNumber: {
                value: function () {
                    return this.definedNumbers[1];
                }
            },
            lastLetter: {
                value: function () {
                    return this.generatedLetters.substr(2, 1);
                }
            },
            lastNumber: {
                value: function () {
                    return this.generatedNumbers[2];
                }
            }
        });
        var map = new Map();
        var prefix = 'Was able to read dependent value from ';
        equal(map.firstLetter, 'A', prefix + 'traditional can.Map style property definition');
        equal(map.firstNumber, 1, prefix + 'traditional can.Map style property definition');
        equal(map.middleLetter, 'E', prefix + 'define plugin style default property definition');
        equal(map.middleNumber, 5, prefix + 'define plugin style default property definition');
        equal(map.lastLetter, 'I', prefix + 'define plugin style generated default property definition');
        equal(map.lastNumber, 9, prefix + 'define plugin style generated default property definition');
    });
    test('default behaviors with "*" work for attributes', function () {
        expect(6);
        var DefaultMap = define.Constructor({
            '*': {
                type: 'number',
                set: function (newVal) {
                    ok(true, 'set called');
                    return newVal;
                }
            },
            someNumber: { value: '5' },
            number: {}
        });
        var map = new DefaultMap();
        equal(map.someNumber, '5', 'default values are not type converted anymore');
        map.someNumber = '5';
        equal(map.someNumber, 5, 'on a set, they should be type converted');
        map.number = '10';
        equal(map.number, 10, 'value of number should be converted to a number');
    });
    test('nested define', function () {
        var nailedIt = 'Nailed it';
        var Example = define.Constructor({ name: { value: nailedIt } });
        var NestedMap = define.Constructor({
            isEnabled: { value: true },
            test: { Value: Example },
            examples: {
                type: {
                    one: { Value: Example },
                    two: {
                        type: { deep: { Value: Example } },
                        Value: Object
                    }
                },
                Value: Object
            }
        });
        var nested = new NestedMap();
        equal(nested.test.name, nailedIt);
        equal(nested.examples.one.name, nailedIt);
        equal(nested.examples.two.deep.name, nailedIt);
        ok(nested.test instanceof Example);
        ok(nested.examples.one instanceof Example);
        ok(nested.examples.two.deep instanceof Example);
    });
    test('Can make an attr alias a compute (#1470)', 9, function () {
        var computeValue = compute(1);
        var GetMap = define.Constructor({
            value: {
                set: function (newValue, setVal, oldValue) {
                    if (newValue.isComputed) {
                        return newValue;
                    }
                    if (oldValue && oldValue.isComputed) {
                        oldValue(newValue);
                        return oldValue;
                    }
                    return newValue;
                },
                get: function (value) {
                    return value && value.isComputed ? value() : value;
                }
            }
        });
        var getMap = new GetMap();
        getMap.value = computeValue;
        equal(getMap.value, 1, 'initial value read from compute');
        var bindCallbacks = 0;
        getMap.bind('value', function (ev, newVal, oldVal) {
            switch (bindCallbacks) {
            case 0:
                equal(newVal, 2, '0 - bind called with new val');
                equal(oldVal, 1, '0 - bind called with old val');
                break;
            case 1:
                equal(newVal, 3, '1 - bind called with new val');
                equal(oldVal, 2, '1 - bind called with old val');
                break;
            case 2:
                equal(newVal, 4, '2 - bind called with new val');
                equal(oldVal, 3, '2 - bind called with old val');
                break;
            }
            bindCallbacks++;
        });
        computeValue(2);
        getMap.value = 3;
        equal(getMap.value, 3, 'read value is 3');
        equal(computeValue(), 3, 'the compute value is 3');
        var newComputeValue = compute(4);
        getMap.value = newComputeValue;
    });
    test('value and get (#1521)', function () {
        var MyMap = define.Constructor({
            data: {
                value: function () {
                    return new CanList(['test']);
                }
            },
            size: {
                value: 1,
                get: function (val) {
                    var list = this.data;
                    var length = list.attr('length');
                    return val + length;
                }
            }
        });
        var map = new MyMap({});
        equal(map.size, 2);
    });
    test('One event on getters (#1585)', function () {
        var Person = define.Constructor({
            name: '*',
            id: 'number'
        });
        var AppState = define.Constructor({
            person: {
                get: function (lastSetValue, resolve) {
                    if (lastSetValue) {
                        return lastSetValue;
                    } else if (this.personId) {
                        resolve(new Person({
                            name: 'Jose',
                            id: 5
                        }));
                    } else {
                        return null;
                    }
                },
                Type: Person
            },
            personId: '*'
        });
        var appState = new AppState();
        var personEvents = 0;
        appState.bind('person', function (ev, person) {
            personEvents++;
        });
        equal(appState.person, null, 'no personId and no lastSetValue');
        appState.personId = 5;
        equal(appState.person.name, 'Jose', 'a personId, providing Jose');
        ok(appState.person instanceof Person, 'got a person instance');
        appState.person = { name: 'Julia' };
        ok(appState.person instanceof Person, 'got a person instance');
        equal(personEvents, 2);
    });
    test('Can read a defined property with a set/get method (#1648)', function () {
        var Map = define.Constructor({
            foo: {
                value: '',
                set: function (setVal) {
                    return setVal;
                },
                get: function (lastSetVal) {
                    return lastSetVal;
                }
            }
        });
        var map = new Map();
        equal(map.foo, '', 'Calling .foo returned the correct value');
        map.foo = 'baz';
        equal(map.foo, 'baz', 'Calling .foo returned the correct value');
    });
    test('Can bind to a defined property with a set/get method (#1648)', 3, function () {
        var Map = define.Constructor({
            foo: {
                value: '',
                set: function (setVal) {
                    return setVal;
                },
                get: function (lastSetVal) {
                    return lastSetVal;
                }
            }
        });
        var map = new Map();
        map.bind('foo', function () {
            ok(true, 'Bound function is called');
        });
        equal(map.foo, '', 'Calling .attr(\'foo\') returned the correct value');
        map.foo = 'baz';
        equal(map.foo, 'baz', 'Calling .attr(\'foo\') returned the correct value');
    });
    test('type converters handle null and undefined in expected ways (1693)', function () {
        var Typer = define.Constructor({
            date: { type: 'date' },
            string: { type: 'string' },
            number: { type: 'number' },
            'boolean': { type: 'boolean' },
            htmlbool: { type: 'htmlbool' },
            leaveAlone: { type: '*' }
        });
        var t = new Typer({
            date: undefined,
            string: undefined,
            number: undefined,
            'boolean': undefined,
            htmlbool: undefined,
            leaveAlone: undefined
        });
        equal(t.date, undefined, 'converted to date');
        equal(t.string, undefined, 'converted to string');
        equal(t.number, undefined, 'converted to number');
        equal(t.boolean, undefined, 'converted to boolean');
        equal(t.htmlbool, false, 'converted to htmlbool');
        equal(t.leaveAlone, undefined, 'left as object');
        t = new Typer({
            date: null,
            string: null,
            number: null,
            'boolean': null,
            htmlbool: null,
            leaveAlone: null
        });
        equal(t.date, null, 'converted to date');
        equal(t.string, null, 'converted to string');
        equal(t.number, null, 'converted to number');
        equal(t.boolean, null, 'converted to boolean');
        equal(t.htmlbool, false, 'converted to htmlbool');
        equal(t.leaveAlone, null, 'left as object');
    });
    test('Initial value does not call getter', function () {
        expect(0);
        var Map = define.Constructor({
            count: {
                get: function (lastVal) {
                    ok(false, 'Should not be called');
                    return lastVal;
                }
            }
        });
        new Map({ count: 100 });
    });
    test('getters produce change events', function () {
        var Map = define.Constructor({
            count: {
                get: function (lastVal) {
                    return lastVal;
                }
            }
        });
        var map = new Map();
        map.bind('count', function () {
            ok(true, 'change called');
        });
        map.count = 22;
    });
    test('Asynchronous virtual properties cause extra recomputes (#1915)', function () {
        stop();
        var ran = false;
        var VM = define.Constructor({
            foo: {
                get: function (lastVal, setVal) {
                    setTimeout(function () {
                        if (setVal) {
                            setVal(5);
                        }
                    }, 10);
                }
            },
            bar: {
                get: function () {
                    var foo = this.foo;
                    if (foo) {
                        if (ran) {
                            ok(false, 'Getter ran twice');
                        }
                        ran = true;
                        return foo * 2;
                    }
                }
            }
        });
        var vm = new VM();
        vm.bind('bar', function () {
        });
        setTimeout(function () {
            equal(vm.bar, 10);
            start();
        }, 200);
    });
    test('Stache with single property', function () {
        var Typer = define.Constructor({ foo: { type: 'string' } });
        var template = stache('{{foo}}');
        var t = new Typer({ foo: 'bar' });
        var frag = template(t);
        equal(frag.firstChild.nodeValue, 'bar');
        t.foo = 'baz';
        equal(frag.firstChild.nodeValue, 'baz');
    });
    test('Stache with boolean property with {{#if}}', function () {
        var nailedIt = 'Nailed it';
        var Example = define.Constructor({ name: { value: nailedIt } });
        var NestedMap = define.Constructor({
            isEnabled: { value: true },
            test: { Value: Example },
            examples: {
                type: {
                    one: { Value: Example },
                    two: {
                        type: { deep: { Value: Example } },
                        Value: Object
                    }
                },
                Value: Object
            }
        });
        var nested = new NestedMap();
        var template = stache('{{#if isEnabled}}Enabled{{/if}}');
        var frag = template(nested);
        equal(frag.firstChild.nodeValue, 'Enabled');
    });
    test('stache with double property', function () {
        var nailedIt = 'Nailed it';
        var Example = define.Constructor({ name: { value: nailedIt } });
        var NestedMap = define.Constructor({
            isEnabled: { value: true },
            test: { Value: Example },
            examples: {
                type: {
                    one: { Value: Example },
                    two: {
                        type: { deep: { Value: Example } },
                        Value: Object
                    }
                },
                Value: Object
            }
        });
        var nested = new NestedMap();
        var template = stache('{{test.name}}');
        var frag = template(nested);
        equal(frag.firstChild.nodeValue, nailedIt);
    });
    test('Stache with one nested property', function () {
        var nailedIt = 'Nailed it';
        var Example = define.Constructor({ name: { value: nailedIt } });
        var NestedMap = define.Constructor({
            isEnabled: { value: true },
            test: { Value: Example },
            examples: {
                type: {
                    one: { Value: Example },
                    two: {
                        type: { deep: { Value: Example } },
                        Value: Object
                    }
                },
                Value: Object
            }
        });
        var nested = new NestedMap();
        var template = stache('{{examples.one.name}}');
        var frag = template(nested);
        equal(frag.firstChild.nodeValue, nailedIt);
    });
    test('Stache with two nested property', function () {
        var nailedIt = 'Nailed it';
        var Example = define.Constructor({ name: { value: nailedIt } });
        var NestedMap = define.Constructor({
            isEnabled: { value: true },
            test: { Value: Example },
            examples: {
                type: {
                    one: { Value: Example },
                    two: {
                        type: { deep: { Value: Example } },
                        Value: Object
                    }
                },
                Value: Object
            }
        });
        var nested = new NestedMap();
        var template = stache('{{examples.two.deep.name}}');
        var frag = template(nested);
        equal(frag.firstChild.nodeValue, nailedIt);
    });
    QUnit.test('Default values cannot be set (#8)', function () {
        var Person = function () {
        };
        define(Person.prototype, {
            first: {
                type: 'string',
                value: 'Chris'
            },
            last: {
                type: 'string',
                value: 'Gomez'
            },
            fullName: {
                get: function () {
                    return this.first + ' ' + this.last;
                }
            }
        });
        var p = new Person();
        QUnit.equal(p.fullName, 'Chris Gomez', 'Fullname is correct');
        p.first = 'Sara';
        QUnit.equal(p.fullName, 'Sara Gomez', 'Fullname is correct after update');
    });
    QUnit.test('default type is setable', function () {
        var Person = function () {
        };
        define(Person.prototype, {
            '*': 'string',
            first: { value: 1 },
            last: { value: 2 }
        });
        var p = new Person();
        QUnit.ok(p.first === '1', typeof p.first);
        QUnit.ok(p.last === '2', typeof p.last);
    });
    QUnit.test('expandos are added in define.setup (#25)', function () {
        var MyMap = define.Constructor({});
        var map = new MyMap({ prop: 4 });
        map.on('prop', function () {
            QUnit.ok(true, 'prop event called');
        });
        map.prop = 5;
    });
    if (compute.prototype.trace) {
        QUnit.test('logs work with maps', function () {
            var MyMap = define.Constructor({
                first: 'string',
                last: 'string'
            });
            var m = new MyMap({
                first: 'J',
                last: 'M'
            });
            var fullName = compute(function () {
                return m.first + m.last;
            });
            fullName.on('change', function () {
            });
            var t = fullName.computeInstance.trace();
            QUnit.equal(t.dependencies[0].obj, m);
            QUnit.equal(t.dependencies[1].obj, m);
        });
    }
    QUnit.test('Set property with type compute', function () {
        var MyMap = define.Constructor({ computeProp: { type: 'compute' } });
        var m = new MyMap();
        m.computeProp = compute(0);
        equal(m.computeProp, 0, 'Property has correct value');
        m.computeProp = compute(1);
        equal(m.computeProp, 1, 'Property has correct value');
    });
    QUnit.test('Compute type property can have a default value', function () {
        var MyMap = define.Constructor({
            computeProp: {
                type: 'compute',
                value: function () {
                    return 0;
                }
            }
        });
        var m = new MyMap();
        equal(m.computeProp, 0, 'Property has correct value');
        m.computeProp = 1;
        equal(m.computeProp, 1, 'Property has correct value');
    });
    QUnit.test('Compute type property with compute default value triggers change events when updated', function () {
        var expected = 0;
        var c = compute(0);
        var MyMap = define.Constructor({
            computeProp: {
                type: 'compute',
                value: function () {
                    return c;
                }
            }
        });
        var m = new MyMap();
        c.bind('change', function (ev, newVal) {
            equal(newVal, expected, 'Compute fired change event');
        });
        m.on('computeProp', function (ev, newVal) {
            equal(newVal, expected, 'Map fired change event');
        });
        expected = 1;
        m.computeProp = expected;
        expected = 2;
        c(expected);
    });
    QUnit.test('Compute type property can have a default value that is a compute', function () {
        var c = compute(0);
        var MyMap = define.Constructor({
            computeProp: {
                type: 'compute',
                value: function () {
                    return c;
                }
            }
        });
        var m = new MyMap();
        equal(m.computeProp, 0, 'Property has correct value');
        c(1);
        equal(m.computeProp, 1, 'Property has correct value');
    });
    QUnit.test('Extensions can modify definitions', function () {
        var oldExtensions = define.extensions;
        define.behaviors.push('extended');
        define.extensions = function (objPrototype, prop, definition) {
            if (definition.extended) {
                return { value: 'extended' };
            }
        };
        var MyMap = define.Constructor({
            foo: {
                value: 'defined',
                extended: true
            },
            bar: { value: 'defined' }
        });
        var map = new MyMap();
        QUnit.equal(map.foo, 'extended', 'Value was set via extension');
        QUnit.equal(map.bar, 'defined', 'Value was set via definition');
        define.extensions = oldExtensions;
    });
    QUnit.test('Properties are enumerable', function () {
        QUnit.expect(4);
        function VM(foo) {
            this.foo = foo;
        }
        define(VM.prototype, { foo: 'string' });
        var vm = new VM('bar');
        vm.baz = 'qux';
        var i = 0;
        each(vm, function (value, key) {
            if (i === 0) {
                QUnit.equal(key, 'foo');
                QUnit.equal(value, 'bar');
            } else {
                QUnit.equal(key, 'baz');
                QUnit.equal(value, 'qux');
            }
            i++;
        });
    });
    QUnit.test('Doesn\'t override types.iterator if already on the prototype', function () {
        function MyMap() {
        }
        MyMap.prototype[types.iterator] = function () {
            var i = 0;
            return {
                next: function () {
                    if (i === 0) {
                        i++;
                        return {
                            value: [
                                'it',
                                'worked'
                            ],
                            done: false
                        };
                    }
                    return {
                        value: undefined,
                        done: true
                    };
                }
            };
        };
        define(MyMap.prototype, { foo: 'string' });
        var map = new MyMap();
        map.foo = 'bar';
        each(map, function (value, key) {
            QUnit.equal(value, 'worked');
            QUnit.equal(key, 'it');
        });
    });
    QUnit.test('nullish values are not converted for type or Type', function (assert) {
        var Foo = function () {
        };
        var MyMap = define.Constructor({
            map: { Type: Foo },
            notype: {}
        });
        var vm = new MyMap({
            map: {},
            notype: {}
        });
        assert.ok(vm.map instanceof Foo, 'map is another type');
        assert.ok(vm.notype instanceof Object, 'notype is an Object');
        vm.map = null;
        vm.notype = null;
        assert.equal(vm.map, null, 'map is null');
        assert.equal(vm.map, null, 'notype is null');
    });
    QUnit.test('shorthand getter (#56)', function () {
        var Person = function (first, last) {
            this.first = first;
            this.last = last;
        };
        define(Person.prototype, {
            first: '*',
            last: '*',
            get fullName() {
                return this.first + ' ' + this.last;
            }
        });
        var p = new Person('Mohamed', 'Cherif');
        p.on('fullName', function (ev, newVal, oldVal) {
            QUnit.equal(oldVal, 'Mohamed Cherif');
            QUnit.equal(newVal, 'Justin Meyer');
        });
        equal(p.fullName, 'Mohamed Cherif', 'fullName initialized right');
        canBatch.start();
        p.first = 'Justin';
        p.last = 'Meyer';
        canBatch.stop();
    });
    QUnit.test('shorthand getter setter (#56)', function () {
        var Person = function (first, last) {
            this.first = first;
            this.last = last;
        };
        define(Person.prototype, {
            first: '*',
            last: '*',
            get fullName() {
                return this.first + ' ' + this.last;
            },
            set fullName(newVal) {
                var parts = newVal.split(' ');
                this.first = parts[0];
                this.last = parts[1];
            }
        });
        var p = new Person('Mohamed', 'Cherif');
        p.on('fullName', function (ev, newVal, oldVal) {
            QUnit.equal(oldVal, 'Mohamed Cherif');
            QUnit.equal(newVal, 'Justin Meyer');
        });
        equal(p.fullName, 'Mohamed Cherif', 'fullName initialized right');
        p.fullName = 'Justin Meyer';
    });
    QUnit.test('set and value work together (#87)', function () {
        var Type = define.Constructor({
            prop: {
                value: 2,
                set: function (num) {
                    return num * num;
                }
            }
        });
        var instance = new Type();
        QUnit.equal(instance.prop, 4, 'used setter');
    });
    QUnit.test('async setter is provided', 5, function () {
        var RESOLVE;
        var Type = define.Constructor({
            prop: {
                value: 2,
                set: function (num, resolve) {
                    resolve(num * num);
                }
            },
            prop2: {
                value: 3,
                set: function (num, resolve) {
                    RESOLVE = resolve;
                }
            }
        });
        var instance = new Type();
        QUnit.equal(instance.prop, 4, 'used async setter');
        QUnit.equal(instance.prop2, undefined, 'used async setter');
        instance.on('prop2', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 9, 'updated');
            QUnit.equal(oldVal, undefined, 'updated');
        });
        RESOLVE(9);
        QUnit.equal(instance.prop2, 9, 'used async setter updates after');
    });
    QUnit.test('setter with default value causes an infinite loop (#142)', function () {
        var A = define.Constructor({
            val: {
                value: 'hello',
                set: function (val) {
                    if (this.val) {
                    }
                    return val;
                }
            }
        });
        var a = new A();
        QUnit.equal(a.val, 'hello', 'creating an instance should not cause an inifinte loop');
    });
});
/*can-define@1.0.17#test/test*/
define('can-define@1.0.17#test/test', function (require, exports, module) {
    require('../list/list-test');
    require('../map/map-test');
    require('../define-test');
    var DefineMap = require('can-define/map/map');
    var DefineList = require('can-define/list/list');
    var isArray = require('can-util/js/is-array/is-array');
    var isPlainObject = require('can-util/js/is-plain-object/is-plain-object');
    var types = require('can-types');
    var QUnit = require('steal-qunit');
    QUnit.module('can-define: map and list combined');
    QUnit.test('basics', function () {
        var items = new DefineMap({
            people: [
                { name: 'Justin' },
                { name: 'Brian' }
            ],
            count: 1000
        });
        QUnit.ok(items.people instanceof types.DefineList, 'people is list');
        QUnit.ok(items.people.item(0) instanceof types.DefineMap, '1st object is Map');
        QUnit.ok(items.people.item(1) instanceof types.DefineMap, '2nd object is Map');
        QUnit.equal(items.people.item(1).name, 'Brian', '2nd object\'s name is right');
        QUnit.equal(items.count, 1000, 'count is number');
    });
    QUnit.test('serialize works', function () {
        var Person = DefineMap.extend({
            first: 'string',
            last: 'string'
        });
        var People = DefineList.extend({ '*': Person });
        var people = new People([{
                first: 'j',
                last: 'm'
            }]);
        QUnit.deepEqual(people.serialize(), [{
                first: 'j',
                last: 'm'
            }]);
    });
    QUnit.test('Extended Map with empty def converts to default Observables', function () {
        var School = DefineMap.extend({
            students: {},
            teacher: {}
        });
        var school = new School();
        school.students = [{ name: 'J' }];
        school.teacher = { name: 'M' };
        ok(school.students instanceof types.DefineList, 'converted to DefineList');
        ok(school.teacher instanceof types.DefineMap, 'converted to DefineMap');
    });
    QUnit.test('default \'observable\' type prevents Type from working (#29)', function () {
        var M = DefineMap.extend('M', { id: 'number' });
        var L = DefineList.extend('L', { '*': M });
        var MyMap = DefineMap.extend({ l: L });
        var m = new MyMap({ l: [{ id: 5 }] });
        QUnit.ok(m.l[0] instanceof M, 'is instance');
        QUnit.ok(m.l[0].id, 5, 'correct props');
    });
    QUnit.test('inline DefineList Type', function () {
        var M = DefineMap.extend('M', { id: 'number' });
        var MyMap = DefineMap.extend({ l: { Type: [M] } });
        var m = new MyMap({ l: [{ id: 5 }] });
        QUnit.ok(m.l[0] instanceof M, 'is instance');
        QUnit.ok(m.l[0].id, 5, 'correct props');
    });
    QUnit.test('recursively `get`s (#31)', function () {
        var M = DefineMap.extend('M', { id: 'number' });
        var MyMap = DefineMap.extend({ l: { Type: [M] } });
        var m = new MyMap({ l: [{ id: 5 }] });
        var res = m.get();
        QUnit.ok(isArray(res.l), 'is a plain array');
        QUnit.ok(isPlainObject(res.l[0]), 'plain object');
    });
    QUnit.test('DefineList trigger deprecation warning when set with Map.set (#93)', 0, function () {
        var map = new DefineMap({ things: [{ foo: 'bar' }] });
        map.things.attr = function () {
            ok(false, 'attr should not be called');
        };
        map.set({ things: [{ baz: 'luhrmann' }] });
    });
});
/*can-set@1.1.0#src/set-core_test*/
define('can-set@1.1.0#src/set-core_test', function (require, exports, module) {
    require('steal-qunit');
    var set = require('./set-core');
    var ignoreProp = function () {
        return true;
    };
    QUnit.module('can-set core');
    test('set.equal', function () {
        var res, now;
        res = set.equal({ type: 'FOLDER' }, {
            type: 'FOLDER',
            count: 5
        }, { count: ignoreProp });
        ok(res, 'count ignored');
        res = set.equal({ type: 'folder' }, { type: 'FOLDER' }, {
            type: function (a, b) {
                return ('' + a).toLowerCase() === ('' + b).toLowerCase();
            }
        });
        ok(res, 'folder case ignored');
        res = set.equal({ foo: null }, { foo: new Date() });
        ok(!res, 'nulls and Dates are not considered the same. (#773)');
        res = set.equal({ foo: null }, { foo: {} });
        ok(!res, 'nulls and empty objects are not considered the same. (#773)');
        now = new Date();
        res = set.equal({ foo: now }, { foo: new Date(now.getTime()) });
        ok(res, 'date objects with same time values are considered the same. (#35)');
    });
    test('set.subset', function () {
        var res;
        res = set.subset({ type: 'FOLDER' }, { type: 'FOLDER' });
        ok(res, 'equal sets');
        res = set.subset({
            type: 'FOLDER',
            parentId: 5
        }, { type: 'FOLDER' });
        ok(res, 'sub set');
        res = set.subset({ type: 'FOLDER' }, {
            type: 'FOLDER',
            parentId: 5
        });
        ok(!res, 'wrong way');
        res = set.subset({
            type: 'FOLDER',
            parentId: 7
        }, {
            type: 'FOLDER',
            parentId: 5
        });
        ok(!res, 'different values');
        res = set.subset({
            type: 'FOLDER',
            count: 5
        }, { type: 'FOLDER' }, { count: ignoreProp });
        ok(res, 'count ignored');
        res = set.subset({
            type: 'FOLDER',
            kind: 'tree'
        }, {
            type: 'FOLDER',
            foo: true,
            bar: true
        }, {
            foo: ignoreProp,
            bar: ignoreProp
        });
        ok(res, 'understands a subset');
        res = set.subset({
            type: 'FOLDER',
            foo: true,
            bar: true
        }, {
            type: 'FOLDER',
            kind: 'tree'
        }, {
            foo: ignoreProp,
            bar: ignoreProp,
            kind: ignoreProp
        });
        ok(res, 'ignores nulls');
    });
    test('set.properSubset', function () {
        equal(set.properSubset({ foo: 'bar' }, {}), true);
        equal(set.properSubset({}, {}), false);
        equal(set.properSubset({}, { foo: 'bar' }), false);
    });
    test('set.difference', function () {
        var res = set.difference({}, { completed: true });
        ok(res === true, 'diff should be true');
        res = set.difference({ completed: true }, { completed: true });
        equal(res, false);
        res = set.difference({ completed: true }, {});
        equal(res, false);
        res = set.difference({ completed: true }, { userId: 5 });
        equal(res, false);
    });
    test('set.difference({ function })', function () {
        var res = set.difference({
            colors: [
                'red',
                'blue'
            ]
        }, { colors: ['blue'] }, {
            colors: function () {
                return {
                    difference: ['red'],
                    intersection: ['blue']
                };
            }
        });
        deepEqual(res, { colors: ['red'] });
    });
    test('set.union', function () {
        var res = set.union({}, { completed: true });
        deepEqual(res, {}, 'set / subset');
        res = set.union({ completed: true }, {});
        deepEqual(res, {}, 'subset / set');
        res = set.union({ foo: 'bar' }, { foo: 'bar' });
        deepEqual(res, { foo: 'bar' }, 'equal');
        res = set.union({ foo: 'bar' }, { foo: 'zed' });
        ok(!res, 'values not equal');
        res = set.union({ foo: 'bar' }, { name: 'A' });
        ok(!res, 'values not equal');
    });
    test('set.union Array', function () {
        var res = set.union({
            foo: [
                'a',
                'b'
            ]
        }, {
            foo: [
                'a',
                'c'
            ]
        });
        deepEqual(res, {
            foo: [
                'a',
                'b',
                'c'
            ]
        }, 'set / subset');
    });
    test('set.count', function () {
        ok(set.count({}) === Infinity, 'defaults to infinity');
        ok(set.count({ foo: 'bar' }, {}) === Infinity, 'defaults to infinity');
        equal(set.count({ foo: 'bar' }, {
            foo: function () {
                return { count: 100 };
            }
        }), 100, 'works with a single value');
    });
    test('set.intersection', function () {
        var res = set.intersection({}, { completed: true });
        deepEqual(res, { completed: true }, 'set / subset');
        res = set.intersection({ completed: true }, {});
        deepEqual(res, { completed: true }, 'subset / set');
        res = set.intersection({ foo: 'bar' }, { foo: 'bar' });
        deepEqual(res, { foo: 'bar' }, 'equal');
        res = set.intersection({ foo: 'bar' }, { foo: 'zed' });
        ok(!res, 'values not equal');
        res = set.intersection({ foo: 'bar' }, { completed: true });
        deepEqual(res, {
            foo: 'bar',
            completed: true
        }, 'intersection should combine definitions');
    });
    test('set.intersection Array', function () {
        var res = set.intersection({
            foo: [
                'a',
                'b'
            ]
        }, {
            foo: [
                'a',
                'c'
            ]
        });
        deepEqual(res, { foo: ['a'] }, 'intersection');
    });
    test('set.has', function () {
        var res;
        res = set.has({ type: 'FOLDER' }, { type: 'FOLDER' });
        ok(res, 'equal sets');
        res = set.has({ type: 'FOLDER' }, {
            type: 'FOLDER',
            parentId: 5
        });
        ok(res, 'sub set');
        res = set.has({
            type: 'FOLDER',
            parentId: 5
        }, { type: 'FOLDER' });
        ok(!res, 'wrong way');
        res = set.has({
            type: 'FOLDER',
            parentId: 7
        }, {
            type: 'FOLDER',
            parentId: 5
        });
        ok(!res, 'different values');
        res = set.has({ type: 'FOLDER' }, {
            type: 'FOLDER',
            count: 5
        }, { count: ignoreProp });
        ok(res, 'count ignored');
        res = set.has({
            type: 'FOLDER',
            foo: true,
            bar: true
        }, {
            type: 'FOLDER',
            kind: 'tree'
        }, {
            foo: ignoreProp,
            bar: ignoreProp
        });
        ok(res, 'understands a subset');
        res = set.has({
            type: 'FOLDER',
            kind: 'tree'
        }, {
            type: 'FOLDER',
            foo: true,
            bar: true
        }, {
            foo: ignoreProp,
            bar: ignoreProp,
            kind: ignoreProp
        });
        ok(res, 'ignores nulls');
    });
    test('set.index', function () {
        var index = set.index({ sort: 'name' }, [
            {
                id: 1,
                name: 'g'
            },
            {
                id: 2,
                name: 'j'
            },
            {
                id: 3,
                name: 'm'
            },
            {
                id: 4,
                name: 's'
            }
        ], { name: 'k' });
        equal(index, undefined, 'no value if nothing is set');
        var algebra = new set.Algebra(set.props.id('id'));
        index = algebra.index({ sort: 'name' }, [
            {
                id: 1,
                name: 'g'
            },
            {
                id: 2,
                name: 'j'
            },
            {
                id: 3,
                name: 'm'
            },
            {
                id: 4,
                name: 's'
            }
        ], {
            id: 0,
            name: 'k'
        });
        equal(index, 0);
    });
    test('algebra.id', function () {
        var algebra = new set.Algebra(set.props.id('_id'));
        QUnit.equal(algebra.id({ _id: 5 }), 5, 'only one id, returns value');
        algebra = new set.Algebra(set.props.id('studentId'), set.props.id('classId'));
        QUnit.equal(algebra.id({
            studentId: 6,
            classId: '7',
            foo: 'bar'
        }), JSON.stringify({
            studentId: 6,
            classId: '7'
        }), 'only one id, returns set as JSON');
    });
});
/*can-set@1.1.0#src/set-core-nested_test*/
define('can-set@1.1.0#src/set-core-nested_test', function (require, exports, module) {
    QUnit.module('can/set core - nested');
    require('steal-qunit');
    var set = require('./set-core');
    var ignoreProp = function () {
        return true;
    };
    QUnit.module('can-set core - nested where');
    test('set.equal', function () {
        var algebra = new set.Algebra(new set.Translate('where', '$where'), {
            count: ignoreProp,
            type: function (a, b) {
                return ('' + a).toLowerCase() === ('' + b).toLowerCase();
            }
        });
        var res;
        res = algebra.equal({ $where: { type: 'FOLDER' } }, {
            $where: {
                type: 'FOLDER',
                count: 5
            }
        });
        ok(res, 'count ignored');
        res = algebra.equal({ $where: { type: 'folder' } }, { $where: { type: 'FOLDER' } });
        ok(res, 'folder case ignored');
    });
    test('set.subset', function () {
        var algebra = new set.Algebra(new set.Translate('where', '$where'), {
            count: ignoreProp,
            type: function (a, b) {
                return ('' + a).toLowerCase() === ('' + b).toLowerCase();
            },
            foo: ignoreProp,
            bar: ignoreProp,
            kind: ignoreProp
        });
        var res;
        res = algebra.subset({ $where: { type: 'FOLDER' } }, { $where: { type: 'FOLDER' } });
        ok(res, 'equal sets');
        res = algebra.subset({
            $where: {
                type: 'FOLDER',
                parentId: 5
            }
        }, { $where: { type: 'FOLDER' } });
        ok(res, 'sub set');
        res = algebra.subset({ $where: { type: 'FOLDER' } }, {
            $where: {
                type: 'FOLDER',
                parentId: 5
            }
        });
        ok(!res, 'wrong way');
        res = algebra.subset({
            $where: {
                type: 'FOLDER',
                parentId: 7
            }
        }, {
            $where: {
                type: 'FOLDER',
                parentId: 5
            }
        });
        ok(!res, 'different values');
        res = algebra.subset({
            $where: {
                type: 'FOLDER',
                count: 5
            }
        }, { $where: { type: 'FOLDER' } });
        ok(res, 'count ignored');
        res = algebra.subset({
            $where: {
                type: 'FOLDER',
                category: 'tree'
            }
        }, {
            $where: {
                type: 'FOLDER',
                foo: true,
                bar: true
            }
        });
        ok(res, 'understands a subset');
        res = algebra.subset({
            $where: {
                type: 'FOLDER',
                foo: true,
                bar: true
            }
        }, {
            $where: {
                type: 'FOLDER',
                kind: 'tree'
            }
        });
        ok(res, 'ignores nulls');
    });
    test('set.properSubset', function () {
        var algebra = new set.Algebra(new set.Translate('where', '$where'));
        equal(algebra.properSubset({ $where: { foo: 'bar' } }, { $where: {} }), true);
        equal(algebra.properSubset({ $where: {} }, { $where: {} }), false);
        equal(algebra.properSubset({ $where: {} }, { $where: { foo: 'bar' } }), false);
    });
    test('set.difference', function () {
        var algebra = new set.Algebra(new set.Translate('where', '$where'));
        var res = algebra.difference({ $where: {} }, { $where: { completed: true } });
        ok(res === true, 'diff should be true');
        res = algebra.difference({ $where: { completed: true } }, { $where: { completed: true } });
        equal(res, false);
        res = algebra.difference({ $where: { completed: true } }, { $where: {} });
        equal(res, false);
        res = algebra.difference({ $where: { completed: true } }, { $where: { userId: 5 } });
        equal(res, false);
    });
    test('set.difference({ function })', function () {
        var algebra = new set.Algebra(new set.Translate('where', '$where'), {
            colors: function () {
                return {
                    difference: ['red'],
                    intersection: ['blue']
                };
            }
        });
        var res = algebra.difference({
            $where: {
                colors: [
                    'red',
                    'blue'
                ]
            }
        }, { $where: { colors: ['blue'] } });
        deepEqual(res, { $where: { colors: ['red'] } });
    });
    test('set.union', function () {
        var algebra = new set.Algebra(new set.Translate('where', '$where'));
        var res = algebra.union({ $where: {} }, { $where: { completed: true } });
        deepEqual(res, { $where: {} }, 'set / subset');
        res = algebra.union({ $where: { completed: true } }, { $where: {} });
        deepEqual(res, { $where: {} }, 'subset / set');
        res = algebra.union({ $where: { foo: 'bar' } }, { $where: { foo: 'bar' } });
        deepEqual(res, { $where: { foo: 'bar' } }, 'equal');
        res = algebra.union({ $where: { foo: 'bar' } }, { $where: { foo: 'zed' } });
        ok(!res, 'values not equal');
        res = algebra.union({ $where: { foo: 'bar' } }, { $where: { name: 'A' } });
        ok(!res, 'values not equal');
    });
    test('set.union Array', function () {
        var algebra = new set.Algebra(new set.Translate('where', '$where'));
        var res = algebra.union({
            $where: {
                foo: [
                    'a',
                    'b'
                ]
            }
        }, {
            $where: {
                foo: [
                    'a',
                    'c'
                ]
            }
        });
        deepEqual(res, {
            $where: {
                foo: [
                    'a',
                    'b',
                    'c'
                ]
            }
        }, 'set / subset');
    });
    test('set.count', function () {
        var algebra = new set.Algebra(new set.Translate('where', '$where'), {
            foo: function () {
                return { count: 100 };
            }
        });
        ok(algebra.count({ $where: {} }) === Infinity, 'defaults to infinity');
        ok(algebra.count({ $where: { bar: 'foo' } }) === Infinity, 'defaults to infinity');
        equal(algebra.count({ $where: { foo: 'bar' } }), 100, 'works with a single value');
    });
    test('set.intersection', function () {
        var algebra = new set.Algebra(new set.Translate('where', '$where'));
        var res = algebra.intersection({ $where: {} }, { $where: { completed: true } });
        deepEqual(res, { $where: { completed: true } }, 'set / subset');
        res = algebra.intersection({ $where: { completed: true } }, { $where: {} });
        deepEqual(res, { $where: { completed: true } }, 'subset / set');
        res = algebra.intersection({ $where: { foo: 'bar' } }, { $where: { foo: 'bar' } });
        deepEqual(res, { $where: { foo: 'bar' } }, 'equal');
        res = algebra.intersection({ $where: { foo: 'bar' } }, { $where: { foo: 'zed' } });
        ok(!res, 'values not equal');
        res = algebra.intersection({ $where: { foo: 'bar' } }, { $where: { completed: true } });
        deepEqual(res, {
            $where: {
                foo: 'bar',
                completed: true
            }
        }, 'intersection should combine definitions');
    });
    test('set.intersection Array', function () {
        var algebra = new set.Algebra(new set.Translate('where', '$where'));
        var res = algebra.intersection({
            $where: {
                foo: [
                    'a',
                    'b'
                ]
            }
        }, {
            $where: {
                foo: [
                    'a',
                    'c'
                ]
            }
        });
        deepEqual(res, { $where: { foo: ['a'] } }, 'intersection');
    });
    test('set.has', function () {
        var algebra = new set.Algebra(new set.Translate('where', '$where'), {
            count: ignoreProp,
            type: function (a, b) {
                return ('' + a).toLowerCase() === ('' + b).toLowerCase();
            },
            foo: ignoreProp,
            bar: ignoreProp,
            kind: ignoreProp
        });
        ok(algebra.has({ $where: { someId: 5 } }, {
            someId: 5,
            name: 'foo'
        }), true);
        var res;
        res = algebra.has({ $where: { type: 'FOLDER' } }, { type: 'FOLDER' });
        ok(res, 'equal sets');
        res = algebra.has({
            $where: {
                type: 'FOLDER',
                parentId: 5
            }
        }, { type: 'FOLDER' });
        equal(res, false, 'doesnt match');
        res = algebra.has({ $where: { type: 'FOLDER' } }, {
            type: 'FOLDER',
            parentId: 5
        });
        ok(true, 'is a subset');
        res = algebra.has({
            $where: {
                type: 'FOLDER',
                parentId: 7
            }
        }, {
            type: 'FOLDER',
            parentId: 5
        });
        ok(!res, 'different values');
        res = algebra.has({
            $where: {
                type: 'FOLDER',
                count: 5
            }
        }, { type: 'FOLDER' }, { count: ignoreProp });
        ok(res, 'count ignored');
        res = algebra.has({
            $where: {
                type: 'FOLDER',
                kind: 'tree'
            }
        }, {
            type: 'FOLDER',
            foo: true,
            bar: true
        });
        ok(res, 'understands a subset');
        res = algebra.has({
            $where: {
                type: 'FOLDER',
                foo: true,
                bar: true
            }
        }, {
            type: 'FOLDER',
            kind: 'tree'
        });
        ok(res, 'ignores nulls');
    });
});
/*can-set@1.1.0#src/prop_tests/sort_test*/
define('can-set@1.1.0#src/prop_tests/sort_test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var set = require('../set-core'), props = require('../props');
    var each = require('can-util/js/each/each');
    QUnit.module('can-set props.sort');
    test('set.difference', function () {
        var prop = props.sort('sort');
        var res = set.difference({ sort: 'foo' }, { completed: true }, prop);
        ok(res === true, 'diff should be true');
        res = set.difference({ completed: true }, {
            completed: true,
            sort: 'foo'
        }, prop);
        equal(res, false, 'the same except for sort');
        res = set.difference({ completed: true }, { sort: 'foo' }, prop);
        equal(res, false);
        res = set.difference({ completed: true }, {
            foo: 'bar',
            sort: 'foo'
        }, prop);
        equal(res, false);
    });
    test('set.difference({ function })', function () {
        var algebra = new set.Algebra(props.sort('sort'), {
            colors: function () {
                return {
                    difference: ['red'],
                    intersection: ['blue']
                };
            }
        });
        var res = algebra.difference({
            colors: [
                'red',
                'blue'
            ],
            sort: 'colors'
        }, { colors: ['blue'] });
        deepEqual(res, { colors: ['red'] });
    });
    test('set.union', function () {
        var prop = props.sort('sort');
        var res = set.union({ sort: 'name' }, { completed: true }, prop);
        deepEqual(res, {}, 'set / subset sort left');
        res = set.union({}, {
            completed: true,
            sort: 'name'
        }, prop);
        deepEqual(res, {}, 'set / subset sort right');
        res = set.union({ sort: 'name' }, {
            completed: true,
            sort: 'namer'
        }, prop);
        deepEqual(res, {}, 'set / subset both sorts');
        res = set.union({ completed: true }, { sort: 'foo' }, prop);
        deepEqual(res, {}, 'subset / set');
        res = set.union({
            foo: 'bar',
            sort: 'foo'
        }, { foo: 'bar' }, prop);
        deepEqual(res, { foo: 'bar' }, 'equal');
        res = set.union({ foo: 'bar' }, {
            foo: 'zed',
            sort: 'foo'
        }, prop);
        ok(!res, 'values not equal');
        res = set.union({
            foo: 'bar',
            sort: 'foo'
        }, { name: 'A' }, prop);
        ok(!res, 'values not equal');
    });
    test('set.union Array', function () {
        var prop = props.sort('sort');
        var res = set.union({
            foo: [
                'a',
                'b'
            ],
            sort: 'foo'
        }, {
            foo: [
                'a',
                'c'
            ]
        }, prop);
        deepEqual(res, {
            foo: [
                'a',
                'b',
                'c'
            ]
        }, 'set / subset');
    });
    test('set.count', function () {
        ok(set.count({ sort: 'name' }) === Infinity, 'defaults to infinity');
        ok(set.count({
            foo: 'bar',
            sort: 'foo'
        }, {}) === Infinity, 'defaults to infinity');
        equal(set.count({
            foo: 'bar',
            sort: 'foo'
        }, {
            foo: function () {
                return { count: 100 };
            }
        }), 100, 'works with a single value');
    });
    test('set.intersection', function () {
        var prop = props.sort('sort');
        var res = set.intersection({}, { sort: 'name' }, prop);
        deepEqual(res, {}, 'no sort if only one is sorted');
        res = set.intersection({ sort: 'name' }, { sort: 'name' }, prop);
        deepEqual(res, { sort: 'name' }, '');
        res = set.intersection({ type: 'new' }, {
            sort: 'name',
            userId: 5
        }, prop);
        deepEqual(res, {
            type: 'new',
            userId: 5
        }, '');
        res = set.intersection({
            type: 'new',
            sort: 'age'
        }, {
            sort: 'name',
            userId: 5
        }, prop);
        deepEqual(res, {
            type: 'new',
            userId: 5
        }, '');
    });
    test('set.intersection Array', function () {
        var prop = props.sort('sort');
        var res = set.intersection({
            foo: [
                'a',
                'b'
            ],
            sort: 'foo'
        }, {
            foo: [
                'a',
                'c'
            ]
        }, prop);
        deepEqual(res, { foo: ['a'] }, 'intersection');
    });
    test('set.subset', function () {
        var ignoreProp = function () {
            return true;
        };
        var algebra = new set.Algebra(props.sort('sort'), {
            foo: ignoreProp,
            bar: ignoreProp,
            kind: ignoreProp,
            count: ignoreProp
        });
        ok(algebra.subset({
            type: 'FOLDER',
            sort: 'thing'
        }, { type: 'FOLDER' }), 'equal sets with sort on the left');
        ok(algebra.subset({ type: 'FOLDER' }, {
            type: 'FOLDER',
            sort: 'thing'
        }), 'equal sets with sort on the right');
        ok(algebra.subset({
            type: 'FOLDER',
            parentId: 5,
            sort: 'thing'
        }, { type: 'FOLDER' }), 'sub set with sort on the left');
        ok(algebra.subset({
            type: 'FOLDER',
            parentId: 5
        }, {
            type: 'FOLDER',
            sort: 'thing'
        }), 'sub set with sort on the right');
        ok(!algebra.subset({
            type: 'FOLDER',
            sort: 'thing'
        }, {
            type: 'FOLDER',
            parentId: 5
        }), 'wrong way with sort on the left');
        ok(!algebra.subset({ type: 'FOLDER' }, {
            type: 'FOLDER',
            parentId: 5,
            sort: 'thing'
        }), 'wrong way with sort on the right');
        ok(!algebra.subset({
            type: 'FOLDER',
            parentId: 7,
            sort: 'thing'
        }, {
            type: 'FOLDER',
            parentId: 5
        }), 'different values with sort on the left');
        ok(!algebra.subset({
            type: 'FOLDER',
            parentId: 7
        }, {
            type: 'FOLDER',
            parentId: 5,
            sort: 'thing'
        }), 'different values with sort on the right');
    });
    test('set.subset with range', function () {
        var algebra = new set.Algebra(props.sort('sort'), props.rangeInclusive('start', 'end'));
        var addSort = function (set, value) {
            set.sort = value;
        };
        var sort = {
            left: function (setA, setB) {
                addSort(setA, 'prop');
            },
            right: function (setA, setB) {
                addSort(setB, 'prop');
            },
            same: function (setA, setB) {
                addSort(setA, 'prop');
                addSort(setB, 'prop');
            },
            different: function (setA, setB) {
                addSort(setA, 'propA');
                addSort(setB, 'propB');
            }
        };
        var addRange = function (set, start, end) {
            set.start = start;
            set.end = end;
        };
        var range = {
            left: function (setA, setB) {
                addRange(setA, 0, 9);
            },
            right: function (setA, setB) {
                addRange(setB, 0, 9);
            },
            same: function (setA, setB) {
                addRange(setA, 0, 9);
                addRange(setB, 0, 9);
            },
            superLeft: function (setA, setB) {
                addRange(setA, 0, 9);
                addRange(setB, 3, 7);
            },
            superRight: function (setA, setB) {
                addRange(setB, 0, 9);
                addRange(setA, 3, 7);
            }
        };
        var sets = {
            same: function (setA, setB) {
            },
            superLeft: function (setA, setB) {
                setB.type = 'apples';
            },
            superRight: function (setA, setB) {
                setA.type = 'apples';
            }
        };
        var make = function () {
            var setA = {}, setB = {};
            each(arguments, function (method) {
                method(setA, setB);
            });
            return {
                left: setA,
                right: setB
            };
        };
        var assertSubset = function (methods, result) {
            var sets = make.apply(null, methods);
            equal(algebra.subset(sets.left, sets.right), result, JSON.stringify(sets.left) + ' \u2282 ' + JSON.stringify(sets.right) + ' = ' + result);
        };
        assertSubset([
            sets.superRight,
            range.right,
            sort.right
        ], false);
        assertSubset([
            sets.same,
            range.same,
            sort.different
        ], false);
        assertSubset([
            sets.same,
            range.same,
            sort.same
        ], true);
        assertSubset([
            sets.same,
            range.superRight,
            sort.left
        ], false);
        assertSubset([
            sets.same,
            range.superRight,
            sort.same
        ], true);
    });
    test('set.index', function () {
        var algebra = new set.Algebra(props.sort('sort'));
        var index = algebra.index({ sort: 'name' }, [
            {
                id: 1,
                name: 'g'
            },
            {
                id: 2,
                name: 'j'
            },
            {
                id: 3,
                name: 'm'
            },
            {
                id: 4,
                name: 's'
            }
        ], { name: 'k' });
        equal(index, 2);
    });
    test('set.getSubset (#14)', function () {
        var algebra = new set.Algebra(props.sort('sort'));
        var subset = algebra.getSubset({ sort: 'name' }, {}, [
            {
                id: 1,
                name: 's'
            },
            {
                id: 2,
                name: 'j'
            },
            {
                id: 3,
                name: 'm'
            },
            {
                id: 4,
                name: 'g'
            }
        ]);
        deepEqual(subset, [
            {
                id: 4,
                name: 'g'
            },
            {
                id: 2,
                name: 'j'
            },
            {
                id: 3,
                name: 'm'
            },
            {
                id: 1,
                name: 's'
            }
        ]);
    });
    test('set.getUnion', function () {
        var algebra = new set.Algebra(props.sort('sort'), props.boolean('complete'));
        var union = algebra.getUnion({
            sort: 'name',
            complete: true
        }, {
            sort: 'name',
            complete: false
        }, [
            {
                id: 4,
                name: 'g',
                complete: true
            },
            {
                id: 3,
                name: 'm',
                complete: true
            }
        ], [
            {
                id: 2,
                name: 'j',
                complete: false
            },
            {
                id: 1,
                name: 's',
                complete: false
            }
        ]);
        deepEqual(union, [
            {
                id: 4,
                name: 'g',
                complete: true
            },
            {
                id: 2,
                name: 'j',
                complete: false
            },
            {
                id: 3,
                name: 'm',
                complete: true
            },
            {
                id: 1,
                name: 's',
                complete: false
            }
        ]);
    });
    test('set.union keeps sort', function () {
        var algebra = new set.Algebra(props.sort('sort'), props.boolean('complete'));
        var union = algebra.union({
            sort: 'name',
            complete: true
        }, {
            sort: 'name',
            complete: false
        });
        deepEqual(union, { sort: 'name' });
    });
    test('paginated and sorted is subset (#17)', function () {
        var algebra = new set.Algebra(props.sort('sort'), props.rangeInclusive('start', 'end'));
        var res = algebra.subset({
            start: 0,
            end: 100,
            sort: 'name'
        }, {
            start: 0,
            end: 100,
            sort: 'name'
        });
        equal(res, true, 'parent:paginate+order child:paginate+order (same set)');
        res = algebra.subset({
            start: 0,
            end: 100,
            sort: 'name'
        }, {
            start: 0,
            end: 100,
            sort: 'age'
        });
        equal(res, false, 'parent:paginate+order child:paginate+order (different order)');
        res = algebra.subset({
            start: 0,
            end: 100,
            sort: 'name'
        }, { sort: 'name' });
        equal(res, true, 'parent:order child:paginate+order');
        res = algebra.subset({ sort: 'name' }, { sort: 'name' });
        equal(res, true, 'parent:order child:order (same)');
        res = algebra.subset({ sort: 'name' }, { sort: 'age' });
        equal(res, true, 'parent:order child:order (different)');
        res = algebra.subset({
            start: 0,
            end: 100
        }, { sort: 'name' });
        equal(res, true, 'parent:order child:paginate');
        res = algebra.subset({
            start: 0,
            end: 100,
            sort: 'age'
        }, { sort: 'name' });
        equal(res, true, 'parent:order child:paginate+order');
        res = algebra.subset({
            start: 0,
            end: 100,
            sort: 'name'
        }, {
            start: 0,
            end: 100
        });
        equal(res, false, 'parent:paginate child:paginate+order');
        res = algebra.subset({ sort: 'name' }, {
            start: 0,
            end: 100
        });
        equal(res, false, 'parent:paginate child:order (same)');
        res = algebra.subset({
            start: 0,
            end: 100,
            sort: 'name'
        }, {});
        equal(res, true, 'parent:-- child:paginate+order');
        res = algebra.subset({
            start: 10,
            end: 90,
            sort: 'name'
        }, {
            start: 0,
            end: 100,
            sort: 'name'
        });
        equal(res, true, 'child in smaller range, same sort');
        res = algebra.subset({
            start: 10,
            end: 90,
            sort: 'name'
        }, {
            start: 0,
            end: 100,
            sort: 'age'
        });
        equal(res, false, 'child in smaller range, but different sort');
    });
});
/*can-set@1.1.0#src/prop_tests/rangeInclusive_test*/
define('can-set@1.1.0#src/prop_tests/rangeInclusive_test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var set = require('../set-core'), props = require('../props');
    QUnit.module('can-set props.rangeInclusive');
    test('rangeInclusive set.equal', function () {
        ok(set.equal({
            start: 0,
            end: 100
        }, {
            start: 0,
            end: 100
        }, props.rangeInclusive('start', 'end')), 'they are equal');
        ok(!set.equal({
            start: 0,
            end: 100
        }, {
            start: 0,
            end: 101
        }, props.rangeInclusive('start', 'end')), 'they are not equal');
        ok(!set.equal({
            start: 0,
            end: 100
        }, {
            start: 1,
            end: 100
        }, props.rangeInclusive('start', 'end')), 'they are not equal');
    });
    test('rangeInclusive set.subset', function () {
        ok(set.subset({
            start: 0,
            end: 100
        }, {
            start: 0,
            end: 100
        }, props.rangeInclusive('start', 'end')), 'self is a subset');
        ok(set.subset({
            start: 0,
            end: 100
        }, {
            start: 0,
            end: 101
        }, props.rangeInclusive('start', 'end')), 'end extends past subset');
        ok(!set.subset({
            start: 0,
            end: 101
        }, {
            start: 0,
            end: 100
        }, props.rangeInclusive('start', 'end')), 'non-subset extends past end');
        ok(set.subset({
            start: 1,
            end: 100
        }, {
            start: 0,
            end: 100
        }, props.rangeInclusive('start', 'end')), 'start extends before subset');
        ok(!set.subset({
            start: 0,
            end: 100
        }, {
            start: 1,
            end: 100
        }, props.rangeInclusive('start', 'end')), 'non-subset extends before start');
    });
    test('rangeInclusive set.difference', function () {
        var prop = props.rangeInclusive('start', 'end');
        var res = set.difference({
            start: 0,
            end: 99
        }, {
            start: 50,
            end: 101
        }, prop);
        deepEqual(res, {
            start: 0,
            end: 49
        }, 'got a diff');
        res = set.difference({}, {
            start: 0,
            end: 10
        }, prop);
        equal(res, true, 'universal set');
        res = set.difference({
            start: 0,
            end: 49
        }, {
            start: 50,
            end: 101
        }, prop);
        deepEqual(res, {
            start: 0,
            end: 49
        }, 'side by side');
        res = set.difference({
            start: 0,
            end: 49
        }, {
            start: 0,
            end: 20
        }, prop);
        deepEqual(res, {
            start: 21,
            end: 49
        }, 'first set extends past second');
        res = set.difference({
            start: 0,
            end: 49
        }, {
            start: 20,
            end: 49
        }, prop);
        deepEqual(res, {
            start: 0,
            end: 19
        }, 'first set starts before second');
    });
    test('rangeInclusive set.union', function () {
        var prop = props.rangeInclusive('start', 'end');
        var res = set.union({
            start: 0,
            end: 99
        }, {
            start: 50,
            end: 101
        }, prop);
        deepEqual(res, {
            start: 0,
            end: 101
        }, 'got a union');
        res = set.union({}, {
            start: 0,
            end: 10
        }, prop);
        deepEqual(res, {}, 'universal set');
        res = set.union({
            start: 100,
            end: 199
        }, {
            start: 200,
            end: 299
        }, prop);
        deepEqual(res, {
            start: 100,
            end: 299
        }, 'no intersection');
        res = set.union({
            start: 200,
            end: 299
        }, {
            start: 100,
            end: 199
        }, prop);
        deepEqual(res, {
            start: 100,
            end: 299
        }, 'no intersection with either argument order');
        res = set.union({
            start: 200,
            end: 299
        }, {
            start: 100,
            end: 209
        }, prop);
        deepEqual(res, {
            start: 100,
            end: 299
        }, 'sets can intersect');
        res = set.union({
            start: 100,
            end: 209
        }, {
            start: 200,
            end: 299
        }, prop);
        deepEqual(res, {
            start: 100,
            end: 299
        }, 'sets can intersect with either argument order');
        res = set.union({
            start: 100,
            end: 299
        }, {
            start: 103,
            end: 209
        }, prop);
        deepEqual(res, {
            start: 100,
            end: 299
        }, 'first set contains second');
        res = set.union({
            start: 100,
            end: 299
        }, {
            start: 103,
            end: 209
        }, prop);
        deepEqual(res, {
            start: 100,
            end: 299
        }, 'second set contains first');
        res = set.union({
            start: 100,
            end: 299
        }, {
            start: 100,
            end: 299
        }, prop);
        deepEqual(res, {
            start: 100,
            end: 299
        }, 'union of identical sets is the same as those sets');
    });
    test('rangeInclusive set.count', function () {
        var prop = props.rangeInclusive('start', 'end');
        var res = set.count({
            start: 0,
            end: 99
        }, prop);
        equal(res, 100, 'count is right');
    });
    test('rangeInclusive set.intersection', function () {
        var prop = props.rangeInclusive('start', 'end');
        var res = set.intersection({
            start: 0,
            end: 99
        }, {
            start: 50,
            end: 101
        }, prop);
        deepEqual(res, {
            start: 50,
            end: 99
        }, 'got a intersection');
    });
    test('rangeInclusive with string numbers (#17)', function () {
        var algebra = new set.Algebra(props.rangeInclusive('start', 'end'));
        ok(algebra.subset({
            start: '1',
            end: '100'
        }, {
            start: '0',
            end: '100'
        }), '.subset');
        var res = algebra.getSubset({
            start: '2',
            end: '3'
        }, {
            start: '1',
            end: '4'
        }, [
            { id: 1 },
            { id: 2 },
            { id: 3 },
            { id: 4 }
        ]);
        deepEqual(res, [
            { id: 2 },
            { id: 3 }
        ], '.getSubset');
        res = algebra.getUnion({
            start: '2',
            end: '3'
        }, {
            start: '1',
            end: '4'
        }, [
            { id: 2 },
            { id: 3 }
        ], [
            { id: 1 },
            { id: 2 },
            { id: 3 },
            { id: 4 }
        ]);
        deepEqual(res, [
            { id: 1 },
            { id: 2 },
            { id: 3 },
            { id: 4 }
        ], '.getUnion');
    });
});
/*can-set@1.1.0#src/prop_tests/offsetLimit_test*/
define('can-set@1.1.0#src/prop_tests/offsetLimit_test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var set = require('../set-core'), props = require('../props');
    QUnit.module('can-set props.limitOffset');
    test('offsetLimit set.equal', function () {
        ok(set.equal({
            offset: 0,
            limit: 99
        }, {
            offset: 0,
            limit: 99
        }, props.offsetLimit('offset', 'limit')), 'they are equal');
        ok(!set.equal({
            offset: 0,
            limit: 100
        }, {
            offset: 0,
            limit: 101
        }, props.offsetLimit('offset', 'limit')), 'they are not equal');
        ok(!set.equal({
            offset: 0,
            limit: 100
        }, {
            offset: 1,
            limit: 100
        }, props.offsetLimit('offset', 'limit')), 'they are not equal');
    });
    test('offsetLimit set.union', function () {
        var prop = props.offsetLimit('offset', 'limit');
        var res = set.union({
            offset: 0,
            limit: 100
        }, {
            offset: 50,
            limit: 52
        }, prop);
        deepEqual(res, {
            offset: 0,
            limit: 102
        }, 'got a union');
        res = set.union({}, {
            offset: 0,
            limit: 10
        }, prop);
        deepEqual(res, {}, 'universal set');
        res = set.union({
            offset: 100,
            limit: 100
        }, {
            offset: 200,
            limit: 100
        }, prop);
        deepEqual(res, {
            offset: 100,
            limit: 200
        }, 'no intersection');
        res = set.union({
            offset: 200,
            limit: 100
        }, {
            offset: 100,
            limit: 100
        }, prop);
        deepEqual(res, {
            offset: 100,
            limit: 200
        }, 'no intersection with either argument order');
        res = set.union({
            offset: 100,
            limit: 110
        }, {
            offset: 200,
            limit: 100
        }, prop);
        deepEqual(res, {
            offset: 100,
            limit: 200
        }, 'sets can intersect with either argument order');
    });
    test('rangeInclusive set.count', function () {
        var prop = props.offsetLimit('offset', 'limit');
        var res = set.count({
            offset: 0,
            limit: 100
        }, prop);
        equal(res, 100, 'count is right');
    });
    test('rangeInclusive set.intersection', function () {
        var prop = props.offsetLimit('offset', 'limit');
        var res = set.intersection({
            offset: 0,
            limit: 100
        }, {
            offset: 50,
            limit: 52
        }, prop);
        deepEqual(res, {
            offset: 50,
            limit: 50
        }, 'got a intersection');
    });
});
/*can-set@1.1.0#src/prop_tests/boolean_test*/
define('can-set@1.1.0#src/prop_tests/boolean_test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var set = require('../set-core'), props = require('../props');
    QUnit.module('can-set props.boolean');
    test('boolean set.difference', function () {
        var prop = props.boolean('completed');
        var res = set.difference({}, { completed: true }, prop);
        deepEqual(res, { completed: false }, 'inverse of true');
        res = set.difference({}, { completed: false }, prop);
        deepEqual(res, { completed: true }, 'inverse of false');
    });
    test('boolean set.union', function () {
        var prop = props.boolean('completed');
        var res = set.union({ completed: false }, { completed: true }, prop);
        deepEqual(res, {}, 'union of true and false is entire boolean set');
    });
    test('boolean set.intersection', function () {
        var prop = props.boolean('completed');
        var res = set.intersection({ foo: 'bar' }, { completed: true }, prop);
        deepEqual(res, {
            foo: 'bar',
            completed: true
        }, 'intersection is false (#4)');
    });
    test('strings false and true are treated as booleans', function () {
        var prop = props.boolean('completed');
        var res = set.subset({}, { completed: 'true' }, prop);
        ok(!res, '{} and \'true\' not a subset');
        res = set.subset({}, { completed: 'false' }, prop);
        ok(!res, '{} and \'false\' not a subset');
        res = set.subset({ completed: 'true' }, {}, prop);
        ok(res, 'subset');
        res = set.subset({ completed: 'false' }, {}, prop);
        ok(res, 'subset');
        res = set.union({ completed: 'false' }, { completed: 'true' }, prop);
        deepEqual(res, {}, 'union of true and false is entire boolean set');
        res = set.equal({ completed: false }, { completed: 'false' }, prop);
        ok(res, 'false and \'false\'');
    });
});
/*can-set@1.1.0#src/prop_tests/enum_test*/
define('can-set@1.1.0#src/prop_tests/enum_test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var set = require('../set-core'), props = require('../props');
    QUnit.module('can-set props.enum');
    test('enum set.intersection', function () {
        var prop = props['enum']('type', [
            'new',
            'prep',
            'deliver',
            'delivered'
        ]);
        var res = set.intersection({}, { type: 'new' }, prop);
        deepEqual(res, { type: 'new' }, 'single enum intersected with universal set is idempotent');
        res = set.intersection({}, {
            type: [
                'new',
                'prep'
            ]
        }, prop);
        deepEqual(res, {
            type: [
                'new',
                'prep'
            ]
        }, 'array enum intersected with unversal set is idempotent');
        res = set.intersection({ type: ['prep'] }, {
            type: [
                'new',
                'prep'
            ]
        }, prop);
        deepEqual(res, { type: 'prep' }, 'items v items intersection');
        res = set.intersection({ type: [] }, {
            type: [
                'new',
                'prep'
            ]
        }, prop);
        deepEqual(res, {
            type: [
                'new',
                'prep'
            ]
        }, 'empty v array intersection');
        res = set.intersection({ type: 'new' }, {}, prop);
        deepEqual(res, { type: 'new' }, 'single v all');
    });
    test('enum set.difference', function () {
        var prop = props['enum']('type', [
            'new',
            'prep',
            'deliver',
            'delivered'
        ]);
        var res = set.difference({}, { type: 'new' }, prop);
        deepEqual(res, {
            type: [
                'prep',
                'deliver',
                'delivered'
            ]
        }, 'difference from universal set');
        res = set.difference({}, {
            type: [
                'new',
                'prep'
            ]
        }, prop);
        deepEqual(res, {
            type: [
                'deliver',
                'delivered'
            ]
        }, 'difference from universal set');
        res = set.difference({ type: ['prep'] }, {
            type: [
                'new',
                'prep'
            ]
        }, prop);
        deepEqual(res, false, 'difference from a superset');
        res = set.difference({ type: [] }, {
            type: [
                'new',
                'prep'
            ]
        }, prop);
        deepEqual(res, {
            type: [
                'deliver',
                'delivered'
            ]
        }, 'empty enum definition is same as universal set');
        res = set.difference({ type: 'new' }, {}, prop);
        deepEqual(res, false, 'all');
    });
    test('enum set.union', function () {
        var prop = props['enum']('type', [
            'new',
            'prep',
            'deliver',
            'delivered'
        ]);
        var res = set.union({}, { type: 'new' }, prop);
        deepEqual(res, {}, 'all');
        res = set.union({}, {
            type: [
                'new',
                'prep'
            ]
        }, prop);
        deepEqual(res, {}, 'intersection');
        res = set.union({ type: ['prep'] }, {
            type: [
                'new',
                'prep'
            ]
        }, prop);
        deepEqual(res, {
            type: [
                'prep',
                'new'
            ]
        }, 'union of a superset is superset');
        res = set.union({ type: [] }, {
            type: [
                'new',
                'prep'
            ]
        }, prop);
        deepEqual(res, {}, 'intersection');
        res = set.union({ type: 'new' }, {}, prop);
        deepEqual(res, {}, 'all');
        res = set.union({
            type: [
                'deliver',
                'delivered'
            ]
        }, {
            type: [
                'new',
                'prep'
            ]
        }, prop);
        deepEqual(res, {}, 'intersection');
    });
    test('enum set.equal', function () {
        var prop = props['enum']('type', [
            'new',
            'prep',
            'deliver',
            'delivered'
        ]);
        var res = set.equal({}, { type: 'new' }, prop);
        deepEqual(res, false, 'proper subset is not the universal set');
        res = set.equal({}, {
            type: [
                'new',
                'prep',
                'deliver',
                'delivered'
            ]
        }, prop);
        deepEqual(res, true, 'subset of all possible enums is the same as universal set');
        res = set.equal({ type: ['prep'] }, { type: ['prep'] }, prop);
        deepEqual(res, true, 'identical sets with single array enum are equal');
        res = set.equal({ type: 'prep' }, { type: 'prep' }, prop);
        deepEqual(res, true, 'identical sets with single property enum are equal');
        res = set.equal({ type: 'new' }, { type: 'prep' }, prop);
        deepEqual(res, false, 'two sets with different enum properties are not equal');
    });
    test('enum set.subset', function () {
        var prop = props['enum']('type', [
            'new',
            'prep',
            'deliver',
            'delivered'
        ]);
        var res = set.subset({}, { type: 'new' }, prop);
        deepEqual(res, false, 'universal set is not a subset');
        res = set.subset({ type: 'new' }, {}, prop);
        deepEqual(res, true, 'any single enum is a subset of universal set');
        res = set.subset({}, {
            type: [
                'new',
                'prep',
                'deliver',
                'delivered'
            ]
        }, prop);
        deepEqual(res, true, 'enum set matching definition of universal set is a subset of universal set');
        res = set.subset({ type: ['prep'] }, { type: ['prep'] }, prop);
        deepEqual(res, true, 'any list of possible enums are subset of universal set');
        res = set.subset({ type: 'prep' }, { type: 'prep' }, prop);
        deepEqual(res, true, 'intersection');
        res = set.subset({ type: 'new' }, { type: 'prep' }, prop);
        deepEqual(res, false, 'all');
        res = set.subset({ type: 'prep' }, {
            type: [
                'new',
                'prep',
                'deliver',
                'delivered'
            ]
        }, prop);
        deepEqual(res, true, 'intersection');
    });
});
/*can-set@1.1.0#src/props_test*/
define('can-set@1.1.0#src/props_test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    QUnit.module('can-set props');
    require('./prop_tests/sort_test');
    require('./prop_tests/rangeInclusive_test');
    require('./prop_tests/offsetLimit_test');
    require('./prop_tests/boolean_test');
    require('./prop_tests/enum_test');
});
/*can-set@1.1.0#src/get_test*/
define('can-set@1.1.0#src/get_test', function (require, exports, module) {
    var set = require('./set');
    var QUnit = require('steal-qunit');
    var props = require('./props');
    var h = require('./helpers');
    QUnit.module('can-set get');
    var getId = function (d) {
        return d.id;
    };
    var items = [
        {
            id: 0,
            note: 'C',
            type: 'eh'
        },
        {
            id: 1,
            note: 'D',
            type: 'critical'
        },
        {
            id: 2,
            note: 'E',
            type: 'critical'
        },
        {
            id: 3,
            note: 'F',
            type: 'eh'
        },
        {
            id: 4,
            note: 'G',
            type: 'critical'
        },
        {
            id: 5,
            note: 'A'
        },
        {
            id: 6,
            note: 'B',
            type: 'critical'
        },
        {
            id: 7,
            note: 'C',
            type: 'critical'
        }
    ];
    test('getSubset against non ranged set', function () {
        var res = set.getSubset({
            type: 'critical',
            start: 1,
            end: 3
        }, {}, items, props.rangeInclusive('start', 'end'));
        deepEqual(res && h.map.call(res, getId), [
            2,
            4,
            6
        ]);
    });
    test('getSubset ordered ascending and paginated', function () {
        var algebra = new set.Algebra(props.sort('sort'), props.rangeInclusive('start', 'end'));
        var res = set.getSubset({
            type: 'critical',
            start: 1,
            end: 3,
            sort: 'note AsC'
        }, {}, items, algebra);
        deepEqual(res && h.map.call(res, getId), [
            7,
            1,
            2
        ]);
    });
    test('getSubset ordered descending and paginated', function () {
        var algebra = new set.Algebra(props.sort('sort'), props.rangeInclusive('start', 'end'));
        var res = set.getSubset({
            type: 'critical',
            start: 1,
            end: 3,
            sort: 'note deSc'
        }, {}, items, algebra);
        deepEqual(res && h.map.call(res, getId), [
            2,
            1,
            7
        ]);
    });
    test('getSubset against paginated set', function () {
        var res = set.getSubset({
            type: 'critical',
            start: 21,
            end: 23
        }, {
            type: 'critical',
            start: 20,
            end: 27
        }, items, props.rangeInclusive('start', 'end'));
        deepEqual(res && h.map.call(res, getId), [
            2,
            4,
            6
        ]);
    });
    test('getSubset returns undefined against incompatible set', function () {
        var res = set.getSubset({ note: 'C' }, { type: 'critical' }, items);
        strictEqual(res, undefined);
    });
    test('getUnion basics', function () {
        var union = set.getUnion({}, { foo: 'bar' }, items, items.slice(0, 3));
        deepEqual(union, items);
    });
    test('getUnion against ranged sets', function () {
        var union = set.getUnion({
            start: 10,
            end: 13
        }, {
            start: 14,
            end: 17
        }, items.slice(0, 4), items.slice(4, 8), props.rangeInclusive('start', 'end'));
        deepEqual(union, items);
        union = set.getUnion({
            start: 14,
            end: 17
        }, {
            start: 10,
            end: 13
        }, items.slice(4, 8), items.slice(0, 4), props.rangeInclusive('start', 'end'));
        deepEqual(union, items, 'disjoint after');
    });
    test('getUnion against overlapping ranged sets', function () {
        var union = set.getUnion({
            start: 10,
            end: 14
        }, {
            start: 13,
            end: 17
        }, items.slice(0, 5), items.slice(3, 8), props.rangeInclusive('start', 'end'));
        deepEqual(union, items);
        union = set.getUnion({
            start: 10,
            end: 11
        }, {
            start: 11,
            end: 17
        }, items.slice(0, 2), items.slice(1, 8), props.rangeInclusive('start', 'end'));
        deepEqual(union, items);
        union = set.getUnion({
            start: 11,
            end: 17
        }, {
            start: 10,
            end: 11
        }, items.slice(1, 8), items.slice(0, 2), props.rangeInclusive('start', 'end'));
        deepEqual(union, items);
    });
    test('getSubset passed same object works (#3)', function () {
        var algebra = new set.Algebra(props.rangeInclusive('start', 'end'));
        var setObj = {
            start: 1,
            end: 2
        };
        var items = algebra.getSubset(setObj, setObj, [{ id: 1 }]);
        deepEqual(items, [{ id: 1 }]);
    });
});
/*can-set@1.1.0#src/set_test*/
define('can-set@1.1.0#src/set_test', function (require, exports, module) {
    require('steal-qunit');
    var set = require('./set');
    QUnit.module('can-set');
    test('set.Algebra constructors', function () {
        var algebra = new set.Algebra(set.props.rangeInclusive('start', 'end'), set.props.boolean('completed'), set.props['enum']('type', [
            'new',
            'prep',
            'deliver',
            'delivered'
        ]));
        var res = algebra.subset({ type: ['new'] }, {
            type: [
                'new',
                'prep'
            ]
        });
        deepEqual(res, true, 'enum');
    });
    test('set.clause', function () {
        QUnit.ok(set.clause);
    });
});
/*can-set@1.1.0#test/test*/
define('can-set@1.1.0#test/test', function (require, exports, module) {
    require('../src/set-core_test');
    require('../src/set-core-nested_test');
    require('../src/props_test');
    require('../src/get_test');
    require('../src/set_test');
});
/*can-stache@3.0.20#test/expression-test*/
define('can-stache@3.0.20#test/expression-test', function (require, exports, module) {
    var expression = require('../src/expression');
    var QUnit = require('steal-qunit');
    var each = require('can-util/js/each/each');
    var Scope = require('can-view-scope');
    var canCompute = require('can-compute');
    var CanMap = require('can-map');
    var helpers = require('../helpers/converter');
    QUnit.module('can-stache/src/expression');
    test('expression.tokenize', function () {
        var literals = '\'quote\' "QUOTE" 1 undefined null true false 0.1';
        var res = expression.tokenize(literals);
        deepEqual(res, literals.split(' '));
        var keys = 'key foo.bar foo@bar %foo *foo foo/bar';
        res = expression.tokenize(keys);
        deepEqual(res, keys.split(' '));
        var syntax = '( ) , ~ =';
        res = expression.tokenize(syntax);
        deepEqual(res, syntax.split(' '));
        var curly = '{{ }}';
        res = expression.tokenize(curly);
        deepEqual(res, []);
        var bracket = '[foo] bar [baz]';
        res = expression.tokenize(bracket);
        deepEqual(res, [
            '[',
            'foo',
            ']',
            ' ',
            'bar',
            ' ',
            '[',
            'baz',
            ']',
            ' '
        ]);
    });
    test('expression.ast - helper followed by hash', function () {
        var ast = expression.ast('print_hash prop=own_prop');
        deepEqual(ast, {
            type: 'Helper',
            method: {
                type: 'Lookup',
                key: 'print_hash'
            },
            children: [{
                    type: 'Hashes',
                    children: [{
                            type: 'Hash',
                            prop: 'prop',
                            children: [{
                                    type: 'Lookup',
                                    key: 'own_prop'
                                }]
                        }]
                }]
        });
    });
    test('expression.ast - everything', function () {
        var ast = expression.ast('helperA helperB(1, valueA, propA=~valueB propC=2, 1).zed() \'def\' nested@prop outerPropA=helperC(2,valueB)');
        var helperBCall = {
            type: 'Call',
            method: {
                type: 'Lookup',
                key: '@helperB'
            },
            children: [
                {
                    type: 'Literal',
                    value: 1
                },
                {
                    type: 'Lookup',
                    key: 'valueA'
                },
                {
                    type: 'Hashes',
                    children: [
                        {
                            type: 'Hash',
                            prop: 'propA',
                            children: [{
                                    type: 'Arg',
                                    key: '~',
                                    children: [{
                                            type: 'Lookup',
                                            key: 'valueB'
                                        }]
                                }]
                        },
                        {
                            type: 'Hash',
                            prop: 'propC',
                            children: [{
                                    type: 'Literal',
                                    value: 2
                                }]
                        }
                    ]
                },
                {
                    type: 'Literal',
                    value: 1
                }
            ]
        };
        var helperCCall = {
            type: 'Call',
            method: {
                type: 'Lookup',
                key: '@helperC'
            },
            children: [
                {
                    type: 'Literal',
                    value: 2
                },
                {
                    type: 'Lookup',
                    key: 'valueB'
                }
            ]
        };
        deepEqual(ast, {
            type: 'Helper',
            method: {
                type: 'Lookup',
                key: 'helperA'
            },
            children: [
                {
                    type: 'Call',
                    method: {
                        type: 'Lookup',
                        root: helperBCall,
                        key: '@zed'
                    }
                },
                {
                    type: 'Literal',
                    value: 'def'
                },
                {
                    type: 'Lookup',
                    key: 'nested@prop'
                },
                {
                    type: 'Hashes',
                    children: [{
                            type: 'Hash',
                            prop: 'outerPropA',
                            children: [helperCCall]
                        }]
                }
            ]
        });
    });
    test('expression.parse - everything', function () {
        var exprData = expression.parse('helperA helperB(1, valueA, propA=~valueB propC=2, 1).zed \'def\' nested@prop outerPropA=helperC(2,valueB)');
        var oneExpr = new expression.Literal(1), twoExpr = new expression.Literal(2), def = new expression.Literal('def'), valueA = new expression.ScopeLookup('valueA'), valueB = new expression.ScopeLookup('valueB'), nested = new expression.HelperScopeLookup('nested@prop'), helperA = new expression.HelperLookup('helperA'), helperB = new expression.Lookup('@helperB'), helperC = new expression.Lookup('@helperC');
        var helperBHashArg = new expression.Hashes({
            propA: new expression.Arg(valueB, { compute: true }),
            propC: twoExpr
        });
        var callHelperB = new expression.Call(helperB, [
            oneExpr,
            valueA,
            helperBHashArg,
            oneExpr
        ]);
        var callHelperBdotZed = new expression.ScopeLookup('zed', callHelperB);
        var callHelperC = new expression.Call(helperC, [
            twoExpr,
            valueB
        ], {});
        var callHelperA = new expression.Helper(helperA, [
            callHelperBdotZed,
            def,
            nested
        ], { outerPropA: callHelperC });
        deepEqual(callHelperB, exprData.argExprs[0].rootExpr, 'call helper b');
        deepEqual(callHelperC, exprData.hashExprs.outerPropA, 'helperC call');
        deepEqual(callHelperBdotZed, exprData.argExprs[0], 'call helper b.zed');
        var expectedArgs = [
            callHelperBdotZed,
            def,
            nested
        ];
        each(exprData.argExprs, function (arg, i) {
            deepEqual(arg, expectedArgs[i], 'helperA arg[' + i);
        });
        deepEqual(exprData, callHelperA, 'full thing');
    });
    test('expression.parse(str, {lookupRule: \'method\', methodRule: \'call\'})', function () {
        var exprData = expression.parse('withArgs content=content', {
            lookupRule: 'method',
            methodRule: 'call'
        });
        var valueContent = new expression.ScopeLookup('content');
        var hashArg = new expression.Arg(new expression.Hashes({ content: valueContent }));
        equal(exprData.argExprs.length, 1, 'there is one arg');
        deepEqual(exprData.argExprs[0], hashArg, 'correct hashes');
    });
    test('numeric expression.Literal', function () {
        var exprData = expression.parse('3');
        var result = new expression.Literal(3);
        deepEqual(exprData, result);
    });
    test('expression.Helper:value non-observable values', function () {
        var scope = new Scope({
            fullName: function (first, last) {
                return first + ' ' + last;
            }
        });
        var callFullName = new expression.Helper(new expression.HelperLookup('fullName'), [
            new expression.Literal('marshall'),
            new expression.Literal('thompson')
        ], {});
        var result = callFullName.value(scope, new Scope({}), {});
        equal(result, 'marshall thompson');
    });
    test('expression.Helper:value observable values', function () {
        var scope = new Scope({
            fullName: function (first, last) {
                return first() + ' ' + last;
            },
            first: canCompute('marshall')
        });
        var callFullName = new expression.Helper(new expression.HelperLookup('fullName'), [
            new expression.HelperLookup('first'),
            new expression.Literal('thompson')
        ], {});
        var result = callFullName.value(scope, new Scope({}));
        equal(result(), 'marshall thompson');
    });
    test('methods can return values (#1887)', function () {
        var MyMap = CanMap.extend({
            getSomething: function (arg) {
                return this.attr('foo') + arg();
            }
        });
        var scope = new Scope(new MyMap({
            foo: 2,
            bar: 3
        })).add({});
        var callGetSomething = new expression.Helper(new expression.HelperLookup('getSomething'), [new expression.ScopeLookup('bar')], {});
        var result = callGetSomething.value(scope, new Scope({}), { asCompute: true });
        equal(result(), 5);
    });
    test('methods don\'t update correctly (#1891)', function () {
        var map = new CanMap({
            num: 1,
            num2: function () {
                return this.attr('num') * 2;
            },
            runTest: function () {
                this.attr('num', this.attr('num') * 2);
            }
        });
        var scope = new Scope(map);
        var num2Expression = new expression.Lookup('num2');
        var num2 = num2Expression.value(scope, new Scope({}), { asCompute: true });
        num2.bind('change', function (ev, newVal) {
        });
        map.runTest();
        equal(num2(), 4, 'num2 updated correctly');
    });
    test('call expressions called with different scopes give different results (#1791)', function () {
        var exprData = expression.parse('doSomething(number)');
        var res = exprData.value(new Scope({
            doSomething: function (num) {
                return num * 2;
            },
            number: canCompute(2)
        }));
        equal(res(), 4);
        res = exprData.value(new Scope({
            doSomething: function (num) {
                return num * 3;
            },
            number: canCompute(4)
        }));
        equal(res(), 12);
    });
    test('convertKeyToLookup', function () {
        equal(expression.convertKeyToLookup('../foo'), '../@foo');
        equal(expression.convertKeyToLookup('foo'), '@foo');
        equal(expression.convertKeyToLookup('.foo'), '@foo');
        equal(expression.convertKeyToLookup('./foo'), './@foo');
        equal(expression.convertKeyToLookup('foo.bar'), 'foo@bar');
    });
    test('expression.ast - [] operator', function () {
        deepEqual(expression.ast('[\'propName\']'), {
            type: 'Bracket',
            children: [{
                    type: 'Literal',
                    value: 'propName'
                }]
        }, '[\'propName\'] valid');
        deepEqual(expression.ast('[propName]'), {
            type: 'Bracket',
            children: [{
                    type: 'Lookup',
                    key: 'propName'
                }]
        }, '[propName] valid');
        deepEqual(expression.ast('foo[\'bar\']'), {
            type: 'Bracket',
            root: {
                type: 'Lookup',
                key: 'foo'
            },
            children: [{
                    type: 'Literal',
                    value: 'bar'
                }]
        }, 'foo[\'bar\'] valid');
        deepEqual(expression.ast('foo[bar]'), {
            type: 'Bracket',
            root: {
                type: 'Lookup',
                key: 'foo'
            },
            children: [{
                    type: 'Lookup',
                    key: 'bar'
                }]
        }, 'foo[bar] valid');
        deepEqual(expression.ast('foo[bar()]'), {
            type: 'Bracket',
            root: {
                type: 'Lookup',
                key: 'foo'
            },
            children: [{
                    type: 'Call',
                    method: {
                        key: '@bar',
                        type: 'Lookup'
                    }
                }]
        }, 'foo[bar()] valid');
        deepEqual(expression.ast('foo()[bar]'), {
            type: 'Bracket',
            root: {
                type: 'Call',
                method: {
                    key: '@foo',
                    type: 'Lookup'
                }
            },
            children: [{
                    type: 'Lookup',
                    key: 'bar'
                }]
        }, 'foo()[bar] valid');
        deepEqual(expression.ast('foo [bar]'), {
            type: 'Helper',
            method: {
                type: 'Lookup',
                key: 'foo'
            },
            children: [{
                    type: 'Bracket',
                    children: [{
                            type: 'Lookup',
                            key: 'bar'
                        }]
                }]
        }, 'foo [bar] valid');
        deepEqual(expression.ast('eq foo[\'bar\'] \'foo\''), {
            type: 'Helper',
            method: {
                type: 'Lookup',
                key: 'eq'
            },
            children: [
                {
                    type: 'Bracket',
                    root: {
                        type: 'Lookup',
                        key: 'foo'
                    },
                    children: [{
                            type: 'Literal',
                            value: 'bar'
                        }]
                },
                {
                    type: 'Literal',
                    value: 'foo'
                }
            ]
        }, 'eq foo[\'bar\'] \'foo\' valid');
        deepEqual(expression.ast('eq foo[bar] foo'), {
            type: 'Helper',
            method: {
                type: 'Lookup',
                key: 'eq'
            },
            children: [
                {
                    type: 'Bracket',
                    root: {
                        type: 'Lookup',
                        key: 'foo'
                    },
                    children: [{
                            type: 'Lookup',
                            key: 'bar'
                        }]
                },
                {
                    type: 'Lookup',
                    key: 'foo'
                }
            ]
        }, 'eq foo[bar] foo valid');
        deepEqual(expression.ast('foo[bar][baz]'), {
            type: 'Bracket',
            root: {
                type: 'Bracket',
                root: {
                    type: 'Lookup',
                    key: 'foo'
                },
                children: [{
                        type: 'Lookup',
                        key: 'bar'
                    }]
            },
            children: [{
                    type: 'Lookup',
                    key: 'baz'
                }]
        }, 'foo[bar][baz] valid');
        deepEqual(expression.ast('foo[bar].baz'), {
            type: 'Lookup',
            key: 'baz',
            root: {
                type: 'Bracket',
                root: {
                    type: 'Lookup',
                    key: 'foo'
                },
                children: [{
                        type: 'Lookup',
                        key: 'bar'
                    }]
            }
        }, 'foo[bar].baz');
        deepEqual(expression.ast('eq foo[bar].baz xyz'), {
            type: 'Helper',
            method: {
                type: 'Lookup',
                key: 'eq'
            },
            children: [
                {
                    type: 'Lookup',
                    key: 'baz',
                    root: {
                        type: 'Bracket',
                        root: {
                            type: 'Lookup',
                            key: 'foo'
                        },
                        children: [{
                                type: 'Lookup',
                                key: 'bar'
                            }]
                    }
                },
                {
                    type: 'Lookup',
                    key: 'xyz'
                }
            ]
        }, 'eq foo[bar].baz xyz');
    });
    test('expression.parse - [] operator', function () {
        deepEqual(expression.parse('[\'propName\']'), new expression.Bracket(new expression.Literal('propName')), '[\'propName\']');
        deepEqual(expression.parse('[propName]'), new expression.Bracket(new expression.Lookup('propName')), '[propName]');
        deepEqual(expression.parse('foo[\'bar\']'), new expression.Bracket(new expression.Literal('bar'), new expression.Lookup('foo')), 'foo[\'bar\']');
        deepEqual(expression.parse('foo[bar]'), new expression.Bracket(new expression.Lookup('bar'), new expression.Lookup('foo')), 'foo[bar]');
        deepEqual(expression.parse('foo()[bar]'), new expression.Bracket(new expression.Lookup('bar'), new expression.Call(new expression.Lookup('@foo'), [], {})), 'foo()[bar]');
        exprData = expression.parse('foo[bar()]');
        deepEqual(exprData, new expression.Bracket(new expression.Call(new expression.Lookup('@bar'), [], {}), new expression.Lookup('foo')));
        exprData = expression.parse('foo()[bar()]');
        deepEqual(exprData, new expression.Bracket(new expression.Call(new expression.Lookup('@bar'), [], {}), new expression.Call(new expression.Lookup('@foo'), [], {})));
    });
    test('Bracket expression', function () {
        var expr = new expression.Bracket(new expression.Literal('bar'));
        var compute = expr.value(new Scope(new CanMap({ bar: 'name' })));
        equal(compute(), 'name');
        expr = new expression.Bracket(new expression.Lookup('bar'));
        compute = expr.value(new Scope(new CanMap({
            bar: 'name',
            name: 'Kevin'
        })));
        equal(compute(), 'Kevin');
        expr = new expression.Bracket(new expression.Literal('bar'), new expression.Lookup('foo'));
        compute = expr.value(new Scope(new CanMap({ foo: { bar: 'name' } })));
        equal(compute(), 'name');
        expr = new expression.Bracket(new expression.Lookup('bar'), new expression.Lookup('foo'));
        var state = new CanMap({
            foo: { name: 'Kevin' },
            bar: 'name'
        });
        compute = expr.value(new Scope(state));
        equal(compute(), 'Kevin');
        compute('Curtis');
        equal(state.attr('foo.name'), 'Curtis');
        expr = new expression.Bracket(new expression.Lookup('bar'), new expression.Call(new expression.Lookup('@foo'), [], {}));
        compute = expr.value(new Scope(new CanMap({
            foo: function () {
                return { name: 'Kevin' };
            },
            bar: 'name'
        })));
        equal(compute(), 'Kevin');
        expr = new expression.Bracket(new expression.Call(new expression.Lookup('@bar'), [], {}), new expression.Lookup('foo'));
        compute = expr.value(new Scope(new CanMap({
            foo: { name: 'Kevin' },
            bar: function () {
                return 'name';
            }
        })));
        equal(compute(), 'Kevin');
        expr = new expression.Bracket(new expression.Call(new expression.Lookup('@bar'), [], {}), new expression.Call(new expression.Lookup('@foo'), [], {}));
        compute = expr.value(new Scope(new CanMap({
            foo: function () {
                return { name: 'Kevin' };
            },
            bar: function () {
                return 'name';
            }
        })));
        equal(compute(), 'Kevin');
        expr = new expression.Call(new expression.Lookup('@foo'), [new expression.Bracket(new expression.Lookup('bar'))], {});
        compute = expr.value(new Scope(new CanMap({
            foo: function (val) {
                return val + '!';
            },
            bar: 'name',
            name: 'Kevin'
        })));
        equal(compute(), 'Kevin!');
    });
    test('registerConverter helpers push and pull correct values', function () {
        helpers.registerConverter('numberToHex', {
            get: function (valCompute) {
                return valCompute().toString(16);
            },
            set: function (val, valCompute) {
                return valCompute(parseInt('0x' + val));
            }
        });
        var data = new CanMap({ observeVal: 255 });
        var scope = new Scope(data);
        var parentExpression = expression.parse('numberToHex(~observeVal)', { baseMethodType: 'Call' });
        var twoWayCompute = parentExpression.value(scope, new Scope.Options({}));
        equal(twoWayCompute(), 'ff', 'Converter called');
        twoWayCompute('7f');
        equal(data.attr('observeVal'), 127, 'push converter called');
    });
    test('registerConverter helpers push and pull multiple values', function () {
        helpers.registerConverter('isInList', {
            get: function (valCompute, list) {
                return !!~list.indexOf(valCompute());
            },
            set: function (newVal, valCompute, list) {
                if (!~list.indexOf(newVal)) {
                    list.push(newVal);
                }
            }
        });
        var data = new CanMap({
            observeVal: 4,
            list: [
                1,
                2,
                3
            ]
        });
        var scope = new Scope(data);
        var parentExpression = expression.parse('isInList(~observeVal, list)', { baseMethodType: 'Call' });
        var twoWayCompute = parentExpression.value(scope, new Scope.Options({}));
        equal(twoWayCompute(), false, 'Converter called');
        twoWayCompute(5);
        deepEqual(data.attr('list').attr(), [
            1,
            2,
            3,
            5
        ], 'push converter called');
    });
    test('registerConverter helpers are chainable', function () {
        helpers.registerConverter('numberToHex', {
            get: function (valCompute) {
                return valCompute().toString(16);
            },
            set: function (val, valCompute) {
                return valCompute(parseInt('0x' + val));
            }
        });
        helpers.registerConverter('upperCase', {
            get: function (valCompute) {
                return valCompute().toUpperCase();
            },
            set: function (val, valCompute) {
                return valCompute(val.toLowerCase());
            }
        });
        var data = new CanMap({ observeVal: 255 });
        var scope = new Scope(data);
        var parentExpression = expression.parse('upperCase(~numberToHex(~observeVal))', { baseMethodType: 'Call' });
        var twoWayCompute = parentExpression.value(scope, new Scope.Options({}));
        equal(twoWayCompute(), 'FF', 'Converter called');
        twoWayCompute('7F');
        equal(data.attr('observeVal'), 127, 'push converter called');
    });
    test('foo().bar', function () {
        var ast4 = expression.ast('foo().bar');
        deepEqual(ast4, {
            type: 'Lookup',
            key: 'bar',
            root: {
                type: 'Call',
                method: {
                    key: '@foo',
                    type: 'Lookup'
                }
            }
        });
        var exprData = expression.parse('foo().bar');
        deepEqual(exprData, new expression.Lookup('bar', new expression.Call(new expression.Lookup('@foo'), [], {})));
        var expr = new expression.Lookup('bar', new expression.Call(new expression.Lookup('@foo'), [], {}));
        var compute = expr.value(new Scope(new CanMap({
            foo: function () {
                return { bar: 'Kevin' };
            }
        })));
        equal(compute(), 'Kevin');
    });
    test('Helper with a ~ key operator (#112)', function () {
        var ast = expression.ast('each ~foo');
        var expected = {
            type: 'Helper',
            method: {
                type: 'Lookup',
                key: 'each'
            },
            children: [{
                    type: 'Arg',
                    key: '~',
                    children: [{
                            type: 'Lookup',
                            key: 'foo'
                        }]
                }]
        };
        QUnit.deepEqual(ast, expected);
    });
});
/*can-stache@3.0.20#test/stache-define-test*/
define('can-stache@3.0.20#test/stache-define-test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var stache = require('can-stache');
    var DefineMap = require('can-define/map/map');
    var DefineList = require('can-define/list/list');
    QUnit.module('can-stache with can-define');
    test('basic replacement and updating', function () {
        var map = new DefineMap({ message: 'World' });
        var stashed = stache('<h1 class=\'foo\'>{{message}}</h1>');
        var frag = stashed(map);
        equal(frag.firstChild.firstChild.nodeValue, 'World', 'got back the right text');
    });
    test('Helper each inside a text section (attribute) (#8)', function (assert) {
        var template = stache('<div class="{{#each list}}{{.}} {{/}}"></div>');
        var vm = new DefineMap({
            list: new DefineList([
                'one',
                'two'
            ])
        });
        var frag = template(vm);
        var className = frag.firstChild.className;
        assert.equal(className, 'one two ');
        vm.list.push('three');
        className = frag.firstChild.className;
        assert.equal(className, 'one two three ');
    });
    test('Using #each on a DefineMap', function (assert) {
        var template = stache('{{#each obj}}{{%key}}{{.}}{{/each}}');
        var VM = DefineMap.extend({ seal: false }, {
            foo: 'string',
            bar: 'string'
        });
        var vm = new VM({
            foo: 'bar',
            bar: 'foo'
        });
        vm.set('baz', 'qux');
        var frag = template({ obj: vm });
        var first = frag.firstChild, second = first.nextSibling.nextSibling, third = second.nextSibling.nextSibling;
        assert.equal(first.nodeValue, 'foo');
        assert.equal(first.nextSibling.nodeValue, 'bar');
        assert.equal(second.nodeValue, 'bar');
        assert.equal(second.nextSibling.nodeValue, 'foo');
        assert.equal(third.nodeValue, 'baz');
        assert.equal(third.nextSibling.nodeValue, 'qux');
    });
    QUnit.test('{{%index}} and {{@index}} work with {{#key}} iteration', function () {
        var template = stache('<p>{{#iter}}<span>{{@index}}</span>{{/iter}}</p> ' + '<p>{{#iter}}<span>{{%index}}</span>{{/iter}}</p>');
        var div = document.createElement('div');
        var dom = template({
            iter: new DefineList([
                'hey',
                'there'
            ])
        });
        div.appendChild(dom);
        var span = div.getElementsByTagName('span');
        equal(span[0].innerHTML, '0', 'iteration for @index');
        equal(span[1].innerHTML, '1', 'iteration for %index');
        equal(span[2].innerHTML, '0', 'iteration for %index');
        equal(span[3].innerHTML, '1', 'iteration for %index');
    });
    QUnit.test('iterate a DefineMap with {{#each}} (#can-define/125)', function () {
        var template = stache('<p>{{#each iter}}<span>{{%key}} {{.}}</span>{{/each}}</p>');
        var div = document.createElement('div');
        var dom = template({
            iter: new DefineMap({
                first: 'justin',
                last: 'meyer'
            })
        });
        div.appendChild(dom);
        var span = div.getElementsByTagName('span');
        equal(span[0].innerHTML, 'first justin', 'first');
        equal(span[1].innerHTML, 'last meyer', 'last');
    });
});
/*can-util@3.3.2#js/deparam/deparam*/
define('can-util@3.3.2#js/deparam/deparam', function (require, exports, module) {
    var each = require('../each/each');
    var digitTest = /^\d+$/, keyBreaker = /([^\[\]]+)|(\[\])/g, paramTest = /([^?#]*)(#.*)?$/, prep = function (str) {
            return decodeURIComponent(str.replace(/\+/g, ' '));
        };
    module.exports = function (params) {
        var data = {}, pairs, lastPart;
        if (params && paramTest.test(params)) {
            pairs = params.split('&');
            each(pairs, function (pair) {
                var parts = pair.split('='), key = prep(parts.shift()), value = prep(parts.join('=')), current = data;
                if (key) {
                    parts = key.match(keyBreaker);
                    for (var j = 0, l = parts.length - 1; j < l; j++) {
                        if (!current[parts[j]]) {
                            current[parts[j]] = digitTest.test(parts[j + 1]) || parts[j + 1] === '[]' ? [] : {};
                        }
                        current = current[parts[j]];
                    }
                    lastPart = parts.pop();
                    if (lastPart === '[]') {
                        current.push(value);
                    } else {
                        current[lastPart] = value;
                    }
                }
            });
        }
        return data;
    };
});
/*can-util@3.3.2#js/diff-object/diff-object*/
define('can-util@3.3.2#js/diff-object/diff-object', function (require, exports, module) {
    var assign = require('../assign/assign');
    module.exports = exports = function (oldObject, newObject) {
        var oldObjectClone, patches = [];
        oldObjectClone = assign({}, oldObject);
        for (var newProp in newObject) {
            if (!oldObject || !oldObject.hasOwnProperty(newProp)) {
                patches.push({
                    property: newProp,
                    type: 'add',
                    value: newObject[newProp]
                });
            } else if (newObject[newProp] !== oldObject[newProp]) {
                patches.push({
                    property: newProp,
                    type: 'set',
                    value: newObject[newProp]
                });
            }
            delete oldObjectClone[newProp];
        }
        for (var oldProp in oldObjectClone) {
            patches.push({
                property: oldProp,
                type: 'remove'
            });
        }
        return patches;
    };
});
/*can-route@3.0.8#can-route*/
define('can-route@3.0.8#can-route', function (require, exports, module) {
    var canBatch = require('can-event/batch/batch');
    var canEvent = require('can-event');
    var Observation = require('can-observation');
    var compute = require('can-compute');
    var namespace = require('can-namespace');
    var deparam = require('can-util/js/deparam/deparam');
    var each = require('can-util/js/each/each');
    var string = require('can-util/js/string/string');
    var isFunction = require('can-util/js/is-function/is-function');
    var param = require('can-util/js/param/param');
    var isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');
    var deepAssign = require('can-util/js/deep-assign/deep-assign');
    var isWebWorker = require('can-util/js/is-web-worker/is-web-worker');
    var isBrowserWindow = require('can-util/js/is-browser-window/is-browser-window');
    var makeArray = require('can-util/js/make-array/make-array');
    var assign = require('can-util/js/assign/assign');
    var types = require('can-types');
    var dev = require('can-util/js/dev/dev');
    var diff = require('can-util/js/diff/diff');
    var diffObject = require('can-util/js/diff-object/diff-object');
    var curliesMatcher = /\{\s*([\w.]+)\s*\}/g;
    var colonMatcher = /\:([\w.]+)/g;
    var paramsMatcher = /^(?:&[^=]+=[^&]*)+/;
    var makeProps = function (props) {
        var tags = [];
        each(props, function (val, name) {
            tags.push((name === 'className' ? 'class' : name) + '="' + (name === 'href' ? val : string.esc(val)) + '"');
        });
        return tags.join(' ');
    };
    var matchesData = function (route, data) {
        var count = 0, i = 0, defaults = {};
        for (var name in route.defaults) {
            if (route.defaults[name] === data[name]) {
                defaults[name] = 1;
                count++;
            }
        }
        for (; i < route.names.length; i++) {
            if (!data.hasOwnProperty(route.names[i])) {
                return -1;
            }
            if (!defaults[route.names[i]]) {
                count++;
            }
        }
        return count;
    };
    var location = typeof window !== 'undefined' ? window.location : {};
    var wrapQuote = function (str) {
        return (str + '').replace(/([.?*+\^$\[\]\\(){}|\-])/g, '\\$1');
    };
    var attrHelper = function (prop, value) {
        if ('attr' in this) {
            return this.attr.apply(this, arguments);
        } else {
            if (arguments.length > 1) {
                this.set(prop, value);
                return this;
            } else if (typeof prop === 'object') {
                this.set(prop);
                return this;
            } else if (arguments.length === 1) {
                return this.get(prop);
            } else {
                return this.toObject();
            }
        }
    };
    var stringify = function (obj) {
        if (obj && typeof obj === 'object') {
            if (obj && typeof obj === 'object' && 'serialize' in obj) {
                obj = obj.serialize();
            } else {
                obj = isFunction(obj.slice) ? obj.slice() : assign({}, obj);
            }
            each(obj, function (val, prop) {
                obj[prop] = stringify(val);
            });
        } else if (obj !== undefined && obj !== null && isFunction(obj.toString)) {
            obj = obj.toString();
        }
        return obj;
    };
    var removeBackslash = function (str) {
        return str.replace(/\\/g, '');
    };
    var timer;
    var curParams;
    var lastHash;
    var changingData;
    var changedAttrs = [];
    var eventsObject = assign({}, canEvent);
    var canRoute = function (url, defaults) {
        var root = canRoute._call('root');
        if (root.lastIndexOf('/') === root.length - 1 && url.indexOf('/') === 0) {
            url = url.substr(1);
        }
        defaults = defaults || {};
        var names = [], res, test = '', matcher, lastIndex, next, querySeparator = canRoute._call('querySeparator'), matchSlashes = canRoute._call('matchSlashes');
        if (colonMatcher.test(url)) {
            matcher = colonMatcher;
        } else {
            matcher = curliesMatcher;
        }
        lastIndex = matcher.lastIndex = 0;
        while (res = matcher.exec(url)) {
            names.push(res[1]);
            test += removeBackslash(url.substring(lastIndex, matcher.lastIndex - res[0].length));
            next = '\\' + (removeBackslash(url.substr(matcher.lastIndex, 1)) || querySeparator + (matchSlashes ? '' : '|/'));
            test += '([^' + next + ']' + (defaults[res[1]] ? '*' : '+') + ')';
            lastIndex = matcher.lastIndex;
        }
        test += url.substr(lastIndex).replace('\\', '');
        canRoute.routes[url] = {
            test: new RegExp('^' + test + '($|' + wrapQuote(querySeparator) + ')'),
            route: url,
            names: names,
            defaults: defaults,
            length: url.split('/').length
        };
        return canRoute;
    };
    var oldProperties = null;
    var onRouteDataChange = function (ev, newProps, oldProps) {
        changingData = 1;
        if (!oldProperties) {
            oldProperties = oldProps;
        }
        clearTimeout(timer);
        timer = setTimeout(function () {
            var old = oldProperties;
            oldProperties = null;
            changingData = 0;
            var serialized = canRoute.data.serialize(), path = canRoute.param(serialized, true);
            canRoute._call('setURL', path, newProps, old);
            canEvent.dispatch.call(eventsObject, '__url', [
                path,
                lastHash
            ]);
            lastHash = path;
            changedAttrs = [];
        }, 10);
    };
    var stringCoercingMapDecorator = function (map) {
        var attrSuper = map.attr;
        map.attr = function (prop, val) {
            var serializable = this.define === undefined || this.define[prop] === undefined || !!this.define[prop].serialize, args;
            if (serializable) {
                args = stringify(Array.apply(null, arguments));
            } else {
                args = arguments;
            }
            return attrSuper.apply(this, args);
        };
        return map;
    };
    var recursiveClean = function (old, cur, data) {
        for (var attr in old) {
            if (cur[attr] === undefined) {
                if ('removeAttr' in data) {
                    data.removeAttr(attr);
                } else {
                    cur[attr] = undefined;
                }
            } else if (Object.prototype.toString.call(old[attr]) === '[object Object]') {
                recursiveClean(old[attr], cur[attr], attrHelper.call(data, attr));
            }
        }
    };
    var matchCheck = function (source, matcher) {
        for (var prop in source) {
            var s = source[prop], m = matcher[prop];
            if (s && m && typeof s === 'object' && typeof matcher === 'object') {
                return matchCheck(s, m);
            }
            if (s != m) {
                return false;
            }
        }
        return true;
    };
    var setState = canRoute.setState = function () {
        var hash = canRoute._call('matchingPartOfURL');
        var oldParams = curParams;
        curParams = canRoute.deparam(hash);
        var matched;
        if (!changingData || hash !== lastHash) {
            canRoute.batch.start();
            recursiveClean(oldParams, curParams, canRoute.data);
            matched = curParams.route;
            delete curParams.route;
            canRoute.matched(matched);
            canRoute.attr(curParams);
            curParams.route = matched;
            canEvent.dispatch.call(eventsObject, '__url', [
                hash,
                lastHash
            ]);
            canRoute.batch.stop();
        }
    };
    assign(canRoute, {
        param: function (data, _setRoute) {
            var route, matches = 0, matchCount, routeName = data.route, propCount = 0, cpy, res, after, matcher;
            delete data.route;
            each(data, function () {
                propCount++;
            });
            each(canRoute.routes, function (temp, name) {
                matchCount = matchesData(temp, data);
                if (matchCount > matches) {
                    route = temp;
                    matches = matchCount;
                }
                if (matchCount >= propCount) {
                    return false;
                }
            });
            if (canRoute.routes[routeName] && matchesData(canRoute.routes[routeName], data) === matches) {
                route = canRoute.routes[routeName];
            }
            if (route) {
                cpy = assign({}, data);
                matcher = colonMatcher.test(route.route) ? colonMatcher : curliesMatcher;
                res = route.route.replace(matcher, function (whole, name) {
                    delete cpy[name];
                    return data[name] === route.defaults[name] ? '' : encodeURIComponent(data[name]);
                }).replace('\\', '');
                each(route.defaults, function (val, name) {
                    if (cpy[name] === val) {
                        delete cpy[name];
                    }
                });
                after = param(cpy);
                if (_setRoute) {
                    canRoute.matched(route.route);
                }
                return res + (after ? canRoute._call('querySeparator') + after : '');
            }
            return isEmptyObject(data) ? '' : canRoute._call('querySeparator') + param(data);
        },
        deparam: function (url) {
            var root = canRoute._call('root');
            if (root.lastIndexOf('/') === root.length - 1 && url.indexOf('/') === 0) {
                url = url.substr(1);
            }
            var route = { length: -1 }, querySeparator = canRoute._call('querySeparator'), paramsMatcher = canRoute._call('paramsMatcher');
            each(canRoute.routes, function (temp, name) {
                if (temp.test.test(url) && temp.length > route.length) {
                    route = temp;
                }
            });
            if (route.length > -1) {
                var parts = url.match(route.test), start = parts.shift(), remainder = url.substr(start.length - (parts[parts.length - 1] === querySeparator ? 1 : 0)), obj = remainder && paramsMatcher.test(remainder) ? deparam(remainder.slice(1)) : {};
                obj = deepAssign(true, {}, route.defaults, obj);
                each(parts, function (part, i) {
                    if (part && part !== querySeparator) {
                        obj[route.names[i]] = decodeURIComponent(part);
                    }
                });
                obj.route = route.route;
                return obj;
            }
            if (url.charAt(0) !== querySeparator) {
                url = querySeparator + url;
            }
            return paramsMatcher.test(url) ? deparam(url.slice(1)) : {};
        },
        map: function (data) {
            canRoute.data = data;
        },
        routes: {},
        ready: function (val) {
            if (val !== true) {
                canRoute._setup();
                if (isBrowserWindow() || isWebWorker()) {
                    canRoute.setState();
                }
            }
            return canRoute;
        },
        url: function (options, merge) {
            if (merge) {
                Observation.add(eventsObject, '__url');
                var baseOptions = canRoute.deparam(canRoute._call('matchingPartOfURL'));
                options = assign(assign({}, baseOptions), options);
            }
            return canRoute._call('root') + canRoute.param(options);
        },
        link: function (name, options, props, merge) {
            return '<a ' + makeProps(assign({ href: canRoute.url(options, merge) }, props)) + '>' + name + '</a>';
        },
        current: function (options, subsetMatch) {
            Observation.add(eventsObject, '__url');
            if (subsetMatch) {
                var baseOptions = canRoute.deparam(canRoute._call('matchingPartOfURL'));
                return matchCheck(options, baseOptions);
            } else {
                return this._call('matchingPartOfURL') === canRoute.param(options);
            }
        },
        bindings: {
            hashchange: {
                paramsMatcher: paramsMatcher,
                querySeparator: '&',
                matchSlashes: false,
                bind: function () {
                    canEvent.on.call(window, 'hashchange', setState);
                },
                unbind: function () {
                    canEvent.on.call(window, 'hashchange', setState);
                },
                matchingPartOfURL: function () {
                    var loc = canRoute.location || location;
                    return loc.href.split(/#!?/)[1] || '';
                },
                setURL: function (path) {
                    if (location.hash !== '#' + path) {
                        location.hash = '!' + path;
                    }
                    return path;
                },
                root: '#!'
            }
        },
        defaultBinding: 'hashchange',
        currentBinding: null,
        _setup: function () {
            if (!canRoute.currentBinding) {
                canRoute._call('bind');
                canRoute.serializedCompute.addEventListener('change', onRouteDataChange);
                canRoute.currentBinding = canRoute.defaultBinding;
            }
        },
        _teardown: function () {
            if (canRoute.currentBinding) {
                canRoute._call('unbind');
                canRoute.serializedCompute.removeEventListener('change', onRouteDataChange);
                canRoute.currentBinding = null;
            }
            clearTimeout(timer);
            changingData = 0;
        },
        _call: function () {
            var args = makeArray(arguments), prop = args.shift(), binding = canRoute.bindings[canRoute.currentBinding || canRoute.defaultBinding], method = binding[prop];
            if (method.apply) {
                return method.apply(binding, args);
            } else {
                return method;
            }
        },
        matched: compute()
    });
    each([
        'addEventListener',
        'removeEventListener',
        'bind',
        'unbind',
        'on',
        'off',
        'delegate',
        'undelegate',
        'removeAttr',
        'compute',
        '_get',
        '___get',
        'each'
    ], function (name) {
        canRoute[name] = function () {
            if (!canRoute.data[name]) {
                return;
            }
            return canRoute.data[name].apply(canRoute.data, arguments);
        };
    });
    var routeData;
    var setRouteData = function (data) {
        routeData = data;
        return routeData;
    };
    var serializedCompute;
    Object.defineProperty(canRoute, 'serializedCompute', {
        get: function () {
            if (!serializedCompute) {
                serializedCompute = compute(function () {
                    return canRoute.data.serialize();
                });
            }
            return serializedCompute;
        }
    });
    Object.defineProperty(canRoute, 'data', {
        get: function () {
            if (routeData) {
                return routeData;
            } else if (types.DefaultMap) {
                if (types.DefaultMap.prototype.toObject) {
                    var DefaultRouteMap = types.DefaultMap.extend({ seal: false }, { '*': 'stringOrObservable' });
                    return setRouteData(new DefaultRouteMap());
                } else {
                    return setRouteData(stringCoercingMapDecorator(new types.DefaultMap()));
                }
            } else {
                throw new Error('can.route.data accessed without being set');
            }
        },
        set: function (data) {
            if (types.isConstructor(data)) {
                data = new data();
            }
            if ('attr' in data) {
                setRouteData(stringCoercingMapDecorator(data));
            } else {
                setRouteData(data);
            }
        }
    });
    canRoute.attr = function () {
        return attrHelper.apply(canRoute.data, arguments);
    };
    canRoute.batch = canBatch;
    var oldIsCallableForValue = types.isCallableForValue;
    types.isCallableForValue = function (obj) {
        if (obj === canRoute) {
            return false;
        } else {
            return oldIsCallableForValue.call(this, obj);
        }
    };
    module.exports = namespace.route = canRoute;
});
/*can-route@3.0.8#test/mock-route-binding*/
define('can-route@3.0.8#test/mock-route-binding', function (require, exports, module) {
    var canRoute = require('can-route');
    var compute = require('can-compute');
    var routeCompute = compute('');
    canRoute.bindings.mock = {
        paramsMatcher: /^(?:&[^=]+=[^&]*)+/,
        querySeparator: '&',
        matchSlashes: false,
        bind: function () {
            routeCompute.bind('change', canRoute.setState);
        },
        unbind: function () {
            routeCompute.unbind('change', canRoute.setState);
        },
        matchingPartOfURL: function () {
            return routeCompute().split(/#!?/)[1] || '';
        },
        setURL: function (path) {
            if (path[0] !== '#') {
                routeCompute('#' + (path || ''));
            } else {
                routeCompute(path || '');
            }
            return path;
        },
        root: '#!'
    };
    var oldDefault;
    module.exports = {
        start: function () {
            oldDefault = canRoute.defaultBinding;
            canRoute._teardown();
            canRoute.currentBinding = null;
            canRoute.defaultBinding = 'mock';
            routeCompute('');
        },
        stop: function () {
            canRoute._teardown();
            canRoute.defaultBinding = oldDefault;
        },
        hash: routeCompute
    };
});
/*can-stache@3.0.20#helpers/route*/
define('can-stache@3.0.20#helpers/route', function (require, exports, module) {
    var helpers = require('./core');
    var route = require('can-route');
    var getLast = require('can-util/js/last/last');
    var stacheExpression = require('../src/expression');
    var each = require('can-util/js/each/each');
    var looksLikeOptions = helpers.looksLikeOptions;
    var calculateArgs = function () {
        var finalParams, finalMerge, optionsArg;
        each(arguments, function (arg) {
            if (typeof arg === 'boolean') {
                finalMerge = arg;
            } else if (arg && typeof arg === 'object') {
                if (!looksLikeOptions(arg)) {
                    finalParams = helpers.resolveHash(arg);
                } else {
                    optionsArg = arg;
                }
            }
        });
        if (!finalParams && optionsArg) {
            finalParams = helpers.resolveHash(optionsArg.hash);
        }
        return {
            finalParams: finalParams || {},
            finalMerge: finalMerge,
            optionsArg: optionsArg
        };
    };
    helpers.registerHelper('routeUrl', function () {
        var args = calculateArgs.apply(this, arguments);
        return route.url(args.finalParams, typeof args.finalMerge === 'boolean' ? args.finalMerge : undefined);
    });
    var routeCurrent = function () {
        var args = calculateArgs.apply(this, arguments);
        var result = route.current(args.finalParams, typeof args.finalMerge === 'boolean' ? args.finalMerge : undefined);
        if (args.optionsArg && !(args.optionsArg instanceof stacheExpression.Call)) {
            if (result) {
                return args.optionsArg.fn();
            } else {
                return args.optionsArg.inverse();
            }
        } else {
            return result;
        }
    };
    routeCurrent.callAsMethod = true;
    helpers.registerHelper('routeCurrent', routeCurrent);
});
/*can-stache@3.0.20#helpers/route-test*/
define('can-stache@3.0.20#helpers/route-test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var stache = require('can-stache');
    var route = require('can-route');
    var mockRoute = require('can-route/test/mock-route-binding');
    var CanMap = require('can-map');
    require('./route');
    QUnit.module('can-stache/helpers/route');
    QUnit.test('routeUrl and routeCurrent', function () {
        stop();
        mockRoute.start();
        var routeData = new CanMap({});
        route.map(routeData);
        route.ready();
        var template = stache('<a href="{{routeUrl page=\'recipe\' id=recipe.id}}">{{recipe.name}}</a>');
        var frag = template({
            recipe: new CanMap({
                id: 5,
                name: 'Cool recipe'
            })
        });
        QUnit.equal(frag.firstChild.getAttribute('href'), '#!&page=recipe&id=5', 'href set');
        template = stache('<a href="{{routeUrl(page=\'recipe\' id=recipe.id}}">{{recipe.name}}</a>');
        frag = template({
            recipe: new CanMap({
                id: 5,
                name: 'Cool recipe'
            })
        });
        QUnit.equal(frag.firstChild.getAttribute('href'), '#!&page=recipe&id=5', 'href set');
        template = stache('{{#routeCurrent(undefined)}}yes{{else}}no{{/routeCurrent}}');
        frag = template({});
        QUnit.equal(frag.firstChild.nodeValue, 'yes', 'route is current');
        template = stache('{{#routeCurrent()}}yes{{else}}no{{/routeCurrent}}');
        frag = template({});
        QUnit.equal(frag.firstChild.nodeValue, 'yes', 'route is current');
        route.attr({
            'foo': 'bar',
            page: 'recipes'
        });
        setTimeout(function () {
            template = stache('{{#routeCurrent()}}yes{{else}}no{{/routeCurrent}}');
            frag = template({});
            QUnit.equal(frag.firstChild.nodeValue, 'no', 'route is not current');
            template = stache('{{#routeCurrent(foo=\'bar\', true)}}yes{{else}}no{{/routeCurrent}}');
            frag = template({});
            QUnit.equal(frag.firstChild.nodeValue, 'yes', 'route is somewhat current');
            template = stache('{{#routeCurrent foo=\'bar\' true}}yes{{else}}no{{/routeCurrent}}');
            frag = template({});
            QUnit.equal(frag.firstChild.nodeValue, 'yes', 'route is somewhat current');
            template = stache('<a href="{{routeUrl page=\'recipes\' id=6 true}}"></a>');
            frag = template({});
            QUnit.equal(frag.firstChild.getAttribute('href'), '#!&foo=bar&page=recipes&id=6', 'merge works helper');
            template = stache('<a href="{{routeUrl(page=\'recipe\' id=5,true)}}"></a>');
            frag = template({});
            QUnit.equal(frag.firstChild.getAttribute('href'), '#!&foo=bar&page=recipe&id=5', 'merge works call expression');
            mockRoute.stop();
            start();
        }, 100);
    });
});
/*can-stache@3.0.20#test/stache-test*/
define('can-stache@3.0.20#test/stache-test', function (require, exports, module) {
    (function (global) {
        require('./expression-test');
        require('./stache-define-test');
        require('../helpers/route-test');
        var stache = require('can-stache');
        var QUnit = require('steal-qunit');
        var CanMap = require('can-map');
        var CanList = require('can-list');
        var canCompute = require('can-compute');
        var DefineMap = require('can-define/map/map');
        var viewCallbacks = require('can-view-callbacks');
        var Scope = require('can-view-scope');
        var parser = require('can-view-parser');
        var nodeLists = require('can-view-nodelist');
        var canBatch = require('can-event/batch/batch');
        var makeDocument = require('can-vdom/make-document/make-document');
        var viewCallbacks = require('can-view-callbacks');
        var getChildNodes = require('can-util/dom/child-nodes/child-nodes');
        var domData = require('can-util/dom/data/data');
        var domMutate = require('can-util/dom/mutate/mutate');
        var DOCUMENT = require('can-util/dom/document/document');
        var MUTATION_OBSERVER = require('can-util/dom/mutation-observer/mutation-observer');
        var canEach = require('can-util/js/each/each');
        var canDev = require('can-util/js/dev/dev');
        var string = require('can-util/js/string/string');
        var makeArray = require('can-util/js/make-array/make-array');
        var joinURIs = require('can-util/js/join-uris/join-uris');
        var getBaseURL = require('can-util/js/base-url/base-url');
        var browserDoc = DOCUMENT();
        var mutationObserver = MUTATION_OBSERVER();
        makeTest('can/view/stache dom', browserDoc);
        makeTest('can/view/stache vdom', makeDocument());
        function makeTest(name, doc, mutation) {
            var isNormalDOM = doc === window.document;
            var innerHTML = function (node) {
                return 'innerHTML' in node ? node.innerHTML : undefined;
            };
            var getValue = function (node) {
                if (node.nodeName.toLowerCase() === 'textarea') {
                    return innerHTML(node);
                } else {
                    return node.value;
                }
            };
            var empty = function (node) {
                var last = node.lastChild;
                while (last) {
                    node.removeChild(last);
                    last = node.lastChild;
                }
            };
            var getText = function (template, data, options) {
                    var div = doc.createElement('div');
                    div.appendChild(stache(template)(data, options));
                    return cleanHTMLTextForIE(innerHTML(div));
                }, getAttr = function (el, attrName) {
                    return attrName === 'class' ? el.className : el.getAttribute(attrName);
                }, cleanHTMLTextForIE = function (html) {
                    return html.replace(/ stache_0\.\d+="[^"]+"/g, '').replace(/<(\/?[-A-Za-z0-9_]+)/g, function (whole, tagName) {
                        return '<' + tagName.toLowerCase();
                    }).replace(/\r?\n/g, '');
                }, getTextFromFrag = function (node) {
                    var txt = '';
                    node = node.firstChild;
                    while (node) {
                        if (node.nodeType === 3) {
                            txt += node.nodeValue;
                        } else {
                            txt += getTextFromFrag(node);
                        }
                        node = node.nextSibling;
                    }
                    return txt;
                };
            var oldDoc;
            QUnit.module(name, {
                setup: function () {
                    if (doc === window.document) {
                        DOCUMENT(null);
                        MUTATION_OBSERVER(mutationObserver);
                    } else {
                        oldDoc = window.document;
                        DOCUMENT(doc);
                        MUTATION_OBSERVER(null);
                    }
                    this.fixture = doc.createElement('div');
                    doc.body.appendChild(this.fixture);
                    this.animals = [
                        'sloth',
                        'bear',
                        'monkey'
                    ];
                },
                teardown: function () {
                    doc.body.removeChild(this.fixture);
                    stop();
                    setTimeout(function () {
                        DOCUMENT(window.document);
                        MUTATION_OBSERVER(mutationObserver);
                        start();
                    }, 1);
                }
            });
            test('html to html', function () {
                var stashed = stache('<h1 class=\'foo\'><span>Hello World!</span></h1>');
                var frag = stashed();
                equal(innerHTML(frag.childNodes.item(0)).toLowerCase(), '<span>hello world!</span>', 'got back the right text');
            });
            test('basic replacement', function () {
                var stashed = stache('<h1 class=\'foo\'><span>Hello {{message}}!</span></h1>');
                var frag = stashed({ message: 'World' });
                equal(innerHTML(frag.firstChild).toLowerCase(), '<span>hello world!</span>', 'got back the right text');
            });
            test('a section helper', function () {
                stache.registerHelper('helper', function (options) {
                    return options.fn({ message: 'World' });
                });
                var stashed = stache('<h1 class=\'foo\'>{{#helper}}<span>Hello {{message}}!</span>{{/helper}}</h1>');
                var frag = stashed({});
                equal(frag.firstChild.firstChild.nodeName.toLowerCase(), 'span', 'got a span');
                equal(innerHTML(frag.firstChild.firstChild), 'Hello World!', 'got back the right text');
            });
            test('attributes sections', function () {
                var template = stache('<div {{attributes}}/>');
                var frag = template({ attributes: 'foo=\'bar\'' });
                equal(frag.firstChild.getAttribute('foo'), 'bar', 'set attribute');
                template = stache('<div {{#truthy}}foo=\'{{baz}}\'{{/truthy}}/>');
                frag = template({
                    truthy: true,
                    baz: 'bar'
                });
                equal(frag.firstChild.getAttribute('foo'), 'bar', 'set attribute');
                frag = template({
                    truthy: false,
                    baz: 'bar'
                });
                equal(frag.firstChild.getAttribute('foo'), null, 'attribute not set if not truthy');
            });
            test('boxes example', function () {
                var boxes = [], Box = CanMap.extend({
                        count: 0,
                        content: 0,
                        top: 0,
                        left: 0,
                        color: 0,
                        tick: function () {
                            var count = this.attr('count') + 1;
                            this.attr({
                                count: count,
                                left: Math.cos(count / 10) * 10,
                                top: Math.sin(count / 10) * 10,
                                color: count % 255,
                                content: count
                            });
                        }
                    });
                for (var i = 0; i < 1; i++) {
                    boxes.push(new Box({ number: i }));
                }
                var stashed = stache('<div class=\'box-view\'>' + '<div class=\'box\' style=\'top: {{top}}px; left: {{left}}px;\'>' + '</div>' + '</div>');
                var frag = stashed(boxes[0]);
                ok(/top: 0px/.test(frag.firstChild.firstChild.getAttribute('style')), '0px');
                boxes[0].tick();
                ok(!/top: 0px/.test(frag.firstChild.firstChild.getAttribute('style')), '!0px');
            });
            var override = {
                comments: {
                    'Standalone Without Newline': '!',
                    'Standalone Line Endings': '|\n|'
                },
                interpolation: {
                    'HTML Escaping': 'These characters should be HTML escaped: & " < >\n',
                    'Triple Mustache': 'These characters should not be HTML escaped: & " < >\n',
                    'Ampersand': 'These characters should not be HTML escaped: & " < >\n'
                },
                inverted: {
                    'Standalone Line Endings': '|\n\n|',
                    'Standalone Without Newline': '^\n/'
                },
                partials: {
                    'Standalone Line Endings': '|\n>\n|',
                    'Standalone Without Newline': '>\n  >\n>',
                    'Standalone Without Previous Line': '  >\n>\n>',
                    'Standalone Indentation': '\\\n |\n<\n->\n|\n\n/\n'
                },
                sections: {
                    'Standalone Line Endings': '|\n\n|',
                    'Standalone Without Newline': '#\n/'
                }
            };
            canEach(window.MUSTACHE_SPECS, function (specData) {
                var spec = specData.name;
                canEach(specData.data.tests, function (t) {
                    test('specs/' + spec + ' - ' + t.name + ': ' + t.desc, function () {
                        var expected = override[spec] && override[spec][t.name] || t.expected.replace(/&quot;/g, '"');
                        if (spec === 'partials' && t.name === 'Recursion') {
                            t.partials.node = t.partials.node.replace(/</g, '[').replace(/\}>/g, '}]');
                            expected = expected.replace(/</g, '[').replace(/>/g, ']');
                        } else if (spec === 'partials') {
                        }
                        if (t.partials) {
                            for (var name in t.partials) {
                                stache.registerPartial(name, t.partials[name]);
                            }
                        }
                        if (t.data.lambda && t.data.lambda.js) {
                            t.data.lambda = eval('(' + t.data.lambda.js + ')');
                        }
                        var res = stache(t.template)(t.data);
                        deepEqual(getTextFromFrag(res), expected);
                    });
                });
            });
            test('Tokens returning 0 where they should display the number', function () {
                var template = '<div id=\'zero\'>{{completed}}</div>';
                var frag = stache(template)({ completed: 0 });
                equal(frag.firstChild.firstChild.nodeValue, '0', 'zero shown');
            });
            test('Inverted section function returning numbers', function () {
                var template = '<div id=\'completed\'>{{^todos.completed}}hidden{{/todos.completed}}</div>';
                var obsvr = new CanMap({ named: false });
                var todos = {
                    completed: function () {
                        return obsvr.attr('named');
                    }
                };
                var frag = stache(template)({ todos: todos });
                deepEqual(frag.firstChild.firstChild.nodeValue, 'hidden', 'hidden shown');
                obsvr.attr('named', true);
                deepEqual(frag.firstChild.firstChild.nodeValue, '', 'hidden gone');
            });
            test('live-binding with escaping', function () {
                var template = '<span id=\'binder1\'>{{ name }}</span><span id=\'binder2\'>{{{name}}}</span>';
                var teacher = new CanMap({ name: '<strong>Mrs Peters</strong>' });
                var tpl = stache(template);
                var frag = tpl(teacher);
                deepEqual(innerHTML(frag.firstChild), '&lt;strong&gt;Mrs Peters&lt;/strong&gt;');
                deepEqual(innerHTML(frag.lastChild.firstChild), 'Mrs Peters');
                teacher.attr('name', '<i>Mr Scott</i>');
                deepEqual(innerHTML(frag.firstChild), '&lt;i&gt;Mr Scott&lt;/i&gt;');
                deepEqual(innerHTML(frag.lastChild.firstChild), 'Mr Scott');
            });
            test('truthy', function () {
                var t = {
                    template: '{{#name}}Do something, {{name}}!{{/name}}',
                    expected: 'Do something, Andy!',
                    data: { name: 'Andy' }
                };
                var expected = t.expected.replace(/&quot;/g, '&#34;').replace(/\r\n/g, '\n');
                deepEqual(getText(t.template, t.data), expected);
            });
            test('falsey', function () {
                var t = {
                    template: '{{^cannot}}Don\'t do it, {{name}}!{{/cannot}}',
                    expected: 'Don\'t do it, Andy!',
                    data: { name: 'Andy' }
                };
                var expected = t.expected.replace(/&quot;/g, '&#34;').replace(/\r\n/g, '\n');
                deepEqual(getText(t.template, t.data), expected);
            });
            test('Handlebars helpers', function () {
                stache.registerHelper('hello', function (options) {
                    return 'Should not hit this';
                });
                stache.registerHelper('there', function (options) {
                    return 'there';
                });
                stache.registerHelper('zero', function (options) {
                    return 0;
                });
                stache.registerHelper('bark', function (obj, str, number, options) {
                    var hash = options.hash || {};
                    return 'The ' + obj + ' barked at ' + str + ' ' + number + ' times, ' + 'then the ' + hash.obj + ' ' + hash.action + ' ' + hash.where + ' times' + (hash.loud === true ? ' loudly' : '') + '.';
                });
                var t = {
                    template: '{{hello}} {{there}}! {{bark name \'Austin and Andy\' 3 obj=name action=\'growled and snarled\' where=2 loud=true}} Then there were {{zero}} barks :(',
                    expected: 'Hello there! The dog barked at Austin and Andy 3 times, then the dog growled and snarled 2 times loudly. Then there were 0 barks :(',
                    data: {
                        name: 'dog',
                        hello: 'Hello'
                    }
                };
                var expected = t.expected.replace(/&quot;/g, '&#34;').replace(/\r\n/g, '\n');
                deepEqual(getText(t.template, t.data), expected);
            });
            test('Handlebars advanced helpers (from docs)', function () {
                stache.registerSimpleHelper('exercise', function (group, action, num, options) {
                    if (group && group.length > 0 && action && num > 0) {
                        return options.fn({
                            group: group,
                            action: action,
                            where: options.hash.where,
                            when: options.hash.when,
                            num: num
                        });
                    } else {
                        return options.inverse(this);
                    }
                });
                var t = {
                    template: '{{#exercise pets \'walked\' 3 where=\'around the block\' when=time}}' + 'Along with the {{#group}}{{.}}, {{/group}}' + 'we {{action}} {{where}} {{num}} times {{when}}.' + '{{else}}' + 'We were lazy today.' + '{{/exercise}}',
                    expected: 'Along with the cat, dog, parrot, we walked around the block 3 times this morning.',
                    expected2: 'We were lazy today.',
                    data: {
                        pets: [
                            'cat',
                            'dog',
                            'parrot'
                        ],
                        time: 'this morning'
                    }
                };
                var template = stache(t.template);
                var frag = template(t.data);
                var div = doc.createElement('div');
                div.appendChild(frag);
                equal(innerHTML(div), t.expected);
                equal(getText(t.template, {}), t.expected2);
            });
            test('Passing functions as data, then executing them', function () {
                var t = {
                    template: '{{#nested}}{{welcome name}}{{/nested}}',
                    expected: 'Welcome Andy!',
                    data: {
                        name: 'Andy',
                        nested: {
                            welcome: function (name) {
                                return 'Welcome ' + name + '!';
                            }
                        }
                    }
                };
                var expected = t.expected.replace(/&quot;/g, '&#34;').replace(/\r\n/g, '\n');
                deepEqual(getText(t.template, t.data), expected);
            });
            test('No arguments passed to helper', function () {
                var template = stache('{{noargHelper}}');
                stache.registerHelper('noargHelper', function () {
                    return 'foo';
                });
                var div1 = doc.createElement('div');
                var div2 = doc.createElement('div');
                div1.appendChild(template({}));
                div2.appendChild(template(new CanMap()));
                deepEqual(innerHTML(div1), 'foo');
                deepEqual(innerHTML(div2), 'foo');
            });
            test('String literals passed to helper should work (#1143)', 1, function () {
                stache.registerHelper('concatStrings', function (arg1, arg2) {
                    return arg1 + arg2;
                });
                var template = stache('{{concatStrings "==" "word"}}');
                var div = doc.createElement('div');
                div.appendChild(template({}));
                equal(innerHTML(div), '==word');
            });
            test('No arguments passed to helper with list', function () {
                var template = stache('{{#items}}{{noargHelper}}{{/items}}');
                var div = doc.createElement('div');
                div.appendChild(template({ items: new CanList([{ name: 'Brian' }]) }, {
                    noargHelper: function () {
                        return 'foo';
                    }
                }));
                deepEqual(innerHTML(div), 'foo');
            });
            if (isNormalDOM) {
                test('Partials and observes', function () {
                    var template;
                    var div = doc.createElement('div');
                    template = stache('<table><thead><tr>{{#data}}{{>list}}{{/data}}</tr></thead></table>');
                    var dom = template({
                        data: new CanMap({
                            list: [
                                'hi',
                                'there'
                            ]
                        })
                    }, { partials: { list: stache('{{#list}}<th>{{.}}</th>{{/list}}') } });
                    div.appendChild(dom);
                    var ths = div.getElementsByTagName('th');
                    equal(ths.length, 2, 'Got two table headings');
                    equal(innerHTML(ths[0]), 'hi', 'First column heading correct');
                    equal(innerHTML(ths[1]), 'there', 'Second column heading correct');
                });
            }
            test('Deeply nested partials', function () {
                var t = {
                    template: '{{#nest1}}{{#nest2}}{{>partial}}{{/nest2}}{{/nest1}}',
                    expected: 'Hello!',
                    partials: { partial: stache('{{#nest3}}{{name}}{{/nest3}}') },
                    data: { nest1: { nest2: { nest3: { name: 'Hello!' } } } }
                };
                deepEqual(getText(t.template, t.data, { partials: t.partials }), t.expected);
            });
            test('Partials correctly set context', function () {
                var t = {
                    template: '{{#users}}{{>partial}}{{/users}}',
                    expected: 'foo - bar',
                    partials: { partial: stache('{{ name }} - {{ company }}') },
                    data: {
                        users: [{ name: 'foo' }],
                        company: 'bar'
                    }
                };
                deepEqual(getText(t.template, t.data, { partials: t.partials }), t.expected);
            });
            test('Handlebars helper: if/else', function () {
                var expected;
                var t = {
                    template: '{{#if name}}{{name}}{{/if}}{{#if missing}} is missing!{{/if}}',
                    expected: 'Andy',
                    data: {
                        name: 'Andy',
                        missing: undefined
                    }
                };
                expected = t.expected.replace(/&quot;/g, '&#34;').replace(/\r\n/g, '\n');
                deepEqual(getText(t.template, t.data), expected);
                t.data.missing = null;
                expected = t.expected.replace(/&quot;/g, '&#34;').replace(/\r\n/g, '\n');
                deepEqual(getText(t.template, t.data), expected);
            });
            test('Handlebars helper: is/else (with \'eq\' alias)', function () {
                var expected;
                var t = {
                    template: '{{#eq ducks tenDucks "10"}}10 ducks{{else}}Not 10 ducks{{/eq}}',
                    expected: '10 ducks',
                    data: {
                        ducks: '10',
                        tenDucks: function () {
                            return '10';
                        }
                    },
                    liveData: new CanMap({
                        ducks: '10',
                        tenDucks: function () {
                            return '10';
                        }
                    })
                };
                expected = t.expected.replace(/&quot;/g, '&#34;').replace(/\r\n/g, '\n');
                deepEqual(getText(t.template, t.data), expected);
                deepEqual(getText(t.template, t.liveData), expected);
                t.data.ducks = 5;
                deepEqual(getText(t.template, t.data), 'Not 10 ducks');
            });
            test('Handlebars helper: unless', function () {
                var t = {
                    template: '{{#unless missing}}Andy is missing!{{/unless}}' + '{{#unless isCool}} But he wasn\'t cool anyways.{{/unless}}',
                    expected: 'Andy is missing! But he wasn\'t cool anyways.',
                    data: { name: 'Andy' },
                    liveData: new CanMap({
                        name: 'Andy',
                        isCool: canCompute(function () {
                            return t.liveData.attr('missing');
                        })
                    })
                };
                var expected = t.expected.replace(/&quot;/g, '&#34;').replace(/\r\n/g, '\n');
                deepEqual(getText(t.template, t.data), expected);
                var div = doc.createElement('div');
                div.appendChild(stache(t.template)(t.liveData));
                deepEqual(innerHTML(div), expected, '#unless condition false');
                t.liveData.attr('missing', true);
                deepEqual(innerHTML(div), '', '#unless condition true');
            });
            test('Handlebars helper: each', function () {
                var t = {
                    template: '{{#each names}}{{this}} {{/each}}',
                    expected: 'Andy Austin Justin ',
                    data: {
                        names: [
                            'Andy',
                            'Austin',
                            'Justin'
                        ]
                    },
                    data2: {
                        names: new CanList([
                            'Andy',
                            'Austin',
                            'Justin'
                        ])
                    }
                };
                var expected = t.expected.replace(/&quot;/g, '&#34;').replace(/\r\n/g, '\n');
                deepEqual(getText(t.template, t.data), expected);
                var div = doc.createElement('div');
                div.appendChild(stache(t.template)(t.data2));
                deepEqual(innerHTML(div), expected, 'Using Observe.List');
                t.data2.names.push('What');
            });
            test('Handlebars helper: with', function () {
                var t = {
                    template: '{{#with person}}{{name}}{{/with}}',
                    expected: 'Andy',
                    data: { person: { name: 'Andy' } }
                };
                var expected = t.expected.replace(/&quot;/g, '&#34;').replace(/\r\n/g, '\n');
                deepEqual(getText(t.template, t.data), expected);
            });
            test('render with double angle', function () {
                var text = '{{& replace_me }}{{{ replace_me_too }}}' + '<ul>{{#animals}}' + '<li>{{.}}</li>' + '{{/animals}}</ul>';
                var compiled = getText(text, { animals: this.animals });
                equal(compiled, '<ul><li>sloth</li><li>bear</li><li>monkey</li></ul>', 'works');
            });
            test('comments', function () {
                var text = '{{! replace_me }}' + '<ul>{{#animals}}' + '<li>{{.}}</li>' + '{{/animals}}</ul>';
                var compiled = getText(text, { animals: this.animals });
                equal(compiled, '<ul><li>sloth</li><li>bear</li><li>monkey</li></ul>');
            });
            test('multi line', function () {
                var text = 'a \n b \n c';
                equal(getTextFromFrag(stache(text)({})), text);
            });
            test('multi line elements', function () {
                var text = '<div\n class="{{myClass}}" />', result = stache(text)({ myClass: 'a' });
                equal(result.firstChild.className, 'a', 'class name is right');
            });
            test('escapedContent', function () {
                var text = '<span>{{ tags }}</span><label>&amp;</label><strong>{{ number }}</strong><input value=\'{{ quotes }}\'/>';
                var div = doc.createElement('div');
                div.appendChild(stache(text)({
                    tags: 'foo < bar < car > zar > poo',
                    quotes: 'I use \'quote\' fingers & &amp;ersands "a lot"',
                    number: 123
                }));
                equal(div.getElementsByTagName('span')[0].firstChild.nodeValue, 'foo < bar < car > zar > poo');
                equal(div.getElementsByTagName('strong')[0].firstChild.nodeValue, 123);
                equal(div.getElementsByTagName('input')[0].value, 'I use \'quote\' fingers & &amp;ersands "a lot"', 'attributes are always safe, and strings are kept as-is without additional escaping');
                equal(innerHTML(div.getElementsByTagName('label')[0]), '&amp;', 'text-based html entities work fine');
            });
            test('unescapedContent', function () {
                var text = '<span>{{{ tags }}}</span><div>{{{ tags }}}</div><input value=\'{{{ quotes }}}\'/>';
                var div = doc.createElement('div');
                div.appendChild(stache(text)({
                    tags: '<strong>foo</strong><strong>bar</strong>',
                    quotes: 'I use \'quote\' fingers "a lot"'
                }));
                equal(div.getElementsByTagName('span')[0].firstChild.nodeType, 1, '');
                equal(innerHTML(div.getElementsByTagName('div')[0]).toLowerCase(), '<strong>foo</strong><strong>bar</strong>');
                equal(innerHTML(div.getElementsByTagName('span')[0]).toLowerCase(), '<strong>foo</strong><strong>bar</strong>');
                equal(div.getElementsByTagName('input')[0].value, 'I use \'quote\' fingers "a lot"', 'escaped no matter what');
            });
            test('attribute single unescaped, html single unescaped', function () {
                var text = '<div id=\'me\' class=\'{{#task.completed}}complete{{/task.completed}}\'>{{ task.name }}</div>';
                var task = new CanMap({ name: 'dishes' });
                var div = doc.createElement('div');
                div.appendChild(stache(text)({ task: task }));
                equal(innerHTML(div.getElementsByTagName('div')[0]), 'dishes', 'html correctly dishes');
                equal(div.getElementsByTagName('div')[0].className, '', 'class empty');
                task.attr('name', 'lawn');
                equal(innerHTML(div.getElementsByTagName('div')[0]), 'lawn', 'html correctly lawn');
                equal(div.getElementsByTagName('div')[0].className, '', 'class empty');
                task.attr('completed', true);
                equal(div.getElementsByTagName('div')[0].className, 'complete', 'class changed to complete');
            });
            test('select live binding', function () {
                var text = '<select>{{ #todos }}<option>{{ name }}</option>{{ /todos }}</select>';
                var todos, div;
                todos = new CanList([{
                        id: 1,
                        name: 'Dishes'
                    }]);
                div = doc.createElement('div');
                div.appendChild(stache(text)({ todos: todos }));
                equal(div.getElementsByTagName('option').length, 1, '1 item in list');
                todos.push({
                    id: 2,
                    name: 'Laundry'
                });
                equal(div.getElementsByTagName('option').length, 2, '2 items in list');
                todos.splice(0, 2);
                equal(div.getElementsByTagName('option').length, 0, '0 items in list');
            });
            test('multiple hookups in a single attribute', function () {
                var text = '<div class=\'{{ obs.foo }}' + '{{ obs.bar }}{{ obs.baz }}{{ obs.nest.what }}\'></div>';
                var obs = new CanMap({
                    foo: 'a',
                    bar: 'b',
                    baz: 'c',
                    nest: new CanMap({ what: 'd' })
                });
                var div = doc.createElement('div');
                div.appendChild(stache(text)({ obs: obs }));
                var innerDiv = div.firstChild;
                equal(getAttr(innerDiv, 'class'), 'abcd', 'initial render');
                obs.attr('bar', 'e');
                equal(getAttr(innerDiv, 'class'), 'aecd', 'initial render');
                obs.attr('bar', 'f');
                equal(getAttr(innerDiv, 'class'), 'afcd', 'initial render');
                obs.nest.attr('what', 'g');
                equal(getAttr(innerDiv, 'class'), 'afcg', 'nested observe');
            });
            test('adding and removing multiple html content within a single element', function () {
                var text, obs;
                text = '<div>{{ obs.a }}{{ obs.b }}{{ obs.c }}</div>';
                obs = new CanMap({
                    a: 'a',
                    b: 'b',
                    c: 'c'
                });
                var div = doc.createElement('div');
                div.appendChild(stache(text)({ obs: obs }));
                equal(innerHTML(div.firstChild), 'abc', 'initial render');
                obs.attr({
                    a: '',
                    b: '',
                    c: ''
                });
                equal(innerHTML(div.firstChild), '', 'updated values');
                obs.attr({ c: 'c' });
                equal(innerHTML(div.firstChild), 'c', 'updated values');
            });
            test('live binding and removeAttr', function () {
                var text = '{{ #obs.show }}' + '<p {{ obs.attributes }} class="{{ obs.className }}"><span>{{ obs.message }}</span></p>' + '{{ /obs.show }}', obs = new CanMap({
                        show: true,
                        className: 'myMessage',
                        attributes: 'some="myText"',
                        message: 'Live long and prosper'
                    }), div = doc.createElement('div');
                div.appendChild(stache(text)({ obs: obs }));
                var p = div.getElementsByTagName('p')[0], span = p.getElementsByTagName('span')[0];
                equal(p.getAttribute('some'), 'myText', 'initial render attr');
                equal(getAttr(p, 'class'), 'myMessage', 'initial render class');
                equal(innerHTML(span), 'Live long and prosper', 'initial render innerHTML');
                obs.removeAttr('className');
                equal(getAttr(p, 'class'), '', 'class is undefined');
                obs.attr('className', 'newClass');
                equal(getAttr(p, 'class'), 'newClass', 'class updated');
                obs.removeAttr('attributes');
                equal(p.getAttribute('some'), null, 'attribute is undefined');
                obs.attr('attributes', 'some="newText"');
                equal(p.getAttribute('some'), 'newText', 'attribute updated');
                obs.removeAttr('message');
                equal(innerHTML(span), '', 'text node value is empty');
                obs.attr('message', 'Warp drive, Mr. Sulu');
                equal(innerHTML(span), 'Warp drive, Mr. Sulu', 'text node updated');
                obs.removeAttr('show');
                equal(innerHTML(div), '', 'value in block statement is undefined');
                obs.attr('show', true);
                p = div.getElementsByTagName('p')[0];
                span = p.getElementsByTagName('span')[0];
                equal(p.getAttribute('some'), 'newText', 'value in block statement updated attr');
                equal(getAttr(p, 'class'), 'newClass', 'value in block statement updated class');
                equal(innerHTML(span), 'Warp drive, Mr. Sulu', 'value in block statement updated innerHTML');
            });
            test('hookup within a tag', function () {
                var text = '<div {{ obs.foo }} ' + '{{ obs.baz }}>lorem ipsum</div>', obs = new CanMap({
                        foo: 'class="a"',
                        baz: 'some=\'property\''
                    }), compiled = stache(text)({ obs: obs });
                var div = doc.createElement('div');
                div.appendChild(compiled);
                var anchor = div.getElementsByTagName('div')[0];
                equal(getAttr(anchor, 'class'), 'a');
                equal(anchor.getAttribute('some'), 'property');
                obs.attr('foo', 'class="b"');
                equal(getAttr(anchor, 'class'), 'b');
                equal(anchor.getAttribute('some'), 'property');
                obs.attr('baz', 'some=\'new property\'');
                equal(getAttr(anchor, 'class'), 'b');
                equal(anchor.getAttribute('some'), 'new property');
                obs.attr('foo', 'class=""');
                obs.attr('baz', '');
                equal(getAttr(anchor, 'class'), '', 'anchor class blank');
                equal(anchor.getAttribute('some'), undefined, 'attribute "some" is undefined');
            });
            test('single escaped tag, removeAttr', function () {
                var text = '<div {{ obs.foo }}>lorem ipsum</div>', obs = new CanMap({ foo: 'data-bar="john doe\'s bar"' }), compiled = stache(text)({ obs: obs });
                var div = doc.createElement('div');
                div.appendChild(compiled);
                var anchor = div.getElementsByTagName('div')[0];
                equal(anchor.getAttribute('data-bar'), 'john doe\'s bar');
                obs.removeAttr('foo');
                equal(anchor.getAttribute('data-bar'), null);
                obs.attr('foo', 'data-bar="baz"');
                equal(anchor.getAttribute('data-bar'), 'baz');
            });
            test('html comments', function () {
                var text = '<!-- bind to changes in the todo list --> <div>{{obs.foo}}</div>';
                var obs = new CanMap({ foo: 'foo' });
                var compiled = stache(text)({ obs: obs });
                var div = doc.createElement('div');
                div.appendChild(compiled);
                equal(innerHTML(div.getElementsByTagName('div')[0]), 'foo', 'Element as expected');
            });
            test('hookup and live binding', function () {
                var text = '<div class=\'{{ task.completed }}\' {{ data \'task\' task }}>' + '{{ task.name }}' + '</div>', task = new CanMap({
                        completed: false,
                        className: 'someTask',
                        name: 'My Name'
                    }), compiled = stache(text)({ task: task }), div = doc.createElement('div');
                div.appendChild(compiled);
                var child = div.getElementsByTagName('div')[0];
                ok(child.className.indexOf('false') > -1, 'is incomplete');
                ok(!!domData.get.call(child, 'task'), 'has data');
                equal(innerHTML(child), 'My Name', 'has name');
                task.attr({
                    completed: true,
                    name: 'New Name'
                });
                ok(child.className.indexOf('true') !== -1, 'is complete');
                equal(innerHTML(child), 'New Name', 'has new name');
            });
            test('multiple curly braces in a block', function () {
                var text = '{{^obs.items}}' + '<li>No items</li>' + '{{/obs.items}}' + '{{#obs.items}}' + '<li>{{name}}</li>' + '{{/obs.items}}', obs = new CanMap({ items: [] }), compiled = stache(text)({ obs: obs });
                var ul = doc.createElement('ul');
                ul.appendChild(compiled);
                equal(innerHTML(ul.getElementsByTagName('li')[0]), 'No items', 'initial observable state');
                obs.attr('items', [{ name: 'foo' }]);
                equal(innerHTML(ul.getElementsByTagName('li')[0]), 'foo', 'updated observable');
            });
            test('unescape bindings change', function () {
                var l = new CanList([
                    { complete: true },
                    { complete: false },
                    { complete: true }
                ]);
                var completed = function () {
                    l.attr('length');
                    var num = 0;
                    l.each(function (item) {
                        if (item.attr('complete')) {
                            num++;
                        }
                    });
                    return num;
                };
                var text = '<div>{{ completed }}</div>', compiled = stache(text)({ completed: completed });
                var div = doc.createElement('div');
                div.appendChild(compiled);
                var child = div.getElementsByTagName('div')[0];
                equal(innerHTML(child), '2', 'at first there are 2 true bindings');
                var item = new CanMap({
                    complete: true,
                    id: 'THIS ONE'
                });
                l.push(item);
                equal(innerHTML(child), '3', 'now there are 3 complete');
                item.attr('complete', false);
                equal(innerHTML(child), '2', 'now there are 2 complete');
                l.pop();
                item.attr('complete', true);
                equal(innerHTML(child), '2', 'there are still 2 complete');
            });
            test('escape bindings change', function () {
                var l = new CanList([
                    { complete: true },
                    { complete: false },
                    { complete: true }
                ]);
                var completed = function () {
                    l.attr('length');
                    var num = 0;
                    l.each(function (item) {
                        if (item.attr('complete')) {
                            num++;
                        }
                    });
                    return num;
                };
                var text = '<div>{{{ completed }}}</div>', compiled = stache(text)({ completed: completed });
                var div = doc.createElement('div');
                div.appendChild(compiled);
                var child = div.getElementsByTagName('div')[0];
                equal(innerHTML(child), '2', 'at first there are 2 true bindings');
                var item = new CanMap({ complete: true });
                l.push(item);
                equal(innerHTML(child), '3', 'now there are 3 complete');
                item.attr('complete', false);
                equal(innerHTML(child), '2', 'now there are 2 complete');
            });
            test('tag bindings change', function () {
                var l = new CanList([
                    { complete: true },
                    { complete: false },
                    { complete: true }
                ]);
                var completed = function () {
                    l.attr('length');
                    var num = 0;
                    l.each(function (item) {
                        if (item.attr('complete')) {
                            num++;
                        }
                    });
                    return 'items=\'' + num + '\'';
                };
                var text = '<div {{{ completed }}}></div>', compiled = stache(text)({ completed: completed });
                var div = doc.createElement('div');
                div.appendChild(compiled);
                var child = div.getElementsByTagName('div')[0];
                equal(child.getAttribute('items'), '2', 'at first there are 2 true bindings');
                var item = new CanMap({ complete: true });
                l.push(item);
                equal(child.getAttribute('items'), '3', 'now there are 3 complete');
                item.attr('complete', false);
                equal(child.getAttribute('items'), '2', 'now there are 2 complete');
            });
            test('attribute value bindings change', function () {
                var l = new CanList([
                    { complete: true },
                    { complete: false },
                    { complete: true }
                ]);
                var completed = function () {
                    l.attr('length');
                    var num = 0;
                    l.each(function (item) {
                        if (item.attr('complete')) {
                            num++;
                        }
                    });
                    return num;
                };
                var text = '<div items="{{{ completed }}}"></div>', compiled = stache(text)({ completed: completed });
                var div = doc.createElement('div');
                div.appendChild(compiled);
                var child = div.getElementsByTagName('div')[0];
                equal(child.getAttribute('items'), '2', 'at first there are 2 true bindings');
                var item = new CanMap({ complete: true });
                l.push(item);
                equal(child.getAttribute('items'), '3', 'now there are 3 complete');
                item.attr('complete', false);
                equal(child.getAttribute('items'), '2', 'now there are 2 complete');
            });
            test('in tag toggling', function () {
                var text = '<div {{ obs.val }}></div>';
                var obs = new CanMap({ val: 'foo="bar"' });
                var compiled = stache(text)({ obs: obs });
                var div = doc.createElement('div');
                div.appendChild(compiled);
                obs.attr('val', 'bar=\'foo\'');
                obs.attr('val', 'foo="bar"');
                var d2 = div.getElementsByTagName('div')[0];
                equal(d2.getAttribute('foo'), 'bar', 'bar set');
                equal(d2.getAttribute('bar'), null, 'bar set');
            });
            test('nested properties', function () {
                var text = '<div>{{ obs.name.first }}</div>';
                var obs = new CanMap({ name: { first: 'Justin' } });
                var compiled = stache(text)({ obs: obs });
                var div = doc.createElement('div');
                div.appendChild(compiled);
                div = div.getElementsByTagName('div')[0];
                equal(innerHTML(div), 'Justin');
                obs.attr('name.first', 'Brian');
                equal(innerHTML(div), 'Brian');
            });
            test('tags without chidren or ending with /> do not change the state', function () {
                var text = '<table><tr><td/>{{{ obs.content }}}</tr></div>';
                var obs = new CanMap({ content: '<td>Justin</td>' });
                var compiled = stache(text)({ obs: obs });
                var div = doc.createElement('div');
                var html = compiled;
                div.appendChild(html);
                equal(div.getElementsByTagName('span').length, 0, 'there are no spans');
                equal(div.getElementsByTagName('td').length, 2, 'there are 2 td');
            });
            test('nested live bindings', function () {
                expect(0);
                var items = new CanList([{
                        title: 0,
                        is_done: false,
                        id: 0
                    }]);
                var div = doc.createElement('div');
                var template = stache('<form>{{#items}}{{^is_done}}<div id="{{title}}"></div>{{/is_done}}{{/items}}</form>');
                div.appendChild(template({ items: items }));
                items.push({
                    title: 1,
                    is_done: false,
                    id: 1
                });
                items[0].attr('is_done', true);
            });
            test('list nested in observe live bindings', function () {
                var template = stache('<ul>{{#data.items}}<li>{{name}}</li>{{/data.items}}</ul>');
                var data = new CanMap({
                    items: [
                        { name: 'Brian' },
                        { name: 'Fara' }
                    ]
                });
                var div = doc.createElement('div');
                div.appendChild(template({ data: data }));
                data.items.push(new CanMap({ name: 'Scott' }));
                ok(/Brian/.test(innerHTML(div)), 'added first name');
                ok(/Fara/.test(innerHTML(div)), 'added 2nd name');
                ok(/Scott/.test(innerHTML(div)), 'added name after push');
            });
            test('trailing text', function () {
                var template = stache('There are {{ length }} todos');
                var div = doc.createElement('div');
                div.appendChild(template(new CanList([
                    {},
                    {}
                ])));
                ok(/There are 2 todos/.test(innerHTML(div)), 'got all text');
            });
            if (isNormalDOM) {
                test('recursive views', function () {
                    var template = stache('<div class="template">' + '{{#items}}' + '<div class="loop">' + '{{#item.children}}' + '<div class="node">' + '{{>recursive}}' + '</div>' + '{{/item.children}}' + '{{^item.children}}' + '<div class="leaf">L</div>' + '{{/item.children}}' + '</div>' + '{{/items}}' + '</div>');
                    var data = new CanList([{
                            label: 'branch1',
                            children: [{
                                    id: 2,
                                    label: 'branch2'
                                }]
                        }]);
                    var div = doc.createElement('div');
                    var frag = template({ items: data }, { partials: { recursive: template } });
                    div.appendChild(frag);
                    ok(/class="?leaf"?/.test(innerHTML(div)), 'we have a leaf');
                });
            }
            test('live binding textarea', function () {
                var template = stache('<textarea>Before{{ obs.middle }}After</textarea>');
                var obs = new CanMap({ middle: 'yes' }), div = doc.createElement('div');
                div.appendChild(template({ obs: obs }));
                var textarea = div.firstChild;
                equal(getValue(textarea), 'BeforeyesAfter');
                obs.attr('middle', 'Middle');
                equal(getValue(textarea), 'BeforeMiddleAfter');
            });
            test('reading a property from a parent object when the current context is an observe', function () {
                var template = stache('{{#foos}}<span>{{bar}}</span>{{/foos}}');
                var data = {
                    foos: new CanList([
                        { name: 'hi' },
                        { name: 'bye' }
                    ]),
                    bar: 'Hello World'
                };
                var div = doc.createElement('div');
                var res = template(data);
                div.appendChild(res);
                var spans = div.getElementsByTagName('span');
                equal(spans.length, 2, 'Got two <span> elements');
                equal(innerHTML(spans[0]), 'Hello World', 'First span Hello World');
                equal(innerHTML(spans[1]), 'Hello World', 'Second span Hello World');
            });
            test('helper parameters don\'t convert functions', function () {
                stache.registerHelper('helperWithFn', function (fn) {
                    ok(typeof fn === 'function', 'Parameter is a function');
                    equal(fn(), 'Hit me!', 'Got the expected function');
                });
                var renderer = stache('{{helperWithFn test}}');
                renderer({
                    test: function () {
                        return 'Hit me!';
                    }
                });
            });
            test('computes as helper parameters don\'t get converted', function () {
                stache.registerHelper('computeTest', function (no) {
                    equal(no(), 5, 'Got computed calue');
                    ok(no.isComputed, 'no is still a compute');
                });
                var renderer = stache('{{computeTest test}}');
                renderer({ test: canCompute(5) });
            });
            test('computes are supported in default helpers', function () {
                var staches = {
                    'if': '{{#if test}}if{{else}}else{{/if}}',
                    'not_if': 'not_{{^if test}}not{{/if}}if',
                    'each': '{{#each test}}{{.}}{{/each}}',
                    'with': 'wit{{#with test}}<span>{{3}}</span>{{/with}}'
                };
                var template = stache('There are {{ length }} todos');
                var div = doc.createElement('div');
                div.appendChild(template(new CanList([
                    {},
                    {}
                ])));
                ok(/There are 2 todos/.test(innerHTML(div)), 'got all text');
                var renderer, result, data, actual, span;
                for (result in staches) {
                    renderer = stache(staches[result]);
                    data = [
                        'e',
                        'a',
                        'c',
                        'h'
                    ];
                    div = doc.createElement('div');
                    actual = renderer({ test: canCompute(data) });
                    div.appendChild(actual);
                    span = div.getElementsByTagName('span')[0];
                    if (span && span.firstChild) {
                        div.insertBefore(span.firstChild, span);
                        div.removeChild(span);
                    }
                    actual = innerHTML(div);
                    equal(actual, result, 'canCompute resolved for helper ' + result);
                }
                var inv_staches = {
                    'else': '{{#if test}}if{{else}}else{{/if}}',
                    'not_not_if': 'not_{{^if test}}not_{{/if}}if',
                    'not_each': 'not_{{#each test}}_{{/each}}each',
                    'not_with': 'not{{#with test}}_{{/with}}_with'
                };
                for (result in inv_staches) {
                    renderer = stache(inv_staches[result]);
                    data = null;
                    div = doc.createElement('div');
                    actual = renderer({ test: canCompute(data) });
                    div.appendChild(actual);
                    actual = innerHTML(div);
                    equal(actual, result, 'canCompute resolved for helper ' + result);
                }
            });
            test('multiple tbodies in table hookup', function () {
                var text = '<table>' + '{{#people}}' + '<tbody><tr><td>{{name}}</td></tr></tbody>' + '{{/people}}' + '</table>', people = new CanList([
                        { name: 'Steve' },
                        { name: 'Doug' }
                    ]), compiled = stache(text)({ people: people });
                equal(compiled.firstChild.getElementsByTagName('tbody').length, 2, 'two tbodies');
            });
            test('Observe with array attributes', function () {
                var renderer = stache('<ul>{{#todos}}<li>{{.}}</li>{{/todos}}</ul><div>{{message}}</div>');
                var div = doc.createElement('div');
                var data = new CanMap({
                    todos: [
                        'Line #1',
                        'Line #2',
                        'Line #3'
                    ],
                    message: 'Hello',
                    count: 2
                });
                div.appendChild(renderer(data));
                equal(innerHTML(div.getElementsByTagName('li')[1]), 'Line #2', 'Check initial array');
                equal(innerHTML(div.getElementsByTagName('div')[0]), 'Hello', 'Check initial message');
                data.attr('todos.1', 'Line #2 changed');
                data.attr('message', 'Hello again');
                equal(innerHTML(div.getElementsByTagName('li')[1]), 'Line #2 changed', 'Check updated array');
                equal(innerHTML(div.getElementsByTagName('div')[0]), 'Hello again', 'Check updated message');
            });
            test('Observe list returned from the function', function () {
                var renderer = stache('<ul>{{#todos}}<li>{{.}}</li>{{/todos}}</ul>');
                var div = doc.createElement('div');
                var todos = new CanList();
                var data = {
                    todos: function () {
                        return todos;
                    }
                };
                div.appendChild(renderer(data));
                todos.push('Todo #1');
                equal(div.getElementsByTagName('li').length, 1, 'Todo is successfuly created');
                equal(innerHTML(div.getElementsByTagName('li')[0]), 'Todo #1', 'Pushing to the list works');
            });
            test('Contexts within helpers not always resolved correctly', function () {
                stache.registerHelper('bad_context', function (context, options) {
                    return [
                        '<span>' + this.text + '</span> should not be ',
                        options.fn(context)
                    ];
                });
                var renderer = stache('{{#bad_context next_level}}<span>{{text}}</span><br/><span>{{other_text}}</span>{{/bad_context}}'), data = {
                        next_level: {
                            text: 'bar',
                            other_text: 'In the inner context'
                        },
                        text: 'foo'
                    }, div = doc.createElement('div');
                div.appendChild(renderer(data));
                equal(innerHTML(div.getElementsByTagName('span')[0]), 'foo', 'Incorrect context passed to helper');
                equal(innerHTML(div.getElementsByTagName('span')[1]), 'bar', 'Incorrect text in helper inner template');
                equal(innerHTML(div.getElementsByTagName('span')[2]), 'In the inner context', 'Incorrect other_text in helper inner template');
            });
            test('Contexts are not always passed to partials properly', function () {
                var inner = stache('{{#if other_first_level}}{{other_first_level}}{{else}}{{second_level}}{{/if}}');
                var renderer = stache('{{#first_level}}<span>{{> inner}}</span> should equal <span>{{other_first_level}}</span>{{/first_level}}'), data = {
                        first_level: { second_level: 'bar' },
                        other_first_level: 'foo'
                    }, div = doc.createElement('div');
                div.appendChild(renderer(data, { partials: { inner: inner } }));
                equal(innerHTML(div.getElementsByTagName('span')[0]), 'foo', 'Incorrect context passed to helper');
                equal(innerHTML(div.getElementsByTagName('span')[1]), 'foo', 'Incorrect text in helper inner template');
            });
            test('Functions and helpers should be passed the same context', function () {
                var textNodes = function (el, cb) {
                    var cur = el.firstChild;
                    while (cur) {
                        if (cur.nodeType === 3) {
                            cb(cur);
                        } else if (el.nodeType === 1) {
                            textNodes(cur, cb);
                        }
                        cur = cur.nextSibling;
                    }
                };
                stache.registerHelper('to_upper', function (fn, options) {
                    if (!fn.fn) {
                        return typeof fn === 'function' ? fn().toString().toUpperCase() : fn.toString().toUpperCase();
                    } else {
                        var frag = fn.fn(this);
                        textNodes(frag, function (el) {
                            el.nodeValue = el.nodeValue.toUpperCase();
                        });
                        return frag;
                    }
                });
                var renderer = stache(' "<span>{{#to_upper}}{{next_level.text}}{{/to_upper}}</span>"'), data = {
                        next_level: {
                            text: function () {
                                return this.other_text;
                            },
                            other_text: 'In the inner context'
                        }
                    }, div = doc.createElement('div');
                window.other_text = 'Window context';
                div.appendChild(renderer(data));
                equal(innerHTML(div.getElementsByTagName('span')[0]), data.next_level.other_text.toUpperCase(), 'correct context passed to helper');
            });
            test('Interpolated values when iterating through an Observe.List should still render when not surrounded by a DOM node', function () {
                var renderer = stache('{{ #todos }}{{ name }}{{ /todos }}'), renderer2 = stache('{{ #todos }}<span>{{ name }}</span>{{ /todos }}'), todos = [
                        {
                            id: 1,
                            name: 'Dishes'
                        },
                        {
                            id: 2,
                            name: 'Forks'
                        }
                    ], liveData = { todos: new CanList(todos) }, plainData = { todos: todos }, div = doc.createElement('div');
                div.appendChild(renderer2(plainData));
                equal(innerHTML(div.getElementsByTagName('span')[0]), 'Dishes', 'Array item rendered with DOM container');
                equal(innerHTML(div.getElementsByTagName('span')[1]), 'Forks', 'Array item rendered with DOM container');
                div.innerHTML = '';
                div.appendChild(renderer2(liveData));
                equal(innerHTML(div.getElementsByTagName('span')[0]), 'Dishes', 'List item rendered with DOM container');
                equal(innerHTML(div.getElementsByTagName('span')[1]), 'Forks', 'List item rendered with DOM container');
                div = doc.createElement('div');
                div.appendChild(renderer(plainData));
                equal(innerHTML(div), 'DishesForks', 'Array item rendered without DOM container');
                div = doc.createElement('div');
                div.appendChild(renderer(liveData));
                equal(innerHTML(div), 'DishesForks', 'List item rendered without DOM container');
                liveData.todos.push({
                    id: 3,
                    name: 'Knives'
                });
                equal(innerHTML(div), 'DishesForksKnives', 'New list item rendered without DOM container');
            });
            test('objects with a \'key\' or \'index\' property should work in helpers', function () {
                var renderer = stache('{{ #obj }}{{ show_name }}{{ /obj }}'), div = doc.createElement('div');
                div.appendChild(renderer({
                    obj: {
                        id: 2,
                        name: 'Forks',
                        key: 'bar'
                    }
                }, {
                    show_name: function () {
                        return this.name;
                    }
                }));
                equal(innerHTML(div), 'Forks', 'item name rendered');
                div = doc.createElement('div');
                div.appendChild(renderer({
                    obj: {
                        id: 2,
                        name: 'Forks',
                        index: 'bar'
                    }
                }, {
                    show_name: function () {
                        return this.name;
                    }
                }));
                equal(innerHTML(div), 'Forks', 'item name rendered');
            });
            test('2 way binding helpers', function () {
                var Value = function (el, value) {
                    this.updateElement = function (ev, newVal) {
                        el.value = newVal || '';
                    };
                    value.bind('change', this.updateElement);
                    el.onchange = function () {
                        value(el.value);
                    };
                    this.teardown = function () {
                        value.unbind('change', this.updateElement);
                        el.onchange = null;
                    };
                    el.value = value() || '';
                };
                var val;
                stache.registerHelper('myValue', function (value) {
                    return function (el) {
                        val = new Value(el, value);
                    };
                });
                var renderer = stache('<input {{myValue user.name}}/>');
                var div = doc.createElement('div'), u = new CanMap({ name: 'Justin' });
                div.appendChild(renderer({ user: u }));
                var input = div.getElementsByTagName('input')[0];
                equal(input.value, 'Justin', 'Name is set correctly');
                u.attr('name', 'Eli');
                equal(input.value, 'Eli', 'Changing observe updates value');
                input.value = 'Austin';
                input.onchange();
                equal(u.attr('name'), 'Austin', 'Name changed by input field');
                val.teardown();
                renderer = stache('<input {{myValue user.name}}/>');
                div = doc.createElement('div');
                u = new CanMap({});
                div.appendChild(renderer({ user: u }));
                input = div.getElementsByTagName('input')[0];
                equal(input.value, '', 'Name is set correctly');
                u.attr('name', 'Eli');
                equal(input.value, 'Eli', 'Changing observe updates value');
                input.value = 'Austin';
                input.onchange();
                equal(u.attr('name'), 'Austin', 'Name changed by input field');
                val.teardown();
                renderer = stache('<input {{myValue user.name}}/>');
                div = doc.createElement('div');
                u = new CanMap({ name: null });
                div.appendChild(renderer({ user: u }));
                input = div.getElementsByTagName('input')[0];
                equal(input.value, '', 'Name is set correctly with null');
                u.attr('name', 'Eli');
                equal(input.value, 'Eli', 'Changing observe updates value');
                input.value = 'Austin';
                input.onchange();
                equal(u.attr('name'), 'Austin', 'Name changed by input field');
                val.teardown();
            });
            test('can pass in partials', function () {
                var hello = stache('<p>Hello {{> name}}</p>');
                var fancyName = stache('<span class=\'fancy\'>{{name}}</span>');
                var result = hello({ name: 'World' }, { partials: { name: fancyName } });
                ok(/World/.test(innerHTML(result.firstChild)), 'Hello World worked');
            });
            test('can pass in helpers', function () {
                var helpers = stache('<p>Hello {{cap name}}</p>');
                var result = helpers({ name: 'world' }, {
                    helpers: {
                        cap: function (name) {
                            return string.capitalize(name);
                        }
                    }
                });
                ok(/World/.test(innerHTML(result.firstChild)), 'Hello World worked');
            });
            test('HTML comment with helper', function () {
                var text = [
                        '<ul>',
                        '{{#todos}}',
                        '<li {{data \'todo\'}}>',
                        '<!-- html comment #1 -->',
                        '{{name}}',
                        '<!-- html comment #2 -->',
                        '</li>',
                        '{{/todos}}',
                        '</ul>'
                    ], todos = new CanList([{
                            id: 1,
                            name: 'Dishes'
                        }]), compiled = stache(text.join('\n'))({ todos: todos }), div = doc.createElement('div'), li;
                var comments = function (el) {
                    var count = 0;
                    var cur = el.firstChild;
                    while (cur) {
                        if (cur.nodeType === 8) {
                            ++count;
                        }
                        cur = cur.nextSibling;
                    }
                    return count;
                };
                div.appendChild(compiled);
                li = div.getElementsByTagName('ul')[0].getElementsByTagName('li');
                equal(li.length, 1, '1 item in list');
                equal(comments(li[0]), 2, '2 comments in item #1');
                todos.push({
                    id: 2,
                    name: 'Laundry'
                });
                li = div.getElementsByTagName('ul')[0].getElementsByTagName('li');
                equal(li.length, 2, '2 items in list');
                equal(comments(li[0]), 2, '2 comments in item #1');
                equal(comments(li[1]), 2, '2 comments in item #2');
                todos.splice(0, 2);
                li = div.getElementsByTagName('ul')[0].getElementsByTagName('li');
                equal(li.length, 0, '0 items in list');
            });
            test('Empty strings in arrays within Observes that are iterated should return blank strings', function () {
                var data = new CanMap({
                        colors: [
                            '',
                            'red',
                            'green',
                            'blue'
                        ]
                    }), compiled = stache('<select>{{#colors}}<option>{{.}}</option>{{/colors}}</select>')(data), div = doc.createElement('div');
                div.appendChild(compiled);
                equal(innerHTML(div.getElementsByTagName('option')[0]), '', 'Blank string should return blank');
            });
            test('Null properties do not throw errors', function () {
                var renderer = stache('Foo bar {{#foo.bar}}exists{{/foo.bar}}{{^foo.bar}}does not exist{{/foo.bar}}'), div = doc.createElement('div'), div2 = doc.createElement('div'), frag, frag2;
                try {
                    frag = renderer(new CanMap({ foo: null }));
                } catch (e) {
                    ok(false, 'rendering with null threw an error');
                }
                frag2 = renderer(new CanMap({ foo: { bar: 'baz' } }));
                div.appendChild(frag);
                div2.appendChild(frag2);
                equal(innerHTML(div), 'Foo bar does not exist');
                equal(innerHTML(div2), 'Foo bar exists');
            });
            test('Data helper should set proper data instead of a context stack', function () {
                var partials = {
                    'nested_data': stache('<span id="has_data" {{data "attr"}}></span>'),
                    'nested_data2': stache('{{#this}}<span id="has_data" {{data "attr"}}></span>{{/this}}'),
                    'nested_data3': stache('{{#bar}}<span id="has_data" {{data "attr"}}></span>{{/bar}}')
                };
                var renderer = stache('{{#bar}}{{> nested_data}}{{/bar}}'), renderer2 = stache('{{#bar}}{{> nested_data2}}{{/bar}}'), renderer3 = stache('{{#bar}}{{> nested_data3}}{{/bar}}'), div = doc.createElement('div'), data = new CanMap({
                        foo: 'bar',
                        bar: new CanMap({})
                    }), span;
                div = doc.createElement('div');
                div.appendChild(renderer(data, { partials: partials }));
                span = div.getElementsByTagName('span')[0];
                strictEqual(domData.get.call(span, 'attr'), data.bar, 'Nested data 1 should have correct data');
                div = doc.createElement('div');
                div.appendChild(renderer2(data, { partials: partials }));
                span = div.getElementsByTagName('span')[0];
                strictEqual(domData.get.call(span, 'attr'), data.bar, 'Nested data 2 should have correct data');
                div = doc.createElement('div');
                div.appendChild(renderer3(data, { partials: partials }));
                span = div.getElementsByTagName('span')[0];
                strictEqual(domData.get.call(span, 'attr'), data.bar, 'Nested data 3 should have correct data');
            });
            test('Functions passed to default helpers should be evaluated', function () {
                var renderer = stache('{{#if hasDucks}}Ducks: {{ducks}}{{else}}No ducks!{{/if}}'), div = doc.createElement('div'), data = new CanMap({
                        ducks: '',
                        hasDucks: function () {
                            return this.attr('ducks').length > 0;
                        }
                    });
                var span;
                div.appendChild(renderer(data));
                span = div.getElementsByTagName('span')[0];
                equal(innerHTML(div), 'No ducks!', 'The function evaluated should evaluate false');
            });
            test('avoid global helpers', function () {
                var noglobals = stache('{{sometext person.name}}');
                var div = doc.createElement('div'), div2 = doc.createElement('div');
                var person = new CanMap({ name: 'Brian' });
                var result = noglobals({ person: person }, {
                    sometext: function (name) {
                        return 'Mr. ' + name();
                    }
                });
                var result2 = noglobals({ person: person }, {
                    sometext: function (name) {
                        return name() + ' rules';
                    }
                });
                div.appendChild(result);
                div2.appendChild(result2);
                person.attr('name', 'Ajax');
                equal(innerHTML(div), 'Mr. Ajax');
                equal(innerHTML(div2), 'Ajax rules');
            });
            test('Helpers always have priority (#258)', function () {
                stache.registerHelper('callMe', function (arg) {
                    return arg + ' called me!';
                });
                var t = {
                    template: '<div>{{callMe \'Tester\'}}</div>',
                    expected: '<div>Tester called me!</div>',
                    data: {
                        callMe: function (arg) {
                            return arg + ' hanging up!';
                        }
                    }
                };
                var expected = t.expected.replace(/&quot;/g, '&#34;').replace(/\r\n/g, '\n');
                deepEqual(getText(t.template, t.data), expected);
            });
            test('avoid global helpers', function () {
                var noglobals = stache('{{sometext person.name}}');
                var div = doc.createElement('div'), div2 = doc.createElement('div');
                var person = new CanMap({ name: 'Brian' });
                var result = noglobals({ person: person }, {
                    sometext: function (name) {
                        return 'Mr. ' + name();
                    }
                });
                var result2 = noglobals({ person: person }, {
                    sometext: function (name) {
                        return name() + ' rules';
                    }
                });
                div.appendChild(result);
                div2.appendChild(result2);
                person.attr('name', 'Ajax');
                equal(innerHTML(div), 'Mr. Ajax');
                equal(innerHTML(div2), 'Ajax rules');
            });
            test('Each does not redraw items', function () {
                var animals = new CanList([
                        'sloth',
                        'bear'
                    ]), renderer = stache('<div>my<b>favorite</b>animals:{{#each animals}}<label>Animal=</label> <span>{{this}}</span>{{/}}!</div>');
                var div = doc.createElement('div');
                var frag = renderer({ animals: animals });
                div.appendChild(frag);
                div.getElementsByTagName('label')[0].myexpando = 'EXPANDO-ED';
                equal(div.getElementsByTagName('label').length, 2, 'There are 2 labels');
                animals.push('turtle');
                equal(div.getElementsByTagName('label')[0].myexpando, 'EXPANDO-ED', 'same expando');
                equal(innerHTML(div.getElementsByTagName('span')[2]), 'turtle', 'turtle added');
            });
            test('Each works with the empty list', function () {
                var animals = new CanList([]), renderer = stache('<div>my<b>favorite</b>animals:{{#each animals}}<label>Animal=</label> <span>{{this}}</span>{{/}}!</div>');
                var div = doc.createElement('div');
                var frag = renderer({ animals: animals });
                div.appendChild(frag);
                animals.push('sloth', 'bear');
                equal(div.getElementsByTagName('label').length, 2, 'There are 2 labels');
            });
            test('each works within another branch', function () {
                var animals = new CanList(['sloth']), template = '<div>Animals:' + '{{#if animals.length}}~' + '{{#each animals}}' + '<span>{{.}}</span>' + '{{/each}}' + '{{else}}' + 'No animals' + '{{/if}}' + '!</div>';
                var renderer = stache(template);
                var div = doc.createElement('div');
                var frag = renderer({ animals: animals });
                div.appendChild(frag);
                equal(div.getElementsByTagName('span').length, 1, 'There is 1 sloth');
                animals.pop();
                equal(innerHTML(div.getElementsByTagName('div')[0]), 'Animals:No animals!');
            });
            test('a compute gets passed to a plugin', function () {
                stache.registerHelper('iamhungryforcomputes', function (value) {
                    ok(value.isComputed, 'value is a compute');
                    return function (el) {
                    };
                });
                var renderer = stache('<input {{iamhungryforcomputes userName}}/>');
                var div = doc.createElement('div'), u = new CanMap({ name: 'Justin' });
                var nameCompute = canCompute(function () {
                    return u.attr('name');
                });
                div.appendChild(renderer({ userName: nameCompute }));
            });
            test('Object references can escape periods for key names containing periods', function () {
                var template = stache('{{#foo.bar}}' + '{{some\\.key\\.name}} {{some\\.other\\.key.with\\.more}}' + '{{/foo.bar}}'), data = {
                        foo: {
                            bar: [{
                                    'some.key.name': 100,
                                    'some.other.key': { 'with.more': 'values' }
                                }]
                        }
                    };
                var div = doc.createElement('div');
                div.appendChild(template(data));
                equal(innerHTML(div), '100 values');
            });
            test('Computes should be resolved prior to accessing attributes', function () {
                var template = stache('{{list.length}}'), data = { list: canCompute(new CanList()) };
                var div = doc.createElement('div');
                div.appendChild(template(data));
                equal(innerHTML(div), '0');
            });
            test('Helpers can be passed . or this for the active context', function () {
                stache.registerHelper('rsvp', function (attendee, event) {
                    return attendee.name + ' is attending ' + event.name;
                });
                var template = stache('{{#attendee}}{{#events}}<div>{{rsvp attendee .}}</div>{{/events}}{{/#attendee}}'), data = {
                        attendee: { name: 'Justin' },
                        events: [
                            { name: 'Reception' },
                            { name: 'Wedding' }
                        ]
                    };
                var div = doc.createElement('div');
                div.appendChild(template(data));
                var children = div.getElementsByTagName('div');
                equal(innerHTML(children[0]), 'Justin is attending Reception');
                equal(innerHTML(children[1]), 'Justin is attending Wedding');
            });
            test('helpers only called once (#477)', function () {
                var callCount = 0;
                stache.registerHelper('foo', function (text) {
                    callCount++;
                    equal(callCount, 1, 'call count is only ever one');
                    return 'result';
                });
                var obs = new CanMap({ quux: false });
                var template = stache('Foo text is: {{#if quux}}{{foo \'bar\'}}{{/if}}');
                template(obs);
                obs.attr('quux', true);
            });
            test('helpers between tags (#469)', function () {
                stache.registerHelper('itemsHelper', function () {
                    return function (textNode) {
                        equal(textNode.nodeType, 3, 'right nodeType');
                    };
                });
                var template = stache('<ul>{{itemsHelper}}</ul>');
                template();
            });
            test('hiding image srcs (#157)', function () {
                var template = stache('<img {{#image}}src="{{.}}"{{/image}} alt="An image" />'), data = new CanMap({ image: null }), url = 'http://canjs.us/scripts/static/img/canjs_logo_yellow_small.png';
                var frag = template(data), img = frag.firstChild;
                equal(img.getAttribute('src'), null, 'there is no src');
                data.attr('image', url);
                notEqual(img.getAttribute('src'), null, 'Image should have src');
                equal(img.getAttribute('src'), url, 'images src is correct');
            });
            test('live binding in a truthy section', function () {
                var template = stache('<div {{#width}}width="{{.}}"{{/width}}></div>'), data = new CanMap({ width: '100' });
                var frag = template(data), img = frag.firstChild;
                equal(img.getAttribute('width'), '100', 'initial width is correct');
                data.attr('width', '300');
                equal(img.getAttribute('width'), '300', 'updated width is correct');
            });
            test('backtracks in mustache (#163)', function () {
                var template = stache('{{#grid.rows}}' + '{{#grid.cols}}' + '<div>{{columnData ../. .}}</div>' + '{{/grid.cols}}' + '{{/grid.rows}}');
                var grid = new CanMap({
                    rows: [
                        {
                            first: 'Justin',
                            last: 'Meyer'
                        },
                        {
                            first: 'Brian',
                            last: 'Moschel'
                        }
                    ],
                    cols: [
                        { prop: 'first' },
                        { prop: 'last' }
                    ]
                });
                var frag = template({ grid: grid }, {
                    columnData: function (row, col) {
                        return row().attr(col().attr('prop'));
                    }
                });
                var divs = getChildNodes(frag);
                equal(divs.length, 4, 'there are 4 divs');
                var vals = makeArray(divs).map(function (div) {
                    return innerHTML(div);
                });
                deepEqual(vals, [
                    'Justin',
                    'Meyer',
                    'Brian',
                    'Moschel'
                ], 'div values are the same');
            });
            test('support null and undefined as an argument', function () {
                var template = stache('{{aHelper null undefined}}');
                template({}, {
                    aHelper: function (arg1, arg2) {
                        ok(arg1 === null);
                        ok(arg2 === undefined);
                    }
                });
            });
            test('passing CanList to helper (#438)', function () {
                var renderer = stache('<ul><li {{helper438 observeList}}>observeList broken</li>' + '<li {{helper438 array}}>plain arrays work</li></ul>');
                stache.registerHelper('helper438', function (classnames) {
                    return function (el) {
                        empty(el);
                        el.appendChild(el.ownerDocument.createTextNode('Helper called'));
                    };
                });
                var frag = renderer({
                    observeList: new CanList([
                        { test: 'first' },
                        { test: 'second' }
                    ]),
                    array: [
                        { test: 'first' },
                        { test: 'second' }
                    ]
                });
                var div = doc.createElement('div');
                div.appendChild(frag);
                var ul = div.firstChild;
                equal(innerHTML(ul.childNodes.item(0)), 'Helper called', 'Helper called');
                equal(innerHTML(ul.childNodes.item(1)), 'Helper called', 'Helper called');
            });
            test('hiding image srcs (#494)', function () {
                var template = stache('<img src="{{image}}"/>'), data = new CanMap({ image: '' }), url = 'http://canjs.us/scripts/static/img/canjs_logo_yellow_small.png';
                var frag = template(data), img = frag.firstChild;
                equal(img.getAttribute('src'), null, 'there is no src');
                data.attr('image', url);
                notEqual(img.getAttribute('src'), '', 'Image should have src');
                equal(img.getAttribute('src'), url, 'images src is correct');
            });
            test('hiding image srcs with complex content (#494)', function () {
                var template = stache('<img src="{{#image}}http://{{domain}}/{{loc}}.png{{/image}}"/>'), data = new CanMap({}), imgData = {
                        domain: 'canjs.us',
                        loc: 'scripts/static/img/canjs_logo_yellow_small'
                    }, url = 'http://canjs.us/scripts/static/img/canjs_logo_yellow_small.png';
                var frag = template(data), img = frag.firstChild;
                equal(img.getAttribute('src'), null, 'there is no src');
                data.attr('image', imgData);
                notEqual(img.getAttribute('src'), '', 'Image should have src');
                equal(img.getAttribute('src'), url, 'images src is correct');
            });
            test('empty lists update', 2, function () {
                var template = stache('<p>{{#list}}{{.}}{{/list}}</p>');
                var map = new CanMap({ list: ['something'] });
                var frag = template(map);
                var div = doc.createElement('div');
                div.appendChild(frag);
                equal(innerHTML(div.childNodes.item(0)), 'something', 'initial list content set');
                map.attr('list', [
                    'one',
                    'two'
                ]);
                equal(innerHTML(div.childNodes.item(0)), 'onetwo', 'updated list content set');
            });
            test('attributes in truthy section', function () {
                var template = stache('<p {{#attribute}}data-test="{{attribute}}"{{/attribute}}></p>');
                var data1 = { attribute: 'test-value' };
                var frag1 = template(data1);
                var div1 = doc.createElement('div');
                div1.appendChild(frag1);
                equal(div1.childNodes.item(0).getAttribute('data-test'), 'test-value', 'hyphenated attribute value');
                var data2 = { attribute: 'test value' };
                var frag2 = template(data2);
                var div2 = doc.createElement('div');
                div2.appendChild(frag2);
                equal(div2.childNodes.item(0).getAttribute('data-test'), 'test value', 'whitespace in attribute value');
            });
            test('live bound attributes with no \'=\'', function () {
                var template = stache('<input type="radio" {{#selected}}checked{{/selected}}>');
                var data = new CanMap({ selected: false });
                var frag = template(data);
                var div = doc.createElement('div');
                div.appendChild(frag);
                data.attr('selected', true);
                equal(div.childNodes.item(0).checked, true, 'hyphenated attribute value');
                data.attr('selected', false);
                equal(div.childNodes.item(0).checked, false, 'hyphenated attribute value');
            });
            test('outputting array of attributes', function () {
                var template = stache('<p {{#attribute}}{{name}}="{{value}}"{{/attribute}}></p>');
                var data = {
                    attribute: [
                        {
                            'name': 'data-test1',
                            'value': 'value1'
                        },
                        {
                            'name': 'data-test2',
                            'value': 'value2'
                        },
                        {
                            'name': 'data-test3',
                            'value': 'value3'
                        }
                    ]
                };
                var frag = template(data);
                var div = doc.createElement('div');
                div.appendChild(frag);
                equal(div.childNodes.item(0).getAttribute('data-test1'), 'value1', 'first value');
                equal(div.childNodes.item(0).getAttribute('data-test2'), 'value2', 'second value');
                equal(div.childNodes.item(0).getAttribute('data-test3'), 'value3', 'third value');
            });
            test('incremental updating of #each within an if', function () {
                var template = stache('{{#if items.length}}<ul>{{#each items}}<li/>{{/each}}</ul>{{/if}}');
                var items = new CanList([
                    {},
                    {}
                ]);
                var div = doc.createElement('div');
                div.appendChild(template({ items: items }));
                var ul = div.getElementsByTagName('ul')[0];
                ul.setAttribute('original', 'yup');
                items.push({});
                ok(ul === div.getElementsByTagName('ul')[0], 'ul is still the same');
            });
            test('stache.safeString', function () {
                var text = 'Google', url = 'http://google.com/', templateEscape = stache('{{link "' + text + '" "' + url + '"}}'), templateUnescape = stache('{{{link "' + text + '" "' + url + '"}}}');
                stache.registerHelper('link', function (text, url) {
                    var link = '<a href="' + url + '">' + text + '</a>';
                    return stache.safeString(link);
                });
                var div = doc.createElement('div');
                var frag = templateEscape({});
                div.appendChild(frag);
                equal(getChildNodes(div).length, 1, 'rendered a DOM node');
                equal(div.childNodes.item(0).nodeName, 'A', 'rendered an anchor tag');
                equal(innerHTML(div.childNodes.item(0)), text, 'rendered the text properly');
                equal(div.childNodes.item(0).getAttribute('href'), url, 'rendered the href properly');
                div = doc.createElement('div');
                div.appendChild(templateUnescape({}));
                equal(getChildNodes(div).length, 1, 'rendered a DOM node');
                equal(div.childNodes.item(0).nodeName, 'A', 'rendered an anchor tag');
                equal(innerHTML(div.childNodes.item(0)), text, 'rendered the text properly');
                equal(div.childNodes.item(0).getAttribute('href'), url, 'rendered the href properly');
            });
            test('changing the list works with each', function () {
                var template = stache('<ul>{{#each list}}<li>.</li>{{/each}}</ul>');
                var map = new CanMap({ list: ['foo'] });
                var tpl = template(map).firstChild;
                equal(tpl.getElementsByTagName('li').length, 1, 'one li');
                map.attr('list', new CanList([
                    'bar',
                    'car'
                ]));
                equal(tpl.getElementsByTagName('li').length, 2, 'two lis');
            });
            test('nested properties binding (#525)', function () {
                var template = stache('<label>{{name.first}}</label>');
                var me = new CanMap();
                var label = template(me).firstChild;
                me.attr('name', { first: 'Justin' });
                equal(innerHTML(label), 'Justin', 'set name object');
                me.attr('name', { first: 'Brian' });
                equal(innerHTML(label), 'Brian', 'merged name object');
                me.removeAttr('name');
                me.attr({ name: { first: 'Payal' } });
                equal(innerHTML(label), 'Payal', 'works after parent removed');
            });
            test('Rendering indicies of an array with @index', function () {
                var template = stache('<ul>{{#each list}}<li>{{@index}} {{.}}</li>{{/each}}</ul>');
                var list = [
                    0,
                    1,
                    2,
                    3
                ];
                var lis = template({ list: list }).firstChild.getElementsByTagName('li');
                for (var i = 0; i < lis.length; i++) {
                    equal(innerHTML(lis[i]), i + ' ' + i, 'rendered index and value are correct');
                }
            });
            test('Rendering indicies of an array with @index + offset (#1078)', function () {
                var template = stache('<ul>{{#each list}}<li>{{@index 5}} {{.}}</li>{{/each}}</ul>');
                var list = [
                    0,
                    1,
                    2,
                    3
                ];
                var lis = template({ list: list }).firstChild.getElementsByTagName('li');
                for (var i = 0; i < lis.length; i++) {
                    equal(innerHTML(lis[i]), i + 5 + ' ' + i, 'rendered index and value are correct');
                }
            });
            test('Passing indices into helpers as values', function () {
                var template = stache('<ul>{{#each list}}<li>{{test @index}} {{.}}</li>{{/each}}</ul>');
                var list = [
                    0,
                    1,
                    2,
                    3
                ];
                var lis = template({ list: list }, {
                    test: function (index) {
                        return '' + index;
                    }
                }).firstChild.getElementsByTagName('li');
                for (var i = 0; i < lis.length; i++) {
                    equal(innerHTML(lis[i]), i + ' ' + i, 'rendered index and value are correct');
                }
            });
            test('Rendering live bound indicies with #each, @index and a simple CanList', function () {
                var list = new CanList([
                    'a',
                    'b',
                    'c'
                ]);
                var template = stache('<ul>{{#each list}}<li>{{@index}} {{.}}</li>{{/each}}</ul>');
                var tpl = template({ list: list }).firstChild;
                var lis = tpl.getElementsByTagName('li');
                equal(lis.length, 3, 'three lis');
                equal(innerHTML(lis[0]), '0 a', 'first index and value are correct');
                equal(innerHTML(lis[1]), '1 b', 'second index and value are correct');
                equal(innerHTML(lis[2]), '2 c', 'third index and value are correct');
                list.push('d', 'e');
                lis = tpl.getElementsByTagName('li');
                equal(lis.length, 5, 'five lis');
                equal(innerHTML(lis[3]), '3 d', 'fourth index and value are correct');
                equal(innerHTML(lis[4]), '4 e', 'fifth index and value are correct');
                list.splice(0, 2, 'z', 'y');
                lis = tpl.getElementsByTagName('li');
                equal(lis.length, 5, 'five lis');
                equal(innerHTML(lis[0]), '0 z', 'first item updated');
                equal(innerHTML(lis[1]), '1 y', 'second item updated');
                equal(innerHTML(lis[2]), '2 c', 'third item the same');
                equal(innerHTML(lis[3]), '3 d', 'fourth item the same');
                equal(innerHTML(lis[4]), '4 e', 'fifth item the same');
                list.splice(2, 2);
                lis = tpl.getElementsByTagName('li');
                equal(lis.length, 3, 'three lis');
                equal(innerHTML(lis[0]), '0 z', 'first item the same');
                equal(innerHTML(lis[1]), '1 y', 'second item the same');
                equal(innerHTML(lis[2]), '2 e', 'fifth item now the 3rd item');
            });
            test('Rendering keys of an object with #each and @key', function () {
                var template = stache('<ul>{{#each obj}}<li>{{@key}} {{.}}</li>{{/each}}</ul>');
                var obj = {
                    foo: 'string',
                    bar: 1,
                    baz: false
                };
                var lis = template({ obj: obj }).firstChild.getElementsByTagName('li');
                equal(lis.length, 3, 'three lis');
                equal(innerHTML(lis[0]), 'foo string', 'first key value pair rendered');
                equal(innerHTML(lis[1]), 'bar 1', 'second key value pair rendered');
                equal(innerHTML(lis[2]), 'baz false', 'third key value pair rendered');
            });
            test('Live bound iteration of keys of a CanMap with #each and @key', function () {
                var template = stache('<ul>{{#each map}}<li>{{@key}} {{.}}</li>{{/each}}</ul>');
                var map = new CanMap({
                    foo: 'string',
                    bar: 1,
                    baz: false
                });
                var tpl = template({ map: map });
                var lis = tpl.firstChild.getElementsByTagName('li');
                equal(lis.length, 3, 'three lis');
                equal(innerHTML(lis[0]), 'foo string', 'first key value pair rendered');
                equal(innerHTML(lis[1]), 'bar 1', 'second key value pair rendered');
                equal(innerHTML(lis[2]), 'baz false', 'third key value pair rendered');
                map.attr('qux', true);
                lis = tpl.firstChild.getElementsByTagName('li');
                equal(lis.length, 4, 'four lis');
                equal(innerHTML(lis[3]), 'qux true', 'fourth key value pair rendered');
                map.removeAttr('foo');
                lis = tpl.firstChild.getElementsByTagName('li');
                equal(lis.length, 3, 'three lis');
                equal(innerHTML(lis[0]), 'bar 1', 'new first key value pair rendered');
                equal(innerHTML(lis[1]), 'baz false', 'new second key value pair rendered');
                equal(innerHTML(lis[2]), 'qux true', 'new third key value pair rendered');
            });
            test('Make sure data passed into template does not call helper by mistake', function () {
                var template = stache('<h1>{{text}}</h1>');
                var data = { text: 'with' };
                var h1 = template(data).firstChild;
                equal(innerHTML(h1), 'with');
            });
            test('no memory leaks with #each (#545)', function () {
                var tmp = stache('<ul id=\'ul-remove\'>{{#each children}}<li></li>{{/each}}</ul>');
                var data = new CanMap({
                    children: [
                        { name: 'A1' },
                        { name: 'A2' },
                        { name: 'A3' }
                    ]
                });
                var div = doc.createElement('div');
                this.fixture.appendChild(div);
                div.id = 'div-remove';
                domMutate.appendChild.call(div, tmp(data));
                stop();
                setTimeout(function () {
                    domMutate.removeChild.call(div, div.firstChild);
                    setTimeout(function () {
                        equal(data._bindings, 0, 'there are no bindings');
                        start();
                    }, 30);
                }, 10);
            });
            test('each directly within live html section', function () {
                var tmp = stache('<ul>{{#if showing}}' + '{{#each items}}<li>item</li>{{/items}}' + '{{/if}}</ul>');
                var items = new CanList([
                    1,
                    2,
                    3
                ]);
                var showing = canCompute(true);
                var frag = tmp({
                    showing: showing,
                    items: items
                });
                showing(false);
                items.pop();
                showing(true);
                items.push('a');
                equal(frag.firstChild.getElementsByTagName('li').length, 3, 'there are 3 elements');
            });
            test('mustache loops with 0 (#568)', function () {
                var tmp = stache('<ul>{{#array}}<li>{{.}}</li>{{/array}}');
                var data = {
                    array: [
                        0,
                        null
                    ]
                };
                var frag = tmp(data);
                equal(innerHTML(frag.firstChild.getElementsByTagName('li')[0]), '0');
                equal(innerHTML(frag.firstChild.getElementsByTagName('li')[1]), '');
            });
            test('@index is correctly calculated when there are identical elements in the array', function () {
                var data = new CanList([
                    'foo',
                    'bar',
                    'baz',
                    'qux',
                    'foo'
                ]);
                var tmp = stache('{{#each data}}{{@index}} {{/each}}');
                var div = doc.createElement('div');
                var frag = tmp({ data: data });
                div.appendChild(frag);
                equal(innerHTML(div), '0 1 2 3 4 ');
            });
            test('if helper within className (#592)', function () {
                var tmp = stache('<div class="fails {{#state}}animate-{{.}}{{/state}}"></div>');
                var data = new CanMap({ state: 'ready' });
                var frag = tmp(data);
                equal(frag.firstChild.className, 'fails animate-ready');
                tmp = stache('<div class="fails {{#if state}}animate-{{state}}{{/if}}"></div>');
                data = new CanMap({ state: 'ready' });
                tmp(data);
                equal(frag.firstChild.className, 'fails animate-ready');
            });
            test('html comments must not break mustache scanner', function () {
                canEach([
                    'text<!-- comment -->',
                    'text<!-- comment-->',
                    'text<!--comment -->',
                    'text<!--comment-->'
                ], function (content) {
                    var div = doc.createElement('div');
                    div.appendChild(stache(content)());
                    equal(innerHTML(div), content, 'Content did not change: "' + content + '"');
                });
            });
            test('Rendering live bound indicies with #each, @index and a simple CanList when remove first item (#613)', function () {
                var list = new CanList([
                    'a',
                    'b',
                    'c'
                ]);
                var template = stache('<ul>{{#each list}}<li>{{@index}} {{.}}</li>{{/each}}</ul>');
                var tpl = template({ list: list });
                list.shift();
                var lis = tpl.firstChild.getElementsByTagName('li');
                equal(lis.length, 2, 'two lis');
                equal(innerHTML(lis[0]), '0 b', 'second item now the 1st item');
                equal(innerHTML(lis[1]), '1 c', 'third item now the 2nd item');
            });
            test('stache.safestring works on live binding (#606)', function () {
                var num = canCompute(1);
                stache.registerHelper('safeHelper', function () {
                    return stache.safeString('<p>' + num() + '</p>');
                });
                var template = stache('<div>{{safeHelper}}</div>');
                var frag = template();
                equal(frag.firstChild.firstChild.nodeName.toLowerCase(), 'p', 'got a p element');
            });
            test('directly nested subitems and each (#605)', function () {
                var template = stache('<div>' + '{{#item}}' + '<p>This is the item:</p>' + '{{#each subitems}}' + '<label>' + 'item' + '</label>' + '{{/each}}' + '{{/item}}' + '</div>');
                var data = new CanMap({ item: { subitems: ['first'] } });
                var frag = template(data), div = frag.firstChild, labels = div.getElementsByTagName('label');
                equal(labels.length, 1, 'initially one label');
                data.attr('item.subitems').push('second');
                labels = div.getElementsByTagName('label');
                equal(labels.length, 2, 'after pushing two label');
                data.removeAttr('item');
                labels = div.getElementsByTagName('label');
                equal(labels.length, 0, 'after removing item no label');
            });
            test('directly nested live sections unbind without needing the element to be removed', function () {
                var template = stache('<div>' + '{{#items}}' + '<p>first</p>' + '{{#visible}}<label>foo</label>{{/visible}}' + '<p>second</p>' + '{{/items}}' + '</div>');
                var data = new CanMap({ items: [{ visible: true }] });
                var bindings = 0;
                function addEventListener(eventType) {
                    bindings++;
                    return CanMap.prototype.addEventListener.apply(this, arguments);
                }
                function removeEventListener(eventType) {
                    CanMap.prototype.removeEventListener.apply(this, arguments);
                    bindings--;
                    if (eventType === 'visible') {
                        ok(true, 'unbound visible');
                    }
                    if (bindings === 0) {
                        start();
                        ok(true, 'unbound visible');
                    }
                }
                data.attr('items.0').addEventListener = addEventListener;
                data.attr('items.0').removeEventListener = removeEventListener;
                template(data);
                data.attr('items', [{ visible: true }]);
                stop();
            });
            test('direct live section', function () {
                var template = stache('{{#if visible}}<label/>{{/if}}');
                var data = new CanMap({ visible: true });
                var div = doc.createElement('div');
                div.appendChild(template(data));
                equal(div.getElementsByTagName('label').length, 1, 'there are 1 items');
                data.attr('visible', false);
                equal(div.getElementsByTagName('label').length, 0, 'there are 0 items');
            });
            test('Rendering keys of an object with #each and @key in a Component', function () {
                var template = stache('<ul>' + '{{#each data}}' + '<li>{{@key}} : {{.}}</li>' + '{{/data}}' + '</ul>');
                var map = new CanMap({
                    data: {
                        some: 'test',
                        things: false,
                        other: 'things'
                    }
                });
                var frag = template(map);
                var lis = frag.firstChild.getElementsByTagName('li');
                equal(lis.length, 3, 'there are 3 properties of map\'s data property');
                equal(innerHTML(lis[0]), 'some : test');
            });
            test('{{each}} does not error with undefined list (#602)', function () {
                var text = '<div>{{#each data}}{{name}}{{/each}}</div>';
                equal(getText(text, {}), '<div></div>', 'Empty text rendered');
                equal(getText(text, { data: false }), '<div></div>', 'Empty text rendered');
                equal(getText(text, { data: null }), '<div></div>', 'Empty text rendered');
                equal(getText(text, { data: [{ name: 'David' }] }), '<div>David</div>', 'Expected name rendered');
            });
            test('{{#each}} helper works reliably with nested sections (#604)', function () {
                var renderer = stache('{{#if first}}<ul>{{#each list}}<li>{{name}}</li>{{/each}}</ul>' + '{{else}}<ul>{{#each list2}}<li>{{name}}</li>{{/each}}</ul>{{/if}}');
                var data = new CanMap({
                    first: true,
                    list: [
                        { name: 'Something' },
                        { name: 'Else' }
                    ],
                    list2: [
                        { name: 'Foo' },
                        { name: 'Bar' }
                    ]
                });
                var div = doc.createElement('div');
                var frag = renderer(data);
                div.appendChild(frag);
                var lis = div.getElementsByTagName('li');
                deepEqual(makeArray(lis).map(function (li) {
                    return innerHTML(li);
                }), [
                    'Something',
                    'Else'
                ], 'Expected HTML with first set');
                data.attr('first', false);
                lis = div.getElementsByTagName('li');
                deepEqual(makeArray(lis).map(function (li) {
                    return innerHTML(li);
                }), [
                    'Foo',
                    'Bar'
                ], 'Expected HTML with first false set');
            });
            test('Block bodies are properly escaped inside attributes', function () {
                var html = '<div title=\'{{#test}}{{.}}{{{.}}}{{/test}}\'></div>', div = doc.createElement('div'), title = 'Alpha&Beta';
                var frag = stache(html)(new CanMap({ test: title }));
                div.appendChild(frag);
                equal(div.firstChild.getAttribute('title'), title + title);
            });
            test('Constructor static properties are accessible (#634)', function () {
                var Foo = CanMap.extend('Foo', { static_prop: 'baz' }, { proto_prop: 'thud' });
                var template = '                  Straight access: <br/>                       <span>{{own_prop}}</span><br/>                       <span>{{constructor.static_prop}}</span><br/>                       <span>{{constructor.proto_prop}}</span><br/>                       <span>{{proto_prop}}</span><br/>                   Helper argument: <br/>                       <span>{{print_prop own_prop}}</span><br/>                       <span>{{print_prop constructor.static_prop}}</span><br/>                       <span>{{print_prop constructor.proto_prop}}</span><br/>                       <span>{{print_prop proto_prop}}</span><br/>                   Helper hash argument: <br/>                       <span>{{print_hash prop=own_prop}}</span><br/>                       <span>{{print_hash prop=constructor.static_prop}}</span><br/>                       <span>{{print_hash prop=constructor.proto_prop}}</span><br/>                       <span>{{print_hash prop=proto_prop}}</span><br/>', renderer = stache(template), data = new Foo({ own_prop: 'quux' }), div = doc.createElement('div');
                div.appendChild(renderer(data, {
                    print_prop: function (arg) {
                        return arg && arg.isComputed ? arg() : arg;
                    },
                    print_hash: function () {
                        var ret = [];
                        canEach(arguments[arguments.length - 1].hash, function (arg, key) {
                            while (arg && arg.isComputed) {
                                arg = arg();
                            }
                            ret.push([
                                key,
                                arg
                            ].join('='));
                        });
                        return ret.join(' ');
                    }
                }));
                var spans = div.getElementsByTagName('span'), i = 0;
                equal(innerHTML(spans[i++]), 'quux', 'Expected "quux"');
                equal(innerHTML(spans[i++]), 'baz', 'Expected "baz"');
                equal(innerHTML(spans[i++]), '', 'Expected ""');
                equal(innerHTML(spans[i++]), 'thud', 'Expected "thud"');
                equal(innerHTML(spans[i++]), 'quux', 'Expected "quux"');
                equal(innerHTML(spans[i++]), 'baz', 'Expected "baz"');
                equal(innerHTML(spans[i++]), '', 'Expected ""');
                equal(innerHTML(spans[i++]), 'thud', 'Expected "thud"');
                equal(innerHTML(spans[i++]), 'prop=quux', 'Expected "prop=quux"');
                equal(innerHTML(spans[i++]), 'prop=baz', 'Expected "prop=baz"');
                equal(innerHTML(spans[i++]), 'prop=', 'Expected "prop="');
                equal(innerHTML(spans[i++]), 'prop=thud', 'Expected "prop=thud"');
            });
            test('{{#each}} handles an undefined list changing to a defined list (#629)', function () {
                var renderer = stache('    {{description}}:           <ul>           {{#each list}}                   <li>{{name}}</li>           {{/each}}           </ul>');
                var div = doc.createElement('div'), data1 = new CanMap({ description: 'Each without list' }), data2 = new CanMap({
                        description: 'Each with empty list',
                        list: []
                    });
                div.appendChild(renderer(data1));
                div.appendChild(renderer(data2));
                equal(div.getElementsByTagName('ul')[0].getElementsByTagName('li').length, 0, 'there are no lis in the undefined list');
                equal(div.getElementsByTagName('ul')[1].getElementsByTagName('li').length, 0, 'there are no lis in the empty list');
                stop();
                setTimeout(function () {
                    start();
                    data1.attr('list', [{ name: 'first' }]);
                    data2.attr('list', [{ name: 'first' }]);
                    equal(div.getElementsByTagName('ul')[0].getElementsByTagName('li').length, 1, 'there should be an li as we set an attr to an array');
                    equal(div.getElementsByTagName('ul')[1].getElementsByTagName('li').length, 1);
                    equal(innerHTML(div.getElementsByTagName('ul')[0].getElementsByTagName('li')[0]), 'first');
                    equal(innerHTML(div.getElementsByTagName('ul')[1].getElementsByTagName('li')[0]), 'first');
                }, 250);
            });
            test('canCompute should live bind when the value is changed to a Construct (#638)', function () {
                var renderer = stache('<p>{{#counter}} Clicked <span>{{count}}</span> times {{/counter}}</p>'), div = doc.createElement('div'), counter = canCompute(), data = { counter: counter };
                div.appendChild(renderer(data));
                equal(div.getElementsByTagName('span').length, 0);
                stop();
                setTimeout(function () {
                    start();
                    counter({ count: 1 });
                    equal(div.getElementsByTagName('span').length, 1);
                    equal(innerHTML(div.getElementsByTagName('span')[0]), '1');
                }, 10);
            });
            test('@index in partials loaded from script templates', function () {
                if (doc === window.document) {
                    var script = doc.createElement('script');
                    script.type = 'text/mustache';
                    script.id = 'itempartial';
                    script.text = '<label></label>';
                    doc.body.appendChild(script);
                    var itemsTemplate = stache('<div>' + '{{#each items}}' + '{{>itempartial}}' + '{{/each}}' + '</div>');
                    var items = new CanList([
                        {},
                        {}
                    ]);
                    var frag = itemsTemplate({ items: items }), div = frag.firstChild, labels = div.getElementsByTagName('label');
                    equal(labels.length, 2, 'two labels');
                    items.shift();
                    labels = div.getElementsByTagName('label');
                    equal(labels.length, 1, 'first label removed');
                } else {
                    expect(0);
                }
            });
            test('#each with #if directly nested (#750)', function () {
                var template = stache('<ul>{{#each list}} {{#if visible}}<li>{{name}}</li>{{/if}} {{/each}}</ul>');
                var data = new CanMap({
                    list: [
                        {
                            name: 'first',
                            visible: true
                        },
                        {
                            name: 'second',
                            visible: false
                        },
                        {
                            name: 'third',
                            visible: true
                        }
                    ]
                });
                var frag = template(data);
                data.attr('list').pop();
                equal(frag.firstChild.getElementsByTagName('li').length, 1, 'only first should be visible');
            });
            test('viewCallbacks.tag', function () {
                expect(4);
                viewCallbacks.tag('stache-tag', function (el, tagData) {
                    ok(tagData.scope instanceof Scope, 'got scope');
                    ok(tagData.options instanceof Scope, 'got options');
                    equal(typeof tagData.subtemplate, 'function', 'got subtemplate');
                    var frag = tagData.subtemplate(tagData.scope.add({ last: 'Meyer' }), tagData.options);
                    equal(innerHTML(frag.firstChild), 'Justin Meyer', 'rendered right');
                });
                var template = stache('<stache-tag><span>{{first}} {{last}}</span></stache-tag>');
                template({ first: 'Justin' });
            });
            test('viewCallbacks.attr', function () {
                expect(3);
                viewCallbacks.attr('stache-attr', function (el, attrData) {
                    ok(attrData.scope instanceof Scope, 'got scope');
                    ok(attrData.options instanceof Scope, 'got options');
                    equal(attrData.attributeName, 'stache-attr', 'got attribute name');
                });
                var template = stache('<div stache-attr=\'foo\'></div>');
                template({});
            });
            test('./ in key', function () {
                var template = stache('<div><label>{{name}}</label>{{#children}}<span>{{./name}}-{{name}}</span>{{/children}}</div>');
                var data = {
                    name: 'CanJS',
                    children: [
                        {},
                        { name: 'stache' }
                    ]
                };
                var res = template(data);
                var spans = res.firstChild.getElementsByTagName('span');
                equal(innerHTML(spans[0]), '-CanJS', 'look in current level');
                equal(innerHTML(spans[1]), 'stache-stache', 'found in current level');
            });
            test('self closing tags callback custom tag callbacks (#880)', function () {
                viewCallbacks.tag('stache-tag', function (el, tagData) {
                    ok(true, 'tag callback called');
                    equal(tagData.scope.peek('.').foo, 'bar', 'got scope');
                    ok(!tagData.subtemplate, 'there is no subtemplate');
                });
                var template = stache('<div><stache-tag/></div>');
                template({ foo: 'bar' });
            });
            test('empty custom tags do not have a subtemplate (#880)', function () {
                viewCallbacks.tag('stache-tag', function (el, tagData) {
                    ok(true, 'tag callback called');
                    equal(tagData.scope.peek('.').foo, 'bar', 'got scope');
                    ok(!tagData.subtemplate, 'there is no subtemplate');
                });
                var template = stache('<div><stache-tag></stache-tag></div>');
                template({ foo: 'bar' });
            });
            test('inverse in tag', function () {
                var template = stache('<span {{^isBlack}} style="display:none"{{/if}}>Hi</span>');
                var res = template({ isBlack: false });
                ok(/display:\s*none/.test(res.firstChild.getAttribute('style')), 'display none is not set');
            });
            test('Calling .fn without arguments should forward scope by default (#658)', function () {
                var tmpl = '{{#foo}}<span>{{bar}}</span>{{/foo}}';
                var frag = stache(tmpl)(new CanMap({ bar: 'baz' }), {
                    foo: function (opts) {
                        return opts.fn();
                    }
                });
                var node = frag.firstChild;
                equal(innerHTML(node), 'baz', 'Context is forwarded correctly');
            });
            test('Calling .fn with falsy value as the context will render correctly (#658)', function () {
                var tmpl = '{{#zero}}<span>{{ . }}</span>{{/zero}}{{#emptyString}}<span>{{ . }}</span>{{/emptyString}}{{#nullVal}}<span>{{ . }}</span>{{/nullVal}}';
                var frag = stache(tmpl)({ foo: 'bar' }, {
                    zero: function (opts) {
                        return opts.fn(0);
                    },
                    emptyString: function (opts) {
                        return opts.fn('');
                    },
                    nullVal: function (opts) {
                        return opts.fn(null);
                    }
                });
                equal(innerHTML(frag.firstChild), '0', 'Context is set correctly for falsy values');
                equal(innerHTML(frag.childNodes.item(1)), '', 'Context is set correctly for falsy values');
                equal(innerHTML(frag.childNodes.item(2)), '', 'Context is set correctly for falsy values');
            });
            test('Custom elements created with default namespace in IE8', function () {
                viewCallbacks.tag('my-tag', function () {
                });
                var tmpl = '<my-tag></my-tag>';
                var frag = stache(tmpl)({});
                this.fixture.appendChild(frag);
                equal(this.fixture.getElementsByTagName('my-tag').length, 1, 'Element created in default namespace');
            });
            test('Partials are passed helpers (#791)', function () {
                var t = {
                        template: '{{>partial}}',
                        expected: 'foo',
                        partials: { partial: '{{ help }}' },
                        helpers: {
                            'help': function () {
                                return 'foo';
                            }
                        }
                    }, frag;
                for (var name in t.partials) {
                    stache.registerPartial(name, t.partials[name]);
                }
                frag = stache(t.template)({}, t.helpers);
                equal(frag.firstChild.nodeValue, t.expected);
            });
            test('{{else}} with {{#unless}} (#988)', function () {
                var tmpl = '<div>{{#unless noData}}data{{else}}no data{{/unless}}</div>';
                var frag = stache(tmpl)({ noData: true });
                equal(innerHTML(frag.firstChild), 'no data', 'else with unless worked');
            });
            test('{{else}} within an attribute (#974)', function () {
                var tmpl = '<div class="{{#if color}}{{color}}{{else}}red{{/if}}"></div>', data = new CanMap({ color: 'orange' }), frag = stache(tmpl)(data);
                equal(frag.firstChild.className, 'orange', 'if branch');
                data.attr('color', false);
                equal(frag.firstChild.className, 'red', 'else branch');
            });
            test('returns correct value for DOM attributes (#1065)', 3, function () {
                var template = '<h2 class="{{#if shown}}foo{{/if}} test1 {{#shown}}muh{{/shown}}"></h2>' + '<h3 class="{{#if shown}}bar{{/if}} test2 {{#shown}}kuh{{/shown}}"></h3>' + '<h4 class="{{#if shown}}baz{{/if}} test3 {{#shown}}boom{{/shown}}"></h4>';
                var frag = stache(template)({ shown: true });
                equal(frag.firstChild.className, 'foo test1 muh');
                equal(frag.childNodes.item(1).className, 'bar test2 kuh');
                equal(frag.childNodes.item(2).className, 'baz test3 boom');
            });
            test('single character attributes work (#1132)', function () {
                if (doc.createElementNS) {
                    var template = '<svg width="50" height="50">' + '<circle r="25" cx="25" cy="25"></circle>' + '</svg>';
                    var frag = stache(template)({});
                    equal(frag.firstChild.firstChild.getAttribute('r'), '25');
                } else {
                    expect(0);
                }
            });
            test('single property read does not infinitely loop (#1155)', function () {
                stop();
                var map = new CanMap({ state: false });
                var current = false;
                var source = canCompute(1);
                var number = canCompute(function () {
                    map.attr('state', current = !current);
                    return source();
                });
                number.bind('change', function () {
                });
                var template = stache('<div>{{#if map.state}}<span>Hi</span>{{/if}}</div>');
                template({ map: map });
                source(2);
                map.attr('state', current = !current);
                ok(true, 'no error at this point');
                start();
            });
            test('methods become observable (#1164)', function () {
                var TeamModel = CanMap.extend({
                    shortName: function () {
                        return this.attr('nickname') && this.attr('nickname').length <= 8 ? this.attr('nickname') : this.attr('abbreviation');
                    }
                });
                var team = new TeamModel({
                    nickname: 'Arsenal London',
                    abbreviation: 'ARS'
                });
                var template = stache('<span>{{team.shortName}}</span>');
                var frag = template({ team: team });
                equal(innerHTML(frag.firstChild), 'ARS', 'got value');
            });
            test('<col> inside <table> renders correctly (#1013)', 1, function () {
                var template = '<table><colgroup>{{#columns}}<col class="{{class}}" />{{/columns}}</colgroup><tbody></tbody></table>';
                var frag = stache(template)({ columns: new CanList([{ 'class': 'test' }]) });
                var index = getChildNodes(frag).length === 2 ? 1 : 0;
                var tagName = frag.childNodes.item(index).firstChild.firstChild.tagName.toLowerCase();
                equal(tagName, 'col', '<col> nodes added in proper position');
            });
            test('splicing negative indices works (#1038)', function () {
                var template = '{{#each list}}<p>{{.}}</p>{{/each}}';
                var list = new CanList([
                    'a',
                    'b',
                    'c',
                    'd'
                ]);
                var frag = stache(template)({ list: list });
                var children = getChildNodes(frag).length;
                list.splice(-1);
                equal(getChildNodes(frag).length, children - 1, 'Child node removed');
            });
            test('stache can accept an intermediate (#1387)', function () {
                var template = '<div class=\'{{className}}\'>{{message}}</div>';
                var intermediate = parser(template, {}, true);
                var renderer = stache(intermediate);
                var frag = renderer({
                    className: 'foo',
                    message: 'bar'
                });
                equal(frag.firstChild.className, 'foo', 'correct class name');
                equal(innerHTML(frag.firstChild), 'bar', 'correct innerHTMl');
            });
            test('Passing Partial set in options (#1388 and #1389). Support live binding of partial', function () {
                var data = new CanMap({
                    name: 'World',
                    greeting: 'hello'
                });
                stache.registerPartial('hello', 'hello {{name}}', '.stache');
                stache.registerPartial('goodbye', 'goodbye {{name}}', '.stache');
                var template = stache('<div>{{>greeting}}</div>')(data);
                var div = doc.createElement('div');
                div.appendChild(template);
                equal(innerHTML(div.firstChild), 'hello World', 'partial retreived and rendered');
                data.attr('greeting', 'goodbye');
                equal(innerHTML(div.firstChild), 'goodbye World', 'Partial updates when attr is updated');
            });
            test('#each with null or undefined and then a list', function () {
                var template = stache('<ul>{{#each items}}<li>{{name}}</li>{{/each}}');
                var data = new CanMap({ items: null });
                var frag = template(data);
                var div = doc.createElement('div');
                div.appendChild(frag);
                data.attr('items', [{ name: 'foo' }]);
                equal(div.getElementsByTagName('li').length, 1, 'li added');
            });
            test('promises work (#179)', function () {
                var template = stache('{{#if promise.isPending}}<span class=\'pending\'></span>{{/if}}' + '{{#if promise.isRejected}}<span class=\'rejected\'>{{promise.reason.message}}</span>{{/if}}' + '{{#if promise.isResolved}}<span class=\'resolved\'>{{promise.value.message}}</span>{{/if}}');
                var def = {};
                var promise = new Promise(function (resolve, reject) {
                    def.resolve = resolve;
                    def.reject = reject;
                });
                var data = { promise: promise };
                var frag = template(data);
                var rootDiv = doc.createElement('div');
                rootDiv.appendChild(frag);
                var spans = rootDiv.getElementsByTagName('span');
                equal(spans.length, 1);
                equal(spans[0].getAttribute('class'), 'pending');
                stop();
                def.resolve({ message: 'Hi there' });
                setTimeout(function () {
                    spans = rootDiv.getElementsByTagName('span');
                    equal(spans.length, 1);
                    equal(spans[0].getAttribute('class'), 'resolved');
                    equal(innerHTML(spans[0]), 'Hi there');
                    var def = {};
                    var promise = new Promise(function (resolve, reject) {
                        def.resolve = resolve;
                        def.reject = reject;
                    });
                    var data = { promise: promise };
                    var frag = template(data);
                    var div = doc.createElement('div');
                    div.appendChild(frag);
                    spans = div.getElementsByTagName('span');
                    def.reject({ message: 'BORKED' });
                    setTimeout(function () {
                        spans = div.getElementsByTagName('span');
                        equal(spans.length, 1);
                        equal(spans[0].getAttribute('class'), 'rejected');
                        equal(innerHTML(spans[0]), 'BORKED');
                        start();
                    }, 30);
                }, 30);
            });
            test('{#list} works right (#1551)', function () {
                var data = new CanMap({});
                var template = stache('<div>{{#items}}<span/>{{/items}}</div>');
                var frag = template(data);
                data.attr('items', new CanList());
                data.attr('items').push('foo');
                var spans = frag.firstChild.getElementsByTagName('span');
                equal(spans.length, 1, 'one span');
            });
            test('promises are not rebound (#1572)', function () {
                stop();
                var d = {};
                var promise = new Promise(function (resolve, reject) {
                    d.resolve = resolve;
                    d.reject = reject;
                });
                var compute = canCompute(promise);
                var template = stache('<div>{{#if promise.isPending}}<span/>{{/if}}</div>');
                var frag = template({ promise: compute });
                var div = frag.firstChild, spans = div.getElementsByTagName('span');
                var d2 = {};
                var promise2 = new Promise(function (resolve, reject) {
                    d2.resolve = resolve;
                    d2.reject = reject;
                });
                compute(promise2);
                setTimeout(function () {
                    d2.resolve('foo');
                    setTimeout(function () {
                        spans = div.getElementsByTagName('span');
                        equal(spans.length, 0, 'there should be no spans');
                        start();
                    }, 30);
                }, 10);
            });
            test('reading alternate values on promises (#1572)', function () {
                var promise = new Promise(function (resolve, reject) {
                });
                promise.myAltProp = 'AltValue';
                var template = stache('<div>{{d.myAltProp}}</div>');
                var frag = template({ d: promise });
                equal(innerHTML(frag.firstChild), 'AltValue', 'read value');
            });
            test('possible to teardown immediate nodeList (#1593)', function () {
                expect(3);
                var map = new CanMap({ show: true });
                var oldBind = map.addEventListener, oldUnbind = map.removeEventListener;
                map.addEventListener = function () {
                    ok(true, 'bound', 'bound');
                    return oldBind.apply(this, arguments);
                };
                map.removeEventListener = function () {
                    ok(true, 'unbound', 'unbound');
                    return oldUnbind.apply(this, arguments);
                };
                var template = stache('{{#if show}}<span/>TEXT{{/if}}');
                var nodeList = nodeLists.register([], undefined, true);
                var frag = template(map, {}, nodeList);
                nodeLists.update(nodeList, getChildNodes(frag));
                equal(nodeList.length, 1, 'our nodeList has the nodeList of #if show');
                nodeLists.unregister(nodeList);
                stop();
                setTimeout(function () {
                    start();
                }, 10);
            });
            test('#1590 #each with surrounding block and setter', function () {
                var product = canCompute();
                var people = canCompute(function () {
                    var newList = new CanList();
                    newList.replace(['Brian']);
                    return newList;
                });
                var frag = stache('<div>{{#if product}}<div>{{#each people}}<span/>{{/each}}</div>{{/if}}</div>')({
                    people: people,
                    product: product
                });
                canBatch.start();
                product(1);
                canBatch.stop();
                equal(frag.firstChild.getElementsByTagName('span').length, 1, 'no duplicates');
            });
            if (doc.createElementNS && System.env !== 'canjs-test') {
                test('svg elements for (#1327)', function () {
                    var template = stache('<svg height="120" width="400">' + '<circle cx="50" cy="50" r="{{radius}}" stroke="black" stroke-width="3" fill="blue" />' + '</svg>');
                    var frag = template({ radius: 6 });
                    equal(frag.firstChild.namespaceURI, 'http://www.w3.org/2000/svg', 'svg namespace');
                });
            }
            test('using #each when toggling between list and null', function () {
                var state = new CanMap();
                var frag = stache('{{#each deepness.rows}}<div></div>{{/each}}')(state);
                state.attr('deepness', { rows: ['test'] });
                state.attr('deepness', null);
                equal(getChildNodes(frag).length, 1, 'only the placeholder textnode');
            });
            test('compute defined after template (#1617)', function () {
                var myMap = new CanMap();
                var frag = stache('<span>{{ myMap.test }}</span>')({ myMap: myMap });
                myMap.attr('test', canCompute(function () {
                    return 'def';
                }));
                equal(frag.firstChild.firstChild.nodeValue, 'def', 'correct value');
            });
            test('template with a block section and nested if doesnt render correctly', function () {
                var myMap = new CanMap({ bar: true });
                var frag = stache('{{#bar}}<div>{{#if foo}}My Meals{{else}}My Order{{/if}}</div>{{/bar}}')(myMap);
                equal(innerHTML(frag.firstChild), 'My Order', 'shows else case');
                myMap.attr('foo', true);
                equal(innerHTML(frag.firstChild), 'My Meals', 'shows if case');
            });
            test('registerSimpleHelper', 3, function () {
                var template = stache('<div>Result: {{simple first second}}</div>');
                stache.registerSimpleHelper('simple', function (first, second) {
                    equal(first, 2);
                    equal(second, 4);
                    return first + second;
                });
                var frag = template(new CanMap({
                    first: 2,
                    second: 4
                }));
                equal(innerHTML(frag.firstChild), 'Result: 6');
            });
            test('Helper handles list replacement (#1652)', 3, function () {
                var state = new CanMap({ list: [] });
                var helpers = {
                    listHasLength: function (options) {
                        ok(true, 'listHasLength helper evaluated');
                        return this.attr('list').attr('length') ? options.fn() : options.inverse();
                    }
                };
                stache('{{#listHasLength}}{{/listHasLength}}')(state, helpers);
                state.attr('list', []);
                state.attr('list').push('...');
            });
            test('Helper binds to nested properties (#1651)', function () {
                var nestedAttrsCount = 0, state = new CanMap({ parent: null });
                var helpers = {
                    bindViaNestedAttrs: function (options) {
                        nestedAttrsCount++;
                        if (nestedAttrsCount === 3) {
                            ok(true, 'bindViaNestedAttrs helper evaluated 3 times');
                        }
                        return this.attr('parent') && this.attr('parent').attr('child') ? options.fn() : options.inverse();
                    }
                };
                stache('{{#bindViaNestedAttrs}}{{/bindViaNestedAttrs}}')(state, helpers);
                state.attr('parent', { child: 'foo' });
                state.attr('parent.child', 'bar');
            });
            test('Using a renderer function as a partial', function () {
                var template = stache('{{> other}}');
                var partial = stache('hello there');
                var map = new CanMap({ other: null });
                var frag = template(map);
                equal(frag.firstChild.nodeValue, '', 'Initially it is a blank textnode');
                map.attr('other', partial);
                equal(frag.firstChild.nodeValue, 'hello there', 'partial rendered');
            });
            test('Handlebars helper: switch/case', function () {
                var expected;
                var t = {
                    template: '{{#switch ducks}}{{#case "10"}}10 ducks{{/case}}' + '{{#default}}Not 10 ducks{{/default}}{{/switch}}',
                    expected: '10 ducks',
                    data: {
                        ducks: '10',
                        tenDucks: function () {
                            return '10';
                        }
                    },
                    liveData: new CanMap({
                        ducks: '10',
                        tenDucks: function () {
                            return '10';
                        }
                    })
                };
                expected = t.expected.replace(/&quot;/g, '&#34;').replace(/\r\n/g, '\n');
                deepEqual(getText(t.template, t.data), expected);
                deepEqual(getText(t.template, t.liveData), expected);
                t.data.ducks = 5;
                deepEqual(getText(t.template, t.data), 'Not 10 ducks');
            });
            test('Handlerbars helper: switch - changing to default (#1857)', function () {
                var template = stache('{{#switch ducks}}{{#case "10"}}10 ducks{{/case}}' + '{{#default}}Not 10 ducks{{/default}}{{/switch}}');
                var map = new CanMap({ ducks: '10' });
                var frag = template(map);
                deepEqual(getTextFromFrag(frag), '10 ducks');
                map.attr('ducks', '12');
                deepEqual(getTextFromFrag(frag), 'Not 10 ducks');
            });
            test('joinBase helper joins to the baseURL', function () {
                var baseUrl = System.baseURL || getBaseURL();
                var template = stache('{{joinBase \'hello/\' name}}');
                var map = new CanMap({ name: 'world' });
                var frag = template(map);
                equal(frag.firstChild.nodeValue, joinURIs(baseUrl, 'hello/world'), 'joined from baseUrl');
            });
            test('joinBase helper can be relative to template module', function () {
                var baseUrl = 'http://foocdn.com/bitovi';
                var template = stache('{{joinBase \'../hello/\' name}}');
                var map = new CanMap({ name: 'world' });
                var frag = template(map, { module: { uri: baseUrl } });
                equal(frag.firstChild.nodeValue, 'http://foocdn.com/hello/world', 'relative lookup works');
            });
            test('Custom attribute callbacks are called when in a conditional within a live section', 8, function () {
                viewCallbacks.attr('test-attr', function (el, attrData) {
                    ok(true, 'test-attr called');
                    equal(attrData.attributeName, 'test-attr', 'attributeName set correctly');
                    ok(attrData.scope, 'scope isn\'t undefined');
                    ok(attrData.options, 'options isn\'t undefined');
                });
                var state = new CanMap({ showAttr: true });
                var template = stache('<button id="find-me" {{#if showAttr}}test-attr{{/if}}></button>');
                template(state);
                state.attr('showAttr', false);
                state.attr('showAttr', true);
            });
            test('inner expressions (#1769)', function () {
                var template = stache('{{helperA helperB(1,valueA,propA=valueB propC=2) \'def\' outerPropA=helperC(2, ~valueB)}}');
                var frag = template(new CanMap({
                    valueA: 'A',
                    valueB: 'B'
                }), {
                    helperA: function (arg1, arg2, options) {
                        equal(arg1(), 'helperB value', 'call expression argument to helperA');
                        equal(arg2, 'def', 'scope argument');
                        equal(options.hash.outerPropA(), 'helperC value', 'scope hash');
                        return 'helperA value';
                    },
                    helperB: function (arg1, arg2, options) {
                        equal(arg1, 1, 'static argument');
                        equal(arg2, 'A', 'scope argument');
                        equal(options.propA, 'B', 'scope hash');
                        equal(options.propC, 2, 'static hash');
                        return 'helperB value';
                    },
                    helperC: function (arg1, arg2) {
                        equal(arg1, 2, 'helperC static argument');
                        equal(arg2(), 'B', 'helperC scope argument');
                        return 'helperC value';
                    }
                });
                equal(frag.firstChild.nodeValue, 'helperA value');
            });
            test('inner expressions with computes', function () {
                var template = stache('{{helperA helperB(1,valueA,propA=valueB propC=2) \'def\' outerPropA=helperC(2,valueB)}}');
                var valueB = canCompute('B');
                var changes = 0;
                var frag = template({
                    valueA: 'A',
                    valueB: valueB
                }, {
                    helperA: function (arg1, arg2, options) {
                        if (changes === 0) {
                            equal(arg1(), 'helperB=B', 'static argument');
                            equal(options.hash.outerPropA(), 'helperC=B', 'scope hash 0');
                        } else {
                            equal(arg1(), 'helperB=X', 'static argument');
                            equal(options.hash.outerPropA(), 'helperC=X', 'scope hash 1');
                        }
                        equal(arg2, 'def', 'scope argument');
                        return arg1() + '-' + options.hash.outerPropA();
                    },
                    helperB: function (arg1, arg2, options) {
                        equal(arg1, 1, 'static argument');
                        equal(arg2, 'A', 'scope argument');
                        if (changes === 0) {
                            equal(options.propA, 'B', 'scope hash');
                        } else {
                            equal(options.propA, 'X', 'scope hash');
                        }
                        equal(options.propC, 2, 'static hash');
                        return 'helperB=' + options.propA;
                    },
                    helperC: function (arg1, arg2) {
                        equal(arg1, 2, 'helperC static argument');
                        if (changes === 0) {
                            equal(arg2, 'B', 'helperC scope argument');
                        } else {
                            equal(arg2, 'X', 'helperC scope argument');
                        }
                        return 'helperC=' + arg2;
                    }
                });
                equal(frag.firstChild.nodeValue, 'helperB=B-helperC=B');
                changes++;
                canBatch.start();
                valueB('X');
                canBatch.stop();
                equal(frag.firstChild.nodeValue, 'helperB=X-helperC=X');
            });
            test('parent scope functions not called with arguments (#1833)', function () {
                var data = {
                    child: { value: 1 },
                    method: function (arg) {
                        equal(arg, 1, 'got the right arg');
                    }
                };
                var template = stache('{{#child}}{{method value}}{{/child}}');
                template(data);
            });
            test('call expression - simple', function () {
                var template = stache('{{method(arg)}}');
                var age = canCompute(32);
                var frag = template({
                    method: function (num) {
                        return num * 2;
                    },
                    arg: age
                });
                equal(frag.firstChild.nodeValue, '64', 'method call works');
            });
            test('call expression #each passed list', function () {
                var animals = new CanList([
                        'sloth',
                        'bear'
                    ]), renderer = stache('<div>my<b>favorite</b>animals:{{#eachOf(animals)}}<label>Animal=</label> <span>{{this}}</span>{{/}}!</div>');
                var div = doc.createElement('div');
                var frag = renderer({ animals: animals });
                div.appendChild(frag);
                div.getElementsByTagName('label')[0].myexpando = 'EXPANDO-ED';
                equal(div.getElementsByTagName('label').length, 2, 'There are 2 labels');
                animals.push('turtle');
                equal(div.getElementsByTagName('label')[0].myexpando, 'EXPANDO-ED', 'same expando');
                equal(innerHTML(div.getElementsByTagName('span')[2]), 'turtle', 'turtle added');
            });
            test('call expression #each passed compute', function () {
                var animals = canCompute(new CanList([
                        'sloth',
                        'bear'
                    ])), renderer = stache('<div>my<b>favorite</b>animals:{{#eachOf(~animals)}}<label>Animal=</label> <span>{{this}}</span>{{/}}!</div>');
                var div = doc.createElement('div');
                var frag = renderer({ animals: animals });
                div.appendChild(frag);
                div.getElementsByTagName('label')[0].myexpando = 'EXPANDO-ED';
                equal(div.getElementsByTagName('label').length, 2, 'There are 2 labels');
                animals(new CanList([
                    'sloth',
                    'bear',
                    'turtle'
                ]));
                equal(div.getElementsByTagName('label')[0].myexpando, 'EXPANDO-ED', 'same expando');
                equal(innerHTML(div.getElementsByTagName('span')[2]), 'turtle', 'turtle added');
            });
            test('call expression with #if', function () {
                var truthy = canCompute(true);
                var template = stache('{{#if(truthy)}}true{{else}}false{{/if}}');
                var frag = template({ truthy: truthy });
                equal(frag.firstChild.nodeValue, 'true', 'set to true');
                truthy(false);
                equal(frag.firstChild.nodeValue, 'false', 'set to false');
            });
            test('getHelper w/o optional options argument (#1497)', function () {
                var options = stache.getHelper('each');
                ok(typeof options.fn === 'function', 'each helper returned');
            });
            test('methods don\'t update correctly (#1891)', function () {
                var map = new CanMap({
                    num1: 1,
                    num2: function () {
                        return this.attr('num1') * 2;
                    }
                });
                var frag = stache('<span class="num1">{{num1}}</span>' + '<span class="num2">{{num2}}</span>')(map);
                equal(frag.firstChild.firstChild.nodeValue, '1', 'Rendered correct value');
                equal(frag.lastChild.firstChild.nodeValue, '2', 'Rendered correct value');
                map.attr('num1', map.attr('num1') * 2);
                equal(frag.firstChild.firstChild.nodeValue, '2', 'Rendered correct value');
                equal(frag.lastChild.firstChild.nodeValue, '4', 'Rendered correct value');
            });
            test('eq called twice (#1931)', function () {
                expect(1);
                var oldIs = stache.getHelper('is').fn;
                stache.registerHelper('is', function () {
                    ok(true, 'comparator invoked');
                    return oldIs.apply(this, arguments);
                });
                var a = canCompute(0), b = canCompute(0);
                stache('{{eq a b}}')({
                    a: a,
                    b: b
                });
                canBatch.start();
                a(1);
                b(1);
                canBatch.stop();
                stache.registerHelper('is', oldIs);
            });
            test('#each with else works (#1979)', function () {
                var list = new CanList([
                    'a',
                    'b'
                ]);
                var template = stache('<div>{{#each list}}<span>{{.}}</span>{{else}}<label>empty</label>{{/each}}</div>');
                var frag = template({ list: list });
                list.replace([]);
                var labels = frag.firstChild.getElementsByTagName('label');
                equal(labels.length, 1, 'empty case');
            });
            test('Re-evaluating a case in a switch (#1988)', function () {
                var template = stache('{{#switch page}}{{#case \'home\'}}<h1 id=\'home\'>Home</h1>' + '{{/case}}{{#case \'users\'}}{{#if slug}}<h1 id=\'user\'>User - {{slug}}</h1>' + '{{else}}<h1 id=\'users\'>Users</h1><ul><li>User 1</li><li>User 2</li>' + '</ul>{{/if}}{{/case}}{{/switch}}');
                var map = new CanMap({ page: 'home' });
                var frag = template(map);
                equal(frag.firstChild.getAttribute('id'), 'home', '\'home\' is the first item shown');
                map.attr('page', 'users');
                equal(frag.firstChild.nextSibling.getAttribute('id'), 'users', '\'users\' is the item shown when the page is users');
                map.attr('slug', 'Matthew');
                equal(frag.firstChild.nextSibling.getAttribute('id'), 'user', '\'user\' is the item shown when the page is users and there is a slug');
                canBatch.start();
                map.attr('page', 'home');
                map.removeAttr('slug');
                canBatch.stop();
                equal(frag.firstChild.getAttribute('id'), 'home', '\'home\' is the first item shown');
                equal(frag.firstChild.nextSibling.nodeType, 3, 'the next sibling is a TextNode');
                equal(frag.firstChild.nextSibling.nextSibling, undefined, 'there are no more nodes');
            });
            test('#each passed a method (2001)', function () {
                var users = new CanList([
                    {
                        name: 'Alexis',
                        num: 4,
                        age: 88
                    },
                    {
                        name: 'Brian',
                        num: 2,
                        age: 31
                    }
                ]);
                var template = stache('<div>{{#each people}}<span/>{{/each}}</div>');
                var VM = CanMap.extend({
                    people: function () {
                        return this.attr('users');
                    },
                    remove: function () {
                        $('#content').empty();
                    }
                });
                var frag = template(new VM({ users: users })), div = frag.firstChild, spans = div.getElementsByTagName('span');
                equal(spans.length, 2, 'two spans');
                domMutate.appendChild.call(this.fixture, frag);
                var fixture = this.fixture;
                stop();
                setTimeout(function () {
                    start();
                    domMutate.removeChild.call(fixture, div);
                    ok(true, 'removed without breaking');
                }, 10);
            });
            test('Rendering live bound indicies with #each, @index and a simple CanList (#2067)', function () {
                var list = new CanList([
                    { value: 'a' },
                    { value: 'b' },
                    { value: 'c' }
                ]);
                var template = stache('<ul>{{#each list}}<li>{{%index}} {{value}}</li>{{/each}}</ul>');
                var tpl = template({ list: list }).firstChild;
                var lis = tpl.getElementsByTagName('li');
                equal(lis.length, 3, 'three lis');
                equal(innerHTML(lis[0]), '0 a', 'first index and value are correct');
                equal(innerHTML(lis[1]), '1 b', 'second index and value are correct');
                equal(innerHTML(lis[2]), '2 c', 'third index and value are correct');
            });
            test('%index content should be skipped by ../ (#1554)', function () {
                var list = new CanList([
                    'a',
                    'b'
                ]);
                var tmpl = stache('{{#each items}}<li>{{.././items.indexOf(this)}}</li>{{/each}}');
                var frag = tmpl({ items: list });
                equal(frag.lastChild.firstChild.nodeValue, '1', 'read indexOf');
            });
            test('rendering style tag (#2035)', function () {
                var map = new CanMap({ color: 'green' });
                var frag = stache('<style>body {color: {{color}} }</style>')(map);
                var content = frag.firstChild.firstChild.nodeValue;
                equal(content, 'body {color: green }', 'got the right style text');
                map = new CanMap({ showGreen: true });
                frag = stache('<style>body {color: {{#showGreen}}green{{/showGreen}} }</style>')(map);
                content = frag.firstChild.firstChild.nodeValue;
                equal(content, 'body {color: green }', 'sub expressions work');
            });
            test('checked as a custom attribute', function () {
                var map = new CanMap({ preview: true });
                var frag = stache('<div {{#if preview}}checked{{/if}}></div>')(map);
                equal(frag.firstChild.getAttribute('checked'), '', 'got attribute');
            });
            test('sections with attribute spacing (#2097)', function () {
                var template = stache('<div {{#foo}} disabled {{/foo}}>');
                var frag = template({ foo: true });
                equal(frag.firstChild.getAttribute('disabled'), '', 'disabled set');
            });
            test('readonly as a custom attribute', function () {
                var map = new DefineMap({ conditions: false });
                var frag = stache('<input {{^conditions}}readonly{{/conditions}} name="password" type="password" />')(map);
                equal(frag.firstChild.getAttribute('readonly'), '', 'readonly set');
            });
            test('keep @index working with multi-dimensional arrays (#2127)', function () {
                var data = new CanMap({
                    array2: [
                        ['asd'],
                        ['sdf']
                    ]
                });
                var template = stache('<div>{{#each array2}}<span>{{@index}}</span>{{/each}}</div>');
                var frag = template(data);
                var spans = frag.firstChild.getElementsByTagName('span');
                equal(spans[0].firstChild.nodeValue, '0');
            });
            test('partials are not working within an {{#each}} (#2174)', function () {
                var data = new CanMap({
                    items: [{ name: 'foo' }],
                    itemRender: stache('{{name}}')
                });
                var renderer = stache('<div>{{#each items}}{{name}}{{/each}}</div>');
                var frag = renderer(data);
                data.attr('items.0.name', 'WORLD');
                equal(innerHTML(frag.firstChild), 'WORLD', 'updated to world');
                data.attr('items').splice(0, 0, { name: 'HELLO' });
                equal(innerHTML(frag.firstChild), 'HELLOWORLD');
            });
            test('partials don\'t leak (#2174)', function () {
                stache.registerHelper('somethingCrazy', function (name, options) {
                    return function (el) {
                        var nodeList = [el];
                        nodeList.expression = 'something crazy';
                        nodeLists.register(nodeList, function () {
                            ok(true, 'nodeList torn down');
                        }, options.nodeList, true);
                        nodeLists.update(options.nodeList, [el]);
                    };
                });
                var data = new CanMap({
                    items: [{ name: 'foo' }],
                    itemRender: stache('{{somethingCrazy name}}')
                });
                var renderer = stache('<div>{{#each items}}{{>itemRender}}{{/each}}</div>');
                renderer(data);
                data.attr('items').pop();
            });
            test('partials should leave binding to helpers and properties (#2174)', function () {
                stache.registerPartial('test', '<input id="one"> {{name}}');
                var renderer = stache('{{#each items}}{{>test}}{{/each}}');
                var data = new CanMap({ items: [] });
                var frag = renderer(data);
                data.attr('items').splice(0, 0, { name: 'bob' });
                frag.firstChild.nextSibling.setAttribute('value', 'user text');
                data.attr('items.0.name', 'dave');
                equal(frag.firstChild.nextSibling.getAttribute('value'), 'user text');
            });
            test('nested switch statement fail (#2188)', function () {
                var template = stache('<div>{{#switch outer}}' + '{{#case "outerValue1"}}' + '{{#switch inner}}' + '{{#case \'innerValue1\'}}' + 'INNER1' + '{{/case}}' + '{{/switch}}' + '{{/case}}' + '{{#case "outerValue2"}}' + 'OUTER2' + '{{/case}}' + '{{/switch}}</div>');
                var vm = new CanMap({
                    outer: 'outerValue1',
                    inner: 'innerValue1'
                });
                var frag = template(vm);
                canBatch.start();
                vm.removeAttr('inner');
                vm.attr('outer', 'outerValue2');
                canBatch.stop();
                ok(innerHTML(frag.firstChild).indexOf('OUTER2') >= 0, 'has OUTER2');
                ok(innerHTML(frag.firstChild).indexOf('INNER1') === -1, 'does not have INNER1');
            });
            test('Child bindings are called before the parent', function () {
                var template = '{{#eq page \'todos\'}}' + '{{#eq action \'view\'}} {{trace \'view todos\'}} {{/eq}}' + '{{#eq action \'edit\'}} {{trace \'edit todos\'}} {{/eq}}' + '{{/eq}}' + '{{#eq page \'recipes\'}}' + '{{#eq action \'view\'}} {{trace \'view recipes\'}} {{/eq}}' + '{{#eq action \'edit\'}} {{trace \'edit recipes\'}} {{/eq}}' + '{{/eq}}';
                var state = new CanMap({
                    action: 'view',
                    page: 'todos'
                });
                var counter = 0;
                stache(template)(state, {
                    trace: function (value, options) {
                        if (counter === 0) {
                            equal(value, 'view todos');
                        } else if (counter === 1) {
                            equal(value, 'edit recipes');
                        } else {
                            ok(false, 'Traced an unexpected template call');
                        }
                        counter++;
                    }
                });
                state.attr({
                    action: 'edit',
                    page: 'recipes'
                });
                equal(counter, 2, 'Counter incremented twice');
            });
            test('%index is double wrapped compute in helper (#2179)', function () {
                var appState = new CanMap({
                    todos: [
                        { description: 'Foo' },
                        { description: 'Bar' }
                    ]
                });
                var template = stache('{{#each todos}}<div>{{indexPlusOne %index}}</div>{{/each}}');
                stache.registerHelper('indexPlusOne', function (val, options) {
                    var resolved = val();
                    equal(typeof resolved, 'number', 'should be a number');
                    return resolved + 2;
                });
                template(appState);
            });
            test('%index is double wrapped compute in helper (#2179)', function () {
                var appState = new CanMap({
                    todos: [
                        { description: 'Foo' },
                        { description: 'Bar' }
                    ]
                });
                var template = stache('{{#each todos}}<div>{{indexPlusOne %index}}</div>{{/each}}');
                stache.registerHelper('indexPlusOne', function (val, options) {
                    var resolved = val();
                    equal(typeof resolved, 'number', 'should be a number');
                    return resolved + 2;
                });
                template(appState);
            });
            test('content within {{#if}} inside partial surrounded by {{#if}} should not display outside partial (#2186)', function () {
                stache.registerPartial('partial', '{{#showHiddenSection}}<div>Hidden</div>{{/showHiddenSection}}');
                var renderer = stache('<div>{{#showPartial}}{{>partial}}{{/showPartial}}</div>');
                var data = new CanMap({
                    showPartial: true,
                    showHiddenSection: false
                });
                var frag = renderer(data);
                data.attr('showHiddenSection', true);
                data.attr('showPartial', false);
                equal(innerHTML(frag.firstChild), '');
            });
            test('nested sections work (#2229)', function () {
                var template = stache('<div {{#a}}' + '{{#b}}f="f"' + '{{else}}' + '{{#c}}f="f"{{/c}}' + '{{/b}}' + '{{/a}}/>');
                var frag = template(new CanMap({
                    a: true,
                    b: false,
                    c: true
                }));
                equal(frag.firstChild.getAttribute('f'), 'f', 'able to set f');
            });
            test('Render with #each by assigning values to a specific variable wrapped in quotes', function () {
                var template = '{{#each animals \'animal\'}}' + '<span>{{animal.name}}</span>' + '{{/each}}';
                var renderer = stache(template);
                var animals = new CanList([{ name: 'sloth' }]);
                var frag = renderer({ animals: animals });
                var div = doc.createElement('div');
                div.appendChild(frag);
                equal(div.getElementsByTagName('span')[0].innerHTML, 'sloth');
            });
            test('Render with #each by assigning values to a specific variable without quotes', function () {
                var template = '{{#each animals animal}}' + '<span>{{animal.name}}</span>' + '{{/each}}';
                var renderer = stache(template);
                var animals = new CanList([{ name: 'sloth' }]);
                var frag = renderer({ animals: animals });
                var div = doc.createElement('div');
                div.appendChild(frag);
                equal(div.getElementsByTagName('span')[0].innerHTML, 'sloth');
            });
            test('Render with #each by assigning values to a specific variable and expressing it with `as` between list and value variable', function () {
                var template = '{{#each animals as animal}}' + '<span>{{animal.name}}</span>' + '{{/each}}';
                var renderer = stache(template);
                var animals = new CanList([{ name: 'sloth' }]);
                var frag = renderer({ animals: animals });
                var div = doc.createElement('div');
                div.appendChild(frag);
                equal(div.getElementsByTagName('span')[0].innerHTML, 'sloth');
            });
            test('Partials with custom context', function () {
                var template;
                var div = doc.createElement('div');
                template = stache('{{>dude dudes}}');
                var data = new CanMap({
                    dudes: [
                        { name: 'austin' },
                        { name: 'justin' }
                    ]
                });
                var dom = template(data, { partials: { dude: stache('{{#this}}<span>{{name}}</span>{{/this}}') } });
                div.appendChild(dom);
                var spans = div.getElementsByTagName('span');
                equal(spans.length, 2, 'Got two dudes');
                equal(innerHTML(spans[0]), 'austin', 'custom context inside');
                equal(innerHTML(spans[1]), 'justin', 'custom context inside');
            });
            test('Partials with nested custom context and parent lookup', function () {
                var template;
                var div = doc.createElement('div');
                template = stache('{{#data}}{{>dude dudes}}{{/data}}');
                var dom = template({
                    data: new CanMap({
                        hello: 'Hello',
                        dudes: [
                            { name: 'austin' },
                            { name: 'justin' }
                        ]
                    })
                }, {
                    helpers: {
                        cap: function (name) {
                            return string.capitalize(name());
                        }
                    },
                    partials: { dude: stache('{{#this}}<span>{{../hello}} {{name}}</span>{{/this}}') }
                });
                div.appendChild(dom);
                var spans = div.getElementsByTagName('span');
                equal(spans.length, 2, 'Got two dudes');
                equal(innerHTML(spans[0]), 'Hello austin', 'correct context');
                equal(innerHTML(spans[1]), 'Hello justin', 'and parent lookup worked also');
            });
            test('Partials with custom context and helper', function () {
                var template;
                var div = doc.createElement('div');
                template = stache('{{>dude dudes}}');
                var data = new CanMap({
                    dudes: [
                        { name: 'austin' },
                        { name: 'justin' }
                    ]
                });
                var dom = template(data, {
                    helpers: {
                        cap: function (name) {
                            return string.capitalize(name());
                        }
                    },
                    partials: { dude: stache('{{#this}}<span>{{cap name}}</span>{{/this}}') }
                });
                div.appendChild(dom);
                var spans = div.getElementsByTagName('span');
                equal(spans.length, 2, 'Got two dudes');
                equal(innerHTML(spans[0]), 'Austin', 'correct context');
                equal(innerHTML(spans[1]), 'Justin', 'and helpers worked also');
            });
            test('Bracket expression', function () {
                var template;
                var div = doc.createElement('div');
                template = stache('<p>{{ foo[bar] }}</p>');
                var data = new CanMap({
                    bar: 'name',
                    foo: {
                        name: 'Kevin',
                        fullName: 'Kevin Phillips'
                    }
                });
                var dom = template(data);
                div.appendChild(dom);
                var p = div.getElementsByTagName('p');
                equal(innerHTML(p[0]), 'Kevin', 'correct value for foo[bar]');
                data.attr('bar', 'fullName');
                equal(innerHTML(p[0]), 'Kevin Phillips', 'updated value for foo[bar]');
            });
            test('Bracket expression as argument to helper', function () {
                var template;
                var div = doc.createElement('div');
                template = stache('<p>{{#if [bar]}}if{{else}}else{{/if}}</p>');
                var data = new CanMap({
                    bar: 'key',
                    key: false
                });
                var dom = template(data);
                div.appendChild(dom);
                var p = div.getElementsByTagName('p');
                equal(innerHTML(p[0]), 'else', 'correctly displays {{else}} section');
                data.attr('key', true);
                equal(innerHTML(p[0]), 'if', 'correctly displays {{#if}} section');
            });
            test('Bracket expression in attributes', function () {
                var template;
                var div = doc.createElement('div');
                template = stache('<p id=\'{{ foo[bar] }}\' class=\'{{ foo[\'bar:baz\'] }}\'></p>');
                var data = new CanMap({
                    bar: 'name',
                    foo: {
                        'bar:baz': 'zulu',
                        name: 'Kevin',
                        fullName: 'Kevin Phillips'
                    }
                });
                var dom = template(data);
                div.appendChild(dom);
                var p = div.getElementsByTagName('p')[0];
                equal(getAttr(p, 'id'), 'Kevin', 'correct value for foo[bar]');
                equal(getAttr(p, 'class'), 'zulu', 'correct value for foo[\'bar:baz\']');
                data.attr('bar', 'fullName');
                data.attr('foo.bar:baz', 'tango');
                equal(getAttr(p, 'id'), 'Kevin Phillips', 'correct value for foo[bar]');
                equal(getAttr(p, 'class'), 'tango', 'correct value for foo[\'bar:baz\']');
            });
            test('Bracket expression - DefineMap', function () {
                var template;
                var div = doc.createElement('div');
                template = stache('<p>{{ foo[bar] }}</p>');
                var data = new DefineMap({
                    bar: 'name',
                    foo: {
                        name: 'Kevin',
                        fullName: 'Kevin Phillips'
                    }
                });
                var dom = template(data);
                div.appendChild(dom);
                var p = div.getElementsByTagName('p');
                equal(innerHTML(p[0]), 'Kevin', 'correct value for foo[bar]');
                data.bar = 'fullName';
                equal(innerHTML(p[0]), 'Kevin Phillips', 'updated value for foo[bar]');
            });
            test('context is observable (#38)', function () {
                var computes = [];
                stache.registerHelper('contextHelper', function (context) {
                    QUnit.equal(typeof context, 'function', 'got a compute');
                    computes.push(context);
                    return context();
                });
                var template = stache('<ul>{{#each .}}<li>{{contextHelper .}}</li>{{/each}}</ul>');
                var items = new CanList([
                    'one',
                    'two'
                ]);
                var frag = template(items);
                var lis = frag.firstChild.getElementsByTagName('li');
                items.attr(1, 'TWO');
                lis = frag.firstChild.getElementsByTagName('li');
                QUnit.equal(lis[1].innerHTML, 'TWO', 'is TWO');
                computes[1]('2');
                lis = frag.firstChild.getElementsByTagName('li');
                QUnit.equal(lis[1].innerHTML, '2', 'is 2');
            });
            if (window.console && window.console.log) {
                test('log', function () {
                    var oldLog = console.log;
                    var FIRST = {}, SECOND = {};
                    console.log = function (first, second) {
                        QUnit.equal(first, FIRST);
                        QUnit.equal(second, SECOND);
                    };
                    var template1 = stache('{{log first second}}'), template2 = stache('{{ log(first, second) }}');
                    template1({
                        first: FIRST,
                        second: SECOND
                    });
                    template2({
                        first: FIRST,
                        second: SECOND
                    });
                    console.log = oldLog;
                });
            }
            test('Nested if-s inside a text section (#9)', function (assert) {
                var template = stache('<div class="{{#if sorting}}sort{{#if ascending}}-ascend{{/if}}{{/if}}"></div>');
                var vm = new CanMap({
                    sorting: true,
                    ascending: false
                });
                var frag = template(vm);
                var className = frag.firstChild.className;
                assert.equal(className, 'sort');
                vm.attr('ascending', true);
                className = frag.firstChild.className;
                assert.equal(className, 'sort-ascend');
            });
            test('Helper each inside a text section (attribute) (#8)', function (assert) {
                var template = stache('<div class="{{#each list}}{{.}} {{/}}"></div>');
                var vm = new CanMap({
                    list: new CanList([
                        'one',
                        'two'
                    ])
                });
                var frag = template(vm);
                var className = frag.firstChild.className;
                assert.equal(className, 'one two ');
                vm.attr('list').push('three');
                className = frag.firstChild.className;
                assert.equal(className, 'one two three ');
            });
            test('stache.from works (#57)', function (assert) {
                var script = DOCUMENT().createElement('script');
                script.type = 'type/stache';
                script.innerHTML = '{{message}}';
                script.setAttribute('id', 'some-template');
                DOCUMENT().body.appendChild(script);
                var template = stache.from('some-template');
                var frag = template({ message: 'Hello' });
                assert.equal(frag.firstChild.nodeValue, 'Hello');
            });
            test('foo().bar', function () {
                var template = stache('<p>{{ person().name }}</p>');
                var div = doc.createElement('div');
                var data = new CanMap({
                    name: 'Kevin',
                    person: function () {
                        return { name: this.attr('name') };
                    }
                });
                var dom = template(data);
                div.appendChild(dom);
                var p = div.getElementsByTagName('p');
                equal(innerHTML(p[0]), 'Kevin', 'correct value for person().name');
                data.attr('name', 'Kevin Phillips');
                equal(innerHTML(p[0]), 'Kevin Phillips', 'updated value for person().name');
            });
            test('foo().bar - DefineMap', function () {
                var template = stache('<p>{{ person().name }}</p>');
                var div = doc.createElement('div');
                var data = new DefineMap({
                    name: 'Kevin',
                    person: function () {
                        return { name: this.name };
                    }
                });
                var dom = template(data);
                div.appendChild(dom);
                var p = div.getElementsByTagName('p');
                equal(innerHTML(p[0]), 'Kevin', 'correct value for person().name');
                data.name = 'Kevin Phillips';
                equal(innerHTML(p[0]), 'Kevin Phillips', 'updated value for person().name');
            });
            test('each values update when replaced in a can map (#62)', function () {
                var template = stache('{{#each this}}<p>{{.}}</p>{{/each}}');
                var div = doc.createElement('div');
                var vm = new CanMap({ foo: 'foo-value' });
                var dom = template(vm);
                div.appendChild(dom);
                vm.attr('foo', 'bar-value');
                var p = div.getElementsByTagName('p');
                equal(innerHTML(p[0]), 'bar-value', 'updated the value inside #each');
            });
            test('Bracket expression as argument to Call expression', function () {
                var template = stache('{{ foo([bar]) }}');
                var div = doc.createElement('div');
                var vm = new CanMap({
                    foo: function (key) {
                        return key + '!';
                    },
                    bar: 'name',
                    name: 'Kevin'
                });
                var dom = template(vm);
                div.appendChild(dom);
                equal(innerHTML(div), 'Kevin!', 'works');
            });
            test('Bracket expression with undefined value', function () {
                var template = stache('{{ place[\'place:name\'] }}');
                var div = doc.createElement('div');
                var vm = new CanMap({ 'place:name': 'foo' });
                var dom = template(vm);
                div.appendChild(dom);
                equal(innerHTML(div), '', 'empty');
                vm.attr('place', { 'place:name': 'bar' });
                equal(innerHTML(div), 'bar', 'updated');
            });
            test('Bracket expression in multi-argument helpers (Literals)', function () {
                var template = stache('{{#eq place[\'place:name\'] \'foo\' }}yes{{else}}no{{/eq}}');
                var div = doc.createElement('div');
                var vm = new CanMap({ place: { 'place:name': 'foo' } });
                var dom = template(vm);
                div.appendChild(dom);
                equal(innerHTML(div), 'yes', 'initially true');
                vm.attr('place.place:name', 'bar');
                equal(innerHTML(div), 'no', 'updated');
            });
            test('Bracket expression in multi-argument helpers (Lookups)', function () {
                var template = stache('{{#eq place[foo] foo }}yes{{else}}no{{/eq}}');
                var div = doc.createElement('div');
                var vm = new CanMap({
                    place: { 'foo': 'foo' },
                    foo: 'foo'
                });
                var dom = template(vm);
                div.appendChild(dom);
                equal(innerHTML(div), 'yes', 'initially true');
                vm.attr('place.foo', 'bar');
                equal(innerHTML(div), 'no', 'updated');
            });
            test('Bracket expression followed by bracket expression', function () {
                var template;
                var div = doc.createElement('div');
                template = stache('<p>{{ foo[bar][baz] }}</p>');
                var data = new CanMap({
                    baz: 'first',
                    bar: 'name',
                    foo: {
                        name: {
                            first: 'K',
                            last: 'P'
                        },
                        fullName: {
                            first: 'Kevin',
                            last: 'Phillips'
                        }
                    }
                });
                var dom = template(data);
                div.appendChild(dom);
                var p = div.getElementsByTagName('p');
                equal(innerHTML(p[0]), 'K', 'correct value for foo[bar][baz]');
                data.attr('bar', 'fullName');
                equal(innerHTML(p[0]), 'Kevin', 'updated value for bar in foo[bar][baz]');
                data.attr('baz', 'last');
                equal(innerHTML(p[0]), 'Phillips', 'updated value for baz in foo[bar][baz]');
            });
            test('Bracket expression with numeric index', function () {
                var template, dom, p;
                var div = doc.createElement('div');
                template = stache('<p>{{ foo[0] }}</p>');
                var data = new CanMap({
                    bar: [
                        'thud',
                        'jeek'
                    ],
                    foo: [
                        'baz',
                        'quux'
                    ]
                });
                dom = template(data);
                div.appendChild(dom);
                p = div.getElementsByTagName('p');
                equal(innerHTML(p[0]), 'baz', 'correct value for foo[0]');
                div.innerHTML = '';
                template = stache('<p>{{#each foo}}{{ bar[%index] }}{{/each}}</p>');
                dom = template(data);
                div.appendChild(dom);
                p = div.getElementsByTagName('p');
                equal(innerHTML(p[0]), 'thudjeek', 'correct value for bar[%index] when iterating foo (Map/List data)');
                div.innerHTML = '';
                dom = template(data.attr());
                div.appendChild(dom);
                p = div.getElementsByTagName('p');
                equal(innerHTML(p[0]), 'thudjeek', 'correct value for bar[%index] when iterating foo (plain object data)');
            });
            test('Bracket expression followed by Lookup expression', function () {
                var template;
                var div = doc.createElement('div');
                template = stache('<p>{{ foo[bar].first }}</p><p>{{#is foo[bar].first "K"}}short{{else}}long{{/is}}</p>');
                var data = new CanMap({
                    baz: 'first',
                    bar: 'name',
                    foo: {
                        name: { first: 'K' },
                        fullName: { first: 'Kevin' }
                    }
                });
                var dom = template(data);
                div.appendChild(dom);
                var p = div.getElementsByTagName('p');
                equal(innerHTML(p[0]), 'K', 'correct value for foo[bar].first');
                equal(innerHTML(p[1]), 'short', 'correct value for `is foo[bar].first "K"`');
                data.attr('bar', 'fullName');
                equal(innerHTML(p[0]), 'Kevin', 'updated value for foo[bar].first');
                equal(innerHTML(p[1]), 'long', 'updated value for `is foo[bar].first "K"`');
            });
            test('renderer itself is not observable', function () {
                var first = canCompute('Justin'), last = canCompute('Meyer');
                var renderer = stache('{{first}} {{last}}');
                var fullNameFrag = canCompute(function () {
                    return renderer({
                        first: first,
                        last: last
                    });
                });
                fullNameFrag.on('change', function () {
                    QUnit.ok(false);
                });
                this.fixture.appendChild(fullNameFrag());
                first('Josh');
                equal(this.fixture.innerHTML, 'Josh Meyer');
            });
            QUnit.test('content is registered (#163)', function () {
                QUnit.ok(viewCallbacks.tag('content'), 'registered content');
            });
        }
    }(function () {
        return this;
    }()));
});
/*can-stache-bindings@3.0.12#test/mock-component*/
define('can-stache-bindings@3.0.12#test/mock-component', function (require, exports, module) {
    var stacheBindings = require('can-stache-bindings');
    var CanMap = require('can-map');
    var viewCallbacks = require('can-view-callbacks');
    var Scope = require('can-view-scope');
    var nodeLists = require('can-view-nodelist');
    var domData = require('can-util/dom/data/data');
    var domMutate = require('can-util/dom/mutate/mutate');
    var MockComponent;
    module.exports = MockComponent = {
        extend: function (proto) {
            viewCallbacks.tag(proto.tag, function (el, componentTagData) {
                var viewModel;
                var teardownBindings = stacheBindings.behaviors.viewModel(el, componentTagData, function (initialViewModelData) {
                    if (typeof proto.viewModel === 'function') {
                        return viewModel = new proto.viewModel(initialViewModelData);
                    } else if (proto.viewModel instanceof CanMap) {
                        return viewModel = proto.viewModel;
                    } else {
                        var VM = CanMap.extend(proto.viewModel);
                        return viewModel = new VM(initialViewModelData);
                    }
                }, {});
                domData.set.call(el, 'viewModel', viewModel);
                domData.set.call(el, 'preventDataBindings', true);
                if (proto.template) {
                    var shadowScope = componentTagData.scope.add(new Scope.Refs()).add(viewModel, { viewModel: true });
                    domData.set.call(el, 'shadowScope', shadowScope);
                    var nodeList = nodeLists.register([], function () {
                        teardownBindings();
                    }, componentTagData.parentNodeList || true, false);
                    var frag = proto.template(shadowScope, componentTagData.options, nodeList);
                    domMutate.appendChild.call(el, frag);
                }
            });
        }
    };
});
/*can-stache-bindings@3.0.12#test/bindings-define-test*/
define('can-stache-bindings@3.0.12#test/bindings-define-test', function (require, exports, module) {
    require('can-stache-bindings');
    var QUnit = require('steal-qunit');
    var DefineMap = require('can-define/map/map');
    var stache = require('can-stache');
    var canViewModel = require('can-view-model');
    var define = require('can-define');
    var canEvent = require('can-event');
    var viewCallbacks = require('can-view-callbacks');
    var domAttr = require('can-util/dom/attr/attr');
    var domData = require('can-util/dom/data/data');
    var domDispatch = require('can-util/dom/dispatch/dispatch');
    var MockComponent = require('./mock-component');
    var viewModelFor = function (tag, viewModel) {
        viewCallbacks.tag(tag, function (el) {
            domData.set.call(el, 'viewModel', viewModel);
        });
    };
    QUnit.module('can-stache-bindings (can-define)');
    test('two way - viewModel', 7, function () {
        var ViewModel = define.Constructor({ vmProp: {} });
        MockComponent.extend({
            tag: 'two-way-viewmodel',
            viewModel: ViewModel
        });
        var template = stache('<two-way-viewmodel {(vm-prop)}="scopeProp" />');
        var Context = define.Constructor({ scopeProp: { value: 'Bing!' } });
        var context = new Context();
        var frag = template(context);
        var viewModel = canViewModel(frag.firstChild);
        ok(viewModel instanceof ViewModel, 'ViewModel is a can-define object');
        equal(viewModel.vmProp, 'Bing!', 'ViewModel property set via scope property set');
        equal(context.scopeProp, 'Bing!', 'Scope property is correct');
        viewModel.vmProp = 'Bang!';
        equal(viewModel.vmProp, 'Bang!', 'ViewModel property was set');
        equal(context.scopeProp, 'Bang!', 'Scope property set via viewModel property set');
        context.scopeProp = 'BOOM!';
        equal(context.scopeProp, 'BOOM!', 'Scope property was set');
        equal(viewModel.vmProp, 'BOOM!', 'ViewModel property set via scope property set');
    });
    test('one-way - parent to child - viewModel', function () {
        var VM = DefineMap.extend({ viewModelProp: '*' });
        viewModelFor('parent-to-child', new VM());
        var template = stache('<parent-to-child {view-model-prop}="scopeProp" />');
        var Context = define.Constructor({ scopeProp: { value: 'Venus' } });
        var context = new Context();
        var frag = template(context);
        var viewModel = canViewModel(frag.firstChild);
        equal(viewModel.viewModelProp, 'Venus', 'ViewModel property initially set from scope');
        viewModel.viewModelProp = 'Earth';
        equal(context.scopeProp, 'Venus', 'Scope property unchanged by viewModel set');
        context.scopeProp = 'Mars';
        equal(viewModel.viewModelProp, 'Mars', 'ViewModel property was set via scope set');
    });
    test('one-way - child to parent - viewModel', function () {
        var ViewModel = define.Constructor({ viewModelProp: { value: 'Mercury' } });
        MockComponent.extend({
            tag: 'view-model-able',
            viewModel: ViewModel
        });
        var template = stache('<view-model-able {^view-model-prop}="scopeProp" />');
        var Context = define.Constructor({ scopeProp: { value: 'Venus' } });
        var context = new Context();
        var frag = template(context);
        var viewModel = canViewModel(frag.firstChild);
        equal(viewModel.viewModelProp, 'Mercury', 'ViewModel property unchanged by scope property');
        equal(context.scopeProp, 'Mercury', 'Scope property initially set from viewModel');
        viewModel.viewModelProp = 'Earth';
        equal(context.scopeProp, 'Earth', 'Scope property set via viewModel set');
        context.scopeProp = 'Mars';
        equal(viewModel.viewModelProp, 'Earth', 'ViewModel property unchanged by scope set');
    });
    test('two-way - DOM - input text (#1700)', function () {
        var template = stache('<input {($value)}=\'age\'/>');
        var MyMap = define.Constructor({ age: { type: 'string' } });
        var map = new MyMap();
        var frag = template(map);
        var ta = document.getElementById('qunit-fixture');
        ta.appendChild(frag);
        var input = ta.getElementsByTagName('input')[0];
        equal(input.value, '', 'input value set correctly if key does not exist in map');
        map.age = 30;
        equal(input.value, '30', 'input value set correctly');
        map.age = '31';
        equal(input.value, '31', 'input value update correctly');
        input.value = '32';
        canEvent.trigger.call(input, 'change');
        equal(map.age, '32', 'updated from input');
    });
    test('Binding to a special property - values', function () {
        var template = stache('<select multiple {($values)}=\'values\'><option value=\'one\'>One</option><option value=\'two\'></option></select>');
        var map = new DefineMap({ values: [] });
        var slice = [].slice;
        var select = template(map).firstChild;
        var option1 = select.firstChild;
        var option2 = option1.nextSibling;
        option2.selected = true;
        canEvent.trigger.call(select, 'change');
        deepEqual(slice.call(map.values), ['two'], 'two is chosen');
        map.values = ['one'];
        equal(option1.selected, true, 'option1 selected');
        equal(option2.selected, false, 'option2 not selected');
    });
    test('Binding to a special property - option\'s selected', function () {
        var template = stache('<select><option {($selected)}=\'a\' value=\'one\'>One</option><option {($selected)}=\'b\' value=\'two\'>Two</option></select>');
        var map = new DefineMap({
            a: true,
            b: false
        });
        var select = template(map).firstChild;
        var option1 = select.firstChild;
        var option2 = option1.nextSibling;
        option2.selected = true;
        canEvent.trigger.call(select, 'change');
        equal(map.a, false, 'map.a false');
        equal(map.b, true, 'map.b true');
    });
    if (System.env !== 'canjs-test') {
        test('Can two way bind to focused', function () {
            stop();
            var template = stache('<input {($focused)}=\'show\' type=\'text\'/>');
            var map = new DefineMap({ show: false });
            var ta = document.getElementById('qunit-fixture');
            var frag = template(map);
            var input = frag.firstChild;
            ta.appendChild(frag);
            map.show = true;
            if (!document.hasFocus()) {
                domDispatch.call(input, 'focus');
            }
            setTimeout(function () {
                ok(input === document.activeElement, 'now focused');
                domAttr.set(input, 'focused', false);
                if (!document.hasFocus()) {
                    domDispatch.call(input, 'blur');
                }
                setTimeout(function () {
                    ok(input !== document.activeElement, 'not focused');
                    equal(map.show, false, 'set the boolean');
                    start();
                }, 50);
            }, 50);
        });
    }
    var supportsKeyboardEvents = function () {
        if (typeof KeyboardEvent !== 'undefined') {
            try {
                var supports = false;
                var el = document.createElement('div');
                el.addEventListener('keyup', function (ev) {
                    supports = ev.key === 'Enter';
                });
                var event = new KeyboardEvent('keyup', { key: 'Enter' });
                el.dispatchEvent(event);
                return supports;
            } catch (e) {
                return false;
            }
        } else {
            return false;
        }
    }();
    if (supportsKeyboardEvents) {
        QUnit.test('KeyboardEvent dispatching works with .key (#93)', function () {
            var template = stache('<input ($enter)=\'method(%event)\' type=\'text\'/>');
            var frag = template({
                method: function (event) {
                    QUnit.ok(true, 'method was called');
                }
            });
            var input = frag.firstChild;
            var event = new KeyboardEvent('keyup', { key: 'Enter' });
            input.dispatchEvent(event);
        });
    }
});
/*can-stache-bindings@3.0.12#test/bindings-test*/
define('can-stache-bindings@3.0.12#test/bindings-test', function (require, exports, module) {
    require('./bindings-define-test');
    var stacheBindings = require('can-stache-bindings');
    var QUnit = require('steal-qunit');
    var CanList = require('can-list');
    var CanMap = require('can-map');
    var stache = require('can-stache');
    var canEvent = require('can-event');
    var canBatch = require('can-event/batch/batch');
    var viewCallbacks = require('can-view-callbacks');
    var canCompute = require('can-compute');
    var canViewModel = require('can-view-model');
    require('can-util/dom/events/inserted/');
    var stacheExpression = require('can-stache/src/expression');
    var domData = require('can-util/dom/data/data');
    var domMutate = require('can-util/dom/mutate/mutate');
    var makeDocument = require('can-vdom/make-document/make-document');
    var MUTATION_OBSERVER = require('can-util/dom/mutation-observer/mutation-observer');
    var DOCUMENT = require('can-util/dom/document/document');
    var dev = require('can-util/js/dev/dev');
    var canEach = require('can-util/js/each/each');
    var types = require('can-types');
    var MockComponent = require('./mock-component');
    var DefaultMap = types.DefaultMap;
    var DOC = DOCUMENT();
    var MUT_OBS = MUTATION_OBSERVER();
    makeTest('can-stache-bindings - dom', document, MUT_OBS);
    makeTest('can-stache-bindings - vdom', makeDocument(), null);
    function makeTest(name, doc, mutObs) {
        var testIfRealDocument = function () {
            if (doc === document) {
                test.apply(null, arguments);
            }
        };
        var isRealDocument = function () {
            return doc === document;
        };
        QUnit.module(name, {
            setup: function () {
                DOCUMENT(doc);
                MUTATION_OBSERVER(mutObs);
                types.DefaultMap = CanMap;
                if (doc === document) {
                    this.fixture = document.getElementById('qunit-fixture');
                } else {
                    this.fixture = doc.createElement('qunit-fixture');
                    doc.body.appendChild(this.fixture);
                }
            },
            teardown: function () {
                if (doc !== document) {
                    doc.body.removeChild(this.fixture);
                }
                stop();
                setTimeout(function () {
                    start();
                    types.DefaultMap = DefaultMap;
                    DOCUMENT(DOC);
                    MUTATION_OBSERVER(MUT_OBS);
                }, 1);
            }
        });
        test('attributeNameInfo', function () {
            var info = stacheBindings.getBindingInfo({
                name: 'foo',
                value: 'bar'
            }, { foo: '@' }, 'legacy');
            deepEqual(info, {
                parent: 'attribute',
                child: 'viewModel',
                parentToChild: true,
                childToParent: true,
                childName: 'foo',
                parentName: 'foo',
                bindingAttributeName: 'foo'
            }, 'legacy with @');
            info = stacheBindings.getBindingInfo({
                name: 'foo-ed',
                value: 'bar'
            }, {}, 'legacy');
            deepEqual(info, {
                parent: 'scope',
                child: 'viewModel',
                parentToChild: true,
                childToParent: true,
                childName: 'fooEd',
                parentName: 'bar',
                bindingAttributeName: 'foo-ed'
            }, 'legacy');
            info = stacheBindings.getBindingInfo({
                name: 'foo-ed',
                value: 'bar'
            });
            deepEqual(info, {
                parent: 'attribute',
                child: 'viewModel',
                parentToChild: true,
                childToParent: true,
                childName: 'fooEd',
                parentName: 'foo-ed',
                bindingAttributeName: 'foo-ed'
            }, 'OG stache attr binding');
            info = stacheBindings.getBindingInfo({
                name: 'foo-ed',
                value: '{bar}'
            });
            deepEqual(info, {
                parent: 'scope',
                child: 'viewModel',
                parentToChild: true,
                childToParent: true,
                childName: 'fooEd',
                parentName: 'bar',
                bindingAttributeName: 'foo-ed'
            }, 'OG stache vm binding');
            info = stacheBindings.getBindingInfo({
                name: '{$foo-ed}',
                value: 'bar'
            });
            deepEqual(info, {
                parent: 'scope',
                child: 'attribute',
                childToParent: false,
                parentToChild: true,
                parentName: 'bar',
                childName: 'foo-ed',
                bindingAttributeName: '{$foo-ed}',
                initializeValues: true
            }, 'new el binding');
            info = stacheBindings.getBindingInfo({
                name: '{($foo-ed)}',
                value: 'bar'
            });
            deepEqual(info, {
                parent: 'scope',
                child: 'attribute',
                childToParent: true,
                parentToChild: true,
                parentName: 'bar',
                childName: 'foo-ed',
                bindingAttributeName: '{($foo-ed)}',
                initializeValues: true
            }, 'new el binding');
            info = stacheBindings.getBindingInfo({
                name: '{^$foo-ed}',
                value: 'bar'
            });
            deepEqual(info, {
                parent: 'scope',
                child: 'attribute',
                childToParent: true,
                parentToChild: false,
                parentName: 'bar',
                childName: 'foo-ed',
                bindingAttributeName: '{^$foo-ed}',
                initializeValues: true
            }, 'new el binding');
            info = stacheBindings.getBindingInfo({
                name: '{foo-ed}',
                value: 'bar'
            });
            deepEqual(info, {
                parent: 'scope',
                child: 'viewModel',
                parentToChild: true,
                childToParent: false,
                childName: 'fooEd',
                parentName: 'bar',
                bindingAttributeName: '{foo-ed}',
                initializeValues: true
            }, 'new vm binding');
            info = stacheBindings.getBindingInfo({
                name: '{(foo-ed)}',
                value: 'bar'
            });
            deepEqual(info, {
                parent: 'scope',
                child: 'viewModel',
                parentToChild: true,
                childToParent: true,
                childName: 'fooEd',
                parentName: 'bar',
                bindingAttributeName: '{(foo-ed)}',
                initializeValues: true
            }, 'new el binding');
            info = stacheBindings.getBindingInfo({
                name: '{^foo-ed}',
                value: 'bar'
            });
            deepEqual(info, {
                parent: 'scope',
                child: 'viewModel',
                parentToChild: false,
                childToParent: true,
                childName: 'fooEd',
                parentName: 'bar',
                bindingAttributeName: '{^foo-ed}',
                initializeValues: true
            }, 'new el binding');
        });
        var foodTypes = new CanList([
            {
                title: 'Fruits',
                content: 'oranges, apples'
            },
            {
                title: 'Breads',
                content: 'pasta, cereal'
            },
            {
                title: 'Sweets',
                content: 'ice cream, candy'
            }
        ]);
        if (typeof doc.getElementsByClassName === 'function') {
            test('can-event handlers', function () {
                var ta = this.fixture;
                var template = stache('<div>' + '{{#each foodTypes}}' + '<p can-click=\'doSomething\'>{{content}}</p>' + '{{/each}}' + '</div>');
                function doSomething(foodType, el, ev) {
                    ok(true, 'doSomething called');
                    equal(el.nodeName.toLowerCase(), 'p', 'this is the element');
                    equal(ev.type, 'click', '1st argument is the event');
                    equal(foodType, foodTypes[0], '2nd argument is the 1st foodType');
                }
                var frag = template({
                    foodTypes: foodTypes,
                    doSomething: doSomething
                });
                ta.appendChild(frag);
                var p0 = ta.getElementsByTagName('p')[0];
                canEvent.trigger.call(p0, 'click');
            });
            test('can-event special keys', function () {
                var scope = new CanMap({ test: 'testval' });
                var ta = this.fixture;
                MockComponent.extend({
                    tag: 'can-event-args-tester',
                    viewModel: scope
                });
                var template = stache('<div>' + '{{#each foodTypes}}' + '<can-event-args-tester class=\'with-args\' can-click=\'{withArgs @event @element @viewModel @viewModel.test . title content=content}\'/>' + '{{/each}}' + '</div>');
                function withArgs(ev1, el1, compScope, testVal, context, title, hash) {
                    ok(true, 'withArgs called');
                    equal(el1.nodeName.toLowerCase(), 'can-event-args-tester', '@element is the event\'s DOM element');
                    equal(ev1.type, 'click', '@event is the click event');
                    equal(scope, compScope, 'Component scope accessible through @viewModel');
                    equal(testVal, scope.attr('test'), 'Attributes accessible');
                    equal(context.title, foodTypes[0].title, 'Context passed in');
                    equal(title, foodTypes[0].title, 'Title passed in');
                    equal(hash.content, foodTypes[0].content, 'Args with = passed in as a hash');
                }
                var frag = template({
                    foodTypes: foodTypes,
                    withArgs: withArgs
                });
                ta.innerHTML = '';
                ta.appendChild(frag);
                var p0 = ta.getElementsByClassName('with-args')[0];
                canEvent.trigger.call(p0, 'click');
            });
            test('(event) handlers', 12, function () {
                var ta = this.fixture;
                var template = stache('<div>' + '{{#each foodTypes}}' + '<p ($click)=\'doSomething\'>{{content}}</p>' + '{{/each}}' + '</div>');
                var foodTypes = new CanList([
                    {
                        title: 'Fruits',
                        content: 'oranges, apples'
                    },
                    {
                        title: 'Breads',
                        content: 'pasta, cereal'
                    },
                    {
                        title: 'Sweets',
                        content: 'ice cream, candy'
                    }
                ]);
                function doSomething(foodType, el, ev) {
                    ok(true, 'doSomething called');
                    equal(el.nodeName.toLowerCase(), 'p', 'this is the element');
                    equal(ev.type, 'click', '1st argument is the event');
                    equal(foodType, foodTypes[0], '2nd argument is the 1st foodType');
                }
                var frag = template({
                    foodTypes: foodTypes,
                    doSomething: doSomething
                });
                ta.appendChild(frag);
                var p0 = ta.getElementsByTagName('p')[0];
                canEvent.trigger.call(p0, 'click');
                var scope = new CanMap({ test: 'testval' });
                MockComponent.extend({
                    tag: 'fancy-event-args-tester',
                    viewModel: scope
                });
                template = stache('<div>' + '{{#each foodTypes}}' + '<fancy-event-args-tester class=\'with-args\' ($click)=\'withArgs @event @element @viewModel @viewModel.test . title content=content\'/>' + '{{/each}}' + '</div>');
                function withArgs(ev1, el1, compScope, testVal, context, title, hash) {
                    ok(true, 'withArgs called');
                    equal(el1.nodeName.toLowerCase(), 'fancy-event-args-tester', '@element is the event\'s DOM element');
                    equal(ev1.type, 'click', '@event is the click event');
                    equal(scope, compScope, 'Component scope accessible through @viewModel');
                    equal(testVal, scope.attr('test'), 'Attributes accessible');
                    equal(context.title, foodTypes[0].title, 'Context passed in');
                    equal(title, foodTypes[0].title, 'Title passed in');
                    equal(hash.content, foodTypes[0].content, 'Args with = passed in as a hash');
                }
                frag = template({
                    foodTypes: foodTypes,
                    withArgs: withArgs
                });
                ta.innerHTML = '';
                ta.appendChild(frag);
                p0 = ta.getElementsByClassName('with-args')[0];
                canEvent.trigger.call(p0, 'click');
            });
        }
        test('can-value input text', function () {
            var template = stache('<input can-value=\'age\'/>');
            var map = new CanMap();
            var frag = template(map);
            var ta = this.fixture;
            ta.appendChild(frag);
            var input = ta.getElementsByTagName('input')[0];
            equal(input.value, '', 'input value set correctly if key does not exist in map');
            map.attr('age', '30');
            equal(input.value, '30', 'input value set correctly');
            map.attr('age', '31');
            equal(input.value, '31', 'input value update correctly');
            input.value = '32';
            canEvent.trigger.call(input, 'change');
            equal(map.attr('age'), '32', 'updated from input');
        });
        test('can-value with spaces (#1477)', function () {
            var template = stache('<input can-value=\'{ age }\'/>');
            var map = new CanMap();
            var frag = template(map);
            var ta = this.fixture;
            ta.appendChild(frag);
            var input = ta.getElementsByTagName('input')[0];
            equal(input.value, '', 'input value set correctly if key does not exist in map');
            map.attr('age', '30');
            equal(input.value, '30', 'input value set correctly');
            map.attr('age', '31');
            equal(input.value, '31', 'input value update correctly');
            input.value = '32';
            canEvent.trigger.call(input, 'change');
            equal(map.attr('age'), '32', 'updated from input');
        });
        test('can-value input radio', function () {
            var template = stache('<input type=\'radio\' can-value=\'color\' value=\'red\'/> Red<br/>' + '<input type=\'radio\' can-value=\'color\' value=\'green\'/> Green<br/>');
            var map = new CanMap({ color: 'red' });
            var frag = template(map);
            var ta = this.fixture;
            ta.appendChild(frag);
            var inputs = ta.getElementsByTagName('input');
            ok(inputs[0].checked, 'first input checked');
            ok(!inputs[1].checked, 'second input not checked');
            map.attr('color', 'green');
            ok(!inputs[0].checked, 'first notinput checked');
            ok(inputs[1].checked, 'second input checked');
            inputs[0].checked = true;
            inputs[1].checked = false;
            canEvent.trigger.call(inputs[0], 'change');
            equal(map.attr('color'), 'red', 'updated from input');
        });
        test('can-enter', function () {
            var template = stache('<input can-enter=\'update\'/>');
            var called = 0;
            var frag = template({
                update: function () {
                    called++;
                    ok(called, 1, 'update called once');
                }
            });
            var input = frag.childNodes.item(0);
            canEvent.trigger.call(input, {
                type: 'keyup',
                keyCode: 38
            });
            canEvent.trigger.call(input, {
                type: 'keyup',
                keyCode: 13
            });
        });
        test('two bindings on one element call back the correct method', function () {
            expect(2);
            var template = stache('<input can-mousemove=\'first\' can-click=\'second\'/>');
            var callingFirst = false, callingSecond = false;
            var frag = template({
                first: function () {
                    ok(callingFirst, 'called first');
                },
                second: function () {
                    ok(callingSecond, 'called second');
                }
            });
            var input = frag.childNodes.item(0);
            callingFirst = true;
            canEvent.trigger.call(input, { type: 'mousemove' });
            callingFirst = false;
            callingSecond = true;
            canEvent.trigger.call(input, { type: 'click' });
        });
        test('can-value select remove from DOM', function () {
            stop();
            expect(1);
            var template = stache('<select can-value=\'color\'>' + '<option value=\'red\'>Red</option>' + '<option value=\'green\'>Green</option>' + '</select>'), frag = template(), ta = this.fixture;
            domMutate.appendChild.call(ta, frag);
            domMutate.removeChild.call(ta, ta.firstChild);
            setTimeout(function () {
                start();
                ok(true, 'Nothing should break if we just add and then remove the select');
            }, 10);
        });
        test('checkboxes with can-value bind properly (#628)', function () {
            var data = new CanMap({ completed: true }), frag = stache('<input type="checkbox" can-value="completed"/>')(data);
            domMutate.appendChild.call(this.fixture, frag);
            var input = this.fixture.getElementsByTagName('input')[0];
            equal(input.checked, data.attr('completed'), 'checkbox value bound (via attr check)');
            data.attr('completed', false);
            equal(input.checked, data.attr('completed'), 'checkbox value bound (via attr uncheck)');
            input.checked = true;
            canEvent.trigger.call(input, 'change');
            equal(input.checked, true, 'checkbox value bound (via check)');
            equal(data.attr('completed'), true, 'checkbox value bound (via check)');
            input.checked = false;
            canEvent.trigger.call(input, 'change');
            equal(input.checked, false, 'checkbox value bound (via uncheck)');
            equal(data.attr('completed'), false, 'checkbox value bound (via uncheck)');
        });
        test('checkboxes with can-true-value bind properly', function () {
            var data = new CanMap({ sex: 'male' }), frag = stache('<input type="checkbox" can-value="sex" can-true-value="male" can-false-value="female"/>')(data);
            domMutate.appendChild.call(this.fixture, frag);
            var input = this.fixture.getElementsByTagName('input')[0];
            stop();
            setTimeout(function () {
                start();
                equal(input.checked, true, 'checkbox value bound (via attr check)');
                data.attr('sex', 'female');
                equal(input.checked, false, 'checkbox value unbound (via attr uncheck)');
                input.checked = true;
                canEvent.trigger.call(input, 'change');
                equal(input.checked, true, 'checkbox value bound (via check)');
                equal(data.attr('sex'), 'male', 'checkbox value bound (via check)');
                input.checked = false;
                canEvent.trigger.call(input, 'change');
                equal(input.checked, false, 'checkbox value bound (via uncheck)');
                equal(data.attr('sex'), 'female', 'checkbox value bound (via uncheck)');
            }, 10);
        });
        testIfRealDocument('can-value select single', function () {
            var template = stache('<select can-value=\'color\'>' + '<option value=\'red\'>Red</option>' + '<option value=\'green\'>Green</option>' + '</select>');
            var map = new CanMap({ color: 'red' });
            var frag = template(map);
            var ta = this.fixture;
            ta.appendChild(frag);
            var inputs = ta.getElementsByTagName('select');
            equal(inputs[0].value, 'red', 'default value set');
            map.attr('color', 'green');
            equal(inputs[0].value, 'green', 'alternate value set');
            canEach(ta.getElementsByTagName('option'), function (opt) {
                if (opt.value === 'red') {
                    opt.selected = 'selected';
                }
            });
            equal(map.attr('color'), 'green', 'not yet updated from input');
            canEvent.trigger.call(inputs[0], 'change');
            equal(map.attr('color'), 'red', 'updated from input');
            canEach(ta.getElementsByTagName('option'), function (opt) {
                if (opt.value === 'green') {
                    opt.selected = 'selected';
                }
            });
            equal(map.attr('color'), 'red', 'not yet updated from input');
            canEvent.trigger.call(inputs[0], 'change');
            equal(map.attr('color'), 'green', 'updated from input');
        });
        testIfRealDocument('can-value select multiple with values cross bound to an array', function () {
            var template = stache('<select can-value=\'colors\' multiple>' + '<option value=\'red\'>Red</option>' + '<option value=\'green\'>Green</option>' + '<option value=\'ultraviolet\'>Ultraviolet</option>' + '</select>');
            var map = new CanMap({});
            stop();
            var frag = template(map);
            var ta = this.fixture;
            ta.appendChild(frag);
            var select = ta.getElementsByTagName('select')[0], options = select.getElementsByTagName('option');
            setTimeout(function () {
                options[0].selected = true;
                canEvent.trigger.call(select, 'change');
                deepEqual(map.attr('colors').attr(), ['red'], 'A CanList property is set even if none existed');
                options[1].selected = true;
                canEvent.trigger.call(select, 'change');
                deepEqual(map.attr('colors').attr(), [
                    'red',
                    'green'
                ], 'Adds items to the list');
                options[0].selected = false;
                canEvent.trigger.call(select, 'change');
                deepEqual(map.attr('colors').attr(), ['green'], 'Removes items from the list');
                map.attr('colors').push('ultraviolet');
                options[0].selected = false;
                options[1].selected = true;
                options[2].selected = true;
                ta.removeChild(select);
                start();
            }, 1);
        });
        testIfRealDocument('can-value multiple select with a CanList', function () {
            var template = stache('<select can-value=\'colors\' multiple>' + '<option value=\'red\'>Red</option>' + '<option value=\'green\'>Green</option>' + '<option value=\'ultraviolet\'>Ultraviolet</option>' + '</select>');
            var list = new CanList();
            stop();
            var frag = template({ colors: list });
            var ta = this.fixture;
            ta.appendChild(frag);
            var select = ta.getElementsByTagName('select')[0], options = select.getElementsByTagName('option');
            setTimeout(function () {
                options[0].selected = true;
                canEvent.trigger.call(select, 'change');
                deepEqual(list.attr(), ['red'], 'A CanList property is set even if none existed');
                options[1].selected = true;
                canEvent.trigger.call(select, 'change');
                deepEqual(list.attr(), [
                    'red',
                    'green'
                ], 'Adds items to the list');
                options[0].selected = false;
                canEvent.trigger.call(select, 'change');
                deepEqual(list.attr(), ['green'], 'Removes items from the list');
                list.push('ultraviolet');
                options[0].selected = false;
                options[1].selected = true;
                options[2].selected = true;
                ta.removeChild(select);
                start();
            }, 1);
        });
        test('can-value contenteditable', function () {
            var template = stache('<div id=\'cdiv\' contenteditable can-value=\'age\'></div>');
            var map = new CanMap();
            var frag = template(map);
            var ta = this.fixture;
            ta.appendChild(frag);
            var div = doc.getElementById('cdiv');
            equal(div.innerHTML, '', 'contenteditable set correctly if key does not exist in map');
            map.attr('age', '30');
            equal(div.innerHTML, '30', 'contenteditable set correctly');
            map.attr('age', '31');
            equal(div.innerHTML, '31', 'contenteditable update correctly');
            div.innerHTML = '32';
            canEvent.trigger.call(div, 'blur');
            equal(map.attr('age'), '32', 'updated from contenteditable');
        });
        test('can-event handlers work with {} (#905)', function () {
            expect(4);
            var template = stache('<div>' + '{{#each foodTypes}}' + '<p can-click=\'{doSomething}\'>{{content}}</p>' + '{{/each}}' + '</div>');
            var foodTypes = new CanList([
                {
                    title: 'Fruits',
                    content: 'oranges, apples'
                },
                {
                    title: 'Breads',
                    content: 'pasta, cereal'
                },
                {
                    title: 'Sweets',
                    content: 'ice cream, candy'
                }
            ]);
            var doSomething = function (foodType, el, ev) {
                ok(true, 'doSomething called');
                equal(el.nodeName.toLowerCase(), 'p', 'this is the element');
                equal(ev.type, 'click', '1st argument is the event');
                equal(foodType, foodTypes[0], '2nd argument is the 1st foodType');
            };
            var frag = template({
                foodTypes: foodTypes,
                doSomething: doSomething
            });
            var ta = this.fixture;
            ta.appendChild(frag);
            var p0 = ta.getElementsByTagName('p')[0];
            canEvent.trigger.call(p0, 'click');
        });
        test('can-value works with {} (#905)', function () {
            var template = stache('<input can-value=\'{age}\'/>');
            var map = new CanMap();
            var frag = template(map);
            var ta = this.fixture;
            ta.appendChild(frag);
            var input = ta.getElementsByTagName('input')[0];
            equal(input.value, '', 'input value set correctly if key does not exist in map');
            map.attr('age', '30');
            equal(input.value, '30', 'input value set correctly');
            map.attr('age', '31');
            equal(input.value, '31', 'input value update correctly');
            input.value = '32';
            canEvent.trigger.call(input, 'change');
            equal(map.attr('age'), '32', 'updated from input');
        });
        test('can-value select with null or undefined value (#813)', function () {
            var template = stache('<select id=\'null-select\' can-value=\'color-1\'>' + '<option value=\'\'>Choose</option>' + '<option value=\'red\'>Red</option>' + '<option value=\'green\'>Green</option>' + '</select>' + '<select id=\'undefined-select\' can-value=\'color-2\'>' + '<option value=\'\'>Choose</option>' + '<option value=\'red\'>Red</option>' + '<option value=\'green\'>Green</option>' + '</select>');
            var map = new CanMap({
                'color-1': null,
                'color-2': undefined
            });
            stop();
            var frag = template(map);
            var ta = this.fixture;
            ta.appendChild(frag);
            var nullInput = doc.getElementById('null-select');
            var nullInputOptions = nullInput.getElementsByTagName('option');
            var undefinedInput = doc.getElementById('undefined-select');
            var undefinedInputOptions = undefinedInput.getElementsByTagName('option');
            setTimeout(function () {
                ok(nullInputOptions[0].selected, 'default (null) value set');
                ok(undefinedInputOptions[0].selected, 'default (undefined) value set');
                start();
            }, 50);
        });
        test('radio type conversion (#811)', function () {
            var data = new CanMap({ id: 1 }), frag = stache('<input type="radio" can-value="id" value="1"/>')(data);
            domMutate.appendChild.call(this.fixture, frag);
            var input = this.fixture.getElementsByTagName('input')[0];
            ok(input.checked, 'checkbox value bound');
        });
        test('template with view binding breaks in stache, not in mustache (#966)', function () {
            var templateString = '<a href="javascript://" can-click="select">' + '{{#if thing}}\n<div />{{/if}}' + '<span>{{name}}</span>' + '</a>';
            var stacheRenderer = stache(templateString);
            var obj = new CanMap({ thing: 'stuff' });
            stacheRenderer(obj);
            ok(true, 'stache worked without errors');
        });
        test('can-event throws an error when inside #if block (#1182)', function (assert) {
            var done = assert.async();
            var flag = canCompute(false), clickHandlerCount = 0;
            var frag = stache('<div {{#if flag}}can-click=\'foo\'{{/if}}>Click</div>')({
                flag: flag,
                foo: function () {
                    clickHandlerCount++;
                }
            });
            var fixture = this.fixture;
            var trig = function () {
                var div = fixture.getElementsByTagName('div')[0];
                canEvent.trigger.call(div, { type: 'click' });
            };
            domMutate.appendChild.call(this.fixture, frag);
            trig();
            setTimeout(function () {
                equal(clickHandlerCount, 0, 'click handler not called');
                done();
            }, 50);
        });
        testIfRealDocument('can-EVENT removed in live bindings doesn\'t unbind (#1112)', function () {
            var flag = canCompute(true), clickHandlerCount = 0;
            var frag = stache('<div {{#if flag}}can-click=\'foo\'{{/if}}>Click</div>')({
                flag: flag,
                foo: function () {
                    clickHandlerCount++;
                }
            });
            var testEnv = this;
            var trig = function () {
                var div = testEnv.fixture.getElementsByTagName('div')[0];
                canEvent.trigger.call(div, { type: 'click' });
            };
            domMutate.appendChild.call(this.fixture, frag);
            stop();
            var numTrigs = 3;
            var testTimer = setInterval(function () {
                if (numTrigs--) {
                    trig();
                    flag(!flag());
                } else {
                    clearTimeout(testTimer);
                    equal(clickHandlerCount, 2, 'click handler called twice');
                    start();
                }
            }, 100);
        });
        test('can-value compute rejects new value (#887)', function () {
            var template = stache('<input can-value=\'age\'/>');
            var compute = canCompute(30, function (newVal, oldVal) {
                if (isNaN(+newVal)) {
                    return oldVal;
                } else {
                    return +newVal;
                }
            });
            var frag = template({ age: compute });
            var ta = this.fixture;
            ta.appendChild(frag);
            var input = ta.getElementsByTagName('input')[0];
            input.value = '30f';
            canEvent.trigger.call(input, 'change');
            equal(compute(), 30, 'Still the old value');
            equal(input.value, '30', 'Text input has also not changed');
        });
        testIfRealDocument('can-value select multiple applies initial value, when options rendered from array (#1414)', function () {
            var template = stache('<select can-value=\'colors\' multiple>' + '{{#each allColors}}<option value=\'{{value}}\'>{{label}}</option>{{/each}}' + '</select>');
            var map = new CanMap({
                colors: [
                    'red',
                    'green'
                ],
                allColors: [
                    {
                        value: 'red',
                        label: 'Red'
                    },
                    {
                        value: 'green',
                        label: 'Green'
                    },
                    {
                        value: 'blue',
                        label: 'Blue'
                    }
                ]
            });
            stop();
            var frag = template(map);
            var ta = this.fixture;
            ta.appendChild(frag);
            var select = ta.getElementsByTagName('select')[0], options = select.getElementsByTagName('option');
            setTimeout(function () {
                ok(options[0].selected, 'red should be set initially');
                ok(options[1].selected, 'green should be set initially');
                ok(!options[2].selected, 'blue should not be set initially');
                start();
            }, 1);
        });
        test('can-value with truthy and falsy values binds to checkbox (#1478)', function () {
            var data = new CanMap({ completed: 1 }), frag = stache('<input type="checkbox" can-value="completed"/>')(data);
            domMutate.appendChild.call(this.fixture, frag);
            var input = this.fixture.getElementsByTagName('input')[0];
            equal(input.checked, true, 'checkbox value bound (via attr check)');
            data.attr('completed', 0);
            equal(input.checked, false, 'checkbox value bound (via attr check)');
        });
        test('can-EVENT can call intermediate functions before calling the final function (#1474)', function () {
            var ta = this.fixture;
            var template = stache('<div id=\'click-me\' can-click=\'{does.some.thing}\'></div>');
            var frag = template({
                does: function () {
                    return {
                        some: function () {
                            return {
                                thing: function (context) {
                                    ok(typeof context.does === 'function');
                                    start();
                                }
                            };
                        }
                    };
                }
            });
            stop();
            ta.appendChild(frag);
            canEvent.trigger.call(doc.getElementById('click-me'), 'click');
        });
        test('by default can-EVENT calls with values, not computes', function () {
            stop();
            var ta = this.fixture;
            var template = stache('<div id=\'click-me\' can-click=\'{map.method one map.two map.three}\'></div>');
            var one = canCompute(1);
            var three = canCompute(3);
            var MyMap = CanMap.extend({
                method: function (ONE, two, three) {
                    equal(ONE, 1);
                    equal(two, 2);
                    equal(three, 3);
                    equal(this, map, 'this set right');
                    start();
                }
            });
            var map = new MyMap({
                'two': 2,
                'three': three
            });
            var frag = template({
                one: one,
                map: map
            });
            ta.appendChild(frag);
            canEvent.trigger.call(doc.getElementById('click-me'), 'click');
        });
        test('Conditional can-EVENT bindings are bound/unbound', 2, function () {
            var state = new CanMap({
                enableClick: true,
                clickHandler: function () {
                    ok(true, '"click" was handled');
                }
            });
            var template = stache('<button id="find-me" {{#if enableClick}}can-click="{clickHandler}"{{/if}}></button>');
            var frag = template(state);
            var sandbox = this.fixture;
            sandbox.appendChild(frag);
            var btn = doc.getElementById('find-me');
            canEvent.trigger.call(btn, 'click');
            state.attr('enableClick', false);
            stop();
            setTimeout(function () {
                canEvent.trigger.call(btn, 'click');
                state.attr('enableClick', true);
                setTimeout(function () {
                    canEvent.trigger.call(btn, 'click');
                    start();
                }, 100);
            }, 100);
        });
        testIfRealDocument('<select can-value={value}> with undefined value selects option without value', function () {
            var template = stache('<select can-value=\'opt\'><option>Loading...</option></select>');
            var map = new CanMap();
            var frag = template(map);
            var ta = this.fixture;
            ta.appendChild(frag);
            var select = ta.childNodes.item(0);
            QUnit.equal(select.selectedIndex, 0, 'Got selected index');
        });
        testIfRealDocument('<select can-value> keeps its value as <option>s change with {{#list}} (#1762)', function () {
            var template = stache('<select can-value=\'{id}\'>{{#values}}<option value=\'{{.}}\'>{{.}}</option>{{/values}}</select>');
            var values = canCompute([
                '1',
                '2',
                '3',
                '4'
            ]);
            var id = canCompute('2');
            var frag = template({
                values: values,
                id: id
            });
            stop();
            var select = frag.firstChild;
            setTimeout(function () {
                ok(select.childNodes.item(1).selected, 'value is initially selected');
                values([
                    '7',
                    '2',
                    '5',
                    '4'
                ]);
                ok(select.childNodes.item(1).selected, 'after changing options, value should still be selected');
                start();
            }, 20);
        });
        testIfRealDocument('<select can-value> keeps its value as <option>s change with {{#each}} (#1762)', function () {
            var template = stache('<select can-value=\'{id}\'>{{#each values}}<option value=\'{{.}}\'>{{.}}</option>{{/values}}</select>');
            var values = canCompute([
                '1',
                '2',
                '3',
                '4'
            ]);
            var id = canCompute('2');
            var frag = template({
                values: values,
                id: id
            });
            stop();
            var select = frag.firstChild;
            setTimeout(function () {
                ok(select.childNodes.item(1).selected, 'value is initially selected');
                values([
                    '7',
                    '2',
                    '5',
                    '4'
                ]);
                ok(select.childNodes.item(1).selected, 'after changing options, value should still be selected');
                start();
            }, 20);
        });
        test('(event) methods on objects are called (#1839)', function () {
            var template = stache('<div ($click)=\'setSomething person.message\'/>');
            var data = {
                setSomething: function (message) {
                    equal(message, 'Matthew P finds good bugs');
                    equal(this, data, 'setSomething called with correct scope');
                },
                person: {
                    name: 'Matthew P',
                    message: function () {
                        return this.name + ' finds good bugs';
                    }
                }
            };
            var frag = template(data);
            canEvent.trigger.call(frag.firstChild, 'click');
        });
        test('(event) methods on objects are called with call expressions (#1839)', function () {
            var template = stache('<div ($click)=\'setSomething(person.message)\'/>');
            var data = {
                setSomething: function (message) {
                    equal(message, 'Matthew P finds good bugs');
                    equal(this, data, 'setSomething called with correct scope');
                },
                person: {
                    name: 'Matthew P',
                    message: function () {
                        return this.name + ' finds good bugs';
                    }
                }
            };
            var frag = template(data);
            canEvent.trigger.call(frag.firstChild, 'click');
        });
        test('two way - viewModel (#1700)', function () {
            MockComponent.extend({ tag: 'view-model-able' });
            var template = stache('<div {(view-model-prop)}=\'scopeProp\'/>');
            var attrSetCalled = 0;
            var map = new CanMap({ scopeProp: 'Hello' });
            var oldAttr = map.attr;
            map.attr = function (attrName, value) {
                if (typeof attrName === 'string' && arguments.length > 1) {
                    attrSetCalled++;
                }
                return oldAttr.apply(this, arguments);
            };
            var frag = template(map);
            var viewModel = canViewModel(frag.firstChild);
            equal(attrSetCalled, 0, 'set is not called on scope map');
            equal(viewModel.attr('viewModelProp'), 'Hello', 'initial value set');
            viewModel = canViewModel(frag.firstChild);
            var viewModelAttrSetCalled = 1;
            viewModel.attr = function (attrName) {
                if (typeof attrName === 'string' && arguments.length > 1) {
                    viewModelAttrSetCalled++;
                }
                return oldAttr.apply(this, arguments);
            };
            viewModel.attr('viewModelProp', 'HELLO');
            equal(map.attr('scopeProp'), 'HELLO', 'binding from child to parent');
            equal(attrSetCalled, 1, 'set is called once on scope map');
            equal(viewModelAttrSetCalled, 3, 'set is called once viewModel');
            map.attr('scopeProp', 'WORLD');
            equal(viewModel.attr('viewModelProp'), 'WORLD', 'binding from parent to child');
            equal(attrSetCalled, 2, 'set is called once on scope map');
            equal(viewModelAttrSetCalled, 4, 'set is called once on viewModel');
        });
        test('two-way - DOM - input text (#1700)', function () {
            var template = stache('<input {($value)}=\'age\'/>');
            var map = new CanMap();
            var frag = template(map);
            var ta = this.fixture;
            ta.appendChild(frag);
            var input = ta.getElementsByTagName('input')[0];
            equal(input.value, '', 'input value set correctly if key does not exist in map');
            map.attr('age', '30');
            stop();
            setTimeout(function () {
                start();
                equal(input.value, '30', 'input value set correctly');
                map.attr('age', '31');
                stop();
                setTimeout(function () {
                    start();
                    equal(input.value, '31', 'input value update correctly');
                    input.value = '32';
                    canEvent.trigger.call(input, 'change');
                    stop();
                    setTimeout(function () {
                        start();
                        equal(map.attr('age'), '32', 'updated from input');
                    }, 10);
                }, 10);
            }, 10);
        });
        test('two-way - DOM - {($checked)} with truthy and falsy values binds to checkbox (#1700)', function () {
            var data = new CanMap({ completed: 1 }), frag = stache('<input type="checkbox" {($checked)}="completed"/>')(data);
            domMutate.appendChild.call(this.fixture, frag);
            var input = this.fixture.getElementsByTagName('input')[0];
            equal(input.checked, true, 'checkbox value bound (via attr check)');
            data.attr('completed', 0);
            stop();
            setTimeout(function () {
                start();
                equal(input.checked, false, 'checkbox value bound (via attr check)');
            }, 10);
        });
        test('two-way - reference - {(child)}="*ref" (#1700)', function () {
            var data = new CanMap({ person: { name: {} } });
            MockComponent.extend({
                tag: 'reference-export',
                viewModel: { tag: 'reference-export' }
            });
            MockComponent.extend({
                tag: 'ref-import',
                viewModel: { tag: 'ref-import' }
            });
            var template = stache('<reference-export {(name)}=\'*refName\'/>' + '<ref-import {(name)}=\'*refName\'/> {{helperToGetScope}}');
            var scope;
            var frag = template(data, {
                helperToGetScope: function (options) {
                    scope = options.scope;
                }
            });
            var refExport = canViewModel(frag.firstChild);
            var refImport = canViewModel(frag.firstChild.nextSibling);
            refExport.attr('name', 'v1');
            equal(scope.getRefs()._context.attr('*refName'), 'v1', 'reference scope updated');
            equal(refImport.attr('name'), 'v1', 'updated ref-import');
            refImport.attr('name', 'v2');
            equal(refExport.attr('name'), 'v2', 'updated ref-export');
            equal(scope.getRefs()._context.attr('*refName'), 'v2', 'actually put in refs scope');
        });
        test('two-way - reference shorthand (#1700)', function () {
            var data = new CanMap({ person: { name: {} } });
            MockComponent.extend({
                tag: 'reference-export',
                template: stache('<span>{{*referenceExport.name}}</span>'),
                viewModel: {}
            });
            var template = stache('{{#person}}{{#name}}' + '<reference-export *reference-export/>' + '{{/name}}{{/person}}<span>{{*referenceExport.name}}</span>');
            var frag = template(data);
            var refExport = canViewModel(frag.firstChild);
            refExport.attr('name', 'done');
            equal(frag.lastChild.firstChild.nodeValue, 'done');
            equal(frag.firstChild.firstChild.firstChild.nodeValue, '', 'not done');
        });
        test('one-way - parent to child - viewModel', function () {
            var template = stache('<div {view-model-prop}=\'scopeProp\'/>');
            var map = new CanMap({ scopeProp: 'Venus' });
            var frag = template(map);
            var viewModel = canViewModel(frag.firstChild);
            equal(viewModel.attr('viewModelProp'), 'Venus', 'initial value set');
            viewModel.attr('viewModelProp', 'Earth');
            equal(map.attr('scopeProp'), 'Venus', 'no binding from child to parent');
            map.attr('scopeProp', 'Mars');
            equal(viewModel.attr('viewModelProp'), 'Mars', 'binding from parent to child');
        });
        test('one-way - child to parent - viewModel', function () {
            MockComponent.extend({
                tag: 'view-model-able',
                viewModel: { viewModelProp: 'Mercury' }
            });
            var template = stache('<view-model-able {^view-model-prop}=\'scopeProp\'/>');
            var map = new CanMap({ scopeProp: 'Venus' });
            var frag = template(map);
            var viewModel = canViewModel(frag.firstChild);
            equal(viewModel.attr('viewModelProp'), 'Mercury', 'initial value kept');
            equal(map.attr('scopeProp'), 'Mercury', 'initial value set on parent');
            viewModel.attr('viewModelProp', 'Earth');
            equal(map.attr('scopeProp'), 'Earth', 'binding from child to parent');
            map.attr('scopeProp', 'Mars');
            equal(viewModel.attr('viewModelProp'), 'Earth', 'no binding from parent to child');
        });
        test('one way - child to parent - importing viewModel {^.}="test"', function () {
            MockComponent.extend({
                tag: 'import-scope',
                template: stache('Hello {{name}}'),
                viewModel: {
                    name: 'David',
                    age: 7
                }
            });
            MockComponent.extend({
                tag: 'import-parent',
                template: stache('<import-scope {^.}="test"></import-scope>' + '<div>Imported: {{test.name}} {{test.age}}</div>')
            });
            var template = stache('<import-parent></import-parent>');
            var frag = template({});
            equal(frag.childNodes.item(0).childNodes.item(1).innerHTML, 'Imported: David 7', '{.} component scope imported into variable');
        });
        test('one way - child to parent - importing viewModel {^prop}="test"', function () {
            MockComponent.extend({
                tag: 'import-prop-scope',
                template: stache('Hello {{name}}'),
                viewModel: {
                    name: 'David',
                    age: 7
                }
            });
            MockComponent.extend({
                tag: 'import-prop-parent',
                template: stache('<import-prop-scope {^name}="test"></import-prop-scope>' + '<div>Imported: {{test}}</div>')
            });
            var template = stache('<import-prop-parent></import-prop-parent>');
            var frag = template({});
            equal(frag.childNodes.item(0).childNodes.item(1).innerHTML, 'Imported: David', '{name} component scope imported into variable');
        });
        test('one way - child to parent - importing viewModel {^hypenated-prop}="test"', function () {
            MockComponent.extend({
                tag: 'import-prop-scope',
                template: stache('Hello {{userName}}'),
                viewModel: {
                    userName: 'David',
                    age: 7,
                    updateName: function () {
                        this.attr('userName', 'Justin');
                    }
                }
            });
            MockComponent.extend({
                tag: 'import-prop-parent',
                template: stache('<import-prop-scope {^user-name}="test" {^.}="childComponent"></import-prop-scope>' + '<div>Imported: {{test}}</div>')
            });
            var template = stache('<import-prop-parent></import-prop-parent>');
            var frag = template({});
            var importPropParent = frag.firstChild;
            var importPropScope = importPropParent.getElementsByTagName('import-prop-scope')[0];
            canViewModel(importPropScope).updateName();
            var importPropParentViewModel = canViewModel(importPropParent);
            equal(importPropParentViewModel.attr('test'), 'Justin', 'got hypenated prop');
            equal(importPropParentViewModel.attr('childComponent'), canViewModel(importPropScope), 'got view model');
        });
        test('viewModel binding (event)', function () {
            MockComponent.extend({
                tag: 'viewmodel-binding',
                viewModel: {
                    makeMyEvent: function () {
                        this.dispatch('myevent');
                    }
                }
            });
            var frag = stache('<viewmodel-binding (myevent)=\'doSomething()\'/>')({
                doSomething: function () {
                    ok(true, 'called!');
                }
            });
            canViewModel(frag.firstChild).makeMyEvent();
        });
        test('checkboxes with {($checked)} bind properly', function () {
            var data = new CanMap({ completed: true }), frag = stache('<input type="checkbox" {($checked)}="completed"/>')(data);
            domMutate.appendChild.call(this.fixture, frag);
            var input = this.fixture.getElementsByTagName('input')[0];
            equal(input.checked, data.attr('completed'), 'checkbox value bound (via attr check)');
            data.attr('completed', false);
            equal(input.checked, data.attr('completed'), 'checkbox value bound (via attr uncheck)');
            input.checked = true;
            canEvent.trigger.call(input, 'change');
            stop();
            setTimeout(function () {
                start();
                equal(input.checked, true, 'checkbox value bound (via check)');
                equal(data.attr('completed'), true, 'checkbox value bound (via check)');
                input.checked = false;
                canEvent.trigger.call(input, 'change');
                stop();
                setTimeout(function () {
                    start();
                    equal(input.checked, false, 'checkbox value bound (via uncheck)');
                    equal(data.attr('completed'), false, 'checkbox value bound (via uncheck)');
                }, 10);
            }, 10);
        });
        test('two-way element empty value (1996)', function () {
            var template = stache('<input can-value=\'age\'/>');
            var map = new CanMap();
            var frag = template(map);
            var ta = this.fixture;
            ta.appendChild(frag);
            var input = ta.getElementsByTagName('input')[0];
            equal(input.value, '', 'input value set correctly if key does not exist in map');
            map.attr('age', '30');
            equal(input.value, '30', 'input value set correctly');
            map.attr('age', '31');
            equal(input.value, '31', 'input value update correctly');
            input.value = '';
            canEvent.trigger.call(input, 'change');
            equal(map.attr('age'), '', 'updated from input');
        });
        test('exporting methods (#2051)', function () {
            expect(2);
            MockComponent.extend({
                tag: 'foo-bar',
                viewModel: {
                    method: function () {
                        ok(true, 'foo called');
                        return 5;
                    }
                }
            });
            var template = stache('<foo-bar {^@method}=\'@*refKey\'></foo-bar>{{*refKey()}}');
            var frag = template({});
            equal(frag.lastChild.nodeValue, '5');
        });
        test('renders dynamic custom attributes (#1800)', function () {
            var template = stache('<ul>{{#actions}}<li can-click=\'{{.}}\'>{{.}}</li>{{/actions}}</ul>');
            var map = new CanMap({
                actions: [
                    'action1',
                    'action2'
                ],
                action1: function () {
                    equal(calling, 0, 'action1');
                },
                action2: function () {
                    equal(calling, 1, 'action2');
                }
            });
            var frag = template(map), lis = frag.firstChild.getElementsByTagName('li');
            var calling = 0;
            canEvent.trigger.call(lis[0], 'click');
            calling = 1;
            canEvent.trigger.call(lis[1], 'click');
        });
        if (System.env.indexOf('production') < 0) {
            test('warning on a mismatched quote (#1995)', function () {
                expect(4);
                var oldlog = dev.warn, message = 'can/view/bindings/bindings.js: mismatched binding syntax - (foo}';
                dev.warn = function (text) {
                    equal(text, message, 'Got expected message logged.');
                };
                stache('<div (foo}=\'bar\'/>')();
                message = 'can/view/bindings/bindings.js: mismatched binding syntax - {foo)';
                stache('<div {foo)=\'bar\'/>')();
                message = 'can/view/bindings/bindings.js: mismatched binding syntax - {(foo})';
                stache('<div {(foo})=\'bar\'/>')();
                message = 'can/view/bindings/bindings.js: mismatched binding syntax - ({foo})';
                stache('<div ({foo})=\'bar\'/>')();
                dev.warn = oldlog;
            });
        }
        testIfRealDocument('One way binding from a select\'s value to a parent compute updates the parent with the select\'s initial value (#2027)', function () {
            var template = stache('<select {^$value}=\'value\'><option value=\'One\'>One</option></select>');
            var map = new CanMap();
            var frag = template(map);
            var select = frag.childNodes.item(0);
            setTimeout(function () {
                equal(select.selectedIndex, 0, 'selectedIndex is 0 because no value exists on the map');
                equal(map.attr('value'), 'One', 'The map\'s value property is set to the select\'s value');
                start();
            }, 50);
            stop();
        });
        testIfRealDocument('two way binding from a select\'s value to null has no selection (#2027)', function () {
            var template = stache('<select {($value)}=\'key\'><option value=\'One\'>One</option></select>');
            var map = new CanMap({ key: null });
            var frag = template(map);
            var select = frag.childNodes.item(0);
            setTimeout(function () {
                equal(select.selectedIndex, -1, 'selectedIndex is 0 because no value exists on the map');
                equal(map.attr('key'), null, 'The map\'s value property is set to the select\'s value');
                start();
            }, 50);
            stop();
        });
        testIfRealDocument('two-way bound values that do not match a select option set selectedIndex to -1 (#2027)', function () {
            var renderer = stache('<select {($value)}="key"><option value="foo">foo</option><option value="bar">bar</option></select>');
            var map = new CanMap({});
            var frag = renderer(map);
            equal(frag.firstChild.selectedIndex, 0, 'undefined <- {($first value)}: selectedIndex = 0');
            map.attr('key', 'notfoo');
            stop();
            setTimeout(function () {
                start();
                equal(frag.firstChild.selectedIndex, -1, 'notfoo: selectedIndex = -1');
                map.attr('key', 'foo');
                strictEqual(frag.firstChild.selectedIndex, 0, 'foo: selectedIndex = 0');
                map.attr('key', 'notbar');
                stop();
                setTimeout(function () {
                    start();
                    equal(frag.firstChild.selectedIndex, -1, 'notbar: selectedIndex = -1');
                    map.attr('key', 'bar');
                    strictEqual(frag.firstChild.selectedIndex, 1, 'bar: selectedIndex = 1');
                    map.attr('key', 'bar');
                    strictEqual(frag.firstChild.selectedIndex, 1, 'bar (no change): selectedIndex = 1');
                }, 10);
            }, 10);
        });
        testIfRealDocument('two way bound select empty string null or undefined value (#2027)', function () {
            var template = stache('<select id=\'null-select\' {($value)}=\'color-1\'>' + '<option value=\'\'>Choose</option>' + '<option value=\'red\'>Red</option>' + '<option value=\'green\'>Green</option>' + '</select>' + '<select id=\'undefined-select\' {($value)}=\'color-2\'>' + '<option value=\'\'>Choose</option>' + '<option value=\'red\'>Red</option>' + '<option value=\'green\'>Green</option>' + '</select>' + '<select id=\'string-select\' {($value)}=\'color-3\'>' + '<option value=\'\'>Choose</option>' + '<option value=\'red\'>Red</option>' + '<option value=\'green\'>Green</option>' + '</select>');
            var map = new CanMap({
                'color-1': null,
                'color-2': undefined,
                'color-3': ''
            });
            stop();
            var frag = template(map);
            domMutate.appendChild.call(this.fixture, frag);
            var nullInput = doc.getElementById('null-select');
            var nullInputOptions = nullInput.getElementsByTagName('option');
            var undefinedInput = doc.getElementById('undefined-select');
            var undefinedInputOptions = undefinedInput.getElementsByTagName('option');
            var stringInput = doc.getElementById('string-select');
            var stringInputOptions = stringInput.getElementsByTagName('option');
            setTimeout(function () {
                ok(!nullInputOptions[0].selected, 'default (null) value set');
                ok(undefinedInputOptions[0].selected, 'default (undefined) value set');
                ok(stringInputOptions[0].selected, 'default (\'\') value set');
                start();
            }, 50);
        });
        if (System.env !== 'canjs-test') {
            test('dynamic attribute bindings (#2016)', function (assert) {
                var done = assert.async();
                var template = stache('<input {($value)}=\'{{propName}}\'/>');
                var map = new CanMap({
                    propName: 'first',
                    first: 'Justin',
                    last: 'Meyer'
                });
                var frag = template(map);
                var ta = this.fixture;
                ta.appendChild(frag);
                var input = ta.getElementsByTagName('input')[0];
                setTimeout(function () {
                    equal(input.value, 'Justin', 'input value set correctly if key does not exist in map');
                    map.attr('propName', 'last');
                    setTimeout(function () {
                        equal(input.value, 'Meyer', 'input value set correctly if key does not exist in map');
                        input.value = 'Lueke';
                        canEvent.trigger.call(input, 'change');
                        setTimeout(function () {
                            equal(map.attr('last'), 'Lueke', 'updated from input');
                            done();
                        }, 50);
                    }, 50);
                }, 50);
            });
        }
        test('select bindings respond to changes immediately or during insert (#2134)', function () {
            var countries = [
                {
                    code: 'MX',
                    countryName: 'MEXICO'
                },
                {
                    code: 'US',
                    countryName: 'USA'
                },
                {
                    code: 'IND',
                    countryName: 'INDIA'
                },
                {
                    code: 'RUS',
                    countryName: 'RUSSIA'
                }
            ];
            var template = stache('<select {($value)}="countryCode">' + '{{#each countries}}' + '<option value="{{code}}">{{countryName}}</option>' + '{{/each}}' + '</select>');
            var data = new CanMap({
                countryCode: 'US',
                countries: countries
            });
            var frag = template(data);
            data.attr('countryCode', 'IND');
            stop();
            setTimeout(function () {
                start();
                equal(frag.firstChild.value, 'IND', 'got last updated value');
            }, 10);
        });
        test('select bindings respond to changes immediately or during insert using can-value (#2134)', function () {
            var countries = [
                {
                    code: 'MX',
                    countryName: 'MEXICO'
                },
                {
                    code: 'US',
                    countryName: 'USA'
                },
                {
                    code: 'IND',
                    countryName: 'INDIA'
                },
                {
                    code: 'RUS',
                    countryName: 'RUSSIA'
                }
            ];
            var template = stache('<select can-value="{countryCode}">' + '{{#each countries}}' + '<option value="{{code}}">{{countryName}}</option>' + '{{/each}}' + '</select>');
            var data = new CanMap({
                countryCode: 'US',
                countries: countries
            });
            var frag = template(data);
            data.attr('countryCode', 'IND');
            stop();
            setTimeout(function () {
                start();
                equal(frag.firstChild.value, 'IND', 'got last updated value');
            }, 10);
        });
        testIfRealDocument('two-way <select> bindings update to `undefined` if options are replaced (#1762)', function () {
            var countries = [
                {
                    code: 'MX',
                    countryName: 'MEXICO'
                },
                {
                    code: 'US',
                    countryName: 'USA'
                }
            ];
            var data = new CanMap({
                countryCode: 'US',
                countries: countries
            });
            var template = stache('<select {($value)}="countryCode">' + '{{#countries}}' + '<option value="{{code}}">{{countryName}}</option>' + '{{/countries}}' + '</select>');
            template(data);
            stop();
            setTimeout(function () {
                data.attr('countries').replace([]);
                setTimeout(function () {
                    equal(data.attr('countryCode'), undefined, 'countryCode set to undefined');
                    start();
                }, 10);
            }, 10);
        });
        testIfRealDocument('two-way <select> bindings update to `undefined` if options are replaced - each (#1762)', function () {
            var countries = [
                {
                    code: 'MX',
                    countryName: 'MEXICO'
                },
                {
                    code: 'US',
                    countryName: 'USA'
                }
            ];
            var data = new CanMap({
                countryCode: 'US',
                countries: countries
            });
            var template = stache('<select {($value)}="countryCode">' + '{{#each countries}}' + '<option value="{{code}}">{{countryName}}</option>' + '{{/each}}' + '</select>');
            template(data);
            stop();
            setTimeout(function () {
                data.attr('countries').replace([]);
                setTimeout(function () {
                    equal(data.attr('countryCode'), undefined, 'countryCode set to undefined');
                    start();
                }, 10);
            }, 10);
        });
        test('previously non-existing select value gets selected from a list when it is added (#1762)', function () {
            var template = stache('<select {($value)}="{person}">' + '<option></option>' + '{{#each people}}<option value="{{.}}">{{.}}</option>{{/each}}' + '</select>' + '<input type="text" size="5" {($value)}="person">');
            var people = new CanList([
                'Alexis',
                'Mihael',
                'Curtis',
                'David'
            ]);
            var vm = new CanMap({
                person: 'Brian',
                people: people
            });
            stop();
            vm.bind('person', function (ev, newVal, oldVal) {
                ok(false, 'person attribute should not change');
            });
            var frag = template(vm);
            equal(vm.attr('person'), 'Brian', 'Person is still set');
            setTimeout(function () {
                people.push('Brian');
                setTimeout(function () {
                    var select = frag.firstChild;
                    ok(select.lastChild.selected, 'New child should be selected');
                    start();
                }, 20);
            }, 20);
        });
        test('one-way <select> bindings keep value if options are replaced (#1762)', function () {
            var countries = [
                {
                    code: 'MX',
                    countryName: 'MEXICO'
                },
                {
                    code: 'US',
                    countryName: 'USA'
                }
            ];
            var data = new CanMap({
                countryCode: 'US',
                countries: countries
            });
            var template = stache('<select {$value}="countryCode">' + '{{#countries}}' + '<option value="{{code}}">{{countryName}}</option>' + '{{/countries}}' + '</select>');
            var frag = template(data);
            var select = frag.firstChild;
            stop();
            setTimeout(function () {
                data.attr('countries').replace([]);
                setTimeout(function () {
                    data.attr('countries').replace(countries);
                    equal(data.attr('countryCode'), 'US', 'country kept as USA');
                    setTimeout(function () {
                        ok(select.getElementsByTagName('option')[1].selected, 'USA still selected');
                    }, 10);
                    start();
                }, 10);
            }, 10);
        });
        test('one-way <select> bindings keep value if options are replaced - each (#1762)', function () {
            var countries = [
                {
                    code: 'MX',
                    countryName: 'MEXICO'
                },
                {
                    code: 'US',
                    countryName: 'USA'
                }
            ];
            var data = new CanMap({
                countryCode: 'US',
                countries: countries
            });
            var template = stache('<select {$value}="countryCode">' + '{{#each countries}}' + '<option value="{{code}}">{{countryName}}</option>' + '{{/each}}' + '</select>');
            var frag = template(data);
            var select = frag.firstChild;
            stop();
            setTimeout(function () {
                data.attr('countries').replace([]);
                setTimeout(function () {
                    data.attr('countries').replace(countries);
                    equal(data.attr('countryCode'), 'US', 'country kept as USA');
                    setTimeout(function () {
                        ok(select.getElementsByTagName('option')[1].selected, 'USA still selected');
                    }, 10);
                    start();
                }, 10);
            }, 10);
        });
        test('@function reference to child (#2116)', function () {
            expect(2);
            var template = stache('<foo-bar {@child}="@parent"></foo-bar>');
            MockComponent.extend({
                tag: 'foo-bar',
                viewModel: {
                    method: function () {
                        ok(false, 'should not be called');
                    }
                }
            });
            var VM = CanMap.extend({
                parent: function () {
                    ok(false, 'should not be called');
                }
            });
            var vm = new VM({});
            var frag = template(vm);
            equal(typeof canViewModel(frag.firstChild).attr('child'), 'function', 'to child binding');
            template = stache('<foo-bar {^@method}="@vmMethod"></foo-bar>');
            vm = new VM({});
            template(vm);
            ok(typeof vm.attr('vmMethod') === 'function', 'parent export function');
        });
        test('setter only gets called once (#2117)', function () {
            expect(1);
            var VM = CanMap.extend({
                _set: function (prop, val) {
                    if (prop === 'bar') {
                        equal(val, 'BAR');
                    }
                    return CanMap.prototype._set.apply(this, arguments);
                }
            });
            MockComponent.extend({
                tag: 'foo-bar',
                viewModel: VM
            });
            var template = stache('<foo-bar {bar}="bar"/>');
            template(new CanMap({ bar: 'BAR' }));
        });
        test('function reference to child binding (#2116)', function () {
            expect(2);
            var template = stache('<foo-bar {child}="@parent"></foo-bar>');
            MockComponent.extend({
                tag: 'foo-bar',
                viewModel: {}
            });
            var VM = CanMap.extend({});
            var vm = new VM({});
            var frag = template(vm);
            vm.attr('parent', function () {
                ok(false, 'should not be called');
            });
            equal(typeof canViewModel(frag.firstChild).attr('child'), 'function', 'to child binding');
            template = stache('<foo-bar {^@method}="vmMethod"></foo-bar>');
            vm = new VM({});
            frag = template(vm);
            canViewModel(frag.firstChild).attr('method', function () {
                ok(false, 'method should not be called');
            });
            equal(typeof vm.attr('vmMethod'), 'function', 'parent export function');
        });
        test('backtrack path in to-parent bindings (#2132)', function () {
            MockComponent.extend({
                tag: 'parent-export',
                viewModel: { value: 'VALUE' }
            });
            var template = stache('{{#innerMap}}<parent-export {^value}=\'../parentValue\'/>{{/innerMap}}');
            var data = new CanMap({ innerMap: {} });
            template(data);
            equal(data.attr('parentValue'), 'VALUE', 'set on correct context');
            equal(data.attr('innerMap.parentValue'), undefined, 'nothing on innerMap');
        });
        test('two-way binding with empty strings (#2147)', function () {
            var template = stache('<select {($value)}=\'val\'>' + '<option value="">Loading...</option>' + '<option>Empty...</option>' + '</select>');
            var map = new CanMap({
                foo: true,
                val: ''
            });
            var frag = template(map);
            setTimeout(function () {
                equal(frag.firstChild.value, '', 'is an empty string');
                if (isRealDocument()) {
                    equal(frag.firstChild.selectedIndex, 0, 'empty strings are bound');
                }
                start();
            }, 10);
            stop();
        });
        test('double render with batched / unbatched events (#2223)', function () {
            var template = stache('{{#page}}{{doLog}}<input {($value)}=\'notAHelper\'/>{{/page}}');
            var appVM = new CanMap();
            var logCalls = 0;
            stache.registerHelper('doLog', function () {
                logCalls++;
            });
            template(appVM);
            canBatch.start();
            appVM.attr('page', true);
            canBatch.stop();
            appVM.attr('notAHelper', 'bar');
            stop();
            setTimeout(function () {
                start();
                equal(logCalls, 1, 'input rendered the right number of times');
            }, 10);
        });
        test('Child bindings updated before parent (#2252)', function () {
            var template = stache('{{#eq page \'view\'}}<child-binder {page}=\'page\'/>{{/eq}}');
            MockComponent.extend({
                tag: 'child-binder',
                template: stache('<span/>'),
                viewModel: {
                    _set: function (prop, val) {
                        if (prop === 'page') {
                            equal(val, 'view', 'value should not be edit');
                        }
                        return CanMap.prototype._set.apply(this, arguments);
                    }
                }
            });
            var vm = new CanMap({ page: 'view' });
            template(vm);
            canBatch.start();
            vm.attr('page', 'edit');
            canBatch.stop();
        });
        test('Child bindings updated before parent (#2252)', function () {
            var template = stache('{{#eq page \'view\'}}<child-binder {page}=\'page\'/>{{/eq}}');
            MockComponent.extend({
                tag: 'child-binder',
                template: stache('<span/>'),
                viewModel: {
                    _set: function (prop, val) {
                        if (prop === 'page') {
                            equal(val, 'view', 'value should not be edit');
                        }
                        return CanMap.prototype._set.apply(this, arguments);
                    }
                }
            });
            var vm = new CanMap({ page: 'view' });
            template(vm);
            canBatch.start();
            vm.attr('page', 'edit');
            canBatch.stop();
        });
        test('can-value memory leak (#2270)', function () {
            var template = stache('<div><input can-value="foo"></div>');
            var vm = new CanMap({ foo: '' });
            var frag = template(vm);
            var ta = this.fixture;
            domMutate.appendChild.call(ta, frag);
            domMutate.removeChild.call(ta, ta.firstChild);
            stop();
            setTimeout(function () {
                equal(vm._bindings, 0, 'no bindings');
                start();
            }, 100);
        });
        test('converters work (#2299)', function () {
            stache.registerHelper('numberToString', function (newVal, source) {
                if (newVal instanceof stacheExpression.SetIdentifier) {
                    source(newVal.value === '' ? null : +newVal.value);
                } else {
                    source = newVal;
                    return source() + '';
                }
            });
            var template = stache('<input {($value)}="numberToString(~age)">');
            var map = new CanMap({ age: 25 });
            var frag = template(map);
            equal(frag.firstChild.value, '25');
            equal(map.attr('age'), 25);
            map.attr('age', 33);
            equal(frag.firstChild.value, '33');
            equal(map.attr('age'), 33);
            frag.firstChild.value = '1';
            canEvent.trigger.call(frag.firstChild, 'change');
            stop();
            setTimeout(function () {
                start();
                equal(frag.firstChild.value, '1');
                equal(map.attr('age'), 1);
            }, 10);
        });
        test('Multi-select empty string works(#1263)', function () {
            var data = {
                isMultiple: 1,
                isSelect: 1,
                name: 'attribute_ 0',
                options: [
                    {
                        label: 'empty',
                        value: ''
                    },
                    {
                        label: 'zero',
                        value: 0
                    },
                    {
                        label: 'one',
                        value: 1
                    },
                    {
                        label: 'two',
                        value: 2
                    },
                    {
                        label: 'three',
                        value: 3
                    },
                    {
                        label: 'four',
                        value: 4
                    }
                ],
                value: [1]
            };
            var template = stache('<select {{#if isMultiple}}multiple{{/if}} can-value=\'value\'> ' + '{{#each options}} <option value=\'{{value}}\' >{{label}}</option>{{/each}} </select>');
            var frag = template(new CanMap(data));
            equal(frag.firstChild.getElementsByTagName('option')[0].selected, false, 'The first empty value is not selected');
        });
        test('$element is wrapped with types.wrapElement', function () {
            var $ = function (element) {
                this.element = element;
            };
            var wrapElement = types.wrapElement, unwrapElement = types.unwrapElement;
            types.wrapElement = function (element) {
                return new $(element);
            };
            types.unwrapElement = function (object) {
                return object.element;
            };
            var template = stache('<button ($click)=\'doSomething($element)\'>Clicky</button>');
            var MyMap = DefaultMap.extend({
                doSomething: function (element) {
                    types.wrapElement = wrapElement;
                    types.unwrapElement = unwrapElement;
                    ok(element instanceof $);
                }
            });
            var button = template(new MyMap()).firstChild;
            canEvent.trigger.call(button, 'click');
        });
        if (System.env.indexOf('production') < 0) {
            test('No warn on id=\'{{foo}}\' or class=\'{{bar}}\' expressions', function () {
                var _warn = dev.warn;
                dev.warn = function () {
                    ok(false, 'dev.warn was called incorrectly');
                    _warn.apply(dev, arguments);
                };
                try {
                    delete viewCallbacks._tags['special-attrs'];
                    expect(2);
                    MockComponent.extend({
                        tag: 'special-attrs',
                        viewModel: {
                            foo: 'skippy',
                            baz: 'xyzzy'
                        }
                    });
                    stache('<special-attrs id=\'{{foo}}\' class=\'{{baz}}\'></div>')({
                        foo: 'bar',
                        baz: 'quux'
                    });
                    stache('<special-attrs id=\'foo\' class=\'baz\'></div>')({
                        foo: 'bar',
                        baz: 'quux'
                    });
                    dev.warn = function () {
                        ok(true, 'dev.warn was called correctly');
                        _warn.apply(dev, arguments);
                    };
                    stache('<special-attrs id=\'{foo}\' class=\'{baz}\'></div>')({
                        foo: 'bar',
                        baz: 'quux'
                    });
                } finally {
                    dev.warn = _warn;
                }
            });
        }
        test('one-way pass computes to components with ~', function (assert) {
            expect(7);
            MockComponent.extend({ tag: 'foo-bar' });
            var baseVm = new CanMap({ foo: 'bar' });
            this.fixture.appendChild(stache('<foo-bar {compute}="~foo"></foo-bar>')(baseVm));
            var vm = canViewModel(this.fixture.firstChild);
            ok(vm.attr('compute').isComputed, 'Compute returned');
            equal(vm.attr('compute')(), 'bar', 'Compute has correct value');
            vm.attr('compute').bind('change', function () {
                ok(true, 'Change handler called');
            });
            baseVm.attr('foo', 'quux');
            equal(vm.attr('compute')(), 'quux', 'Compute updates');
            vm.attr('compute')('xyzzy');
            equal(baseVm.attr('foo'), 'quux', 'Compute does not update the other direction');
            vm.attr('compute', 'notACompute');
            baseVm.attr('foo', 'thud');
            ok(vm.attr('compute').isComputed, 'Back to being a compute');
        });
        test('special values get called', function (assert) {
            assert.expect(2);
            var done = assert.async(1);
            MockComponent.extend({
                tag: 'ref-syntax',
                template: stache('<input ($change)="%scope.attr(\'*foo\', $element.value)">'),
                viewModel: new CanMap({
                    method: function () {
                        assert.ok(true, 'method called');
                        done();
                    }
                })
            });
            var template = stache('<ref-syntax ($inserted)="%viewModel.method()"></ref-syntax>');
            var frag = template({});
            domMutate.appendChild.call(this.fixture, frag);
            var input = doc.getElementsByTagName('input')[0];
            input.value = 'bar';
            canEvent.trigger.call(input, 'change');
            var scope = domData.get.call(this.fixture.firstChild).shadowScope;
            assert.equal(scope.get('*foo'), 'bar', 'Reference attribute set');
        });
        test('%arguments gives the event arguments', function () {
            var template = stache('<button ($click)=\'doSomething(%event, %arguments)\'>Default Args</button>');
            var MyMap = DefaultMap.extend({
                doSomething: function (ev, args) {
                    equal(args[0], ev, 'default arg is ev');
                }
            });
            var frag = template(new MyMap());
            var button = frag.firstChild;
            canEvent.trigger.call(button, 'click');
        });
    }
});
/*can@3.4.1#view/stache/stache_test*/
define('can@3.4.1#view/stache/stache_test', function (require, exports, module) {
    require('can-stache/test/stache-test');
    require('can-stache-bindings/test/bindings-test');
});
/*can-util@3.3.2#js/string-to-any/string-to-any*/
define('can-util@3.3.2#js/string-to-any/string-to-any', function (require, exports, module) {
    module.exports = function (str) {
        switch (str) {
        case 'NaN':
        case 'Infinity':
            return +str;
        case 'null':
            return null;
        case 'undefined':
            return undefined;
        case 'true':
        case 'false':
            return str === 'true';
        default:
            var val = +str;
            if (!isNaN(val)) {
                return val;
            } else {
                return str;
            }
        }
    };
});
/*can-stache-converters@3.0.7#can-stache-converters*/
define('can-stache-converters@3.0.7#can-stache-converters', function (require, exports, module) {
    var stache = require('can-stache');
    var stringToAny = require('can-util/js/string-to-any/string-to-any');
    require('can-stache-bindings');
    stache.registerConverter('boolean-to-inList', {
        get: function (item, list) {
            if (!list) {
                return false;
            } else {
                return list.indexOf(item) !== -1;
            }
        },
        set: function (newVal, item, list) {
            if (!list) {
                return;
            }
            if (!newVal) {
                var idx = list.indexOf(item);
                if (idx !== -1) {
                    list.splice(idx, 1);
                }
            } else {
                list.push(item);
            }
        }
    });
    stache.registerConverter('string-to-any', {
        get: function (compute) {
            return '' + compute();
        },
        set: function (newVal, compute) {
            var converted = stringToAny(newVal);
            compute(converted);
        }
    });
    stache.registerConverter('not', {
        get: function (compute) {
            return !compute();
        },
        set: function (newVal, compute) {
            compute(!newVal);
        }
    });
    stache.registerConverter('index-to-selected', {
        get: function (item, list) {
            var val = item.isComputed ? item() : item;
            var idx = list.indexOf(val);
            return idx;
        },
        set: function (idx, item, list) {
            var newVal = list[idx];
            if (newVal !== -1 && item.isComputed) {
                item(newVal);
            }
        }
    });
    stache.registerConverter('either-or', {
        get: function (chosen, a, b) {
            return b !== chosen();
        },
        set: function (newVal, chosen, a, b) {
            chosen(newVal ? a : b);
        }
    });
    stache.registerConverter('equal', {
        get: function (compute, comparer) {
            var val = compute && compute.isComputed ? compute() : compute;
            return val === comparer;
        },
        set: function (b, compute, comparer) {
            if (b) {
                compute(comparer);
            }
        }
    });
});
/*can-stache-converters@3.0.7#test/boolean-to-inList_test*/
define('can-stache-converters@3.0.7#test/boolean-to-inList_test', function (require, exports, module) {
    require('can-stache-converters');
    var canEvent = require('can-event');
    var DefineList = require('can-define/list/list');
    var DefineMap = require('can-define/map/map');
    var stache = require('can-stache');
    var each = require('can-util/js/each/each');
    var QUnit = require('steal-qunit');
    QUnit.module('boolean-to-inList');
    QUnit.test('Works with checkboxes', function () {
        var template = stache('<input type=\'checkbox\' {($checked)}=\'boolean-to-inList(item, list)\' />');
        var map = new DefineMap({
            item: 2,
            list: new DefineList([
                1,
                2,
                3
            ])
        });
        var frag = template(map);
        var input = frag.firstChild;
        QUnit.ok(input.checked, 'it is initially checked');
        QUnit.equal(map.list.indexOf(2), 1, 'two is in the list');
        input.checked = false;
        canEvent.trigger.call(input, 'change');
        QUnit.equal(map.list.indexOf(2), -1, 'No longer in the list');
        map.item = 3;
        QUnit.ok(input.checked, '3 is in the list');
        map.item = 5;
        QUnit.ok(!input.checked, '5 is not in the list');
        map.list.push(5);
        QUnit.ok(input.checked, 'Now 5 is in the list');
        map.item = 6;
        input.checked = true;
        canEvent.trigger.call(input, 'change');
        QUnit.equal(map.list.indexOf(6), 3, 'pushed into the list');
    });
    QUnit.test('If there is no list, treated as false', function () {
        var template = stache('<input type=\'checkbox\' {($checked)}=\'boolean-to-inList(item, list)\' />');
        var map = new DefineMap({
            item: 2,
            list: undefined
        });
        var frag = template(map);
        var input = frag.firstChild;
        QUnit.ok(!input.checked, 'not checked because there is no list');
        input.checked = true;
        canEvent.trigger.call(input, 'change');
        QUnit.ok(true, 'no errors thrown');
    });
    QUnit.test('works with radio buttons', function () {
        var template = stache('<form><input type=\'radio\' name=\'name\' value=\'Matthew\' {($checked)}=\'boolean-to-inList("Matthew", names)\' /><input type=\'radio\' name=\'name\' value=\'Wilbur\' {($checked)}=\'boolean-to-inList("Wilbur", names)\' /></form>');
        var map = new DefineMap({ names: ['Wilbur'] });
        var frag = template(map);
        var radioOne = frag.firstChild.firstChild;
        var radioTwo = radioOne.nextSibling;
        QUnit.equal(radioOne.checked, false, 'Matthew not checked');
        QUnit.equal(radioTwo.checked, true, 'Wilbur is checked');
        radioOne.checked = true;
        canEvent.trigger.call(radioOne, 'change');
        QUnit.equal(radioOne.checked, true, 'Matthew is checked');
        QUnit.equal(radioTwo.checked, false, 'Wilbur is not checked');
    });
});
/*can-stache-converters@3.0.7#test/index-to-selected_test*/
define('can-stache-converters@3.0.7#test/index-to-selected_test', function (require, exports, module) {
    require('can-stache-converters');
    var canEvent = require('can-event');
    var DefineList = require('can-define/list/list');
    var DefineMap = require('can-define/map/map');
    var stache = require('can-stache');
    var each = require('can-util/js/each/each');
    var QUnit = require('steal-qunit');
    QUnit.module('index-to-selected');
    QUnit.test('chooses select option by the index from a list', function () {
        var template = stache('<select {($value)}="index-to-selected(~person, people)"><option value="none"></option>{{#each people}}<option value="{{%index}}">{{name}}</option>{{/each}}</select>');
        var map = new DefineMap({
            person: 'Anne',
            people: [
                'Matthew',
                'Anne',
                'Wilbur'
            ]
        });
        var select = template(map).firstChild;
        QUnit.equal(select.value, 1, 'initially set to the first value');
        select.value = 2;
        canEvent.trigger.call(select, 'change');
        QUnit.equal(map.person, 'Wilbur', 'now it is me');
        map.person = map.people.item(0);
        QUnit.equal(select.value, 0, 'set back');
        select.value = 'none';
        canEvent.trigger.call(select, 'change');
        QUnit.equal(map.person, undefined, 'now undefined because not in the list');
    });
});
/*can-stache-converters@3.0.7#test/string-to-any_test*/
define('can-stache-converters@3.0.7#test/string-to-any_test', function (require, exports, module) {
    require('can-stache-converters');
    var canEvent = require('can-event');
    var DefineList = require('can-define/list/list');
    var DefineMap = require('can-define/map/map');
    var stache = require('can-stache');
    var each = require('can-util/js/each/each');
    var QUnit = require('steal-qunit');
    QUnit.module('string-to-any');
    QUnit.test('Works on all the types', function () {
        var types = {
            '22.3': 22.3,
            'foo': 'foo',
            'true': true,
            'false': false,
            'undefined': undefined,
            'null': null,
            'Infinity': Infinity,
            'NaN': {
                expected: NaN,
                equalityTest: function (a) {
                    return isNaN(a);
                }
            }
        };
        var defaultEquality = function (a, b) {
            return a === b;
        };
        each(types, function (expected, type) {
            var template = stache('<select {($value)}="string-to-any(~val)"><option value="test">test</option><option value="' + type + '">' + type + '</option></select>');
            var map = new DefineMap({ val: 'test' });
            var frag = template(map);
            var select = frag.firstChild;
            var option = select.firstChild.nextSibling;
            var equality = defaultEquality;
            if (expected != null && expected.equalityTest) {
                equality = expected.equalityTest;
                expected = expected.expected;
            }
            select.value = type;
            canEvent.trigger.call(select, 'change');
            QUnit.ok(equality(map.val, expected), 'map\'s value updated to: ' + type);
            map.val = 'test';
            map.val = expected;
            QUnit.equal(select.value, type, 'select\'s value updated to: ' + type);
        });
    });
});
/*can-stache-converters@3.0.7#test/not_test*/
define('can-stache-converters@3.0.7#test/not_test', function (require, exports, module) {
    require('can-stache-converters');
    var canEvent = require('can-event');
    var DefineList = require('can-define/list/list');
    var DefineMap = require('can-define/map/map');
    var stache = require('can-stache');
    var each = require('can-util/js/each/each');
    var QUnit = require('steal-qunit');
    QUnit.module('not');
    QUnit.test('saves the inverse of the selected value', function () {
        var template = stache('<input type="checkbox" {($checked)}="not(~val)" />');
        var map = new DefineMap({ val: true });
        var input = template(map).firstChild;
        QUnit.equal(input.checked, false, 'initially false');
        map.val = false;
        QUnit.equal(input.checked, true, 'true because map val is false');
        input.checked = false;
        canEvent.trigger.call(input, 'change');
        QUnit.equal(map.val, true, 'map is now true because checkbox is false');
    });
    QUnit.test('works with boolean-to-inList', function () {
        var template = stache('<input type=\'checkbox\' {($checked)}=\'not(~boolean-to-inList(item, list))\' />');
        var map = new DefineMap({
            item: 2,
            list: new DefineList([
                1,
                2,
                3
            ])
        });
        var input = template(map).firstChild;
        QUnit.equal(input.checked, false, 'not checked because it is in the list');
        map.item = 4;
        QUnit.equal(input.checked, true, 'checked because not in the list');
        input.checked = false;
        canEvent.trigger.call(input, 'change');
        QUnit.equal(map.list.indexOf(4), 3, 'it was pushed into the list');
        map.list.splice(3, 1);
        QUnit.equal(input.checked, true, 'now it\'s checked because not in the list');
    });
});
/*can-stache-converters@3.0.7#test/either-or_test*/
define('can-stache-converters@3.0.7#test/either-or_test', function (require, exports, module) {
    require('can-stache-converters');
    var canEvent = require('can-event');
    var DefineMap = require('can-define/map/map');
    var stache = require('can-stache');
    var QUnit = require('steal-qunit');
    QUnit.module('either-or');
    QUnit.test('can bind to a checkbox', function () {
        var template = stache('<input type=\'checkbox\' {($checked)}=\'either-or(~pref, "Star Trek", "Star Wars")\' />');
        var map = new DefineMap({ pref: 'Star Trek' });
        var input = template(map).firstChild;
        QUnit.equal(input.checked, true, 'initial value is right');
        input.checked = false;
        canEvent.trigger.call(input, 'change');
        QUnit.equal(map.pref, 'Star Wars', 'changed because input changed');
        map.pref = 'Star Trek';
        QUnit.equal(input.checked, true, 'changed because map changed');
    });
});
/*can-stache-converters@3.0.7#test/equal_test*/
define('can-stache-converters@3.0.7#test/equal_test', function (require, exports, module) {
    require('can-stache-converters');
    var canEvent = require('can-event');
    var compute = require('can-compute');
    var DefineList = require('can-define/list/list');
    var DefineMap = require('can-define/map/map');
    var stache = require('can-stache');
    var each = require('can-util/js/each/each');
    var QUnit = require('steal-qunit');
    QUnit.module('equal');
    QUnit.test('Basics works', function () {
        var template = stache('<input type="radio" {($checked)}="equal(~attending, \'yes\'" /><input type="radio" {($checked)}="equal(~attending, \'no\'" />');
        var attending = compute('yes');
        var yes = template({ attending: attending }).firstChild, no = yes.nextSibling;
        QUnit.equal(yes.checked, true, 'initially a yes');
        QUnit.equal(no.checked, false, 'initially unchecked');
        attending('no');
        QUnit.equal(yes.checked, false, 'now not checked');
        QUnit.equal(no.checked, true, 'now checked');
        yes.checked = true;
        canEvent.trigger.call(yes, 'change');
        QUnit.equal(attending(), 'yes', 'now it is yes');
        QUnit.equal(yes.checked, true, 'yes is checked');
        QUnit.equal(no.checked, false, 'no is unchecked');
    });
    QUnit.test('Allows one-way binding when passed a non-compute as the first argument', function () {
        var template = stache('<input type="radio" {($checked)}="equal(attending, true)" />');
        var attending = compute(false);
        var input = template({ attending: attending }).firstChild;
        QUnit.equal(input.checked, false, 'initially false');
        attending(true);
        QUnit.equal(input.checked, true, 'can be changed to true');
        input.checked = false;
        QUnit.equal(attending(), true, 'does not change compute');
    });
});
/*can-stache-converters@3.0.7#test/test*/
define('can-stache-converters@3.0.7#test/test', function (require, exports, module) {
    require('./boolean-to-inList_test');
    require('./index-to-selected_test');
    require('./string-to-any_test');
    require('./not_test');
    require('./either-or_test');
    require('./equal_test');
});
/*can-event@3.1.1#batch/batch-test*/
define('can-event@3.1.1#batch/batch-test', function (require, exports, module) {
    var canEvent = require('can-event');
    var QUnit = require('steal-qunit');
    var assign = require('can-util/js/assign/assign');
    var canBatch = require('can-event/batch/batch');
    var eventAsync = require('can-event/async/async');
    require('can-util/dom/events/delegate/delegate');
    QUnit.module('can-event/batch', {
        setup: function () {
            eventAsync.sync();
        },
        teardown: function () {
            eventAsync.async();
        }
    });
    QUnit.test('basics', function () {
        var collecting;
        var secondFired = false;
        var obj = assign({}, canEvent);
        obj.on('first', function (ev, arg1, arg2) {
            QUnit.equal(collecting.number, ev.batchNum, 'same batch num');
            QUnit.equal(canBatch.dispatching(), collecting, 'dispatching old collecting');
            QUnit.equal(arg1, 1, 'first arg');
            QUnit.equal(arg2, 2, 'second arg');
            collecting = canBatch.collecting();
            QUnit.ok(!collecting, 'not collecting b/c we\'re not in a batch yet');
            obj.dispatch('second');
            collecting = canBatch.collecting();
            QUnit.ok(collecting, 'forced a batch');
            QUnit.equal(secondFired, false, 'don\'t fire yet, put in next batch');
        });
        obj.on('second', function (ev) {
            secondFired = true;
            QUnit.equal(collecting.number, ev.batchNum, 'same batch num on second');
            QUnit.equal(canBatch.dispatching(), collecting, 'dispatching second collecting');
        });
        canBatch.start();
        collecting = canBatch.collecting();
        QUnit.ok(canBatch.collecting(), 'is collecting');
        obj.dispatch('first', [
            1,
            2
        ]);
        canBatch.stop();
    });
    QUnit.test('events are queued and dispatched without .stop being called (#14)', function () {
        var obj = assign({}, canEvent);
        obj.on('first', function (ev) {
            obj.dispatch('second');
            QUnit.ok(canBatch.collecting() !== canBatch.dispatching(), 'dispatching is not collecting');
        });
        obj.on('second', function () {
            QUnit.ok(canBatch.collecting() !== canBatch.dispatching(), 'dispatching is not collecting');
            QUnit.ok(true, 'called');
        });
        canBatch.start();
        obj.dispatch('first');
        canBatch.stop();
    });
    test('Everything is part of a batch', function () {
        var obj = {};
        assign(obj, canEvent);
        obj.on('foo', function (ev) {
            ok(ev.batchNum);
        });
        obj.dispatch('foo');
    });
    test('batch.queue callback called after events fired in the same fn', function () {
        var obj = assign({}, canEvent);
        var thirdCalled = false, firstBatch;
        obj.on('third', function (ev) {
            QUnit.equal(firstBatch, ev.batchNum, 'third is right');
            thirdCalled = true;
        });
        obj.on('first', function (ev) {
            equal(typeof ev.batchNum, 'number', 'got a batch number');
            firstBatch = ev.batchNum;
            canBatch.queue([
                function () {
                    equal(thirdCalled, true, 'third called before this');
                },
                null,
                []
            ]);
            obj.dispatch({
                type: 'third',
                batchNum: ev.batchNum
            });
        });
        obj.dispatch('first');
    });
    QUnit.test('afterPreviousEvents doesn\'t run after all collecting previous events (#17)', function () {
        var obj = assign({}, canEvent);
        var afterPreviousEventsFired = false;
        obj.on('first', function () {
            QUnit.ok(!afterPreviousEventsFired, 'after previous should fire after');
        });
        canBatch.start();
        obj.dispatch('first');
        canBatch.afterPreviousEvents(function () {
            afterPreviousEventsFired = true;
        });
        canBatch.stop();
    });
    QUnit.test('flushing works (#18)', function () {
        var firstFired, secondFired, thirdFired;
        var obj = assign({}, canEvent);
        obj.on('first', function () {
            canBatch.flush();
            QUnit.ok(firstFired, 'first fired');
            QUnit.ok(secondFired, 'second fired');
            QUnit.ok(thirdFired, 'third fired');
        });
        obj.on('first', function () {
            firstFired = true;
        });
        obj.on('second', function () {
            secondFired = true;
        });
        obj.on('third', function () {
            thirdFired = true;
        });
        canBatch.start();
        obj.dispatch('first');
        obj.dispatch('second');
        obj.dispatch('third');
        canBatch.stop();
    });
    QUnit.test('flush is non enumerable (#18)', 1, function () {
        QUnit.equal(canEvent.flush, canBatch.flush);
        for (var prop in canEvent) {
            if (prop === 'flush') {
                ok(false, 'flush is enumerable');
            }
        }
    });
    QUnit.test('flushing a future batch (#18)', function () {
        var firstFired, secondFired, thirdFired;
        var obj = assign({}, canEvent);
        obj.on('first', function () {
            canBatch.start();
            obj.dispatch('second');
            obj.dispatch('third');
            canBatch.stop();
            canBatch.flush();
            QUnit.ok(firstFired, 'first fired');
            QUnit.ok(secondFired, 'second fired');
            QUnit.ok(thirdFired, 'third fired');
        });
        obj.on('first', function () {
            firstFired = true;
        });
        obj.on('second', function () {
            secondFired = true;
        });
        obj.on('third', function () {
            thirdFired = true;
        });
        canBatch.start();
        obj.dispatch('first');
        canBatch.stop();
    });
});
/*can-event@3.1.1#async/async-test*/
define('can-event@3.1.1#async/async-test', function (require, exports, module) {
    var canEvent = require('can-event');
    var QUnit = require('steal-qunit');
    var assign = require('can-util/js/assign/assign');
    var eventAsync = require('can-event/async/async');
    require('can-util/dom/events/delegate/delegate');
    QUnit.module('can-event/async', {
        setup: function () {
            eventAsync.async();
        },
        teardown: function () {
            eventAsync.sync();
        }
    });
    QUnit.asyncTest('removing an event handler, nothing called', 5, function () {
        var obj = {};
        assign(obj, canEvent);
        var handler = function (ev, arg1, arg2) {
            ok(true, 'foo called');
            equal(ev.type, 'foo');
            equal(arg1, 1, 'one');
            equal(arg2, 2, 'two');
        };
        obj.addEventListener('foo', handler);
        obj.dispatch({ type: 'foo' }, [
            1,
            2
        ]);
        obj.removeEventListener('foo', handler);
        obj.addEventListener('foo', function () {
            QUnit.ok(true, 'this handler called');
            QUnit.start();
        });
        obj.dispatch({
            type: 'foo',
            data: [
                1,
                2
            ]
        });
    });
    QUnit.asyncTest('removing an event handler, nothing called with on', 6, function () {
        var obj = {};
        assign(obj, canEvent);
        var dispatched = false;
        var handler = function (ev, arg1, arg2) {
            ok(dispatched, 'dispatched should be async');
            ok(true, 'foo called');
            equal(ev.type, 'foo');
            equal(arg1, 1, 'one');
            equal(arg2, 2, 'two');
        };
        obj.on('foo', handler);
        obj.dispatch({ type: 'foo' }, [
            1,
            2
        ]);
        dispatched = true;
        obj.off('foo', handler);
        obj.on('foo', function () {
            QUnit.ok(true, 'this handler called');
            QUnit.start();
        });
        obj.dispatch({
            type: 'foo',
            data: [
                1,
                2
            ]
        });
    });
    QUnit.asyncTest('async with same batch number is fired right away', function () {
        var obj = assign({}, canEvent);
        var secondDispatched = false;
        var secondBatchNum;
        obj.on('first', function (ev) {
            obj.dispatch({
                batchNum: ev.batchNum,
                type: 'second'
            });
            equal(secondBatchNum, ev.batchNum, 'batch nums the same');
            ok(secondDispatched, 'dispatched event immediately');
            QUnit.start();
        });
        obj.on('second', function (ev) {
            secondDispatched = true;
            secondBatchNum = ev.batchNum;
        });
        obj.dispatch('first');
    });
});
/*can-event@3.1.1#lifecycle/lifecycle-test*/
define('can-event@3.1.1#lifecycle/lifecycle-test', function (require, exports, module) {
    var canEvent = require('can-event');
    var lifecycle = require('can-event/lifecycle/lifecycle');
    var QUnit = require('steal-qunit');
    QUnit.module('can-event/lifecycle');
    QUnit.test('Mixins your addEventListener', function () {
        var proto = {
            addEventListener: function () {
                QUnit.ok(true, 'this was called');
            },
            removeEventListener: function () {
            }
        };
        var obj = lifecycle(proto);
        obj.addEventListener('Hello world!');
    });
    QUnit.test('Mixins your removeEventListener', function () {
        var proto = {
            removeEventListener: function () {
                QUnit.ok(true, 'this was called');
            },
            addEventListener: canEvent.addEventListener
        };
        var obj = lifecycle(proto);
        obj.addEventListener('some-event');
        obj.removeEventListener('some-event');
    });
    QUnit.test('Calls _eventSetup on the first addEventListener', function () {
        var proto = {
            _eventSetup: function () {
                QUnit.ok(true, 'eventSetup was called');
            },
            addEventListener: function () {
            },
            removeEventListener: function () {
            }
        };
        var obj = lifecycle(proto);
        obj.addEventListener('Something');
    });
    QUnit.test('Calls _eventTeardown on the last removeEventListener', function () {
        var proto = {
            _eventTeardown: function () {
                QUnit.ok(true, 'eventTeardown was called');
            },
            addEventListener: canEvent.addEventListener,
            removeEventListener: canEvent.removeEventListener
        };
        var obj = lifecycle(proto);
        var handler = function () {
        };
        obj.addEventListener('Something', handler);
        obj.removeEventListener('Something', handler);
    });
});
/*can-event@3.1.1#can-event_test*/
define('can-event@3.1.1#can-event_test', function (require, exports, module) {
    var canEvent = require('can-event');
    var QUnit = require('steal-qunit');
    var assign = require('can-util/js/assign/');
    require('can-util/dom/events/delegate/');
    require('can-event/batch/batch-test');
    require('can-event/async/async-test');
    require('can-event/lifecycle/lifecycle-test');
    QUnit.module('can-event');
    test('basics', 4, function () {
        var obj = {
            addEvent: canEvent.addEvent,
            removeEvent: canEvent.removeEvent,
            dispatch: canEvent.dispatch
        };
        var handler = function (ev, arg1, arg2) {
            ok(true, 'foo called');
            equal(ev.type, 'foo');
            equal(arg1, 1, 'one');
            equal(arg2, 2, 'two');
        };
        obj.addEvent('foo', handler);
        obj.dispatch({ type: 'foo' }, [
            1,
            2
        ]);
        obj.removeEvent('foo', handler);
        obj.dispatch({
            type: 'foo',
            data: [
                1,
                2
            ]
        });
    });
    test('listenTo and stopListening', 9, function () {
        var parent = {
            bind: canEvent.bind,
            unbind: canEvent.unbind,
            listenTo: canEvent.listenTo,
            stopListening: canEvent.stopListening
        };
        var child1 = {
            bind: canEvent.bind,
            unbind: canEvent.unbind
        };
        var child2 = {
            bind: canEvent.bind,
            unbind: canEvent.unbind
        };
        var change1WithId = 0;
        parent.listenTo(child1, 'change', function () {
            change1WithId++;
            if (change1WithId === 1) {
                ok(true, 'child 1 handler with id called');
            } else {
                ok(false, 'child 1 handler with id should only be called once');
            }
        });
        child1.bind('change', function () {
            ok(true, 'child 1 handler without id called');
        });
        var foo1WidthId = 0;
        parent.listenTo(child1, 'foo', function () {
            foo1WidthId++;
            if (foo1WidthId === 1) {
                ok(true, 'child 1 foo handler with id called');
            } else {
                ok(false, 'child 1 foo handler should not be called twice');
            }
        });
        (function () {
            var okToCall = true;
            parent.listenTo(child2, 'change', function () {
                ok(okToCall, 'child 2 handler with id called');
                okToCall = false;
            });
        }());
        child2.bind('change', function () {
            ok(true, 'child 2 handler without id called');
        });
        parent.listenTo(child2, 'foo', function () {
            ok(true, 'child 2 foo handler with id called');
        });
        canEvent.trigger.call(child1, 'change');
        canEvent.trigger.call(child1, 'foo');
        canEvent.trigger.call(child2, 'change');
        canEvent.trigger.call(child2, 'foo');
        parent.stopListening(child1);
        parent.stopListening(child2, 'change');
        canEvent.trigger.call(child1, 'change');
        canEvent.trigger.call(child1, 'foo');
        canEvent.trigger.call(child2, 'change');
        canEvent.trigger.call(child2, 'foo');
    });
    test('stopListening on something you\'ve never listened to ', function () {
        var parent = {
            bind: canEvent.bind,
            unbind: canEvent.unbind,
            listenTo: canEvent.listenTo,
            stopListening: canEvent.stopListening
        };
        var child = {
            bind: canEvent.bind,
            unbind: canEvent.unbind
        };
        parent.listenTo({}, 'foo');
        parent.stopListening(child, 'change');
        ok(true, 'did not error');
    });
    test('bind on document', function () {
        var called = false, handler = function () {
                called = true;
            };
        canEvent.on.call(document, 'click', handler);
        canEvent.trigger.call(document, 'click');
        ok(called, 'got click event');
        ok(true, 'did not error');
        canEvent.off.call(document, 'click', handler);
    });
    test('delegate on document', function () {
        var called = false, handler = function () {
                called = true;
            };
        canEvent.delegate.call(document, 'click', 'body', handler);
        canEvent.trigger.call(document.body, 'click');
        ok(called, 'got click event');
        ok(true, 'did not error');
        canEvent.undelegate.call(document, 'body', 'click', handler);
    });
    test('One will listen to an event once, then unbind', function () {
        var obj = {}, count = 0, mixin = 0;
        canEvent.one.call(obj, 'action', function () {
            count++;
        });
        canEvent.dispatch.call(obj, 'action');
        canEvent.dispatch.call(obj, 'action');
        canEvent.dispatch.call(obj, 'action');
        equal(count, 1, 'one should only fire a handler once (direct)');
        assign(obj, canEvent);
        obj.one('mixin', function () {
            mixin++;
        });
        obj.dispatch('mixin');
        obj.dispatch('mixin');
        obj.dispatch('mixin');
        equal(mixin, 1, 'one should only fire a handler once (mixin)');
    });
    test('Test events using mixin', function () {
        var obj = {}, fn;
        assign(obj, canEvent);
        var bindCount = 0;
        obj.bind('action', fn = function () {
            ++bindCount;
        });
        obj.dispatch('action');
        obj.dispatch('action');
        obj.unbind('action', fn);
        obj.dispatch('action');
        equal(bindCount, 2, 'action triggered twice');
        bindCount = 0;
        obj.one('action', fn = function () {
            ++bindCount;
        });
        obj.dispatch('action');
        obj.dispatch('action');
        equal(bindCount, 1, 'action triggered only once, then unbound');
        var other = {};
        bindCount = 0;
        assign(other, canEvent);
        obj.listenTo(other, 'action', fn = function () {
            ++bindCount;
        });
        other.dispatch('action');
        other.dispatch('action');
        obj.stopListening(other, 'action', fn);
        other.dispatch('action');
        equal(bindCount, 2, 'action triggered twice');
    });
    QUnit.test('makeHandlerArgs and handlers are non enumerable', 0, function () {
        for (var prop in canEvent) {
            if (prop === 'makeHandlerArgs' || prop === 'handlers') {
                ok(false, prop + ' is enumerable');
            }
        }
    });
});
/*can@3.4.1#event/event_test*/
define('can@3.4.1#event/event_test', function (require, exports, module) {
    require('can-event/can-event_test');
});
/*can-util@3.3.2#test/qunit*/
define('can-util@3.3.2#test/qunit', function (require, exports, module) {
    (function (global) {
        if (typeof QUnit === 'undefined') {
            module.exports = require('steal-qunit');
        } else {
            QUnit.test = test;
            module.exports = QUnit;
        }
    }(function () {
        return this;
    }()));
});
/*can-util@3.3.2#js/assign/assign-test*/
define('can-util@3.3.2#js/assign/assign-test', function (require, exports, module) {
    var assign = require('./assign');
    var QUnit = require('../../test/qunit');
    QUnit.module('can-util/js/assign');
    QUnit.test('Assign all properties to an object', function () {
        var a = {
            a: 1,
            b: 2,
            d: 3
        };
        var b = {
            a: 1,
            b: 3,
            c: 2
        };
        var expected = {
            a: 1,
            b: 3,
            c: 2,
            d: 3
        };
        var actual = assign(a, b);
        for (var prop in actual) {
            equal(expected[prop], actual[prop]);
        }
    });
});
/*can-util@3.3.2#js/base-url/base-url-test*/
define('can-util@3.3.2#js/base-url/base-url-test', function (require, exports, module) {
    (function (global) {
        var QUnit = require('../../test/qunit');
        var getBaseUrl = require('./base-url');
        var getGlobal = require('../global/global');
        QUnit.module('can-util/js/base-url');
        test('basics', function () {
            var global = getGlobal();
            if (global.location) {
                ok(getBaseUrl() === global.location.href.substr(0, global.location.href.lastIndexOf('/')), getBaseUrl());
            } else if (typeof process !== 'undefined') {
                ok(getBaseUrl() === process.cwd(), getBaseUrl());
            }
        });
    }(function () {
        return this;
    }()));
});
/*can-util@3.3.2#js/cid-map/cid-map-test*/
define('can-util@3.3.2#js/cid-map/cid-map-test', function (require, exports, module) {
    var QUnit = require('../../test/qunit');
    var CIDMap = require('./cid-map');
    QUnit.module('can-util/js/cid-map');
    QUnit.test('basics', function () {
        var o1 = {}, o2 = {}, o3 = {};
        var map = new CIDMap();
        map.set(o1, 'o1');
        map.set(o2, 'o2');
        QUnit.equal(map.get(o1), 'o1');
        QUnit.equal(map.get(o2), 'o2');
        QUnit.equal(map.get(o3), undefined);
        QUnit.equal(map.size, 2);
        map.clear();
        QUnit.equal(map.size, 0);
    });
    QUnit.test('forEach', function () {
        var o1 = {}, o2 = {};
        var map = new CIDMap();
        map.set(o1, 'o1');
        map.set(o2, 'o2');
        map.forEach(function (value, key) {
            if (value === 'o1') {
                QUnit.equal(key, o1);
            } else if (value === 'o2') {
                QUnit.equal(key, o2);
            } else {
                QUnit.ok(false, 'key shouldn\'t be ' + value);
            }
        });
    });
});
/*can-util@3.3.2#js/cid-set/cid-set-test*/
define('can-util@3.3.2#js/cid-set/cid-set-test', function (require, exports, module) {
    var QUnit = require('../../test/qunit');
    var CIDSet = require('./cid-set');
    QUnit.module('can-util/js/cid-set');
    QUnit.test('basics', function () {
        var o1 = {}, o2 = {};
        var set = new CIDSet();
        set.add(o1);
        set.add(o2);
        QUnit.ok(set.has(o1));
        QUnit.ok(set.has(o2));
        QUnit.equal(set.size, 2);
        set.clear();
        QUnit.equal(set.size, 0);
    });
    QUnit.test('primitives', function () {
        var set = new CIDSet();
        set.add(0);
        set.add(1);
        set.add(1);
        set.add('1');
        QUnit.equal(set.size, 3);
        QUnit.ok(set.has(0), 'has 0');
        QUnit.ok(!set.has('0'));
        QUnit.ok(set.has(1));
        QUnit.ok(set.has('1'));
        set.clear();
        QUnit.equal(set.size, 0);
    });
});
/*can-util@3.3.2#js/deep-assign/deep-assign-test*/
define('can-util@3.3.2#js/deep-assign/deep-assign-test', function (require, exports, module) {
    var QUnit = require('../../test/qunit');
    var deepAssign = require('./deep-assign');
    QUnit.module('can-util/js/deep-assign');
    QUnit.test('basics', function () {
        var original = { nested: { foo: 'bar' } };
        var res = deepAssign(true, {}, original);
        deepEqual(res, { nested: { foo: 'bar' } }, 'they look the same');
        ok(res.nested !== original.nested, 'different objects');
    });
});
/*can-util@3.3.2#js/defaults/defaults-test*/
define('can-util@3.3.2#js/defaults/defaults-test', function (require, exports, module) {
    var defaults = require('./defaults');
    var QUnit = require('../../test/qunit');
    QUnit.module('can-util/js/defaults');
    QUnit.test('Assigns props from sources to object if they are undefined in object', function () {
        var a = {
            a: 1,
            b: 2,
            c: 3
        };
        var b = {
            a: 2,
            b: 3,
            d: 4
        };
        var c = {
            d: 5,
            e: 5
        };
        var expected = {
            a: 1,
            b: 2,
            c: 3,
            d: 4,
            e: 5
        };
        var actual = defaults(a, b, c);
        for (var prop in actual) {
            equal(expected[prop], actual[prop]);
        }
    });
});
/*can-util@3.3.2#js/dev/dev-test*/
define('can-util@3.3.2#js/dev/dev-test', function (require, exports, module) {
    var QUnit = require('../../test/qunit');
    require('./dev');
    QUnit.module('can-util/js/dev');
});
/*can-util@3.3.2#js/log/log-test*/
define('can-util@3.3.2#js/log/log-test', function (require, exports, module) {
    var QUnit = require('../../test/qunit');
    var canLog = require('./log');
    if (typeof console !== 'undefined') {
        QUnit.module('can-util/js/log');
        QUnit.test('log.log works', function () {
            QUnit.expect(2);
            var log = console.log;
            console.log = function (type, msg) {
                QUnit.equal(type, 'INFO:');
                QUnit.equal(msg, 'it worked');
                console.log = log;
            };
            canLog.log('it worked');
        });
        QUnit.test('log.warn works', function () {
            QUnit.expect(2);
            var warn = console.warn;
            console.warn = function (type, msg) {
                QUnit.equal(type, 'WARN:');
                QUnit.equal(msg, 'it worked');
                console.warn = warn;
            };
            canLog.warn('it worked');
        });
        QUnit.test('log.error works', function () {
            QUnit.expect(2);
            var error = console.error;
            console.error = function (type, msg) {
                QUnit.equal(type, 'ERROR:');
                QUnit.equal(msg, 'an error');
                console.error = error;
            };
            canLog.error('an error');
        });
    }
});
/*can-util@3.3.2#js/diff/diff-test*/
define('can-util@3.3.2#js/diff/diff-test', function (require, exports, module) {
    var QUnit = require('../../test/qunit');
    var diff = require('./diff');
    QUnit.module('can-util/js/diff');
    QUnit.test('basics', function () {
        var patches = diff([], [
            1,
            2,
            3
        ]);
        deepEqual(patches, [{
                index: 0,
                deleteCount: 0,
                insert: [
                    1,
                    2,
                    3
                ]
            }], 'insert many at end');
        patches = diff([
            1,
            2,
            3
        ], [
            1,
            2,
            3
        ]);
        deepEqual(patches, [], 'no changes');
        patches = diff([
            1,
            2,
            3
        ], [
            1,
            2,
            3,
            4
        ]);
        deepEqual(patches, [{
                index: 3,
                deleteCount: 0,
                insert: [4]
            }], 'add one at the end');
        patches = diff([
            1,
            2,
            3,
            4
        ], [
            1,
            2,
            4
        ]);
        deepEqual(patches, [{
                index: 2,
                deleteCount: 1,
                insert: []
            }], 'remove one in the middle');
        patches = diff([
            'a',
            'b',
            'z',
            'f',
            'x'
        ], [
            'a',
            'b',
            'f',
            'w',
            'z'
        ]);
        deepEqual(patches, [
            {
                index: 2,
                insert: [],
                deleteCount: 1
            },
            {
                index: 3,
                deleteCount: 1,
                insert: [
                    'w',
                    'z'
                ]
            }
        ]);
        patches = diff([
            'a',
            'b',
            'b'
        ], [
            'c',
            'a',
            'b'
        ]);
        deepEqual(patches, [
            {
                index: 0,
                insert: ['c'],
                deleteCount: 0
            },
            {
                index: 3,
                deleteCount: 1,
                insert: []
            }
        ]);
        patches = diff([
            'a',
            'b',
            'c',
            'd',
            'e',
            'f',
            'g'
        ], [
            'a',
            'c',
            'e',
            'g'
        ]);
        deepEqual(patches, [
            {
                index: 1,
                insert: [],
                deleteCount: 1
            },
            {
                index: 2,
                deleteCount: 1,
                insert: []
            },
            {
                index: 3,
                deleteCount: 1,
                insert: []
            }
        ]);
        patches = diff([
            { id: 1 },
            { id: 2 }
        ], [
            { id: 1 },
            { id: 1.5 },
            { id: 3 }
        ], function (a, b) {
            return a.id === b.id;
        });
        deepEqual(patches, [{
                index: 1,
                deleteCount: 1,
                insert: [
                    { id: 1.5 },
                    { id: 3 }
                ]
            }], 'identity works');
        patches = diff([
            { id: 1 },
            { id: 2 }
        ], [
            { id: 1 },
            { id: 3 },
            { id: 2 }
        ], function (a, b) {
            return a.id === b.id;
        });
        deepEqual(patches, [{
                index: 1,
                deleteCount: 0,
                insert: [{ id: 3 }]
            }], 'identity for a single middle insertion');
    });
});
/*can-util@3.3.2#js/diff-array/diff-array*/
define('can-util@3.3.2#js/diff-array/diff-array', function (require, exports, module) {
    var diff = require('../diff/diff');
    module.exports = exports = diff;
});
/*can-util@3.3.2#js/diff-array/diff-array-test*/
define('can-util@3.3.2#js/diff-array/diff-array-test', function (require, exports, module) {
    var QUnit = require('../../test/qunit');
    var diffArray = require('./diff-array');
    QUnit.module('can-util/js/diff-array');
    QUnit.test('basics', function () {
        var patches = diffArray([], [
            1,
            2,
            3
        ]);
        deepEqual(patches, [{
                index: 0,
                deleteCount: 0,
                insert: [
                    1,
                    2,
                    3
                ]
            }], 'insert many at end');
        patches = diffArray([
            1,
            2,
            3
        ], [
            1,
            2,
            3
        ]);
        deepEqual(patches, [], 'no changes');
        patches = diffArray([
            1,
            2,
            3
        ], [
            1,
            2,
            3,
            4
        ]);
        deepEqual(patches, [{
                index: 3,
                deleteCount: 0,
                insert: [4]
            }], 'add one at the end');
        patches = diffArray([
            1,
            2,
            3,
            4
        ], [
            1,
            2,
            4
        ]);
        deepEqual(patches, [{
                index: 2,
                deleteCount: 1,
                insert: []
            }], 'remove one in the middle');
        patches = diffArray([
            'a',
            'b',
            'z',
            'f',
            'x'
        ], [
            'a',
            'b',
            'f',
            'w',
            'z'
        ]);
        deepEqual(patches, [
            {
                index: 2,
                insert: [],
                deleteCount: 1
            },
            {
                index: 3,
                deleteCount: 1,
                insert: [
                    'w',
                    'z'
                ]
            }
        ]);
        patches = diffArray([
            'a',
            'b',
            'b'
        ], [
            'c',
            'a',
            'b'
        ]);
        deepEqual(patches, [
            {
                index: 0,
                insert: ['c'],
                deleteCount: 0
            },
            {
                index: 3,
                deleteCount: 1,
                insert: []
            }
        ]);
        patches = diffArray([
            'a',
            'b',
            'c',
            'd',
            'e',
            'f',
            'g'
        ], [
            'a',
            'c',
            'e',
            'g'
        ]);
        deepEqual(patches, [
            {
                index: 1,
                insert: [],
                deleteCount: 1
            },
            {
                index: 2,
                deleteCount: 1,
                insert: []
            },
            {
                index: 3,
                deleteCount: 1,
                insert: []
            }
        ]);
    });
});
/*can-util@3.3.2#js/diff-object/diff-object-test*/
define('can-util@3.3.2#js/diff-object/diff-object-test', function (require, exports, module) {
    var QUnit = require('../../test/qunit');
    var diffObject = require('./diff-object');
    QUnit.module('can-util/js/diff');
    QUnit.test('basics', function () {
        var patches = diffObject({}, { a: 'foo' });
        deepEqual(patches, [{
                property: 'a',
                type: 'add',
                value: 'foo'
            }], 'add property');
        patches = diffObject(null, { a: 'foo' });
        deepEqual(patches, [{
                property: 'a',
                type: 'add',
                value: 'foo'
            }], 'add property - oldObject null');
        patches = diffObject({ a: 'foo' }, { a: 'bar' });
        deepEqual(patches, [{
                property: 'a',
                type: 'set',
                value: 'bar'
            }], 'change property');
        patches = diffObject({ a: 'foo' }, {});
        deepEqual(patches, [{
                property: 'a',
                type: 'remove'
            }], 'remove property');
        patches = diffObject({
            a: 'foo',
            b: 'baz'
        }, {
            a: 'bar',
            c: 'quz'
        });
        deepEqual(patches, [
            {
                property: 'a',
                type: 'set',
                value: 'bar'
            },
            {
                property: 'c',
                type: 'add',
                value: 'quz'
            },
            {
                property: 'b',
                type: 'remove'
            }
        ], 'add, set, and remove');
    });
    QUnit.test('mutation test', function () {
        var oldObject = {
            a: 'foo',
            b: 'baz'
        };
        var newObject = {
            a: 'bar',
            c: 'quz'
        };
        diffObject(oldObject, newObject);
        deepEqual(oldObject, {
            a: 'foo',
            b: 'baz'
        }, 'should not mutate old object');
        deepEqual(newObject, {
            a: 'bar',
            c: 'quz'
        }, 'should not mutate new object');
    });
});
/*can-util@3.3.2#js/each/each-test*/
define('can-util@3.3.2#js/each/each-test', function (require, exports, module) {
    var QUnit = require('../../test/qunit');
    var each = require('./each');
    var types = require('can-types');
    QUnit.module('can-util/js/each');
    test('iOS 8 64-bit JIT object length bug', function () {
        expect(4);
        var i;
        for (i = 0; i < 1000; i++) {
            each([]);
        }
        i = 0;
        each({
            1: '1',
            2: '2',
            3: '3'
        }, function (index) {
            equal(++i, index, 'Iterate over object');
        });
        equal(i, 3, 'Last index should be the length of the array');
    });
    test('#1989 - isArrayLike needs to check for object type', function () {
        try {
            each(true, function (index) {
            });
            ok(true, 'each on true worked');
        } catch (e) {
            ok(false, 'Should not fail');
        }
    });
    test('objects that implement iterators work', function () {
        var Ctr = function () {
        };
        Ctr.prototype[types.iterator] = function () {
            return {
                i: 0,
                next: function () {
                    if (this.i === 1) {
                        return {
                            value: undefined,
                            done: true
                        };
                    }
                    this.i++;
                    return {
                        value: [
                            'a',
                            'b'
                        ],
                        done: false
                    };
                }
            };
        };
        var obj = new Ctr();
        each(obj, function (value, key) {
            equal(key, 'a');
            equal(value, 'b');
        });
    });
});
/*can-util@3.3.2#js/get/get-test*/
define('can-util@3.3.2#js/get/get-test', function (require, exports, module) {
    var QUnit = require('../../test/qunit');
    var get = require('./get');
    QUnit.module('can-util/js/get');
    QUnit.test('get Single root', function () {
        var root, result;
        root = { foo: 'bar' };
        result = get(root, 'foo');
        equal(result, 'bar', 'got \'bar\'');
        result = get(root, 'baz');
        equal(result, undefined, 'got \'undefined\'');
    });
    QUnit.test('get Deep objects', function () {
        var root, result;
        root = { foo: { bar: 'baz' } };
        result = get(root, 'foo.bar');
        equal(result, 'baz', 'got \'baz\'');
        result = get(root, 'foo.world');
        equal(result, undefined, 'got \'undefined\'');
    });
    QUnit.test('get with numeric index', function () {
        var list = [
                1,
                2,
                3
            ], result0 = get(list, 0);
        equal(result0, 1, 'got the 1st element of the list');
        var result1 = get(list, 1);
        equal(result1, 2, 'got the 2nd element of the list');
    });
});
/*can-util@3.3.2#js/global/global-test*/
define('can-util@3.3.2#js/global/global-test', function (require, exports, module) {
    (function (global) {
        var QUnit = require('../../test/qunit');
        var getGlobal = require('./global');
        var isBrowserWindow = require('../is-browser-window/is-browser-window');
        QUnit.module('can-util/js/global');
        test('basics', function () {
            if (isBrowserWindow()) {
                ok(getGlobal() === window);
            } else {
                ok(getGlobal() === global);
            }
        });
        if (!isBrowserWindow()) {
            QUnit.module('in Node with fake window', {
                setup: function () {
                    this.oldWindow = global.window;
                    global.window = {};
                },
                teardown: function () {
                    global.window = this.oldWindow;
                }
            });
            test('Gets the Node global', function () {
                ok(getGlobal() === global);
            });
        }
    }(function () {
        return this;
    }()));
});
/*can-util@3.3.2#js/import/import-test*/
define('can-util@3.3.2#js/import/import-test', function (require, exports, module) {
    (function (global, __dirname) {
        var QUnit = require('../../test/qunit');
        var load = require('./import');
        var isNode = require('../is-node/is-node')();
        if (!isNode) {
            QUnit.module('can-util/js/import');
            if (__dirname !== '/') {
                QUnit.test('basic can-import works', function () {
                    stop();
                    load('can-util/js/import/testmodule', __dirname).then(function (data) {
                        QUnit.equal(data, 'Hello world');
                    }).then(null, function (err) {
                        QUnit.ok(false, err);
                    }).then(start, start);
                });
            }
        } else {
            QUnit.module('can-util/js/import - Node', {
                setup: function () {
                    this.oldSystem = global.System;
                    global.System = {
                        'import': function (name) {
                            name = name.replace('can-util', '');
                            return new Promise(function (resolve, reject) {
                                try {
                                    var mod = require(process.cwd() + name);
                                    resolve(mod);
                                } catch (err) {
                                    reject(err);
                                }
                            });
                        }
                    };
                },
                teardown: function () {
                    global.System = this.oldSystem;
                }
            });
            QUnit.test('basic can-import works', function () {
                stop();
                load('can-util/js/import/testmodule', __dirname).then(function (data) {
                    QUnit.equal(data, 'Hello world');
                }).then(null, function (err) {
                    QUnit.ok(false, err);
                }).then(start, start);
            });
        }
    }(function () {
        return this;
    }(), '/'));
});
/*can-util@3.3.2#js/is-array/is-array-test*/
define('can-util@3.3.2#js/is-array/is-array-test', function (require, exports, module) {
    var QUnit = require('../../test/qunit');
    var isArray = require('./is-array');
    QUnit.module('can-util/js/is-array');
    QUnit.test('basics', function () {
        ok(isArray([]));
        ok(!isArray({
            0: 'a',
            length: 1
        }));
    });
});
/*can-util@3.3.2#js/is-array-like/is-array-like-test*/
define('can-util@3.3.2#js/is-array-like/is-array-like-test', function (require, exports, module) {
    var QUnit = require('../../test/qunit');
    var isArrayLike = require('./is-array-like');
    QUnit.module('can-util/js/is-array-like');
    QUnit.test('basics', function () {
        ok(isArrayLike({
            0: 1,
            length: 1
        }));
    });
    QUnit.test('string', function () {
        ok(isArrayLike('yes'));
    });
    QUnit.test('Object with a .length property', function () {
        var obj = { length: 0 };
        ok(isArrayLike(obj));
    });
    QUnit.test('function should be false', function () {
        var func = function () {
        };
        ok(!isArrayLike(func));
    });
});
/*can-util@3.3.2#js/is-browser-window/is-browser-window-test*/
define('can-util@3.3.2#js/is-browser-window/is-browser-window-test', function (require, exports, module) {
    var QUnit = require('../../test/qunit');
    var isBrowserWindow = require('./is-browser-window');
    QUnit.module('can-util/js/is-browser-window');
    QUnit.test('basics', function () {
        equal(typeof isBrowserWindow(), 'boolean');
    });
});
/*can-util@3.3.2#js/is-container/is-container-test*/
define('can-util@3.3.2#js/is-container/is-container-test', function (require, exports, module) {
    var QUnit = require('../../test/qunit');
    var isContainer = require('./is-container');
    QUnit.module('can-util/js/is-container');
    QUnit.test('object', function () {
        ok(isContainer({ 'a': 1 }));
    });
    QUnit.test('function', function () {
        var sum = function (num1, num2) {
            return num1 + num2;
        };
        ok(isContainer(sum));
    });
    QUnit.test('NaN and undefined is not a container', function () {
        ok(!isContainer(NaN));
        ok(!isContainer());
    });
});
/*can-util@3.3.2#js/is-empty-object/is-empty-object-test*/
define('can-util@3.3.2#js/is-empty-object/is-empty-object-test', function (require, exports, module) {
    var isEmptyObject = require('./is-empty-object');
    var QUnit = require('../../test/qunit');
    QUnit.module('can-util/js/is-empty-object/is-empty-object');
    QUnit.test('Returns true for plain objects', function (assert) {
        assert.ok(isEmptyObject({}), '{} is true');
        assert.ok(isEmptyObject(new Object()), 'new Object is true');
    });
    QUnit.test('Plain objects with properties are false', function (assert) {
        assert.equal(isEmptyObject({ a: 1 }), false, 'not empty');
    });
    QUnit.test('Returns true for custom objects with no props', function (assert) {
        var Thing = function () {
        };
        assert.equal(isEmptyObject(new Thing()), true, 'is empty');
        var thing2 = new Thing();
        thing2.foo = 'bar';
        assert.equal(isEmptyObject(thing2), false, 'not empty');
    });
});
/*can-util@3.3.2#js/is-function/is-function-test*/
define('can-util@3.3.2#js/is-function/is-function-test', function (require, exports, module) {
    var QUnit = require('../../test/qunit');
    var isFunction = require('./is-function');
    QUnit.module('can-util/js/is-function');
    QUnit.test('basics', function () {
        QUnit.ok(isFunction(function () {
        }));
    });
});
/*can-util@3.3.2#js/is-node/is-node-test*/
define('can-util@3.3.2#js/is-node/is-node-test', function (require, exports, module) {
    var QUnit = require('../../test/qunit');
    var isNode = require('./is-node');
    QUnit.module('can-util/js/is-node');
    test('basics', function () {
        QUnit.equal(typeof isNode(), 'boolean');
    });
});
/*can-util@3.3.2#js/is-plain-object/is-plain-object-test*/
define('can-util@3.3.2#js/is-plain-object/is-plain-object-test', function (require, exports, module) {
    var QUnit = require('../../test/qunit');
    var isPlainObject = require('./is-plain-object');
    QUnit.module('can-util/js/is-plain-object');
    QUnit.test('basics', function () {
        QUnit.ok(isPlainObject({ foo: 'bar' }));
    });
    QUnit.test('objects with prototypes', function () {
        var Ctr = function () {
        };
        var obj = new Ctr();
        QUnit.equal(isPlainObject(obj), false, 'not a plain object');
    });
    QUnit.test('new Object', function () {
        var obj;
        obj = new Object();
        QUnit.equal(isPlainObject(obj), true, 'using new Object gives you a plain object');
    });
    QUnit.test('Booleans', function () {
        QUnit.equal(isPlainObject(true), false, 'Boolean value true is false');
        QUnit.equal(isPlainObject(Boolean(true)), false, 'Boolean constructor');
    });
    QUnit.test('Numbers', function () {
        QUnit.equal(isPlainObject(15.66), false, 'number is not a plain object');
        QUnit.equal(isPlainObject(parseInt(13)), false, 'integer is not a plain object');
    });
    QUnit.test('NaN', function () {
        QUnit.equal(isPlainObject(NaN), false, 'NaN is not a plain object');
    });
});
/*can-util@3.3.2#js/is-promise-like/is-promise-like-test*/
define('can-util@3.3.2#js/is-promise-like/is-promise-like-test', function (require, exports, module) {
    var QUnit = require('../../test/qunit');
    var isPromise = require('./is-promise-like');
    QUnit.module('can-util/js/is-promise-like');
    QUnit.test('basics', function () {
        QUnit.ok(isPromise({
            then: function () {
            }
        }));
    });
});
/*can-util@3.3.2#js/make-promise/make-promise-test*/
define('can-util@3.3.2#js/make-promise/make-promise-test', function (require, exports, module) {
    var QUnit = require('../../test/qunit');
    var isPromise = require('../is-promise/is-promise');
    var makePromise = require('./make-promise');
    QUnit.module('can-util/js/make-promise');
    QUnit.test('basics', function () {
        var obj = {
            fail: function () {
            },
            then: function () {
            }
        };
        var promise = makePromise(obj);
        QUnit.ok(isPromise(promise));
        obj = {
            catch: function () {
            },
            then: function () {
            }
        };
        promise = makePromise(obj);
        QUnit.ok(isPromise(promise));
    });
});
/*can-util@3.3.2#js/omit/omit-test*/
define('can-util@3.3.2#js/omit/omit-test', function (require, exports, module) {
    var omit = require('./omit');
    var QUnit = require('../../test/qunit');
    QUnit.module('can-util/js/omit');
    QUnit.test('Omit properties from an object', function () {
        var source = {
            a: 1,
            b: 2,
            c: 3,
            d: 4
        };
        var propsToOmit = [
            'b',
            'd'
        ];
        var expected = {
            a: 1,
            c: 3
        };
        var actual = omit(source, propsToOmit);
        deepEqual(expected, actual);
    });
});
/*can-util@3.3.2#js/is-string/is-string-test*/
define('can-util@3.3.2#js/is-string/is-string-test', function (require, exports, module) {
    var QUnit = require('../../test/qunit');
    var isString = require('./is-string');
    QUnit.module('can-util/js/is-string');
    QUnit.test('basics', function () {
        QUnit.equal(isString('yes'), true);
        QUnit.equal(isString(String('yes')), true);
    });
});
/*can-util@3.3.2#js/is-web-worker/is-web-worker-test*/
define('can-util@3.3.2#js/is-web-worker/is-web-worker-test', function (require, exports, module) {
    var QUnit = require('../../test/qunit');
    var isWebWorker = require('./is-web-worker');
    QUnit.module('can-util/js/is-web-worker');
    QUnit.test('basics', function () {
        QUnit.equal(typeof isWebWorker(), 'boolean');
    });
});
/*can-util@3.3.2#js/join-uris/join-uris-test*/
define('can-util@3.3.2#js/join-uris/join-uris-test', function (require, exports, module) {
    var QUnit = require('../../test/qunit');
    var joinURIs = require('./join-uris');
    QUnit.module('can-util/js/join-uris');
    QUnit.test('basics', function () {
        QUnit.deepEqual(joinURIs('foo/bar/car.html', '../zed.html'), 'foo/zed.html');
    });
});
/*can-util@3.3.2#js/parse-uri/parse-uri-test*/
define('can-util@3.3.2#js/parse-uri/parse-uri-test', function (require, exports, module) {
    var QUnit = require('../../test/qunit');
    var parseURI = require('./parse-uri');
    QUnit.module('can-util/js/parse-uri');
    QUnit.test('basics', function () {
        QUnit.deepEqual(parseURI('http://foo:8080/bar.html#change'), {
            authority: '//foo:8080',
            hash: '#change',
            host: 'foo:8080',
            hostname: 'foo',
            href: 'http://foo:8080/bar.html#change',
            pathname: '/bar.html',
            port: '8080',
            protocol: 'http:',
            search: ''
        });
    });
});
/*can-util@3.3.2#js/last/last-test*/
define('can-util@3.3.2#js/last/last-test', function (require, exports, module) {
    var QUnit = require('../../test/qunit');
    var last = require('./last');
    QUnit.module('can-util/js/last');
    QUnit.test('basics', function () {
        QUnit.equal(last([
            'a',
            'b'
        ]), 'b');
    });
});
/*can-util@3.3.2#js/make-array/make-array-test*/
define('can-util@3.3.2#js/make-array/make-array-test', function (require, exports, module) {
    var QUnit = require('../../test/qunit');
    var makeArray = require('./make-array');
    QUnit.module('can-util/js/make-array');
    QUnit.test('basics', function () {
        var res = makeArray({
            0: 'a',
            length: 1
        });
        QUnit.deepEqual(res, ['a']);
        QUnit.ok(res instanceof Array);
    });
});
/*can-util@3.3.2#js/make-map/make-map*/
define('can-util@3.3.2#js/make-map/make-map', function (require, exports, module) {
    var each = require('../each/each');
    function makeMap(str) {
        var obj = {}, items = str.split(',');
        each(items, function (name) {
            obj[name] = true;
        });
        return obj;
    }
    module.exports = makeMap;
});
/*can-util@3.3.2#js/make-map/make-map-test*/
define('can-util@3.3.2#js/make-map/make-map-test', function (require, exports, module) {
    var QUnit = require('../../test/qunit');
    var makeMap = require('./make-map');
    QUnit.module('can-util/js/make-map');
    QUnit.test('basics', function () {
        var res = makeMap('a,b,c');
        QUnit.deepEqual(res, {
            a: true,
            b: true,
            c: true
        });
        QUnit.ok(res instanceof Object);
    });
});
/*can-util@3.3.2#js/set-not-enumerable/set-not-enumerable*/
define('can-util@3.3.2#js/set-not-enumerable/set-not-enumerable', function (require, exports, module) {
    module.exports = function (obj, prop, value) {
        Object.defineProperty(obj, prop, {
            configurable: true,
            enumerable: false,
            writable: true,
            value: value
        });
    };
});
/*can-util@3.3.2#js/set-not-enumerable/set-not-enumerable-test*/
define('can-util@3.3.2#js/set-not-enumerable/set-not-enumerable-test', function (require, exports, module) {
    var QUnit = require('../../test/qunit');
    var setNotEnumerable = require('./set-not-enumerable');
    QUnit.module('can-util/js/set-not-enumerable');
    QUnit.test('basics', 0, function () {
        var obj = {};
        setNotEnumerable(obj, 'prop', 'val');
        for (var prop in obj) {
            ok(false, prop);
        }
    });
});
/*can-util@3.3.2#js/string/string-test*/
define('can-util@3.3.2#js/string/string-test', function (require, exports, module) {
    var QUnit = require('../../test/qunit');
    var string = require('./string');
    QUnit.module('can-util/js/string');
    QUnit.test('string.sub', function () {
        equal(string.sub('a{b}', { b: 'c' }), 'ac');
        var foo = { b: 'c' };
        equal(string.sub('a{b}', foo, true), 'ac');
        ok(!foo.b, 'b\'s value was removed');
    });
    QUnit.test('string.sub with undefined values', function () {
        var subbed = string.sub('test{exists} plus{noexists}', { exists: 'test' });
        deepEqual(subbed, null, 'Rendering with undefined values should return null');
        subbed = string.sub('test{exists} plus{noexists}', { exists: 'test' }, true);
        deepEqual(subbed, null, 'Rendering with undefined values should return null even when remove param is true');
    });
    QUnit.test('string.sub with null values', function () {
        var subbed = string.sub('test{exists} plus{noexists}', {
            exists: 'test',
            noexists: null
        });
        deepEqual(subbed, null, 'Rendering with null values should return null');
        subbed = string.sub('test{exists} plus{noexists}', {
            exists: 'test',
            noexists: null
        }, true);
        deepEqual(subbed, null, 'Rendering with null values should return null even when remove param is true');
    });
    QUnit.test('string.sub double', function () {
        equal(string.sub('{b} {d}', {
            b: 'c',
            d: 'e'
        }), 'c e');
    });
    QUnit.test('String.underscore', function () {
        equal(string.underscore('Foo.Bar.ZarDar'), 'foo.bar.zar_dar');
    });
    QUnit.test('string.sub remove', function () {
        var obj = { a: 'a' };
        equal(string.sub('{a}', obj, false), 'a');
        deepEqual(obj, { a: 'a' });
        equal(string.sub('{a}', obj, true), 'a');
        deepEqual(obj, {});
    });
    QUnit.test('string.getObject Single root', function () {
        var root, result;
        root = { foo: 'bar' };
        result = string.getObject('foo', root);
        equal(result, 'bar', 'got \'bar\'');
        result = string.getObject('baz', root);
        equal(result, undefined, 'got \'undefined\'');
    });
    QUnit.test('string.getObject Multiple root', function () {
        var root1, root2, roots, result;
        root1 = { a: 1 };
        root2 = { b: 2 };
        roots = [
            root1,
            root2
        ];
        result = string.getObject('a', roots);
        equal(result, 1, 'got \'1\'');
        result = string.getObject('b', roots);
        equal(result, 2, 'got \'2\'');
        result = string.getObject('c', roots);
        equal(result, undefined, 'got \'undefined\'');
        root1 = undefined;
        root2 = { b: 2 };
        roots = [
            root1,
            root2
        ];
        result = string.getObject('b', roots);
        equal(result, 2, 'got \'2\'');
    });
    QUnit.test('string.getObject Deep objects', function () {
        var root, result;
        root = { foo: { bar: 'baz' } };
        result = string.getObject('foo.bar', root);
        equal(result, 'baz', 'got \'baz\'');
        result = string.getObject('foo.world', root);
        equal(result, undefined, 'got \'undefined\'');
    });
    QUnit.test('string.esc', function () {
        var text = string.esc(0);
        equal(text, '0', '0 value properly rendered');
        text = string.esc(null);
        deepEqual(text, '', 'null value returns empty string');
        text = string.esc();
        deepEqual(text, '', 'undefined returns empty string');
        text = string.esc(NaN);
        deepEqual(text, '', 'NaN returns empty string');
        text = string.esc('<div>&nbsp;</div>');
        equal(text, '&lt;div&gt;&amp;nbsp;&lt;/div&gt;', 'HTML escaped properly');
    });
    QUnit.test('string.camelize', function () {
        var text = string.camelize(0);
        equal(text, '0', '0 value properly rendered');
        text = string.camelize(null);
        equal(text, '', 'null value returns empty string');
        text = string.camelize();
        equal(text, '', 'undefined returns empty string');
        text = string.camelize(NaN);
        equal(text, '', 'NaN returns empty string');
        text = string.camelize('-moz-index');
        equal(text, 'MozIndex');
        text = string.camelize('foo-bar');
        equal(text, 'fooBar');
    });
    QUnit.test('string.hyphenate', function () {
        var text = string.hyphenate(0);
        equal(text, '0', '0 value properly rendered');
        text = string.hyphenate(null);
        equal(text, '', 'null value returns empty string');
        text = string.hyphenate();
        equal(text, '', 'undefined returns empty string');
        text = string.hyphenate(NaN);
        equal(text, '', 'NaN returns empty string');
        text = string.hyphenate('ABC');
        equal(text, 'ABC');
        text = string.hyphenate('dataNode');
        equal(text, 'data-node');
    });
});
/*can-util@3.3.2#js/string-to-any/string-to-any-test*/
define('can-util@3.3.2#js/string-to-any/string-to-any-test', function (require, exports, module) {
    var QUnit = require('../../test/qunit');
    var stringToAny = require('./string-to-any');
    var each = require('../each/each');
    QUnit.module('can-util/js/string-to-any');
    QUnit.test('works with primitive types', function () {
        var fixture = {
            'foo': 'foo',
            '33': 33,
            'true': true,
            'false': false,
            'undefined': undefined,
            'null': null,
            'Infinity': Infinity
        };
        each(fixture, function (value, key) {
            QUnit.ok(stringToAny(key) === value, 'Correctly converted type: ' + key);
        });
        QUnit.ok(isNaN(stringToAny('NaN')), 'Correclty converted type: NaN');
    });
});
/*can-util@3.3.2#js/param/param-test*/
define('can-util@3.3.2#js/param/param-test', function (require, exports, module) {
    var QUnit = require('../../test/qunit');
    var param = require('./param');
    QUnit.module('can-util/js/param');
    QUnit.test('param', function () {
        QUnit.deepEqual(param({
            foo: 'bar',
            baz: 'zed'
        }), 'foo=bar&baz=zed', 'Regular object');
        QUnit.deepEqual(param({ foo: { bar: 'baz' } }), encodeURI('foo[bar]=baz'), 'Nested object');
        QUnit.deepEqual(param({
            foo: [
                'bar',
                'baz'
            ]
        }), encodeURI('foo[]=bar&foo[]=baz'), 'Nested array');
        QUnit.deepEqual(param({ foo: 'bar & baz' }), 'foo=bar+%26+baz', 'Spec chars values');
    });
});
/*can-util@3.3.2#js/tests.js*/
define('can-util@3.3.2#js/tests.js', function (require, exports, module) {
    (function (global) {
        require('./assign/assign-test');
        require('./base-url/base-url-test');
        require('./cid-map/cid-map-test');
        require('./cid-set/cid-set-test');
        require('./deep-assign/deep-assign-test');
        require('./defaults/defaults-test');
        require('./dev/dev-test');
        require('./log/log-test');
        require('./diff/diff-test');
        require('./diff-array/diff-array-test');
        require('./diff-object/diff-object-test');
        require('./each/each-test');
        require('./get/get-test');
        require('./global/global-test');
        require('./import/import-test');
        require('./is-array/is-array-test');
        require('./is-array-like/is-array-like-test');
        require('./is-browser-window/is-browser-window-test');
        require('./is-container/is-container-test');
        require('./is-empty-object/is-empty-object-test');
        require('./is-function/is-function-test');
        require('./is-node/is-node-test');
        require('./is-plain-object/is-plain-object-test');
        require('./is-promise-like/is-promise-like-test');
        require('./make-promise/make-promise-test');
        require('./omit/omit-test');
        require('./is-string/is-string-test');
        require('./is-web-worker/is-web-worker-test');
        require('./join-uris/join-uris-test');
        require('./parse-uri/parse-uri-test');
        require('./last/last-test');
        require('./make-array/make-array-test');
        require('./make-map/make-map-test');
        require('./set-not-enumerable/set-not-enumerable-test');
        require('./string/string-test');
        require('./string-to-any/string-to-any-test');
        require('./param/param-test');
    }(function () {
        return this;
    }()));
});
/*can-util@3.3.2#dom/ajax/ajax-test*/
define('can-util@3.3.2#dom/ajax/ajax-test', function (require, exports, module) {
    (function (__dirname) {
        var ajax = require('can-util/dom/ajax/ajax');
        var namespace = require('can-namespace');
        var makeMap = require('can-util/js/make-map/make-map');
        QUnit = require('steal-qunit');
        QUnit.module('can-util/dom/ajax');
        var makeFixture = function (XHR) {
            var oldXhr = window.XMLHttpRequest || window.ActiveXObject;
            if (window.XMLHttpRequest) {
                window.XMLHttpRequest = XHR;
            } else if (window.ActiveXObject) {
                window.ActiveXObject = XHR;
            }
            return function restoreXHR() {
                if (window.XMLHttpRequest) {
                    window.XMLHttpRequest = oldXhr;
                } else if (window.ActiveXObject) {
                    window.ActiveXObject = oldXhr;
                }
            };
        };
        var makePredicateContains = function (str) {
            var obj = makeMap(str);
            return function (val) {
                return obj[val];
            };
        };
        if (__dirname !== '/') {
            QUnit.asyncTest('basic get request', function () {
                ajax({
                    type: 'get',
                    url: __dirname + '/test-result.json'
                }).then(function (resp) {
                    QUnit.equal(resp.message, 'VALUE');
                    start();
                });
            });
        }
        QUnit.test('added to namespace (#99)', function () {
            QUnit.equal(namespace.ajax, ajax);
        });
        if (__dirname !== '/') {
            QUnit.asyncTest('GET requests with dataType parse JSON (#106)', function () {
                ajax({
                    type: 'get',
                    url: __dirname + '/test-result.txt',
                    dataType: 'json'
                }).then(function (resp) {
                    QUnit.equal(resp.message, 'VALUE');
                    start();
                });
            });
        }
        QUnit.asyncTest('ignores case of type parameter for a post request (#100)', function () {
            var requestHeaders = { CONTENT_TYPE: 'Content-Type' }, restore = makeFixture(function () {
                    this.open = function (type, url) {
                    };
                    this.send = function () {
                        this.readyState = 4;
                        this.status = 200;
                        this.onreadystatechange();
                    };
                    this.setRequestHeader = function (header, value) {
                        if (header === requestHeaders.CONTENT_TYPE) {
                            var o = {};
                            o[header] = value;
                            this.responseText = JSON.stringify(o);
                        }
                    };
                });
            ajax({
                type: 'post',
                url: 'http://anotherdomain.com/foo',
                data: { bar: 'qux' }
            }).then(function (value) {
                QUnit.equal(value[requestHeaders.CONTENT_TYPE], 'application/x-www-form-urlencoded');
            }, function (reason) {
                QUnit.notOk(reason, 'request failed with reason = ', reason);
            }).then(function () {
                restore();
                start();
            });
        });
        if (typeof XDomainRequest === 'undefined') {
            QUnit.asyncTest('cross domain post request should change data to form data (#90)', function () {
                ajax({
                    type: 'POST',
                    url: 'http://httpbin.org/post',
                    data: { 'message': 'VALUE' },
                    dataType: 'application/json'
                }).then(function (resp) {
                    QUnit.equal(resp.form.message, 'VALUE');
                    start();
                });
            });
            QUnit.asyncTest('GET CORS should be a simple request - without a preflight (#187)', function () {
                var isSimpleRequest = true, restore;
                var isSimpleMethod = makePredicateContains('GET,POST,HEAD');
                var isSimpleHeader = makePredicateContains('Accept,Accept-Language,Content-Language,Content-Type,DPR,Downlink,Save-Data,Viewport-Width,Width');
                var isSimpleContentType = makePredicateContains('application/x-www-form-urlencoded,multipart/form-data,text/plain');
                restore = makeFixture(function () {
                    this.open = function (type, url) {
                        if (!isSimpleMethod(type)) {
                            isSimpleRequest = false;
                        }
                    };
                    var response = {};
                    this.send = function () {
                        this.responseText = JSON.stringify(response);
                        this.readyState = 4;
                        this.status = 200;
                        this.onreadystatechange();
                    };
                    this.setRequestHeader = function (header, value) {
                        if (header === 'Content-Type' && !isSimpleHeader(value)) {
                            isSimpleRequest = false;
                        }
                        if (isSimpleContentType(header)) {
                            isSimpleRequest = false;
                        }
                        response[header] = value;
                    };
                });
                ajax({
                    url: 'http://query.yahooapis.com/v1/public/yql',
                    data: {
                        q: 'select * from geo.places where text="sunnyvale, ca"',
                        format: 'json'
                    }
                }).then(function (response) {
                    QUnit.ok(isSimpleRequest, 'CORS GET is simple');
                    restore();
                    start();
                }, function (err) {
                    QUnit.ok(false, 'Should be resolved');
                    restore();
                    start();
                });
            });
        }
        if (System.env !== 'canjs-test' && __dirname !== '/') {
            QUnit.asyncTest('abort', function () {
                var promise = ajax({
                    type: 'get',
                    url: __dirname + '/test-result.json'
                });
                promise.catch(function (xhr) {
                    if (xhr instanceof Error) {
                        QUnit.equal(xhr.message, 'Could not complete the operation due to error c00c023f.');
                        start();
                    } else {
                        setTimeout(function () {
                            QUnit.equal(xhr.readyState, 0, 'aborts the promise');
                            start();
                        }, 50);
                    }
                });
                promise.abort();
            });
        }
        QUnit.asyncTest('crossDomain is true for relative requests', function () {
            var headers = {}, restore = makeFixture(function () {
                    this.open = function (type, url) {
                    };
                    this.send = function () {
                        this.readyState = 4;
                        this.status = 200;
                        this.responseText = JSON.stringify({ great: 'success' });
                        this.onreadystatechange();
                    };
                    this.setRequestHeader = function (header, value) {
                        headers[header] = value;
                    };
                });
            ajax({
                type: 'post',
                url: '/foo',
                data: { bar: 'qux' },
                dataType: 'json'
            }).then(function (value) {
                QUnit.deepEqual(headers, {
                    'Content-Type': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest'
                });
            }, function (reason) {
                QUnit.notOk(reason, 'request failed with reason = ', reason);
            }).then(function () {
                restore();
                start();
            });
        });
        if (__dirname !== '/') {
            QUnit.asyncTest('correctly serializes null and undefined values (#177)', function () {
                ajax({
                    type: 'get',
                    url: __dirname + '/test-result.txt',
                    data: { foo: null }
                }).then(function (resp) {
                    QUnit.equal(resp.message, 'VALUE');
                    start();
                });
            });
        }
    }('/'));
});
/*can-util@3.3.2#dom/attr/attr-test*/
define('can-util@3.3.2#dom/attr/attr-test', function (require, exports, module) {
    var domAttr = require('../attr/attr');
    var domEvents = require('../events/events');
    var domData = require('../data/data');
    var domDispatch = require('../dispatch/dispatch');
    var mutate = require('../mutate/mutate');
    var MUTATION_OBSERVER = require('can-util/dom/mutation-observer/mutation-observer');
    var types = require('can-types');
    QUnit = require('steal-qunit');
    QUnit.module('can-util/dom/attr');
    test('attributes event', function () {
        var div = document.createElement('div');
        var attrHandler1 = function (ev) {
            equal(ev.attributeName, 'foo', 'attribute name is correct');
            equal(ev.target, div, 'target');
            equal(ev.oldValue, null, 'oldValue');
            equal(div.getAttribute(ev.attributeName), 'bar');
            domEvents.removeEventListener.call(div, 'attributes', attrHandler1);
        };
        domEvents.addEventListener.call(div, 'attributes', attrHandler1);
        domAttr.set(div, 'foo', 'bar');
        stop();
        setTimeout(function () {
            var attrHandler = function (ev) {
                ok(true, 'removed event handler should be called');
                equal(ev.attributeName, 'foo', 'attribute name is correct');
                equal(ev.target, div, 'target');
                equal(ev.oldValue, 'bar', 'oldValue should be \'bar\'');
                equal(div.getAttribute(ev.attributeName), null, 'value of the attribute should be null after the remove.');
                domEvents.removeEventListener.call(div, 'attributes', attrHandler);
                start();
            };
            domEvents.addEventListener.call(div, 'attributes', attrHandler);
            domAttr.remove(div, 'foo');
        }, 50);
    });
    test('attr events without MUTATION_OBSERVER', 9, function () {
        var MO = MUTATION_OBSERVER();
        MUTATION_OBSERVER(null);
        var div = document.createElement('div');
        var attrHandler1 = function (ev) {
            equal(ev.attributeName, 'foo', 'attribute name is correct');
            equal(ev.target, div, 'target');
            equal(ev.oldValue, null, 'oldValue');
            equal(div.getAttribute(ev.attributeName), 'bar');
            domEvents.removeEventListener.call(div, 'attributes', attrHandler1);
        };
        domEvents.addEventListener.call(div, 'attributes', attrHandler1);
        domAttr.set(div, 'foo', 'bar');
        stop();
        setTimeout(function () {
            var attrHandler = function (ev) {
                ok(true, 'removed event handler should be called');
                equal(ev.attributeName, 'foo', 'attribute name is correct');
                equal(ev.target, div, 'target');
                equal(ev.oldValue, 'bar', 'oldValue should be \'bar\'');
                equal(div.getAttribute(ev.attributeName), null, 'value of the attribute should be null after the remove.');
                domEvents.removeEventListener.call(div, 'attributes', attrHandler);
                MUTATION_OBSERVER(MO);
                start();
            };
            domEvents.addEventListener.call(div, 'attributes', attrHandler);
            domAttr.remove(div, 'foo');
        }, 50);
    });
    test('attr.set CHECKED attribute works', function () {
        var input = document.createElement('input');
        input.type = 'checkbox';
        document.getElementById('qunit-fixture').appendChild(input);
        domAttr.set(input, 'CHECKED');
        equal(input.checked, true);
        input.checked = false;
        domAttr.set(input, 'CHECKED');
        equal(input.checked, true);
        document.getElementById('qunit-fixture').removeChild(input);
    });
    test('Map special attributes', function () {
        var div = document.createElement('label');
        document.getElementById('qunit-fixture').appendChild(div);
        domAttr.set(div, 'for', 'my-for');
        equal(div.htmlFor, 'my-for', 'Map for to htmlFor');
        if ('innerText' in div) {
            domAttr.set(div, 'innertext', 'my-inner-text');
            equal(div.innerText, 'my-inner-text', 'Map innertext to innerText');
        }
        domAttr.set(div, 'textcontent', 'my-content');
        equal(div.textContent, 'my-content', 'Map textcontent to textContent');
        document.getElementById('qunit-fixture').removeChild(div);
        div = document.createElement('input');
        div.type = 'text';
        document.getElementById('qunit-fixture').appendChild(div);
        domAttr.set(div, 'readonly');
        equal(div.readOnly, true, 'Map readonly to readOnly');
        domAttr.set(div, 'readonly', false);
        equal(div.readOnly, false, 'not readonly');
        domAttr.set(div, 'readonly', '');
        equal(div.readOnly, true, 'readonly again');
        document.getElementById('qunit-fixture').removeChild(div);
    });
    test('set class attribute via className or setAttribute for svg (#2015)', function () {
        var div = document.createElement('div');
        var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        var obj = {
            toString: function () {
                return 'my-class';
            }
        };
        domAttr.set(div, 'class', 'my-class');
        equal(div.getAttribute('class'), 'my-class', 'class mapped to className');
        domAttr.set(div, 'class', undefined);
        equal(div.getAttribute('class'), '', 'an undefined className is an empty string');
        domAttr.set(div, 'class', obj);
        equal(div.getAttribute('class'), 'my-class', 'you can pass an object to className');
        domAttr.set(svg, 'class', 'my-class');
        equal(svg.getAttribute('class'), 'my-class', 'svg class was set as an attribute');
        domAttr.set(svg, 'class', undefined);
        equal(svg.getAttribute('class'), '', 'an undefined svg class is an empty string');
        domAttr.set(svg, 'class', obj);
        equal(svg.getAttribute('class'), 'my-class', 'you can pass an object to svg class');
    });
    test('set xlink:href attribute via setAttributeNS for svg-use (#2384)', function () {
        var use = document.createElementNS('http://www.w3.org/2000/svg', 'use');
        domAttr.set(use, 'xlink:href', 'svgUri');
        equal(use.getAttributeNS('http://www.w3.org/1999/xlink', 'href'), 'svgUri', 'svg-use xlink:href was set with setAttributeNS');
    });
    test('attr.special addEventListener allows custom binding', function () {
        var trigger;
        domAttr.special.foo = {
            addEventListener: function (eventName, handler) {
                trigger = function () {
                    handler();
                };
                return function () {
                    trigger = function () {
                    };
                };
            },
            set: function (val) {
                this.foo = val;
                trigger();
            }
        };
        var div = document.createElement('div');
        var times = 0;
        var handler = function () {
            times++;
            equal(times, 1, 'addEventListener called');
        };
        domEvents.addEventListener.call(div, 'foo', handler);
        domAttr.set(div, 'foo', 'bar');
        domEvents.removeEventListener.call(div, 'foo', handler);
        domAttr.set(div, 'foo', 'baz');
        delete domAttr.special.foo;
    });
    test('\'selected\' is bindable on an <option>', function () {
        var select = document.createElement('select');
        var option1 = document.createElement('option');
        option1.value = 'one';
        var option2 = document.createElement('option');
        option2.value = 'two';
        select.appendChild(option1);
        select.appendChild(option2);
        domEvents.addEventListener.call(option2, 'selected', function () {
            ok(true, 'selected was called on the option');
        });
        option2.selected = true;
        domDispatch.call(select, 'change');
        equal(domAttr.get(option1, 'selected'), false, 'option1 is not selected');
        equal(domAttr.get(option2, 'selected'), true, 'option2 is selected');
    });
    test('get, set, and addEventListener on values', function () {
        var select = document.createElement('select');
        select.multiple = true;
        var option1 = document.createElement('option');
        option1.value = 'one';
        var option2 = document.createElement('option');
        option2.value = 'two';
        select.appendChild(option1);
        select.appendChild(option2);
        var valuesCount = 0;
        domEvents.addEventListener.call(select, 'values', function () {
            valuesCount++;
        });
        deepEqual(domAttr.get(select, 'values'), [], 'None selected to start');
        option1.selected = true;
        domDispatch.call(select, 'change');
        equal(valuesCount, 1, 'values event');
        deepEqual(domAttr.get(select, 'values'), ['one'], 'First option is in values');
        option2.selected = true;
        domDispatch.call(select, 'change');
        equal(valuesCount, 2, 'values event');
        deepEqual(domAttr.get(select, 'values'), [
            'one',
            'two'
        ], 'both selected');
        option1.selected = option2.selected = false;
        domDispatch.call(select, 'change');
        equal(valuesCount, 3, 'values event');
        deepEqual(domAttr.get(select, 'values'), [], 'none selected');
        domAttr.set(select, 'values', ['two']);
        equal(option1.selected, false, 'option1 not selected');
        equal(option2.selected, true, 'option2 selected');
        deepEqual(domAttr.get(select, 'values'), ['two'], 'two is only selected');
    });
    test('get, set, and addEventListener on innerHTML', function () {
        var div = document.createElement('div');
        div.appendChild(document.createElement('span'));
        var count = 0;
        domEvents.addEventListener.call(div, 'innerHTML', function () {
            count++;
        });
        equal(domAttr.get(div, 'innerHTML'), '<span></span>', 'got innerhtml');
        domAttr.set(div, 'innerHTML', '<p>hello</p>');
        domDispatch.call(div, 'change');
        equal(count, 1, 'innerHTML event');
        equal(domAttr.get(div, 'innerHTML'), '<p>hello</p>', 'got innerhtml');
    });
    test('get, set on \'value\'', function () {
        var input = document.createElement('input');
        input.value = 'foo';
        equal(domAttr.get(input, 'value'), 'foo', 'got the value');
        domAttr.set(input, 'value', 'bar');
        equal(domAttr.get(input, 'value'), 'bar', 'got the value');
        input.value = '';
        equal(domAttr.get(input, 'value'), '', 'value is an empty string');
    });
    test('get/sets the checkedness of a checkbox', function () {
        var input = document.createElement('input');
        input.type = 'checkbox';
        equal(domAttr.get(input, 'checked'), false, 'not checked');
        domAttr.set(input, 'checked', true);
        equal(domAttr.get(input, 'checked'), true, 'now it is true');
        domAttr.set(input, 'checked', false);
        equal(domAttr.get(input, 'checked'), false, 'now it is false');
        domAttr.set(input, 'checked');
        equal(domAttr.get(input, 'checked'), true, 'now it is true');
        domAttr.set(input, 'checked', 0);
        equal(domAttr.get(input, 'checked'), false, 'now it is false');
        domAttr.set(input, 'checked', '');
        equal(domAttr.get(input, 'checked'), true, 'now it is true');
    });
    test('For inputs checked is set as an attribute', function () {
        var input = document.createElement('input');
        input.type = 'checkbox';
        domAttr.set(input, 'checked', '');
        equal(input.checked, true, 'checked is true');
        equal(input.getAttribute('checked'), undefined, 'no checked attr');
        var customEl = document.createElement('custom-element');
        domAttr.set(customEl, 'checked', '');
        ok(customEl.hasAttribute('checked'), 'has checked attr');
        equal(customEl.getAttribute('checked'), '', 'attr is an empty string');
        equal(domAttr.get(customEl, 'checked'), '', 'attr from get');
    });
    test('attr.special.value, fallback to the attribute', function () {
        var customEl = document.createElement('custom-element');
        customEl.setAttribute('value', 'foo');
        equal(domAttr.get(customEl, 'value'), 'foo', 'value is foo');
    });
    test('Setting a select\'s value updates child\'s selectedness', function () {
        var select = document.createElement('select');
        var option1 = document.createElement('option');
        option1.value = 'one';
        option1.selected = true;
        var option2 = document.createElement('option');
        option2.value = 'two';
        select.appendChild(option1);
        select.appendChild(option2);
        equal(domAttr.get(select, 'value'), 'one', 'initial value');
        domAttr.set(select, 'value', 'two');
        equal(option1.selected, false, 'not selected');
        equal(option2.selected, true, 'now it is selected');
    });
    test('Removing an option causes the select\'s value to be re-evaluated', function () {
        var select = document.createElement('select');
        var option1 = document.createElement('option');
        option1.value = 'one';
        var option2 = document.createElement('option');
        option2.value = 'two';
        select.appendChild(option1);
        select.appendChild(option2);
        domAttr.set(select, 'value', 'one');
        equal(option1.selected, true, 'selected');
        equal(domAttr.get(select, 'value'), 'one', 'got the value');
        domEvents.addEventListener.call(select, 'change', function () {
            equal(domAttr.get(select, 'value'), undefined, 'no value now');
            start();
        });
        stop();
        select.removeChild(option1);
        if (!MUTATION_OBSERVER()) {
            var data = domData.get.call(select, 'canBindingCallback');
            data.onMutation();
        }
    });
    test('Multiselect values is updated on any children added/removed', function () {
        var select = document.createElement('select');
        select.multiple = true;
        var option1 = document.createElement('option');
        option1.value = 'one';
        var option2 = document.createElement('option');
        option2.value = 'two';
        var option3 = document.createElement('option');
        option3.value = 'three';
        option3.selected = true;
        select.appendChild(option1);
        select.appendChild(option2);
        select.appendChild(option3);
        domAttr.set(select, 'values', [
            'one',
            'three'
        ]);
        deepEqual(domAttr.get(select, 'values'), [
            'one',
            'three'
        ], 'initial value is right');
        domEvents.addEventListener.call(select, 'values', function () {
            deepEqual(domAttr.get(select, 'values'), ['three'], 'new val is right');
            start();
        });
        stop();
        select.removeChild(option1);
        if (!MUTATION_OBSERVER()) {
            var data = domData.get.call(select, 'canBindingCallback');
            data.onMutation();
        }
    });
    test('Setting a value that will be appended later', function () {
        var select = document.createElement('select');
        var option1 = document.createElement('option');
        option1.value = 'one';
        domAttr.set(select, 'value', 'two');
        var option2 = document.createElement('option');
        option2.value = 'two';
        domEvents.addEventListener.call(select, 'change', function () {
            equal(domAttr.get(select, 'value'), 'two', 'option2 is selected');
            start();
        });
        stop();
        select.appendChild(option2);
        if (!MUTATION_OBSERVER()) {
            var data = domData.get.call(select, 'canBindingCallback');
            data.onMutation();
        }
    });
    test('Calling remove on checked sets it to false', function () {
        var input = document.createElement('input');
        input.type = 'checkbox';
        domAttr.set(input, 'checked');
        equal(input.checked, true, 'it is checked');
        domAttr.remove(input, 'checked');
        equal(input.checked, false, 'not checked');
    });
    test('Boolean attrs that don\'t support a prop sets the attribute', function () {
        var div = document.createElement('div');
        domAttr.set(div, 'disabled');
        equal(domAttr.get(div, 'disabled'), '', 'empty string');
    });
    test('Setting a non-string value on a select correctly selects the child', function () {
        var select = document.createElement('select');
        var option1 = document.createElement('option');
        option1.value = '1';
        var option2 = document.createElement('option');
        option2.value = '2';
        select.appendChild(option1);
        select.appendChild(option2);
        domAttr.set(select, 'value', 2);
        equal(option2.selected, true, 'second one is selected');
    });
    test('Setting null doesn\'t select the default value on a select', function () {
        var select = document.createElement('select');
        var option1 = document.createElement('option');
        option1.value = '';
        var option2 = document.createElement('option');
        option2.value = 'two';
        select.appendChild(option1);
        select.appendChild(option2);
        domAttr.set(select, 'value', null);
        equal(option1.selected, false, 'option1 not selected');
        equal(option2.selected, false, 'option2 not selected');
        equal(select.selectedIndex, -1, 'no selected index, wha-wha');
    });
    test('setting .value on an input to undefined or null makes value empty (#83)', function () {
        var input = document.createElement('input');
        input.value = 'something';
        domAttr.set(input, 'value', null);
        QUnit.equal(input.value, '', 'null');
        domAttr.set(input, 'value', undefined);
        QUnit.equal(input.value, '', 'undefined');
    });
    test('attr.special.focused calls after previous events', function () {
        var oldQueue = types.queueTask;
        types.queueTask = function (task) {
            setTimeout(function () {
                task[0].apply(task[1], task[2]);
            }, 5);
        };
        var input = document.createElement('input');
        input.type = 'text';
        var ta = document.getElementById('qunit-fixture');
        ta.appendChild(input);
        stop();
        domAttr.set(input, 'focused', true);
        setTimeout(function () {
            equal(domAttr.get(input, 'focused'), true, 'it is now focused');
            types.queueTask = oldQueue;
            start();
        }, 10);
        equal(domAttr.get(input, 'focused'), false, 'not focused yet');
    });
    test('handles removing multiple event handlers', function () {
        var handler1 = function () {
        };
        var handler2 = function () {
        };
        var div = document.createElement('div');
        domEvents.addEventListener.call(div, 'attributes', handler1, false);
        domEvents.addEventListener.call(div, 'attributes', handler2, false);
        domEvents.removeEventListener.call(div, 'attributes', handler1);
        domEvents.removeEventListener.call(div, 'attributes', handler2);
        ok(true, 'should not throw');
    });
    test('handles removing multiple event handlers without MUTATION_OBSERVER', function () {
        var MO = MUTATION_OBSERVER();
        MUTATION_OBSERVER(null);
        var handler1 = function () {
        };
        var handler2 = function () {
        };
        var div = document.createElement('div');
        domEvents.addEventListener.call(div, 'attributes', handler1, false);
        domEvents.addEventListener.call(div, 'attributes', handler2, false);
        domEvents.removeEventListener.call(div, 'attributes', handler1);
        domEvents.removeEventListener.call(div, 'attributes', handler2);
        ok(true, 'should not throw');
        MUTATION_OBSERVER(MO);
    });
    if (window.eventsBubble) {
        test('get, set, and addEventListener on focused', function () {
            var input = document.createElement('input');
            var ta = document.getElementById('qunit-fixture');
            var test;
            var focusedCount = 0;
            ta.appendChild(input);
            var tests = [
                {
                    action: function () {
                        equal(domAttr.get(input, 'focused'), false, 'get not focused');
                        domAttr.set(input, 'focused', true);
                        if (!document.hasFocus()) {
                            domDispatch.call(input, 'focus');
                        }
                    },
                    test: function () {
                        equal(focusedCount, 1, 'focused event');
                        equal(domAttr.get(input, 'focused'), true, 'get focused');
                    }
                },
                {
                    action: function () {
                        domAttr.set(input, 'focused', false);
                        if (!document.hasFocus()) {
                            domDispatch.call(input, 'blur');
                        }
                    },
                    test: function () {
                        equal(focusedCount, 2, 'focused event');
                        equal(domAttr.get(input, 'focused'), false, 'get not focused after blur');
                    }
                }
            ];
            function next() {
                test = tests.shift();
                if (!test) {
                    start();
                    return;
                }
                test.action();
            }
            ok(domAttr.special.focused.addEventListener, 'addEventListener implemented');
            domEvents.addEventListener.call(input, 'focused', function () {
                focusedCount++;
                test.test();
                setTimeout(next, 50);
            });
            stop();
            next();
        });
    }
    test('Binding to selected updates the selectedness of options', function () {
        expect(3);
        var select = document.createElement('select');
        var option1 = document.createElement('option');
        option1.selected = false;
        option1.value = 'one';
        select.appendChild(option1);
        var option2 = document.createElement('option');
        option2.value = 'two';
        select.appendChild(option2);
        domEvents.addEventListener.call(option1, 'selected', function () {
            ok(true, 'this was called');
        });
        domAttr.set(option1, 'selected', true);
        option2.selected = true;
        domDispatch.call(select, 'change');
        equal(option2.selected, true);
        equal(option1.selected, false);
    });
    test('Select\'s value is preserved when inserted into the document', function () {
        stop();
        var select = document.createElement('select');
        var option1 = document.createElement('option');
        option1.value = 'one';
        select.appendChild(option1);
        domAttr.set(select, 'value', null);
        equal(select.selectedIndex, -1, 'was set to -1');
        var ta = document.getElementById('qunit-fixture');
        mutate.appendChild.call(ta, select);
        setTimeout(function () {
            equal(select.selectedIndex, -1, 'still is -1');
            start();
        }, 50);
    });
    test('multi-select does not dispatch a values change event if its selected options are unchanged (#105)', function () {
        var div = document.createElement('div');
        div.innerHTML = '<select multiple><option selected>2</option><option selected>1</option><option>3</option></select>';
        var select = div.firstChild;
        document.body.appendChild(div);
        var valuesChanges = 0;
        domEvents.addEventListener.call(select, 'values', function () {
            valuesChanges++;
        });
        domAttr.set(select, 'values', [
            '1',
            '2'
        ]);
        select.innerHTML = '<option selected>1</option><option selected>2</option><option>3</option>';
        QUnit.stop();
        setTimeout(function () {
            QUnit.strictEqual(valuesChanges, 0, 'we do not dispatch a change event');
            document.body.removeChild(div);
            QUnit.start();
        }, 50);
    });
    test('setting checked to undefined should result in false for checkboxes (#184)', function () {
        var input = document.createElement('input');
        input.type = 'checkbox';
        domAttr.set(input, 'checked', undefined);
        QUnit.equal(input.checked, false, 'Should set checked to false');
        domAttr.set(input, 'checked', true);
        QUnit.equal(input.checked, true, 'Should become true');
        domAttr.set(input, 'checked', undefined);
        QUnit.equal(input.checked, false, 'Should become false again');
    });
});
/*can-util@3.3.2#dom/dispatch/dispatch-test*/
define('can-util@3.3.2#dom/dispatch/dispatch-test', function (require, exports, module) {
    var domDispatch = require('can-util/dom/dispatch/');
    var domEvents = require('can-util/dom/events/');
    QUnit = require('steal-qunit');
    QUnit.module('can-util/dom/dispatch');
    test('basic synthetic events', function () {
        var div = document.createElement('div');
        domEvents.addEventListener.call(div, 'foo', function () {
            ok(true, 'called back');
        });
        domDispatch.call(div, 'foo');
    });
    test('more complex synthetic events', function () {
        var div = document.createElement('div');
        var arr = [];
        domEvents.addEventListener.call(div, 'attributes', function (ev) {
            ok(true, 'called back');
            equal(ev.something, arr, 'got data');
        });
        domDispatch.call(div, {
            type: 'attributes',
            something: arr
        }, ['a']);
    });
});
/*can-util@3.3.2#dom/events/delegate/delegate-test*/
define('can-util@3.3.2#dom/events/delegate/delegate-test', function (require, exports, module) {
    require('can-util/dom/events/inserted/');
    var domEvents = require('can-util/dom/events/');
    var domDispatch = require('can-util/dom/dispatch/');
    var domData = require('can-util/dom/data/');
    require('can-util/dom/events/delegate/');
    var buildFrag = require('can-util/dom/fragment/');
    QUnit = require('steal-qunit');
    QUnit.module('can-util/dom/events/delegate');
    test('basics', 2, function () {
        stop();
        var frag = buildFrag('<ul><li><span/></li><li></li></ul>');
        var ul = frag.firstChild;
        document.getElementById('qunit-fixture').appendChild(ul);
        var handler = function (ev) {
            ok(true, 'called');
            domEvents.removeDelegateListener.call(ul, 'click', 'li', handler);
            var dE = domData.get.call(this, 'delegateEvents');
            equal(dE, undefined, 'data removed');
            domEvents.addDelegateListener.call(ul, 'click', 'li', handler);
            start();
        };
        domEvents.addDelegateListener.call(ul, 'click', 'li', handler);
        domDispatch.call(ul.firstChild.firstChild, 'click');
    });
    test('focus', 2, function () {
        stop();
        var frag = buildFrag('<div><input type=\'text\'></div>');
        var div = frag.firstChild;
        document.getElementById('qunit-fixture').appendChild(div);
        var handler = function (ev) {
            ok(true, 'called');
            domEvents.removeDelegateListener.call(div, 'focus', 'input', handler);
            var dE = domData.get.call(this, 'delegateEvents');
            equal(dE, undefined, 'data removed');
            start();
        };
        domEvents.addDelegateListener.call(div, 'focus', 'input', handler);
        domDispatch.call(div.firstChild, 'focus', [], false);
    });
    test('blur', 2, function () {
        stop();
        var frag = buildFrag('<div><input type=\'text\'></div>');
        var div = frag.firstChild;
        document.getElementById('qunit-fixture').appendChild(div);
        var handler = function (ev) {
            ok(true, 'called');
            domEvents.removeDelegateListener.call(div, 'blur', 'input', handler);
            var dE = domData.get.call(this, 'delegateEvents');
            equal(dE, undefined, 'data removed');
            start();
        };
        domEvents.addDelegateListener.call(div, 'blur', 'input', handler);
        domDispatch.call(div.firstChild, 'blur', [], false);
    });
});
/*can-util@3.3.2#dom/events/inserted/inserted-test*/
define('can-util@3.3.2#dom/events/inserted/inserted-test', function (require, exports, module) {
    require('can-util/dom/events/inserted/');
    var domEvents = require('can-util/dom/events/');
    var MUTATION_OBSERVER = require('can-util/dom/mutation-observer/');
    var domMutate = require('can-util/dom/mutate/');
    QUnit = require('steal-qunit');
    function runTest(name, MUT_OBS) {
        var oldMutObs;
        QUnit.module(name, {
            setup: function () {
                oldMutObs = MUTATION_OBSERVER();
                MUTATION_OBSERVER(MUT_OBS);
            },
            teardown: function () {
                MUTATION_OBSERVER(oldMutObs);
            }
        });
        asyncTest('basic insertion with mutation observer', function () {
            var div = document.createElement('div');
            domEvents.addEventListener.call(div, 'inserted', function () {
                ok(true, 'called back');
                start();
            });
            domMutate.appendChild.call(document.getElementById('qunit-fixture'), div);
        });
        asyncTest('parent then child inserted - appendChild', function () {
            expect(1);
            var div = document.createElement('div');
            var span = document.createElement('span');
            domEvents.addEventListener.call(span, 'inserted', function () {
                ok(true, 'called back');
                start();
            });
            domMutate.appendChild.call(document.getElementById('qunit-fixture'), div);
            domMutate.appendChild.call(div, span);
        });
        asyncTest('parent then child inserted in callback - appendChild', function () {
            expect(1);
            var div = document.createElement('div');
            var span = document.createElement('span');
            domEvents.addEventListener.call(div, 'inserted', function () {
                domMutate.appendChild.call(div, span);
            });
            domEvents.addEventListener.call(span, 'inserted', function () {
                ok(true, 'called back');
                start();
            });
            domMutate.appendChild.call(document.getElementById('qunit-fixture'), div);
        });
    }
    runTest('can-util/dom/events/inserted - MutationObserver', MUTATION_OBSERVER());
    runTest('can-util/dom/events/inserted - no MutationObserver', null);
});
/*can-util@3.3.2#dom/events/removed/removed-test*/
define('can-util@3.3.2#dom/events/removed/removed-test', function (require, exports, module) {
    require('can-util/dom/events/removed/');
    var each = require('can-util/js/each/');
    var domEvents = require('can-util/dom/events/');
    var getMutationObserver = require('can-util/dom/mutation-observer/');
    var domMutate = require('can-util/dom/mutate/');
    QUnit = require('steal-qunit');
    var events = [];
    var addEvent = function (el, event, handler) {
        domEvents.addEventListener.call(el, event, handler);
        events.push({
            el: el,
            event: event,
            handler: handler
        });
    };
    var removeEvents = function () {
        if (events.length) {
            each(events, function (ev) {
                domEvents.removeEventListener.call(ev.el, ev.event, ev.handler);
            });
        }
        events = [];
    };
    QUnit.module('can-util/dom/events/removed', { teardown: removeEvents });
    var _MutationObserver = getMutationObserver();
    if (_MutationObserver) {
        asyncTest('with mutation observer - basic removal - removeChild', function () {
            var div = document.createElement('div');
            domEvents.addEventListener.call(div, 'removed', function () {
                ok(true, 'called back');
                start();
            });
            document.getElementById('qunit-fixture').appendChild(div);
            document.getElementById('qunit-fixture').removeChild(div);
        });
        asyncTest('with mutation observer - basic removal - replaceChild', function () {
            var div = document.createElement('div');
            var div2 = document.createElement('div');
            domEvents.addEventListener.call(div, 'removed', function () {
                ok(true, 'called back');
                start();
            });
            document.getElementById('qunit-fixture').appendChild(div);
            document.getElementById('qunit-fixture').replaceChild(div2, div);
        });
        asyncTest('with mutation observer - nested removal - removeChild', function () {
            var div = document.createElement('div');
            var span = document.createElement('span');
            div.appendChild(span);
            domEvents.addEventListener.call(span, 'removed', function () {
                ok(true, 'called back');
                start();
            });
            document.getElementById('qunit-fixture').appendChild(div);
            document.getElementById('qunit-fixture').removeChild(div);
        });
        asyncTest('with mutation observer - move', function () {
            expect(0);
            var div = document.createElement('div');
            var span = document.createElement('span');
            var p = document.createElement('p');
            div.appendChild(span);
            div.appendChild(p);
            domMutate.appendChild.call(document.getElementById('qunit-fixture'), div);
            addEvent(p, 'removed', function () {
                ok(false, 'called removed');
            });
            div.insertBefore(p, span);
            start();
        });
        asyncTest('with mutation observer - move and remove (#146)', function () {
            var fixture = document.getElementById('qunit-fixture');
            var div = document.createElement('div');
            var span = document.createElement('span');
            var p = document.createElement('p');
            div.appendChild(span);
            div.appendChild(p);
            domMutate.appendChild.call(fixture, div);
            var div2 = document.createElement('div');
            domMutate.appendChild.call(fixture, div2);
            addEvent(p, 'removed', function () {
                ok(false, 'called removed');
            });
            addEvent(div2, 'removed', function () {
                ok(true, 'div removed');
                start();
            });
            div.insertBefore(p, span);
            domMutate.removeChild.call(fixture, div2);
        });
    }
    asyncTest('basic insertion without mutation observer - removeChild', function () {
        getMutationObserver(null);
        var div = document.createElement('div');
        domEvents.addEventListener.call(div, 'removed', function () {
            ok(true, 'called back');
            getMutationObserver(_MutationObserver);
            start();
        });
        domMutate.appendChild.call(document.getElementById('qunit-fixture'), div);
        domMutate.removeChild.call(document.getElementById('qunit-fixture'), div);
    });
    asyncTest('basic insertion without mutation observer - replaceChild', function () {
        getMutationObserver(null);
        var div = document.createElement('div');
        var div2 = document.createElement('div');
        domEvents.addEventListener.call(div, 'removed', function () {
            ok(true, 'called back');
            getMutationObserver(_MutationObserver);
            start();
        });
        domMutate.appendChild.call(document.getElementById('qunit-fixture'), div);
        domMutate.replaceChild.call(document.getElementById('qunit-fixture'), div2, div);
    });
});
/*can-util@3.3.2#dom/mutate/mutate-test*/
define('can-util@3.3.2#dom/mutate/mutate-test', function (require, exports, module) {
    var mutate = require('./mutate');
    var MUTATION_OBSERVER = require('../mutation-observer/mutation-observer');
    var DOCUMENT = require('../document/document');
    QUnit = require('steal-qunit');
    QUnit.module('can-util/dom/mutate');
    function disableMO() {
        var old = MUTATION_OBSERVER();
        MUTATION_OBSERVER(null);
        return function () {
            MUTATION_OBSERVER(old);
        };
    }
    test('inserting empty frag', function () {
        var enableMO = disableMO();
        var frag = document.createDocumentFragment();
        mutate.appendChild.call(document.getElementById('qunit-fixture'), frag);
        var div = document.createElement('div');
        div.addEventListener('inserted', function () {
            ok(true, 'called');
        });
        mutate.appendChild.call(document.getElementById('qunit-fixture'), div);
        stop();
        setTimeout(function () {
            enableMO();
            start();
        }, 10);
    });
    if (window.eventsBubble) {
        test('inserting into a different document fires inserted', function () {
            var enableMO = disableMO();
            var doc = document.implementation.createHTMLDocument('Demo');
            var oldDoc = DOCUMENT();
            DOCUMENT(doc);
            var div = document.createElement('div');
            div.addEventListener('inserted', function () {
                ok(true, 'called');
            });
            mutate.appendChild.call(doc.body, div);
            stop();
            setTimeout(function () {
                enableMO();
                DOCUMENT(oldDoc);
                start();
            }, 10);
        });
    }
});
/*can-util@3.3.2#dom/matches/matches-test*/
define('can-util@3.3.2#dom/matches/matches-test', function (require, exports, module) {
    var matches = require('./matches');
    QUnit = require('steal-qunit');
    QUnit.module('can-util/dom/matches');
    QUnit.test('basics', function () {
        var a = document.createElement('a');
        a.id = 'foo';
        document.getElementById('qunit-fixture').appendChild(a);
        QUnit.ok(matches.call(a, '#foo'), 'matches selector');
    });
    QUnit.test('returns false for document', function () {
        var res = matches.call(document, 'a');
        QUnit.equal(res, false, 'document never matches');
    });
});
/*can-util@3.3.2#dom/location/location*/
define('can-util@3.3.2#dom/location/location', function (require, exports, module) {
    (function (global) {
        var global = require('../../js/global/global');
        var setLocation;
        module.exports = function (setLoc) {
            if (setLoc) {
                setLocation = setLoc;
            }
            return setLocation || global().location;
        };
    }(function () {
        return this;
    }()));
});
/*can-util@3.3.2#dom/location/location-test*/
define('can-util@3.3.2#dom/location/location-test', function (require, exports, module) {
    var LOCATION = require('./location');
    QUnit = require('steal-qunit');
    QUnit.module('can-util/dom/location/location');
    QUnit.test('Can set a location', function () {
        var myLoc = {};
        var oldLoc = LOCATION();
        LOCATION(myLoc);
        QUnit.equal(LOCATION(), myLoc, 'It was set');
        LOCATION(oldLoc);
    });
});
/*can-util@3.3.2#dom/tests.js*/
define('can-util@3.3.2#dom/tests.js', function (require, exports, module) {
    require('./ajax/ajax-test');
    require('./attr/attr-test');
    require('./dispatch/dispatch-test');
    require('./events/delegate/delegate-test');
    require('./events/inserted/inserted-test');
    require('./events/removed/removed-test');
    require('./mutate/mutate-test');
    require('./matches/matches-test');
    require('./location/location-test');
});
/*can-util@3.3.2#test/test*/
define('can-util@3.3.2#test/test', function (require, exports, module) {
    require('../js/tests.js');
    require('../dom/tests.js');
    var domDispatch = require('can-util/dom/dispatch/');
    var buildFrag = require('can-util/dom/fragment/');
    window.eventsBubble = function () {
        var frag = buildFrag('<div><span></span></div>');
        var bubbles = false;
        frag.firstChild.addEventListener('click', function () {
            bubbles = true;
        });
        domDispatch.call(frag.firstChild.firstChild, 'click');
        return bubbles;
    }();
});
/*can@3.4.1#util/util_test*/
define('can@3.4.1#util/util_test', function (require, exports, module) {
    require('can-util/test/test');
});
/*can-view-import@3.0.6#can-view-import_test*/
define('can-view-import@3.0.6#can-view-import_test', function (require, exports, module) {
    var CanMap = require('can-map');
    var Component = require('can-component');
    var stache = require('can-stache');
    var compute = require('can-compute');
    var getIntermediateAndImports = require('can-stache/src/intermediate_and_imports');
    var QUnit = require('steal-qunit');
    var importer = require('can-util/js/import/import');
    var tag = require('can-view-callbacks').tag;
    require('./can-view-import');
    if (window.steal) {
        QUnit.module('can/view/import');
        var test = QUnit.test;
        var equal = QUnit.equal;
        test('static imports are imported', function () {
            var iai = getIntermediateAndImports('<can-import from=\'can-view-import/test/hello\'/>' + '<hello-world></hello-world>');
            equal(iai.imports.length, 1, 'There is one import');
        });
        test('dynamic imports are not imported', function () {
            var iai = getIntermediateAndImports('{{#if a}}<can-import from=\'can-view-import/test/hello\'>' + '<hello-world></hello-world></can-import>{{/if a}}');
            equal(iai.imports.length, 0, 'There are no imports');
        });
        if (!System.isEnv('production')) {
            asyncTest('dynamic imports will only load when in scope', function () {
                expect(4);
                var iai = getIntermediateAndImports('{{#if a}}<can-import from=\'can-view-import/test/hello\'>' + '{{#eq state \'resolved\'}}<hello-world></hello-world>{{/eq}}</can-import>{{/if a}}');
                var template = stache(iai.intermediate);
                var a = compute(false);
                var res = template({ a: a });
                equal(res.childNodes[0].childNodes.length, 0, 'There are no child nodes immediately');
                a(true);
                importer('can-view-import/test/hello').then(function () {
                    equal(res.childNodes[0].childNodes.length, 1, 'There is now a nested component');
                    equal(res.childNodes[0].childNodes[0].tagName.toUpperCase(), 'HELLO-WORLD', 'imported the tag');
                    equal(res.childNodes[0].childNodes[0].childNodes[0].nodeValue, 'Hello world!', 'text inserted');
                    start();
                });
            });
        }
        test('if a can-tag is present, handed over rendering to that tag', function () {
            var iai = getIntermediateAndImports('<can-import from=\'can-view-import/test/hello\' can-tag=\'loading\'/>');
            tag('loading', function (el) {
                var template = stache('it worked');
                el.appendChild(template());
            });
            var template = stache(iai.intermediate);
            var res = template();
            equal(res.childNodes[0].childNodes[0].nodeValue, 'it worked', 'Rendered with the can-tag');
        });
        if (!System.isEnv('production')) {
            asyncTest('can use an import\'s value', function () {
                var template = '<can-import from=\'can-view-import/test/person\' {^value}=\'*person\' />hello {{*person.name}}';
                var iai = getIntermediateAndImports(template);
                var renderer = stache(iai.intermediate);
                var res = renderer(new CanMap());
                importer('can-view-import/test/person').then(function () {
                    equal(res.childNodes[2].nodeValue, 'world', 'Got the person.name from the import');
                    start();
                });
            });
        }
        if (!System.isEnv('production')) {
            asyncTest('can import a template and use it', function () {
                var template = '<can-import from=\'can-view-import/test/other.stache!\' {^@value}=\'*other\' />{{{*other()}}}';
                stache.async(template).then(function (renderer) {
                    var frag = renderer();
                    importer('can-view-import/test/other.stache!').then(function () {
                        equal(frag.childNodes[3].firstChild.nodeValue, 'hi there', 'Partial was renderered right after the can-import');
                        QUnit.start();
                    });
                });
            });
        }
        if (!System.isEnv('production')) {
            asyncTest('can import a template and use it using the > syntax', function () {
                var template = '<can-import from=\'can-view-import/test/other.stache!\' {^@value}=\'*other\' />{{> *other}}';
                stache.async(template).then(function (renderer) {
                    var frag = renderer();
                    importer('can-view-import/test/other.stache!').then(function () {
                        equal(frag.childNodes[3].firstChild.nodeValue, 'hi there', 'Partial was renderered right after the can-import');
                        QUnit.start();
                    });
                });
            });
        }
        if (!System.isEnv('production')) {
            asyncTest('importing a template works with can-tag', function () {
                Component.extend({
                    tag: 'my-waiter',
                    view: stache('{{#isResolved}}' + '<content></content>' + '{{else}}' + '<div class=\'loading\'></div>' + '{{/isResolved}}'),
                    leakScope: true
                });
                var template = '<can-import from=\'can-view-import/test/other.stache\' {^@value}=\'*other\' can-tag=\'my-waiter\'>{{{*other()}}}</can-import>';
                stache.async(template).then(function (renderer) {
                    var frag = renderer(new CanMap());
                    importer('can-view-import/test/other.stache').then(function () {
                        ok(frag.childNodes[0].childNodes.length > 1, 'Something besides a text node is inserted');
                        equal(frag.childNodes[0].childNodes[2].firstChild.nodeValue, 'hi there', 'Partial worked with can-tag');
                        QUnit.start();
                    });
                });
            });
        }
        if (!System.isEnv('production')) {
            asyncTest('can dynamically import a template and use it', function () {
                var template = '<can-import from=\'can-view-import/test/other-dynamic.stache!\' {^@value}=\'*other\'/>{{> *other}}';
                stache.async(template).then(function (renderer) {
                    var frag = renderer();
                    importer('can-view-import/test/other.stache!').then(function () {
                        equal(frag.childNodes[3].firstChild.nodeValue, 'hi there', 'Partial was renderered right after the can-import');
                        QUnit.start();
                    });
                });
            });
        }
        if (!System.isEnv('production') && typeof console === 'object') {
            asyncTest('loading errors are logged to the console', function () {
                var template = '<can-import from=\'can-view-import/test/error\'></can-import>';
                var error = console.error;
                console.error = function (type) {
                    console.error = error;
                    QUnit.ok(/ERROR/.test(type), 'Logged an error that originated from the dynamically imported module');
                    QUnit.start();
                };
                stache.async(template).then(function (renderer) {
                    renderer({});
                });
            });
        }
    }
});
/*can@3.4.1#view/import/import_test*/
define('can@3.4.1#view/import/import_test', function (require, exports, module) {
    require('can-view-import/can-view-import_test');
});
/*can-view-live@3.0.6#test/live-test*/
define('can-view-live@3.0.6#test/live-test', function (require, exports, module) {
    var live = require('can-view-live');
    var compute = require('can-compute');
    var Map = require('can-map');
    var List = require('can-list');
    var nodeLists = require('can-view-nodelist');
    var canBatch = require('can-event/batch/batch');
    var QUnit = require('steal-qunit');
    var isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');
    var domMutate = require('can-util/dom/mutate/mutate');
    var domAttr = require('can-util/dom/attr/attr');
    QUnit.module('can-view-live', {
        setup: function () {
            this.fixture = document.getElementById('qunit-fixture');
        }
    });
    test('html', function () {
        var div = document.createElement('div'), span = document.createElement('span');
        div.appendChild(span);
        var items = new List([
            'one',
            'two'
        ]);
        var html = compute(function () {
            var html = '';
            items.each(function (item) {
                html += '<label>' + item + '</label>';
            });
            return html;
        });
        live.html(span, html, div);
        equal(div.getElementsByTagName('label').length, 2);
        items.push('three');
        equal(div.getElementsByTagName('label').length, 3);
    });
    var esc = function (str) {
        return str.replace(/</g, '&lt;').replace(/>/g, '&gt;');
    };
    test('text', function () {
        var div = document.createElement('div'), span = document.createElement('span');
        div.appendChild(span);
        var items = new List([
            'one',
            'two'
        ]);
        var text = compute(function () {
            var html = '';
            items.each(function (item) {
                html += '<label>' + item + '</label>';
            });
            return html;
        });
        live.text(span, text, div);
        equal(div.innerHTML, esc('<label>one</label><label>two</label>'));
        items.push('three');
        equal(div.innerHTML, esc('<label>one</label><label>two</label><label>three</label>'));
    });
    test('attributes', function () {
        var div = document.createElement('div');
        var items = new List([
            'class',
            'foo'
        ]);
        var text = compute(function () {
            var html = '';
            if (items.attr(0) && items.attr(1)) {
                html += items.attr(0) + '=\'' + items.attr(1) + '\'';
            }
            return html;
        });
        live.attrs(div, text);
        equal(div.className, 'foo');
        items.splice(0, 2);
        equal(div.className, '');
        items.push('foo', 'bar');
        equal(div.getAttribute('foo'), 'bar');
    });
    test('attribute', function () {
        var div = document.createElement('div');
        var firstObject = new Map({});
        var first = compute(function () {
            return firstObject.attr('selected') ? 'selected' : '';
        });
        var secondObject = new Map({});
        var second = compute(function () {
            return secondObject.attr('active') ? 'active' : '';
        });
        var className = compute(function () {
            return 'foo ' + first() + ' ' + second() + ' end';
        });
        live.attr(div, 'class', className);
        equal(div.className, 'foo   end');
        firstObject.attr('selected', true);
        equal(div.className, 'foo selected  end');
        secondObject.attr('active', true);
        equal(div.className, 'foo selected active end');
        firstObject.attr('selected', false);
        equal(div.className, 'foo  active end');
    });
    test('specialAttribute with new line', function () {
        var div = document.createElement('div');
        var style = compute('width: 50px;\nheight:50px;');
        live.attr(div, 'style', style);
        equal(div.style.height, '50px');
        equal(div.style.width, '50px');
    });
    test('list', function () {
        var div = document.createElement('div'), list = new List([
                'sloth',
                'bear'
            ]), template = function (animal) {
                return '<label>Animal=</label> <span>' + animal() + '</span>';
            };
        div.innerHTML = 'my <b>fav</b> animals: <span></span> !';
        var el = div.getElementsByTagName('span')[0];
        live.list(el, list, template, {});
        equal(div.getElementsByTagName('label').length, 2, 'There are 2 labels');
        div.getElementsByTagName('label')[0].myexpando = 'EXPANDO-ED';
        list.push('turtle');
        equal(div.getElementsByTagName('label')[0].myexpando, 'EXPANDO-ED', 'same expando');
        equal(div.getElementsByTagName('span')[2].innerHTML, 'turtle', 'turtle added');
    });
    test('list with a compute', function () {
        var div = document.createElement('div'), map = new Map({
                animals: [
                    'bear',
                    'turtle'
                ]
            }), template = function (animal) {
                return '<label>Animal=</label> <span>' + animal() + '</span>';
            };
        var listCompute = compute(function () {
            return map.attr('animals');
        });
        div.innerHTML = 'my <b>fav</b> animals: <span></span> !';
        var el = div.getElementsByTagName('span')[0];
        live.list(el, listCompute, template, {});
        equal(div.getElementsByTagName('label').length, 2, 'There are 2 labels');
        div.getElementsByTagName('label')[0].myexpando = 'EXPANDO-ED';
        map.attr('animals').push('turtle');
        equal(div.getElementsByTagName('label')[0].myexpando, 'EXPANDO-ED', 'same expando');
        equal(div.getElementsByTagName('span')[2].innerHTML, 'turtle', 'turtle added');
        map.attr('animals', new List([
            'sloth',
            'bear',
            'turtle'
        ]));
        var spans = div.getElementsByTagName('span');
        equal(spans.length, 3, 'there are 3 spans');
        ok(!div.getElementsByTagName('label')[0].myexpando, 'no expando');
    });
    test('list with a compute that returns a list', function () {
        var div = document.createElement('div'), template = function (num) {
                return '<label>num=</label> <span>' + num + '</span>';
            };
        var arrCompute = compute([
            0,
            1
        ]);
        div.innerHTML = 'my <b>fav</b> nums: <span></span> !';
        var el = div.getElementsByTagName('span')[0];
        live.list(el, arrCompute, template, {});
        equal(div.getElementsByTagName('label').length, 2, 'There are 2 labels');
        arrCompute([
            0,
            1,
            2
        ]);
        var spans = div.getElementsByTagName('span');
        equal(spans.length, 3, 'there are 3 spans');
    });
    test('text binding is memory safe (#666)', function () {
        nodeLists.nodeMap.clear();
        var div = document.createElement('div'), span = document.createElement('span'), text = compute(function () {
                return 'foo';
            });
        div.appendChild(span);
        domMutate.appendChild.call(this.fixture, div);
        live.text(span, text, div);
        domMutate.removeChild.call(this.fixture, div);
        stop();
        setTimeout(function () {
            ok(!nodeLists.nodeMap.size, 'nothing in nodeMap');
            start();
        }, 100);
    });
    test('html live binding handles getting a function from a compute', 5, function () {
        var handler = function (el) {
            ok(true, 'called handler');
            equal(el.nodeType, 3, 'got a placeholder');
        };
        var div = document.createElement('div'), placeholder = document.createTextNode('');
        div.appendChild(placeholder);
        var count = compute(0);
        var html = compute(function () {
            if (count() === 0) {
                return '<h1>Hello World</h1>';
            } else {
                return handler;
            }
        });
        live.html(placeholder, html, div);
        equal(div.getElementsByTagName('h1').length, 1, 'got h1');
        count(1);
        equal(div.getElementsByTagName('h1').length, 0, 'got h1');
        count(0);
        equal(div.getElementsByTagName('h1').length, 1, 'got h1');
    });
    test('live.list does not unbind on a list unnecessarily (#1835)', function () {
        expect(0);
        var div = document.createElement('div'), list = new List([
                'sloth',
                'bear'
            ]), template = function (animal) {
                return '<label>Animal=</label> <span>' + animal + '</span>';
            }, unbind = list.unbind;
        list.unbind = function () {
            ok(false, 'unbind called');
            return unbind.apply(this, arguments);
        };
        div.innerHTML = 'my <b>fav</b> animals: <span></span> !';
        var el = div.getElementsByTagName('span')[0];
        live.list(el, list, template, {});
    });
    test('can.live.attr works with non-string attributes (#1790)', function () {
        var el = document.createElement('div'), attrCompute = compute(function () {
                return 2;
            });
        domAttr.set(el, 'value', 1);
        live.attr(el, 'value', attrCompute);
        ok(true, 'No exception thrown.');
    });
    test('list and an falsey section (#1979)', function () {
        var div = document.createElement('div'), template = function (num) {
                return '<label>num=</label> <span>' + num + '</span>';
            }, falseyTemplate = function (num) {
                return '<p>NOTHING</p>';
            };
        var listCompute = compute([
            0,
            1
        ]);
        div.innerHTML = 'my <b>fav</b> nums: <span></span> !';
        var el = div.getElementsByTagName('span')[0];
        live.list(el, listCompute, template, {}, undefined, undefined, falseyTemplate);
        equal(div.getElementsByTagName('label').length, 2, 'There are 2 labels');
        listCompute([]);
        var spans = div.getElementsByTagName('span');
        equal(spans.length, 0, 'there are 0 spans');
        var ps = div.getElementsByTagName('p');
        equal(ps.length, 1, 'there is 1 p');
        listCompute([2]);
        spans = div.getElementsByTagName('span');
        equal(spans.length, 1, 'there is 1 spans');
        ps = div.getElementsByTagName('p');
        equal(ps.length, 0, 'there is 1 p');
    });
    test('list and an initial falsey section (#1979)', function () {
        var div = document.createElement('div'), template = function (num) {
                return '<label>num=</label> <span>' + num + '</span>';
            }, falseyTemplate = function (num) {
                return '<p>NOTHING</p>';
            };
        var listCompute = compute([]);
        div.innerHTML = 'my <b>fav</b> nums: <span></span> !';
        var el = div.getElementsByTagName('span')[0];
        live.list(el, listCompute, template, {}, undefined, undefined, falseyTemplate);
        var spans = div.getElementsByTagName('span');
        equal(spans.length, 0, 'there are 0 spans');
        var ps = div.getElementsByTagName('p');
        equal(ps.length, 1, 'there is 1 p');
        listCompute([2]);
        spans = div.getElementsByTagName('span');
        equal(spans.length, 1, 'there is 1 spans');
        ps = div.getElementsByTagName('p');
        equal(ps.length, 0, 'there is 1 p');
    });
    test('rendered list items should re-render when updated (#2007)', function () {
        var partial = document.createElement('div');
        var placeholderElement = document.createElement('span');
        var list = new List(['foo']);
        var renderer = function (item) {
            return '<span>' + item() + '</span>';
        };
        partial.appendChild(placeholderElement);
        live.list(placeholderElement, list, renderer, {});
        equal(partial.getElementsByTagName('span')[0].firstChild.data, 'foo', 'list item 0 is foo');
        list.push('bar');
        equal(partial.getElementsByTagName('span')[1].firstChild.data, 'bar', 'list item 1 is bar');
        list.attr(0, 'baz');
        equal(partial.getElementsByTagName('span')[0].firstChild.data, 'baz', 'list item 0 is baz');
    });
    test('list items should be correct even if renderer flushes batch (#8)', function () {
        var partial = document.createElement('div');
        var placeholderElement = document.createElement('span');
        var list = new List([
            'one',
            'two'
        ]);
        var renderer = function (item) {
            canBatch.flush();
            return '<span>' + item() + '</span>';
        };
        partial.appendChild(placeholderElement);
        live.list(placeholderElement, list, renderer, {});
        equal(partial.getElementsByTagName('span').length, 2, 'should be two items');
        equal(partial.getElementsByTagName('span')[0].firstChild.data, 'one', 'list item 0 is "one"');
        equal(partial.getElementsByTagName('span')[1].firstChild.data, 'two', 'list item 1 is "two"');
        canBatch.start();
        list.splice(0, 0, 'three');
        list.splice(2, 1);
        canBatch.stop();
        equal(partial.getElementsByTagName('span').length, 2, 'should be two items');
        equal(partial.getElementsByTagName('span')[0].firstChild.data, 'three', 'list item 0 is "three"');
        equal(partial.getElementsByTagName('span')[1].firstChild.data, 'one', 'list item 1 is "one"');
    });
});
/*can@3.4.1#view/live/live_test*/
define('can@3.4.1#view/live/live_test', function (require, exports, module) {
    require('can-view-live/test/live-test');
});
/*can-view-model@3.1.3#can-view-model_test*/
define('can-view-model@3.1.3#can-view-model_test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var viewModel = require('can-view-model');
    var SimpleMap = require('can-simple-map');
    var types = require('can-types');
    QUnit.module('can-view-model');
    QUnit.test('basics', function () {
        var DefaultMap = types.DefaultMap;
        types.DefaultMap = undefined;
        var el = document.createElement('div');
        viewModel(el, 'foo', 'bar');
        QUnit.equal(viewModel(el, 'foo'), 'bar');
        QUnit.ok(viewModel(el) instanceof SimpleMap, 'is can-map');
        types.DefaultMap = DefaultMap;
    });
    QUnit.test('a selector can be passed as the first argument (#6)', function () {
        var DefaultMap = types.DefaultMap;
        types.DefaultMap = undefined;
        var el = document.createElement('div');
        el.className = 'the-el';
        document.getElementById('qunit-fixture').appendChild(el);
        viewModel('.the-el', 'foo', 'bar');
        QUnit.equal(viewModel('.the-el', 'foo'), 'bar');
        QUnit.ok(viewModel(el) instanceof SimpleMap, 'is can-map');
        types.DefaultMap = DefaultMap;
    });
});
/*can-view-model@3.1.3#test/test*/
define('can-view-model@3.1.3#test/test', function (require, exports, module) {
    require('../can-view-model_test');
});
/*can-view-nodelist@3.0.4#test/can-view-nodelist-test*/
define('can-view-nodelist@3.0.4#test/can-view-nodelist-test', function (require, exports, module) {
    var nodeLists = require('can-view-nodelist');
    var fragment = require('can-util/dom/fragment/fragment');
    var makeArray = require('can-util/js/make-array/make-array');
    var frag = require('can-util/dom/frag/frag');
    var QUnit = require('steal-qunit');
    QUnit.module('can-view-nodelist');
    test('unregisters child nodeLists', function () {
        expect(3);
        var spansFrag = fragment('<span>1</span><span>2</span>');
        var spansList = makeArray(spansFrag.childNodes);
        nodeLists.register(spansList, function () {
            ok(true, 'unregistered spansList');
        });
        var labelFrag = fragment('<label>l</label>');
        var labelList = makeArray(labelFrag.childNodes);
        nodeLists.register(labelList, function () {
            ok(true, 'unregistered labelList');
        });
        var ifPreHookupFrag = frag([
                '~',
                '',
                '-',
                ''
            ]), ifChildNodes = ifPreHookupFrag.childNodes, ifEls = makeArray(ifChildNodes);
        nodeLists.replace([ifChildNodes[1]], spansFrag);
        nodeLists.replace([ifChildNodes[4]], labelFrag);
        var ifList = makeArray(ifPreHookupFrag.childNodes);
        nodeLists.register(ifList, function () {
            ok(true, 'unregistered ifList');
        });
        deepEqual(ifList, [
            ifEls[0],
            spansList,
            ifEls[2],
            labelList
        ]);
        nodeLists.update(ifList, [document.createTextNode('empty')]);
    });
});
/*can@3.4.1#view/node_lists/node_lists_test*/
define('can@3.4.1#view/node_lists/node_lists_test', function (require, exports, module) {
    require('can-view-nodelist/test/can-view-nodelist-test');
});
/*can-view-parser@3.0.6#test/can-view-parser-test*/
define('can-view-parser@3.0.6#test/can-view-parser-test', function (require, exports, module) {
    var parser = require('can-view-parser');
    var QUnit = require('steal-qunit');
    QUnit.module('can-view-parser');
    var makeChecks = function (tests) {
        var count = 0;
        var makeCheck = function (name) {
            return function () {
                if (count >= tests.length) {
                    ok(false, 'called ' + name + ' with ' + arguments[0]);
                } else {
                    var test = tests[count], args = test[1];
                    equal(name, test[0], 'test ' + count + ' ' + name + '(');
                    for (var i = 0; i < args.length; i++) {
                        equal(arguments[i], args[i], i + 1 + ' arg -> ' + args[i]);
                    }
                    count++;
                }
            };
        };
        return {
            start: makeCheck('start'),
            end: makeCheck('end'),
            close: makeCheck('close'),
            attrStart: makeCheck('attrStart'),
            attrEnd: makeCheck('attrEnd'),
            attrValue: makeCheck('attrValue'),
            chars: makeCheck('chars'),
            comment: makeCheck('comment'),
            special: makeCheck('special'),
            done: makeCheck('done')
        };
    };
    test('html to html', function () {
        var tests = [
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'attrStart',
                ['id']
            ],
            [
                'attrValue',
                ['foo']
            ],
            [
                'attrEnd',
                ['id']
            ],
            [
                'special',
                ['#if']
            ],
            [
                'special',
                ['.']
            ],
            [
                'special',
                ['/if']
            ],
            [
                'attrStart',
                ['class']
            ],
            [
                'attrValue',
                ['a']
            ],
            [
                'special',
                ['foo']
            ],
            [
                'attrEnd',
                ['class']
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'chars',
                ['Hello ']
            ],
            [
                'special',
                ['message']
            ],
            [
                'chars',
                ['!']
            ],
            [
                'close',
                ['h1']
            ],
            [
                'done',
                []
            ]
        ];
        parser('<h1 id=\'foo\' {{#if}}{{.}}{{/if}} class=\'a{{foo}}\'>Hello {{message}}!</h1>', makeChecks(tests));
    });
    test('uppercase html to html', function () {
        var tests = [
            [
                'start',
                [
                    'div',
                    false
                ]
            ],
            [
                'end',
                [
                    'div',
                    false
                ]
            ],
            [
                'chars',
                ['sibling']
            ],
            [
                'close',
                ['div']
            ],
            [
                'start',
                [
                    'div',
                    false
                ]
            ],
            [
                'end',
                [
                    'div',
                    false
                ]
            ],
            [
                'chars',
                ['sibling']
            ],
            [
                'close',
                ['div']
            ],
            [
                'done',
                []
            ]
        ];
        parser('<DIV>sibling</DIV><DIV>sibling</DIV>', makeChecks(tests));
    });
    test('camelCase attributes stay untouched (svg) - #22', function () {
        var tests = [
            [
                'start',
                [
                    'svg',
                    false
                ]
            ],
            [
                'attrStart',
                ['viewBox']
            ],
            [
                'attrValue',
                ['0 0 15 22']
            ],
            [
                'attrEnd',
                ['viewBox']
            ],
            [
                'end',
                [
                    'svg',
                    false
                ]
            ],
            [
                'close',
                ['svg']
            ],
            [
                'done',
                []
            ]
        ];
        parser('<svg viewBox="0 0 15 22"></svg>', makeChecks(tests));
    });
    test('camelCase tags stay untouched (svg)', function () {
        var tests = [
            [
                'start',
                [
                    'svg',
                    false
                ]
            ],
            [
                'end',
                [
                    'svg',
                    false
                ]
            ],
            [
                'start',
                [
                    'radialGradient',
                    false
                ]
            ],
            [
                'end',
                [
                    'radialGradient',
                    false
                ]
            ],
            [
                'close',
                ['radialGradient']
            ],
            [
                'close',
                ['svg']
            ],
            [
                'done',
                []
            ]
        ];
        parser('<svg><radialGradient></radialGradient></svg>', makeChecks(tests));
    });
    test('special in an attribute in an in-tag section', function () {
        parser('<div {{#truthy}}foo=\'{{baz}}\'{{/truthy}}></div>', makeChecks([
            [
                'start',
                [
                    'div',
                    false
                ]
            ],
            [
                'special',
                ['#truthy']
            ],
            [
                'attrStart',
                ['foo']
            ],
            [
                'special',
                ['baz']
            ],
            [
                'attrEnd',
                ['foo']
            ],
            [
                'special',
                ['/truthy']
            ],
            [
                'end',
                [
                    'div',
                    false
                ]
            ],
            [
                'close',
                ['div']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('special with a custom attribute', function () {
        parser('<div {{#attribute}} {{name}}="{{value}}" {{/attribute}}></div>', makeChecks([
            [
                'start',
                [
                    'div',
                    false
                ]
            ],
            [
                'special',
                ['#attribute']
            ],
            [
                'special',
                ['name']
            ],
            [
                'attrStart',
                ['']
            ],
            [
                'special',
                ['value']
            ],
            [
                'attrEnd',
                ['']
            ],
            [
                'special',
                ['/attribute']
            ],
            [
                'end',
                [
                    'div',
                    false
                ]
            ],
            [
                'close',
                ['div']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('single attribute value', function () {
        parser('<input DISABLED/>', makeChecks([
            [
                'start',
                [
                    'input',
                    true
                ]
            ],
            [
                'attrStart',
                ['DISABLED']
            ],
            [
                'attrEnd',
                ['DISABLED']
            ],
            [
                'end',
                [
                    'input',
                    true
                ]
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('trailing linebreaks in IE', function () {
        parser('12345{{!\n  This is a\n  multi-line comment...\n}}67890\n', makeChecks([
            [
                'chars',
                ['12345']
            ],
            [
                'special',
                ['!\n  This is a\n  multi-line comment...\n']
            ],
            [
                'chars',
                ['67890\n']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('block are allowed inside anchor tags', function () {
        parser('<a><div></div></a>', makeChecks([
            [
                'start',
                [
                    'a',
                    false
                ]
            ],
            [
                'end',
                [
                    'a',
                    false
                ]
            ],
            [
                'start',
                [
                    'div',
                    false
                ]
            ],
            [
                'end',
                [
                    'div',
                    false
                ]
            ],
            [
                'close',
                ['div']
            ],
            [
                'close',
                ['a']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('anchors are allowed as children of inline elements - #2169', function () {
        parser('<span><a></a></span>', makeChecks([
            [
                'start',
                [
                    'span',
                    false
                ]
            ],
            [
                'end',
                [
                    'span',
                    false
                ]
            ],
            [
                'start',
                [
                    'a',
                    false
                ]
            ],
            [
                'end',
                [
                    'a',
                    false
                ]
            ],
            [
                'close',
                ['a']
            ],
            [
                'close',
                ['span']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('inline tags encapsulate inner block elements', function () {
        parser('<span><div></div></span>', makeChecks([
            [
                'start',
                [
                    'span',
                    false
                ]
            ],
            [
                'end',
                [
                    'span',
                    false
                ]
            ],
            [
                'start',
                [
                    'div',
                    false
                ]
            ],
            [
                'end',
                [
                    'div',
                    false
                ]
            ],
            [
                'close',
                ['div']
            ],
            [
                'close',
                ['span']
            ],
            [
                'done',
                []
            ]
        ]));
        parser('<em><h1></h1></em>', makeChecks([
            [
                'start',
                [
                    'em',
                    false
                ]
            ],
            [
                'end',
                [
                    'em',
                    false
                ]
            ],
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'close',
                ['h1']
            ],
            [
                'close',
                ['em']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('unordered lists will contain their list items', function () {
        parser('<ul><li></li><li></li></ul>', makeChecks([
            [
                'start',
                [
                    'ul',
                    false
                ]
            ],
            [
                'end',
                [
                    'ul',
                    false
                ]
            ],
            [
                'start',
                [
                    'li',
                    false
                ]
            ],
            [
                'end',
                [
                    'li',
                    false
                ]
            ],
            [
                'close',
                ['li']
            ],
            [
                'start',
                [
                    'li',
                    false
                ]
            ],
            [
                'end',
                [
                    'li',
                    false
                ]
            ],
            [
                'close',
                ['li']
            ],
            [
                'close',
                ['ul']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('supports single character attributes (#1132)', function () {
        parser('<circle r="25"></circle>', makeChecks([
            [
                'start',
                [
                    'circle',
                    false
                ]
            ],
            [
                'attrStart',
                ['r']
            ],
            [
                'attrValue',
                ['25']
            ],
            [
                'attrEnd',
                ['r']
            ],
            [
                'end',
                [
                    'circle',
                    false
                ]
            ],
            [
                'close',
                ['circle']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('accept custom tag with colon ":" #1108', function () {
        parser('<x:widget/>', makeChecks([
            [
                'start',
                [
                    'x:widget',
                    true
                ]
            ],
            [
                'end',
                [
                    'x:widget',
                    true
                ]
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('output json', function () {
        var tests = [
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'attrStart',
                ['id']
            ],
            [
                'attrValue',
                ['foo']
            ],
            [
                'attrEnd',
                ['id']
            ],
            [
                'special',
                ['#if']
            ],
            [
                'special',
                ['.']
            ],
            [
                'special',
                ['/if']
            ],
            [
                'attrStart',
                ['class']
            ],
            [
                'attrValue',
                ['a']
            ],
            [
                'special',
                ['foo']
            ],
            [
                'attrEnd',
                ['class']
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'chars',
                ['Hello ']
            ],
            [
                'special',
                ['message']
            ],
            [
                'chars',
                ['!']
            ],
            [
                'close',
                ['h1']
            ],
            [
                'done',
                []
            ]
        ];
        var intermediate = parser('<h1 id=\'foo\' {{#if}}{{.}}{{/if}} class=\'a{{foo}}\'>Hello {{message}}!</h1>', makeChecks(tests), true);
        parser(intermediate, makeChecks(tests));
    });
    test('less than outside of an element', function () {
        var tests = [
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'chars',
                [' < ']
            ],
            [
                'close',
                ['h1']
            ],
            [
                'done',
                []
            ]
        ];
        var intermediate = parser('<h1> < </h1>', makeChecks(tests), true);
        parser(intermediate, makeChecks(tests));
    });
    test('allow () and [] to enclose attributes', function () {
        parser('<p [click]="test"></p>', makeChecks([
            [
                'start',
                [
                    'p',
                    false
                ]
            ],
            [
                'attrStart',
                ['[click]']
            ],
            [
                'attrValue',
                ['test']
            ],
            [
                'attrEnd',
                ['[click]']
            ],
            [
                'end',
                ['p']
            ],
            [
                'close',
                ['p']
            ],
            [
                'done',
                []
            ]
        ]));
        parser('<p (click)="test"></p>', makeChecks([
            [
                'start',
                [
                    'p',
                    false
                ]
            ],
            [
                'attrStart',
                ['(click)']
            ],
            [
                'attrValue',
                ['test']
            ],
            [
                'attrEnd',
                ['(click)']
            ],
            [
                'end',
                ['p']
            ],
            [
                'close',
                ['p']
            ],
            [
                'done',
                []
            ]
        ]));
        parser('<p (click-me)="test"></p>', makeChecks([
            [
                'start',
                [
                    'p',
                    false
                ]
            ],
            [
                'attrStart',
                ['(click-me)']
            ],
            [
                'attrValue',
                ['test']
            ],
            [
                'attrEnd',
                ['(click-me)']
            ],
            [
                'end',
                ['p']
            ],
            [
                'close',
                ['p']
            ],
            [
                'done',
                []
            ]
        ]));
        parser('<p (click_me)="test"></p>', makeChecks([
            [
                'start',
                [
                    'p',
                    false
                ]
            ],
            [
                'attrStart',
                ['(click_me)']
            ],
            [
                'attrValue',
                ['test']
            ],
            [
                'attrEnd',
                ['(click_me)']
            ],
            [
                'end',
                ['p']
            ],
            [
                'close',
                ['p']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('allow {} to enclose attributes', function () {
        parser.parseAttrs('{a}="b" {{#c}}d{{/c}}', makeChecks([
            [
                'attrStart',
                ['{a}']
            ],
            [
                'attrValue',
                ['b']
            ],
            [
                'attrEnd',
                ['{a}']
            ],
            [
                'special',
                ['#c']
            ],
            [
                'attrStart',
                ['d']
            ],
            [
                'attrEnd',
                ['d']
            ],
            [
                'special',
                ['/c']
            ]
        ]));
    });
    test('tripple curly in attrs', function () {
        parser.parseAttrs('items="{{{ completed }}}"', makeChecks([
            [
                'attrStart',
                ['items']
            ],
            [
                'special',
                ['{ completed ']
            ],
            [
                'attrEnd',
                ['items']
            ]
        ]));
    });
    test('something', function () {
        parser.parseAttrs('c d=\'e\'', makeChecks([
            [
                'attrStart',
                ['c']
            ],
            [
                'attrEnd',
                ['c']
            ],
            [
                'attrStart',
                ['d']
            ],
            [
                'attrValue',
                ['e']
            ],
            [
                'attrEnd',
                ['d']
            ]
        ]));
    });
    test('references', function () {
        parser('<year-selector *y />', makeChecks([
            [
                'start',
                [
                    'year-selector',
                    true
                ]
            ],
            [
                'attrStart',
                ['*y']
            ],
            [
                'attrEnd',
                ['*y']
            ],
            [
                'end',
                ['year-selector']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('quotes around attributes and other lazy attribute writing (#2097)', function () {
        parser('<c-d a={z}/>', makeChecks([
            [
                'start',
                [
                    'c-d',
                    true
                ]
            ],
            [
                'attrStart',
                ['a']
            ],
            [
                'attrValue',
                ['{z}']
            ],
            [
                'attrEnd',
                ['a']
            ],
            [
                'end',
                ['c-d']
            ],
            [
                'done',
                []
            ]
        ]));
        parser('<span v={{.}}/>', makeChecks([
            [
                'start',
                [
                    'span',
                    true
                ]
            ],
            [
                'attrStart',
                ['v']
            ],
            [
                'special',
                ['.']
            ],
            [
                'attrEnd',
                ['v']
            ],
            [
                'end',
                ['span']
            ],
            [
                'done',
                []
            ]
        ]));
        parser('<div {{^f}} d {{/f}}/>', makeChecks([
            [
                'start',
                [
                    'div',
                    true
                ]
            ],
            [
                'special',
                ['^f']
            ],
            [
                'attrStart',
                ['d']
            ],
            [
                'attrEnd',
                ['d']
            ],
            [
                'special',
                ['/f']
            ],
            [
                'end',
                ['div']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('camelCased attributes are converted to spinal-case', function () {
        parser.parseAttrs('({camelCase})=\'assigned\'', makeChecks([
            [
                'attrStart',
                ['({camel-case})']
            ],
            [
                'attrValue',
                ['assigned']
            ],
            [
                'attrEnd',
                ['({camel-case})']
            ]
        ]));
    });
    test('elements that have attributes with equal signs and no values are handled appropriately (#17)', function () {
        parser('<input class=\'toggle\' type=\'checkbox\' {($checked)}=\'complete\' ($change)=>', makeChecks([
            [
                'start',
                [
                    'input',
                    true
                ]
            ],
            [
                'attrStart',
                ['class']
            ],
            [
                'attrValue',
                ['toggle']
            ],
            [
                'attrEnd',
                ['class']
            ],
            [
                'attrStart',
                ['type']
            ],
            [
                'attrValue',
                ['checkbox']
            ],
            [
                'attrEnd',
                ['type']
            ],
            [
                'attrStart',
                ['{($checked)}']
            ],
            [
                'attrValue',
                ['complete']
            ],
            [
                'attrEnd',
                ['{($checked)}']
            ],
            [
                'attrStart',
                ['($change)']
            ],
            [
                'attrEnd',
                ['($change)']
            ],
            [
                'end',
                ['input']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('supports other delimiters (#31)', function () {
        var checks = makeChecks([
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'attrStart',
                ['id']
            ],
            [
                'attrValue',
                ['foo']
            ],
            [
                'attrEnd',
                ['id']
            ],
            [
                'special',
                ['#if']
            ],
            [
                'special',
                ['.']
            ],
            [
                'special',
                ['/if']
            ],
            [
                'attrStart',
                ['class']
            ],
            [
                'attrValue',
                ['a']
            ],
            [
                'special',
                ['foo']
            ],
            [
                'attrEnd',
                ['class']
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'chars',
                ['Hello ']
            ],
            [
                'special',
                ['message']
            ],
            [
                'chars',
                ['!']
            ],
            [
                'close',
                ['h1']
            ],
            [
                'done',
                []
            ]
        ]);
        checks.magicStart = '{';
        checks.magicMatch = /\{([^\}]*)\}/g;
        parser('<h1 id=\'foo\' {#if}{.}{/if} class=\'a{foo}\'>Hello {message}!</h1>', checks);
    });
    test('{{}} in attribute values are handled correctly (#34)', function () {
        var tests = [
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'attrStart',
                ['class']
            ],
            [
                'special',
                ['foo']
            ],
            [
                'attrValue',
                ['a']
            ],
            [
                'attrEnd',
                ['class']
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'close',
                ['h1']
            ],
            [
                'done',
                []
            ]
        ];
        parser('<h1 class=\'{{foo}}a\'></h1>', makeChecks(tests));
    });
});
/*can@3.4.1#view/parser/parser_test*/
define('can@3.4.1#view/parser/parser_test', function (require, exports, module) {
    require('can-view-parser/test/can-view-parser-test');
});
/*can-view-scope@3.1.4#test/scope-define-test*/
define('can-view-scope@3.1.4#test/scope-define-test', function (require, exports, module) {
    'use strict';
    var Scope = require('can-view-scope');
    var DefineMap = require('can-define/map/map');
    var DefineList = require('can-define/list/list');
    var observeReader = require('can-observation/reader/reader');
    var compute = require('can-compute');
    var QUnit = require('steal-qunit');
    QUnit.module('can-view-scope with define');
    test('basics', function () {
        var items = new DefineMap({
            people: [
                { name: 'Justin' },
                { name: 'Brian' }
            ],
            count: 1000
        });
        var itemsScope = new Scope(items), arrayScope = new Scope(itemsScope.peek('people'), itemsScope), firstItem = new Scope(arrayScope.peek('0'), arrayScope);
        var nameInfo;
        var c = compute(function () {
            nameInfo = firstItem.read('name');
        });
        c.bind('change', function () {
        });
        deepEqual(nameInfo.reads, [{
                key: 'name',
                at: false
            }], 'reads');
        equal(nameInfo.scope, firstItem, 'scope');
        equal(nameInfo.value, 'Justin', 'value');
        equal(nameInfo.rootObserve, items.people[0], 'rootObserve');
    });
    test('Scope.prototype.computeData', function () {
        var map = new DefineMap({ age: undefined });
        var base = new Scope(map);
        var age = base.computeData('age').compute;
        equal(age(), undefined, 'age is not set');
        age.bind('change', function (ev, newVal, oldVal) {
            equal(newVal, 31, 'newVal is provided correctly');
            equal(oldVal, undefined, 'oldVal is undefined');
        });
        age(31);
        equal(map.age, 31, 'maps age is set correctly');
    });
    test('backtrack path (#163)', function () {
        var row = new DefineMap({ first: 'Justin' }), col = { format: 'str' }, base = new Scope(row), cur = base.add(col);
        equal(cur.peek('.'), col, 'got col');
        equal(cur.peek('..'), row, 'got row');
        equal(cur.peek('../first'), 'Justin', 'got row');
    });
    test('nested properties with compute', function () {
        var me = new DefineMap({ name: { first: 'Justin' } });
        var cur = new Scope(me);
        var compute = cur.computeData('name.first').compute;
        var changes = 0;
        compute.bind('change', function (ev, newVal, oldVal) {
            if (changes === 0) {
                equal(oldVal, 'Justin');
                equal(newVal, 'Brian');
            } else if (changes === 1) {
                equal(oldVal, 'Brian');
                equal(newVal, undefined);
            } else if (changes === 2) {
                equal(oldVal, undefined);
                equal(newVal, 'Payal');
            } else if (changes === 3) {
                equal(oldVal, 'Payal');
                equal(newVal, 'Curtis');
            }
            changes++;
        });
        equal(compute(), 'Justin', 'read value after bind');
        me.name.first = 'Brian';
        me.name = undefined;
        me.name = { first: 'Payal' };
        me.name = new DefineMap({ first: 'Curtis' });
    });
    test('binds to the right scope only', 3, function () {
        var baseMap = new DefineMap({ me: { name: { first: 'Justin' } } });
        var base = new Scope(baseMap);
        var topMap = new DefineMap({ me: { name: {} } });
        var scope = base.add(topMap);
        var compute = scope.computeData('me.name.first').compute;
        compute.bind('change', function (ev, newVal, oldVal) {
            equal(oldVal, 'Justin');
            equal(newVal, 'Brian');
        });
        equal(compute(), 'Justin');
        baseMap.me.name.first = 'Brian';
    });
    test('Scope read returnObserveMethods=true', function () {
        var MapConstruct = DefineMap.extend({
            foo: function (arg) {
                equal(this, data.map, 'correct this');
                equal(arg, true, 'correct arg');
            }
        });
        var data = { map: new MapConstruct() };
        var res = Scope.read(data, observeReader.reads('map.foo'), { isArgument: true });
        res.value(true);
    });
    test('rooted observable is able to update correctly', function () {
        var baseMap = new DefineMap({ name: { first: 'Justin' } });
        var scope = new Scope(baseMap);
        var compute = scope.computeData('name.first').compute;
        equal(compute(), 'Justin');
        baseMap.name = new DefineMap({ first: 'Brian' });
        equal(compute(), 'Brian');
    });
    test('Can read static properties on constructors (#634)', function () {
        var Foo = DefineMap.extend({ static_prop: 'baz' }, { proto_prop: 'thud' });
        var data = new Foo({ own_prop: 'quux' }), scope = new Scope(data);
        equal(scope.computeData('constructor.static_prop').compute(), 'baz', 'static prop');
    });
    test('setting props in a compute (#18)', function () {
        var map = new DefineMap({ complete: true });
        var computeVal = compute(map);
        var base = new Scope(computeVal);
        var complete = base.computeData('complete').compute;
        equal(complete(), true, 'can read the value');
        complete(false);
        QUnit.equal(map.complete, false, 'value set');
    });
    test('undefined DefineMap props should be a scope hit (#20)', function () {
        var MyType = DefineMap.extend('MyType', { value: 'string' });
        var EmptyType = DefineMap.extend('EmptyType', {});
        var instance = new MyType();
        var scope = new Scope(instance).add(new EmptyType());
        var c1 = scope.computeData('value').compute;
        c1.on('change', function () {
        });
        c1('BAR');
        QUnit.equal(instance.value, 'BAR');
        var instance2 = new MyType();
        var scope2 = new Scope(instance2).add(compute());
        var c2 = scope2.computeData('value').compute;
        c2.on('change', function () {
        });
        c2('BAR');
        QUnit.equal(instance2.value, 'BAR');
    });
    test('that .set with ../ is able to skip notContext scopes (#43)', function () {
        var instance = new DefineMap({ prop: 0 });
        var notContextContext = { NAME: 'NOT CONTEXT' };
        var top = { NAME: 'TOP' };
        var scope = new Scope(instance).add(notContextContext, { notContext: true }).add(top);
        scope.set('../prop', 1);
        QUnit.equal(instance.prop, 1);
    });
    QUnit.test('this works everywhere (#45)', function () {
        var obj = { foo: 'bar' };
        var scope = new Scope(obj);
        QUnit.equal(scope.get('this.foo'), 'bar');
    });
});
/*can-view-scope@3.1.4#test/scope-test*/
define('can-view-scope@3.1.4#test/scope-test', function (require, exports, module) {
    require('./scope-define-test');
    var Scope = require('can-view-scope');
    var Map = require('can-map');
    require('can-list');
    var observeReader = require('can-observation/reader/reader');
    var compute = require('can-compute');
    var ReferenceMap = require('../reference-map');
    var QUnit = require('steal-qunit');
    QUnit.module('can/view/scope');
    test('basics', function () {
        var items = new Map({
            people: [
                { name: 'Justin' },
                [{ name: 'Brian' }]
            ],
            count: 1000
        });
        var itemsScope = new Scope(items), arrayScope = new Scope(itemsScope.peek('people'), itemsScope), firstItem = new Scope(arrayScope.peek('0'), arrayScope);
        var nameInfo;
        var c = compute(function () {
            nameInfo = firstItem.read('name');
        });
        c.bind('change', function () {
        });
        deepEqual(nameInfo.reads, [{
                key: 'name',
                at: false
            }], 'reads');
        equal(nameInfo.scope, firstItem, 'scope');
        equal(nameInfo.value, 'Justin', 'value');
        equal(nameInfo.rootObserve, items.people[0], 'rootObserve');
    });
    test('Scope.prototype.computeData', function () {
        var map = new Map();
        var base = new Scope(map);
        var age = base.computeData('age').compute;
        equal(age(), undefined, 'age is not set');
        age.bind('change', function (ev, newVal, oldVal) {
            equal(newVal, 31, 'newVal is provided correctly');
            equal(oldVal, undefined, 'oldVal is undefined');
        });
        age(31);
        equal(map.attr('age'), 31, 'maps age is set correctly');
    });
    test('backtrack path (#163)', function () {
        var row = new Map({ first: 'Justin' }), col = { format: 'str' }, base = new Scope(row), cur = base.add(col);
        equal(cur.peek('.'), col, 'got col');
        equal(cur.peek('..'), row, 'got row');
        equal(cur.peek('../first'), 'Justin', 'got row');
    });
    test('nested properties with compute', function () {
        var me = new Map({ name: { first: 'Justin' } });
        var cur = new Scope(me);
        var compute = cur.computeData('name.first').compute;
        var changes = 0;
        compute.bind('change', function (ev, newVal, oldVal) {
            if (changes === 0) {
                equal(oldVal, 'Justin');
                equal(newVal, 'Brian');
            } else if (changes === 1) {
                equal(oldVal, 'Brian');
                equal(newVal, undefined);
            } else if (changes === 2) {
                equal(oldVal, undefined);
                equal(newVal, 'Payal');
            } else if (changes === 3) {
                equal(oldVal, 'Payal');
                equal(newVal, 'Curtis');
            }
            changes++;
        });
        equal(compute(), 'Justin', 'read value after bind');
        me.attr('name.first', 'Brian');
        me.removeAttr('name');
        me.attr('name', { first: 'Payal' });
        me.attr('name', new Map({ first: 'Curtis' }));
    });
    test('function at the end', function () {
        var compute = new Scope({
            me: {
                info: function () {
                    return 'Justin';
                }
            }
        }).computeData('me.info').compute;
        equal(compute(), 'Justin');
        var fn = function () {
            return this.name;
        };
        var compute2 = new Scope({
            me: {
                info: fn,
                name: 'Hank'
            }
        }).computeData('me.info', {
            isArgument: true,
            args: []
        }).compute;
        equal(compute2()(), 'Hank');
    });
    test('binds to the right scope only', function () {
        var baseMap = new Map({ me: { name: { first: 'Justin' } } });
        var base = new Scope(baseMap);
        var topMap = new Map({ me: { name: {} } });
        var scope = base.add(topMap);
        var compute = scope.computeData('me.name.first').compute;
        compute.bind('change', function (ev, newVal, oldVal) {
            equal(oldVal, 'Justin');
            equal(newVal, 'Brian');
        });
        equal(compute(), 'Justin');
        topMap.attr('me.name.first', 'Payal');
        baseMap.attr('me.name.first', 'Brian');
    });
    test('Scope read returnObserveMethods=true', function () {
        var MapConstruct = Map.extend({
            foo: function (arg) {
                equal(this, data.map, 'correct this');
                equal(arg, true, 'correct arg');
            }
        });
        var data = { map: new MapConstruct() };
        var res = Scope.read(data, observeReader.reads('map.foo'), { isArgument: true });
        res.value(true);
    });
    test('rooted observable is able to update correctly', function () {
        var baseMap = new Map({ name: { first: 'Justin' } });
        var scope = new Scope(baseMap);
        var compute = scope.computeData('name.first').compute;
        equal(compute(), 'Justin');
        baseMap.attr('name', new Map({ first: 'Brian' }));
        equal(compute(), 'Brian');
    });
    test('computeData reading an object with a compute', function () {
        var sourceAge = 21;
        var age = compute(function (newVal) {
            if (newVal) {
                sourceAge = newVal;
            } else {
                return sourceAge;
            }
        });
        var scope = new Scope({ person: { age: age } });
        var computeData = scope.computeData('person.age');
        var value = computeData.compute();
        equal(value, 21, 'correct value');
        computeData.compute(31);
        equal(age(), 31, 'age updated');
    });
    test('computeData with initial empty compute (#638)', function () {
        expect(2);
        var c = compute();
        var scope = new Scope({ compute: c });
        var computeData = scope.computeData('compute');
        equal(computeData.compute(), undefined);
        computeData.compute.bind('change', function (ev, newVal) {
            equal(newVal, 'compute value');
        });
        c('compute value');
    });
    test('Can read static properties on constructors (#634)', function () {
        var Foo = Map.extend({ static_prop: 'baz' }, { proto_prop: 'thud' });
        var data = new Foo({ own_prop: 'quux' }), scope = new Scope(data);
        equal(scope.computeData('constructor.static_prop').compute(), 'baz', 'static prop');
    });
    test('Can read static properties on constructors (#634)', function () {
        var Foo = Map.extend({ static_prop: 'baz' }, { proto_prop: 'thud' });
        var data = new Foo({ own_prop: 'quux' }), scope = new Scope(data);
        equal(scope.computeData('constructor.static_prop').compute(), 'baz', 'static prop');
    });
    test('Scope lookup restricted to current scope with ./ (#874)', function () {
        var current;
        var scope = new Scope(new Map({ value: 'A Value' })).add(current = new Map({}));
        var compute = scope.computeData('./value').compute;
        equal(compute(), undefined, 'no initial value');
        compute.bind('change', function (ev, newVal) {
            equal(newVal, 'B Value', 'changed');
        });
        compute('B Value');
        equal(current.attr('value'), 'B Value', 'updated');
    });
    test('reading properties on undefined (#1314)', function () {
        var scope = new Scope(undefined);
        var compute = scope.compute('property');
        equal(compute(), undefined, 'got back undefined');
    });
    test('Scope attributes can be set (#1297, #1304)', function () {
        var comp = compute('Test');
        var map = new Map({ other: { name: 'Justin' } });
        var scope = new Scope({
            name: 'Matthew',
            other: {
                person: { name: 'David' },
                comp: comp
            }
        });
        scope.set('name', 'Wilbur');
        equal(scope.get('name'), 'Wilbur', 'Value updated');
        scope.set('other.person.name', 'Dave');
        equal(scope.get('other.person.name'), 'Dave', 'Value updated');
        scope.set('other.comp', 'Changed');
        equal(comp(), 'Changed', 'Compute updated');
        scope = new Scope(map);
        scope.set('other.name', 'Brian');
        equal(scope.get('other.name'), 'Brian', 'Value updated');
        equal(map.attr('other.name'), 'Brian', 'Name update in map');
    });
    test('computeData.compute get/sets computes in maps', function () {
        var cmpt = compute(4);
        var map = new Map();
        map.attr('computer', cmpt);
        var scope = new Scope(map);
        var computeData = scope.computeData('computer', {});
        equal(computeData.compute(), 4, 'got the value');
        computeData.compute(5);
        equal(cmpt(), 5, 'updated compute value');
        equal(computeData.compute(), 5, 'the compute has the right value');
    });
    test('computesData can find update when initially undefined parent scope becomes defined (#579)', function () {
        expect(2);
        var map = new Map();
        var scope = new Scope(map);
        var top = scope.add(new Map());
        var computeData = top.computeData('value', {});
        equal(computeData.compute(), undefined, 'initially undefined');
        computeData.compute.bind('change', function (ev, newVal) {
            equal(newVal, 'first');
        });
        map.attr('value', 'first');
    });
    test('A scope\'s %root is the last context', function () {
        var map = new Map();
        var refs = Scope.refsScope();
        var scope = refs.add(map).add(new Scope.Refs()).add(new Map());
        var root = scope.peek('%root');
        ok(!(root instanceof Scope.Refs), 'root isn\'t a reference');
        equal(root, map, 'The root is the map passed into the scope');
    });
    test('can set scope attributes with ../ (#2132)', function () {
        var map = new Map();
        var scope = new Scope(map);
        var top = scope.add(new Map());
        top.set('../foo', 'bar');
        equal(map.attr('foo'), 'bar');
    });
    test('can read parent context with ../ (#2244)', function () {
        var map = new Map();
        var scope = new Scope(map);
        var top = scope.add(new Map());
        equal(top.peek('../'), map, 'looked up value correctly');
    });
    test('trying to read constructor from refs scope is ok', function () {
        var map = new ReferenceMap();
        var construct = compute(function () {
            return map.attr('constructor');
        });
        construct.bind('change', function () {
        });
        equal(construct(), ReferenceMap);
    });
    test('reading from a string in a nested scope doesn\'t throw an error (#22)', function () {
        var foo = compute('foo');
        var bar = compute('bar');
        var scope = new Scope(foo);
        var localScope = scope.add(bar);
        equal(localScope.read('foo').value, undefined);
    });
    test('Optimize for compute().observableProperty (#29)', function () {
        var map = new Map({ value: 'a' });
        var wrap = compute(map);
        var scope = new Scope(wrap);
        var scopeCompute = scope.compute('value');
        var changeNumber = 0;
        scopeCompute.on('change', function (ev, newVal, oldVal) {
            if (changeNumber === 1) {
                QUnit.equal(newVal, 'b');
                QUnit.equal(oldVal, 'a');
                QUnit.ok(scopeCompute.fastPath, 'still fast path');
                changeNumber++;
                wrap(new Map({ value: 'c' }));
            } else if (changeNumber === 2) {
                QUnit.equal(newVal, 'c', 'got new value');
                QUnit.equal(oldVal, 'b', 'got old value');
                QUnit.notOk(scopeCompute.fastPath, 'still fast path');
            }
        });
        QUnit.ok(scopeCompute.fastPath, 'fast path');
        changeNumber++;
        map.attr('value', 'b');
    });
    test('read should support passing %scope (#24)', function () {
        var scope = new Scope(new Map({
            foo: '',
            bar: ''
        }));
        equal(scope.read('%scope').value, scope, 'looked up %scope correctly');
    });
});
/*can@3.4.1#view/scope/scope_test*/
define('can@3.4.1#view/scope/scope_test', function (require, exports, module) {
    require('can-view-scope/test/scope-test');
    require('can-view-scope/test/scope-define-test');
});
/*can-view-autorender@3.0.4#can-view-autorender_test*/
define('can-view-autorender@3.0.4#can-view-autorender_test', function (require, exports, module) {
    (function (__dirname) {
        var QUnit = require('steal-qunit');
        var makeIframe = function (src) {
            var iframe = document.createElement('iframe');
            window.removeMyself = function () {
                delete window.removeMyself;
                delete window.isReady;
                delete window.hasError;
                document.body.removeChild(iframe);
                start();
            };
            window.hasError = function (error) {
                ok(false, error.message || error);
                window.removeMyself();
            };
            document.body.appendChild(iframe);
            iframe.src = src;
        };
        var get = function (map, prop) {
            return map.attr ? map.attr(prop) : map.get(prop);
        };
        var makeBasicTestIframe = function (src) {
            var iframe = document.createElement('iframe');
            window.removeMyself = function () {
                delete window.removeMyself;
                delete window.isReady;
                delete window.hasError;
                document.body.removeChild(iframe);
                start();
            };
            window.hasError = function (error) {
                ok(false, error.message || error);
                window.removeMyself();
            };
            window.isReady = function (el, scope) {
                equal(el.length, 1, 'only one my-component');
                equal(el[0].innerHTML, 'Hello World', 'template rendered');
                equal(get(scope, 'message'), 'Hello World', 'Scope correctly setup');
                window.removeMyself();
            };
            document.body.appendChild(iframe);
            iframe.src = src;
        };
        QUnit.module('can-view-autorender');
        if (__dirname !== '/') {
            QUnit.asyncTest('the basics are able to work for steal', function () {
                makeBasicTestIframe(__dirname + '/test/basics.html?' + Math.random());
            });
            QUnit.asyncTest('autoload loads a jquery viewmodel fn', function () {
                makeIframe(__dirname + '/test/steal-viewmodel.html?' + Math.random());
            });
            QUnit.asyncTest('works with a can-define/map/map', function () {
                makeBasicTestIframe(__dirname + '/test/define.html?' + Math.random());
            });
        }
    }('/'));
});
/*can@3.4.1#view/autorender/autorender_test*/
define('can@3.4.1#view/autorender/autorender_test', function (require, exports, module) {
    require('can-view-autorender/can-view-autorender_test');
});
/*can-simple-dom@1.0.5#simple-dom/document/node*/
define('can-simple-dom@1.0.5#simple-dom/document/node', [], function () {
    'use strict';
    function Node(nodeType, nodeName, nodeValue, ownerDocument) {
        this.nodeType = nodeType;
        this.nodeName = nodeName;
        this.nodeValue = nodeValue;
        this.ownerDocument = ownerDocument;
        this.childNodes = new ChildNodes(this);
        this.parentNode = null;
        this.previousSibling = null;
        this.nextSibling = null;
        this.firstChild = null;
        this.lastChild = null;
    }
    Node.prototype._cloneNode = function () {
        return new Node(this.nodeType, this.nodeName, this.nodeValue, this.ownerDocument);
    };
    Node.prototype.cloneNode = function (deep) {
        var node = this._cloneNode();
        if (deep) {
            var child = this.firstChild, nextChild = child;
            while (nextChild) {
                nextChild = child.nextSibling;
                node.appendChild(child.cloneNode(true));
                child = nextChild;
            }
        }
        return node;
    };
    Node.prototype.appendChild = function (node) {
        if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
            insertFragment(node, this, this.lastChild, null);
            return node;
        }
        if (node.parentNode) {
            node.parentNode.removeChild(node);
        }
        node.parentNode = this;
        var refNode = this.lastChild;
        if (refNode === null) {
            this.firstChild = node;
            this.lastChild = node;
        } else {
            node.previousSibling = refNode;
            refNode.nextSibling = node;
            this.lastChild = node;
        }
        return node;
    };
    function insertFragment(fragment, newParent, before, after) {
        if (!fragment.firstChild) {
            return;
        }
        var firstChild = fragment.firstChild;
        var lastChild = firstChild;
        var node = firstChild;
        firstChild.previousSibling = before;
        if (before) {
            before.nextSibling = firstChild;
        } else {
            newParent.firstChild = firstChild;
        }
        while (node) {
            node.parentNode = newParent;
            lastChild = node;
            node = node.nextSibling;
        }
        lastChild.nextSibling = after;
        if (after) {
            after.previousSibling = lastChild;
        } else {
            newParent.lastChild = lastChild;
        }
        fragment.firstChild = null;
        fragment.lastChild = null;
    }
    var nodeInsertBefore = Node.prototype.insertBefore = function (node, refNode) {
        if (refNode == null) {
            return this.appendChild(node);
        }
        if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
            insertFragment(node, this, refNode ? refNode.previousSibling : null, refNode);
            return node;
        }
        if (node.parentNode) {
            node.parentNode.removeChild(node);
        }
        node.parentNode = this;
        var previousSibling = refNode.previousSibling;
        if (previousSibling) {
            previousSibling.nextSibling = node;
            node.previousSibling = previousSibling;
        }
        refNode.previousSibling = node;
        node.nextSibling = refNode;
        if (this.firstChild === refNode) {
            this.firstChild = node;
        }
        return node;
    };
    var nodeRemoveChild = Node.prototype.removeChild = function (refNode) {
        if (this.firstChild === refNode) {
            this.firstChild = refNode.nextSibling;
        }
        if (this.lastChild === refNode) {
            this.lastChild = refNode.previousSibling;
        }
        if (refNode.previousSibling) {
            refNode.previousSibling.nextSibling = refNode.nextSibling;
        }
        if (refNode.nextSibling) {
            refNode.nextSibling.previousSibling = refNode.previousSibling;
        }
        refNode.parentNode = null;
        refNode.nextSibling = null;
        refNode.previousSibling = null;
        return refNode;
    };
    Node.prototype.replaceChild = function (newChild, oldChild) {
        nodeInsertBefore.call(this, newChild, oldChild);
        nodeRemoveChild.call(this, oldChild);
        return oldChild;
    };
    Node.prototype.addEventListener = function () {
    };
    Node.prototype.removeEventListener = function () {
    };
    Node.ELEMENT_NODE = 1;
    Node.ATTRIBUTE_NODE = 2;
    Node.TEXT_NODE = 3;
    Node.CDATA_SECTION_NODE = 4;
    Node.ENTITY_REFERENCE_NODE = 5;
    Node.ENTITY_NODE = 6;
    Node.PROCESSING_INSTRUCTION_NODE = 7;
    Node.COMMENT_NODE = 8;
    Node.DOCUMENT_NODE = 9;
    Node.DOCUMENT_TYPE_NODE = 10;
    Node.DOCUMENT_FRAGMENT_NODE = 11;
    Node.NOTATION_NODE = 12;
    function ChildNodes(node) {
        this.node = node;
    }
    ChildNodes.prototype.item = function (index) {
        var child = this.node.firstChild;
        for (var i = 0; child && index !== i; i++) {
            child = child.nextSibling;
        }
        return child;
    };
    var $__default = Node;
    return {
        get default() {
            return $__default;
        },
        __esModule: true
    };
});
/*can-simple-dom@1.0.5#simple-dom/document/element*/
define('can-simple-dom@1.0.5#simple-dom/document/element', ['./node'], function ($__0) {
    'use strict';
    if (!$__0 || !$__0.__esModule)
        $__0 = { default: $__0 };
    var Node = $__0.default;
    var attrSpecial = {
        'class': function (element, value) {
            element._className = value;
        }
    };
    function Element(tagName, ownerDocument) {
        tagName = tagName.toUpperCase();
        this.nodeConstructor(1, tagName, null, ownerDocument);
        this.style = new Style(this);
        this.attributes = [];
        this.tagName = tagName;
    }
    Element.prototype = Object.create(Node.prototype);
    Element.prototype.constructor = Element;
    Element.prototype.nodeConstructor = Node;
    Element.prototype._cloneNode = function () {
        var node = this.ownerDocument.createElement(this.tagName);
        node.attributes = this.attributes.map(function (attr) {
            return {
                name: attr.name,
                value: attr.value,
                specified: attr.specified
            };
        });
        return node;
    };
    Element.prototype.getAttribute = function (_name) {
        var attributes = this.attributes;
        var name = _name.toLowerCase();
        var attr;
        for (var i = 0, l = attributes.length; i < l; i++) {
            attr = attributes[i];
            if (attr.name === name) {
                return attr.value;
            }
        }
        return null;
    };
    Element.prototype.setAttribute = function () {
        return this._setAttribute.apply(this, arguments);
    };
    Element.prototype._setAttribute = function (_name, value) {
        var attributes = this.attributes;
        var name = _name.toLowerCase();
        var attr;
        for (var i = 0, l = attributes.length; i < l; i++) {
            attr = attributes[i];
            if (attr.name === name) {
                attr.value = value;
                return;
            }
        }
        attributes.push({
            name: name,
            value: value,
            specified: true
        });
        attributes[name] = value;
        var special = attrSpecial[name];
        if (special) {
            special(this, value);
        }
    };
    Element.prototype.hasAttribute = function (_name) {
        var attributes = this.attributes;
        var name = _name.toLowerCase();
        var attr;
        for (var i = 0, len = attributes.length; i < len; i++) {
            attr = attributes[i];
            if (attr.name === name) {
                return true;
            }
        }
        return false;
    };
    Element.prototype.removeAttribute = function (name) {
        var attributes = this.attributes;
        for (var i = 0, l = attributes.length; i < l; i++) {
            var attr = attributes[i];
            if (attr.name === name) {
                attributes.splice(i, 1);
                delete attributes[name];
                return;
            }
        }
    };
    Element.prototype.getElementsByTagName = function (name) {
        name = name.toUpperCase();
        var elements = [];
        var cur = this.firstChild;
        while (cur) {
            if (cur.nodeType === Node.ELEMENT_NODE) {
                if (cur.nodeName === name || name === '*') {
                    elements.push(cur);
                }
                elements.push.apply(elements, cur.getElementsByTagName(name));
            }
            cur = cur.nextSibling;
        }
        return elements;
    };
    Element.prototype.contains = function (child) {
        child = child.parentNode;
        while (child) {
            if (child === this) {
                return true;
            }
            child = child.parentNode;
        }
        return false;
    };
    Element.prototype.getElementById = function (id) {
        var cur = this.firstChild, child;
        while (cur) {
            if (cur.attributes && cur.attributes.length) {
                var attr = void 0;
                for (var i = 0, len = cur.attributes.length; i < len; i++) {
                    attr = cur.attributes[i];
                    if (attr.name === 'id' && attr.value === id) {
                        return cur;
                    }
                }
            }
            if (cur.getElementById) {
                child = cur.getElementById(id);
                if (child) {
                    return child;
                }
            }
            cur = cur.nextSibling;
        }
    };
    function Style(node) {
        this.__node = node;
    }
    if (Object.defineProperty) {
        Object.defineProperty(Element.prototype, 'className', {
            get: function () {
                return this._className || '';
            },
            set: function (val) {
                this._setAttribute('class', val);
                this._className = val;
            }
        });
        Object.defineProperty(Style.prototype, 'cssText', {
            get: function () {
                return this.__node.getAttribute('style') || '';
            },
            set: function (val) {
                this.__node._setAttribute('style', val);
            }
        });
        Object.defineProperty(Element.prototype, 'innerHTML', {
            get: function () {
                var html = '';
                var cur = this.firstChild;
                while (cur) {
                    html += this.ownerDocument.__serializer.serialize(cur);
                    cur = cur.nextSibling;
                }
                return html;
            },
            set: function (html) {
                this.lastChild = this.firstChild = null;
                var fragment;
                if (this.nodeName === 'SCRIPT' || this.nodeName === 'STYLE') {
                    fragment = this.ownerDocument.createTextNode(html);
                } else {
                    fragment = this.ownerDocument.__parser.parse(html);
                }
                this.appendChild(fragment);
            }
        });
        Object.defineProperty(Element.prototype, 'outerHTML', {
            get: function () {
                return this.ownerDocument.__serializer.serialize(this);
            },
            set: function (html) {
                this.parentNode.replaceChild(this.ownerDocument.__parser.parse(html), this);
            }
        });
    }
    var $__default = Element;
    return {
        get default() {
            return $__default;
        },
        __esModule: true
    };
});
/*can-simple-dom@1.0.5#simple-dom/document/text*/
define('can-simple-dom@1.0.5#simple-dom/document/text', ['./node'], function ($__0) {
    'use strict';
    if (!$__0 || !$__0.__esModule)
        $__0 = { default: $__0 };
    var Node = $__0.default;
    function Text(text, ownerDocument) {
        this.nodeConstructor(3, '#text', text, ownerDocument);
    }
    Text.prototype._cloneNode = function () {
        return this.ownerDocument.createTextNode(this.nodeValue);
    };
    Text.prototype = Object.create(Node.prototype);
    Text.prototype.constructor = Text;
    Text.prototype.nodeConstructor = Node;
    var $__default = Text;
    return {
        get default() {
            return $__default;
        },
        __esModule: true
    };
});
/*can-simple-dom@1.0.5#simple-dom/document/comment*/
define('can-simple-dom@1.0.5#simple-dom/document/comment', ['./node'], function ($__0) {
    'use strict';
    if (!$__0 || !$__0.__esModule)
        $__0 = { default: $__0 };
    var Node = $__0.default;
    function Comment(text, ownerDocument) {
        this.nodeConstructor(8, '#comment', text, ownerDocument);
    }
    Comment.prototype._cloneNode = function () {
        return this.ownerDocument.createComment(this.nodeValue);
    };
    Comment.prototype = Object.create(Node.prototype);
    Comment.prototype.constructor = Comment;
    Comment.prototype.nodeConstructor = Node;
    var $__default = Comment;
    return {
        get default() {
            return $__default;
        },
        __esModule: true
    };
});
/*can-simple-dom@1.0.5#simple-dom/document/document-fragment*/
define('can-simple-dom@1.0.5#simple-dom/document/document-fragment', ['./node'], function ($__0) {
    'use strict';
    if (!$__0 || !$__0.__esModule)
        $__0 = { default: $__0 };
    var Node = $__0.default;
    function DocumentFragment(ownerDocument) {
        this.nodeConstructor(11, '#document-fragment', null, ownerDocument);
    }
    DocumentFragment.prototype._cloneNode = function () {
        return this.ownerDocument.createDocumentFragment();
    };
    DocumentFragment.prototype = Object.create(Node.prototype);
    DocumentFragment.prototype.constructor = DocumentFragment;
    DocumentFragment.prototype.nodeConstructor = Node;
    var $__default = DocumentFragment;
    return {
        get default() {
            return $__default;
        },
        __esModule: true
    };
});
/*can-simple-dom@1.0.5#simple-dom/extend*/
define('can-simple-dom@1.0.5#simple-dom/extend', [], function () {
    'use strict';
    var $__default = function (a, b) {
        for (var p in b) {
            a[p] = b[p];
        }
        return a;
    };
    ;
    return {
        get default() {
            return $__default;
        },
        __esModule: true
    };
});
/*can-simple-dom@1.0.5#simple-dom/document/anchor-element*/
define('can-simple-dom@1.0.5#simple-dom/document/anchor-element', [
    './element',
    'micro-location',
    '../extend'
], function ($__0, $__2, $__4) {
    'use strict';
    if (!$__0 || !$__0.__esModule)
        $__0 = { default: $__0 };
    if (!$__2 || !$__2.__esModule)
        $__2 = { default: $__2 };
    if (!$__4 || !$__4.__esModule)
        $__4 = { default: $__4 };
    var Element = $__0.default;
    var microLocation = $__2.default;
    var extend = $__4.default;
    var Location = microLocation.Location || microLocation;
    function AnchorElement(tagName, ownerDocument) {
        this.elementConstructor(tagName, ownerDocument);
        extend(this, Location.parse(''));
    }
    AnchorElement.prototype = Object.create(Element.prototype);
    AnchorElement.prototype.constructor = AnchorElement;
    AnchorElement.prototype.elementConstructor = Element;
    AnchorElement.prototype.setAttribute = function (_name, value) {
        Element.prototype.setAttribute.apply(this, arguments);
        if (_name.toLowerCase() === 'href') {
            extend(this, Location.parse(value));
        }
    };
    var $__default = AnchorElement;
    return {
        get default() {
            return $__default;
        },
        __esModule: true
    };
});
/*can-simple-dom@1.0.5#simple-dom/document/utils.js*/
define('can-simple-dom@1.0.5#simple-dom/document/utils.js', [], function () {
    'use strict';
    function propToAttr(Element, name) {
        Object.defineProperty(Element.prototype, name, {
            get: function () {
                return this.getAttribute(name);
            },
            set: function (val) {
                this.setAttribute(name, val);
            }
        });
    }
    ;
    return {
        get propToAttr() {
            return propToAttr;
        },
        __esModule: true
    };
});
/*can-simple-dom@1.0.5#simple-dom/document/input-element*/
define('can-simple-dom@1.0.5#simple-dom/document/input-element', [
    './element',
    './utils'
], function ($__0, $__2) {
    'use strict';
    if (!$__0 || !$__0.__esModule)
        $__0 = { default: $__0 };
    if (!$__2 || !$__2.__esModule)
        $__2 = { default: $__2 };
    var Element = $__0.default;
    var propToAttr = $__2.propToAttr;
    function InputElement(tagName, ownerDocument) {
        this.elementConstructor(tagName, ownerDocument);
    }
    InputElement.prototype = Object.create(Element.prototype);
    InputElement.prototype.constructor = InputElement;
    InputElement.prototype.elementConstructor = Element;
    propToAttr(InputElement, 'type');
    propToAttr(InputElement, 'value');
    Object.defineProperty(InputElement.prototype, 'checked', {
        get: function () {
            return this.hasAttribute('checked');
        },
        set: function (value) {
            if (value) {
                this.setAttribute('checked', '');
            } else {
                this.removeAttribute('checked');
            }
        }
    });
    var $__default = InputElement;
    return {
        get default() {
            return $__default;
        },
        __esModule: true
    };
});
/*can-simple-dom@1.0.5#simple-dom/document/utils*/
define('can-simple-dom@1.0.5#simple-dom/document/utils', [], function () {
    'use strict';
    function propToAttr(Element, name) {
        Object.defineProperty(Element.prototype, name, {
            get: function () {
                return this.getAttribute(name);
            },
            set: function (val) {
                this.setAttribute(name, val);
            }
        });
    }
    ;
    return {
        get propToAttr() {
            return propToAttr;
        },
        __esModule: true
    };
});
/*can-simple-dom@1.0.5#simple-dom/document/option-element*/
define('can-simple-dom@1.0.5#simple-dom/document/option-element', [
    './element',
    './utils'
], function ($__0, $__2) {
    'use strict';
    if (!$__0 || !$__0.__esModule)
        $__0 = { default: $__0 };
    if (!$__2 || !$__2.__esModule)
        $__2 = { default: $__2 };
    var Element = $__0.default;
    var propToAttr = $__2.propToAttr;
    function OptionElement(tagName, ownerDocument) {
        this.elementConstructor(tagName, ownerDocument);
    }
    OptionElement.prototype = Object.create(Element.prototype);
    OptionElement.prototype.constructor = OptionElement;
    OptionElement.prototype.elementConstructor = Element;
    propToAttr(OptionElement, 'value');
    Object.defineProperty(OptionElement.prototype, 'selected', {
        get: function () {
            var val = this.value || '';
            var parent = this.parentNode;
            return parent && parent.value == val;
        },
        set: function (val) {
            if (val) {
                var parent = this.parentNode;
                if (parent) {
                    parent.value = this.value;
                }
            }
        }
    });
    var $__default = OptionElement;
    return {
        get default() {
            return $__default;
        },
        __esModule: true
    };
});
/*can-simple-dom@1.0.5#simple-dom/document/select-element*/
define('can-simple-dom@1.0.5#simple-dom/document/select-element', [
    './element',
    './utils'
], function ($__0, $__2) {
    'use strict';
    if (!$__0 || !$__0.__esModule)
        $__0 = { default: $__0 };
    if (!$__2 || !$__2.__esModule)
        $__2 = { default: $__2 };
    var Element = $__0.default;
    var propToAttr = $__2.propToAttr;
    function SelectElement(tagName, ownerDocument) {
        this.elementConstructor(tagName, ownerDocument);
        this.selectedIndex = 0;
    }
    SelectElement.prototype = Object.create(Element.prototype);
    SelectElement.prototype.constructor = SelectElement;
    SelectElement.prototype.elementConstructor = Element;
    propToAttr(SelectElement, 'value');
    var $__default = SelectElement;
    return {
        get default() {
            return $__default;
        },
        __esModule: true
    };
});
/*can-simple-dom@1.0.5#simple-dom/document*/
define('can-simple-dom@1.0.5#simple-dom/document', [
    './document/node',
    './document/element',
    './document/text',
    './document/comment',
    './document/document-fragment',
    './document/anchor-element',
    './document/input-element',
    './document/option-element',
    './document/select-element'
], function ($__0, $__2, $__4, $__6, $__8, $__10, $__12, $__14, $__16) {
    'use strict';
    if (!$__0 || !$__0.__esModule)
        $__0 = { default: $__0 };
    if (!$__2 || !$__2.__esModule)
        $__2 = { default: $__2 };
    if (!$__4 || !$__4.__esModule)
        $__4 = { default: $__4 };
    if (!$__6 || !$__6.__esModule)
        $__6 = { default: $__6 };
    if (!$__8 || !$__8.__esModule)
        $__8 = { default: $__8 };
    if (!$__10 || !$__10.__esModule)
        $__10 = { default: $__10 };
    if (!$__12 || !$__12.__esModule)
        $__12 = { default: $__12 };
    if (!$__14 || !$__14.__esModule)
        $__14 = { default: $__14 };
    if (!$__16 || !$__16.__esModule)
        $__16 = { default: $__16 };
    var Node = $__0.default;
    var Element = $__2.default;
    var Text = $__4.default;
    var Comment = $__6.default;
    var DocumentFragment = $__8.default;
    var AnchorElement = $__10.default;
    var InputElement = $__12.default;
    var OptionElement = $__14.default;
    var SelectElement = $__16.default;
    function Document() {
        this.nodeConstructor(9, '#document', null, this);
        this.documentElement = new Element('html', this);
        this.body = new Element('body', this);
        this.documentElement.appendChild(this.body);
        this.appendChild(this.documentElement);
        var self = this;
        this.implementation = {
            createHTMLDocument: function (content) {
                var document = new Document();
                var frag = self.__parser.parse(content);
                var body = Element.prototype.getElementsByTagName.call(frag, 'body')[0];
                var head = Element.prototype.getElementsByTagName.call(frag, 'head')[0];
                if (!body && !head) {
                    document.body.appendChild(frag);
                } else {
                    if (body) {
                        document.documentElement.replaceChild(body, document.body);
                    }
                    if (head) {
                        document.documentElement.replaceChild(head, document.head);
                    }
                    document.documentElement.appendChild(frag);
                }
                document.__addSerializerAndParser(self.__serializer, self.__parser);
                return document;
            }
        };
    }
    Document.prototype = Object.create(Node.prototype);
    Document.prototype.constructor = Document;
    Document.prototype.nodeConstructor = Node;
    var specialElements = {
        'a': AnchorElement,
        'input': InputElement,
        'option': OptionElement,
        'select': SelectElement
    };
    Document.prototype.createElement = function (tagName) {
        var Special = specialElements[tagName.toLowerCase()];
        if (Special) {
            return new Special(tagName, this);
        }
        return new Element(tagName, this);
    };
    Document.prototype.createTextNode = function (text) {
        return new Text(text, this);
    };
    Document.prototype.createComment = function (text) {
        return new Comment(text, this);
    };
    Document.prototype.createDocumentFragment = function () {
        return new DocumentFragment(this);
    };
    Document.prototype.getElementsByTagName = function (name) {
        name = name.toUpperCase();
        var elements = [];
        var cur = this.firstChild;
        while (cur) {
            if (cur.nodeType === Node.ELEMENT_NODE) {
                if (cur.nodeName === name || name === '*') {
                    elements.push(cur);
                }
                elements.push.apply(elements, cur.getElementsByTagName(name));
            }
            cur = cur.nextSibling;
        }
        return elements;
    };
    Document.prototype.getElementById = function (id) {
        return Element.prototype.getElementById.apply(this.documentElement, arguments);
    };
    Document.prototype.__addSerializerAndParser = function (serializer, parser) {
        this.__parser = parser;
        this.__serializer = serializer;
    };
    if (Object.defineProperty) {
        Object.defineProperty(Document.prototype, 'currentScript', {
            get: function () {
                var scripts = this.getElementsByTagName('script');
                var first = scripts[scripts.length - 1];
                if (!first) {
                    first = this.createElement('script');
                }
                return first;
            }
        });
    }
    var $__default = Document;
    return {
        get default() {
            return $__default;
        },
        __esModule: true
    };
});
/*can-simple-dom@1.0.5#simple-dom/event*/
define('can-simple-dom@1.0.5#simple-dom/event', [
    './document/node',
    './document'
], function ($__0, $__2) {
    'use strict';
    if (!$__0 || !$__0.__esModule)
        $__0 = { default: $__0 };
    if (!$__2 || !$__2.__esModule)
        $__2 = { default: $__2 };
    var Node = $__0.default;
    var Document = $__2.default;
    var Event = function () {
    };
    Event.prototype.initEvent = function (type, bubbles, cancelable) {
        this.type = type;
        this.bubbles = !!bubbles;
        this.cancelable = !!cancelable;
    };
    Event.prototype.stopPropagation = function () {
        this.isPropagationStopped = true;
    };
    Event.prototype.preventDefault = function () {
        this.isDefaultPrevented = true;
    };
    Document.prototype.createEvent = function (type) {
        return new Event();
    };
    Node.prototype.addEventListener = function (event, handler, capture) {
        if (!this.__handlers) {
            Object.defineProperty(this, '__handlers', {
                value: {},
                enumerable: false
            });
        }
        var phase = capture ? 'capture' : 'bubble';
        var handlersByType = this.__handlers[event + ' ' + phase];
        if (!handlersByType) {
            handlersByType = this.__handlers[event + ' ' + phase] = [];
        }
        handlersByType.push(handler);
    };
    Node.prototype.removeEventListener = function (event, handler, capture) {
        if (this.__handlers) {
            var phase = capture ? 'capture' : 'bubble';
            var handlersByType = this.__handlers[event + ' ' + phase];
            if (handlersByType) {
                var index = 0;
                while (index < handlersByType.length) {
                    if (handlersByType[index] === handler) {
                        handlersByType.splice(index, 1);
                    } else {
                        index++;
                    }
                }
            }
        }
    };
    Node.prototype.dispatchEvent = function (event) {
        event.target = this;
        var cur = this;
        var dispatchHandlers = [];
        do {
            var handlers = cur.__handlers && cur.__handlers[event.type + ' bubble'];
            if (handlers) {
                dispatchHandlers.push({
                    node: cur,
                    handlers: handlers
                });
            }
            cur = cur.parentNode;
        } while (event.bubbles && cur);
        for (var i = 0; i < dispatchHandlers.length; i++) {
            var dispatches = dispatchHandlers[i];
            event.currentTarget = dispatches.node;
            for (var h = 0; h < dispatches.handlers.length; h++) {
                var handler = dispatches.handlers[h];
                var res = handler.call(this, event);
                if (res) {
                    event.stopPropagation();
                    event.preventDefault();
                }
                if (event.isImmediatePropagationStopped) {
                    return !event.isDefaultPrevented;
                }
            }
            if (event.isPropagationStopped) {
                return !event.isDefaultPrevented;
            }
        }
        return !event.isDefaultPrevented;
    };
    var $__default = Event;
    return {
        get default() {
            return $__default;
        },
        __esModule: true
    };
});
/*he@1.1.1#he*/
;
(function (root) {
    var freeExports = typeof exports == 'object' && exports;
    var freeModule = typeof module == 'object' && module && module.exports == freeExports && module;
    var freeGlobal = typeof global == 'object' && global;
    if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
        root = freeGlobal;
    }
    var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    var regexAsciiWhitelist = /[\x01-\x7F]/g;
    var regexBmpWhitelist = /[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g;
    var regexEncodeNonAscii = /<\u20D2|=\u20E5|>\u20D2|\u205F\u200A|\u219D\u0338|\u2202\u0338|\u2220\u20D2|\u2229\uFE00|\u222A\uFE00|\u223C\u20D2|\u223D\u0331|\u223E\u0333|\u2242\u0338|\u224B\u0338|\u224D\u20D2|\u224E\u0338|\u224F\u0338|\u2250\u0338|\u2261\u20E5|\u2264\u20D2|\u2265\u20D2|\u2266\u0338|\u2267\u0338|\u2268\uFE00|\u2269\uFE00|\u226A\u0338|\u226A\u20D2|\u226B\u0338|\u226B\u20D2|\u227F\u0338|\u2282\u20D2|\u2283\u20D2|\u228A\uFE00|\u228B\uFE00|\u228F\u0338|\u2290\u0338|\u2293\uFE00|\u2294\uFE00|\u22B4\u20D2|\u22B5\u20D2|\u22D8\u0338|\u22D9\u0338|\u22DA\uFE00|\u22DB\uFE00|\u22F5\u0338|\u22F9\u0338|\u2933\u0338|\u29CF\u0338|\u29D0\u0338|\u2A6D\u0338|\u2A70\u0338|\u2A7D\u0338|\u2A7E\u0338|\u2AA1\u0338|\u2AA2\u0338|\u2AAC\uFE00|\u2AAD\uFE00|\u2AAF\u0338|\u2AB0\u0338|\u2AC5\u0338|\u2AC6\u0338|\u2ACB\uFE00|\u2ACC\uFE00|\u2AFD\u20E5|[\xA0-\u0113\u0116-\u0122\u0124-\u012B\u012E-\u014D\u0150-\u017E\u0192\u01B5\u01F5\u0237\u02C6\u02C7\u02D8-\u02DD\u0311\u0391-\u03A1\u03A3-\u03A9\u03B1-\u03C9\u03D1\u03D2\u03D5\u03D6\u03DC\u03DD\u03F0\u03F1\u03F5\u03F6\u0401-\u040C\u040E-\u044F\u0451-\u045C\u045E\u045F\u2002-\u2005\u2007-\u2010\u2013-\u2016\u2018-\u201A\u201C-\u201E\u2020-\u2022\u2025\u2026\u2030-\u2035\u2039\u203A\u203E\u2041\u2043\u2044\u204F\u2057\u205F-\u2063\u20AC\u20DB\u20DC\u2102\u2105\u210A-\u2113\u2115-\u211E\u2122\u2124\u2127-\u2129\u212C\u212D\u212F-\u2131\u2133-\u2138\u2145-\u2148\u2153-\u215E\u2190-\u219B\u219D-\u21A7\u21A9-\u21AE\u21B0-\u21B3\u21B5-\u21B7\u21BA-\u21DB\u21DD\u21E4\u21E5\u21F5\u21FD-\u2205\u2207-\u2209\u220B\u220C\u220F-\u2214\u2216-\u2218\u221A\u221D-\u2238\u223A-\u2257\u2259\u225A\u225C\u225F-\u2262\u2264-\u228B\u228D-\u229B\u229D-\u22A5\u22A7-\u22B0\u22B2-\u22BB\u22BD-\u22DB\u22DE-\u22E3\u22E6-\u22F7\u22F9-\u22FE\u2305\u2306\u2308-\u2310\u2312\u2313\u2315\u2316\u231C-\u231F\u2322\u2323\u232D\u232E\u2336\u233D\u233F\u237C\u23B0\u23B1\u23B4-\u23B6\u23DC-\u23DF\u23E2\u23E7\u2423\u24C8\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2550-\u256C\u2580\u2584\u2588\u2591-\u2593\u25A1\u25AA\u25AB\u25AD\u25AE\u25B1\u25B3-\u25B5\u25B8\u25B9\u25BD-\u25BF\u25C2\u25C3\u25CA\u25CB\u25EC\u25EF\u25F8-\u25FC\u2605\u2606\u260E\u2640\u2642\u2660\u2663\u2665\u2666\u266A\u266D-\u266F\u2713\u2717\u2720\u2736\u2758\u2772\u2773\u27C8\u27C9\u27E6-\u27ED\u27F5-\u27FA\u27FC\u27FF\u2902-\u2905\u290C-\u2913\u2916\u2919-\u2920\u2923-\u292A\u2933\u2935-\u2939\u293C\u293D\u2945\u2948-\u294B\u294E-\u2976\u2978\u2979\u297B-\u297F\u2985\u2986\u298B-\u2996\u299A\u299C\u299D\u29A4-\u29B7\u29B9\u29BB\u29BC\u29BE-\u29C5\u29C9\u29CD-\u29D0\u29DC-\u29DE\u29E3-\u29E5\u29EB\u29F4\u29F6\u2A00-\u2A02\u2A04\u2A06\u2A0C\u2A0D\u2A10-\u2A17\u2A22-\u2A27\u2A29\u2A2A\u2A2D-\u2A31\u2A33-\u2A3C\u2A3F\u2A40\u2A42-\u2A4D\u2A50\u2A53-\u2A58\u2A5A-\u2A5D\u2A5F\u2A66\u2A6A\u2A6D-\u2A75\u2A77-\u2A9A\u2A9D-\u2AA2\u2AA4-\u2AB0\u2AB3-\u2AC8\u2ACB\u2ACC\u2ACF-\u2ADB\u2AE4\u2AE6-\u2AE9\u2AEB-\u2AF3\u2AFD\uFB00-\uFB04]|\uD835[\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDD6B]/g;
    var encodeMap = {
        '\xAD': 'shy',
        '‌': 'zwnj',
        '‍': 'zwj',
        '\u200E': 'lrm',
        '\u2063': 'ic',
        '\u2062': 'it',
        '\u2061': 'af',
        '\u200F': 'rlm',
        '\u200B': 'ZeroWidthSpace',
        '\u2060': 'NoBreak',
        '̑': 'DownBreve',
        '⃛': 'tdot',
        '⃜': 'DotDot',
        '\t': 'Tab',
        '\n': 'NewLine',
        '\u2008': 'puncsp',
        '\u205F': 'MediumSpace',
        '\u2009': 'thinsp',
        '\u200A': 'hairsp',
        '\u2004': 'emsp13',
        '\u2002': 'ensp',
        '\u2005': 'emsp14',
        '\u2003': 'emsp',
        '\u2007': 'numsp',
        '\xA0': 'nbsp',
        '\u205F\u200A': 'ThickSpace',
        '\u203E': 'oline',
        '_': 'lowbar',
        '\u2010': 'dash',
        '\u2013': 'ndash',
        '\u2014': 'mdash',
        '\u2015': 'horbar',
        ',': 'comma',
        ';': 'semi',
        '\u204F': 'bsemi',
        ':': 'colon',
        '\u2A74': 'Colone',
        '!': 'excl',
        '\xA1': 'iexcl',
        '?': 'quest',
        '\xBF': 'iquest',
        '.': 'period',
        '\u2025': 'nldr',
        '\u2026': 'mldr',
        '\xB7': 'middot',
        '\'': 'apos',
        '\u2018': 'lsquo',
        '\u2019': 'rsquo',
        '\u201A': 'sbquo',
        '\u2039': 'lsaquo',
        '\u203A': 'rsaquo',
        '"': 'quot',
        '\u201C': 'ldquo',
        '\u201D': 'rdquo',
        '\u201E': 'bdquo',
        '\xAB': 'laquo',
        '\xBB': 'raquo',
        '(': 'lpar',
        ')': 'rpar',
        '[': 'lsqb',
        ']': 'rsqb',
        '{': 'lcub',
        '}': 'rcub',
        '\u2308': 'lceil',
        '\u2309': 'rceil',
        '\u230A': 'lfloor',
        '\u230B': 'rfloor',
        '\u2985': 'lopar',
        '\u2986': 'ropar',
        '\u298B': 'lbrke',
        '\u298C': 'rbrke',
        '\u298D': 'lbrkslu',
        '\u298E': 'rbrksld',
        '\u298F': 'lbrksld',
        '\u2990': 'rbrkslu',
        '\u2991': 'langd',
        '\u2992': 'rangd',
        '\u2993': 'lparlt',
        '\u2994': 'rpargt',
        '\u2995': 'gtlPar',
        '\u2996': 'ltrPar',
        '\u27E6': 'lobrk',
        '\u27E7': 'robrk',
        '\u27E8': 'lang',
        '\u27E9': 'rang',
        '\u27EA': 'Lang',
        '\u27EB': 'Rang',
        '\u27EC': 'loang',
        '\u27ED': 'roang',
        '\u2772': 'lbbrk',
        '\u2773': 'rbbrk',
        '\u2016': 'Vert',
        '\xA7': 'sect',
        '\xB6': 'para',
        '@': 'commat',
        '*': 'ast',
        '/': 'sol',
        'undefined': null,
        '&': 'amp',
        '#': 'num',
        '%': 'percnt',
        '\u2030': 'permil',
        '\u2031': 'pertenk',
        '\u2020': 'dagger',
        '\u2021': 'Dagger',
        '\u2022': 'bull',
        '\u2043': 'hybull',
        '\u2032': 'prime',
        '\u2033': 'Prime',
        '\u2034': 'tprime',
        '\u2057': 'qprime',
        '\u2035': 'bprime',
        '\u2041': 'caret',
        '`': 'grave',
        '\xB4': 'acute',
        '\u02DC': 'tilde',
        '^': 'Hat',
        '\xAF': 'macr',
        '\u02D8': 'breve',
        '\u02D9': 'dot',
        '\xA8': 'die',
        '\u02DA': 'ring',
        '\u02DD': 'dblac',
        '\xB8': 'cedil',
        '\u02DB': 'ogon',
        'ˆ': 'circ',
        'ˇ': 'caron',
        '\xB0': 'deg',
        '\xA9': 'copy',
        '\xAE': 'reg',
        '\u2117': 'copysr',
        '\u2118': 'wp',
        '\u211E': 'rx',
        '\u2127': 'mho',
        '\u2129': 'iiota',
        '\u2190': 'larr',
        '\u219A': 'nlarr',
        '\u2192': 'rarr',
        '\u219B': 'nrarr',
        '\u2191': 'uarr',
        '\u2193': 'darr',
        '\u2194': 'harr',
        '\u21AE': 'nharr',
        '\u2195': 'varr',
        '\u2196': 'nwarr',
        '\u2197': 'nearr',
        '\u2198': 'searr',
        '\u2199': 'swarr',
        '\u219D': 'rarrw',
        '\u219D̸': 'nrarrw',
        '\u219E': 'Larr',
        '\u219F': 'Uarr',
        '\u21A0': 'Rarr',
        '\u21A1': 'Darr',
        '\u21A2': 'larrtl',
        '\u21A3': 'rarrtl',
        '\u21A4': 'mapstoleft',
        '\u21A5': 'mapstoup',
        '\u21A6': 'map',
        '\u21A7': 'mapstodown',
        '\u21A9': 'larrhk',
        '\u21AA': 'rarrhk',
        '\u21AB': 'larrlp',
        '\u21AC': 'rarrlp',
        '\u21AD': 'harrw',
        '\u21B0': 'lsh',
        '\u21B1': 'rsh',
        '\u21B2': 'ldsh',
        '\u21B3': 'rdsh',
        '\u21B5': 'crarr',
        '\u21B6': 'cularr',
        '\u21B7': 'curarr',
        '\u21BA': 'olarr',
        '\u21BB': 'orarr',
        '\u21BC': 'lharu',
        '\u21BD': 'lhard',
        '\u21BE': 'uharr',
        '\u21BF': 'uharl',
        '\u21C0': 'rharu',
        '\u21C1': 'rhard',
        '\u21C2': 'dharr',
        '\u21C3': 'dharl',
        '\u21C4': 'rlarr',
        '\u21C5': 'udarr',
        '\u21C6': 'lrarr',
        '\u21C7': 'llarr',
        '\u21C8': 'uuarr',
        '\u21C9': 'rrarr',
        '\u21CA': 'ddarr',
        '\u21CB': 'lrhar',
        '\u21CC': 'rlhar',
        '\u21D0': 'lArr',
        '\u21CD': 'nlArr',
        '\u21D1': 'uArr',
        '\u21D2': 'rArr',
        '\u21CF': 'nrArr',
        '\u21D3': 'dArr',
        '\u21D4': 'iff',
        '\u21CE': 'nhArr',
        '\u21D5': 'vArr',
        '\u21D6': 'nwArr',
        '\u21D7': 'neArr',
        '\u21D8': 'seArr',
        '\u21D9': 'swArr',
        '\u21DA': 'lAarr',
        '\u21DB': 'rAarr',
        '\u21DD': 'zigrarr',
        '\u21E4': 'larrb',
        '\u21E5': 'rarrb',
        '\u21F5': 'duarr',
        '\u21FD': 'loarr',
        '\u21FE': 'roarr',
        '\u21FF': 'hoarr',
        '\u2200': 'forall',
        '\u2201': 'comp',
        '\u2202': 'part',
        '\u2202̸': 'npart',
        '\u2203': 'exist',
        '\u2204': 'nexist',
        '\u2205': 'empty',
        '\u2207': 'Del',
        '\u2208': 'in',
        '\u2209': 'notin',
        '\u220B': 'ni',
        '\u220C': 'notni',
        '\u03F6': 'bepsi',
        '\u220F': 'prod',
        '\u2210': 'coprod',
        '\u2211': 'sum',
        '+': 'plus',
        '\xB1': 'pm',
        '\xF7': 'div',
        '\xD7': 'times',
        '<': 'lt',
        '\u226E': 'nlt',
        '<⃒': 'nvlt',
        '=': 'equals',
        '\u2260': 'ne',
        '=⃥': 'bne',
        '\u2A75': 'Equal',
        '>': 'gt',
        '\u226F': 'ngt',
        '>⃒': 'nvgt',
        '\xAC': 'not',
        '|': 'vert',
        '\xA6': 'brvbar',
        '\u2212': 'minus',
        '\u2213': 'mp',
        '\u2214': 'plusdo',
        '\u2044': 'frasl',
        '\u2216': 'setmn',
        '\u2217': 'lowast',
        '\u2218': 'compfn',
        '\u221A': 'Sqrt',
        '\u221D': 'prop',
        '\u221E': 'infin',
        '\u221F': 'angrt',
        '\u2220': 'ang',
        '\u2220⃒': 'nang',
        '\u2221': 'angmsd',
        '\u2222': 'angsph',
        '\u2223': 'mid',
        '\u2224': 'nmid',
        '\u2225': 'par',
        '\u2226': 'npar',
        '\u2227': 'and',
        '\u2228': 'or',
        '\u2229': 'cap',
        '\u2229︀': 'caps',
        '\u222A': 'cup',
        '\u222A︀': 'cups',
        '\u222B': 'int',
        '\u222C': 'Int',
        '\u222D': 'tint',
        '\u2A0C': 'qint',
        '\u222E': 'oint',
        '\u222F': 'Conint',
        '\u2230': 'Cconint',
        '\u2231': 'cwint',
        '\u2232': 'cwconint',
        '\u2233': 'awconint',
        '\u2234': 'there4',
        '\u2235': 'becaus',
        '\u2236': 'ratio',
        '\u2237': 'Colon',
        '\u2238': 'minusd',
        '\u223A': 'mDDot',
        '\u223B': 'homtht',
        '\u223C': 'sim',
        '\u2241': 'nsim',
        '\u223C⃒': 'nvsim',
        '\u223D': 'bsim',
        '\u223Ḏ': 'race',
        '\u223E': 'ac',
        '\u223E̳': 'acE',
        '\u223F': 'acd',
        '\u2240': 'wr',
        '\u2242': 'esim',
        '\u2242̸': 'nesim',
        '\u2243': 'sime',
        '\u2244': 'nsime',
        '\u2245': 'cong',
        '\u2247': 'ncong',
        '\u2246': 'simne',
        '\u2248': 'ap',
        '\u2249': 'nap',
        '\u224A': 'ape',
        '\u224B': 'apid',
        '\u224B̸': 'napid',
        '\u224C': 'bcong',
        '\u224D': 'CupCap',
        '\u226D': 'NotCupCap',
        '\u224D⃒': 'nvap',
        '\u224E': 'bump',
        '\u224E̸': 'nbump',
        '\u224F': 'bumpe',
        '\u224F̸': 'nbumpe',
        '\u2250': 'doteq',
        '\u2250̸': 'nedot',
        '\u2251': 'eDot',
        '\u2252': 'efDot',
        '\u2253': 'erDot',
        '\u2254': 'colone',
        '\u2255': 'ecolon',
        '\u2256': 'ecir',
        '\u2257': 'cire',
        '\u2259': 'wedgeq',
        '\u225A': 'veeeq',
        '\u225C': 'trie',
        '\u225F': 'equest',
        '\u2261': 'equiv',
        '\u2262': 'nequiv',
        '\u2261⃥': 'bnequiv',
        '\u2264': 'le',
        '\u2270': 'nle',
        '\u2264⃒': 'nvle',
        '\u2265': 'ge',
        '\u2271': 'nge',
        '\u2265⃒': 'nvge',
        '\u2266': 'lE',
        '\u2266̸': 'nlE',
        '\u2267': 'gE',
        '\u2267̸': 'ngE',
        '\u2268︀': 'lvnE',
        '\u2268': 'lnE',
        '\u2269': 'gnE',
        '\u2269︀': 'gvnE',
        '\u226A': 'll',
        '\u226A̸': 'nLtv',
        '\u226A⃒': 'nLt',
        '\u226B': 'gg',
        '\u226B̸': 'nGtv',
        '\u226B⃒': 'nGt',
        '\u226C': 'twixt',
        '\u2272': 'lsim',
        '\u2274': 'nlsim',
        '\u2273': 'gsim',
        '\u2275': 'ngsim',
        '\u2276': 'lg',
        '\u2278': 'ntlg',
        '\u2277': 'gl',
        '\u2279': 'ntgl',
        '\u227A': 'pr',
        '\u2280': 'npr',
        '\u227B': 'sc',
        '\u2281': 'nsc',
        '\u227C': 'prcue',
        '\u22E0': 'nprcue',
        '\u227D': 'sccue',
        '\u22E1': 'nsccue',
        '\u227E': 'prsim',
        '\u227F': 'scsim',
        '\u227F̸': 'NotSucceedsTilde',
        '\u2282': 'sub',
        '\u2284': 'nsub',
        '\u2282⃒': 'vnsub',
        '\u2283': 'sup',
        '\u2285': 'nsup',
        '\u2283⃒': 'vnsup',
        '\u2286': 'sube',
        '\u2288': 'nsube',
        '\u2287': 'supe',
        '\u2289': 'nsupe',
        '\u228A︀': 'vsubne',
        '\u228A': 'subne',
        '\u228B︀': 'vsupne',
        '\u228B': 'supne',
        '\u228D': 'cupdot',
        '\u228E': 'uplus',
        '\u228F': 'sqsub',
        '\u228F̸': 'NotSquareSubset',
        '\u2290': 'sqsup',
        '\u2290̸': 'NotSquareSuperset',
        '\u2291': 'sqsube',
        '\u22E2': 'nsqsube',
        '\u2292': 'sqsupe',
        '\u22E3': 'nsqsupe',
        '\u2293': 'sqcap',
        '\u2293︀': 'sqcaps',
        '\u2294': 'sqcup',
        '\u2294︀': 'sqcups',
        '\u2295': 'oplus',
        '\u2296': 'ominus',
        '\u2297': 'otimes',
        '\u2298': 'osol',
        '\u2299': 'odot',
        '\u229A': 'ocir',
        '\u229B': 'oast',
        '\u229D': 'odash',
        '\u229E': 'plusb',
        '\u229F': 'minusb',
        '\u22A0': 'timesb',
        '\u22A1': 'sdotb',
        '\u22A2': 'vdash',
        '\u22AC': 'nvdash',
        '\u22A3': 'dashv',
        '\u22A4': 'top',
        '\u22A5': 'bot',
        '\u22A7': 'models',
        '\u22A8': 'vDash',
        '\u22AD': 'nvDash',
        '\u22A9': 'Vdash',
        '\u22AE': 'nVdash',
        '\u22AA': 'Vvdash',
        '\u22AB': 'VDash',
        '\u22AF': 'nVDash',
        '\u22B0': 'prurel',
        '\u22B2': 'vltri',
        '\u22EA': 'nltri',
        '\u22B3': 'vrtri',
        '\u22EB': 'nrtri',
        '\u22B4': 'ltrie',
        '\u22EC': 'nltrie',
        '\u22B4⃒': 'nvltrie',
        '\u22B5': 'rtrie',
        '\u22ED': 'nrtrie',
        '\u22B5⃒': 'nvrtrie',
        '\u22B6': 'origof',
        '\u22B7': 'imof',
        '\u22B8': 'mumap',
        '\u22B9': 'hercon',
        '\u22BA': 'intcal',
        '\u22BB': 'veebar',
        '\u22BD': 'barvee',
        '\u22BE': 'angrtvb',
        '\u22BF': 'lrtri',
        '\u22C0': 'Wedge',
        '\u22C1': 'Vee',
        '\u22C2': 'xcap',
        '\u22C3': 'xcup',
        '\u22C4': 'diam',
        '\u22C5': 'sdot',
        '\u22C6': 'Star',
        '\u22C7': 'divonx',
        '\u22C8': 'bowtie',
        '\u22C9': 'ltimes',
        '\u22CA': 'rtimes',
        '\u22CB': 'lthree',
        '\u22CC': 'rthree',
        '\u22CD': 'bsime',
        '\u22CE': 'cuvee',
        '\u22CF': 'cuwed',
        '\u22D0': 'Sub',
        '\u22D1': 'Sup',
        '\u22D2': 'Cap',
        '\u22D3': 'Cup',
        '\u22D4': 'fork',
        '\u22D5': 'epar',
        '\u22D6': 'ltdot',
        '\u22D7': 'gtdot',
        '\u22D8': 'Ll',
        '\u22D8̸': 'nLl',
        '\u22D9': 'Gg',
        '\u22D9̸': 'nGg',
        '\u22DA︀': 'lesg',
        '\u22DA': 'leg',
        '\u22DB': 'gel',
        '\u22DB︀': 'gesl',
        '\u22DE': 'cuepr',
        '\u22DF': 'cuesc',
        '\u22E6': 'lnsim',
        '\u22E7': 'gnsim',
        '\u22E8': 'prnsim',
        '\u22E9': 'scnsim',
        '\u22EE': 'vellip',
        '\u22EF': 'ctdot',
        '\u22F0': 'utdot',
        '\u22F1': 'dtdot',
        '\u22F2': 'disin',
        '\u22F3': 'isinsv',
        '\u22F4': 'isins',
        '\u22F5': 'isindot',
        '\u22F5̸': 'notindot',
        '\u22F6': 'notinvc',
        '\u22F7': 'notinvb',
        '\u22F9': 'isinE',
        '\u22F9̸': 'notinE',
        '\u22FA': 'nisd',
        '\u22FB': 'xnis',
        '\u22FC': 'nis',
        '\u22FD': 'notnivc',
        '\u22FE': 'notnivb',
        '\u2305': 'barwed',
        '\u2306': 'Barwed',
        '\u230C': 'drcrop',
        '\u230D': 'dlcrop',
        '\u230E': 'urcrop',
        '\u230F': 'ulcrop',
        '\u2310': 'bnot',
        '\u2312': 'profline',
        '\u2313': 'profsurf',
        '\u2315': 'telrec',
        '\u2316': 'target',
        '\u231C': 'ulcorn',
        '\u231D': 'urcorn',
        '\u231E': 'dlcorn',
        '\u231F': 'drcorn',
        '\u2322': 'frown',
        '\u2323': 'smile',
        '\u232D': 'cylcty',
        '\u232E': 'profalar',
        '\u2336': 'topbot',
        '\u233D': 'ovbar',
        '\u233F': 'solbar',
        '\u237C': 'angzarr',
        '\u23B0': 'lmoust',
        '\u23B1': 'rmoust',
        '\u23B4': 'tbrk',
        '\u23B5': 'bbrk',
        '\u23B6': 'bbrktbrk',
        '\u23DC': 'OverParenthesis',
        '\u23DD': 'UnderParenthesis',
        '\u23DE': 'OverBrace',
        '\u23DF': 'UnderBrace',
        '\u23E2': 'trpezium',
        '\u23E7': 'elinters',
        '\u2423': 'blank',
        '\u2500': 'boxh',
        '\u2502': 'boxv',
        '\u250C': 'boxdr',
        '\u2510': 'boxdl',
        '\u2514': 'boxur',
        '\u2518': 'boxul',
        '\u251C': 'boxvr',
        '\u2524': 'boxvl',
        '\u252C': 'boxhd',
        '\u2534': 'boxhu',
        '\u253C': 'boxvh',
        '\u2550': 'boxH',
        '\u2551': 'boxV',
        '\u2552': 'boxdR',
        '\u2553': 'boxDr',
        '\u2554': 'boxDR',
        '\u2555': 'boxdL',
        '\u2556': 'boxDl',
        '\u2557': 'boxDL',
        '\u2558': 'boxuR',
        '\u2559': 'boxUr',
        '\u255A': 'boxUR',
        '\u255B': 'boxuL',
        '\u255C': 'boxUl',
        '\u255D': 'boxUL',
        '\u255E': 'boxvR',
        '\u255F': 'boxVr',
        '\u2560': 'boxVR',
        '\u2561': 'boxvL',
        '\u2562': 'boxVl',
        '\u2563': 'boxVL',
        '\u2564': 'boxHd',
        '\u2565': 'boxhD',
        '\u2566': 'boxHD',
        '\u2567': 'boxHu',
        '\u2568': 'boxhU',
        '\u2569': 'boxHU',
        '\u256A': 'boxvH',
        '\u256B': 'boxVh',
        '\u256C': 'boxVH',
        '\u2580': 'uhblk',
        '\u2584': 'lhblk',
        '\u2588': 'block',
        '\u2591': 'blk14',
        '\u2592': 'blk12',
        '\u2593': 'blk34',
        '\u25A1': 'squ',
        '\u25AA': 'squf',
        '\u25AB': 'EmptyVerySmallSquare',
        '\u25AD': 'rect',
        '\u25AE': 'marker',
        '\u25B1': 'fltns',
        '\u25B3': 'xutri',
        '\u25B4': 'utrif',
        '\u25B5': 'utri',
        '\u25B8': 'rtrif',
        '\u25B9': 'rtri',
        '\u25BD': 'xdtri',
        '\u25BE': 'dtrif',
        '\u25BF': 'dtri',
        '\u25C2': 'ltrif',
        '\u25C3': 'ltri',
        '\u25CA': 'loz',
        '\u25CB': 'cir',
        '\u25EC': 'tridot',
        '\u25EF': 'xcirc',
        '\u25F8': 'ultri',
        '\u25F9': 'urtri',
        '\u25FA': 'lltri',
        '\u25FB': 'EmptySmallSquare',
        '\u25FC': 'FilledSmallSquare',
        '\u2605': 'starf',
        '\u2606': 'star',
        '\u260E': 'phone',
        '\u2640': 'female',
        '\u2642': 'male',
        '\u2660': 'spades',
        '\u2663': 'clubs',
        '\u2665': 'hearts',
        '\u2666': 'diams',
        '\u266A': 'sung',
        '\u2713': 'check',
        '\u2717': 'cross',
        '\u2720': 'malt',
        '\u2736': 'sext',
        '\u2758': 'VerticalSeparator',
        '\u27C8': 'bsolhsub',
        '\u27C9': 'suphsol',
        '\u27F5': 'xlarr',
        '\u27F6': 'xrarr',
        '\u27F7': 'xharr',
        '\u27F8': 'xlArr',
        '\u27F9': 'xrArr',
        '\u27FA': 'xhArr',
        '\u27FC': 'xmap',
        '\u27FF': 'dzigrarr',
        '\u2902': 'nvlArr',
        '\u2903': 'nvrArr',
        '\u2904': 'nvHarr',
        '\u2905': 'Map',
        '\u290C': 'lbarr',
        '\u290D': 'rbarr',
        '\u290E': 'lBarr',
        '\u290F': 'rBarr',
        '\u2910': 'RBarr',
        '\u2911': 'DDotrahd',
        '\u2912': 'UpArrowBar',
        '\u2913': 'DownArrowBar',
        '\u2916': 'Rarrtl',
        '\u2919': 'latail',
        '\u291A': 'ratail',
        '\u291B': 'lAtail',
        '\u291C': 'rAtail',
        '\u291D': 'larrfs',
        '\u291E': 'rarrfs',
        '\u291F': 'larrbfs',
        '\u2920': 'rarrbfs',
        '\u2923': 'nwarhk',
        '\u2924': 'nearhk',
        '\u2925': 'searhk',
        '\u2926': 'swarhk',
        '\u2927': 'nwnear',
        '\u2928': 'toea',
        '\u2929': 'tosa',
        '\u292A': 'swnwar',
        '\u2933': 'rarrc',
        '\u2933̸': 'nrarrc',
        '\u2935': 'cudarrr',
        '\u2936': 'ldca',
        '\u2937': 'rdca',
        '\u2938': 'cudarrl',
        '\u2939': 'larrpl',
        '\u293C': 'curarrm',
        '\u293D': 'cularrp',
        '\u2945': 'rarrpl',
        '\u2948': 'harrcir',
        '\u2949': 'Uarrocir',
        '\u294A': 'lurdshar',
        '\u294B': 'ldrushar',
        '\u294E': 'LeftRightVector',
        '\u294F': 'RightUpDownVector',
        '\u2950': 'DownLeftRightVector',
        '\u2951': 'LeftUpDownVector',
        '\u2952': 'LeftVectorBar',
        '\u2953': 'RightVectorBar',
        '\u2954': 'RightUpVectorBar',
        '\u2955': 'RightDownVectorBar',
        '\u2956': 'DownLeftVectorBar',
        '\u2957': 'DownRightVectorBar',
        '\u2958': 'LeftUpVectorBar',
        '\u2959': 'LeftDownVectorBar',
        '\u295A': 'LeftTeeVector',
        '\u295B': 'RightTeeVector',
        '\u295C': 'RightUpTeeVector',
        '\u295D': 'RightDownTeeVector',
        '\u295E': 'DownLeftTeeVector',
        '\u295F': 'DownRightTeeVector',
        '\u2960': 'LeftUpTeeVector',
        '\u2961': 'LeftDownTeeVector',
        '\u2962': 'lHar',
        '\u2963': 'uHar',
        '\u2964': 'rHar',
        '\u2965': 'dHar',
        '\u2966': 'luruhar',
        '\u2967': 'ldrdhar',
        '\u2968': 'ruluhar',
        '\u2969': 'rdldhar',
        '\u296A': 'lharul',
        '\u296B': 'llhard',
        '\u296C': 'rharul',
        '\u296D': 'lrhard',
        '\u296E': 'udhar',
        '\u296F': 'duhar',
        '\u2970': 'RoundImplies',
        '\u2971': 'erarr',
        '\u2972': 'simrarr',
        '\u2973': 'larrsim',
        '\u2974': 'rarrsim',
        '\u2975': 'rarrap',
        '\u2976': 'ltlarr',
        '\u2978': 'gtrarr',
        '\u2979': 'subrarr',
        '\u297B': 'suplarr',
        '\u297C': 'lfisht',
        '\u297D': 'rfisht',
        '\u297E': 'ufisht',
        '\u297F': 'dfisht',
        '\u299A': 'vzigzag',
        '\u299C': 'vangrt',
        '\u299D': 'angrtvbd',
        '\u29A4': 'ange',
        '\u29A5': 'range',
        '\u29A6': 'dwangle',
        '\u29A7': 'uwangle',
        '\u29A8': 'angmsdaa',
        '\u29A9': 'angmsdab',
        '\u29AA': 'angmsdac',
        '\u29AB': 'angmsdad',
        '\u29AC': 'angmsdae',
        '\u29AD': 'angmsdaf',
        '\u29AE': 'angmsdag',
        '\u29AF': 'angmsdah',
        '\u29B0': 'bemptyv',
        '\u29B1': 'demptyv',
        '\u29B2': 'cemptyv',
        '\u29B3': 'raemptyv',
        '\u29B4': 'laemptyv',
        '\u29B5': 'ohbar',
        '\u29B6': 'omid',
        '\u29B7': 'opar',
        '\u29B9': 'operp',
        '\u29BB': 'olcross',
        '\u29BC': 'odsold',
        '\u29BE': 'olcir',
        '\u29BF': 'ofcir',
        '\u29C0': 'olt',
        '\u29C1': 'ogt',
        '\u29C2': 'cirscir',
        '\u29C3': 'cirE',
        '\u29C4': 'solb',
        '\u29C5': 'bsolb',
        '\u29C9': 'boxbox',
        '\u29CD': 'trisb',
        '\u29CE': 'rtriltri',
        '\u29CF': 'LeftTriangleBar',
        '\u29CF̸': 'NotLeftTriangleBar',
        '\u29D0': 'RightTriangleBar',
        '\u29D0̸': 'NotRightTriangleBar',
        '\u29DC': 'iinfin',
        '\u29DD': 'infintie',
        '\u29DE': 'nvinfin',
        '\u29E3': 'eparsl',
        '\u29E4': 'smeparsl',
        '\u29E5': 'eqvparsl',
        '\u29EB': 'lozf',
        '\u29F4': 'RuleDelayed',
        '\u29F6': 'dsol',
        '\u2A00': 'xodot',
        '\u2A01': 'xoplus',
        '\u2A02': 'xotime',
        '\u2A04': 'xuplus',
        '\u2A06': 'xsqcup',
        '\u2A0D': 'fpartint',
        '\u2A10': 'cirfnint',
        '\u2A11': 'awint',
        '\u2A12': 'rppolint',
        '\u2A13': 'scpolint',
        '\u2A14': 'npolint',
        '\u2A15': 'pointint',
        '\u2A16': 'quatint',
        '\u2A17': 'intlarhk',
        '\u2A22': 'pluscir',
        '\u2A23': 'plusacir',
        '\u2A24': 'simplus',
        '\u2A25': 'plusdu',
        '\u2A26': 'plussim',
        '\u2A27': 'plustwo',
        '\u2A29': 'mcomma',
        '\u2A2A': 'minusdu',
        '\u2A2D': 'loplus',
        '\u2A2E': 'roplus',
        '\u2A2F': 'Cross',
        '\u2A30': 'timesd',
        '\u2A31': 'timesbar',
        '\u2A33': 'smashp',
        '\u2A34': 'lotimes',
        '\u2A35': 'rotimes',
        '\u2A36': 'otimesas',
        '\u2A37': 'Otimes',
        '\u2A38': 'odiv',
        '\u2A39': 'triplus',
        '\u2A3A': 'triminus',
        '\u2A3B': 'tritime',
        '\u2A3C': 'iprod',
        '\u2A3F': 'amalg',
        '\u2A40': 'capdot',
        '\u2A42': 'ncup',
        '\u2A43': 'ncap',
        '\u2A44': 'capand',
        '\u2A45': 'cupor',
        '\u2A46': 'cupcap',
        '\u2A47': 'capcup',
        '\u2A48': 'cupbrcap',
        '\u2A49': 'capbrcup',
        '\u2A4A': 'cupcup',
        '\u2A4B': 'capcap',
        '\u2A4C': 'ccups',
        '\u2A4D': 'ccaps',
        '\u2A50': 'ccupssm',
        '\u2A53': 'And',
        '\u2A54': 'Or',
        '\u2A55': 'andand',
        '\u2A56': 'oror',
        '\u2A57': 'orslope',
        '\u2A58': 'andslope',
        '\u2A5A': 'andv',
        '\u2A5B': 'orv',
        '\u2A5C': 'andd',
        '\u2A5D': 'ord',
        '\u2A5F': 'wedbar',
        '\u2A66': 'sdote',
        '\u2A6A': 'simdot',
        '\u2A6D': 'congdot',
        '\u2A6D̸': 'ncongdot',
        '\u2A6E': 'easter',
        '\u2A6F': 'apacir',
        '\u2A70': 'apE',
        '\u2A70̸': 'napE',
        '\u2A71': 'eplus',
        '\u2A72': 'pluse',
        '\u2A73': 'Esim',
        '\u2A77': 'eDDot',
        '\u2A78': 'equivDD',
        '\u2A79': 'ltcir',
        '\u2A7A': 'gtcir',
        '\u2A7B': 'ltquest',
        '\u2A7C': 'gtquest',
        '\u2A7D': 'les',
        '\u2A7D̸': 'nles',
        '\u2A7E': 'ges',
        '\u2A7E̸': 'nges',
        '\u2A7F': 'lesdot',
        '\u2A80': 'gesdot',
        '\u2A81': 'lesdoto',
        '\u2A82': 'gesdoto',
        '\u2A83': 'lesdotor',
        '\u2A84': 'gesdotol',
        '\u2A85': 'lap',
        '\u2A86': 'gap',
        '\u2A87': 'lne',
        '\u2A88': 'gne',
        '\u2A89': 'lnap',
        '\u2A8A': 'gnap',
        '\u2A8B': 'lEg',
        '\u2A8C': 'gEl',
        '\u2A8D': 'lsime',
        '\u2A8E': 'gsime',
        '\u2A8F': 'lsimg',
        '\u2A90': 'gsiml',
        '\u2A91': 'lgE',
        '\u2A92': 'glE',
        '\u2A93': 'lesges',
        '\u2A94': 'gesles',
        '\u2A95': 'els',
        '\u2A96': 'egs',
        '\u2A97': 'elsdot',
        '\u2A98': 'egsdot',
        '\u2A99': 'el',
        '\u2A9A': 'eg',
        '\u2A9D': 'siml',
        '\u2A9E': 'simg',
        '\u2A9F': 'simlE',
        '\u2AA0': 'simgE',
        '\u2AA1': 'LessLess',
        '\u2AA1̸': 'NotNestedLessLess',
        '\u2AA2': 'GreaterGreater',
        '\u2AA2̸': 'NotNestedGreaterGreater',
        '\u2AA4': 'glj',
        '\u2AA5': 'gla',
        '\u2AA6': 'ltcc',
        '\u2AA7': 'gtcc',
        '\u2AA8': 'lescc',
        '\u2AA9': 'gescc',
        '\u2AAA': 'smt',
        '\u2AAB': 'lat',
        '\u2AAC': 'smte',
        '\u2AAC︀': 'smtes',
        '\u2AAD': 'late',
        '\u2AAD︀': 'lates',
        '\u2AAE': 'bumpE',
        '\u2AAF': 'pre',
        '\u2AAF̸': 'npre',
        '\u2AB0': 'sce',
        '\u2AB0̸': 'nsce',
        '\u2AB3': 'prE',
        '\u2AB4': 'scE',
        '\u2AB5': 'prnE',
        '\u2AB6': 'scnE',
        '\u2AB7': 'prap',
        '\u2AB8': 'scap',
        '\u2AB9': 'prnap',
        '\u2ABA': 'scnap',
        '\u2ABB': 'Pr',
        '\u2ABC': 'Sc',
        '\u2ABD': 'subdot',
        '\u2ABE': 'supdot',
        '\u2ABF': 'subplus',
        '\u2AC0': 'supplus',
        '\u2AC1': 'submult',
        '\u2AC2': 'supmult',
        '\u2AC3': 'subedot',
        '\u2AC4': 'supedot',
        '\u2AC5': 'subE',
        '\u2AC5̸': 'nsubE',
        '\u2AC6': 'supE',
        '\u2AC6̸': 'nsupE',
        '\u2AC7': 'subsim',
        '\u2AC8': 'supsim',
        '\u2ACB︀': 'vsubnE',
        '\u2ACB': 'subnE',
        '\u2ACC︀': 'vsupnE',
        '\u2ACC': 'supnE',
        '\u2ACF': 'csub',
        '\u2AD0': 'csup',
        '\u2AD1': 'csube',
        '\u2AD2': 'csupe',
        '\u2AD3': 'subsup',
        '\u2AD4': 'supsub',
        '\u2AD5': 'subsub',
        '\u2AD6': 'supsup',
        '\u2AD7': 'suphsub',
        '\u2AD8': 'supdsub',
        '\u2AD9': 'forkv',
        '\u2ADA': 'topfork',
        '\u2ADB': 'mlcp',
        '\u2AE4': 'Dashv',
        '\u2AE6': 'Vdashl',
        '\u2AE7': 'Barv',
        '\u2AE8': 'vBar',
        '\u2AE9': 'vBarv',
        '\u2AEB': 'Vbar',
        '\u2AEC': 'Not',
        '\u2AED': 'bNot',
        '\u2AEE': 'rnmid',
        '\u2AEF': 'cirmid',
        '\u2AF0': 'midcir',
        '\u2AF1': 'topcir',
        '\u2AF2': 'nhpar',
        '\u2AF3': 'parsim',
        '\u2AFD': 'parsl',
        '\u2AFD⃥': 'nparsl',
        '\u266D': 'flat',
        '\u266E': 'natur',
        '\u266F': 'sharp',
        '\xA4': 'curren',
        '\xA2': 'cent',
        '$': 'dollar',
        '\xA3': 'pound',
        '\xA5': 'yen',
        '\u20AC': 'euro',
        '\xB9': 'sup1',
        '\xBD': 'half',
        '\u2153': 'frac13',
        '\xBC': 'frac14',
        '\u2155': 'frac15',
        '\u2159': 'frac16',
        '\u215B': 'frac18',
        '\xB2': 'sup2',
        '\u2154': 'frac23',
        '\u2156': 'frac25',
        '\xB3': 'sup3',
        '\xBE': 'frac34',
        '\u2157': 'frac35',
        '\u215C': 'frac38',
        '\u2158': 'frac45',
        '\u215A': 'frac56',
        '\u215D': 'frac58',
        '\u215E': 'frac78',
        '\uD835\uDCB6': 'ascr',
        '\uD835\uDD52': 'aopf',
        '\uD835\uDD1E': 'afr',
        '\uD835\uDD38': 'Aopf',
        '\uD835\uDD04': 'Afr',
        '\uD835\uDC9C': 'Ascr',
        'ª': 'ordf',
        'á': 'aacute',
        'Á': 'Aacute',
        'à': 'agrave',
        'À': 'Agrave',
        'ă': 'abreve',
        'Ă': 'Abreve',
        'â': 'acirc',
        'Â': 'Acirc',
        'å': 'aring',
        'Å': 'angst',
        'ä': 'auml',
        'Ä': 'Auml',
        'ã': 'atilde',
        'Ã': 'Atilde',
        'ą': 'aogon',
        'Ą': 'Aogon',
        'ā': 'amacr',
        'Ā': 'Amacr',
        'æ': 'aelig',
        'Æ': 'AElig',
        '\uD835\uDCB7': 'bscr',
        '\uD835\uDD53': 'bopf',
        '\uD835\uDD1F': 'bfr',
        '\uD835\uDD39': 'Bopf',
        'ℬ': 'Bscr',
        '\uD835\uDD05': 'Bfr',
        '\uD835\uDD20': 'cfr',
        '\uD835\uDCB8': 'cscr',
        '\uD835\uDD54': 'copf',
        'ℭ': 'Cfr',
        '\uD835\uDC9E': 'Cscr',
        'ℂ': 'Copf',
        'ć': 'cacute',
        'Ć': 'Cacute',
        'ĉ': 'ccirc',
        'Ĉ': 'Ccirc',
        'č': 'ccaron',
        'Č': 'Ccaron',
        'ċ': 'cdot',
        'Ċ': 'Cdot',
        'ç': 'ccedil',
        'Ç': 'Ccedil',
        '\u2105': 'incare',
        '\uD835\uDD21': 'dfr',
        'ⅆ': 'dd',
        '\uD835\uDD55': 'dopf',
        '\uD835\uDCB9': 'dscr',
        '\uD835\uDC9F': 'Dscr',
        '\uD835\uDD07': 'Dfr',
        'ⅅ': 'DD',
        '\uD835\uDD3B': 'Dopf',
        'ď': 'dcaron',
        'Ď': 'Dcaron',
        'đ': 'dstrok',
        'Đ': 'Dstrok',
        'ð': 'eth',
        'Ð': 'ETH',
        'ⅇ': 'ee',
        'ℯ': 'escr',
        '\uD835\uDD22': 'efr',
        '\uD835\uDD56': 'eopf',
        'ℰ': 'Escr',
        '\uD835\uDD08': 'Efr',
        '\uD835\uDD3C': 'Eopf',
        'é': 'eacute',
        'É': 'Eacute',
        'è': 'egrave',
        'È': 'Egrave',
        'ê': 'ecirc',
        'Ê': 'Ecirc',
        'ě': 'ecaron',
        'Ě': 'Ecaron',
        'ë': 'euml',
        'Ë': 'Euml',
        'ė': 'edot',
        'Ė': 'Edot',
        'ę': 'eogon',
        'Ę': 'Eogon',
        'ē': 'emacr',
        'Ē': 'Emacr',
        '\uD835\uDD23': 'ffr',
        '\uD835\uDD57': 'fopf',
        '\uD835\uDCBB': 'fscr',
        '\uD835\uDD09': 'Ffr',
        '\uD835\uDD3D': 'Fopf',
        'ℱ': 'Fscr',
        'ﬀ': 'fflig',
        'ﬃ': 'ffilig',
        'ﬄ': 'ffllig',
        'ﬁ': 'filig',
        'fj': 'fjlig',
        'ﬂ': 'fllig',
        'ƒ': 'fnof',
        'ℊ': 'gscr',
        '\uD835\uDD58': 'gopf',
        '\uD835\uDD24': 'gfr',
        '\uD835\uDCA2': 'Gscr',
        '\uD835\uDD3E': 'Gopf',
        '\uD835\uDD0A': 'Gfr',
        'ǵ': 'gacute',
        'ğ': 'gbreve',
        'Ğ': 'Gbreve',
        'ĝ': 'gcirc',
        'Ĝ': 'Gcirc',
        'ġ': 'gdot',
        'Ġ': 'Gdot',
        'Ģ': 'Gcedil',
        '\uD835\uDD25': 'hfr',
        'ℎ': 'planckh',
        '\uD835\uDCBD': 'hscr',
        '\uD835\uDD59': 'hopf',
        'ℋ': 'Hscr',
        'ℌ': 'Hfr',
        'ℍ': 'Hopf',
        'ĥ': 'hcirc',
        'Ĥ': 'Hcirc',
        'ℏ': 'hbar',
        'ħ': 'hstrok',
        'Ħ': 'Hstrok',
        '\uD835\uDD5A': 'iopf',
        '\uD835\uDD26': 'ifr',
        '\uD835\uDCBE': 'iscr',
        'ⅈ': 'ii',
        '\uD835\uDD40': 'Iopf',
        'ℐ': 'Iscr',
        'ℑ': 'Im',
        'í': 'iacute',
        'Í': 'Iacute',
        'ì': 'igrave',
        'Ì': 'Igrave',
        'î': 'icirc',
        'Î': 'Icirc',
        'ï': 'iuml',
        'Ï': 'Iuml',
        'ĩ': 'itilde',
        'Ĩ': 'Itilde',
        'İ': 'Idot',
        'į': 'iogon',
        'Į': 'Iogon',
        'ī': 'imacr',
        'Ī': 'Imacr',
        'ĳ': 'ijlig',
        'Ĳ': 'IJlig',
        'ı': 'imath',
        '\uD835\uDCBF': 'jscr',
        '\uD835\uDD5B': 'jopf',
        '\uD835\uDD27': 'jfr',
        '\uD835\uDCA5': 'Jscr',
        '\uD835\uDD0D': 'Jfr',
        '\uD835\uDD41': 'Jopf',
        'ĵ': 'jcirc',
        'Ĵ': 'Jcirc',
        'ȷ': 'jmath',
        '\uD835\uDD5C': 'kopf',
        '\uD835\uDCC0': 'kscr',
        '\uD835\uDD28': 'kfr',
        '\uD835\uDCA6': 'Kscr',
        '\uD835\uDD42': 'Kopf',
        '\uD835\uDD0E': 'Kfr',
        'ķ': 'kcedil',
        'Ķ': 'Kcedil',
        '\uD835\uDD29': 'lfr',
        '\uD835\uDCC1': 'lscr',
        'ℓ': 'ell',
        '\uD835\uDD5D': 'lopf',
        'ℒ': 'Lscr',
        '\uD835\uDD0F': 'Lfr',
        '\uD835\uDD43': 'Lopf',
        'ĺ': 'lacute',
        'Ĺ': 'Lacute',
        'ľ': 'lcaron',
        'Ľ': 'Lcaron',
        'ļ': 'lcedil',
        'Ļ': 'Lcedil',
        'ł': 'lstrok',
        'Ł': 'Lstrok',
        'ŀ': 'lmidot',
        'Ŀ': 'Lmidot',
        '\uD835\uDD2A': 'mfr',
        '\uD835\uDD5E': 'mopf',
        '\uD835\uDCC2': 'mscr',
        '\uD835\uDD10': 'Mfr',
        '\uD835\uDD44': 'Mopf',
        'ℳ': 'Mscr',
        '\uD835\uDD2B': 'nfr',
        '\uD835\uDD5F': 'nopf',
        '\uD835\uDCC3': 'nscr',
        'ℕ': 'Nopf',
        '\uD835\uDCA9': 'Nscr',
        '\uD835\uDD11': 'Nfr',
        'ń': 'nacute',
        'Ń': 'Nacute',
        'ň': 'ncaron',
        'Ň': 'Ncaron',
        'ñ': 'ntilde',
        'Ñ': 'Ntilde',
        'ņ': 'ncedil',
        'Ņ': 'Ncedil',
        '\u2116': 'numero',
        'ŋ': 'eng',
        'Ŋ': 'ENG',
        '\uD835\uDD60': 'oopf',
        '\uD835\uDD2C': 'ofr',
        'ℴ': 'oscr',
        '\uD835\uDCAA': 'Oscr',
        '\uD835\uDD12': 'Ofr',
        '\uD835\uDD46': 'Oopf',
        'º': 'ordm',
        'ó': 'oacute',
        'Ó': 'Oacute',
        'ò': 'ograve',
        'Ò': 'Ograve',
        'ô': 'ocirc',
        'Ô': 'Ocirc',
        'ö': 'ouml',
        'Ö': 'Ouml',
        'ő': 'odblac',
        'Ő': 'Odblac',
        'õ': 'otilde',
        'Õ': 'Otilde',
        'ø': 'oslash',
        'Ø': 'Oslash',
        'ō': 'omacr',
        'Ō': 'Omacr',
        'œ': 'oelig',
        'Œ': 'OElig',
        '\uD835\uDD2D': 'pfr',
        '\uD835\uDCC5': 'pscr',
        '\uD835\uDD61': 'popf',
        'ℙ': 'Popf',
        '\uD835\uDD13': 'Pfr',
        '\uD835\uDCAB': 'Pscr',
        '\uD835\uDD62': 'qopf',
        '\uD835\uDD2E': 'qfr',
        '\uD835\uDCC6': 'qscr',
        '\uD835\uDCAC': 'Qscr',
        '\uD835\uDD14': 'Qfr',
        'ℚ': 'Qopf',
        'ĸ': 'kgreen',
        '\uD835\uDD2F': 'rfr',
        '\uD835\uDD63': 'ropf',
        '\uD835\uDCC7': 'rscr',
        'ℛ': 'Rscr',
        'ℜ': 'Re',
        'ℝ': 'Ropf',
        'ŕ': 'racute',
        'Ŕ': 'Racute',
        'ř': 'rcaron',
        'Ř': 'Rcaron',
        'ŗ': 'rcedil',
        'Ŗ': 'Rcedil',
        '\uD835\uDD64': 'sopf',
        '\uD835\uDCC8': 'sscr',
        '\uD835\uDD30': 'sfr',
        '\uD835\uDD4A': 'Sopf',
        '\uD835\uDD16': 'Sfr',
        '\uD835\uDCAE': 'Sscr',
        '\u24C8': 'oS',
        'ś': 'sacute',
        'Ś': 'Sacute',
        'ŝ': 'scirc',
        'Ŝ': 'Scirc',
        'š': 'scaron',
        'Š': 'Scaron',
        'ş': 'scedil',
        'Ş': 'Scedil',
        'ß': 'szlig',
        '\uD835\uDD31': 'tfr',
        '\uD835\uDCC9': 'tscr',
        '\uD835\uDD65': 'topf',
        '\uD835\uDCAF': 'Tscr',
        '\uD835\uDD17': 'Tfr',
        '\uD835\uDD4B': 'Topf',
        'ť': 'tcaron',
        'Ť': 'Tcaron',
        'ţ': 'tcedil',
        'Ţ': 'Tcedil',
        '\u2122': 'trade',
        'ŧ': 'tstrok',
        'Ŧ': 'Tstrok',
        '\uD835\uDCCA': 'uscr',
        '\uD835\uDD66': 'uopf',
        '\uD835\uDD32': 'ufr',
        '\uD835\uDD4C': 'Uopf',
        '\uD835\uDD18': 'Ufr',
        '\uD835\uDCB0': 'Uscr',
        'ú': 'uacute',
        'Ú': 'Uacute',
        'ù': 'ugrave',
        'Ù': 'Ugrave',
        'ŭ': 'ubreve',
        'Ŭ': 'Ubreve',
        'û': 'ucirc',
        'Û': 'Ucirc',
        'ů': 'uring',
        'Ů': 'Uring',
        'ü': 'uuml',
        'Ü': 'Uuml',
        'ű': 'udblac',
        'Ű': 'Udblac',
        'ũ': 'utilde',
        'Ũ': 'Utilde',
        'ų': 'uogon',
        'Ų': 'Uogon',
        'ū': 'umacr',
        'Ū': 'Umacr',
        '\uD835\uDD33': 'vfr',
        '\uD835\uDD67': 'vopf',
        '\uD835\uDCCB': 'vscr',
        '\uD835\uDD19': 'Vfr',
        '\uD835\uDD4D': 'Vopf',
        '\uD835\uDCB1': 'Vscr',
        '\uD835\uDD68': 'wopf',
        '\uD835\uDCCC': 'wscr',
        '\uD835\uDD34': 'wfr',
        '\uD835\uDCB2': 'Wscr',
        '\uD835\uDD4E': 'Wopf',
        '\uD835\uDD1A': 'Wfr',
        'ŵ': 'wcirc',
        'Ŵ': 'Wcirc',
        '\uD835\uDD35': 'xfr',
        '\uD835\uDCCD': 'xscr',
        '\uD835\uDD69': 'xopf',
        '\uD835\uDD4F': 'Xopf',
        '\uD835\uDD1B': 'Xfr',
        '\uD835\uDCB3': 'Xscr',
        '\uD835\uDD36': 'yfr',
        '\uD835\uDCCE': 'yscr',
        '\uD835\uDD6A': 'yopf',
        '\uD835\uDCB4': 'Yscr',
        '\uD835\uDD1C': 'Yfr',
        '\uD835\uDD50': 'Yopf',
        'ý': 'yacute',
        'Ý': 'Yacute',
        'ŷ': 'ycirc',
        'Ŷ': 'Ycirc',
        'ÿ': 'yuml',
        'Ÿ': 'Yuml',
        '\uD835\uDCCF': 'zscr',
        '\uD835\uDD37': 'zfr',
        '\uD835\uDD6B': 'zopf',
        'ℨ': 'Zfr',
        'ℤ': 'Zopf',
        '\uD835\uDCB5': 'Zscr',
        'ź': 'zacute',
        'Ź': 'Zacute',
        'ž': 'zcaron',
        'Ž': 'Zcaron',
        'ż': 'zdot',
        'Ż': 'Zdot',
        'Ƶ': 'imped',
        'þ': 'thorn',
        'Þ': 'THORN',
        'ŉ': 'napos',
        'α': 'alpha',
        'Α': 'Alpha',
        'β': 'beta',
        'Β': 'Beta',
        'γ': 'gamma',
        'Γ': 'Gamma',
        'δ': 'delta',
        'Δ': 'Delta',
        'ε': 'epsi',
        'ϵ': 'epsiv',
        'Ε': 'Epsilon',
        'ϝ': 'gammad',
        'Ϝ': 'Gammad',
        'ζ': 'zeta',
        'Ζ': 'Zeta',
        'η': 'eta',
        'Η': 'Eta',
        'θ': 'theta',
        'ϑ': 'thetav',
        'Θ': 'Theta',
        'ι': 'iota',
        'Ι': 'Iota',
        'κ': 'kappa',
        'ϰ': 'kappav',
        'Κ': 'Kappa',
        'λ': 'lambda',
        'Λ': 'Lambda',
        'μ': 'mu',
        'µ': 'micro',
        'Μ': 'Mu',
        'ν': 'nu',
        'Ν': 'Nu',
        'ξ': 'xi',
        'Ξ': 'Xi',
        'ο': 'omicron',
        'Ο': 'Omicron',
        'π': 'pi',
        'ϖ': 'piv',
        'Π': 'Pi',
        'ρ': 'rho',
        'ϱ': 'rhov',
        'Ρ': 'Rho',
        'σ': 'sigma',
        'Σ': 'Sigma',
        'ς': 'sigmaf',
        'τ': 'tau',
        'Τ': 'Tau',
        'υ': 'upsi',
        'Υ': 'Upsilon',
        'ϒ': 'Upsi',
        'φ': 'phi',
        'ϕ': 'phiv',
        'Φ': 'Phi',
        'χ': 'chi',
        'Χ': 'Chi',
        'ψ': 'psi',
        'Ψ': 'Psi',
        'ω': 'omega',
        'Ω': 'ohm',
        'а': 'acy',
        'А': 'Acy',
        'б': 'bcy',
        'Б': 'Bcy',
        'в': 'vcy',
        'В': 'Vcy',
        'г': 'gcy',
        'Г': 'Gcy',
        'ѓ': 'gjcy',
        'Ѓ': 'GJcy',
        'д': 'dcy',
        'Д': 'Dcy',
        'ђ': 'djcy',
        'Ђ': 'DJcy',
        'е': 'iecy',
        'Е': 'IEcy',
        'ё': 'iocy',
        'Ё': 'IOcy',
        'є': 'jukcy',
        'Є': 'Jukcy',
        'ж': 'zhcy',
        'Ж': 'ZHcy',
        'з': 'zcy',
        'З': 'Zcy',
        'ѕ': 'dscy',
        'Ѕ': 'DScy',
        'и': 'icy',
        'И': 'Icy',
        'і': 'iukcy',
        'І': 'Iukcy',
        'ї': 'yicy',
        'Ї': 'YIcy',
        'й': 'jcy',
        'Й': 'Jcy',
        'ј': 'jsercy',
        'Ј': 'Jsercy',
        'к': 'kcy',
        'К': 'Kcy',
        'ќ': 'kjcy',
        'Ќ': 'KJcy',
        'л': 'lcy',
        'Л': 'Lcy',
        'љ': 'ljcy',
        'Љ': 'LJcy',
        'м': 'mcy',
        'М': 'Mcy',
        'н': 'ncy',
        'Н': 'Ncy',
        'њ': 'njcy',
        'Њ': 'NJcy',
        'о': 'ocy',
        'О': 'Ocy',
        'п': 'pcy',
        'П': 'Pcy',
        'р': 'rcy',
        'Р': 'Rcy',
        'с': 'scy',
        'С': 'Scy',
        'т': 'tcy',
        'Т': 'Tcy',
        'ћ': 'tshcy',
        'Ћ': 'TSHcy',
        'у': 'ucy',
        'У': 'Ucy',
        'ў': 'ubrcy',
        'Ў': 'Ubrcy',
        'ф': 'fcy',
        'Ф': 'Fcy',
        'х': 'khcy',
        'Х': 'KHcy',
        'ц': 'tscy',
        'Ц': 'TScy',
        'ч': 'chcy',
        'Ч': 'CHcy',
        'џ': 'dzcy',
        'Џ': 'DZcy',
        'ш': 'shcy',
        'Ш': 'SHcy',
        'щ': 'shchcy',
        'Щ': 'SHCHcy',
        'ъ': 'hardcy',
        'Ъ': 'HARDcy',
        'ы': 'ycy',
        'Ы': 'Ycy',
        'ь': 'softcy',
        'Ь': 'SOFTcy',
        'э': 'ecy',
        'Э': 'Ecy',
        'ю': 'yucy',
        'Ю': 'YUcy',
        'я': 'yacy',
        'Я': 'YAcy',
        'ℵ': 'aleph',
        'ℶ': 'beth',
        'ℷ': 'gimel',
        'ℸ': 'daleth'
    };
    var regexEscape = /["&'<>`]/g;
    var escapeMap = {
        '"': '&quot;',
        '&': '&amp;',
        '\'': '&#x27;',
        '<': '&lt;',
        '>': '&gt;',
        '`': '&#x60;'
    };
    var regexInvalidEntity = /&#(?:[xX][^a-fA-F0-9]|[^0-9xX])/;
    var regexInvalidRawCodePoint = /[\0-\x08\x0B\x0E-\x1F\x7F-\x9F\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
    var regexDecode = /&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)([=a-zA-Z0-9])?/g;
    var decodeMap = {
        'aacute': 'á',
        'Aacute': 'Á',
        'abreve': 'ă',
        'Abreve': 'Ă',
        'ac': '\u223E',
        'acd': '\u223F',
        'acE': '\u223E̳',
        'acirc': 'â',
        'Acirc': 'Â',
        'acute': '\xB4',
        'acy': 'а',
        'Acy': 'А',
        'aelig': 'æ',
        'AElig': 'Æ',
        'af': '\u2061',
        'afr': '\uD835\uDD1E',
        'Afr': '\uD835\uDD04',
        'agrave': 'à',
        'Agrave': 'À',
        'alefsym': 'ℵ',
        'aleph': 'ℵ',
        'alpha': 'α',
        'Alpha': 'Α',
        'amacr': 'ā',
        'Amacr': 'Ā',
        'amalg': '\u2A3F',
        'amp': '&',
        'AMP': '&',
        'and': '\u2227',
        'And': '\u2A53',
        'andand': '\u2A55',
        'andd': '\u2A5C',
        'andslope': '\u2A58',
        'andv': '\u2A5A',
        'ang': '\u2220',
        'ange': '\u29A4',
        'angle': '\u2220',
        'angmsd': '\u2221',
        'angmsdaa': '\u29A8',
        'angmsdab': '\u29A9',
        'angmsdac': '\u29AA',
        'angmsdad': '\u29AB',
        'angmsdae': '\u29AC',
        'angmsdaf': '\u29AD',
        'angmsdag': '\u29AE',
        'angmsdah': '\u29AF',
        'angrt': '\u221F',
        'angrtvb': '\u22BE',
        'angrtvbd': '\u299D',
        'angsph': '\u2222',
        'angst': 'Å',
        'angzarr': '\u237C',
        'aogon': 'ą',
        'Aogon': 'Ą',
        'aopf': '\uD835\uDD52',
        'Aopf': '\uD835\uDD38',
        'ap': '\u2248',
        'apacir': '\u2A6F',
        'ape': '\u224A',
        'apE': '\u2A70',
        'apid': '\u224B',
        'apos': '\'',
        'ApplyFunction': '\u2061',
        'approx': '\u2248',
        'approxeq': '\u224A',
        'aring': 'å',
        'Aring': 'Å',
        'ascr': '\uD835\uDCB6',
        'Ascr': '\uD835\uDC9C',
        'Assign': '\u2254',
        'ast': '*',
        'asymp': '\u2248',
        'asympeq': '\u224D',
        'atilde': 'ã',
        'Atilde': 'Ã',
        'auml': 'ä',
        'Auml': 'Ä',
        'awconint': '\u2233',
        'awint': '\u2A11',
        'backcong': '\u224C',
        'backepsilon': '\u03F6',
        'backprime': '\u2035',
        'backsim': '\u223D',
        'backsimeq': '\u22CD',
        'Backslash': '\u2216',
        'Barv': '\u2AE7',
        'barvee': '\u22BD',
        'barwed': '\u2305',
        'Barwed': '\u2306',
        'barwedge': '\u2305',
        'bbrk': '\u23B5',
        'bbrktbrk': '\u23B6',
        'bcong': '\u224C',
        'bcy': 'б',
        'Bcy': 'Б',
        'bdquo': '\u201E',
        'becaus': '\u2235',
        'because': '\u2235',
        'Because': '\u2235',
        'bemptyv': '\u29B0',
        'bepsi': '\u03F6',
        'bernou': 'ℬ',
        'Bernoullis': 'ℬ',
        'beta': 'β',
        'Beta': 'Β',
        'beth': 'ℶ',
        'between': '\u226C',
        'bfr': '\uD835\uDD1F',
        'Bfr': '\uD835\uDD05',
        'bigcap': '\u22C2',
        'bigcirc': '\u25EF',
        'bigcup': '\u22C3',
        'bigodot': '\u2A00',
        'bigoplus': '\u2A01',
        'bigotimes': '\u2A02',
        'bigsqcup': '\u2A06',
        'bigstar': '\u2605',
        'bigtriangledown': '\u25BD',
        'bigtriangleup': '\u25B3',
        'biguplus': '\u2A04',
        'bigvee': '\u22C1',
        'bigwedge': '\u22C0',
        'bkarow': '\u290D',
        'blacklozenge': '\u29EB',
        'blacksquare': '\u25AA',
        'blacktriangle': '\u25B4',
        'blacktriangledown': '\u25BE',
        'blacktriangleleft': '\u25C2',
        'blacktriangleright': '\u25B8',
        'blank': '\u2423',
        'blk12': '\u2592',
        'blk14': '\u2591',
        'blk34': '\u2593',
        'block': '\u2588',
        'bne': '=⃥',
        'bnequiv': '\u2261⃥',
        'bnot': '\u2310',
        'bNot': '\u2AED',
        'bopf': '\uD835\uDD53',
        'Bopf': '\uD835\uDD39',
        'bot': '\u22A5',
        'bottom': '\u22A5',
        'bowtie': '\u22C8',
        'boxbox': '\u29C9',
        'boxdl': '\u2510',
        'boxdL': '\u2555',
        'boxDl': '\u2556',
        'boxDL': '\u2557',
        'boxdr': '\u250C',
        'boxdR': '\u2552',
        'boxDr': '\u2553',
        'boxDR': '\u2554',
        'boxh': '\u2500',
        'boxH': '\u2550',
        'boxhd': '\u252C',
        'boxhD': '\u2565',
        'boxHd': '\u2564',
        'boxHD': '\u2566',
        'boxhu': '\u2534',
        'boxhU': '\u2568',
        'boxHu': '\u2567',
        'boxHU': '\u2569',
        'boxminus': '\u229F',
        'boxplus': '\u229E',
        'boxtimes': '\u22A0',
        'boxul': '\u2518',
        'boxuL': '\u255B',
        'boxUl': '\u255C',
        'boxUL': '\u255D',
        'boxur': '\u2514',
        'boxuR': '\u2558',
        'boxUr': '\u2559',
        'boxUR': '\u255A',
        'boxv': '\u2502',
        'boxV': '\u2551',
        'boxvh': '\u253C',
        'boxvH': '\u256A',
        'boxVh': '\u256B',
        'boxVH': '\u256C',
        'boxvl': '\u2524',
        'boxvL': '\u2561',
        'boxVl': '\u2562',
        'boxVL': '\u2563',
        'boxvr': '\u251C',
        'boxvR': '\u255E',
        'boxVr': '\u255F',
        'boxVR': '\u2560',
        'bprime': '\u2035',
        'breve': '\u02D8',
        'Breve': '\u02D8',
        'brvbar': '\xA6',
        'bscr': '\uD835\uDCB7',
        'Bscr': 'ℬ',
        'bsemi': '\u204F',
        'bsim': '\u223D',
        'bsime': '\u22CD',
        'bsol': '\\',
        'bsolb': '\u29C5',
        'bsolhsub': '\u27C8',
        'bull': '\u2022',
        'bullet': '\u2022',
        'bump': '\u224E',
        'bumpe': '\u224F',
        'bumpE': '\u2AAE',
        'bumpeq': '\u224F',
        'Bumpeq': '\u224E',
        'cacute': 'ć',
        'Cacute': 'Ć',
        'cap': '\u2229',
        'Cap': '\u22D2',
        'capand': '\u2A44',
        'capbrcup': '\u2A49',
        'capcap': '\u2A4B',
        'capcup': '\u2A47',
        'capdot': '\u2A40',
        'CapitalDifferentialD': 'ⅅ',
        'caps': '\u2229︀',
        'caret': '\u2041',
        'caron': 'ˇ',
        'Cayleys': 'ℭ',
        'ccaps': '\u2A4D',
        'ccaron': 'č',
        'Ccaron': 'Č',
        'ccedil': 'ç',
        'Ccedil': 'Ç',
        'ccirc': 'ĉ',
        'Ccirc': 'Ĉ',
        'Cconint': '\u2230',
        'ccups': '\u2A4C',
        'ccupssm': '\u2A50',
        'cdot': 'ċ',
        'Cdot': 'Ċ',
        'cedil': '\xB8',
        'Cedilla': '\xB8',
        'cemptyv': '\u29B2',
        'cent': '\xA2',
        'centerdot': '\xB7',
        'CenterDot': '\xB7',
        'cfr': '\uD835\uDD20',
        'Cfr': 'ℭ',
        'chcy': 'ч',
        'CHcy': 'Ч',
        'check': '\u2713',
        'checkmark': '\u2713',
        'chi': 'χ',
        'Chi': 'Χ',
        'cir': '\u25CB',
        'circ': 'ˆ',
        'circeq': '\u2257',
        'circlearrowleft': '\u21BA',
        'circlearrowright': '\u21BB',
        'circledast': '\u229B',
        'circledcirc': '\u229A',
        'circleddash': '\u229D',
        'CircleDot': '\u2299',
        'circledR': '\xAE',
        'circledS': '\u24C8',
        'CircleMinus': '\u2296',
        'CirclePlus': '\u2295',
        'CircleTimes': '\u2297',
        'cire': '\u2257',
        'cirE': '\u29C3',
        'cirfnint': '\u2A10',
        'cirmid': '\u2AEF',
        'cirscir': '\u29C2',
        'ClockwiseContourIntegral': '\u2232',
        'CloseCurlyDoubleQuote': '\u201D',
        'CloseCurlyQuote': '\u2019',
        'clubs': '\u2663',
        'clubsuit': '\u2663',
        'colon': ':',
        'Colon': '\u2237',
        'colone': '\u2254',
        'Colone': '\u2A74',
        'coloneq': '\u2254',
        'comma': ',',
        'commat': '@',
        'comp': '\u2201',
        'compfn': '\u2218',
        'complement': '\u2201',
        'complexes': 'ℂ',
        'cong': '\u2245',
        'congdot': '\u2A6D',
        'Congruent': '\u2261',
        'conint': '\u222E',
        'Conint': '\u222F',
        'ContourIntegral': '\u222E',
        'copf': '\uD835\uDD54',
        'Copf': 'ℂ',
        'coprod': '\u2210',
        'Coproduct': '\u2210',
        'copy': '\xA9',
        'COPY': '\xA9',
        'copysr': '\u2117',
        'CounterClockwiseContourIntegral': '\u2233',
        'crarr': '\u21B5',
        'cross': '\u2717',
        'Cross': '\u2A2F',
        'cscr': '\uD835\uDCB8',
        'Cscr': '\uD835\uDC9E',
        'csub': '\u2ACF',
        'csube': '\u2AD1',
        'csup': '\u2AD0',
        'csupe': '\u2AD2',
        'ctdot': '\u22EF',
        'cudarrl': '\u2938',
        'cudarrr': '\u2935',
        'cuepr': '\u22DE',
        'cuesc': '\u22DF',
        'cularr': '\u21B6',
        'cularrp': '\u293D',
        'cup': '\u222A',
        'Cup': '\u22D3',
        'cupbrcap': '\u2A48',
        'cupcap': '\u2A46',
        'CupCap': '\u224D',
        'cupcup': '\u2A4A',
        'cupdot': '\u228D',
        'cupor': '\u2A45',
        'cups': '\u222A︀',
        'curarr': '\u21B7',
        'curarrm': '\u293C',
        'curlyeqprec': '\u22DE',
        'curlyeqsucc': '\u22DF',
        'curlyvee': '\u22CE',
        'curlywedge': '\u22CF',
        'curren': '\xA4',
        'curvearrowleft': '\u21B6',
        'curvearrowright': '\u21B7',
        'cuvee': '\u22CE',
        'cuwed': '\u22CF',
        'cwconint': '\u2232',
        'cwint': '\u2231',
        'cylcty': '\u232D',
        'dagger': '\u2020',
        'Dagger': '\u2021',
        'daleth': 'ℸ',
        'darr': '\u2193',
        'dArr': '\u21D3',
        'Darr': '\u21A1',
        'dash': '\u2010',
        'dashv': '\u22A3',
        'Dashv': '\u2AE4',
        'dbkarow': '\u290F',
        'dblac': '\u02DD',
        'dcaron': 'ď',
        'Dcaron': 'Ď',
        'dcy': 'д',
        'Dcy': 'Д',
        'dd': 'ⅆ',
        'DD': 'ⅅ',
        'ddagger': '\u2021',
        'ddarr': '\u21CA',
        'DDotrahd': '\u2911',
        'ddotseq': '\u2A77',
        'deg': '\xB0',
        'Del': '\u2207',
        'delta': 'δ',
        'Delta': 'Δ',
        'demptyv': '\u29B1',
        'dfisht': '\u297F',
        'dfr': '\uD835\uDD21',
        'Dfr': '\uD835\uDD07',
        'dHar': '\u2965',
        'dharl': '\u21C3',
        'dharr': '\u21C2',
        'DiacriticalAcute': '\xB4',
        'DiacriticalDot': '\u02D9',
        'DiacriticalDoubleAcute': '\u02DD',
        'DiacriticalGrave': '`',
        'DiacriticalTilde': '\u02DC',
        'diam': '\u22C4',
        'diamond': '\u22C4',
        'Diamond': '\u22C4',
        'diamondsuit': '\u2666',
        'diams': '\u2666',
        'die': '\xA8',
        'DifferentialD': 'ⅆ',
        'digamma': 'ϝ',
        'disin': '\u22F2',
        'div': '\xF7',
        'divide': '\xF7',
        'divideontimes': '\u22C7',
        'divonx': '\u22C7',
        'djcy': 'ђ',
        'DJcy': 'Ђ',
        'dlcorn': '\u231E',
        'dlcrop': '\u230D',
        'dollar': '$',
        'dopf': '\uD835\uDD55',
        'Dopf': '\uD835\uDD3B',
        'dot': '\u02D9',
        'Dot': '\xA8',
        'DotDot': '⃜',
        'doteq': '\u2250',
        'doteqdot': '\u2251',
        'DotEqual': '\u2250',
        'dotminus': '\u2238',
        'dotplus': '\u2214',
        'dotsquare': '\u22A1',
        'doublebarwedge': '\u2306',
        'DoubleContourIntegral': '\u222F',
        'DoubleDot': '\xA8',
        'DoubleDownArrow': '\u21D3',
        'DoubleLeftArrow': '\u21D0',
        'DoubleLeftRightArrow': '\u21D4',
        'DoubleLeftTee': '\u2AE4',
        'DoubleLongLeftArrow': '\u27F8',
        'DoubleLongLeftRightArrow': '\u27FA',
        'DoubleLongRightArrow': '\u27F9',
        'DoubleRightArrow': '\u21D2',
        'DoubleRightTee': '\u22A8',
        'DoubleUpArrow': '\u21D1',
        'DoubleUpDownArrow': '\u21D5',
        'DoubleVerticalBar': '\u2225',
        'downarrow': '\u2193',
        'Downarrow': '\u21D3',
        'DownArrow': '\u2193',
        'DownArrowBar': '\u2913',
        'DownArrowUpArrow': '\u21F5',
        'DownBreve': '̑',
        'downdownarrows': '\u21CA',
        'downharpoonleft': '\u21C3',
        'downharpoonright': '\u21C2',
        'DownLeftRightVector': '\u2950',
        'DownLeftTeeVector': '\u295E',
        'DownLeftVector': '\u21BD',
        'DownLeftVectorBar': '\u2956',
        'DownRightTeeVector': '\u295F',
        'DownRightVector': '\u21C1',
        'DownRightVectorBar': '\u2957',
        'DownTee': '\u22A4',
        'DownTeeArrow': '\u21A7',
        'drbkarow': '\u2910',
        'drcorn': '\u231F',
        'drcrop': '\u230C',
        'dscr': '\uD835\uDCB9',
        'Dscr': '\uD835\uDC9F',
        'dscy': 'ѕ',
        'DScy': 'Ѕ',
        'dsol': '\u29F6',
        'dstrok': 'đ',
        'Dstrok': 'Đ',
        'dtdot': '\u22F1',
        'dtri': '\u25BF',
        'dtrif': '\u25BE',
        'duarr': '\u21F5',
        'duhar': '\u296F',
        'dwangle': '\u29A6',
        'dzcy': 'џ',
        'DZcy': 'Џ',
        'dzigrarr': '\u27FF',
        'eacute': 'é',
        'Eacute': 'É',
        'easter': '\u2A6E',
        'ecaron': 'ě',
        'Ecaron': 'Ě',
        'ecir': '\u2256',
        'ecirc': 'ê',
        'Ecirc': 'Ê',
        'ecolon': '\u2255',
        'ecy': 'э',
        'Ecy': 'Э',
        'eDDot': '\u2A77',
        'edot': 'ė',
        'eDot': '\u2251',
        'Edot': 'Ė',
        'ee': 'ⅇ',
        'efDot': '\u2252',
        'efr': '\uD835\uDD22',
        'Efr': '\uD835\uDD08',
        'eg': '\u2A9A',
        'egrave': 'è',
        'Egrave': 'È',
        'egs': '\u2A96',
        'egsdot': '\u2A98',
        'el': '\u2A99',
        'Element': '\u2208',
        'elinters': '\u23E7',
        'ell': 'ℓ',
        'els': '\u2A95',
        'elsdot': '\u2A97',
        'emacr': 'ē',
        'Emacr': 'Ē',
        'empty': '\u2205',
        'emptyset': '\u2205',
        'EmptySmallSquare': '\u25FB',
        'emptyv': '\u2205',
        'EmptyVerySmallSquare': '\u25AB',
        'emsp': '\u2003',
        'emsp13': '\u2004',
        'emsp14': '\u2005',
        'eng': 'ŋ',
        'ENG': 'Ŋ',
        'ensp': '\u2002',
        'eogon': 'ę',
        'Eogon': 'Ę',
        'eopf': '\uD835\uDD56',
        'Eopf': '\uD835\uDD3C',
        'epar': '\u22D5',
        'eparsl': '\u29E3',
        'eplus': '\u2A71',
        'epsi': 'ε',
        'epsilon': 'ε',
        'Epsilon': 'Ε',
        'epsiv': 'ϵ',
        'eqcirc': '\u2256',
        'eqcolon': '\u2255',
        'eqsim': '\u2242',
        'eqslantgtr': '\u2A96',
        'eqslantless': '\u2A95',
        'Equal': '\u2A75',
        'equals': '=',
        'EqualTilde': '\u2242',
        'equest': '\u225F',
        'Equilibrium': '\u21CC',
        'equiv': '\u2261',
        'equivDD': '\u2A78',
        'eqvparsl': '\u29E5',
        'erarr': '\u2971',
        'erDot': '\u2253',
        'escr': 'ℯ',
        'Escr': 'ℰ',
        'esdot': '\u2250',
        'esim': '\u2242',
        'Esim': '\u2A73',
        'eta': 'η',
        'Eta': 'Η',
        'eth': 'ð',
        'ETH': 'Ð',
        'euml': 'ë',
        'Euml': 'Ë',
        'euro': '\u20AC',
        'excl': '!',
        'exist': '\u2203',
        'Exists': '\u2203',
        'expectation': 'ℰ',
        'exponentiale': 'ⅇ',
        'ExponentialE': 'ⅇ',
        'fallingdotseq': '\u2252',
        'fcy': 'ф',
        'Fcy': 'Ф',
        'female': '\u2640',
        'ffilig': 'ﬃ',
        'fflig': 'ﬀ',
        'ffllig': 'ﬄ',
        'ffr': '\uD835\uDD23',
        'Ffr': '\uD835\uDD09',
        'filig': 'ﬁ',
        'FilledSmallSquare': '\u25FC',
        'FilledVerySmallSquare': '\u25AA',
        'fjlig': 'fj',
        'flat': '\u266D',
        'fllig': 'ﬂ',
        'fltns': '\u25B1',
        'fnof': 'ƒ',
        'fopf': '\uD835\uDD57',
        'Fopf': '\uD835\uDD3D',
        'forall': '\u2200',
        'ForAll': '\u2200',
        'fork': '\u22D4',
        'forkv': '\u2AD9',
        'Fouriertrf': 'ℱ',
        'fpartint': '\u2A0D',
        'frac12': '\xBD',
        'frac13': '\u2153',
        'frac14': '\xBC',
        'frac15': '\u2155',
        'frac16': '\u2159',
        'frac18': '\u215B',
        'frac23': '\u2154',
        'frac25': '\u2156',
        'frac34': '\xBE',
        'frac35': '\u2157',
        'frac38': '\u215C',
        'frac45': '\u2158',
        'frac56': '\u215A',
        'frac58': '\u215D',
        'frac78': '\u215E',
        'frasl': '\u2044',
        'frown': '\u2322',
        'fscr': '\uD835\uDCBB',
        'Fscr': 'ℱ',
        'gacute': 'ǵ',
        'gamma': 'γ',
        'Gamma': 'Γ',
        'gammad': 'ϝ',
        'Gammad': 'Ϝ',
        'gap': '\u2A86',
        'gbreve': 'ğ',
        'Gbreve': 'Ğ',
        'Gcedil': 'Ģ',
        'gcirc': 'ĝ',
        'Gcirc': 'Ĝ',
        'gcy': 'г',
        'Gcy': 'Г',
        'gdot': 'ġ',
        'Gdot': 'Ġ',
        'ge': '\u2265',
        'gE': '\u2267',
        'gel': '\u22DB',
        'gEl': '\u2A8C',
        'geq': '\u2265',
        'geqq': '\u2267',
        'geqslant': '\u2A7E',
        'ges': '\u2A7E',
        'gescc': '\u2AA9',
        'gesdot': '\u2A80',
        'gesdoto': '\u2A82',
        'gesdotol': '\u2A84',
        'gesl': '\u22DB︀',
        'gesles': '\u2A94',
        'gfr': '\uD835\uDD24',
        'Gfr': '\uD835\uDD0A',
        'gg': '\u226B',
        'Gg': '\u22D9',
        'ggg': '\u22D9',
        'gimel': 'ℷ',
        'gjcy': 'ѓ',
        'GJcy': 'Ѓ',
        'gl': '\u2277',
        'gla': '\u2AA5',
        'glE': '\u2A92',
        'glj': '\u2AA4',
        'gnap': '\u2A8A',
        'gnapprox': '\u2A8A',
        'gne': '\u2A88',
        'gnE': '\u2269',
        'gneq': '\u2A88',
        'gneqq': '\u2269',
        'gnsim': '\u22E7',
        'gopf': '\uD835\uDD58',
        'Gopf': '\uD835\uDD3E',
        'grave': '`',
        'GreaterEqual': '\u2265',
        'GreaterEqualLess': '\u22DB',
        'GreaterFullEqual': '\u2267',
        'GreaterGreater': '\u2AA2',
        'GreaterLess': '\u2277',
        'GreaterSlantEqual': '\u2A7E',
        'GreaterTilde': '\u2273',
        'gscr': 'ℊ',
        'Gscr': '\uD835\uDCA2',
        'gsim': '\u2273',
        'gsime': '\u2A8E',
        'gsiml': '\u2A90',
        'gt': '>',
        'Gt': '\u226B',
        'GT': '>',
        'gtcc': '\u2AA7',
        'gtcir': '\u2A7A',
        'gtdot': '\u22D7',
        'gtlPar': '\u2995',
        'gtquest': '\u2A7C',
        'gtrapprox': '\u2A86',
        'gtrarr': '\u2978',
        'gtrdot': '\u22D7',
        'gtreqless': '\u22DB',
        'gtreqqless': '\u2A8C',
        'gtrless': '\u2277',
        'gtrsim': '\u2273',
        'gvertneqq': '\u2269︀',
        'gvnE': '\u2269︀',
        'Hacek': 'ˇ',
        'hairsp': '\u200A',
        'half': '\xBD',
        'hamilt': 'ℋ',
        'hardcy': 'ъ',
        'HARDcy': 'Ъ',
        'harr': '\u2194',
        'hArr': '\u21D4',
        'harrcir': '\u2948',
        'harrw': '\u21AD',
        'Hat': '^',
        'hbar': 'ℏ',
        'hcirc': 'ĥ',
        'Hcirc': 'Ĥ',
        'hearts': '\u2665',
        'heartsuit': '\u2665',
        'hellip': '\u2026',
        'hercon': '\u22B9',
        'hfr': '\uD835\uDD25',
        'Hfr': 'ℌ',
        'HilbertSpace': 'ℋ',
        'hksearow': '\u2925',
        'hkswarow': '\u2926',
        'hoarr': '\u21FF',
        'homtht': '\u223B',
        'hookleftarrow': '\u21A9',
        'hookrightarrow': '\u21AA',
        'hopf': '\uD835\uDD59',
        'Hopf': 'ℍ',
        'horbar': '\u2015',
        'HorizontalLine': '\u2500',
        'hscr': '\uD835\uDCBD',
        'Hscr': 'ℋ',
        'hslash': 'ℏ',
        'hstrok': 'ħ',
        'Hstrok': 'Ħ',
        'HumpDownHump': '\u224E',
        'HumpEqual': '\u224F',
        'hybull': '\u2043',
        'hyphen': '\u2010',
        'iacute': 'í',
        'Iacute': 'Í',
        'ic': '\u2063',
        'icirc': 'î',
        'Icirc': 'Î',
        'icy': 'и',
        'Icy': 'И',
        'Idot': 'İ',
        'iecy': 'е',
        'IEcy': 'Е',
        'iexcl': '\xA1',
        'iff': '\u21D4',
        'ifr': '\uD835\uDD26',
        'Ifr': 'ℑ',
        'igrave': 'ì',
        'Igrave': 'Ì',
        'ii': 'ⅈ',
        'iiiint': '\u2A0C',
        'iiint': '\u222D',
        'iinfin': '\u29DC',
        'iiota': '\u2129',
        'ijlig': 'ĳ',
        'IJlig': 'Ĳ',
        'Im': 'ℑ',
        'imacr': 'ī',
        'Imacr': 'Ī',
        'image': 'ℑ',
        'ImaginaryI': 'ⅈ',
        'imagline': 'ℐ',
        'imagpart': 'ℑ',
        'imath': 'ı',
        'imof': '\u22B7',
        'imped': 'Ƶ',
        'Implies': '\u21D2',
        'in': '\u2208',
        'incare': '\u2105',
        'infin': '\u221E',
        'infintie': '\u29DD',
        'inodot': 'ı',
        'int': '\u222B',
        'Int': '\u222C',
        'intcal': '\u22BA',
        'integers': 'ℤ',
        'Integral': '\u222B',
        'intercal': '\u22BA',
        'Intersection': '\u22C2',
        'intlarhk': '\u2A17',
        'intprod': '\u2A3C',
        'InvisibleComma': '\u2063',
        'InvisibleTimes': '\u2062',
        'iocy': 'ё',
        'IOcy': 'Ё',
        'iogon': 'į',
        'Iogon': 'Į',
        'iopf': '\uD835\uDD5A',
        'Iopf': '\uD835\uDD40',
        'iota': 'ι',
        'Iota': 'Ι',
        'iprod': '\u2A3C',
        'iquest': '\xBF',
        'iscr': '\uD835\uDCBE',
        'Iscr': 'ℐ',
        'isin': '\u2208',
        'isindot': '\u22F5',
        'isinE': '\u22F9',
        'isins': '\u22F4',
        'isinsv': '\u22F3',
        'isinv': '\u2208',
        'it': '\u2062',
        'itilde': 'ĩ',
        'Itilde': 'Ĩ',
        'iukcy': 'і',
        'Iukcy': 'І',
        'iuml': 'ï',
        'Iuml': 'Ï',
        'jcirc': 'ĵ',
        'Jcirc': 'Ĵ',
        'jcy': 'й',
        'Jcy': 'Й',
        'jfr': '\uD835\uDD27',
        'Jfr': '\uD835\uDD0D',
        'jmath': 'ȷ',
        'jopf': '\uD835\uDD5B',
        'Jopf': '\uD835\uDD41',
        'jscr': '\uD835\uDCBF',
        'Jscr': '\uD835\uDCA5',
        'jsercy': 'ј',
        'Jsercy': 'Ј',
        'jukcy': 'є',
        'Jukcy': 'Є',
        'kappa': 'κ',
        'Kappa': 'Κ',
        'kappav': 'ϰ',
        'kcedil': 'ķ',
        'Kcedil': 'Ķ',
        'kcy': 'к',
        'Kcy': 'К',
        'kfr': '\uD835\uDD28',
        'Kfr': '\uD835\uDD0E',
        'kgreen': 'ĸ',
        'khcy': 'х',
        'KHcy': 'Х',
        'kjcy': 'ќ',
        'KJcy': 'Ќ',
        'kopf': '\uD835\uDD5C',
        'Kopf': '\uD835\uDD42',
        'kscr': '\uD835\uDCC0',
        'Kscr': '\uD835\uDCA6',
        'lAarr': '\u21DA',
        'lacute': 'ĺ',
        'Lacute': 'Ĺ',
        'laemptyv': '\u29B4',
        'lagran': 'ℒ',
        'lambda': 'λ',
        'Lambda': 'Λ',
        'lang': '\u27E8',
        'Lang': '\u27EA',
        'langd': '\u2991',
        'langle': '\u27E8',
        'lap': '\u2A85',
        'Laplacetrf': 'ℒ',
        'laquo': '\xAB',
        'larr': '\u2190',
        'lArr': '\u21D0',
        'Larr': '\u219E',
        'larrb': '\u21E4',
        'larrbfs': '\u291F',
        'larrfs': '\u291D',
        'larrhk': '\u21A9',
        'larrlp': '\u21AB',
        'larrpl': '\u2939',
        'larrsim': '\u2973',
        'larrtl': '\u21A2',
        'lat': '\u2AAB',
        'latail': '\u2919',
        'lAtail': '\u291B',
        'late': '\u2AAD',
        'lates': '\u2AAD︀',
        'lbarr': '\u290C',
        'lBarr': '\u290E',
        'lbbrk': '\u2772',
        'lbrace': '{',
        'lbrack': '[',
        'lbrke': '\u298B',
        'lbrksld': '\u298F',
        'lbrkslu': '\u298D',
        'lcaron': 'ľ',
        'Lcaron': 'Ľ',
        'lcedil': 'ļ',
        'Lcedil': 'Ļ',
        'lceil': '\u2308',
        'lcub': '{',
        'lcy': 'л',
        'Lcy': 'Л',
        'ldca': '\u2936',
        'ldquo': '\u201C',
        'ldquor': '\u201E',
        'ldrdhar': '\u2967',
        'ldrushar': '\u294B',
        'ldsh': '\u21B2',
        'le': '\u2264',
        'lE': '\u2266',
        'LeftAngleBracket': '\u27E8',
        'leftarrow': '\u2190',
        'Leftarrow': '\u21D0',
        'LeftArrow': '\u2190',
        'LeftArrowBar': '\u21E4',
        'LeftArrowRightArrow': '\u21C6',
        'leftarrowtail': '\u21A2',
        'LeftCeiling': '\u2308',
        'LeftDoubleBracket': '\u27E6',
        'LeftDownTeeVector': '\u2961',
        'LeftDownVector': '\u21C3',
        'LeftDownVectorBar': '\u2959',
        'LeftFloor': '\u230A',
        'leftharpoondown': '\u21BD',
        'leftharpoonup': '\u21BC',
        'leftleftarrows': '\u21C7',
        'leftrightarrow': '\u2194',
        'Leftrightarrow': '\u21D4',
        'LeftRightArrow': '\u2194',
        'leftrightarrows': '\u21C6',
        'leftrightharpoons': '\u21CB',
        'leftrightsquigarrow': '\u21AD',
        'LeftRightVector': '\u294E',
        'LeftTee': '\u22A3',
        'LeftTeeArrow': '\u21A4',
        'LeftTeeVector': '\u295A',
        'leftthreetimes': '\u22CB',
        'LeftTriangle': '\u22B2',
        'LeftTriangleBar': '\u29CF',
        'LeftTriangleEqual': '\u22B4',
        'LeftUpDownVector': '\u2951',
        'LeftUpTeeVector': '\u2960',
        'LeftUpVector': '\u21BF',
        'LeftUpVectorBar': '\u2958',
        'LeftVector': '\u21BC',
        'LeftVectorBar': '\u2952',
        'leg': '\u22DA',
        'lEg': '\u2A8B',
        'leq': '\u2264',
        'leqq': '\u2266',
        'leqslant': '\u2A7D',
        'les': '\u2A7D',
        'lescc': '\u2AA8',
        'lesdot': '\u2A7F',
        'lesdoto': '\u2A81',
        'lesdotor': '\u2A83',
        'lesg': '\u22DA︀',
        'lesges': '\u2A93',
        'lessapprox': '\u2A85',
        'lessdot': '\u22D6',
        'lesseqgtr': '\u22DA',
        'lesseqqgtr': '\u2A8B',
        'LessEqualGreater': '\u22DA',
        'LessFullEqual': '\u2266',
        'LessGreater': '\u2276',
        'lessgtr': '\u2276',
        'LessLess': '\u2AA1',
        'lesssim': '\u2272',
        'LessSlantEqual': '\u2A7D',
        'LessTilde': '\u2272',
        'lfisht': '\u297C',
        'lfloor': '\u230A',
        'lfr': '\uD835\uDD29',
        'Lfr': '\uD835\uDD0F',
        'lg': '\u2276',
        'lgE': '\u2A91',
        'lHar': '\u2962',
        'lhard': '\u21BD',
        'lharu': '\u21BC',
        'lharul': '\u296A',
        'lhblk': '\u2584',
        'ljcy': 'љ',
        'LJcy': 'Љ',
        'll': '\u226A',
        'Ll': '\u22D8',
        'llarr': '\u21C7',
        'llcorner': '\u231E',
        'Lleftarrow': '\u21DA',
        'llhard': '\u296B',
        'lltri': '\u25FA',
        'lmidot': 'ŀ',
        'Lmidot': 'Ŀ',
        'lmoust': '\u23B0',
        'lmoustache': '\u23B0',
        'lnap': '\u2A89',
        'lnapprox': '\u2A89',
        'lne': '\u2A87',
        'lnE': '\u2268',
        'lneq': '\u2A87',
        'lneqq': '\u2268',
        'lnsim': '\u22E6',
        'loang': '\u27EC',
        'loarr': '\u21FD',
        'lobrk': '\u27E6',
        'longleftarrow': '\u27F5',
        'Longleftarrow': '\u27F8',
        'LongLeftArrow': '\u27F5',
        'longleftrightarrow': '\u27F7',
        'Longleftrightarrow': '\u27FA',
        'LongLeftRightArrow': '\u27F7',
        'longmapsto': '\u27FC',
        'longrightarrow': '\u27F6',
        'Longrightarrow': '\u27F9',
        'LongRightArrow': '\u27F6',
        'looparrowleft': '\u21AB',
        'looparrowright': '\u21AC',
        'lopar': '\u2985',
        'lopf': '\uD835\uDD5D',
        'Lopf': '\uD835\uDD43',
        'loplus': '\u2A2D',
        'lotimes': '\u2A34',
        'lowast': '\u2217',
        'lowbar': '_',
        'LowerLeftArrow': '\u2199',
        'LowerRightArrow': '\u2198',
        'loz': '\u25CA',
        'lozenge': '\u25CA',
        'lozf': '\u29EB',
        'lpar': '(',
        'lparlt': '\u2993',
        'lrarr': '\u21C6',
        'lrcorner': '\u231F',
        'lrhar': '\u21CB',
        'lrhard': '\u296D',
        'lrm': '\u200E',
        'lrtri': '\u22BF',
        'lsaquo': '\u2039',
        'lscr': '\uD835\uDCC1',
        'Lscr': 'ℒ',
        'lsh': '\u21B0',
        'Lsh': '\u21B0',
        'lsim': '\u2272',
        'lsime': '\u2A8D',
        'lsimg': '\u2A8F',
        'lsqb': '[',
        'lsquo': '\u2018',
        'lsquor': '\u201A',
        'lstrok': 'ł',
        'Lstrok': 'Ł',
        'lt': '<',
        'Lt': '\u226A',
        'LT': '<',
        'ltcc': '\u2AA6',
        'ltcir': '\u2A79',
        'ltdot': '\u22D6',
        'lthree': '\u22CB',
        'ltimes': '\u22C9',
        'ltlarr': '\u2976',
        'ltquest': '\u2A7B',
        'ltri': '\u25C3',
        'ltrie': '\u22B4',
        'ltrif': '\u25C2',
        'ltrPar': '\u2996',
        'lurdshar': '\u294A',
        'luruhar': '\u2966',
        'lvertneqq': '\u2268︀',
        'lvnE': '\u2268︀',
        'macr': '\xAF',
        'male': '\u2642',
        'malt': '\u2720',
        'maltese': '\u2720',
        'map': '\u21A6',
        'Map': '\u2905',
        'mapsto': '\u21A6',
        'mapstodown': '\u21A7',
        'mapstoleft': '\u21A4',
        'mapstoup': '\u21A5',
        'marker': '\u25AE',
        'mcomma': '\u2A29',
        'mcy': 'м',
        'Mcy': 'М',
        'mdash': '\u2014',
        'mDDot': '\u223A',
        'measuredangle': '\u2221',
        'MediumSpace': '\u205F',
        'Mellintrf': 'ℳ',
        'mfr': '\uD835\uDD2A',
        'Mfr': '\uD835\uDD10',
        'mho': '\u2127',
        'micro': 'µ',
        'mid': '\u2223',
        'midast': '*',
        'midcir': '\u2AF0',
        'middot': '\xB7',
        'minus': '\u2212',
        'minusb': '\u229F',
        'minusd': '\u2238',
        'minusdu': '\u2A2A',
        'MinusPlus': '\u2213',
        'mlcp': '\u2ADB',
        'mldr': '\u2026',
        'mnplus': '\u2213',
        'models': '\u22A7',
        'mopf': '\uD835\uDD5E',
        'Mopf': '\uD835\uDD44',
        'mp': '\u2213',
        'mscr': '\uD835\uDCC2',
        'Mscr': 'ℳ',
        'mstpos': '\u223E',
        'mu': 'μ',
        'Mu': 'Μ',
        'multimap': '\u22B8',
        'mumap': '\u22B8',
        'nabla': '\u2207',
        'nacute': 'ń',
        'Nacute': 'Ń',
        'nang': '\u2220⃒',
        'nap': '\u2249',
        'napE': '\u2A70̸',
        'napid': '\u224B̸',
        'napos': 'ŉ',
        'napprox': '\u2249',
        'natur': '\u266E',
        'natural': '\u266E',
        'naturals': 'ℕ',
        'nbsp': '\xA0',
        'nbump': '\u224E̸',
        'nbumpe': '\u224F̸',
        'ncap': '\u2A43',
        'ncaron': 'ň',
        'Ncaron': 'Ň',
        'ncedil': 'ņ',
        'Ncedil': 'Ņ',
        'ncong': '\u2247',
        'ncongdot': '\u2A6D̸',
        'ncup': '\u2A42',
        'ncy': 'н',
        'Ncy': 'Н',
        'ndash': '\u2013',
        'ne': '\u2260',
        'nearhk': '\u2924',
        'nearr': '\u2197',
        'neArr': '\u21D7',
        'nearrow': '\u2197',
        'nedot': '\u2250̸',
        'NegativeMediumSpace': '\u200B',
        'NegativeThickSpace': '\u200B',
        'NegativeThinSpace': '\u200B',
        'NegativeVeryThinSpace': '\u200B',
        'nequiv': '\u2262',
        'nesear': '\u2928',
        'nesim': '\u2242̸',
        'NestedGreaterGreater': '\u226B',
        'NestedLessLess': '\u226A',
        'NewLine': '\n',
        'nexist': '\u2204',
        'nexists': '\u2204',
        'nfr': '\uD835\uDD2B',
        'Nfr': '\uD835\uDD11',
        'nge': '\u2271',
        'ngE': '\u2267̸',
        'ngeq': '\u2271',
        'ngeqq': '\u2267̸',
        'ngeqslant': '\u2A7E̸',
        'nges': '\u2A7E̸',
        'nGg': '\u22D9̸',
        'ngsim': '\u2275',
        'ngt': '\u226F',
        'nGt': '\u226B⃒',
        'ngtr': '\u226F',
        'nGtv': '\u226B̸',
        'nharr': '\u21AE',
        'nhArr': '\u21CE',
        'nhpar': '\u2AF2',
        'ni': '\u220B',
        'nis': '\u22FC',
        'nisd': '\u22FA',
        'niv': '\u220B',
        'njcy': 'њ',
        'NJcy': 'Њ',
        'nlarr': '\u219A',
        'nlArr': '\u21CD',
        'nldr': '\u2025',
        'nle': '\u2270',
        'nlE': '\u2266̸',
        'nleftarrow': '\u219A',
        'nLeftarrow': '\u21CD',
        'nleftrightarrow': '\u21AE',
        'nLeftrightarrow': '\u21CE',
        'nleq': '\u2270',
        'nleqq': '\u2266̸',
        'nleqslant': '\u2A7D̸',
        'nles': '\u2A7D̸',
        'nless': '\u226E',
        'nLl': '\u22D8̸',
        'nlsim': '\u2274',
        'nlt': '\u226E',
        'nLt': '\u226A⃒',
        'nltri': '\u22EA',
        'nltrie': '\u22EC',
        'nLtv': '\u226A̸',
        'nmid': '\u2224',
        'NoBreak': '\u2060',
        'NonBreakingSpace': '\xA0',
        'nopf': '\uD835\uDD5F',
        'Nopf': 'ℕ',
        'not': '\xAC',
        'Not': '\u2AEC',
        'NotCongruent': '\u2262',
        'NotCupCap': '\u226D',
        'NotDoubleVerticalBar': '\u2226',
        'NotElement': '\u2209',
        'NotEqual': '\u2260',
        'NotEqualTilde': '\u2242̸',
        'NotExists': '\u2204',
        'NotGreater': '\u226F',
        'NotGreaterEqual': '\u2271',
        'NotGreaterFullEqual': '\u2267̸',
        'NotGreaterGreater': '\u226B̸',
        'NotGreaterLess': '\u2279',
        'NotGreaterSlantEqual': '\u2A7E̸',
        'NotGreaterTilde': '\u2275',
        'NotHumpDownHump': '\u224E̸',
        'NotHumpEqual': '\u224F̸',
        'notin': '\u2209',
        'notindot': '\u22F5̸',
        'notinE': '\u22F9̸',
        'notinva': '\u2209',
        'notinvb': '\u22F7',
        'notinvc': '\u22F6',
        'NotLeftTriangle': '\u22EA',
        'NotLeftTriangleBar': '\u29CF̸',
        'NotLeftTriangleEqual': '\u22EC',
        'NotLess': '\u226E',
        'NotLessEqual': '\u2270',
        'NotLessGreater': '\u2278',
        'NotLessLess': '\u226A̸',
        'NotLessSlantEqual': '\u2A7D̸',
        'NotLessTilde': '\u2274',
        'NotNestedGreaterGreater': '\u2AA2̸',
        'NotNestedLessLess': '\u2AA1̸',
        'notni': '\u220C',
        'notniva': '\u220C',
        'notnivb': '\u22FE',
        'notnivc': '\u22FD',
        'NotPrecedes': '\u2280',
        'NotPrecedesEqual': '\u2AAF̸',
        'NotPrecedesSlantEqual': '\u22E0',
        'NotReverseElement': '\u220C',
        'NotRightTriangle': '\u22EB',
        'NotRightTriangleBar': '\u29D0̸',
        'NotRightTriangleEqual': '\u22ED',
        'NotSquareSubset': '\u228F̸',
        'NotSquareSubsetEqual': '\u22E2',
        'NotSquareSuperset': '\u2290̸',
        'NotSquareSupersetEqual': '\u22E3',
        'NotSubset': '\u2282⃒',
        'NotSubsetEqual': '\u2288',
        'NotSucceeds': '\u2281',
        'NotSucceedsEqual': '\u2AB0̸',
        'NotSucceedsSlantEqual': '\u22E1',
        'NotSucceedsTilde': '\u227F̸',
        'NotSuperset': '\u2283⃒',
        'NotSupersetEqual': '\u2289',
        'NotTilde': '\u2241',
        'NotTildeEqual': '\u2244',
        'NotTildeFullEqual': '\u2247',
        'NotTildeTilde': '\u2249',
        'NotVerticalBar': '\u2224',
        'npar': '\u2226',
        'nparallel': '\u2226',
        'nparsl': '\u2AFD⃥',
        'npart': '\u2202̸',
        'npolint': '\u2A14',
        'npr': '\u2280',
        'nprcue': '\u22E0',
        'npre': '\u2AAF̸',
        'nprec': '\u2280',
        'npreceq': '\u2AAF̸',
        'nrarr': '\u219B',
        'nrArr': '\u21CF',
        'nrarrc': '\u2933̸',
        'nrarrw': '\u219D̸',
        'nrightarrow': '\u219B',
        'nRightarrow': '\u21CF',
        'nrtri': '\u22EB',
        'nrtrie': '\u22ED',
        'nsc': '\u2281',
        'nsccue': '\u22E1',
        'nsce': '\u2AB0̸',
        'nscr': '\uD835\uDCC3',
        'Nscr': '\uD835\uDCA9',
        'nshortmid': '\u2224',
        'nshortparallel': '\u2226',
        'nsim': '\u2241',
        'nsime': '\u2244',
        'nsimeq': '\u2244',
        'nsmid': '\u2224',
        'nspar': '\u2226',
        'nsqsube': '\u22E2',
        'nsqsupe': '\u22E3',
        'nsub': '\u2284',
        'nsube': '\u2288',
        'nsubE': '\u2AC5̸',
        'nsubset': '\u2282⃒',
        'nsubseteq': '\u2288',
        'nsubseteqq': '\u2AC5̸',
        'nsucc': '\u2281',
        'nsucceq': '\u2AB0̸',
        'nsup': '\u2285',
        'nsupe': '\u2289',
        'nsupE': '\u2AC6̸',
        'nsupset': '\u2283⃒',
        'nsupseteq': '\u2289',
        'nsupseteqq': '\u2AC6̸',
        'ntgl': '\u2279',
        'ntilde': 'ñ',
        'Ntilde': 'Ñ',
        'ntlg': '\u2278',
        'ntriangleleft': '\u22EA',
        'ntrianglelefteq': '\u22EC',
        'ntriangleright': '\u22EB',
        'ntrianglerighteq': '\u22ED',
        'nu': 'ν',
        'Nu': 'Ν',
        'num': '#',
        'numero': '\u2116',
        'numsp': '\u2007',
        'nvap': '\u224D⃒',
        'nvdash': '\u22AC',
        'nvDash': '\u22AD',
        'nVdash': '\u22AE',
        'nVDash': '\u22AF',
        'nvge': '\u2265⃒',
        'nvgt': '>⃒',
        'nvHarr': '\u2904',
        'nvinfin': '\u29DE',
        'nvlArr': '\u2902',
        'nvle': '\u2264⃒',
        'nvlt': '<⃒',
        'nvltrie': '\u22B4⃒',
        'nvrArr': '\u2903',
        'nvrtrie': '\u22B5⃒',
        'nvsim': '\u223C⃒',
        'nwarhk': '\u2923',
        'nwarr': '\u2196',
        'nwArr': '\u21D6',
        'nwarrow': '\u2196',
        'nwnear': '\u2927',
        'oacute': 'ó',
        'Oacute': 'Ó',
        'oast': '\u229B',
        'ocir': '\u229A',
        'ocirc': 'ô',
        'Ocirc': 'Ô',
        'ocy': 'о',
        'Ocy': 'О',
        'odash': '\u229D',
        'odblac': 'ő',
        'Odblac': 'Ő',
        'odiv': '\u2A38',
        'odot': '\u2299',
        'odsold': '\u29BC',
        'oelig': 'œ',
        'OElig': 'Œ',
        'ofcir': '\u29BF',
        'ofr': '\uD835\uDD2C',
        'Ofr': '\uD835\uDD12',
        'ogon': '\u02DB',
        'ograve': 'ò',
        'Ograve': 'Ò',
        'ogt': '\u29C1',
        'ohbar': '\u29B5',
        'ohm': 'Ω',
        'oint': '\u222E',
        'olarr': '\u21BA',
        'olcir': '\u29BE',
        'olcross': '\u29BB',
        'oline': '\u203E',
        'olt': '\u29C0',
        'omacr': 'ō',
        'Omacr': 'Ō',
        'omega': 'ω',
        'Omega': 'Ω',
        'omicron': 'ο',
        'Omicron': 'Ο',
        'omid': '\u29B6',
        'ominus': '\u2296',
        'oopf': '\uD835\uDD60',
        'Oopf': '\uD835\uDD46',
        'opar': '\u29B7',
        'OpenCurlyDoubleQuote': '\u201C',
        'OpenCurlyQuote': '\u2018',
        'operp': '\u29B9',
        'oplus': '\u2295',
        'or': '\u2228',
        'Or': '\u2A54',
        'orarr': '\u21BB',
        'ord': '\u2A5D',
        'order': 'ℴ',
        'orderof': 'ℴ',
        'ordf': 'ª',
        'ordm': 'º',
        'origof': '\u22B6',
        'oror': '\u2A56',
        'orslope': '\u2A57',
        'orv': '\u2A5B',
        'oS': '\u24C8',
        'oscr': 'ℴ',
        'Oscr': '\uD835\uDCAA',
        'oslash': 'ø',
        'Oslash': 'Ø',
        'osol': '\u2298',
        'otilde': 'õ',
        'Otilde': 'Õ',
        'otimes': '\u2297',
        'Otimes': '\u2A37',
        'otimesas': '\u2A36',
        'ouml': 'ö',
        'Ouml': 'Ö',
        'ovbar': '\u233D',
        'OverBar': '\u203E',
        'OverBrace': '\u23DE',
        'OverBracket': '\u23B4',
        'OverParenthesis': '\u23DC',
        'par': '\u2225',
        'para': '\xB6',
        'parallel': '\u2225',
        'parsim': '\u2AF3',
        'parsl': '\u2AFD',
        'part': '\u2202',
        'PartialD': '\u2202',
        'pcy': 'п',
        'Pcy': 'П',
        'percnt': '%',
        'period': '.',
        'permil': '\u2030',
        'perp': '\u22A5',
        'pertenk': '\u2031',
        'pfr': '\uD835\uDD2D',
        'Pfr': '\uD835\uDD13',
        'phi': 'φ',
        'Phi': 'Φ',
        'phiv': 'ϕ',
        'phmmat': 'ℳ',
        'phone': '\u260E',
        'pi': 'π',
        'Pi': 'Π',
        'pitchfork': '\u22D4',
        'piv': 'ϖ',
        'planck': 'ℏ',
        'planckh': 'ℎ',
        'plankv': 'ℏ',
        'plus': '+',
        'plusacir': '\u2A23',
        'plusb': '\u229E',
        'pluscir': '\u2A22',
        'plusdo': '\u2214',
        'plusdu': '\u2A25',
        'pluse': '\u2A72',
        'PlusMinus': '\xB1',
        'plusmn': '\xB1',
        'plussim': '\u2A26',
        'plustwo': '\u2A27',
        'pm': '\xB1',
        'Poincareplane': 'ℌ',
        'pointint': '\u2A15',
        'popf': '\uD835\uDD61',
        'Popf': 'ℙ',
        'pound': '\xA3',
        'pr': '\u227A',
        'Pr': '\u2ABB',
        'prap': '\u2AB7',
        'prcue': '\u227C',
        'pre': '\u2AAF',
        'prE': '\u2AB3',
        'prec': '\u227A',
        'precapprox': '\u2AB7',
        'preccurlyeq': '\u227C',
        'Precedes': '\u227A',
        'PrecedesEqual': '\u2AAF',
        'PrecedesSlantEqual': '\u227C',
        'PrecedesTilde': '\u227E',
        'preceq': '\u2AAF',
        'precnapprox': '\u2AB9',
        'precneqq': '\u2AB5',
        'precnsim': '\u22E8',
        'precsim': '\u227E',
        'prime': '\u2032',
        'Prime': '\u2033',
        'primes': 'ℙ',
        'prnap': '\u2AB9',
        'prnE': '\u2AB5',
        'prnsim': '\u22E8',
        'prod': '\u220F',
        'Product': '\u220F',
        'profalar': '\u232E',
        'profline': '\u2312',
        'profsurf': '\u2313',
        'prop': '\u221D',
        'Proportion': '\u2237',
        'Proportional': '\u221D',
        'propto': '\u221D',
        'prsim': '\u227E',
        'prurel': '\u22B0',
        'pscr': '\uD835\uDCC5',
        'Pscr': '\uD835\uDCAB',
        'psi': 'ψ',
        'Psi': 'Ψ',
        'puncsp': '\u2008',
        'qfr': '\uD835\uDD2E',
        'Qfr': '\uD835\uDD14',
        'qint': '\u2A0C',
        'qopf': '\uD835\uDD62',
        'Qopf': 'ℚ',
        'qprime': '\u2057',
        'qscr': '\uD835\uDCC6',
        'Qscr': '\uD835\uDCAC',
        'quaternions': 'ℍ',
        'quatint': '\u2A16',
        'quest': '?',
        'questeq': '\u225F',
        'quot': '"',
        'QUOT': '"',
        'rAarr': '\u21DB',
        'race': '\u223Ḏ',
        'racute': 'ŕ',
        'Racute': 'Ŕ',
        'radic': '\u221A',
        'raemptyv': '\u29B3',
        'rang': '\u27E9',
        'Rang': '\u27EB',
        'rangd': '\u2992',
        'range': '\u29A5',
        'rangle': '\u27E9',
        'raquo': '\xBB',
        'rarr': '\u2192',
        'rArr': '\u21D2',
        'Rarr': '\u21A0',
        'rarrap': '\u2975',
        'rarrb': '\u21E5',
        'rarrbfs': '\u2920',
        'rarrc': '\u2933',
        'rarrfs': '\u291E',
        'rarrhk': '\u21AA',
        'rarrlp': '\u21AC',
        'rarrpl': '\u2945',
        'rarrsim': '\u2974',
        'rarrtl': '\u21A3',
        'Rarrtl': '\u2916',
        'rarrw': '\u219D',
        'ratail': '\u291A',
        'rAtail': '\u291C',
        'ratio': '\u2236',
        'rationals': 'ℚ',
        'rbarr': '\u290D',
        'rBarr': '\u290F',
        'RBarr': '\u2910',
        'rbbrk': '\u2773',
        'rbrace': '}',
        'rbrack': ']',
        'rbrke': '\u298C',
        'rbrksld': '\u298E',
        'rbrkslu': '\u2990',
        'rcaron': 'ř',
        'Rcaron': 'Ř',
        'rcedil': 'ŗ',
        'Rcedil': 'Ŗ',
        'rceil': '\u2309',
        'rcub': '}',
        'rcy': 'р',
        'Rcy': 'Р',
        'rdca': '\u2937',
        'rdldhar': '\u2969',
        'rdquo': '\u201D',
        'rdquor': '\u201D',
        'rdsh': '\u21B3',
        'Re': 'ℜ',
        'real': 'ℜ',
        'realine': 'ℛ',
        'realpart': 'ℜ',
        'reals': 'ℝ',
        'rect': '\u25AD',
        'reg': '\xAE',
        'REG': '\xAE',
        'ReverseElement': '\u220B',
        'ReverseEquilibrium': '\u21CB',
        'ReverseUpEquilibrium': '\u296F',
        'rfisht': '\u297D',
        'rfloor': '\u230B',
        'rfr': '\uD835\uDD2F',
        'Rfr': 'ℜ',
        'rHar': '\u2964',
        'rhard': '\u21C1',
        'rharu': '\u21C0',
        'rharul': '\u296C',
        'rho': 'ρ',
        'Rho': 'Ρ',
        'rhov': 'ϱ',
        'RightAngleBracket': '\u27E9',
        'rightarrow': '\u2192',
        'Rightarrow': '\u21D2',
        'RightArrow': '\u2192',
        'RightArrowBar': '\u21E5',
        'RightArrowLeftArrow': '\u21C4',
        'rightarrowtail': '\u21A3',
        'RightCeiling': '\u2309',
        'RightDoubleBracket': '\u27E7',
        'RightDownTeeVector': '\u295D',
        'RightDownVector': '\u21C2',
        'RightDownVectorBar': '\u2955',
        'RightFloor': '\u230B',
        'rightharpoondown': '\u21C1',
        'rightharpoonup': '\u21C0',
        'rightleftarrows': '\u21C4',
        'rightleftharpoons': '\u21CC',
        'rightrightarrows': '\u21C9',
        'rightsquigarrow': '\u219D',
        'RightTee': '\u22A2',
        'RightTeeArrow': '\u21A6',
        'RightTeeVector': '\u295B',
        'rightthreetimes': '\u22CC',
        'RightTriangle': '\u22B3',
        'RightTriangleBar': '\u29D0',
        'RightTriangleEqual': '\u22B5',
        'RightUpDownVector': '\u294F',
        'RightUpTeeVector': '\u295C',
        'RightUpVector': '\u21BE',
        'RightUpVectorBar': '\u2954',
        'RightVector': '\u21C0',
        'RightVectorBar': '\u2953',
        'ring': '\u02DA',
        'risingdotseq': '\u2253',
        'rlarr': '\u21C4',
        'rlhar': '\u21CC',
        'rlm': '\u200F',
        'rmoust': '\u23B1',
        'rmoustache': '\u23B1',
        'rnmid': '\u2AEE',
        'roang': '\u27ED',
        'roarr': '\u21FE',
        'robrk': '\u27E7',
        'ropar': '\u2986',
        'ropf': '\uD835\uDD63',
        'Ropf': 'ℝ',
        'roplus': '\u2A2E',
        'rotimes': '\u2A35',
        'RoundImplies': '\u2970',
        'rpar': ')',
        'rpargt': '\u2994',
        'rppolint': '\u2A12',
        'rrarr': '\u21C9',
        'Rrightarrow': '\u21DB',
        'rsaquo': '\u203A',
        'rscr': '\uD835\uDCC7',
        'Rscr': 'ℛ',
        'rsh': '\u21B1',
        'Rsh': '\u21B1',
        'rsqb': ']',
        'rsquo': '\u2019',
        'rsquor': '\u2019',
        'rthree': '\u22CC',
        'rtimes': '\u22CA',
        'rtri': '\u25B9',
        'rtrie': '\u22B5',
        'rtrif': '\u25B8',
        'rtriltri': '\u29CE',
        'RuleDelayed': '\u29F4',
        'ruluhar': '\u2968',
        'rx': '\u211E',
        'sacute': 'ś',
        'Sacute': 'Ś',
        'sbquo': '\u201A',
        'sc': '\u227B',
        'Sc': '\u2ABC',
        'scap': '\u2AB8',
        'scaron': 'š',
        'Scaron': 'Š',
        'sccue': '\u227D',
        'sce': '\u2AB0',
        'scE': '\u2AB4',
        'scedil': 'ş',
        'Scedil': 'Ş',
        'scirc': 'ŝ',
        'Scirc': 'Ŝ',
        'scnap': '\u2ABA',
        'scnE': '\u2AB6',
        'scnsim': '\u22E9',
        'scpolint': '\u2A13',
        'scsim': '\u227F',
        'scy': 'с',
        'Scy': 'С',
        'sdot': '\u22C5',
        'sdotb': '\u22A1',
        'sdote': '\u2A66',
        'searhk': '\u2925',
        'searr': '\u2198',
        'seArr': '\u21D8',
        'searrow': '\u2198',
        'sect': '\xA7',
        'semi': ';',
        'seswar': '\u2929',
        'setminus': '\u2216',
        'setmn': '\u2216',
        'sext': '\u2736',
        'sfr': '\uD835\uDD30',
        'Sfr': '\uD835\uDD16',
        'sfrown': '\u2322',
        'sharp': '\u266F',
        'shchcy': 'щ',
        'SHCHcy': 'Щ',
        'shcy': 'ш',
        'SHcy': 'Ш',
        'ShortDownArrow': '\u2193',
        'ShortLeftArrow': '\u2190',
        'shortmid': '\u2223',
        'shortparallel': '\u2225',
        'ShortRightArrow': '\u2192',
        'ShortUpArrow': '\u2191',
        'shy': '\xAD',
        'sigma': 'σ',
        'Sigma': 'Σ',
        'sigmaf': 'ς',
        'sigmav': 'ς',
        'sim': '\u223C',
        'simdot': '\u2A6A',
        'sime': '\u2243',
        'simeq': '\u2243',
        'simg': '\u2A9E',
        'simgE': '\u2AA0',
        'siml': '\u2A9D',
        'simlE': '\u2A9F',
        'simne': '\u2246',
        'simplus': '\u2A24',
        'simrarr': '\u2972',
        'slarr': '\u2190',
        'SmallCircle': '\u2218',
        'smallsetminus': '\u2216',
        'smashp': '\u2A33',
        'smeparsl': '\u29E4',
        'smid': '\u2223',
        'smile': '\u2323',
        'smt': '\u2AAA',
        'smte': '\u2AAC',
        'smtes': '\u2AAC︀',
        'softcy': 'ь',
        'SOFTcy': 'Ь',
        'sol': '/',
        'solb': '\u29C4',
        'solbar': '\u233F',
        'sopf': '\uD835\uDD64',
        'Sopf': '\uD835\uDD4A',
        'spades': '\u2660',
        'spadesuit': '\u2660',
        'spar': '\u2225',
        'sqcap': '\u2293',
        'sqcaps': '\u2293︀',
        'sqcup': '\u2294',
        'sqcups': '\u2294︀',
        'Sqrt': '\u221A',
        'sqsub': '\u228F',
        'sqsube': '\u2291',
        'sqsubset': '\u228F',
        'sqsubseteq': '\u2291',
        'sqsup': '\u2290',
        'sqsupe': '\u2292',
        'sqsupset': '\u2290',
        'sqsupseteq': '\u2292',
        'squ': '\u25A1',
        'square': '\u25A1',
        'Square': '\u25A1',
        'SquareIntersection': '\u2293',
        'SquareSubset': '\u228F',
        'SquareSubsetEqual': '\u2291',
        'SquareSuperset': '\u2290',
        'SquareSupersetEqual': '\u2292',
        'SquareUnion': '\u2294',
        'squarf': '\u25AA',
        'squf': '\u25AA',
        'srarr': '\u2192',
        'sscr': '\uD835\uDCC8',
        'Sscr': '\uD835\uDCAE',
        'ssetmn': '\u2216',
        'ssmile': '\u2323',
        'sstarf': '\u22C6',
        'star': '\u2606',
        'Star': '\u22C6',
        'starf': '\u2605',
        'straightepsilon': 'ϵ',
        'straightphi': 'ϕ',
        'strns': '\xAF',
        'sub': '\u2282',
        'Sub': '\u22D0',
        'subdot': '\u2ABD',
        'sube': '\u2286',
        'subE': '\u2AC5',
        'subedot': '\u2AC3',
        'submult': '\u2AC1',
        'subne': '\u228A',
        'subnE': '\u2ACB',
        'subplus': '\u2ABF',
        'subrarr': '\u2979',
        'subset': '\u2282',
        'Subset': '\u22D0',
        'subseteq': '\u2286',
        'subseteqq': '\u2AC5',
        'SubsetEqual': '\u2286',
        'subsetneq': '\u228A',
        'subsetneqq': '\u2ACB',
        'subsim': '\u2AC7',
        'subsub': '\u2AD5',
        'subsup': '\u2AD3',
        'succ': '\u227B',
        'succapprox': '\u2AB8',
        'succcurlyeq': '\u227D',
        'Succeeds': '\u227B',
        'SucceedsEqual': '\u2AB0',
        'SucceedsSlantEqual': '\u227D',
        'SucceedsTilde': '\u227F',
        'succeq': '\u2AB0',
        'succnapprox': '\u2ABA',
        'succneqq': '\u2AB6',
        'succnsim': '\u22E9',
        'succsim': '\u227F',
        'SuchThat': '\u220B',
        'sum': '\u2211',
        'Sum': '\u2211',
        'sung': '\u266A',
        'sup': '\u2283',
        'Sup': '\u22D1',
        'sup1': '\xB9',
        'sup2': '\xB2',
        'sup3': '\xB3',
        'supdot': '\u2ABE',
        'supdsub': '\u2AD8',
        'supe': '\u2287',
        'supE': '\u2AC6',
        'supedot': '\u2AC4',
        'Superset': '\u2283',
        'SupersetEqual': '\u2287',
        'suphsol': '\u27C9',
        'suphsub': '\u2AD7',
        'suplarr': '\u297B',
        'supmult': '\u2AC2',
        'supne': '\u228B',
        'supnE': '\u2ACC',
        'supplus': '\u2AC0',
        'supset': '\u2283',
        'Supset': '\u22D1',
        'supseteq': '\u2287',
        'supseteqq': '\u2AC6',
        'supsetneq': '\u228B',
        'supsetneqq': '\u2ACC',
        'supsim': '\u2AC8',
        'supsub': '\u2AD4',
        'supsup': '\u2AD6',
        'swarhk': '\u2926',
        'swarr': '\u2199',
        'swArr': '\u21D9',
        'swarrow': '\u2199',
        'swnwar': '\u292A',
        'szlig': 'ß',
        'Tab': '\t',
        'target': '\u2316',
        'tau': 'τ',
        'Tau': 'Τ',
        'tbrk': '\u23B4',
        'tcaron': 'ť',
        'Tcaron': 'Ť',
        'tcedil': 'ţ',
        'Tcedil': 'Ţ',
        'tcy': 'т',
        'Tcy': 'Т',
        'tdot': '⃛',
        'telrec': '\u2315',
        'tfr': '\uD835\uDD31',
        'Tfr': '\uD835\uDD17',
        'there4': '\u2234',
        'therefore': '\u2234',
        'Therefore': '\u2234',
        'theta': 'θ',
        'Theta': 'Θ',
        'thetasym': 'ϑ',
        'thetav': 'ϑ',
        'thickapprox': '\u2248',
        'thicksim': '\u223C',
        'ThickSpace': '\u205F\u200A',
        'thinsp': '\u2009',
        'ThinSpace': '\u2009',
        'thkap': '\u2248',
        'thksim': '\u223C',
        'thorn': 'þ',
        'THORN': 'Þ',
        'tilde': '\u02DC',
        'Tilde': '\u223C',
        'TildeEqual': '\u2243',
        'TildeFullEqual': '\u2245',
        'TildeTilde': '\u2248',
        'times': '\xD7',
        'timesb': '\u22A0',
        'timesbar': '\u2A31',
        'timesd': '\u2A30',
        'tint': '\u222D',
        'toea': '\u2928',
        'top': '\u22A4',
        'topbot': '\u2336',
        'topcir': '\u2AF1',
        'topf': '\uD835\uDD65',
        'Topf': '\uD835\uDD4B',
        'topfork': '\u2ADA',
        'tosa': '\u2929',
        'tprime': '\u2034',
        'trade': '\u2122',
        'TRADE': '\u2122',
        'triangle': '\u25B5',
        'triangledown': '\u25BF',
        'triangleleft': '\u25C3',
        'trianglelefteq': '\u22B4',
        'triangleq': '\u225C',
        'triangleright': '\u25B9',
        'trianglerighteq': '\u22B5',
        'tridot': '\u25EC',
        'trie': '\u225C',
        'triminus': '\u2A3A',
        'TripleDot': '⃛',
        'triplus': '\u2A39',
        'trisb': '\u29CD',
        'tritime': '\u2A3B',
        'trpezium': '\u23E2',
        'tscr': '\uD835\uDCC9',
        'Tscr': '\uD835\uDCAF',
        'tscy': 'ц',
        'TScy': 'Ц',
        'tshcy': 'ћ',
        'TSHcy': 'Ћ',
        'tstrok': 'ŧ',
        'Tstrok': 'Ŧ',
        'twixt': '\u226C',
        'twoheadleftarrow': '\u219E',
        'twoheadrightarrow': '\u21A0',
        'uacute': 'ú',
        'Uacute': 'Ú',
        'uarr': '\u2191',
        'uArr': '\u21D1',
        'Uarr': '\u219F',
        'Uarrocir': '\u2949',
        'ubrcy': 'ў',
        'Ubrcy': 'Ў',
        'ubreve': 'ŭ',
        'Ubreve': 'Ŭ',
        'ucirc': 'û',
        'Ucirc': 'Û',
        'ucy': 'у',
        'Ucy': 'У',
        'udarr': '\u21C5',
        'udblac': 'ű',
        'Udblac': 'Ű',
        'udhar': '\u296E',
        'ufisht': '\u297E',
        'ufr': '\uD835\uDD32',
        'Ufr': '\uD835\uDD18',
        'ugrave': 'ù',
        'Ugrave': 'Ù',
        'uHar': '\u2963',
        'uharl': '\u21BF',
        'uharr': '\u21BE',
        'uhblk': '\u2580',
        'ulcorn': '\u231C',
        'ulcorner': '\u231C',
        'ulcrop': '\u230F',
        'ultri': '\u25F8',
        'umacr': 'ū',
        'Umacr': 'Ū',
        'uml': '\xA8',
        'UnderBar': '_',
        'UnderBrace': '\u23DF',
        'UnderBracket': '\u23B5',
        'UnderParenthesis': '\u23DD',
        'Union': '\u22C3',
        'UnionPlus': '\u228E',
        'uogon': 'ų',
        'Uogon': 'Ų',
        'uopf': '\uD835\uDD66',
        'Uopf': '\uD835\uDD4C',
        'uparrow': '\u2191',
        'Uparrow': '\u21D1',
        'UpArrow': '\u2191',
        'UpArrowBar': '\u2912',
        'UpArrowDownArrow': '\u21C5',
        'updownarrow': '\u2195',
        'Updownarrow': '\u21D5',
        'UpDownArrow': '\u2195',
        'UpEquilibrium': '\u296E',
        'upharpoonleft': '\u21BF',
        'upharpoonright': '\u21BE',
        'uplus': '\u228E',
        'UpperLeftArrow': '\u2196',
        'UpperRightArrow': '\u2197',
        'upsi': 'υ',
        'Upsi': 'ϒ',
        'upsih': 'ϒ',
        'upsilon': 'υ',
        'Upsilon': 'Υ',
        'UpTee': '\u22A5',
        'UpTeeArrow': '\u21A5',
        'upuparrows': '\u21C8',
        'urcorn': '\u231D',
        'urcorner': '\u231D',
        'urcrop': '\u230E',
        'uring': 'ů',
        'Uring': 'Ů',
        'urtri': '\u25F9',
        'uscr': '\uD835\uDCCA',
        'Uscr': '\uD835\uDCB0',
        'utdot': '\u22F0',
        'utilde': 'ũ',
        'Utilde': 'Ũ',
        'utri': '\u25B5',
        'utrif': '\u25B4',
        'uuarr': '\u21C8',
        'uuml': 'ü',
        'Uuml': 'Ü',
        'uwangle': '\u29A7',
        'vangrt': '\u299C',
        'varepsilon': 'ϵ',
        'varkappa': 'ϰ',
        'varnothing': '\u2205',
        'varphi': 'ϕ',
        'varpi': 'ϖ',
        'varpropto': '\u221D',
        'varr': '\u2195',
        'vArr': '\u21D5',
        'varrho': 'ϱ',
        'varsigma': 'ς',
        'varsubsetneq': '\u228A︀',
        'varsubsetneqq': '\u2ACB︀',
        'varsupsetneq': '\u228B︀',
        'varsupsetneqq': '\u2ACC︀',
        'vartheta': 'ϑ',
        'vartriangleleft': '\u22B2',
        'vartriangleright': '\u22B3',
        'vBar': '\u2AE8',
        'Vbar': '\u2AEB',
        'vBarv': '\u2AE9',
        'vcy': 'в',
        'Vcy': 'В',
        'vdash': '\u22A2',
        'vDash': '\u22A8',
        'Vdash': '\u22A9',
        'VDash': '\u22AB',
        'Vdashl': '\u2AE6',
        'vee': '\u2228',
        'Vee': '\u22C1',
        'veebar': '\u22BB',
        'veeeq': '\u225A',
        'vellip': '\u22EE',
        'verbar': '|',
        'Verbar': '\u2016',
        'vert': '|',
        'Vert': '\u2016',
        'VerticalBar': '\u2223',
        'VerticalLine': '|',
        'VerticalSeparator': '\u2758',
        'VerticalTilde': '\u2240',
        'VeryThinSpace': '\u200A',
        'vfr': '\uD835\uDD33',
        'Vfr': '\uD835\uDD19',
        'vltri': '\u22B2',
        'vnsub': '\u2282⃒',
        'vnsup': '\u2283⃒',
        'vopf': '\uD835\uDD67',
        'Vopf': '\uD835\uDD4D',
        'vprop': '\u221D',
        'vrtri': '\u22B3',
        'vscr': '\uD835\uDCCB',
        'Vscr': '\uD835\uDCB1',
        'vsubne': '\u228A︀',
        'vsubnE': '\u2ACB︀',
        'vsupne': '\u228B︀',
        'vsupnE': '\u2ACC︀',
        'Vvdash': '\u22AA',
        'vzigzag': '\u299A',
        'wcirc': 'ŵ',
        'Wcirc': 'Ŵ',
        'wedbar': '\u2A5F',
        'wedge': '\u2227',
        'Wedge': '\u22C0',
        'wedgeq': '\u2259',
        'weierp': '\u2118',
        'wfr': '\uD835\uDD34',
        'Wfr': '\uD835\uDD1A',
        'wopf': '\uD835\uDD68',
        'Wopf': '\uD835\uDD4E',
        'wp': '\u2118',
        'wr': '\u2240',
        'wreath': '\u2240',
        'wscr': '\uD835\uDCCC',
        'Wscr': '\uD835\uDCB2',
        'xcap': '\u22C2',
        'xcirc': '\u25EF',
        'xcup': '\u22C3',
        'xdtri': '\u25BD',
        'xfr': '\uD835\uDD35',
        'Xfr': '\uD835\uDD1B',
        'xharr': '\u27F7',
        'xhArr': '\u27FA',
        'xi': 'ξ',
        'Xi': 'Ξ',
        'xlarr': '\u27F5',
        'xlArr': '\u27F8',
        'xmap': '\u27FC',
        'xnis': '\u22FB',
        'xodot': '\u2A00',
        'xopf': '\uD835\uDD69',
        'Xopf': '\uD835\uDD4F',
        'xoplus': '\u2A01',
        'xotime': '\u2A02',
        'xrarr': '\u27F6',
        'xrArr': '\u27F9',
        'xscr': '\uD835\uDCCD',
        'Xscr': '\uD835\uDCB3',
        'xsqcup': '\u2A06',
        'xuplus': '\u2A04',
        'xutri': '\u25B3',
        'xvee': '\u22C1',
        'xwedge': '\u22C0',
        'yacute': 'ý',
        'Yacute': 'Ý',
        'yacy': 'я',
        'YAcy': 'Я',
        'ycirc': 'ŷ',
        'Ycirc': 'Ŷ',
        'ycy': 'ы',
        'Ycy': 'Ы',
        'yen': '\xA5',
        'yfr': '\uD835\uDD36',
        'Yfr': '\uD835\uDD1C',
        'yicy': 'ї',
        'YIcy': 'Ї',
        'yopf': '\uD835\uDD6A',
        'Yopf': '\uD835\uDD50',
        'yscr': '\uD835\uDCCE',
        'Yscr': '\uD835\uDCB4',
        'yucy': 'ю',
        'YUcy': 'Ю',
        'yuml': 'ÿ',
        'Yuml': 'Ÿ',
        'zacute': 'ź',
        'Zacute': 'Ź',
        'zcaron': 'ž',
        'Zcaron': 'Ž',
        'zcy': 'з',
        'Zcy': 'З',
        'zdot': 'ż',
        'Zdot': 'Ż',
        'zeetrf': 'ℨ',
        'ZeroWidthSpace': '\u200B',
        'zeta': 'ζ',
        'Zeta': 'Ζ',
        'zfr': '\uD835\uDD37',
        'Zfr': 'ℨ',
        'zhcy': 'ж',
        'ZHcy': 'Ж',
        'zigrarr': '\u21DD',
        'zopf': '\uD835\uDD6B',
        'Zopf': 'ℤ',
        'zscr': '\uD835\uDCCF',
        'Zscr': '\uD835\uDCB5',
        'zwj': '‍',
        'zwnj': '‌'
    };
    var decodeMapLegacy = {
        'aacute': 'á',
        'Aacute': 'Á',
        'acirc': 'â',
        'Acirc': 'Â',
        'acute': '\xB4',
        'aelig': 'æ',
        'AElig': 'Æ',
        'agrave': 'à',
        'Agrave': 'À',
        'amp': '&',
        'AMP': '&',
        'aring': 'å',
        'Aring': 'Å',
        'atilde': 'ã',
        'Atilde': 'Ã',
        'auml': 'ä',
        'Auml': 'Ä',
        'brvbar': '\xA6',
        'ccedil': 'ç',
        'Ccedil': 'Ç',
        'cedil': '\xB8',
        'cent': '\xA2',
        'copy': '\xA9',
        'COPY': '\xA9',
        'curren': '\xA4',
        'deg': '\xB0',
        'divide': '\xF7',
        'eacute': 'é',
        'Eacute': 'É',
        'ecirc': 'ê',
        'Ecirc': 'Ê',
        'egrave': 'è',
        'Egrave': 'È',
        'eth': 'ð',
        'ETH': 'Ð',
        'euml': 'ë',
        'Euml': 'Ë',
        'frac12': '\xBD',
        'frac14': '\xBC',
        'frac34': '\xBE',
        'gt': '>',
        'GT': '>',
        'iacute': 'í',
        'Iacute': 'Í',
        'icirc': 'î',
        'Icirc': 'Î',
        'iexcl': '\xA1',
        'igrave': 'ì',
        'Igrave': 'Ì',
        'iquest': '\xBF',
        'iuml': 'ï',
        'Iuml': 'Ï',
        'laquo': '\xAB',
        'lt': '<',
        'LT': '<',
        'macr': '\xAF',
        'micro': 'µ',
        'middot': '\xB7',
        'nbsp': '\xA0',
        'not': '\xAC',
        'ntilde': 'ñ',
        'Ntilde': 'Ñ',
        'oacute': 'ó',
        'Oacute': 'Ó',
        'ocirc': 'ô',
        'Ocirc': 'Ô',
        'ograve': 'ò',
        'Ograve': 'Ò',
        'ordf': 'ª',
        'ordm': 'º',
        'oslash': 'ø',
        'Oslash': 'Ø',
        'otilde': 'õ',
        'Otilde': 'Õ',
        'ouml': 'ö',
        'Ouml': 'Ö',
        'para': '\xB6',
        'plusmn': '\xB1',
        'pound': '\xA3',
        'quot': '"',
        'QUOT': '"',
        'raquo': '\xBB',
        'reg': '\xAE',
        'REG': '\xAE',
        'sect': '\xA7',
        'shy': '\xAD',
        'sup1': '\xB9',
        'sup2': '\xB2',
        'sup3': '\xB3',
        'szlig': 'ß',
        'thorn': 'þ',
        'THORN': 'Þ',
        'times': '\xD7',
        'uacute': 'ú',
        'Uacute': 'Ú',
        'ucirc': 'û',
        'Ucirc': 'Û',
        'ugrave': 'ù',
        'Ugrave': 'Ù',
        'uml': '\xA8',
        'uuml': 'ü',
        'Uuml': 'Ü',
        'yacute': 'ý',
        'Yacute': 'Ý',
        'yen': '\xA5',
        'yuml': 'ÿ'
    };
    var decodeMapNumeric = {
        '0': '\uFFFD',
        '128': '\u20AC',
        '130': '\u201A',
        '131': 'ƒ',
        '132': '\u201E',
        '133': '\u2026',
        '134': '\u2020',
        '135': '\u2021',
        '136': 'ˆ',
        '137': '\u2030',
        '138': 'Š',
        '139': '\u2039',
        '140': 'Œ',
        '142': 'Ž',
        '145': '\u2018',
        '146': '\u2019',
        '147': '\u201C',
        '148': '\u201D',
        '149': '\u2022',
        '150': '\u2013',
        '151': '\u2014',
        '152': '\u02DC',
        '153': '\u2122',
        '154': 'š',
        '155': '\u203A',
        '156': 'œ',
        '158': 'ž',
        '159': 'Ÿ'
    };
    var invalidReferenceCodePoints = [
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        11,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        27,
        28,
        29,
        30,
        31,
        127,
        128,
        129,
        130,
        131,
        132,
        133,
        134,
        135,
        136,
        137,
        138,
        139,
        140,
        141,
        142,
        143,
        144,
        145,
        146,
        147,
        148,
        149,
        150,
        151,
        152,
        153,
        154,
        155,
        156,
        157,
        158,
        159,
        64976,
        64977,
        64978,
        64979,
        64980,
        64981,
        64982,
        64983,
        64984,
        64985,
        64986,
        64987,
        64988,
        64989,
        64990,
        64991,
        64992,
        64993,
        64994,
        64995,
        64996,
        64997,
        64998,
        64999,
        65000,
        65001,
        65002,
        65003,
        65004,
        65005,
        65006,
        65007,
        65534,
        65535,
        131070,
        131071,
        196606,
        196607,
        262142,
        262143,
        327678,
        327679,
        393214,
        393215,
        458750,
        458751,
        524286,
        524287,
        589822,
        589823,
        655358,
        655359,
        720894,
        720895,
        786430,
        786431,
        851966,
        851967,
        917502,
        917503,
        983038,
        983039,
        1048574,
        1048575,
        1114110,
        1114111
    ];
    var stringFromCharCode = String.fromCharCode;
    var object = {};
    var hasOwnProperty = object.hasOwnProperty;
    var has = function (object, propertyName) {
        return hasOwnProperty.call(object, propertyName);
    };
    var contains = function (array, value) {
        var index = -1;
        var length = array.length;
        while (++index < length) {
            if (array[index] == value) {
                return true;
            }
        }
        return false;
    };
    var merge = function (options, defaults) {
        if (!options) {
            return defaults;
        }
        var result = {};
        var key;
        for (key in defaults) {
            result[key] = has(options, key) ? options[key] : defaults[key];
        }
        return result;
    };
    var codePointToSymbol = function (codePoint, strict) {
        var output = '';
        if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
            if (strict) {
                parseError('character reference outside the permissible Unicode range');
            }
            return '\uFFFD';
        }
        if (has(decodeMapNumeric, codePoint)) {
            if (strict) {
                parseError('disallowed character reference');
            }
            return decodeMapNumeric[codePoint];
        }
        if (strict && contains(invalidReferenceCodePoints, codePoint)) {
            parseError('disallowed character reference');
        }
        if (codePoint > 65535) {
            codePoint -= 65536;
            output += stringFromCharCode(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
        }
        output += stringFromCharCode(codePoint);
        return output;
    };
    var hexEscape = function (codePoint) {
        return '&#x' + codePoint.toString(16).toUpperCase() + ';';
    };
    var decEscape = function (codePoint) {
        return '&#' + codePoint + ';';
    };
    var parseError = function (message) {
        throw Error('Parse error: ' + message);
    };
    var encode = function (string, options) {
        options = merge(options, encode.options);
        var strict = options.strict;
        if (strict && regexInvalidRawCodePoint.test(string)) {
            parseError('forbidden code point');
        }
        var encodeEverything = options.encodeEverything;
        var useNamedReferences = options.useNamedReferences;
        var allowUnsafeSymbols = options.allowUnsafeSymbols;
        var escapeCodePoint = options.decimal ? decEscape : hexEscape;
        var escapeBmpSymbol = function (symbol) {
            return escapeCodePoint(symbol.charCodeAt(0));
        };
        if (encodeEverything) {
            string = string.replace(regexAsciiWhitelist, function (symbol) {
                if (useNamedReferences && has(encodeMap, symbol)) {
                    return '&' + encodeMap[symbol] + ';';
                }
                return escapeBmpSymbol(symbol);
            });
            if (useNamedReferences) {
                string = string.replace(/&gt;\u20D2/g, '&nvgt;').replace(/&lt;\u20D2/g, '&nvlt;').replace(/&#x66;&#x6A;/g, '&fjlig;');
            }
            if (useNamedReferences) {
                string = string.replace(regexEncodeNonAscii, function (string) {
                    return '&' + encodeMap[string] + ';';
                });
            }
        } else if (useNamedReferences) {
            if (!allowUnsafeSymbols) {
                string = string.replace(regexEscape, function (string) {
                    return '&' + encodeMap[string] + ';';
                });
            }
            string = string.replace(/&gt;\u20D2/g, '&nvgt;').replace(/&lt;\u20D2/g, '&nvlt;');
            string = string.replace(regexEncodeNonAscii, function (string) {
                return '&' + encodeMap[string] + ';';
            });
        } else if (!allowUnsafeSymbols) {
            string = string.replace(regexEscape, escapeBmpSymbol);
        }
        return string.replace(regexAstralSymbols, function ($0) {
            var high = $0.charCodeAt(0);
            var low = $0.charCodeAt(1);
            var codePoint = (high - 55296) * 1024 + low - 56320 + 65536;
            return escapeCodePoint(codePoint);
        }).replace(regexBmpWhitelist, escapeBmpSymbol);
    };
    encode.options = {
        'allowUnsafeSymbols': false,
        'encodeEverything': false,
        'strict': false,
        'useNamedReferences': false,
        'decimal': false
    };
    var decode = function (html, options) {
        options = merge(options, decode.options);
        var strict = options.strict;
        if (strict && regexInvalidEntity.test(html)) {
            parseError('malformed character reference');
        }
        return html.replace(regexDecode, function ($0, $1, $2, $3, $4, $5, $6, $7) {
            var codePoint;
            var semicolon;
            var decDigits;
            var hexDigits;
            var reference;
            var next;
            if ($1) {
                decDigits = $1;
                semicolon = $2;
                if (strict && !semicolon) {
                    parseError('character reference was not terminated by a semicolon');
                }
                codePoint = parseInt(decDigits, 10);
                return codePointToSymbol(codePoint, strict);
            }
            if ($3) {
                hexDigits = $3;
                semicolon = $4;
                if (strict && !semicolon) {
                    parseError('character reference was not terminated by a semicolon');
                }
                codePoint = parseInt(hexDigits, 16);
                return codePointToSymbol(codePoint, strict);
            }
            if ($5) {
                reference = $5;
                if (has(decodeMap, reference)) {
                    return decodeMap[reference];
                } else {
                    if (strict) {
                        parseError('named character reference was not terminated by a semicolon');
                    }
                    return $0;
                }
            }
            reference = $6;
            next = $7;
            if (next && options.isAttributeValue) {
                if (strict && next == '=') {
                    parseError('`&` did not start a character reference');
                }
                return $0;
            } else {
                if (strict) {
                    parseError('named character reference was not terminated by a semicolon');
                }
                return decodeMapLegacy[reference] + (next || '');
            }
        });
    };
    decode.options = {
        'isAttributeValue': false,
        'strict': false
    };
    var escape = function (string) {
        return string.replace(regexEscape, function ($0) {
            return escapeMap[$0];
        });
    };
    var he = {
        'version': '1.1.1',
        'encode': encode,
        'decode': decode,
        'escape': escape,
        'unescape': decode
    };
    if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
        define('he@1.1.1#he', function () {
            return he;
        });
    } else if (freeExports && !freeExports.nodeType) {
        if (freeModule) {
            freeModule.exports = he;
        } else {
            for (var key in he) {
                has(he, key) && (freeExports[key] = he[key]);
            }
        }
    } else {
        root.he = he;
    }
}(this));
/*can-simple-dom@1.0.5#simple-dom/html-parser*/
define('can-simple-dom@1.0.5#simple-dom/html-parser', ['he'], function ($__0) {
    'use strict';
    if (!$__0 || !$__0.__esModule)
        $__0 = { default: $__0 };
    var he = $__0.default;
    function HTMLParser(tokenize, document, voidMap) {
        this.tokenize = tokenize;
        this.document = document;
        this.voidMap = voidMap;
        this.parentStack = [];
    }
    HTMLParser.prototype.isVoid = function (element) {
        return this.voidMap[element.nodeName] === true;
    };
    HTMLParser.prototype.pushElement = function (token) {
        var el = this.document.createElement(token.tagName);
        for (var i = 0; i < token.attributes.length; i++) {
            var attr = token.attributes[i];
            if (attr[0] !== 'href' && attr[0] !== 'src') {
                attr[1] = he.encode(attr[1]);
            }
            el.setAttribute(attr[0], attr[1]);
        }
        if (this.isVoid(el) || token.selfClosing) {
            return this.appendChild(el);
        }
        this.parentStack.push(el);
    };
    HTMLParser.prototype.popElement = function (token) {
        var el = this.parentStack.pop();
        if (el.nodeName !== token.tagName.toUpperCase()) {
            throw new Error('unbalanced tag');
        }
        this.appendChild(el);
    };
    HTMLParser.prototype.appendText = function (token) {
        var content = he.encode(token.chars);
        var text = this.document.createTextNode(content);
        this.appendChild(text);
    };
    HTMLParser.prototype.appendComment = function (token) {
        var comment = this.document.createComment(token.chars);
        this.appendChild(comment);
    };
    HTMLParser.prototype.appendChild = function (node) {
        var parentNode = this.parentStack[this.parentStack.length - 1];
        parentNode.appendChild(node);
    };
    HTMLParser.prototype.parse = function (html) {
        var fragment = this.document.createDocumentFragment();
        this.parentStack.push(fragment);
        var tokens = this.tokenize(html);
        for (var i = 0, l = tokens.length; i < l; i++) {
            var token = tokens[i];
            switch (token.type) {
            case 'StartTag':
                this.pushElement(token);
                break;
            case 'EndTag':
                this.popElement(token);
                break;
            case 'Chars':
                this.appendText(token);
                break;
            case 'Comment':
                this.appendComment(token);
                break;
            }
        }
        return this.parentStack.pop();
    };
    var $__default = HTMLParser;
    return {
        get default() {
            return $__default;
        },
        __esModule: true
    };
});
/*can-simple-dom@1.0.5#simple-dom/html-serializer*/
define('can-simple-dom@1.0.5#simple-dom/html-serializer', [], function () {
    'use strict';
    var REG_ESCAPE_ALL = /[<>&]/g;
    var REG_ESCAPE_PRESERVE_ENTITIES = /[<>]|&(?:#?[a-zA-Z0-9]+;)?/g;
    function HTMLSerializer(voidMap) {
        this.voidMap = voidMap;
    }
    HTMLSerializer.prototype.openTag = function (element) {
        return '<' + element.nodeName.toLowerCase() + this.attributes(element.attributes) + '>';
    };
    HTMLSerializer.prototype.closeTag = function (element) {
        return '</' + element.nodeName.toLowerCase() + '>';
    };
    HTMLSerializer.prototype.isVoid = function (element) {
        return this.voidMap[element.nodeName] === true;
    };
    HTMLSerializer.prototype.attributes = function (namedNodeMap) {
        var buffer = '';
        for (var i = 0, l = namedNodeMap.length; i < l; i++) {
            buffer += this.attr(namedNodeMap[i]);
        }
        return buffer;
    };
    HTMLSerializer.prototype.escapeAttrValue = function (attrValue) {
        return attrValue.replace(/"|&(?:#?[a-zA-Z0-9]+;)?/g, function (match) {
            switch (match) {
            case '&':
                return '&amp;';
            case '"':
                return '&quot;';
            default:
                return match;
            }
        });
    };
    HTMLSerializer.prototype.attr = function (attr) {
        if (!attr.specified) {
            return '';
        }
        if (attr.value) {
            if (attr.name === 'href' || attr.name === 'src') {
                return ' ' + attr.name + '="' + attr.value + '"';
            }
            return ' ' + attr.name + '="' + this.escapeAttrValue(attr.value) + '"';
        }
        return ' ' + attr.name;
    };
    HTMLSerializer.prototype.escapeText = function (textNodeValue, escapeAll) {
        return textNodeValue.replace(escapeAll ? REG_ESCAPE_ALL : REG_ESCAPE_PRESERVE_ENTITIES, function (match) {
            switch (match) {
            case '&':
                return '&amp;';
            case '<':
                return '&lt;';
            case '>':
                return '&gt;';
            default:
                return match;
            }
        });
    };
    HTMLSerializer.prototype.text = function (text) {
        var parentNode = text.parentNode;
        if (parentNode && (parentNode.nodeName === 'STYLE' || parentNode.nodeName === 'SCRIPT')) {
            return text.nodeValue;
        }
        return this.escapeText(text.nodeValue);
    };
    HTMLSerializer.prototype.comment = function (comment) {
        return '<!--' + comment.nodeValue + '-->';
    };
    HTMLSerializer.prototype.serialize = function (node) {
        var buffer = '';
        var next;
        switch (node.nodeType) {
        case 1:
            buffer += this.openTag(node);
            break;
        case 3:
            buffer += this.text(node);
            break;
        case 8:
            buffer += this.comment(node);
            break;
        default:
            break;
        }
        next = node.firstChild;
        if (next) {
            while (next) {
                buffer += this.serialize(next);
                next = next.nextSibling;
            }
        } else if (node.nodeType === 1 && node.textContent) {
            buffer += this.escapeText(node.textContent, true);
        }
        if (node.nodeType === 1 && !this.isVoid(node)) {
            buffer += this.closeTag(node);
        }
        return buffer;
    };
    var $__default = HTMLSerializer;
    return {
        get default() {
            return $__default;
        },
        __esModule: true
    };
});
/*can-simple-dom@1.0.5#simple-dom/void-map*/
define('can-simple-dom@1.0.5#simple-dom/void-map', [], function () {
    'use strict';
    var $__default = {
        AREA: true,
        BASE: true,
        BR: true,
        COL: true,
        COMMAND: true,
        EMBED: true,
        HR: true,
        IMG: true,
        INPUT: true,
        KEYGEN: true,
        LINK: true,
        META: true,
        PARAM: true,
        SOURCE: true,
        TRACK: true,
        WBR: true
    };
    return {
        get default() {
            return $__default;
        },
        __esModule: true
    };
});
/*can-simple-dom@1.0.5#simple-dom/dom*/
define('can-simple-dom@1.0.5#simple-dom/dom', [
    './document/node',
    './document/element',
    './document',
    './event',
    './html-parser',
    './html-serializer',
    './void-map'
], function ($__0, $__2, $__4, $__6, $__8, $__10, $__12) {
    'use strict';
    if (!$__0 || !$__0.__esModule)
        $__0 = { default: $__0 };
    if (!$__2 || !$__2.__esModule)
        $__2 = { default: $__2 };
    if (!$__4 || !$__4.__esModule)
        $__4 = { default: $__4 };
    if (!$__6 || !$__6.__esModule)
        $__6 = { default: $__6 };
    if (!$__8 || !$__8.__esModule)
        $__8 = { default: $__8 };
    if (!$__10 || !$__10.__esModule)
        $__10 = { default: $__10 };
    if (!$__12 || !$__12.__esModule)
        $__12 = { default: $__12 };
    var Node = $__0.default;
    var Element = $__2.default;
    var Document = $__4.default;
    var Event = $__6.default;
    var HTMLParser = $__8.default;
    var HTMLSerializer = $__10.default;
    var voidMap = $__12.default;
    function createDocument(serializer, parser) {
        var doc = new Document();
        doc.__serializer = serializer;
        doc.__parser = parser;
        return doc;
    }
    return {
        get Node() {
            return Node;
        },
        get Element() {
            return Element;
        },
        get Document() {
            return Document;
        },
        get Event() {
            return Event;
        },
        get HTMLParser() {
            return HTMLParser;
        },
        get HTMLSerializer() {
            return HTMLSerializer;
        },
        get voidMap() {
            return voidMap;
        },
        get createDocument() {
            return createDocument;
        },
        __esModule: true
    };
});
/*can-simple-dom@1.0.5#simple-dom*/
define('can-simple-dom@1.0.5#simple-dom', [
    './simple-dom/dom',
    './simple-dom/dom'
], function ($__0, $__1) {
    'use strict';
    if (!$__0 || !$__0.__esModule)
        $__0 = { default: $__0 };
    if (!$__1 || !$__1.__esModule)
        $__1 = { default: $__1 };
    var SimpleDOM = $__0;
    if (typeof window !== 'undefined') {
        window.SimpleDOM = SimpleDOM;
    }
    var $__simple_45_dom_47_dom__ = $__1;
    return $traceurRuntime.exportStar({ __esModule: true }, $__simple_45_dom_47_dom__);
});
/*can-view-target@3.0.7#test/test*/
define('can-view-target@3.0.7#test/test', function (require, exports, module) {
    var target = require('can-view-target');
    var simpleDom = require('can-simple-dom');
    var QUnit = require('steal-qunit');
    var MUTATION_OBSERVER = require('can-util/dom/mutation-observer/mutation-observer');
    QUnit.module('can-view-target');
    test('basics', function () {
        var classCallback = function () {
                equal(this.nodeName.toLowerCase(), 'h1', 'class on the right element');
                this.className = 'selected';
            }, attributesCallback = function () {
                equal(this.nodeName.toLowerCase(), 'h1', 'attributes on the right element');
            }, textNodeCallback = function () {
                equal(this.nodeType, 3, 'got a text node');
                this.nodeValue = 'World';
            };
        var data = target([{
                tag: 'h1',
                attrs: {
                    'id': 'myh1',
                    'class': classCallback
                },
                attributes: [attributesCallback],
                children: [{
                        tag: 'span',
                        children: [
                            'Hello ',
                            textNodeCallback,
                            '!'
                        ]
                    }]
            }]);
        equal(data.clone.childNodes.length, 1, 'there is one child');
        var h1 = data.clone.childNodes[0];
        equal(h1.nodeName.toLowerCase(), 'h1', 'there is one h1');
        equal(h1.id, 'myh1', 'the h1 has the right id');
        equal(h1.childNodes.length, 1, 'the h1 has span');
        equal(h1.childNodes[0].childNodes.length, 3, 'the span has 3 children');
        deepEqual(data.paths, [{
                path: [0],
                callbacks: [
                    { callback: classCallback },
                    { callback: attributesCallback }
                ],
                paths: [{
                        path: [
                            0,
                            1
                        ],
                        callbacks: [{ callback: target.keepsTextNodes ? textNodeCallback : data.paths[0].paths[0].callbacks[0].callback }]
                    }]
            }]);
        var result = data.hydrate();
        var newH1 = result.childNodes[0];
        equal(newH1.className, 'selected', 'got selected class name');
        equal(newH1.innerHTML.toLowerCase(), '<span>hello world!</span>');
    });
    test('replacing items', function () {
        var data = target([
            function () {
                this.parentNode.insertBefore(document.createTextNode('inserted'), this.nextSibling);
            },
            'hi',
            function () {
                equal(this.previousSibling.nodeValue, 'hi', 'previous is as expected');
            }
        ]);
        data.hydrate();
    });
    test('comments', function () {
        var data = target([
            { tag: 'h1' },
            { comment: 'foo bar' }
        ]);
        var node = data.clone.childNodes[1];
        equal(node.nodeValue, 'foo bar', 'node value is right');
        equal(node.nodeType, 8, 'node is a comment');
    });
    test('paths should be run in reverse order (#966)', function () {
        var data = target([{
                tag: 'h1',
                attributes: [function () {
                    }],
                children: [
                    function () {
                        this.parentNode.insertBefore(document.createElement('div'), this.nextSibling);
                    },
                    {
                        tag: 'span',
                        children: [function () {
                                equal(this.nodeType, 3, 'got an element');
                            }]
                    }
                ]
            }]);
        data.hydrate();
    });
    test('renderToVirtualDOM', function () {
        var simpleDocument = new simpleDom.Document();
        var innerData = target([{ tag: 'span' }], simpleDocument);
        var outerData = target([{
                tag: 'h1',
                children: [
                    function (data) {
                        this.parentNode.insertBefore(innerData.hydrate(data), this);
                        this.parentNode.removeChild(this);
                    },
                    'foo'
                ]
            }], simpleDocument);
        var out = outerData.hydrate({ foo: true });
        equal(out.firstChild.nodeName, 'H1');
        equal(out.firstChild.firstChild.nodeName, 'SPAN');
        equal(out.firstChild.lastChild.nodeValue, 'foo');
    });
    test('cloneNode works in IE11', function () {
        var frag = document.createDocumentFragment();
        var text = document.createTextNode('some-text');
        var MO = MUTATION_OBSERVER();
        var observer;
        frag.appendChild(text);
        var clone = target.cloneNode(frag);
        equal(clone.childNodes.length, 1, 'cloneNode should work');
        if (MO) {
            observer = new MO(function (mutations) {
            });
            observer.observe(document.documentElement, {
                childList: true,
                subtree: true
            });
            clone = target.cloneNode(frag);
            equal(clone.childNodes.length, 1, 'cloneNode should work after creating MutationObserver');
        }
    });
});
/*can-simple-dom@1.0.5#test/support*/
define('can-simple-dom@1.0.5#test/support', ['can-simple-dom/simple-dom/document'], function ($__0) {
    'use strict';
    if (!$__0 || !$__0.__esModule)
        $__0 = { default: $__0 };
    var Document = $__0.default;
    var root = typeof window !== 'undefined' ? window : global;
    var document;
    document = new Document();
    function element(tagName, attrs) {
        var el = document.createElement(tagName);
        for (var key in attrs) {
            el.setAttribute(key, attrs[key]);
        }
        for (var i = 2; i < arguments.length; i++) {
            el.appendChild(arguments[i]);
        }
        return el;
    }
    function fragment() {
        var frag = document.createDocumentFragment();
        for (var i = 0; i < arguments.length; i++) {
            frag.appendChild(arguments[i]);
        }
        return frag;
    }
    function text(s) {
        return document.createTextNode(s);
    }
    function comment(s) {
        return document.createComment(s);
    }
    return {
        get document() {
            return document;
        },
        get element() {
            return element;
        },
        get fragment() {
            return fragment;
        },
        get text() {
            return text;
        },
        get comment() {
            return comment;
        },
        __esModule: true
    };
});
/*can-simple-dom@1.0.5#test/element-test*/
define('can-simple-dom@1.0.5#test/element-test', [
    'can-simple-dom/simple-dom/document',
    'can-simple-dom/simple-dom/html-serializer',
    'can-simple-dom/simple-dom/void-map',
    './support',
    'steal-qunit'
], function ($__0, $__2, $__4, $__6, $__8) {
    'use strict';
    if (!$__0 || !$__0.__esModule)
        $__0 = { default: $__0 };
    if (!$__2 || !$__2.__esModule)
        $__2 = { default: $__2 };
    if (!$__4 || !$__4.__esModule)
        $__4 = { default: $__4 };
    if (!$__6 || !$__6.__esModule)
        $__6 = { default: $__6 };
    if (!$__8 || !$__8.__esModule)
        $__8 = { default: $__8 };
    var Document = $__0.default;
    var Serializer = $__2.default;
    var voidMap = $__4.default;
    var $__7 = $__6, element = $__7.element, fragment = $__7.fragment, text = $__7.text;
    var QUnit = $__8.default;
    QUnit.module('can-simple-dom - Element');
    QUnit.test('appending a document fragment appends the fragment\'s children and not the fragment itself', function (assert) {
        var document = new Document();
        var frag = document.createDocumentFragment();
        var elem = document.createElement('div');
        var body = document.body;
        assert.strictEqual(body.firstChild, null, 'body has no children');
        frag.appendChild(elem);
        body.appendChild(frag);
        assert.strictEqual(body.firstChild.tagName, 'DIV', 'fragment\'s child is added as child of document');
    });
    QUnit.test('appending a document fragment (via insertBefore) appends the fragment\'s children and not the fragment itself', function (assert) {
        var document = new Document();
        var frag = document.createDocumentFragment();
        var elem = document.createElement('div');
        var existing = document.createElement('main');
        var body = document.body;
        body.appendChild(existing);
        assert.strictEqual(body.firstChild.tagName, 'MAIN', 'sanity check: the main element was actually inserted');
        assert.strictEqual(body.lastChild.tagName, 'MAIN', 'sanity check: the main element was actually inserted');
        frag.appendChild(elem);
        body.insertBefore(frag, existing);
        assert.strictEqual(body.firstChild.tagName, 'DIV', 'The body\'s first child is now DIV');
        assert.strictEqual(body.lastChild.tagName, 'MAIN', 'The body\'s last child is now MAIN');
    });
    QUnit.test('child nodes can be access via item()', function (assert) {
        var document = new Document();
        var parent = document.createElement('div');
        var child1 = document.createElement('p');
        var child2 = document.createElement('img');
        assert.strictEqual(parent.childNodes.item(0), null, 'attempting to access an item that doesn\'t exist returns null');
        parent.appendChild(child1);
        parent.appendChild(child2);
        assert.strictEqual(parent.childNodes.item(0), child1);
        assert.strictEqual(parent.childNodes.item(1), child2);
        assert.strictEqual(parent.childNodes.item(2), null);
        parent.removeChild(child1);
        assert.strictEqual(parent.childNodes.item(0), child2);
        assert.strictEqual(parent.childNodes.item(1), null);
        parent.removeChild(child2);
        assert.strictEqual(parent.childNodes.item(0), null);
        assert.strictEqual(parent.childNodes.item(1), null);
    });
    QUnit.test('insertBefore can insert before the last child node', function (assert) {
        var document = new Document();
        var parent = document.createElement('div');
        var child1 = document.createElement('p');
        var child2 = document.createElement('img');
        var child3 = document.createElement('span');
        parent.appendChild(child1);
        parent.appendChild(child2);
        parent.insertBefore(child3, child2);
        assert.strictEqual(parent.childNodes.item(1), child3);
    });
    QUnit.test('cloneNode(true) recursively clones nodes', function (assert) {
        var parent = element('div');
        var child1 = element('p');
        var child2 = element('img', { src: 'hamster.png' });
        var child3 = element('span');
        parent.appendChild(child1);
        parent.appendChild(child2);
        parent.appendChild(child3);
        var child11 = text('hello');
        var child12 = element('span');
        child12.appendChild(text(' world'));
        var child13 = text('!');
        child1.appendChild(child11);
        child1.appendChild(child12);
        child1.appendChild(child13);
        var clone = parent.cloneNode(true);
        assert.notEqual(parent.firstChild, null);
        assert.notStrictEqual(clone.firstChild, parent.firstChild);
        var clone2 = parent.cloneNode(true);
        assert.notEqual(parent.firstChild, null);
        assert.notStrictEqual(clone2.firstChild, clone.firstChild);
        assert.notStrictEqual(clone2.firstChild, parent.firstChild);
        var actual = new Serializer(voidMap).serialize(fragment(clone));
        assert.equal(actual, '<div><p>hello<span> world</span>!</p><img src="hamster.png"><span></span></div>');
    });
    QUnit.test('anchor element is created successfully - micro-location works (see #11)', function (assert) {
        assert.expect(0);
        var document = new Document();
        try {
            document.createElement('a');
        } catch (ex) {
            assert.ok(false, 'Anchor throws exception');
        }
    });
    QUnit.test('style.cssText is two way bound to the style attribute (#13)', function (assert) {
        var document = new Document();
        var el = document.createElement('div');
        el.style.cssText = 'color: green;';
        assert.equal(el.getAttribute('style'), 'color: green;');
    });
    QUnit.test('replaceChild works', function (assert) {
        var document = new Document();
        var parent = document.createElement('div');
        var one = document.createElement('p');
        var two = document.createElement('span');
        parent.appendChild(one);
        assert.equal(parent.firstChild.nodeName, 'P', 'first child is a p');
        var oldChild = parent.replaceChild(two, one);
        assert.equal(oldChild, one, 'correct return value');
        assert.equal(parent.firstChild.nodeName, 'SPAN', 'child is now the span');
    });
    QUnit.test('setAttribute(\'class\', value) updates the className', function (assert) {
        var document = new Document();
        var el = document.createElement('div');
        el.setAttribute('class', 'foo bar');
        assert.equal(el.className, 'foo bar', 'Element\'s className is same as the attribute class');
    });
    QUnit.test('innerHTML does not parse the contents of SCRIPT and STYLE nodes', function (assert) {
        var document = new Document();
        var div = document.createElement('div');
        var script = document.createElement('script');
        try {
            div.innerHTML = '<span>foo</span>';
            ok(0, 'should not make it here b/c no parser is shipped');
        } catch (ex) {
            ok(1, 'tried to parse content');
        }
        var jsCode = 'var foo = \'<span>bar</span>\';';
        try {
            script.innerHTML = jsCode;
            equal(script.firstChild, script.lastChild, 'script has one child');
            equal(script.firstChild.nodeType, 3, 'only child is a text node');
            equal(script.firstChild.nodeValue, jsCode, 'code matches');
        } catch (ex) {
            ok(0, 'should not cause an error');
        }
    });
    QUnit.test('removeChild should return the removed node', function (assert) {
        var document = new Document();
        var parent = document.createElement('div');
        var child = document.createElement('p');
        parent.appendChild(child);
        var removedNode = parent.removeChild(child);
        assert.strictEqual(removedNode, child, 'removeChild should return the removed node');
    });
    QUnit.test('Input\'s type property is two-way bound to the attribute', function (assert) {
        var document = new Document();
        var input = document.createElement('input');
        input.setAttribute('type', 'text');
        assert.equal(input.type, 'text');
        input.type = 'radio';
        assert.equal(input.type, 'radio');
        assert.equal(input.getAttribute('type'), 'radio');
    });
    QUnit.test('Input\'s value property is two-way bound to the attribute', function (assert) {
        var document = new Document();
        var input = document.createElement('input');
        input.setAttribute('value', 'foo');
        assert.equal(input.value, 'foo');
        input.value = 'bar';
        assert.equal(input.value, 'bar');
        assert.equal(input.getAttribute('value'), 'bar');
    });
    QUnit.test('Input\'s checked value is two-way bound', function (assert) {
        var document = new Document();
        var input = document.createElement('input');
        input.setAttribute('checked', '');
        assert.ok(input.checked);
        input.checked = false;
        assert.equal(input.hasAttribute('checked'), false);
        assert.equal(input.checked, false);
    });
    QUnit.test('Select\'s value attribute is two-way bound', function (assert) {
        var document = new Document();
        var select = document.createElement('select');
        select.setAttribute('value', 'foo');
        assert.equal(select.value, 'foo');
        select.value = 'bar';
        assert.equal(select.value, 'bar');
        assert.equal(select.getAttribute('value'), 'bar');
    });
    QUnit.test('Option\'s value attribute is two-way bound', function (assert) {
        var document = new Document();
        var option = document.createElement('option');
        option.setAttribute('value', 'foo');
        assert.equal(option.value, 'foo');
        option.value = 'bar';
        assert.equal(option.value, 'bar');
        assert.equal(option.getAttribute('value'), 'bar');
    });
    QUnit.test('Option\'s selected value is tied to parent select\'s value', function (assert) {
        var document = new Document();
        var select = document.createElement('select');
        var option = document.createElement('option');
        select.appendChild(option);
        select.value = 'foo';
        option.value = 'foo';
        assert.equal(option.selected, true);
        option.value = 'bar';
        assert.equal(option.selected, false);
        option.selected = true;
        assert.equal(select.value, 'bar');
    });
    return {};
});
/*can-simple-dom@1.0.5#test/serializer-test*/
define('can-simple-dom@1.0.5#test/serializer-test', [
    './support',
    'can-simple-dom/simple-dom/html-serializer',
    'can-simple-dom/simple-dom/void-map',
    'steal-qunit'
], function ($__0, $__2, $__4, $__6) {
    'use strict';
    if (!$__0 || !$__0.__esModule)
        $__0 = { default: $__0 };
    if (!$__2 || !$__2.__esModule)
        $__2 = { default: $__2 };
    if (!$__4 || !$__4.__esModule)
        $__4 = { default: $__4 };
    if (!$__6 || !$__6.__esModule)
        $__6 = { default: $__6 };
    var $__1 = $__0, element = $__1.element, fragment = $__1.fragment, text = $__1.text;
    var Serializer = $__2.default;
    var voidMap = $__4.default;
    var QUnit = $__6.default;
    QUnit.module('can-simple-dom - Serializer', {
        beforeEach: function () {
            this.serializer = new Serializer(voidMap);
        }
    });
    QUnit.test('simple text', function (assert) {
        var actual = this.serializer.serialize(fragment(text('hello > world &amp; &nbsp;&nbsp; & goodbye')));
        assert.equal(actual, 'hello &gt; world &amp; &nbsp;&nbsp; &amp; goodbye');
    });
    QUnit.test('serializes correctly', function (assert) {
        var actual = this.serializer.serialize(fragment(element('div', {
            id: 'foo',
            title: '&amp;&"'
        }, element('b', {}, text('Foo & Bar &amp; Baz < Buz > Biz \xA9')))));
        assert.equal(actual, '<div id="foo" title="&amp;&amp;&quot;"><b>Foo &amp; Bar &amp; Baz &lt; Buz &gt; Biz \xA9</b></div>');
    });
    QUnit.test('serializes image correctly', function (assert) {
        var actual = this.serializer.serialize(fragment(element('img', { src: 'https://foo.com/foobar.jpg?foo=bar&bar=foo' })));
        assert.equal(actual, '<img src="https://foo.com/foobar.jpg?foo=bar&bar=foo">');
    });
    QUnit.test('serializes textContent', function (assert) {
        var el, actual, frag;
        el = element('div', {});
        el.textContent = 'hello world';
        actual = this.serializer.serialize(fragment(el));
        assert.equal(actual, '<div>hello world</div>');
    });
    return {};
});
/*simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/utils*/
define('simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/utils', [], function () {
    'use strict';
    var WSP = /[\t\n\f ]/;
    var ALPHA = /[A-Za-z]/;
    var CRLF = /\r\n?/g;
    function isSpace(char) {
        return WSP.test(char);
    }
    function isAlpha(char) {
        return ALPHA.test(char);
    }
    function preprocessInput(input) {
        return input.replace(CRLF, '\n');
    }
    return {
        get isSpace() {
            return isSpace;
        },
        get isAlpha() {
            return isAlpha;
        },
        get preprocessInput() {
            return preprocessInput;
        },
        __esModule: true
    };
});
/*simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/evented-tokenizer*/
define('simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/evented-tokenizer', ['./utils'], function ($__0) {
    'use strict';
    if (!$__0 || !$__0.__esModule)
        $__0 = { default: $__0 };
    var $__1 = $__0, preprocessInput = $__1.preprocessInput, isAlpha = $__1.isAlpha, isSpace = $__1.isSpace;
    function EventedTokenizer(delegate, entityParser) {
        this.delegate = delegate;
        this.entityParser = entityParser;
        this.state = null;
        this.input = null;
        this.index = -1;
        this.line = -1;
        this.column = -1;
        this.tagLine = -1;
        this.tagColumn = -1;
        this.reset();
    }
    EventedTokenizer.prototype = {
        reset: function () {
            this.state = 'beforeData';
            this.input = '';
            this.index = 0;
            this.line = 1;
            this.column = 0;
            this.tagLine = -1;
            this.tagColumn = -1;
            this.delegate.reset();
        },
        tokenize: function (input) {
            this.reset();
            this.tokenizePart(input);
            this.tokenizeEOF();
        },
        tokenizePart: function (input) {
            this.input += preprocessInput(input);
            while (this.index < this.input.length) {
                this.states[this.state].call(this);
            }
        },
        tokenizeEOF: function () {
            this.flushData();
        },
        flushData: function () {
            if (this.state === 'data') {
                this.delegate.finishData();
                this.state = 'beforeData';
            }
        },
        peek: function () {
            return this.input.charAt(this.index);
        },
        consume: function () {
            var char = this.peek();
            this.index++;
            if (char === '\n') {
                this.line++;
                this.column = 0;
            } else {
                this.column++;
            }
            return char;
        },
        consumeCharRef: function () {
            var endIndex = this.input.indexOf(';', this.index);
            if (endIndex === -1) {
                return;
            }
            var entity = this.input.slice(this.index, endIndex);
            var chars = this.entityParser.parse(entity);
            if (chars) {
                var count = entity.length;
                while (count) {
                    this.consume();
                    count--;
                }
                this.consume();
                return chars;
            }
        },
        markTagStart: function () {
            this.tagLine = this.line;
            this.tagColumn = this.column;
            if (this.delegate.tagOpen) {
                this.delegate.tagOpen();
            }
        },
        states: {
            beforeData: function () {
                var char = this.peek();
                if (char === '<') {
                    this.state = 'tagOpen';
                    this.markTagStart();
                    this.consume();
                } else {
                    this.state = 'data';
                    this.delegate.beginData();
                }
            },
            data: function () {
                var char = this.peek();
                if (char === '<') {
                    this.delegate.finishData();
                    this.state = 'tagOpen';
                    this.markTagStart();
                    this.consume();
                } else if (char === '&') {
                    this.consume();
                    this.delegate.appendToData(this.consumeCharRef() || '&');
                } else {
                    this.consume();
                    this.delegate.appendToData(char);
                }
            },
            tagOpen: function () {
                var char = this.consume();
                if (char === '!') {
                    this.state = 'markupDeclaration';
                } else if (char === '/') {
                    this.state = 'endTagOpen';
                } else if (isAlpha(char)) {
                    this.state = 'tagName';
                    this.delegate.beginStartTag();
                    this.delegate.appendToTagName(char.toLowerCase());
                }
            },
            markupDeclaration: function () {
                var char = this.consume();
                if (char === '-' && this.input.charAt(this.index) === '-') {
                    this.consume();
                    this.state = 'commentStart';
                    this.delegate.beginComment();
                }
            },
            commentStart: function () {
                var char = this.consume();
                if (char === '-') {
                    this.state = 'commentStartDash';
                } else if (char === '>') {
                    this.delegate.finishComment();
                    this.state = 'beforeData';
                } else {
                    this.delegate.appendToCommentData(char);
                    this.state = 'comment';
                }
            },
            commentStartDash: function () {
                var char = this.consume();
                if (char === '-') {
                    this.state = 'commentEnd';
                } else if (char === '>') {
                    this.delegate.finishComment();
                    this.state = 'beforeData';
                } else {
                    this.delegate.appendToCommentData('-');
                    this.state = 'comment';
                }
            },
            comment: function () {
                var char = this.consume();
                if (char === '-') {
                    this.state = 'commentEndDash';
                } else {
                    this.delegate.appendToCommentData(char);
                }
            },
            commentEndDash: function () {
                var char = this.consume();
                if (char === '-') {
                    this.state = 'commentEnd';
                } else {
                    this.delegate.appendToCommentData('-' + char);
                    this.state = 'comment';
                }
            },
            commentEnd: function () {
                var char = this.consume();
                if (char === '>') {
                    this.delegate.finishComment();
                    this.state = 'beforeData';
                } else {
                    this.delegate.appendToCommentData('--' + char);
                    this.state = 'comment';
                }
            },
            tagName: function () {
                var char = this.consume();
                if (isSpace(char)) {
                    this.state = 'beforeAttributeName';
                } else if (char === '/') {
                    this.state = 'selfClosingStartTag';
                } else if (char === '>') {
                    this.delegate.finishTag();
                    this.state = 'beforeData';
                } else {
                    this.delegate.appendToTagName(char);
                }
            },
            beforeAttributeName: function () {
                var char = this.peek();
                if (isSpace(char)) {
                    this.consume();
                    return;
                } else if (char === '/') {
                    this.state = 'selfClosingStartTag';
                    this.consume();
                } else if (char === '>') {
                    this.consume();
                    this.delegate.finishTag();
                    this.state = 'beforeData';
                } else {
                    this.state = 'attributeName';
                    this.delegate.beginAttribute();
                    this.consume();
                    this.delegate.appendToAttributeName(char);
                }
            },
            attributeName: function () {
                var char = this.peek();
                if (isSpace(char)) {
                    this.state = 'afterAttributeName';
                    this.consume();
                } else if (char === '/') {
                    this.delegate.beginAttributeValue(false);
                    this.delegate.finishAttributeValue();
                    this.consume();
                    this.state = 'selfClosingStartTag';
                } else if (char === '=') {
                    this.state = 'beforeAttributeValue';
                    this.consume();
                } else if (char === '>') {
                    this.delegate.beginAttributeValue(false);
                    this.delegate.finishAttributeValue();
                    this.consume();
                    this.delegate.finishTag();
                    this.state = 'beforeData';
                } else {
                    this.consume();
                    this.delegate.appendToAttributeName(char);
                }
            },
            afterAttributeName: function () {
                var char = this.peek();
                if (isSpace(char)) {
                    this.consume();
                    return;
                } else if (char === '/') {
                    this.delegate.beginAttributeValue(false);
                    this.delegate.finishAttributeValue();
                    this.consume();
                    this.state = 'selfClosingStartTag';
                } else if (char === '=') {
                    this.consume();
                    this.state = 'beforeAttributeValue';
                } else if (char === '>') {
                    this.delegate.beginAttributeValue(false);
                    this.delegate.finishAttributeValue();
                    this.consume();
                    this.delegate.finishTag();
                    this.state = 'beforeData';
                } else {
                    this.delegate.beginAttributeValue(false);
                    this.delegate.finishAttributeValue();
                    this.consume();
                    this.state = 'attributeName';
                    this.delegate.beginAttribute();
                    this.delegate.appendToAttributeName(char);
                }
            },
            beforeAttributeValue: function () {
                var char = this.peek();
                if (isSpace(char)) {
                    this.consume();
                } else if (char === '"') {
                    this.state = 'attributeValueDoubleQuoted';
                    this.delegate.beginAttributeValue(true);
                    this.consume();
                } else if (char === '\'') {
                    this.state = 'attributeValueSingleQuoted';
                    this.delegate.beginAttributeValue(true);
                    this.consume();
                } else if (char === '>') {
                    this.delegate.beginAttributeValue(false);
                    this.delegate.finishAttributeValue();
                    this.consume();
                    this.delegate.finishTag();
                    this.state = 'beforeData';
                } else {
                    this.state = 'attributeValueUnquoted';
                    this.delegate.beginAttributeValue(false);
                    this.consume();
                    this.delegate.appendToAttributeValue(char);
                }
            },
            attributeValueDoubleQuoted: function () {
                var char = this.consume();
                if (char === '"') {
                    this.delegate.finishAttributeValue();
                    this.state = 'afterAttributeValueQuoted';
                } else if (char === '&') {
                    this.delegate.appendToAttributeValue(this.consumeCharRef('"') || '&');
                } else {
                    this.delegate.appendToAttributeValue(char);
                }
            },
            attributeValueSingleQuoted: function () {
                var char = this.consume();
                if (char === '\'') {
                    this.delegate.finishAttributeValue();
                    this.state = 'afterAttributeValueQuoted';
                } else if (char === '&') {
                    this.delegate.appendToAttributeValue(this.consumeCharRef('\'') || '&');
                } else {
                    this.delegate.appendToAttributeValue(char);
                }
            },
            attributeValueUnquoted: function () {
                var char = this.peek();
                if (isSpace(char)) {
                    this.delegate.finishAttributeValue();
                    this.consume();
                    this.state = 'beforeAttributeName';
                } else if (char === '&') {
                    this.consume();
                    this.delegate.appendToAttributeValue(this.consumeCharRef('>') || '&');
                } else if (char === '>') {
                    this.delegate.finishAttributeValue();
                    this.consume();
                    this.delegate.finishTag();
                    this.state = 'beforeData';
                } else {
                    this.consume();
                    this.delegate.appendToAttributeValue(char);
                }
            },
            afterAttributeValueQuoted: function () {
                var char = this.peek();
                if (isSpace(char)) {
                    this.consume();
                    this.state = 'beforeAttributeName';
                } else if (char === '/') {
                    this.consume();
                    this.state = 'selfClosingStartTag';
                } else if (char === '>') {
                    this.consume();
                    this.delegate.finishTag();
                    this.state = 'beforeData';
                } else {
                    this.state = 'beforeAttributeName';
                }
            },
            selfClosingStartTag: function () {
                var char = this.peek();
                if (char === '>') {
                    this.consume();
                    this.delegate.markTagAsSelfClosing();
                    this.delegate.finishTag();
                    this.state = 'beforeData';
                } else {
                    this.state = 'beforeAttributeName';
                }
            },
            endTagOpen: function () {
                var char = this.consume();
                if (isAlpha(char)) {
                    this.state = 'tagName';
                    this.delegate.beginEndTag();
                    this.delegate.appendToTagName(char.toLowerCase());
                }
            }
        }
    };
    var $__default = EventedTokenizer;
    return {
        get default() {
            return $__default;
        },
        __esModule: true
    };
});
/*simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/tokenizer*/
define('simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/tokenizer', ['./evented-tokenizer'], function ($__0) {
    'use strict';
    if (!$__0 || !$__0.__esModule)
        $__0 = { default: $__0 };
    var EventedTokenizer = $__0.default;
    function Tokenizer(entityParser, options) {
        this.token = null;
        this.startLine = 1;
        this.startColumn = 0;
        this.options = options || {};
        this.tokenizer = new EventedTokenizer(this, entityParser);
    }
    Tokenizer.prototype = {
        tokenize: function (input) {
            this.tokens = [];
            this.tokenizer.tokenize(input);
            return this.tokens;
        },
        tokenizePart: function (input) {
            this.tokens = [];
            this.tokenizer.tokenizePart(input);
            return this.tokens;
        },
        tokenizeEOF: function () {
            this.tokens = [];
            this.tokenizer.tokenizeEOF();
            return this.tokens[0];
        },
        reset: function () {
            this.token = null;
            this.startLine = 1;
            this.startColumn = 0;
        },
        addLocInfo: function () {
            if (this.options.loc) {
                this.token.loc = {
                    start: {
                        line: this.startLine,
                        column: this.startColumn
                    },
                    end: {
                        line: this.tokenizer.line,
                        column: this.tokenizer.column
                    }
                };
            }
            this.startLine = this.tokenizer.line;
            this.startColumn = this.tokenizer.column;
        },
        beginData: function () {
            this.token = {
                type: 'Chars',
                chars: ''
            };
            this.tokens.push(this.token);
        },
        appendToData: function (char) {
            this.token.chars += char;
        },
        finishData: function () {
            this.addLocInfo();
        },
        beginComment: function () {
            this.token = {
                type: 'Comment',
                chars: ''
            };
            this.tokens.push(this.token);
        },
        appendToCommentData: function (char) {
            this.token.chars += char;
        },
        finishComment: function () {
            this.addLocInfo();
        },
        beginStartTag: function () {
            this.token = {
                type: 'StartTag',
                tagName: '',
                attributes: [],
                selfClosing: false
            };
            this.tokens.push(this.token);
        },
        beginEndTag: function () {
            this.token = {
                type: 'EndTag',
                tagName: ''
            };
            this.tokens.push(this.token);
        },
        finishTag: function () {
            this.addLocInfo();
        },
        markTagAsSelfClosing: function () {
            this.token.selfClosing = true;
        },
        appendToTagName: function (char) {
            this.token.tagName += char;
        },
        beginAttribute: function () {
            this._currentAttribute = [
                '',
                '',
                null
            ];
            this.token.attributes.push(this._currentAttribute);
        },
        appendToAttributeName: function (char) {
            this._currentAttribute[0] += char;
        },
        beginAttributeValue: function (isQuoted) {
            this._currentAttribute[2] = isQuoted;
        },
        appendToAttributeValue: function (char) {
            this._currentAttribute[1] = this._currentAttribute[1] || '';
            this._currentAttribute[1] += char;
        },
        finishAttributeValue: function () {
        }
    };
    var $__default = Tokenizer;
    return {
        get default() {
            return $__default;
        },
        __esModule: true
    };
});
/*simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/entity-parser*/
define('simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/entity-parser', [], function () {
    'use strict';
    function EntityParser(named) {
        this.named = named;
    }
    var HEXCHARCODE = /^#[xX]([A-Fa-f0-9]+)$/;
    var CHARCODE = /^#([0-9]+)$/;
    var NAMED = /^([A-Za-z0-9]+)$/;
    EntityParser.prototype.parse = function (entity) {
        if (!entity) {
            return;
        }
        var matches = entity.match(HEXCHARCODE);
        if (matches) {
            return String.fromCharCode(parseInt(matches[1], 16));
        }
        matches = entity.match(CHARCODE);
        if (matches) {
            return String.fromCharCode(parseInt(matches[1], 10));
        }
        matches = entity.match(NAMED);
        if (matches) {
            return this.named[matches[1]];
        }
    };
    var $__default = EntityParser;
    return {
        get default() {
            return $__default;
        },
        __esModule: true
    };
});
/*simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/html5-named-char-refs*/
define('simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/html5-named-char-refs', [], function () {
    'use strict';
    var $__default = {
        Aacute: 'Á',
        aacute: 'á',
        Abreve: 'Ă',
        abreve: 'ă',
        ac: '\u223E',
        acd: '\u223F',
        acE: '\u223E̳',
        Acirc: 'Â',
        acirc: 'â',
        acute: '\xB4',
        Acy: 'А',
        acy: 'а',
        AElig: 'Æ',
        aelig: 'æ',
        af: '\u2061',
        Afr: '\uD835\uDD04',
        afr: '\uD835\uDD1E',
        Agrave: 'À',
        agrave: 'à',
        alefsym: 'ℵ',
        aleph: 'ℵ',
        Alpha: 'Α',
        alpha: 'α',
        Amacr: 'Ā',
        amacr: 'ā',
        amalg: '\u2A3F',
        AMP: '&',
        amp: '&',
        And: '\u2A53',
        and: '\u2227',
        andand: '\u2A55',
        andd: '\u2A5C',
        andslope: '\u2A58',
        andv: '\u2A5A',
        ang: '\u2220',
        ange: '\u29A4',
        angle: '\u2220',
        angmsd: '\u2221',
        angmsdaa: '\u29A8',
        angmsdab: '\u29A9',
        angmsdac: '\u29AA',
        angmsdad: '\u29AB',
        angmsdae: '\u29AC',
        angmsdaf: '\u29AD',
        angmsdag: '\u29AE',
        angmsdah: '\u29AF',
        angrt: '\u221F',
        angrtvb: '\u22BE',
        angrtvbd: '\u299D',
        angsph: '\u2222',
        angst: 'Å',
        angzarr: '\u237C',
        Aogon: 'Ą',
        aogon: 'ą',
        Aopf: '\uD835\uDD38',
        aopf: '\uD835\uDD52',
        ap: '\u2248',
        apacir: '\u2A6F',
        apE: '\u2A70',
        ape: '\u224A',
        apid: '\u224B',
        apos: '\'',
        ApplyFunction: '\u2061',
        approx: '\u2248',
        approxeq: '\u224A',
        Aring: 'Å',
        aring: 'å',
        Ascr: '\uD835\uDC9C',
        ascr: '\uD835\uDCB6',
        Assign: '\u2254',
        ast: '*',
        asymp: '\u2248',
        asympeq: '\u224D',
        Atilde: 'Ã',
        atilde: 'ã',
        Auml: 'Ä',
        auml: 'ä',
        awconint: '\u2233',
        awint: '\u2A11',
        backcong: '\u224C',
        backepsilon: '\u03F6',
        backprime: '\u2035',
        backsim: '\u223D',
        backsimeq: '\u22CD',
        Backslash: '\u2216',
        Barv: '\u2AE7',
        barvee: '\u22BD',
        Barwed: '\u2306',
        barwed: '\u2305',
        barwedge: '\u2305',
        bbrk: '\u23B5',
        bbrktbrk: '\u23B6',
        bcong: '\u224C',
        Bcy: 'Б',
        bcy: 'б',
        bdquo: '\u201E',
        becaus: '\u2235',
        Because: '\u2235',
        because: '\u2235',
        bemptyv: '\u29B0',
        bepsi: '\u03F6',
        bernou: 'ℬ',
        Bernoullis: 'ℬ',
        Beta: 'Β',
        beta: 'β',
        beth: 'ℶ',
        between: '\u226C',
        Bfr: '\uD835\uDD05',
        bfr: '\uD835\uDD1F',
        bigcap: '\u22C2',
        bigcirc: '\u25EF',
        bigcup: '\u22C3',
        bigodot: '\u2A00',
        bigoplus: '\u2A01',
        bigotimes: '\u2A02',
        bigsqcup: '\u2A06',
        bigstar: '\u2605',
        bigtriangledown: '\u25BD',
        bigtriangleup: '\u25B3',
        biguplus: '\u2A04',
        bigvee: '\u22C1',
        bigwedge: '\u22C0',
        bkarow: '\u290D',
        blacklozenge: '\u29EB',
        blacksquare: '\u25AA',
        blacktriangle: '\u25B4',
        blacktriangledown: '\u25BE',
        blacktriangleleft: '\u25C2',
        blacktriangleright: '\u25B8',
        blank: '\u2423',
        blk12: '\u2592',
        blk14: '\u2591',
        blk34: '\u2593',
        block: '\u2588',
        bne: '=⃥',
        bnequiv: '\u2261⃥',
        bNot: '\u2AED',
        bnot: '\u2310',
        Bopf: '\uD835\uDD39',
        bopf: '\uD835\uDD53',
        bot: '\u22A5',
        bottom: '\u22A5',
        bowtie: '\u22C8',
        boxbox: '\u29C9',
        boxDL: '\u2557',
        boxDl: '\u2556',
        boxdL: '\u2555',
        boxdl: '\u2510',
        boxDR: '\u2554',
        boxDr: '\u2553',
        boxdR: '\u2552',
        boxdr: '\u250C',
        boxH: '\u2550',
        boxh: '\u2500',
        boxHD: '\u2566',
        boxHd: '\u2564',
        boxhD: '\u2565',
        boxhd: '\u252C',
        boxHU: '\u2569',
        boxHu: '\u2567',
        boxhU: '\u2568',
        boxhu: '\u2534',
        boxminus: '\u229F',
        boxplus: '\u229E',
        boxtimes: '\u22A0',
        boxUL: '\u255D',
        boxUl: '\u255C',
        boxuL: '\u255B',
        boxul: '\u2518',
        boxUR: '\u255A',
        boxUr: '\u2559',
        boxuR: '\u2558',
        boxur: '\u2514',
        boxV: '\u2551',
        boxv: '\u2502',
        boxVH: '\u256C',
        boxVh: '\u256B',
        boxvH: '\u256A',
        boxvh: '\u253C',
        boxVL: '\u2563',
        boxVl: '\u2562',
        boxvL: '\u2561',
        boxvl: '\u2524',
        boxVR: '\u2560',
        boxVr: '\u255F',
        boxvR: '\u255E',
        boxvr: '\u251C',
        bprime: '\u2035',
        Breve: '\u02D8',
        breve: '\u02D8',
        brvbar: '\xA6',
        Bscr: 'ℬ',
        bscr: '\uD835\uDCB7',
        bsemi: '\u204F',
        bsim: '\u223D',
        bsime: '\u22CD',
        bsol: '\\',
        bsolb: '\u29C5',
        bsolhsub: '\u27C8',
        bull: '\u2022',
        bullet: '\u2022',
        bump: '\u224E',
        bumpE: '\u2AAE',
        bumpe: '\u224F',
        Bumpeq: '\u224E',
        bumpeq: '\u224F',
        Cacute: 'Ć',
        cacute: 'ć',
        Cap: '\u22D2',
        cap: '\u2229',
        capand: '\u2A44',
        capbrcup: '\u2A49',
        capcap: '\u2A4B',
        capcup: '\u2A47',
        capdot: '\u2A40',
        CapitalDifferentialD: 'ⅅ',
        caps: '\u2229︀',
        caret: '\u2041',
        caron: 'ˇ',
        Cayleys: 'ℭ',
        ccaps: '\u2A4D',
        Ccaron: 'Č',
        ccaron: 'č',
        Ccedil: 'Ç',
        ccedil: 'ç',
        Ccirc: 'Ĉ',
        ccirc: 'ĉ',
        Cconint: '\u2230',
        ccups: '\u2A4C',
        ccupssm: '\u2A50',
        Cdot: 'Ċ',
        cdot: 'ċ',
        cedil: '\xB8',
        Cedilla: '\xB8',
        cemptyv: '\u29B2',
        cent: '\xA2',
        CenterDot: '\xB7',
        centerdot: '\xB7',
        Cfr: 'ℭ',
        cfr: '\uD835\uDD20',
        CHcy: 'Ч',
        chcy: 'ч',
        check: '\u2713',
        checkmark: '\u2713',
        Chi: 'Χ',
        chi: 'χ',
        cir: '\u25CB',
        circ: 'ˆ',
        circeq: '\u2257',
        circlearrowleft: '\u21BA',
        circlearrowright: '\u21BB',
        circledast: '\u229B',
        circledcirc: '\u229A',
        circleddash: '\u229D',
        CircleDot: '\u2299',
        circledR: '\xAE',
        circledS: '\u24C8',
        CircleMinus: '\u2296',
        CirclePlus: '\u2295',
        CircleTimes: '\u2297',
        cirE: '\u29C3',
        cire: '\u2257',
        cirfnint: '\u2A10',
        cirmid: '\u2AEF',
        cirscir: '\u29C2',
        ClockwiseContourIntegral: '\u2232',
        CloseCurlyDoubleQuote: '\u201D',
        CloseCurlyQuote: '\u2019',
        clubs: '\u2663',
        clubsuit: '\u2663',
        Colon: '\u2237',
        colon: ':',
        Colone: '\u2A74',
        colone: '\u2254',
        coloneq: '\u2254',
        comma: ',',
        commat: '@',
        comp: '\u2201',
        compfn: '\u2218',
        complement: '\u2201',
        complexes: 'ℂ',
        cong: '\u2245',
        congdot: '\u2A6D',
        Congruent: '\u2261',
        Conint: '\u222F',
        conint: '\u222E',
        ContourIntegral: '\u222E',
        Copf: 'ℂ',
        copf: '\uD835\uDD54',
        coprod: '\u2210',
        Coproduct: '\u2210',
        COPY: '\xA9',
        copy: '\xA9',
        copysr: '\u2117',
        CounterClockwiseContourIntegral: '\u2233',
        crarr: '\u21B5',
        Cross: '\u2A2F',
        cross: '\u2717',
        Cscr: '\uD835\uDC9E',
        cscr: '\uD835\uDCB8',
        csub: '\u2ACF',
        csube: '\u2AD1',
        csup: '\u2AD0',
        csupe: '\u2AD2',
        ctdot: '\u22EF',
        cudarrl: '\u2938',
        cudarrr: '\u2935',
        cuepr: '\u22DE',
        cuesc: '\u22DF',
        cularr: '\u21B6',
        cularrp: '\u293D',
        Cup: '\u22D3',
        cup: '\u222A',
        cupbrcap: '\u2A48',
        CupCap: '\u224D',
        cupcap: '\u2A46',
        cupcup: '\u2A4A',
        cupdot: '\u228D',
        cupor: '\u2A45',
        cups: '\u222A︀',
        curarr: '\u21B7',
        curarrm: '\u293C',
        curlyeqprec: '\u22DE',
        curlyeqsucc: '\u22DF',
        curlyvee: '\u22CE',
        curlywedge: '\u22CF',
        curren: '\xA4',
        curvearrowleft: '\u21B6',
        curvearrowright: '\u21B7',
        cuvee: '\u22CE',
        cuwed: '\u22CF',
        cwconint: '\u2232',
        cwint: '\u2231',
        cylcty: '\u232D',
        Dagger: '\u2021',
        dagger: '\u2020',
        daleth: 'ℸ',
        Darr: '\u21A1',
        dArr: '\u21D3',
        darr: '\u2193',
        dash: '\u2010',
        Dashv: '\u2AE4',
        dashv: '\u22A3',
        dbkarow: '\u290F',
        dblac: '\u02DD',
        Dcaron: 'Ď',
        dcaron: 'ď',
        Dcy: 'Д',
        dcy: 'д',
        DD: 'ⅅ',
        dd: 'ⅆ',
        ddagger: '\u2021',
        ddarr: '\u21CA',
        DDotrahd: '\u2911',
        ddotseq: '\u2A77',
        deg: '\xB0',
        Del: '\u2207',
        Delta: 'Δ',
        delta: 'δ',
        demptyv: '\u29B1',
        dfisht: '\u297F',
        Dfr: '\uD835\uDD07',
        dfr: '\uD835\uDD21',
        dHar: '\u2965',
        dharl: '\u21C3',
        dharr: '\u21C2',
        DiacriticalAcute: '\xB4',
        DiacriticalDot: '\u02D9',
        DiacriticalDoubleAcute: '\u02DD',
        DiacriticalGrave: '`',
        DiacriticalTilde: '\u02DC',
        diam: '\u22C4',
        Diamond: '\u22C4',
        diamond: '\u22C4',
        diamondsuit: '\u2666',
        diams: '\u2666',
        die: '\xA8',
        DifferentialD: 'ⅆ',
        digamma: 'ϝ',
        disin: '\u22F2',
        div: '\xF7',
        divide: '\xF7',
        divideontimes: '\u22C7',
        divonx: '\u22C7',
        DJcy: 'Ђ',
        djcy: 'ђ',
        dlcorn: '\u231E',
        dlcrop: '\u230D',
        dollar: '$',
        Dopf: '\uD835\uDD3B',
        dopf: '\uD835\uDD55',
        Dot: '\xA8',
        dot: '\u02D9',
        DotDot: '⃜',
        doteq: '\u2250',
        doteqdot: '\u2251',
        DotEqual: '\u2250',
        dotminus: '\u2238',
        dotplus: '\u2214',
        dotsquare: '\u22A1',
        doublebarwedge: '\u2306',
        DoubleContourIntegral: '\u222F',
        DoubleDot: '\xA8',
        DoubleDownArrow: '\u21D3',
        DoubleLeftArrow: '\u21D0',
        DoubleLeftRightArrow: '\u21D4',
        DoubleLeftTee: '\u2AE4',
        DoubleLongLeftArrow: '\u27F8',
        DoubleLongLeftRightArrow: '\u27FA',
        DoubleLongRightArrow: '\u27F9',
        DoubleRightArrow: '\u21D2',
        DoubleRightTee: '\u22A8',
        DoubleUpArrow: '\u21D1',
        DoubleUpDownArrow: '\u21D5',
        DoubleVerticalBar: '\u2225',
        DownArrow: '\u2193',
        Downarrow: '\u21D3',
        downarrow: '\u2193',
        DownArrowBar: '\u2913',
        DownArrowUpArrow: '\u21F5',
        DownBreve: '̑',
        downdownarrows: '\u21CA',
        downharpoonleft: '\u21C3',
        downharpoonright: '\u21C2',
        DownLeftRightVector: '\u2950',
        DownLeftTeeVector: '\u295E',
        DownLeftVector: '\u21BD',
        DownLeftVectorBar: '\u2956',
        DownRightTeeVector: '\u295F',
        DownRightVector: '\u21C1',
        DownRightVectorBar: '\u2957',
        DownTee: '\u22A4',
        DownTeeArrow: '\u21A7',
        drbkarow: '\u2910',
        drcorn: '\u231F',
        drcrop: '\u230C',
        Dscr: '\uD835\uDC9F',
        dscr: '\uD835\uDCB9',
        DScy: 'Ѕ',
        dscy: 'ѕ',
        dsol: '\u29F6',
        Dstrok: 'Đ',
        dstrok: 'đ',
        dtdot: '\u22F1',
        dtri: '\u25BF',
        dtrif: '\u25BE',
        duarr: '\u21F5',
        duhar: '\u296F',
        dwangle: '\u29A6',
        DZcy: 'Џ',
        dzcy: 'џ',
        dzigrarr: '\u27FF',
        Eacute: 'É',
        eacute: 'é',
        easter: '\u2A6E',
        Ecaron: 'Ě',
        ecaron: 'ě',
        ecir: '\u2256',
        Ecirc: 'Ê',
        ecirc: 'ê',
        ecolon: '\u2255',
        Ecy: 'Э',
        ecy: 'э',
        eDDot: '\u2A77',
        Edot: 'Ė',
        eDot: '\u2251',
        edot: 'ė',
        ee: 'ⅇ',
        efDot: '\u2252',
        Efr: '\uD835\uDD08',
        efr: '\uD835\uDD22',
        eg: '\u2A9A',
        Egrave: 'È',
        egrave: 'è',
        egs: '\u2A96',
        egsdot: '\u2A98',
        el: '\u2A99',
        Element: '\u2208',
        elinters: '\u23E7',
        ell: 'ℓ',
        els: '\u2A95',
        elsdot: '\u2A97',
        Emacr: 'Ē',
        emacr: 'ē',
        empty: '\u2205',
        emptyset: '\u2205',
        EmptySmallSquare: '\u25FB',
        emptyv: '\u2205',
        EmptyVerySmallSquare: '\u25AB',
        emsp: '\u2003',
        emsp13: '\u2004',
        emsp14: '\u2005',
        ENG: 'Ŋ',
        eng: 'ŋ',
        ensp: '\u2002',
        Eogon: 'Ę',
        eogon: 'ę',
        Eopf: '\uD835\uDD3C',
        eopf: '\uD835\uDD56',
        epar: '\u22D5',
        eparsl: '\u29E3',
        eplus: '\u2A71',
        epsi: 'ε',
        Epsilon: 'Ε',
        epsilon: 'ε',
        epsiv: 'ϵ',
        eqcirc: '\u2256',
        eqcolon: '\u2255',
        eqsim: '\u2242',
        eqslantgtr: '\u2A96',
        eqslantless: '\u2A95',
        Equal: '\u2A75',
        equals: '=',
        EqualTilde: '\u2242',
        equest: '\u225F',
        Equilibrium: '\u21CC',
        equiv: '\u2261',
        equivDD: '\u2A78',
        eqvparsl: '\u29E5',
        erarr: '\u2971',
        erDot: '\u2253',
        Escr: 'ℰ',
        escr: 'ℯ',
        esdot: '\u2250',
        Esim: '\u2A73',
        esim: '\u2242',
        Eta: 'Η',
        eta: 'η',
        ETH: 'Ð',
        eth: 'ð',
        Euml: 'Ë',
        euml: 'ë',
        euro: '\u20AC',
        excl: '!',
        exist: '\u2203',
        Exists: '\u2203',
        expectation: 'ℰ',
        ExponentialE: 'ⅇ',
        exponentiale: 'ⅇ',
        fallingdotseq: '\u2252',
        Fcy: 'Ф',
        fcy: 'ф',
        female: '\u2640',
        ffilig: 'ﬃ',
        fflig: 'ﬀ',
        ffllig: 'ﬄ',
        Ffr: '\uD835\uDD09',
        ffr: '\uD835\uDD23',
        filig: 'ﬁ',
        FilledSmallSquare: '\u25FC',
        FilledVerySmallSquare: '\u25AA',
        fjlig: 'fj',
        flat: '\u266D',
        fllig: 'ﬂ',
        fltns: '\u25B1',
        fnof: 'ƒ',
        Fopf: '\uD835\uDD3D',
        fopf: '\uD835\uDD57',
        ForAll: '\u2200',
        forall: '\u2200',
        fork: '\u22D4',
        forkv: '\u2AD9',
        Fouriertrf: 'ℱ',
        fpartint: '\u2A0D',
        frac12: '\xBD',
        frac13: '\u2153',
        frac14: '\xBC',
        frac15: '\u2155',
        frac16: '\u2159',
        frac18: '\u215B',
        frac23: '\u2154',
        frac25: '\u2156',
        frac34: '\xBE',
        frac35: '\u2157',
        frac38: '\u215C',
        frac45: '\u2158',
        frac56: '\u215A',
        frac58: '\u215D',
        frac78: '\u215E',
        frasl: '\u2044',
        frown: '\u2322',
        Fscr: 'ℱ',
        fscr: '\uD835\uDCBB',
        gacute: 'ǵ',
        Gamma: 'Γ',
        gamma: 'γ',
        Gammad: 'Ϝ',
        gammad: 'ϝ',
        gap: '\u2A86',
        Gbreve: 'Ğ',
        gbreve: 'ğ',
        Gcedil: 'Ģ',
        Gcirc: 'Ĝ',
        gcirc: 'ĝ',
        Gcy: 'Г',
        gcy: 'г',
        Gdot: 'Ġ',
        gdot: 'ġ',
        gE: '\u2267',
        ge: '\u2265',
        gEl: '\u2A8C',
        gel: '\u22DB',
        geq: '\u2265',
        geqq: '\u2267',
        geqslant: '\u2A7E',
        ges: '\u2A7E',
        gescc: '\u2AA9',
        gesdot: '\u2A80',
        gesdoto: '\u2A82',
        gesdotol: '\u2A84',
        gesl: '\u22DB︀',
        gesles: '\u2A94',
        Gfr: '\uD835\uDD0A',
        gfr: '\uD835\uDD24',
        Gg: '\u22D9',
        gg: '\u226B',
        ggg: '\u22D9',
        gimel: 'ℷ',
        GJcy: 'Ѓ',
        gjcy: 'ѓ',
        gl: '\u2277',
        gla: '\u2AA5',
        glE: '\u2A92',
        glj: '\u2AA4',
        gnap: '\u2A8A',
        gnapprox: '\u2A8A',
        gnE: '\u2269',
        gne: '\u2A88',
        gneq: '\u2A88',
        gneqq: '\u2269',
        gnsim: '\u22E7',
        Gopf: '\uD835\uDD3E',
        gopf: '\uD835\uDD58',
        grave: '`',
        GreaterEqual: '\u2265',
        GreaterEqualLess: '\u22DB',
        GreaterFullEqual: '\u2267',
        GreaterGreater: '\u2AA2',
        GreaterLess: '\u2277',
        GreaterSlantEqual: '\u2A7E',
        GreaterTilde: '\u2273',
        Gscr: '\uD835\uDCA2',
        gscr: 'ℊ',
        gsim: '\u2273',
        gsime: '\u2A8E',
        gsiml: '\u2A90',
        GT: '>',
        Gt: '\u226B',
        gt: '>',
        gtcc: '\u2AA7',
        gtcir: '\u2A7A',
        gtdot: '\u22D7',
        gtlPar: '\u2995',
        gtquest: '\u2A7C',
        gtrapprox: '\u2A86',
        gtrarr: '\u2978',
        gtrdot: '\u22D7',
        gtreqless: '\u22DB',
        gtreqqless: '\u2A8C',
        gtrless: '\u2277',
        gtrsim: '\u2273',
        gvertneqq: '\u2269︀',
        gvnE: '\u2269︀',
        Hacek: 'ˇ',
        hairsp: '\u200A',
        half: '\xBD',
        hamilt: 'ℋ',
        HARDcy: 'Ъ',
        hardcy: 'ъ',
        hArr: '\u21D4',
        harr: '\u2194',
        harrcir: '\u2948',
        harrw: '\u21AD',
        Hat: '^',
        hbar: 'ℏ',
        Hcirc: 'Ĥ',
        hcirc: 'ĥ',
        hearts: '\u2665',
        heartsuit: '\u2665',
        hellip: '\u2026',
        hercon: '\u22B9',
        Hfr: 'ℌ',
        hfr: '\uD835\uDD25',
        HilbertSpace: 'ℋ',
        hksearow: '\u2925',
        hkswarow: '\u2926',
        hoarr: '\u21FF',
        homtht: '\u223B',
        hookleftarrow: '\u21A9',
        hookrightarrow: '\u21AA',
        Hopf: 'ℍ',
        hopf: '\uD835\uDD59',
        horbar: '\u2015',
        HorizontalLine: '\u2500',
        Hscr: 'ℋ',
        hscr: '\uD835\uDCBD',
        hslash: 'ℏ',
        Hstrok: 'Ħ',
        hstrok: 'ħ',
        HumpDownHump: '\u224E',
        HumpEqual: '\u224F',
        hybull: '\u2043',
        hyphen: '\u2010',
        Iacute: 'Í',
        iacute: 'í',
        ic: '\u2063',
        Icirc: 'Î',
        icirc: 'î',
        Icy: 'И',
        icy: 'и',
        Idot: 'İ',
        IEcy: 'Е',
        iecy: 'е',
        iexcl: '\xA1',
        iff: '\u21D4',
        Ifr: 'ℑ',
        ifr: '\uD835\uDD26',
        Igrave: 'Ì',
        igrave: 'ì',
        ii: 'ⅈ',
        iiiint: '\u2A0C',
        iiint: '\u222D',
        iinfin: '\u29DC',
        iiota: '\u2129',
        IJlig: 'Ĳ',
        ijlig: 'ĳ',
        Im: 'ℑ',
        Imacr: 'Ī',
        imacr: 'ī',
        image: 'ℑ',
        ImaginaryI: 'ⅈ',
        imagline: 'ℐ',
        imagpart: 'ℑ',
        imath: 'ı',
        imof: '\u22B7',
        imped: 'Ƶ',
        Implies: '\u21D2',
        in: '\u2208',
        incare: '\u2105',
        infin: '\u221E',
        infintie: '\u29DD',
        inodot: 'ı',
        Int: '\u222C',
        int: '\u222B',
        intcal: '\u22BA',
        integers: 'ℤ',
        Integral: '\u222B',
        intercal: '\u22BA',
        Intersection: '\u22C2',
        intlarhk: '\u2A17',
        intprod: '\u2A3C',
        InvisibleComma: '\u2063',
        InvisibleTimes: '\u2062',
        IOcy: 'Ё',
        iocy: 'ё',
        Iogon: 'Į',
        iogon: 'į',
        Iopf: '\uD835\uDD40',
        iopf: '\uD835\uDD5A',
        Iota: 'Ι',
        iota: 'ι',
        iprod: '\u2A3C',
        iquest: '\xBF',
        Iscr: 'ℐ',
        iscr: '\uD835\uDCBE',
        isin: '\u2208',
        isindot: '\u22F5',
        isinE: '\u22F9',
        isins: '\u22F4',
        isinsv: '\u22F3',
        isinv: '\u2208',
        it: '\u2062',
        Itilde: 'Ĩ',
        itilde: 'ĩ',
        Iukcy: 'І',
        iukcy: 'і',
        Iuml: 'Ï',
        iuml: 'ï',
        Jcirc: 'Ĵ',
        jcirc: 'ĵ',
        Jcy: 'Й',
        jcy: 'й',
        Jfr: '\uD835\uDD0D',
        jfr: '\uD835\uDD27',
        jmath: 'ȷ',
        Jopf: '\uD835\uDD41',
        jopf: '\uD835\uDD5B',
        Jscr: '\uD835\uDCA5',
        jscr: '\uD835\uDCBF',
        Jsercy: 'Ј',
        jsercy: 'ј',
        Jukcy: 'Є',
        jukcy: 'є',
        Kappa: 'Κ',
        kappa: 'κ',
        kappav: 'ϰ',
        Kcedil: 'Ķ',
        kcedil: 'ķ',
        Kcy: 'К',
        kcy: 'к',
        Kfr: '\uD835\uDD0E',
        kfr: '\uD835\uDD28',
        kgreen: 'ĸ',
        KHcy: 'Х',
        khcy: 'х',
        KJcy: 'Ќ',
        kjcy: 'ќ',
        Kopf: '\uD835\uDD42',
        kopf: '\uD835\uDD5C',
        Kscr: '\uD835\uDCA6',
        kscr: '\uD835\uDCC0',
        lAarr: '\u21DA',
        Lacute: 'Ĺ',
        lacute: 'ĺ',
        laemptyv: '\u29B4',
        lagran: 'ℒ',
        Lambda: 'Λ',
        lambda: 'λ',
        Lang: '\u27EA',
        lang: '\u27E8',
        langd: '\u2991',
        langle: '\u27E8',
        lap: '\u2A85',
        Laplacetrf: 'ℒ',
        laquo: '\xAB',
        Larr: '\u219E',
        lArr: '\u21D0',
        larr: '\u2190',
        larrb: '\u21E4',
        larrbfs: '\u291F',
        larrfs: '\u291D',
        larrhk: '\u21A9',
        larrlp: '\u21AB',
        larrpl: '\u2939',
        larrsim: '\u2973',
        larrtl: '\u21A2',
        lat: '\u2AAB',
        lAtail: '\u291B',
        latail: '\u2919',
        late: '\u2AAD',
        lates: '\u2AAD︀',
        lBarr: '\u290E',
        lbarr: '\u290C',
        lbbrk: '\u2772',
        lbrace: '{',
        lbrack: '[',
        lbrke: '\u298B',
        lbrksld: '\u298F',
        lbrkslu: '\u298D',
        Lcaron: 'Ľ',
        lcaron: 'ľ',
        Lcedil: 'Ļ',
        lcedil: 'ļ',
        lceil: '\u2308',
        lcub: '{',
        Lcy: 'Л',
        lcy: 'л',
        ldca: '\u2936',
        ldquo: '\u201C',
        ldquor: '\u201E',
        ldrdhar: '\u2967',
        ldrushar: '\u294B',
        ldsh: '\u21B2',
        lE: '\u2266',
        le: '\u2264',
        LeftAngleBracket: '\u27E8',
        LeftArrow: '\u2190',
        Leftarrow: '\u21D0',
        leftarrow: '\u2190',
        LeftArrowBar: '\u21E4',
        LeftArrowRightArrow: '\u21C6',
        leftarrowtail: '\u21A2',
        LeftCeiling: '\u2308',
        LeftDoubleBracket: '\u27E6',
        LeftDownTeeVector: '\u2961',
        LeftDownVector: '\u21C3',
        LeftDownVectorBar: '\u2959',
        LeftFloor: '\u230A',
        leftharpoondown: '\u21BD',
        leftharpoonup: '\u21BC',
        leftleftarrows: '\u21C7',
        LeftRightArrow: '\u2194',
        Leftrightarrow: '\u21D4',
        leftrightarrow: '\u2194',
        leftrightarrows: '\u21C6',
        leftrightharpoons: '\u21CB',
        leftrightsquigarrow: '\u21AD',
        LeftRightVector: '\u294E',
        LeftTee: '\u22A3',
        LeftTeeArrow: '\u21A4',
        LeftTeeVector: '\u295A',
        leftthreetimes: '\u22CB',
        LeftTriangle: '\u22B2',
        LeftTriangleBar: '\u29CF',
        LeftTriangleEqual: '\u22B4',
        LeftUpDownVector: '\u2951',
        LeftUpTeeVector: '\u2960',
        LeftUpVector: '\u21BF',
        LeftUpVectorBar: '\u2958',
        LeftVector: '\u21BC',
        LeftVectorBar: '\u2952',
        lEg: '\u2A8B',
        leg: '\u22DA',
        leq: '\u2264',
        leqq: '\u2266',
        leqslant: '\u2A7D',
        les: '\u2A7D',
        lescc: '\u2AA8',
        lesdot: '\u2A7F',
        lesdoto: '\u2A81',
        lesdotor: '\u2A83',
        lesg: '\u22DA︀',
        lesges: '\u2A93',
        lessapprox: '\u2A85',
        lessdot: '\u22D6',
        lesseqgtr: '\u22DA',
        lesseqqgtr: '\u2A8B',
        LessEqualGreater: '\u22DA',
        LessFullEqual: '\u2266',
        LessGreater: '\u2276',
        lessgtr: '\u2276',
        LessLess: '\u2AA1',
        lesssim: '\u2272',
        LessSlantEqual: '\u2A7D',
        LessTilde: '\u2272',
        lfisht: '\u297C',
        lfloor: '\u230A',
        Lfr: '\uD835\uDD0F',
        lfr: '\uD835\uDD29',
        lg: '\u2276',
        lgE: '\u2A91',
        lHar: '\u2962',
        lhard: '\u21BD',
        lharu: '\u21BC',
        lharul: '\u296A',
        lhblk: '\u2584',
        LJcy: 'Љ',
        ljcy: 'љ',
        Ll: '\u22D8',
        ll: '\u226A',
        llarr: '\u21C7',
        llcorner: '\u231E',
        Lleftarrow: '\u21DA',
        llhard: '\u296B',
        lltri: '\u25FA',
        Lmidot: 'Ŀ',
        lmidot: 'ŀ',
        lmoust: '\u23B0',
        lmoustache: '\u23B0',
        lnap: '\u2A89',
        lnapprox: '\u2A89',
        lnE: '\u2268',
        lne: '\u2A87',
        lneq: '\u2A87',
        lneqq: '\u2268',
        lnsim: '\u22E6',
        loang: '\u27EC',
        loarr: '\u21FD',
        lobrk: '\u27E6',
        LongLeftArrow: '\u27F5',
        Longleftarrow: '\u27F8',
        longleftarrow: '\u27F5',
        LongLeftRightArrow: '\u27F7',
        Longleftrightarrow: '\u27FA',
        longleftrightarrow: '\u27F7',
        longmapsto: '\u27FC',
        LongRightArrow: '\u27F6',
        Longrightarrow: '\u27F9',
        longrightarrow: '\u27F6',
        looparrowleft: '\u21AB',
        looparrowright: '\u21AC',
        lopar: '\u2985',
        Lopf: '\uD835\uDD43',
        lopf: '\uD835\uDD5D',
        loplus: '\u2A2D',
        lotimes: '\u2A34',
        lowast: '\u2217',
        lowbar: '_',
        LowerLeftArrow: '\u2199',
        LowerRightArrow: '\u2198',
        loz: '\u25CA',
        lozenge: '\u25CA',
        lozf: '\u29EB',
        lpar: '(',
        lparlt: '\u2993',
        lrarr: '\u21C6',
        lrcorner: '\u231F',
        lrhar: '\u21CB',
        lrhard: '\u296D',
        lrm: '\u200E',
        lrtri: '\u22BF',
        lsaquo: '\u2039',
        Lscr: 'ℒ',
        lscr: '\uD835\uDCC1',
        Lsh: '\u21B0',
        lsh: '\u21B0',
        lsim: '\u2272',
        lsime: '\u2A8D',
        lsimg: '\u2A8F',
        lsqb: '[',
        lsquo: '\u2018',
        lsquor: '\u201A',
        Lstrok: 'Ł',
        lstrok: 'ł',
        LT: '<',
        Lt: '\u226A',
        lt: '<',
        ltcc: '\u2AA6',
        ltcir: '\u2A79',
        ltdot: '\u22D6',
        lthree: '\u22CB',
        ltimes: '\u22C9',
        ltlarr: '\u2976',
        ltquest: '\u2A7B',
        ltri: '\u25C3',
        ltrie: '\u22B4',
        ltrif: '\u25C2',
        ltrPar: '\u2996',
        lurdshar: '\u294A',
        luruhar: '\u2966',
        lvertneqq: '\u2268︀',
        lvnE: '\u2268︀',
        macr: '\xAF',
        male: '\u2642',
        malt: '\u2720',
        maltese: '\u2720',
        Map: '\u2905',
        map: '\u21A6',
        mapsto: '\u21A6',
        mapstodown: '\u21A7',
        mapstoleft: '\u21A4',
        mapstoup: '\u21A5',
        marker: '\u25AE',
        mcomma: '\u2A29',
        Mcy: 'М',
        mcy: 'м',
        mdash: '\u2014',
        mDDot: '\u223A',
        measuredangle: '\u2221',
        MediumSpace: '\u205F',
        Mellintrf: 'ℳ',
        Mfr: '\uD835\uDD10',
        mfr: '\uD835\uDD2A',
        mho: '\u2127',
        micro: 'µ',
        mid: '\u2223',
        midast: '*',
        midcir: '\u2AF0',
        middot: '\xB7',
        minus: '\u2212',
        minusb: '\u229F',
        minusd: '\u2238',
        minusdu: '\u2A2A',
        MinusPlus: '\u2213',
        mlcp: '\u2ADB',
        mldr: '\u2026',
        mnplus: '\u2213',
        models: '\u22A7',
        Mopf: '\uD835\uDD44',
        mopf: '\uD835\uDD5E',
        mp: '\u2213',
        Mscr: 'ℳ',
        mscr: '\uD835\uDCC2',
        mstpos: '\u223E',
        Mu: 'Μ',
        mu: 'μ',
        multimap: '\u22B8',
        mumap: '\u22B8',
        nabla: '\u2207',
        Nacute: 'Ń',
        nacute: 'ń',
        nang: '\u2220⃒',
        nap: '\u2249',
        napE: '\u2A70̸',
        napid: '\u224B̸',
        napos: 'ŉ',
        napprox: '\u2249',
        natur: '\u266E',
        natural: '\u266E',
        naturals: 'ℕ',
        nbsp: '\xA0',
        nbump: '\u224E̸',
        nbumpe: '\u224F̸',
        ncap: '\u2A43',
        Ncaron: 'Ň',
        ncaron: 'ň',
        Ncedil: 'Ņ',
        ncedil: 'ņ',
        ncong: '\u2247',
        ncongdot: '\u2A6D̸',
        ncup: '\u2A42',
        Ncy: 'Н',
        ncy: 'н',
        ndash: '\u2013',
        ne: '\u2260',
        nearhk: '\u2924',
        neArr: '\u21D7',
        nearr: '\u2197',
        nearrow: '\u2197',
        nedot: '\u2250̸',
        NegativeMediumSpace: '\u200B',
        NegativeThickSpace: '\u200B',
        NegativeThinSpace: '\u200B',
        NegativeVeryThinSpace: '\u200B',
        nequiv: '\u2262',
        nesear: '\u2928',
        nesim: '\u2242̸',
        NestedGreaterGreater: '\u226B',
        NestedLessLess: '\u226A',
        NewLine: '\n',
        nexist: '\u2204',
        nexists: '\u2204',
        Nfr: '\uD835\uDD11',
        nfr: '\uD835\uDD2B',
        ngE: '\u2267̸',
        nge: '\u2271',
        ngeq: '\u2271',
        ngeqq: '\u2267̸',
        ngeqslant: '\u2A7E̸',
        nges: '\u2A7E̸',
        nGg: '\u22D9̸',
        ngsim: '\u2275',
        nGt: '\u226B⃒',
        ngt: '\u226F',
        ngtr: '\u226F',
        nGtv: '\u226B̸',
        nhArr: '\u21CE',
        nharr: '\u21AE',
        nhpar: '\u2AF2',
        ni: '\u220B',
        nis: '\u22FC',
        nisd: '\u22FA',
        niv: '\u220B',
        NJcy: 'Њ',
        njcy: 'њ',
        nlArr: '\u21CD',
        nlarr: '\u219A',
        nldr: '\u2025',
        nlE: '\u2266̸',
        nle: '\u2270',
        nLeftarrow: '\u21CD',
        nleftarrow: '\u219A',
        nLeftrightarrow: '\u21CE',
        nleftrightarrow: '\u21AE',
        nleq: '\u2270',
        nleqq: '\u2266̸',
        nleqslant: '\u2A7D̸',
        nles: '\u2A7D̸',
        nless: '\u226E',
        nLl: '\u22D8̸',
        nlsim: '\u2274',
        nLt: '\u226A⃒',
        nlt: '\u226E',
        nltri: '\u22EA',
        nltrie: '\u22EC',
        nLtv: '\u226A̸',
        nmid: '\u2224',
        NoBreak: '\u2060',
        NonBreakingSpace: '\xA0',
        Nopf: 'ℕ',
        nopf: '\uD835\uDD5F',
        Not: '\u2AEC',
        not: '\xAC',
        NotCongruent: '\u2262',
        NotCupCap: '\u226D',
        NotDoubleVerticalBar: '\u2226',
        NotElement: '\u2209',
        NotEqual: '\u2260',
        NotEqualTilde: '\u2242̸',
        NotExists: '\u2204',
        NotGreater: '\u226F',
        NotGreaterEqual: '\u2271',
        NotGreaterFullEqual: '\u2267̸',
        NotGreaterGreater: '\u226B̸',
        NotGreaterLess: '\u2279',
        NotGreaterSlantEqual: '\u2A7E̸',
        NotGreaterTilde: '\u2275',
        NotHumpDownHump: '\u224E̸',
        NotHumpEqual: '\u224F̸',
        notin: '\u2209',
        notindot: '\u22F5̸',
        notinE: '\u22F9̸',
        notinva: '\u2209',
        notinvb: '\u22F7',
        notinvc: '\u22F6',
        NotLeftTriangle: '\u22EA',
        NotLeftTriangleBar: '\u29CF̸',
        NotLeftTriangleEqual: '\u22EC',
        NotLess: '\u226E',
        NotLessEqual: '\u2270',
        NotLessGreater: '\u2278',
        NotLessLess: '\u226A̸',
        NotLessSlantEqual: '\u2A7D̸',
        NotLessTilde: '\u2274',
        NotNestedGreaterGreater: '\u2AA2̸',
        NotNestedLessLess: '\u2AA1̸',
        notni: '\u220C',
        notniva: '\u220C',
        notnivb: '\u22FE',
        notnivc: '\u22FD',
        NotPrecedes: '\u2280',
        NotPrecedesEqual: '\u2AAF̸',
        NotPrecedesSlantEqual: '\u22E0',
        NotReverseElement: '\u220C',
        NotRightTriangle: '\u22EB',
        NotRightTriangleBar: '\u29D0̸',
        NotRightTriangleEqual: '\u22ED',
        NotSquareSubset: '\u228F̸',
        NotSquareSubsetEqual: '\u22E2',
        NotSquareSuperset: '\u2290̸',
        NotSquareSupersetEqual: '\u22E3',
        NotSubset: '\u2282⃒',
        NotSubsetEqual: '\u2288',
        NotSucceeds: '\u2281',
        NotSucceedsEqual: '\u2AB0̸',
        NotSucceedsSlantEqual: '\u22E1',
        NotSucceedsTilde: '\u227F̸',
        NotSuperset: '\u2283⃒',
        NotSupersetEqual: '\u2289',
        NotTilde: '\u2241',
        NotTildeEqual: '\u2244',
        NotTildeFullEqual: '\u2247',
        NotTildeTilde: '\u2249',
        NotVerticalBar: '\u2224',
        npar: '\u2226',
        nparallel: '\u2226',
        nparsl: '\u2AFD⃥',
        npart: '\u2202̸',
        npolint: '\u2A14',
        npr: '\u2280',
        nprcue: '\u22E0',
        npre: '\u2AAF̸',
        nprec: '\u2280',
        npreceq: '\u2AAF̸',
        nrArr: '\u21CF',
        nrarr: '\u219B',
        nrarrc: '\u2933̸',
        nrarrw: '\u219D̸',
        nRightarrow: '\u21CF',
        nrightarrow: '\u219B',
        nrtri: '\u22EB',
        nrtrie: '\u22ED',
        nsc: '\u2281',
        nsccue: '\u22E1',
        nsce: '\u2AB0̸',
        Nscr: '\uD835\uDCA9',
        nscr: '\uD835\uDCC3',
        nshortmid: '\u2224',
        nshortparallel: '\u2226',
        nsim: '\u2241',
        nsime: '\u2244',
        nsimeq: '\u2244',
        nsmid: '\u2224',
        nspar: '\u2226',
        nsqsube: '\u22E2',
        nsqsupe: '\u22E3',
        nsub: '\u2284',
        nsubE: '\u2AC5̸',
        nsube: '\u2288',
        nsubset: '\u2282⃒',
        nsubseteq: '\u2288',
        nsubseteqq: '\u2AC5̸',
        nsucc: '\u2281',
        nsucceq: '\u2AB0̸',
        nsup: '\u2285',
        nsupE: '\u2AC6̸',
        nsupe: '\u2289',
        nsupset: '\u2283⃒',
        nsupseteq: '\u2289',
        nsupseteqq: '\u2AC6̸',
        ntgl: '\u2279',
        Ntilde: 'Ñ',
        ntilde: 'ñ',
        ntlg: '\u2278',
        ntriangleleft: '\u22EA',
        ntrianglelefteq: '\u22EC',
        ntriangleright: '\u22EB',
        ntrianglerighteq: '\u22ED',
        Nu: 'Ν',
        nu: 'ν',
        num: '#',
        numero: '\u2116',
        numsp: '\u2007',
        nvap: '\u224D⃒',
        nVDash: '\u22AF',
        nVdash: '\u22AE',
        nvDash: '\u22AD',
        nvdash: '\u22AC',
        nvge: '\u2265⃒',
        nvgt: '>⃒',
        nvHarr: '\u2904',
        nvinfin: '\u29DE',
        nvlArr: '\u2902',
        nvle: '\u2264⃒',
        nvlt: '<⃒',
        nvltrie: '\u22B4⃒',
        nvrArr: '\u2903',
        nvrtrie: '\u22B5⃒',
        nvsim: '\u223C⃒',
        nwarhk: '\u2923',
        nwArr: '\u21D6',
        nwarr: '\u2196',
        nwarrow: '\u2196',
        nwnear: '\u2927',
        Oacute: 'Ó',
        oacute: 'ó',
        oast: '\u229B',
        ocir: '\u229A',
        Ocirc: 'Ô',
        ocirc: 'ô',
        Ocy: 'О',
        ocy: 'о',
        odash: '\u229D',
        Odblac: 'Ő',
        odblac: 'ő',
        odiv: '\u2A38',
        odot: '\u2299',
        odsold: '\u29BC',
        OElig: 'Œ',
        oelig: 'œ',
        ofcir: '\u29BF',
        Ofr: '\uD835\uDD12',
        ofr: '\uD835\uDD2C',
        ogon: '\u02DB',
        Ograve: 'Ò',
        ograve: 'ò',
        ogt: '\u29C1',
        ohbar: '\u29B5',
        ohm: 'Ω',
        oint: '\u222E',
        olarr: '\u21BA',
        olcir: '\u29BE',
        olcross: '\u29BB',
        oline: '\u203E',
        olt: '\u29C0',
        Omacr: 'Ō',
        omacr: 'ō',
        Omega: 'Ω',
        omega: 'ω',
        Omicron: 'Ο',
        omicron: 'ο',
        omid: '\u29B6',
        ominus: '\u2296',
        Oopf: '\uD835\uDD46',
        oopf: '\uD835\uDD60',
        opar: '\u29B7',
        OpenCurlyDoubleQuote: '\u201C',
        OpenCurlyQuote: '\u2018',
        operp: '\u29B9',
        oplus: '\u2295',
        Or: '\u2A54',
        or: '\u2228',
        orarr: '\u21BB',
        ord: '\u2A5D',
        order: 'ℴ',
        orderof: 'ℴ',
        ordf: 'ª',
        ordm: 'º',
        origof: '\u22B6',
        oror: '\u2A56',
        orslope: '\u2A57',
        orv: '\u2A5B',
        oS: '\u24C8',
        Oscr: '\uD835\uDCAA',
        oscr: 'ℴ',
        Oslash: 'Ø',
        oslash: 'ø',
        osol: '\u2298',
        Otilde: 'Õ',
        otilde: 'õ',
        Otimes: '\u2A37',
        otimes: '\u2297',
        otimesas: '\u2A36',
        Ouml: 'Ö',
        ouml: 'ö',
        ovbar: '\u233D',
        OverBar: '\u203E',
        OverBrace: '\u23DE',
        OverBracket: '\u23B4',
        OverParenthesis: '\u23DC',
        par: '\u2225',
        para: '\xB6',
        parallel: '\u2225',
        parsim: '\u2AF3',
        parsl: '\u2AFD',
        part: '\u2202',
        PartialD: '\u2202',
        Pcy: 'П',
        pcy: 'п',
        percnt: '%',
        period: '.',
        permil: '\u2030',
        perp: '\u22A5',
        pertenk: '\u2031',
        Pfr: '\uD835\uDD13',
        pfr: '\uD835\uDD2D',
        Phi: 'Φ',
        phi: 'φ',
        phiv: 'ϕ',
        phmmat: 'ℳ',
        phone: '\u260E',
        Pi: 'Π',
        pi: 'π',
        pitchfork: '\u22D4',
        piv: 'ϖ',
        planck: 'ℏ',
        planckh: 'ℎ',
        plankv: 'ℏ',
        plus: '+',
        plusacir: '\u2A23',
        plusb: '\u229E',
        pluscir: '\u2A22',
        plusdo: '\u2214',
        plusdu: '\u2A25',
        pluse: '\u2A72',
        PlusMinus: '\xB1',
        plusmn: '\xB1',
        plussim: '\u2A26',
        plustwo: '\u2A27',
        pm: '\xB1',
        Poincareplane: 'ℌ',
        pointint: '\u2A15',
        Popf: 'ℙ',
        popf: '\uD835\uDD61',
        pound: '\xA3',
        Pr: '\u2ABB',
        pr: '\u227A',
        prap: '\u2AB7',
        prcue: '\u227C',
        prE: '\u2AB3',
        pre: '\u2AAF',
        prec: '\u227A',
        precapprox: '\u2AB7',
        preccurlyeq: '\u227C',
        Precedes: '\u227A',
        PrecedesEqual: '\u2AAF',
        PrecedesSlantEqual: '\u227C',
        PrecedesTilde: '\u227E',
        preceq: '\u2AAF',
        precnapprox: '\u2AB9',
        precneqq: '\u2AB5',
        precnsim: '\u22E8',
        precsim: '\u227E',
        Prime: '\u2033',
        prime: '\u2032',
        primes: 'ℙ',
        prnap: '\u2AB9',
        prnE: '\u2AB5',
        prnsim: '\u22E8',
        prod: '\u220F',
        Product: '\u220F',
        profalar: '\u232E',
        profline: '\u2312',
        profsurf: '\u2313',
        prop: '\u221D',
        Proportion: '\u2237',
        Proportional: '\u221D',
        propto: '\u221D',
        prsim: '\u227E',
        prurel: '\u22B0',
        Pscr: '\uD835\uDCAB',
        pscr: '\uD835\uDCC5',
        Psi: 'Ψ',
        psi: 'ψ',
        puncsp: '\u2008',
        Qfr: '\uD835\uDD14',
        qfr: '\uD835\uDD2E',
        qint: '\u2A0C',
        Qopf: 'ℚ',
        qopf: '\uD835\uDD62',
        qprime: '\u2057',
        Qscr: '\uD835\uDCAC',
        qscr: '\uD835\uDCC6',
        quaternions: 'ℍ',
        quatint: '\u2A16',
        quest: '?',
        questeq: '\u225F',
        QUOT: '"',
        quot: '"',
        rAarr: '\u21DB',
        race: '\u223Ḏ',
        Racute: 'Ŕ',
        racute: 'ŕ',
        radic: '\u221A',
        raemptyv: '\u29B3',
        Rang: '\u27EB',
        rang: '\u27E9',
        rangd: '\u2992',
        range: '\u29A5',
        rangle: '\u27E9',
        raquo: '\xBB',
        Rarr: '\u21A0',
        rArr: '\u21D2',
        rarr: '\u2192',
        rarrap: '\u2975',
        rarrb: '\u21E5',
        rarrbfs: '\u2920',
        rarrc: '\u2933',
        rarrfs: '\u291E',
        rarrhk: '\u21AA',
        rarrlp: '\u21AC',
        rarrpl: '\u2945',
        rarrsim: '\u2974',
        Rarrtl: '\u2916',
        rarrtl: '\u21A3',
        rarrw: '\u219D',
        rAtail: '\u291C',
        ratail: '\u291A',
        ratio: '\u2236',
        rationals: 'ℚ',
        RBarr: '\u2910',
        rBarr: '\u290F',
        rbarr: '\u290D',
        rbbrk: '\u2773',
        rbrace: '}',
        rbrack: ']',
        rbrke: '\u298C',
        rbrksld: '\u298E',
        rbrkslu: '\u2990',
        Rcaron: 'Ř',
        rcaron: 'ř',
        Rcedil: 'Ŗ',
        rcedil: 'ŗ',
        rceil: '\u2309',
        rcub: '}',
        Rcy: 'Р',
        rcy: 'р',
        rdca: '\u2937',
        rdldhar: '\u2969',
        rdquo: '\u201D',
        rdquor: '\u201D',
        rdsh: '\u21B3',
        Re: 'ℜ',
        real: 'ℜ',
        realine: 'ℛ',
        realpart: 'ℜ',
        reals: 'ℝ',
        rect: '\u25AD',
        REG: '\xAE',
        reg: '\xAE',
        ReverseElement: '\u220B',
        ReverseEquilibrium: '\u21CB',
        ReverseUpEquilibrium: '\u296F',
        rfisht: '\u297D',
        rfloor: '\u230B',
        Rfr: 'ℜ',
        rfr: '\uD835\uDD2F',
        rHar: '\u2964',
        rhard: '\u21C1',
        rharu: '\u21C0',
        rharul: '\u296C',
        Rho: 'Ρ',
        rho: 'ρ',
        rhov: 'ϱ',
        RightAngleBracket: '\u27E9',
        RightArrow: '\u2192',
        Rightarrow: '\u21D2',
        rightarrow: '\u2192',
        RightArrowBar: '\u21E5',
        RightArrowLeftArrow: '\u21C4',
        rightarrowtail: '\u21A3',
        RightCeiling: '\u2309',
        RightDoubleBracket: '\u27E7',
        RightDownTeeVector: '\u295D',
        RightDownVector: '\u21C2',
        RightDownVectorBar: '\u2955',
        RightFloor: '\u230B',
        rightharpoondown: '\u21C1',
        rightharpoonup: '\u21C0',
        rightleftarrows: '\u21C4',
        rightleftharpoons: '\u21CC',
        rightrightarrows: '\u21C9',
        rightsquigarrow: '\u219D',
        RightTee: '\u22A2',
        RightTeeArrow: '\u21A6',
        RightTeeVector: '\u295B',
        rightthreetimes: '\u22CC',
        RightTriangle: '\u22B3',
        RightTriangleBar: '\u29D0',
        RightTriangleEqual: '\u22B5',
        RightUpDownVector: '\u294F',
        RightUpTeeVector: '\u295C',
        RightUpVector: '\u21BE',
        RightUpVectorBar: '\u2954',
        RightVector: '\u21C0',
        RightVectorBar: '\u2953',
        ring: '\u02DA',
        risingdotseq: '\u2253',
        rlarr: '\u21C4',
        rlhar: '\u21CC',
        rlm: '\u200F',
        rmoust: '\u23B1',
        rmoustache: '\u23B1',
        rnmid: '\u2AEE',
        roang: '\u27ED',
        roarr: '\u21FE',
        robrk: '\u27E7',
        ropar: '\u2986',
        Ropf: 'ℝ',
        ropf: '\uD835\uDD63',
        roplus: '\u2A2E',
        rotimes: '\u2A35',
        RoundImplies: '\u2970',
        rpar: ')',
        rpargt: '\u2994',
        rppolint: '\u2A12',
        rrarr: '\u21C9',
        Rrightarrow: '\u21DB',
        rsaquo: '\u203A',
        Rscr: 'ℛ',
        rscr: '\uD835\uDCC7',
        Rsh: '\u21B1',
        rsh: '\u21B1',
        rsqb: ']',
        rsquo: '\u2019',
        rsquor: '\u2019',
        rthree: '\u22CC',
        rtimes: '\u22CA',
        rtri: '\u25B9',
        rtrie: '\u22B5',
        rtrif: '\u25B8',
        rtriltri: '\u29CE',
        RuleDelayed: '\u29F4',
        ruluhar: '\u2968',
        rx: '\u211E',
        Sacute: 'Ś',
        sacute: 'ś',
        sbquo: '\u201A',
        Sc: '\u2ABC',
        sc: '\u227B',
        scap: '\u2AB8',
        Scaron: 'Š',
        scaron: 'š',
        sccue: '\u227D',
        scE: '\u2AB4',
        sce: '\u2AB0',
        Scedil: 'Ş',
        scedil: 'ş',
        Scirc: 'Ŝ',
        scirc: 'ŝ',
        scnap: '\u2ABA',
        scnE: '\u2AB6',
        scnsim: '\u22E9',
        scpolint: '\u2A13',
        scsim: '\u227F',
        Scy: 'С',
        scy: 'с',
        sdot: '\u22C5',
        sdotb: '\u22A1',
        sdote: '\u2A66',
        searhk: '\u2925',
        seArr: '\u21D8',
        searr: '\u2198',
        searrow: '\u2198',
        sect: '\xA7',
        semi: ';',
        seswar: '\u2929',
        setminus: '\u2216',
        setmn: '\u2216',
        sext: '\u2736',
        Sfr: '\uD835\uDD16',
        sfr: '\uD835\uDD30',
        sfrown: '\u2322',
        sharp: '\u266F',
        SHCHcy: 'Щ',
        shchcy: 'щ',
        SHcy: 'Ш',
        shcy: 'ш',
        ShortDownArrow: '\u2193',
        ShortLeftArrow: '\u2190',
        shortmid: '\u2223',
        shortparallel: '\u2225',
        ShortRightArrow: '\u2192',
        ShortUpArrow: '\u2191',
        shy: '\xAD',
        Sigma: 'Σ',
        sigma: 'σ',
        sigmaf: 'ς',
        sigmav: 'ς',
        sim: '\u223C',
        simdot: '\u2A6A',
        sime: '\u2243',
        simeq: '\u2243',
        simg: '\u2A9E',
        simgE: '\u2AA0',
        siml: '\u2A9D',
        simlE: '\u2A9F',
        simne: '\u2246',
        simplus: '\u2A24',
        simrarr: '\u2972',
        slarr: '\u2190',
        SmallCircle: '\u2218',
        smallsetminus: '\u2216',
        smashp: '\u2A33',
        smeparsl: '\u29E4',
        smid: '\u2223',
        smile: '\u2323',
        smt: '\u2AAA',
        smte: '\u2AAC',
        smtes: '\u2AAC︀',
        SOFTcy: 'Ь',
        softcy: 'ь',
        sol: '/',
        solb: '\u29C4',
        solbar: '\u233F',
        Sopf: '\uD835\uDD4A',
        sopf: '\uD835\uDD64',
        spades: '\u2660',
        spadesuit: '\u2660',
        spar: '\u2225',
        sqcap: '\u2293',
        sqcaps: '\u2293︀',
        sqcup: '\u2294',
        sqcups: '\u2294︀',
        Sqrt: '\u221A',
        sqsub: '\u228F',
        sqsube: '\u2291',
        sqsubset: '\u228F',
        sqsubseteq: '\u2291',
        sqsup: '\u2290',
        sqsupe: '\u2292',
        sqsupset: '\u2290',
        sqsupseteq: '\u2292',
        squ: '\u25A1',
        Square: '\u25A1',
        square: '\u25A1',
        SquareIntersection: '\u2293',
        SquareSubset: '\u228F',
        SquareSubsetEqual: '\u2291',
        SquareSuperset: '\u2290',
        SquareSupersetEqual: '\u2292',
        SquareUnion: '\u2294',
        squarf: '\u25AA',
        squf: '\u25AA',
        srarr: '\u2192',
        Sscr: '\uD835\uDCAE',
        sscr: '\uD835\uDCC8',
        ssetmn: '\u2216',
        ssmile: '\u2323',
        sstarf: '\u22C6',
        Star: '\u22C6',
        star: '\u2606',
        starf: '\u2605',
        straightepsilon: 'ϵ',
        straightphi: 'ϕ',
        strns: '\xAF',
        Sub: '\u22D0',
        sub: '\u2282',
        subdot: '\u2ABD',
        subE: '\u2AC5',
        sube: '\u2286',
        subedot: '\u2AC3',
        submult: '\u2AC1',
        subnE: '\u2ACB',
        subne: '\u228A',
        subplus: '\u2ABF',
        subrarr: '\u2979',
        Subset: '\u22D0',
        subset: '\u2282',
        subseteq: '\u2286',
        subseteqq: '\u2AC5',
        SubsetEqual: '\u2286',
        subsetneq: '\u228A',
        subsetneqq: '\u2ACB',
        subsim: '\u2AC7',
        subsub: '\u2AD5',
        subsup: '\u2AD3',
        succ: '\u227B',
        succapprox: '\u2AB8',
        succcurlyeq: '\u227D',
        Succeeds: '\u227B',
        SucceedsEqual: '\u2AB0',
        SucceedsSlantEqual: '\u227D',
        SucceedsTilde: '\u227F',
        succeq: '\u2AB0',
        succnapprox: '\u2ABA',
        succneqq: '\u2AB6',
        succnsim: '\u22E9',
        succsim: '\u227F',
        SuchThat: '\u220B',
        Sum: '\u2211',
        sum: '\u2211',
        sung: '\u266A',
        Sup: '\u22D1',
        sup: '\u2283',
        sup1: '\xB9',
        sup2: '\xB2',
        sup3: '\xB3',
        supdot: '\u2ABE',
        supdsub: '\u2AD8',
        supE: '\u2AC6',
        supe: '\u2287',
        supedot: '\u2AC4',
        Superset: '\u2283',
        SupersetEqual: '\u2287',
        suphsol: '\u27C9',
        suphsub: '\u2AD7',
        suplarr: '\u297B',
        supmult: '\u2AC2',
        supnE: '\u2ACC',
        supne: '\u228B',
        supplus: '\u2AC0',
        Supset: '\u22D1',
        supset: '\u2283',
        supseteq: '\u2287',
        supseteqq: '\u2AC6',
        supsetneq: '\u228B',
        supsetneqq: '\u2ACC',
        supsim: '\u2AC8',
        supsub: '\u2AD4',
        supsup: '\u2AD6',
        swarhk: '\u2926',
        swArr: '\u21D9',
        swarr: '\u2199',
        swarrow: '\u2199',
        swnwar: '\u292A',
        szlig: 'ß',
        Tab: '\t',
        target: '\u2316',
        Tau: 'Τ',
        tau: 'τ',
        tbrk: '\u23B4',
        Tcaron: 'Ť',
        tcaron: 'ť',
        Tcedil: 'Ţ',
        tcedil: 'ţ',
        Tcy: 'Т',
        tcy: 'т',
        tdot: '⃛',
        telrec: '\u2315',
        Tfr: '\uD835\uDD17',
        tfr: '\uD835\uDD31',
        there4: '\u2234',
        Therefore: '\u2234',
        therefore: '\u2234',
        Theta: 'Θ',
        theta: 'θ',
        thetasym: 'ϑ',
        thetav: 'ϑ',
        thickapprox: '\u2248',
        thicksim: '\u223C',
        ThickSpace: '\u205F\u200A',
        thinsp: '\u2009',
        ThinSpace: '\u2009',
        thkap: '\u2248',
        thksim: '\u223C',
        THORN: 'Þ',
        thorn: 'þ',
        Tilde: '\u223C',
        tilde: '\u02DC',
        TildeEqual: '\u2243',
        TildeFullEqual: '\u2245',
        TildeTilde: '\u2248',
        times: '\xD7',
        timesb: '\u22A0',
        timesbar: '\u2A31',
        timesd: '\u2A30',
        tint: '\u222D',
        toea: '\u2928',
        top: '\u22A4',
        topbot: '\u2336',
        topcir: '\u2AF1',
        Topf: '\uD835\uDD4B',
        topf: '\uD835\uDD65',
        topfork: '\u2ADA',
        tosa: '\u2929',
        tprime: '\u2034',
        TRADE: '\u2122',
        trade: '\u2122',
        triangle: '\u25B5',
        triangledown: '\u25BF',
        triangleleft: '\u25C3',
        trianglelefteq: '\u22B4',
        triangleq: '\u225C',
        triangleright: '\u25B9',
        trianglerighteq: '\u22B5',
        tridot: '\u25EC',
        trie: '\u225C',
        triminus: '\u2A3A',
        TripleDot: '⃛',
        triplus: '\u2A39',
        trisb: '\u29CD',
        tritime: '\u2A3B',
        trpezium: '\u23E2',
        Tscr: '\uD835\uDCAF',
        tscr: '\uD835\uDCC9',
        TScy: 'Ц',
        tscy: 'ц',
        TSHcy: 'Ћ',
        tshcy: 'ћ',
        Tstrok: 'Ŧ',
        tstrok: 'ŧ',
        twixt: '\u226C',
        twoheadleftarrow: '\u219E',
        twoheadrightarrow: '\u21A0',
        Uacute: 'Ú',
        uacute: 'ú',
        Uarr: '\u219F',
        uArr: '\u21D1',
        uarr: '\u2191',
        Uarrocir: '\u2949',
        Ubrcy: 'Ў',
        ubrcy: 'ў',
        Ubreve: 'Ŭ',
        ubreve: 'ŭ',
        Ucirc: 'Û',
        ucirc: 'û',
        Ucy: 'У',
        ucy: 'у',
        udarr: '\u21C5',
        Udblac: 'Ű',
        udblac: 'ű',
        udhar: '\u296E',
        ufisht: '\u297E',
        Ufr: '\uD835\uDD18',
        ufr: '\uD835\uDD32',
        Ugrave: 'Ù',
        ugrave: 'ù',
        uHar: '\u2963',
        uharl: '\u21BF',
        uharr: '\u21BE',
        uhblk: '\u2580',
        ulcorn: '\u231C',
        ulcorner: '\u231C',
        ulcrop: '\u230F',
        ultri: '\u25F8',
        Umacr: 'Ū',
        umacr: 'ū',
        uml: '\xA8',
        UnderBar: '_',
        UnderBrace: '\u23DF',
        UnderBracket: '\u23B5',
        UnderParenthesis: '\u23DD',
        Union: '\u22C3',
        UnionPlus: '\u228E',
        Uogon: 'Ų',
        uogon: 'ų',
        Uopf: '\uD835\uDD4C',
        uopf: '\uD835\uDD66',
        UpArrow: '\u2191',
        Uparrow: '\u21D1',
        uparrow: '\u2191',
        UpArrowBar: '\u2912',
        UpArrowDownArrow: '\u21C5',
        UpDownArrow: '\u2195',
        Updownarrow: '\u21D5',
        updownarrow: '\u2195',
        UpEquilibrium: '\u296E',
        upharpoonleft: '\u21BF',
        upharpoonright: '\u21BE',
        uplus: '\u228E',
        UpperLeftArrow: '\u2196',
        UpperRightArrow: '\u2197',
        Upsi: 'ϒ',
        upsi: 'υ',
        upsih: 'ϒ',
        Upsilon: 'Υ',
        upsilon: 'υ',
        UpTee: '\u22A5',
        UpTeeArrow: '\u21A5',
        upuparrows: '\u21C8',
        urcorn: '\u231D',
        urcorner: '\u231D',
        urcrop: '\u230E',
        Uring: 'Ů',
        uring: 'ů',
        urtri: '\u25F9',
        Uscr: '\uD835\uDCB0',
        uscr: '\uD835\uDCCA',
        utdot: '\u22F0',
        Utilde: 'Ũ',
        utilde: 'ũ',
        utri: '\u25B5',
        utrif: '\u25B4',
        uuarr: '\u21C8',
        Uuml: 'Ü',
        uuml: 'ü',
        uwangle: '\u29A7',
        vangrt: '\u299C',
        varepsilon: 'ϵ',
        varkappa: 'ϰ',
        varnothing: '\u2205',
        varphi: 'ϕ',
        varpi: 'ϖ',
        varpropto: '\u221D',
        vArr: '\u21D5',
        varr: '\u2195',
        varrho: 'ϱ',
        varsigma: 'ς',
        varsubsetneq: '\u228A︀',
        varsubsetneqq: '\u2ACB︀',
        varsupsetneq: '\u228B︀',
        varsupsetneqq: '\u2ACC︀',
        vartheta: 'ϑ',
        vartriangleleft: '\u22B2',
        vartriangleright: '\u22B3',
        Vbar: '\u2AEB',
        vBar: '\u2AE8',
        vBarv: '\u2AE9',
        Vcy: 'В',
        vcy: 'в',
        VDash: '\u22AB',
        Vdash: '\u22A9',
        vDash: '\u22A8',
        vdash: '\u22A2',
        Vdashl: '\u2AE6',
        Vee: '\u22C1',
        vee: '\u2228',
        veebar: '\u22BB',
        veeeq: '\u225A',
        vellip: '\u22EE',
        Verbar: '\u2016',
        verbar: '|',
        Vert: '\u2016',
        vert: '|',
        VerticalBar: '\u2223',
        VerticalLine: '|',
        VerticalSeparator: '\u2758',
        VerticalTilde: '\u2240',
        VeryThinSpace: '\u200A',
        Vfr: '\uD835\uDD19',
        vfr: '\uD835\uDD33',
        vltri: '\u22B2',
        vnsub: '\u2282⃒',
        vnsup: '\u2283⃒',
        Vopf: '\uD835\uDD4D',
        vopf: '\uD835\uDD67',
        vprop: '\u221D',
        vrtri: '\u22B3',
        Vscr: '\uD835\uDCB1',
        vscr: '\uD835\uDCCB',
        vsubnE: '\u2ACB︀',
        vsubne: '\u228A︀',
        vsupnE: '\u2ACC︀',
        vsupne: '\u228B︀',
        Vvdash: '\u22AA',
        vzigzag: '\u299A',
        Wcirc: 'Ŵ',
        wcirc: 'ŵ',
        wedbar: '\u2A5F',
        Wedge: '\u22C0',
        wedge: '\u2227',
        wedgeq: '\u2259',
        weierp: '\u2118',
        Wfr: '\uD835\uDD1A',
        wfr: '\uD835\uDD34',
        Wopf: '\uD835\uDD4E',
        wopf: '\uD835\uDD68',
        wp: '\u2118',
        wr: '\u2240',
        wreath: '\u2240',
        Wscr: '\uD835\uDCB2',
        wscr: '\uD835\uDCCC',
        xcap: '\u22C2',
        xcirc: '\u25EF',
        xcup: '\u22C3',
        xdtri: '\u25BD',
        Xfr: '\uD835\uDD1B',
        xfr: '\uD835\uDD35',
        xhArr: '\u27FA',
        xharr: '\u27F7',
        Xi: 'Ξ',
        xi: 'ξ',
        xlArr: '\u27F8',
        xlarr: '\u27F5',
        xmap: '\u27FC',
        xnis: '\u22FB',
        xodot: '\u2A00',
        Xopf: '\uD835\uDD4F',
        xopf: '\uD835\uDD69',
        xoplus: '\u2A01',
        xotime: '\u2A02',
        xrArr: '\u27F9',
        xrarr: '\u27F6',
        Xscr: '\uD835\uDCB3',
        xscr: '\uD835\uDCCD',
        xsqcup: '\u2A06',
        xuplus: '\u2A04',
        xutri: '\u25B3',
        xvee: '\u22C1',
        xwedge: '\u22C0',
        Yacute: 'Ý',
        yacute: 'ý',
        YAcy: 'Я',
        yacy: 'я',
        Ycirc: 'Ŷ',
        ycirc: 'ŷ',
        Ycy: 'Ы',
        ycy: 'ы',
        yen: '\xA5',
        Yfr: '\uD835\uDD1C',
        yfr: '\uD835\uDD36',
        YIcy: 'Ї',
        yicy: 'ї',
        Yopf: '\uD835\uDD50',
        yopf: '\uD835\uDD6A',
        Yscr: '\uD835\uDCB4',
        yscr: '\uD835\uDCCE',
        YUcy: 'Ю',
        yucy: 'ю',
        Yuml: 'Ÿ',
        yuml: 'ÿ',
        Zacute: 'Ź',
        zacute: 'ź',
        Zcaron: 'Ž',
        zcaron: 'ž',
        Zcy: 'З',
        zcy: 'з',
        Zdot: 'Ż',
        zdot: 'ż',
        zeetrf: 'ℨ',
        ZeroWidthSpace: '\u200B',
        Zeta: 'Ζ',
        zeta: 'ζ',
        Zfr: 'ℨ',
        zfr: '\uD835\uDD37',
        ZHcy: 'Ж',
        zhcy: 'ж',
        zigrarr: '\u21DD',
        Zopf: 'ℤ',
        zopf: '\uD835\uDD6B',
        Zscr: '\uD835\uDCB5',
        zscr: '\uD835\uDCCF',
        zwj: '‍',
        zwnj: '‌'
    };
    return {
        get default() {
            return $__default;
        },
        __esModule: true
    };
});
/*simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/tokenize*/
define('simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/tokenize', [
    './tokenizer',
    './entity-parser',
    './html5-named-char-refs'
], function ($__0, $__2, $__4) {
    'use strict';
    if (!$__0 || !$__0.__esModule)
        $__0 = { default: $__0 };
    if (!$__2 || !$__2.__esModule)
        $__2 = { default: $__2 };
    if (!$__4 || !$__4.__esModule)
        $__4 = { default: $__4 };
    var Tokenizer = $__0.default;
    var EntityParser = $__2.default;
    var namedCharRefs = $__4.default;
    function tokenize(input, options) {
        var tokenizer = new Tokenizer(new EntityParser(namedCharRefs), options);
        return tokenizer.tokenize(input);
    }
    var $__default = tokenize;
    return {
        get default() {
            return $__default;
        },
        __esModule: true
    };
});
/*can-simple-dom@1.0.5#simple-dom/default-tokenize*/
define('can-simple-dom@1.0.5#simple-dom/default-tokenize', ['simple-html-tokenizer/lib/simple-html-tokenizer/tokenize'], function ($__0) {
    'use strict';
    if (!$__0 || !$__0.__esModule)
        $__0 = { default: $__0 };
    var tokenize = $__0.default;
    var $__default = function (input) {
        return tokenize(input);
    };
    ;
    return {
        get default() {
            return $__default;
        },
        __esModule: true
    };
});
/*can-simple-dom@1.0.5#test/element-sp-test*/
define('can-simple-dom@1.0.5#test/element-sp-test', [
    'can-simple-dom',
    'steal-qunit',
    'can-simple-dom/simple-dom/html-parser',
    'can-simple-dom/simple-dom/void-map',
    'can-simple-dom/simple-dom/html-serializer',
    'can-simple-dom/simple-dom/default-tokenize'
], function ($__0, $__2, $__4, $__6, $__8, $__10) {
    'use strict';
    if (!$__0 || !$__0.__esModule)
        $__0 = { default: $__0 };
    if (!$__2 || !$__2.__esModule)
        $__2 = { default: $__2 };
    if (!$__4 || !$__4.__esModule)
        $__4 = { default: $__4 };
    if (!$__6 || !$__6.__esModule)
        $__6 = { default: $__6 };
    if (!$__8 || !$__8.__esModule)
        $__8 = { default: $__8 };
    if (!$__10 || !$__10.__esModule)
        $__10 = { default: $__10 };
    var Document = $__0.Document;
    var QUnit = $__2.default;
    var Parser = $__4.default;
    var voidMap = $__6.default;
    var Serializer = $__8.default;
    var tokenize = $__10.default;
    QUnit.module('can-simple-dom - Element with serialization and parsing');
    QUnit.test('document.implementation is supported (#23)', function () {
        var document = new Document();
        document.__addSerializerAndParser(new Serializer(voidMap), new Parser(tokenize, document, voidMap));
        ok(document.implementation, 'implementation exists');
        var doc2 = document.implementation.createHTMLDocument('');
        ok(doc2.body, 'has a body');
    });
    QUnit.test('innerHTML supported', function () {
        var document = new Document();
        document.__addSerializerAndParser(new Serializer(voidMap), new Parser(tokenize, document, voidMap));
        document.body.innerHTML = '<span class=\'bar\'>HI</span>';
        QUnit.equal(document.body.firstChild.nodeName, 'SPAN');
        QUnit.equal(document.body.firstChild.className, 'bar');
        QUnit.equal(document.body.firstChild.firstChild.nodeValue, 'HI');
        QUnit.equal(document.body.innerHTML, '<span class="bar">HI</span>');
    });
    QUnit.test('outerHTML supported', function () {
        var document = new Document();
        document.__addSerializerAndParser(new Serializer(voidMap), new Parser(tokenize, document, voidMap));
        document.body.innerHTML = '<span/><div id=\'item\'>HI</div><span/>';
        var item = document.getElementById('item');
        QUnit.equal(item.outerHTML, '<div id="item">HI</div>', 'getter');
        item.outerHTML = '<label>IT</label>';
        QUnit.equal(document.body.innerHTML, '<span></span><label>IT</label><span></span>', 'setter');
    });
    return {};
});
/*can-simple-dom@1.0.5#test/element-event-test*/
define('can-simple-dom@1.0.5#test/element-event-test', [
    'can-simple-dom/simple-dom/document',
    'can-simple-dom/simple-dom/html-serializer',
    'can-simple-dom/simple-dom/void-map',
    './support',
    'steal-qunit'
], function ($__0, $__2, $__4, $__6, $__8) {
    'use strict';
    if (!$__0 || !$__0.__esModule)
        $__0 = { default: $__0 };
    if (!$__2 || !$__2.__esModule)
        $__2 = { default: $__2 };
    if (!$__4 || !$__4.__esModule)
        $__4 = { default: $__4 };
    if (!$__6 || !$__6.__esModule)
        $__6 = { default: $__6 };
    if (!$__8 || !$__8.__esModule)
        $__8 = { default: $__8 };
    var Document = $__0.default;
    var Serializer = $__2.default;
    var voidMap = $__4.default;
    var $__7 = $__6, element = $__7.element, fragment = $__7.fragment, text = $__7.text;
    var QUnit = $__8.default;
    QUnit.module('can-simple-dom - Event');
    QUnit.test('basic bubbling', 4, function (assert) {
        var document = new Document();
        var elem = document.createElement('div');
        document.body.appendChild(elem);
        document.addEventListener('foo', function (event) {
            assert.strictEqual(event.currentTarget, document, 'document current target');
        });
        document.documentElement.addEventListener('foo', function (event) {
            assert.strictEqual(event.currentTarget, document.documentElement, 'documentElement current target');
        });
        document.body.addEventListener('foo', function (event) {
            assert.strictEqual(event.currentTarget, document.body, 'body current target');
        });
        elem.addEventListener('foo', function (event) {
            assert.strictEqual(event.currentTarget, elem, 'elem current target');
        });
        document.body.appendChild(elem);
        var ev = document.createEvent('HTMLEvents');
        ev.initEvent('foo', true, false);
        elem.dispatchEvent(ev);
    });
    QUnit.test('stop propagation', 2, function (assert) {
        var document = new Document();
        var elem = document.createElement('div');
        document.body.appendChild(elem);
        document.addEventListener('foo', function (event) {
            assert.strictEqual(event.currentTarget, document, 'document current target');
        });
        document.documentElement.addEventListener('foo', function (event) {
            assert.strictEqual(event.currentTarget, document.documentElement, 'documentElement current target');
        });
        document.body.addEventListener('foo', function (event) {
            assert.strictEqual(event.currentTarget, document.body, 'body current target');
            event.stopPropagation();
        });
        elem.addEventListener('foo', function (event) {
            assert.strictEqual(event.currentTarget, elem, 'elem current target');
        });
        document.body.appendChild(elem);
        var ev = document.createEvent('HTMLEvents');
        ev.initEvent('foo', true, false);
        elem.dispatchEvent(ev);
    });
    QUnit.test('initEvent without bubbling', 2, function (assert) {
        var document = new Document();
        var elem = document.createElement('div');
        document.body.appendChild(elem);
        document.body.addEventListener('foo', function (event) {
            assert.strictEqual(event.currentTarget, document.body, 'body current target');
            event.stopPropagation();
        });
        elem.addEventListener('foo', function (event) {
            assert.strictEqual(event.currentTarget, elem, 'elem current target');
        });
        elem.addEventListener('foo', function (event) {
            assert.strictEqual(event.currentTarget, elem, 'elem current target');
        });
        document.body.appendChild(elem);
        var ev = document.createEvent('HTMLEvents');
        ev.initEvent('foo', false, false);
        elem.dispatchEvent(ev);
    });
    QUnit.test('this inside event handler', function (assert) {
        var document = new Document();
        var elem = document.createElement('div');
        document.body.appendChild(elem);
        elem.addEventListener('foo', function () {
            assert.equal(this, elem, 'this is the element');
        });
        var ev = document.createEvent('HTMLEvents');
        ev.initEvent('foo', true, false);
        elem.dispatchEvent(ev);
    });
    return {};
});
/*can-simple-dom@1.0.5#test/parser-test*/
define('can-simple-dom@1.0.5#test/parser-test', [
    './support',
    'can-simple-dom/simple-dom/html-parser',
    'can-simple-dom/simple-dom/void-map',
    'can-simple-dom/simple-dom/default-tokenize',
    'steal-qunit'
], function ($__0, $__2, $__4, $__6, $__8) {
    'use strict';
    if (!$__0 || !$__0.__esModule)
        $__0 = { default: $__0 };
    if (!$__2 || !$__2.__esModule)
        $__2 = { default: $__2 };
    if (!$__4 || !$__4.__esModule)
        $__4 = { default: $__4 };
    if (!$__6 || !$__6.__esModule)
        $__6 = { default: $__6 };
    if (!$__8 || !$__8.__esModule)
        $__8 = { default: $__8 };
    var document = $__0.document;
    var Parser = $__2.default;
    var voidMap = $__4.default;
    var tokenize = $__6.default;
    var QUnit = $__8.default;
    QUnit.module('can-simple-dom - Basic HTML parsing', {
        beforeEach: function () {
            this.parser = new Parser(tokenize, document, voidMap);
        }
    });
    QUnit.test('simple parse', function (assert) {
        var fragment = this.parser.parse('<div>Hello</div>');
        assert.ok(fragment);
        var node = fragment.firstChild;
        assert.ok(node);
        assert.equal(node.nodeType, 1);
        assert.equal(node.nodeName.toLowerCase(), 'div');
        assert.ok(node.firstChild);
        assert.equal(node.firstChild.nodeType, 3);
        assert.equal(node.firstChild.nodeValue, 'Hello');
    });
    QUnit.test('nested parse', function (assert) {
        var fragment = this.parser.parse('text before<div>Hello</div>text between<div id=foo title="Hello World">World</div>text after');
        assert.ok(fragment);
        var node = fragment.firstChild;
        assert.ok(node);
        assert.equal(node.nodeType, 3);
        assert.equal(node.nodeValue, 'text before');
        node = node.nextSibling;
        assert.ok(node);
        assert.equal(node.nodeType, 1);
        assert.equal(node.nodeName, 'DIV');
        assert.ok(node.firstChild);
        assert.equal(node.firstChild.nodeType, 3);
        assert.equal(node.firstChild.nodeValue, 'Hello');
        node = node.nextSibling;
        assert.ok(node);
        assert.equal(node.nodeType, 3);
        assert.equal(node.nodeValue, 'text between');
        node = node.nextSibling;
        assert.ok(node);
        assert.equal(node.nodeType, 1);
        assert.equal(node.nodeName, 'DIV');
        var expectedValues = {
            id: 'foo',
            title: 'Hello World'
        };
        assert.equal(node.attributes.length, 2);
        assert.equal(node.attributes[0].value, expectedValues[node.attributes[0].name]);
        assert.equal(node.attributes[1].value, expectedValues[node.attributes[1].name]);
        assert.equal(node.attributes.length, 2);
        assert.ok(node.firstChild);
        assert.equal(node.firstChild.nodeType, 3);
        assert.equal(node.firstChild.nodeValue, 'World');
        node = node.nextSibling;
        assert.ok(node);
        assert.equal(node.nodeType, 3);
        assert.equal(node.nodeValue, 'text after');
    });
    QUnit.test('void tags', function (assert) {
        var fragment = this.parser.parse('<div>Hello<br>World<img src="http://example.com/image.png?foo=bar&bar=foo"></div>');
        assert.ok(fragment);
        var node = fragment.firstChild;
        assert.ok(node);
        assert.equal(node.nodeType, 1);
        assert.equal(node.nodeName, 'DIV');
        node = node.firstChild;
        assert.ok(node);
        assert.equal(node.nodeType, 3);
        assert.equal(node.nodeValue, 'Hello');
        node = node.nextSibling;
        assert.ok(node);
        assert.equal(node.nodeType, 1);
        assert.equal(node.nodeName, 'BR');
        node = node.nextSibling;
        assert.ok(node);
        assert.equal(node.nodeType, 3);
        assert.equal(node.nodeValue, 'World');
        node = node.nextSibling;
        assert.ok(node);
        assert.equal(node.nodeType, 1);
        assert.equal(node.nodeName, 'IMG');
        assert.equal(node.getAttribute('src'), 'http://example.com/image.png?foo=bar&bar=foo');
        assert.equal(node.nextSibling, null);
    });
    QUnit.test('simple charater encode', function (assert) {
        var fragment = this.parser.parse('hello > world &amp; &nbsp;&nbsp;goodbye');
        assert.ok(fragment);
        var node = fragment.firstChild;
        assert.ok(node);
        assert.equal(node.nodeType, 3);
        assert.equal(node.nodeValue, 'hello &#x3E; world &#x26; &#xA0;&#xA0;goodbye');
    });
    QUnit.test('node child charater encode', function (assert) {
        var fragment = this.parser.parse('<div>Foo & Bar &amp; Baz &lt; Buz &gt; Biz</div>');
        assert.ok(fragment);
        var node = fragment.firstChild;
        assert.ok(node);
        assert.equal(node.nodeType, 1);
        assert.equal(node.nodeName, 'DIV');
        node = node.firstChild;
        assert.ok(node);
        assert.equal(node.nodeType, 3);
        assert.equal(node.nodeValue, 'Foo &#x26; Bar &#x26; Baz &#x3C; Buz &#x3E; Biz');
    });
    QUnit.test('node attribute charater encode', function (assert) {
        var fragment = this.parser.parse('<div title="&nbsp;foo & bar &amp; baz < buz > biz"></div>');
        assert.ok(fragment);
        var node = fragment.firstChild;
        assert.ok(node);
        assert.equal(node.nodeType, 1);
        assert.equal(node.nodeName, 'DIV');
        var attibutes = node.attributes;
        assert.ok(attibutes.length);
        var title = attibutes[0];
        assert.equal(title.name, 'title');
        assert.equal(title.value, '&#xA0;foo &#x26; bar &#x26; baz &#x3C; buz &#x3E; biz');
    });
    return {};
});
/*can-simple-dom@1.0.5#test/test*/
define('can-simple-dom@1.0.5#test/test', [
    './element-test',
    './serializer-test',
    './element-sp-test',
    './element-event-test',
    './parser-test'
], function ($__0, $__1, $__2, $__3, $__4) {
    'use strict';
    if (!$__0 || !$__0.__esModule)
        $__0 = { default: $__0 };
    if (!$__1 || !$__1.__esModule)
        $__1 = { default: $__1 };
    if (!$__2 || !$__2.__esModule)
        $__2 = { default: $__2 };
    if (!$__3 || !$__3.__esModule)
        $__3 = { default: $__3 };
    if (!$__4 || !$__4.__esModule)
        $__4 = { default: $__4 };
    $__0;
    $__1;
    $__2;
    $__3;
    $__4;
    return {};
});
/*can-control@3.0.7#can-control_test*/
define('can-control@3.0.7#can-control_test', function (require, exports, module) {
    var Control = require('can-control');
    var QUnit = require('steal-qunit');
    var fragment = require('can-util/dom/fragment/');
    var domData = require('can-util/dom/data/');
    var dev = require('can-util/js/dev/');
    var domDispatch = require('can-util/dom/dispatch/');
    var domMutate = require('can-util/dom/mutate/');
    var canEvent = require('can-event');
    var types = require('can-types');
    var CanMap = require('can-map');
    var DefineMap = require('can-define/map/');
    QUnit.module('can-control', {
        setup: function () {
            this.fixture = document.getElementById('qunit-fixture');
        }
    });
    test('data', function () {
        var Things = Control.extend({});
        this.fixture.appendChild(fragment('<div id=\'things\'>div<span>span</span></div>'));
        var things = document.getElementById('things');
        new Things('#things', {});
        new Things('#things', {});
        equal(domData.get.call(things, 'controls').length, 2, 'there are 2 items in the data array');
    });
    test('parameterized actions', function () {
        var called = false, WeirderBind = Control.extend({
                '{parameterized}': function () {
                    called = true;
                }
            }), a;
        this.fixture.appendChild(fragment('<div id=\'crazy\'></div>'));
        a = document.getElementById('crazy');
        new WeirderBind(a, { parameterized: 'sillyEvent' });
        domDispatch.call(a, 'sillyEvent');
        ok(called, 'heard the trigger');
    });
    test('windowresize', function () {
        var called = false, WindowBind = Control.extend('', {
                '{window} resize': function () {
                    called = true;
                }
            });
        this.fixture.appendChild(fragment('<div id=\'weird\'>'));
        new WindowBind('#weird');
        domDispatch.call(window, 'resize');
        ok(called, 'got window resize event');
    });
    test('on', 9, function () {
        var called = false, DelegateTest = Control.extend({
                click: function () {
                }
            }), Tester = Control.extend({
                init: function (el, ops) {
                    this.on(window, 'click', function (ev) {
                        ok(true, 'Got window click event');
                    });
                    this.on(window, 'click', 'clicked');
                    this.on('click', function () {
                        ok(true, 'Directly clicked element');
                    });
                    this.on('click', 'clicked');
                },
                clicked: function (context) {
                    ok(true, 'Controller action delegated click triggered, too');
                }
            }), div = document.createElement('div');
        this.fixture.appendChild(div);
        var rb = new Tester(div);
        this.fixture.appendChild(fragment('<div id=\'els\'><span id=\'elspan\'><a href=\'javascript://\' id=\'elsa\'>click me</a></span></div>'));
        var dt = new DelegateTest('#els');
        dt.on(document.querySelector('#els span'), 'a', 'click', function () {
            called = true;
        });
        domDispatch.call(document.querySelector('#els a'), 'click');
        ok(called, 'delegate works');
        domMutate.removeChild.call(this.fixture, document.querySelector('#els'));
        domDispatch.call(div, 'click');
        domDispatch.call(window, 'click');
        rb.destroy();
    });
    test('inherit', function () {
        var called = false, Parent = Control.extend({
                click: function () {
                    called = true;
                }
            }), Child = Parent.extend({});
        this.fixture.appendChild(fragment('<div id=\'els\'><span id=\'elspan\'><a href=\'#\' id=\'elsa\'>click me</a></span></div>'));
        new Child('#els');
        domDispatch.call(document.querySelector('#els'), 'click');
        ok(called, 'inherited the click method');
    });
    test('space makes event', 1, function () {
        var Dot = Control.extend({
            ' foo': function () {
                ok(true, 'called');
            }
        });
        this.fixture.appendChild(fragment('<div id=\'els\'><span id=\'elspan\'><a href=\'#\' id=\'elsa\'>click me</a></span></div>'));
        new Dot('#els');
        domDispatch.call(document.querySelector('#els'), 'foo');
    });
    test('custom events with hyphens work', 1, function () {
        this.fixture.appendChild(fragment('<div id=\'customEvent\'><span></span></div>'));
        var FooBar = Control.extend({
            'span custom-event': function () {
                ok(true, 'Custom event was fired.');
            }
        });
        new FooBar('#customEvent');
        domDispatch.call(document.querySelector('#customEvent span'), 'custom-event');
    });
    test('inherit defaults', function () {
        var BASE = Control.extend({ defaults: { foo: 'bar' } }, {});
        var INHERIT = BASE.extend({ defaults: { newProp: 'newVal' } }, {});
        ok(INHERIT.defaults.foo === 'bar', 'Class must inherit defaults from the parent class');
        ok(INHERIT.defaults.newProp === 'newVal', 'Class must have own defaults');
        var inst = new INHERIT(document.createElement('div'), {});
        ok(inst.options.foo === 'bar', 'Instance must inherit defaults from the parent class');
        ok(inst.options.newProp === 'newVal', 'Instance must have defaults of it`s class');
    });
    var bindable = function (b) {
        if (window.jQuery) {
            return b;
        } else {
        }
        return b;
    };
    test('on rebinding', 2, function () {
        var first = true;
        var Rebinder = Control.extend({
            '{item} foo': function (item, ev) {
                if (first) {
                    equal(item.id, 1, 'first item');
                    first = false;
                } else {
                    equal(item.id, 2, 'first item');
                }
            }
        });
        var item1 = bindable({ id: 1 }), item2 = bindable({ id: 2 }), rb = new Rebinder(document.createElement('div'), { item: item1 });
        canEvent.trigger.call(item1, 'foo');
        rb.options = { item: item2 };
        rb.on();
        canEvent.trigger.call(item2, 'foo');
    });
    test('actions provide method names', function () {
        var item1 = {};
        var item2 = {};
        var Tester = Control.extend({
            '{item1} foo': 'food',
            '{item2} bar': 'food',
            food: function (item, ev, data) {
                ok(true, 'food called');
                ok(item === item1 || item === item2, 'called with an item');
            }
        });
        new Tester(document.createElement('div'), {
            item1: item1,
            item2: item2
        });
        canEvent.trigger.call(item1, 'foo');
        canEvent.trigger.call(item2, 'bar');
    });
    test('Don\'t bind if there are undefined values in templates', function () {
        var C = Control.extend({}, {
            '{noExistStuff} proc': function () {
            }
        });
        var c = new C(document.createElement('div'));
        equal(c._bindings.user.length, 1, 'There is only one binding');
        var C2 = Control.extend({
            '{noExistStuff} click': function () {
                ok(false, 'should not fall through to click handler');
            }
        });
        var div = document.createElement('div');
        new C2(div, {});
        canEvent.trigger.call(div, 'click');
    });
    test('Multiple calls to destroy', 2, function () {
        var C = Control.extend({
                destroy: function () {
                    ok(true);
                    Control.prototype.destroy.call(this);
                }
            }), div = document.createElement('div'), c = new C(div);
        c.destroy();
        c.destroy();
    });
    test('drag and drop events', function () {
        expect(7);
        var DragDrop = Control.extend('', {
            ' dragstart': function () {
                ok(true, 'dragstart called');
            },
            ' dragenter': function () {
                ok(true, 'dragenter called');
            },
            ' dragover': function () {
                ok(true, 'dragover called');
            },
            ' dragleave': function () {
                ok(true, 'dragleave called');
            },
            ' drag': function () {
                ok(true, 'drag called');
            },
            ' drop': function () {
                ok(true, 'drop called');
            },
            ' dragend': function () {
                ok(true, 'dragend called');
            }
        });
        this.fixture.appendChild(fragment('<div id="draggable"/>'));
        new DragDrop('#draggable');
        var draggable = document.getElementById('draggable');
        domDispatch.call(draggable, 'dragstart');
        domDispatch.call(draggable, 'dragenter');
        domDispatch.call(draggable, 'dragover');
        domDispatch.call(draggable, 'dragleave');
        domDispatch.call(draggable, 'drag');
        domDispatch.call(draggable, 'drop');
        domDispatch.call(draggable, 'dragend');
    });
    if (System.env.indexOf('production') < 0) {
        test('Control is logging information in dev mode', function () {
            expect(2);
            var oldlog = dev.log;
            var oldwarn = dev.warn;
            dev.log = function (text) {
                equal(text, 'can/control/control.js: No property found for handling {dummy} change', 'Text logged as expected');
            };
            var C = Control.extend({
                '{dummy} change': function () {
                }
            });
            var instance = new C(document.createElement('div'));
            dev.warn = function (text) {
                equal(text, 'can/control/control.js: Control already destroyed');
            };
            instance.destroy();
            instance.destroy();
            dev.warn = oldwarn;
            dev.log = oldlog;
        });
    }
    test('Uses types.wrapElement', function () {
        expect(3);
        var $ = function (element) {
            this.element = element;
        };
        var wrapElement = types.wrapElement;
        var unwrapElement = types.unwrapElement;
        types.wrapElement = function (element) {
            return new $(element);
        };
        types.unwrapElement = function (object) {
            return object.element;
        };
        var MyControl = Control.extend({
            init: function (element) {
                ok(element instanceof $, 'element is wrapped');
                ok(this.element instanceof $, 'this.element is wrapped');
            },
            'click': function (element) {
                types.wrapElement = wrapElement;
                types.unwrapElement = unwrapElement;
                ok(element instanceof $);
            }
        });
        var el = document.createElement('div');
        el.innerHTML = 'Click Me!';
        new MyControl(el);
        canEvent.trigger.call(el, 'click');
    });
    test('event handlers should rebind when target is replaced', function () {
        var nameChanges = 0;
        var MyControl = Control.extend({
            '{person.name} first': function () {
                nameChanges++;
            },
            name: function (name) {
                this.options.person.attr('name', name);
            }
        });
        var c = new MyControl(document.createElement('div'), { person: new CanMap({ name: { first: 'Kevin' } }) });
        c.options.person.attr('name.first', 'Tracy');
        c.name({ first: 'Kim' });
        c.options.person.attr('name.first', 'Max');
        equal(nameChanges, 2);
    });
    test('{element} event handling', function () {
        expect(3);
        stop();
        var MyControl = Control.extend({
            '{element} click': function (element) {
                if (element === this.element) {
                    ok(true, '`{element} click` should catch clicking on the element');
                } else {
                    ok(true, '`{element} click` should catch clicking on a child of the element');
                }
            },
            '{element} p click': function () {
                ok(true, '`{element} p click` works');
                start();
            }
        });
        var div = document.createElement('div');
        var p = document.createElement('p');
        div.appendChild(p);
        new MyControl(div, { foo: 'bar' });
        canEvent.trigger.call(div, 'click');
        canEvent.trigger.call(p, 'click');
    });
    test('Passing a Map as options works', function () {
        expect(2);
        stop();
        var MyControl = Control.extend({ defaults: { testEndEvent: 'mouseleave' } }, {
            '{element} {eventType}': function () {
                ok(true, 'catches handler from options');
            },
            '{element} {testEndEvent}': function () {
                ok(true, 'catches handler from defaults');
                start();
            }
        });
        var map = new CanMap({ eventType: 'click' });
        var div = document.createElement('div');
        new MyControl(div, map);
        map.attr('eventType', 'mouseenter');
        canEvent.trigger.call(div, 'mouseenter');
        canEvent.trigger.call(div, 'mouseleave');
    });
    test('Passing a DefineMap as options works', function () {
        expect(2);
        stop();
        var MyControl = Control.extend({ defaults: { testEndEvent: 'mouseleave' } }, {
            '{element} {eventType}': function () {
                ok(true, 'catches handler from options');
            },
            '{element} {testEndEvent}': function () {
                ok(true, 'catches handler from defaults');
                start();
            }
        });
        var MyMap = DefineMap.extend({
            eventType: 'string',
            testEndEvent: 'string'
        });
        var map = new MyMap();
        map.eventType = 'click';
        var div = document.createElement('div');
        new MyControl(div, map);
        map.eventType = 'mousenter';
        canEvent.trigger.call(div, 'mousenter');
        canEvent.trigger.call(div, 'mouseleave');
    });
});
/*can@3.4.1#control/control_test*/
define('can@3.4.1#control/control_test', function (require, exports, module) {
    require('can-control/can-control_test');
});
/*can-map-define@3.0.5#can-map-define*/
define('can-map-define@3.0.5#can-map-define', function (require, exports, module) {
    var dev = require('can-util/js/dev/dev');
    var extend = require('can-util/js/assign/assign');
    var isPlainObject = require('can-util/js/is-plain-object/is-plain-object');
    var canEvent = require('can-event');
    var batch = require('can-event/batch/batch');
    var mapHelpers = require('can-map/map-helpers');
    var CanMap = require('can-map');
    var compute = require('can-compute');
    var define = {};
    var getPropDefineBehavior = function (behavior, attr, define) {
        var prop, defaultProp;
        if (define) {
            prop = define[attr];
            defaultProp = define['*'];
            if (prop && prop[behavior] !== undefined) {
                return prop[behavior];
            } else if (defaultProp && defaultProp[behavior] !== undefined) {
                return defaultProp[behavior];
            }
        }
    };
    mapHelpers.define = function (Map, baseDefine) {
        var definitions = Map.prototype.define;
        if (baseDefine) {
            var defines = {};
            mapHelpers.twoLevelDeepExtend(defines, baseDefine);
            mapHelpers.twoLevelDeepExtend(defines, definitions);
            extend(definitions, defines);
        }
        Map.defaultGenerators = {};
        for (var prop in definitions) {
            var type = definitions[prop].type;
            if (typeof type === 'string') {
                if (typeof define.types[type] === 'object') {
                    delete definitions[prop].type;
                    extend(definitions[prop], define.types[type]);
                }
            }
            if ('value' in definitions[prop]) {
                if (typeof definitions[prop].value === 'function') {
                    Map.defaultGenerators[prop] = definitions[prop].value;
                } else {
                    Map.defaults[prop] = definitions[prop].value;
                }
            }
            if (typeof definitions[prop].Value === 'function') {
                (function (Constructor) {
                    Map.defaultGenerators[prop] = function () {
                        return new Constructor();
                    };
                }(definitions[prop].Value));
            }
        }
    };
    var oldSetupDefaults = CanMap.prototype._setupDefaults;
    CanMap.prototype._setupDefaults = function (obj) {
        var defaults = oldSetupDefaults.call(this), propsCommittedToAttr = {}, Map = this.constructor, originalGet = this._get;
        this._get = function (originalProp) {
            var prop = originalProp.indexOf('.') !== -1 ? originalProp.substr(0, originalProp.indexOf('.')) : originalProp;
            if (prop in defaults && !(prop in propsCommittedToAttr)) {
                this.attr(prop, defaults[prop]);
                propsCommittedToAttr[prop] = true;
            }
            return originalGet.apply(this, arguments);
        };
        for (var prop in Map.defaultGenerators) {
            if (!obj || !(prop in obj)) {
                defaults[prop] = Map.defaultGenerators[prop].call(this);
            }
        }
        delete this._get;
        return defaults;
    };
    var proto = CanMap.prototype, oldSet = proto.__set;
    proto.__set = function (prop, value, current, success, error) {
        var self = this;
        var errorCallback = function (errors) {
                var stub = error && error.call(self, errors);
                if (stub !== false) {
                    canEvent.trigger(self, 'error', [
                        prop,
                        errors
                    ], true);
                }
                return false;
            }, setter = getPropDefineBehavior('set', prop, this.define), getter = getPropDefineBehavior('get', prop, this.define);
        if (setter) {
            batch.start();
            var setterCalled = false, setValue = setter.call(this, value, function (value) {
                    if (getter) {
                        self[prop](value);
                    } else {
                        oldSet.call(self, prop, value, current, success, errorCallback);
                    }
                    setterCalled = true;
                }, errorCallback, getter ? this._computedAttrs[prop].compute.computeInstance.lastSetValue.get() : current);
            if (getter) {
                if (setValue !== undefined && !setterCalled && setter.length >= 1) {
                    this._computedAttrs[prop].compute(setValue);
                }
                batch.stop();
                return;
            } else if (setValue === undefined && !setterCalled && setter.length > 1) {
                batch.stop();
                return;
            } else {
                if (!setterCalled) {
                    oldSet.call(self, prop, setter.length === 0 && setValue === undefined ? value : setValue, current, success, errorCallback);
                }
                batch.stop();
                return this;
            }
        } else {
            oldSet.call(self, prop, value, current, success, errorCallback);
        }
        return this;
    };
    define.types = {
        'date': function (str) {
            var type = typeof str;
            if (type === 'string') {
                str = Date.parse(str);
                return isNaN(str) ? null : new Date(str);
            } else if (type === 'number') {
                return new Date(str);
            } else {
                return str;
            }
        },
        'number': function (val) {
            if (val == null) {
                return val;
            }
            return +val;
        },
        'boolean': function (val) {
            if (val == null) {
                return val;
            }
            if (val === 'false' || val === '0' || !val) {
                return false;
            }
            return true;
        },
        'htmlbool': function (val) {
            return typeof val === 'string' || !!val;
        },
        '*': function (val) {
            return val;
        },
        'string': function (val) {
            if (val == null) {
                return val;
            }
            return '' + val;
        },
        'compute': {
            set: function (newValue, setVal, setErr, oldValue) {
                if (newValue && newValue.isComputed) {
                    return newValue;
                }
                if (oldValue && oldValue.isComputed) {
                    oldValue(newValue);
                    return oldValue;
                }
                return newValue;
            },
            get: function (value) {
                return value && value.isComputed ? value() : value;
            }
        }
    };
    var oldType = proto.__type;
    proto.__type = function (value, prop) {
        var type = getPropDefineBehavior('type', prop, this.define), Type = getPropDefineBehavior('Type', prop, this.define), newValue = value;
        if (typeof type === 'string') {
            type = define.types[type];
        }
        if (type || Type) {
            if (type) {
                newValue = type.call(this, newValue, prop);
            }
            if (Type && newValue != null && !(newValue instanceof Type)) {
                newValue = new Type(newValue);
            }
            return newValue;
        } else if (isPlainObject(newValue) && newValue.define) {
            newValue = CanMap.extend(newValue);
            newValue = new newValue();
        }
        return oldType.call(this, newValue, prop);
    };
    var oldRemove = proto.__remove;
    proto.__remove = function (prop, current) {
        var remove = getPropDefineBehavior('remove', prop, this.define), res;
        if (remove) {
            batch.start();
            res = remove.call(this, current);
            if (res === false) {
                batch.stop();
                return;
            } else {
                res = oldRemove.call(this, prop, current);
                batch.stop();
                return res;
            }
        }
        return oldRemove.call(this, prop, current);
    };
    var oldSetupComputes = proto._setupComputedProperties;
    proto._setupComputedProperties = function () {
        oldSetupComputes.apply(this, arguments);
        for (var attr in this.define) {
            var def = this.define[attr], get = def.get;
            if (get) {
                mapHelpers.addComputedAttr(this, attr, compute.async(undefined, get, this));
            }
        }
    };
    var oldSingleSerialize = proto.___serialize;
    var serializeProp = function (map, attr, val) {
        var serializer = attr === '*' ? false : getPropDefineBehavior('serialize', attr, map.define);
        if (serializer === undefined) {
            return oldSingleSerialize.call(map, attr, val);
        } else if (serializer !== false) {
            return typeof serializer === 'function' ? serializer.call(map, val, attr) : oldSingleSerialize.call(map, attr, val);
        }
    };
    proto.___serialize = function (name, val) {
        return serializeProp(this, name, val);
    };
    var oldSerialize = proto.serialize;
    proto.serialize = function (property) {
        var serialized = oldSerialize.apply(this, arguments);
        if (property) {
            return serialized;
        }
        var serializer, val;
        for (var attr in this.define) {
            if (!(attr in serialized)) {
                serializer = this.define && (this.define[attr] && this.define[attr].serialize || this.define['*'] && this.define['*'].serialize);
                if (serializer) {
                    val = serializeProp(this, attr, this.attr(attr));
                    if (val !== undefined) {
                        serialized[attr] = val;
                    }
                }
            }
        }
        return serialized;
    };
    module.exports = define;
});
/*can-list@3.0.3#can-list_test*/
define('can-list@3.0.3#can-list_test', function (require, exports, module) {
    var List = require('can-list');
    var QUnit = require('steal-qunit');
    var Observation = require('can-observation');
    var Map = require('can-map');
    require('can-map-define');
    QUnit.module('can-list');
    test('list attr changes length', function () {
        var l = new List([
            0,
            1,
            2
        ]);
        l.attr(3, 3);
        equal(l.length, 4);
    });
    test('removeAttr on list', function () {
        var l = new List([
            0,
            1,
            2
        ]);
        l.removeAttr(1);
        equal(l.attr('length'), 2);
        deepEqual(l.attr(), [
            0,
            2
        ]);
    });
    test('list splice', function () {
        var l = new List([
                0,
                1,
                2,
                3
            ]), first = true;
        l.bind('change', function (ev, attr, how, newVals, oldVals) {
            equal(attr, '1');
            if (first) {
                equal(how, 'remove', 'removing items');
                equal(newVals, undefined, 'no new Vals');
            } else {
                deepEqual(newVals, [
                    'a',
                    'b'
                ], 'got the right newVals');
                equal(how, 'add', 'adding items');
            }
            first = false;
        });
        l.splice(1, 2, 'a', 'b');
        deepEqual(l.serialize(), [
            0,
            'a',
            'b',
            3
        ], 'serialized');
    });
    test('list pop', function () {
        var l = new List([
            0,
            1,
            2,
            3
        ]);
        l.bind('change', function (ev, attr, how, newVals, oldVals) {
            equal(attr, '3');
            equal(how, 'remove');
            equal(newVals, undefined);
            deepEqual(oldVals, [3]);
        });
        l.pop();
        deepEqual(l.serialize(), [
            0,
            1,
            2
        ]);
    });
    test('remove nested property in item of array map', function () {
        var state = new List([{ nested: true }]);
        state.bind('change', function (ev, attr, how, newVal, old) {
            equal(attr, '0.nested');
            equal(how, 'remove');
            deepEqual(old, true);
        });
        state.removeAttr('0.nested');
        equal(undefined, state.attr('0.nested'));
    });
    test('pop unbinds', function () {
        var l = new List([{ foo: 'bar' }]);
        var o = l.attr(0), count = 0;
        l.bind('change', function (ev, attr, how, newVal, oldVal) {
            count++;
            if (count === 1) {
                equal(attr, '0.foo', 'count is set');
            } else if (count === 2) {
                equal(how, 'remove');
                equal(attr, '0');
            } else {
                ok(false, 'called too many times');
            }
        });
        equal(o.attr('foo'), 'bar');
        o.attr('foo', 'car');
        l.pop();
        o.attr('foo', 'bad');
    });
    test('splice unbinds', function () {
        var l = new List([{ foo: 'bar' }]);
        var o = l.attr(0), count = 0;
        l.bind('change', function (ev, attr, how, newVal, oldVal) {
            count++;
            if (count === 1) {
                equal(attr, '0.foo', 'count is set');
            } else if (count === 2) {
                equal(how, 'remove');
                equal(attr, '0');
            } else {
                ok(false, 'called too many times');
            }
        });
        equal(o.attr('foo'), 'bar');
        o.attr('foo', 'car');
        l.splice(0, 1);
        o.attr('foo', 'bad');
    });
    test('always gets right attr even after moving array items', function () {
        var l = new List([{ foo: 'bar' }]);
        var o = l.attr(0);
        l.unshift('A new Value');
        l.bind('change', function (ev, attr, how) {
            equal(attr, '1.foo');
        });
        o.attr('foo', 'led you');
    });
    test('Array accessor methods', 11, function () {
        var l = new List([
                'a',
                'b',
                'c'
            ]), sliced = l.slice(2), joined = l.join(' | '), concatenated = l.concat([
                2,
                1
            ], new List([0]));
        ok(sliced instanceof List, 'Slice is an Observable list');
        equal(sliced.length, 1, 'Sliced off two elements');
        equal(sliced[0], 'c', 'Single element as expected');
        equal(joined, 'a | b | c', 'Joined list properly');
        ok(concatenated instanceof List, 'Concatenated is an Observable list');
        deepEqual(concatenated.serialize(), [
            'a',
            'b',
            'c',
            2,
            1,
            0
        ], 'List concatenated properly');
        l.forEach(function (letter, index) {
            ok(true, 'Iteration');
            if (index === 0) {
                equal(letter, 'a', 'First letter right');
            }
            if (index === 2) {
                equal(letter, 'c', 'Last letter right');
            }
        });
    });
    test('Concatenated list items Equal original', function () {
        var l = new List([
                { firstProp: 'Some data' },
                { secondProp: 'Next data' }
            ]), concatenated = l.concat([
                { hello: 'World' },
                { foo: 'Bar' }
            ]);
        ok(l[0] === concatenated[0], 'They are Equal');
        ok(l[1] === concatenated[1], 'They are Equal');
    });
    test('Lists with maps concatenate properly', function () {
        var Person = Map.extend();
        var People = List.extend({ Map: Person }, {});
        var Genius = Person.extend();
        var Animal = Map.extend();
        var me = new Person({ name: 'John' });
        var animal = new Animal({ name: 'Tak' });
        var genius = new Genius({ name: 'Einstein' });
        var hero = { name: 'Ghandi' };
        var people = new People([]);
        var specialPeople = new People([
            genius,
            hero
        ]);
        people = people.concat([
            me,
            animal,
            specialPeople
        ], specialPeople, [
            1,
            2
        ], 3);
        ok(people.attr('length') === 8, 'List length is right');
        ok(people[0] === me, 'Map in list === vars created before concat');
        ok(people[1] instanceof Person, 'Animal got serialized to Person');
    });
    test('splice removes items in IE (#562)', function () {
        var l = new List(['a']);
        l.splice(0, 1);
        ok(!l.attr(0), 'all props are removed');
    });
    test('reverse triggers add/remove events (#851)', function () {
        expect(6);
        var l = new List([
            1,
            2,
            3
        ]);
        l.bind('change', function () {
            ok(true, 'change should be called');
        });
        l.bind('set', function () {
            ok(false, 'set should not be called');
        });
        l.bind('add', function () {
            ok(true, 'add called');
        });
        l.bind('remove', function () {
            ok(true, 'remove called');
        });
        l.bind('length', function () {
            ok(true, 'length should be called');
        });
        l.reverse();
    });
    test('filter', function () {
        var l = new List([
            {
                id: 1,
                name: 'John'
            },
            {
                id: 2,
                name: 'Mary'
            }
        ]);
        var filtered = l.filter(function (item) {
            return item.name === 'Mary';
        });
        notEqual(filtered._cid, l._cid, 'not same object');
        equal(filtered.length, 1, 'one item');
        equal(filtered[0].name, 'Mary', 'filter works');
    });
    test('removing expandos on lists', function () {
        var list = new List([
            'a',
            'b'
        ]);
        list.removeAttr('foo');
        equal(list.length, 2);
    });
    test('No Add Events if List Splice adds the same items that it is removing. (#1277, #1399)', function () {
        var list = new List([
            'a',
            'b'
        ]);
        list.bind('add', function () {
            ok(false, 'Add callback should not be called.');
        });
        list.bind('remove', function () {
            ok(false, 'Remove callback should not be called.');
        });
        var result = list.splice(0, 2, 'a', 'b');
        deepEqual(result, [
            'a',
            'b'
        ]);
    });
    test('add event always returns an array as the value (#998)', function () {
        var list = new List([]), msg;
        list.bind('add', function (ev, newElements, index) {
            deepEqual(newElements, [4], msg);
        });
        msg = 'works on push';
        list.push(4);
        list.pop();
        msg = 'works on attr()';
        list.attr(0, 4);
        list.pop();
        msg = 'works on replace()';
        list.replace([4]);
    });
    test('Setting with .attr() out of bounds of length triggers add event with leading undefineds', function () {
        var list = new List([1]);
        list.bind('add', function (ev, newElements, index) {
            deepEqual(newElements, [
                undefined,
                undefined,
                4
            ], 'Leading undefineds are included');
            equal(index, 1, 'Index takes into account the leading undefineds from a .attr()');
        });
        list.attr(3, 4);
    });
    test('No events should fire if removals happened on empty arrays', function () {
        var list = new List([]), msg;
        list.bind('remove', function (ev, removed, index) {
            ok(false, msg);
        });
        msg = 'works on pop';
        list.pop();
        msg = 'works on shift';
        list.shift();
        ok(true, 'No events were fired.');
    });
    test('setting an index out of bounds does not create an array', function () {
        expect(1);
        var l = new List();
        l.attr('1', 'foo');
        equal(l.attr('1'), 'foo');
    });
    test('splice with similar but less items works (#1606)', function () {
        var list = new List([
            'aa',
            'bb',
            'cc'
        ]);
        list.splice(0, list.length, 'aa', 'cc', 'dd');
        deepEqual(list.attr(), [
            'aa',
            'cc',
            'dd'
        ]);
        list.splice(0, list.length, 'aa', 'cc');
        deepEqual(list.attr(), [
            'aa',
            'cc'
        ]);
    });
    test('filter returns same list type (#1744)', function () {
        var ParentList = List.extend();
        var ChildList = ParentList.extend();
        var children = new ChildList([
            1,
            2,
            3
        ]);
        ok(children.filter(function () {
        }) instanceof ChildList);
    });
    test('reverse returns the same list instance (#1744)', function () {
        var ParentList = List.extend();
        var ChildList = ParentList.extend();
        var children = new ChildList([
            1,
            2,
            3
        ]);
        ok(children.reverse() === children);
    });
    test('slice and join are observable by a compute (#1884)', function () {
        expect(2);
        var list = new List([
            1,
            2,
            3
        ]);
        var sliced = new Observation(function () {
            return list.slice(0, 1);
        }, null, {
            updater: function (newVal) {
                deepEqual(newVal.attr(), [2], 'got a new List');
            }
        });
        sliced.start();
        var joined = new Observation(function () {
            return list.join(',');
        }, null, {
            updater: function (newVal) {
                equal(newVal, '2,3', 'joined is observable');
            }
        });
        joined.start();
        list.shift();
    });
    test('list is always updated with the last promise passed to replace (#2136)', function () {
        var list = new List();
        stop();
        list.replace(new Promise(function (resolve) {
            setTimeout(function () {
                resolve(['A']);
                setTimeout(function () {
                    equal(list.attr(0), 'B', 'list set to last promise\'s value');
                    start();
                }, 10);
            }, 20);
        }));
        list.replace(new Promise(function (resolve) {
            setTimeout(function () {
                resolve(['B']);
            }, 10);
        }));
    });
    test('works with can-map-define', function () {
        var MyList = List.extend({}, {
            define: {
                foo: {
                    get: function () {
                        return 'bar';
                    }
                }
            }
        });
        var list = new MyList();
        equal(list.attr('foo'), 'bar');
    });
    test('forEach callback', function () {
        var list = new List([]), counter = 0;
        list.attr(9, 'foo');
        list.forEach(function (element, index, list) {
            counter++;
        });
        equal(counter, 1, 'Should not be invoked for uninitialized attr keys');
    });
    test('each callback', function () {
        var list = new List([]), counter = 0;
        list.attr(9, 'foo');
        list.each(function (item, index) {
            counter++;
        });
        equal(counter, 1, 'Should not be invoked for uninitialized attr keys');
    });
});
/*can@3.4.1#list/list_test*/
define('can@3.4.1#list/list_test', function (require, exports, module) {
    require('can-list/can-list_test');
});
/*can-map@3.0.6#can-map_test*/
define('can-map@3.0.6#can-map_test', function (require, exports, module) {
    var Map = require('can-map');
    var QUnit = require('steal-qunit');
    var Observation = require('can-observation');
    var Construct = require('can-construct');
    var observeReader = require('can-observation/reader/reader');
    QUnit.module('can-map');
    test('Basic Map', 4, function () {
        var state = new Map({
            category: 5,
            productType: 4
        });
        state.bind('change', function (ev, attr, how, val, old) {
            equal(attr, 'category', 'correct change name');
            equal(how, 'set');
            equal(val, 6, 'correct');
            equal(old, 5, 'correct');
        });
        state.attr('category', 6);
        state.unbind('change');
    });
    test('Nested Map', 5, function () {
        var me = new Map({
            name: {
                first: 'Justin',
                last: 'Meyer'
            }
        });
        ok(me.attr('name') instanceof Map);
        me.bind('change', function (ev, attr, how, val, old) {
            equal(attr, 'name.first', 'correct change name');
            equal(how, 'set');
            equal(val, 'Brian', 'correct');
            equal(old, 'Justin', 'correct');
        });
        me.attr('name.first', 'Brian');
        me.unbind('change');
    });
    test('remove attr', function () {
        var state = new Map({
            category: 5,
            productType: 4
        });
        state.removeAttr('category');
        deepEqual(Map.keys(state), ['productType'], 'one property');
    });
    test('remove attr on key with dot', function () {
        var state = new Map({
            'key.with.dots': 12,
            productType: 4
        });
        var state2 = new Map({
            'key.with.dots': 4,
            key: { 'with': { someValue: 20 } }
        });
        state.removeAttr('key.with.dots');
        state2.removeAttr('key.with.someValue');
        deepEqual(Map.keys(state), ['productType'], 'one property');
        deepEqual(Map.keys(state2), [
            'key.with.dots',
            'key'
        ], 'two properties');
        deepEqual(Map.keys(state2.key['with']), [], 'zero properties');
    });
    test('nested event handlers are not run by changing the parent property (#280)', function () {
        var person = new Map({ name: { first: 'Justin' } });
        person.bind('name.first', function (ev, newName) {
            ok(false, 'name.first should never be called');
        });
        person.bind('name', function () {
            ok(true, 'name event triggered');
        });
        person.attr('name', { first: 'Hank' });
    });
    test('cyclical objects (#521)', function () {
        var foo = {};
        foo.foo = foo;
        var fooed = new Map(foo);
        ok(true, 'did not cause infinate recursion');
        ok(fooed.attr('foo') === fooed, 'map points to itself');
        var me = { name: 'Justin' };
        var references = {
            husband: me,
            friend: me
        };
        var ref = new Map(references);
        ok(ref.attr('husband') === ref.attr('friend'), 'multiple properties point to the same thing');
    });
    test('_cid add to original object', function () {
        var map = new Map(), obj = { 'name': 'thecountofzero' };
        map.attr('myObj', obj);
        ok(!obj._cid, '_cid not added to original object');
    });
    test('Map serialize triggers reading (#626)', function () {
        var old = Observation.add;
        var attributesRead = [];
        var readingTriggeredForKeys = false;
        Observation.add = function (object, attribute) {
            if (attribute === '__keys') {
                readingTriggeredForKeys = true;
            } else {
                attributesRead.push(attribute);
            }
        };
        var testMap = new Map({
            cats: 'meow',
            dogs: 'bark'
        });
        testMap.serialize();
        ok(attributesRead.indexOf('cats') !== -1 && attributesRead.indexOf('dogs') !== -1, 'map serialization triggered __reading on all attributes');
        ok(readingTriggeredForKeys, 'map serialization triggered __reading for __keys');
        Observation.add = old;
    });
    test('Test top level attributes', 7, function () {
        var test = new Map({
            'my.enable': false,
            'my.item': true,
            'my.count': 0,
            'my.newCount': 1,
            'my': {
                'value': true,
                'nested': { 'value': 100 }
            }
        });
        equal(test.attr('my.value'), true, 'correct');
        equal(test.attr('my.nested.value'), 100, 'correct');
        ok(test.attr('my.nested') instanceof Map);
        equal(test.attr('my.enable'), false, 'falsey (false) value accessed correctly');
        equal(test.attr('my.item'), true, 'truthey (true) value accessed correctly');
        equal(test.attr('my.count'), 0, 'falsey (0) value accessed correctly');
        equal(test.attr('my.newCount'), 1, 'falsey (1) value accessed correctly');
    });
    test('serializing cycles', function () {
        var map1 = new Map({ name: 'map1' });
        var map2 = new Map({ name: 'map2' });
        map1.attr('map2', map2);
        map2.attr('map1', map1);
        var res = map1.serialize();
        equal(res.name, 'map1');
        equal(res.map2.name, 'map2');
    });
    test('Unbinding from a map with no bindings doesn\'t throw an error (#1015)', function () {
        expect(0);
        var test = new Map({});
        try {
            test.unbind('change');
        } catch (e) {
            ok(false, 'No error should be thrown');
        }
    });
    test('Fast dispatch event still has target and type (#1082)', 4, function () {
        var data = new Map({ name: 'CanJS' });
        data.bind('change', function (ev) {
            equal(ev.type, 'change');
            equal(ev.target, data);
        });
        data.bind('name', function (ev) {
            equal(ev.type, 'name');
            equal(ev.target, data);
        });
        data.attr('name', 'David');
    });
    test('map passed to Map constructor (#1166)', function () {
        var map = new Map({ x: 1 });
        var res = new Map(map);
        deepEqual(res.attr(), { x: 1 }, 'has the same properties');
    });
    test('constructor passed to scope is threated as a property (#1261)', function () {
        var Constructor = Construct.extend({});
        var MyMap = Map.extend({ Todo: Constructor });
        var m = new MyMap();
        equal(m.attr('Todo'), Constructor);
    });
    test('_bindings count maintained after calling .off() on undefined property (#1490) ', function () {
        var map = new Map({ test: 1 });
        map.on('test', function () {
        });
        equal(map._bindings, 1, 'The number of bindings is correct');
        map.off('undefined_property');
        equal(map._bindings, 1, 'The number of bindings is still correct');
    });
    test('Should be able to get and set attribute named \'watch\' on Map in Firefox', function () {
        var map = new Map({});
        map.attr('watch');
        ok(true, 'can have attribute named \'watch\' on a Map instance');
    });
    test('Should be able to get and set attribute named \'unwatch\' on Map in Firefox', function () {
        var map = new Map({});
        map.attr('unwatch');
        ok(true, 'can have attribute named \'unwatch\' on a Map instance');
    });
    test('should get an empty string property value correctly', function () {
        var map = new Map({
            foo: 'foo',
            '': 'empty string'
        });
        equal(map.attr(''), 'empty string');
    });
    test('ObserveReader - can.Construct derived classes should be considered objects, not functions (#450)', function () {
        var foostructor = Map.extend({ text: 'bar' }, {}), obj = {
                next_level: {
                    thing: foostructor,
                    text: 'In the inner context'
                }
            }, read;
        foostructor.self = foostructor;
        read = observeReader.read(obj, observeReader.reads('next_level.thing.self.text'));
        equal(read.value, 'bar', 'static properties on a can.Construct-based function');
        read = observeReader.read(obj, observeReader.reads('next_level.thing.self'), { isArgument: true });
        ok(read.value === foostructor, 'arguments shouldn\'t be executed');
        foostructor.self = function () {
            return foostructor;
        };
        read = observeReader.read(obj, observeReader.reads('next_level.thing.self.text'), {});
        equal(read.value, 'bar', 'anonymous functions in the middle of a read should be executed if requested');
    });
    test('Basic Map.prototype.compute', function () {
        var state = new Map({
            category: 5,
            productType: 4
        });
        var catCompute = state.compute('category');
        var prodCompute = state.compute('productType');
        catCompute.bind('change', function (ev, val, old) {
            equal(val, 6, 'correct');
            equal(old, 5, 'correct');
        });
        state.bind('productType', function (ev, val, old) {
            equal(val, 5, 'correct');
            equal(old, 4, 'correct');
        });
        state.attr('category', 6);
        prodCompute(5);
        catCompute.unbind('change');
        state.unbind('productType');
    });
    test('Deep Map.prototype.compute', function () {
        var state = new Map({
            product: {
                category: 5,
                productType: 4
            }
        });
        var catCompute = state.compute('product.category');
        var prodCompute = state.compute('product.productType');
        catCompute.bind('change', function (ev, val, old) {
            equal(val, 6, 'correct');
            equal(old, 5, 'correct');
        });
        state.attr('product').bind('productType', function (ev, val, old) {
            equal(val, 5, 'correct');
            equal(old, 4, 'correct');
        });
        state.attr('product.category', 6);
        prodCompute(5);
        catCompute.unbind('change');
        state.unbind('productType');
    });
});
/*can@3.4.1#map/map_test*/
define('can@3.4.1#map/map_test', function (require, exports, module) {
    require('can-map/can-map_test');
});
/*can-map-define@3.0.5#can-map-define_test*/
define('can-map-define@3.0.5#can-map-define_test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var isArray = require('can-util/js/is-array/is-array');
    var string = require('can-util/js/string/string');
    var CanMap = require('can-map');
    var List = require('can-list');
    var compute = require('can-compute');
    require('./can-map-define');
    QUnit.module('can/map/define');
    test('basics set', function () {
        var Defined = CanMap.extend({
            define: {
                prop: {
                    set: function (newVal) {
                        return 'foo' + newVal;
                    }
                }
            }
        });
        var def = new Defined();
        def.attr('prop', 'bar');
        equal(def.attr('prop'), 'foobar', 'setter works');
        Defined = CanMap.extend({
            define: {
                prop: {
                    set: function (newVal, setter) {
                        setter('foo' + newVal);
                    }
                }
            }
        });
        def = new Defined();
        def.attr('prop', 'bar');
        equal(def.attr('prop'), 'foobar', 'setter callback works');
    });
    test('basics remove', function () {
        var ViewModel = CanMap.extend({
            define: {
                makeId: {
                    remove: function () {
                        this.removeAttr('models');
                    }
                },
                models: {
                    remove: function () {
                        this.removeAttr('modelId');
                    }
                },
                modelId: {
                    remove: function () {
                        this.removeAttr('years');
                    }
                },
                years: {
                    remove: function () {
                        this.removeAttr('year');
                    }
                }
            }
        });
        var mmy = new ViewModel({
            makes: [{ id: 1 }],
            makeId: 1,
            models: [{ id: 2 }],
            modelId: 2,
            years: [2010],
            year: 2010
        });
        var events = [
                'year',
                'years',
                'modelId',
                'models',
                'makeId'
            ], eventCount = 0, batchNum;
        mmy.bind('change', function (ev, attr) {
            if (batchNum === undefined) {
                batchNum = ev.batchNum;
            }
            equal(attr, events[eventCount++], 'got correct attribute');
            ok(ev.batchNum && ev.batchNum === batchNum, 'batched');
        });
        mmy.removeAttr('makeId');
    });
    test('basics get', function () {
        var Person = CanMap.extend({
            define: {
                fullName: {
                    get: function () {
                        return this.attr('first') + ' ' + this.attr('last');
                    }
                }
            }
        });
        var p = new Person({
            first: 'Justin',
            last: 'Meyer'
        });
        equal(p.attr('fullName'), 'Justin Meyer', 'sync getter works');
        var Adder = CanMap.extend({
            define: {
                more: {
                    get: function (curVal, setVal) {
                        var num = this.attr('num');
                        setTimeout(function () {
                            setVal(num + 1);
                        }, 10);
                    }
                }
            }
        });
        var a = new Adder({ num: 1 }), callbackVals = [
                [
                    2,
                    undefined,
                    function () {
                        a.attr('num', 2);
                    }
                ],
                [
                    3,
                    2,
                    function () {
                        start();
                    }
                ]
            ], callbackCount = 0;
        a.bind('more', function (ev, newVal, oldVal) {
            var vals = callbackVals[callbackCount++];
            equal(newVal, vals[0], 'newVal is correct');
            equal(a.attr('more'), vals[0], 'attr value is correct');
            equal(oldVal, vals[1], 'oldVal is correct');
            setTimeout(vals[2], 10);
        });
        stop();
    });
    test('basic type', function () {
        expect(6);
        var Typer = CanMap.extend({
            define: {
                arrayWithAddedItem: {
                    type: function (value) {
                        if (value && value.push) {
                            value.push('item');
                        }
                        return value;
                    }
                },
                listWithAddedItem: {
                    type: function (value) {
                        if (value && value.push) {
                            value.push('item');
                        }
                        return value;
                    },
                    Type: List
                }
            }
        });
        var t = new Typer();
        deepEqual(CanMap.keys(t), [], 'no keys');
        var array = [];
        t.attr('arrayWithAddedItem', array);
        deepEqual(array, ['item'], 'updated array');
        equal(t.attr('arrayWithAddedItem'), array, 'leave value as array');
        t.attr('listWithAddedItem', []);
        ok(t.attr('listWithAddedItem') instanceof List, 'convert to List');
        equal(t.attr('listWithAddedItem').attr(0), 'item', 'has item in it');
        t.bind('change', function (ev, attr) {
            equal(attr, 'listWithAddedItem.1', 'got a bubbling event');
        });
        t.attr('listWithAddedItem').push('another item');
    });
    test('basic Type', function () {
        var Foo = function (name) {
            this.name = name;
        };
        Foo.prototype.getName = function () {
            return this.name;
        };
        var Typer = CanMap.extend({ define: { foo: { Type: Foo } } });
        var t = new Typer({ foo: 'Justin' });
        equal(t.attr('foo').getName(), 'Justin', 'correctly created an instance');
        var brian = new Foo('brian');
        t.attr('foo', brian);
        equal(t.attr('foo'), brian, 'same instances');
    });
    test('type converters', function () {
        var Typer = CanMap.extend({
            define: {
                date: { type: 'date' },
                string: { type: 'string' },
                number: { type: 'number' },
                'boolean': { type: 'boolean' },
                htmlbool: { type: 'htmlbool' },
                leaveAlone: { type: '*' }
            }
        });
        var obj = {};
        var t = new Typer({
            date: 1395896701516,
            string: 5,
            number: '5',
            'boolean': 'false',
            htmlbool: '',
            leaveAlone: obj
        });
        ok(t.attr('date') instanceof Date, 'converted to date');
        equal(t.attr('string'), '5', 'converted to string');
        equal(t.attr('number'), 5, 'converted to number');
        equal(t.attr('boolean'), false, 'converted to boolean');
        equal(t.attr('htmlbool'), true, 'converted to htmlbool');
        equal(t.attr('leaveAlone'), obj, 'left as object');
        t.attr({ 'number': '15' });
        ok(t.attr('number') === 15, 'converted to number');
    });
    test('basics value', function () {
        var Typer = CanMap.extend({ define: { prop: { value: 'foo' } } });
        equal(new Typer().attr('prop'), 'foo', 'value is used as default value');
        var Typer2 = CanMap.extend({
            define: {
                prop: {
                    value: function () {
                        return [];
                    },
                    type: '*'
                }
            }
        });
        var t1 = new Typer2(), t2 = new Typer2();
        ok(t1.attr('prop') !== t2.attr('prop'), 'different array instances');
        ok(isArray(t1.attr('prop')), 'its an array');
    });
    test('basics Value', function () {
        var Typer = CanMap.extend({
            define: {
                prop: {
                    Value: Array,
                    type: '*'
                }
            }
        });
        var t1 = new Typer(), t2 = new Typer();
        ok(t1.attr('prop') !== t2.attr('prop'), 'different array instances');
        ok(isArray(t1.attr('prop')), 'its an array');
    });
    test('setter with no arguments and returns undefined does the default behavior, the setter is for side effects only', function () {
        var Typer = CanMap.extend({
            define: {
                prop: {
                    set: function () {
                        this.attr('foo', 'bar');
                    }
                }
            }
        });
        var t = new Typer();
        t.attr('prop', false);
        deepEqual(t.attr(), {
            foo: 'bar',
            prop: false
        });
    });
    test('type happens before the set', function () {
        var MyMap = CanMap.extend({
            define: {
                prop: {
                    type: 'number',
                    set: function (newValue) {
                        equal(typeof newValue, 'number', 'got a number');
                        return newValue + 1;
                    }
                }
            }
        });
        var map = new MyMap();
        map.attr('prop', '5');
        equal(map.attr('prop'), 6, 'number');
    });
    test('getter and setter work', function () {
        expect(5);
        var Paginate = CanMap.extend({
            define: {
                page: {
                    set: function (newVal) {
                        this.attr('offset', (parseInt(newVal) - 1) * this.attr('limit'));
                    },
                    get: function () {
                        return Math.floor(this.attr('offset') / this.attr('limit')) + 1;
                    }
                }
            }
        });
        var p = new Paginate({
            limit: 10,
            offset: 20
        });
        equal(p.attr('page'), 3, 'page get right');
        p.bind('page', function (ev, newValue, oldValue) {
            equal(newValue, 2, 'got new value event');
            equal(oldValue, 3, 'got old value event');
        });
        p.attr('page', 2);
        equal(p.attr('page'), 2, 'page set right');
        equal(p.attr('offset'), 10, 'page offset set');
    });
    test('getter with initial value', function () {
        var comp = compute(1);
        var Grabber = CanMap.extend({
            define: {
                vals: {
                    type: '*',
                    Value: Array,
                    get: function (current, setVal) {
                        if (setVal) {
                            current.push(comp());
                        }
                        return current;
                    }
                }
            }
        });
        var g = new Grabber();
        equal(g.attr('vals').length, 0, 'zero items in array');
    });
    test('serialize basics', function () {
        var MyMap = CanMap.extend({
            define: {
                name: {
                    serialize: function () {
                        return;
                    }
                },
                locations: { serialize: false },
                locationIds: {
                    get: function () {
                        var ids = [];
                        this.attr('locations').each(function (location) {
                            ids.push(location.id);
                        });
                        return ids;
                    },
                    serialize: function (locationIds) {
                        return locationIds.join(',');
                    }
                },
                bared: {
                    get: function () {
                        return this.attr('name') + '+bar';
                    },
                    serialize: true
                },
                ignored: {
                    get: function () {
                        return this.attr('name') + '+ignored';
                    }
                }
            }
        });
        var map = new MyMap({ name: 'foo' });
        map.attr('locations', [
            {
                id: 1,
                name: 'Chicago'
            },
            {
                id: 2,
                name: 'LA'
            }
        ]);
        equal(map.attr('locationIds').length, 2, 'get locationIds');
        equal(map.attr('locationIds')[0], 1, 'get locationIds index 0');
        equal(map.attr('locations')[0].id, 1, 'get locations index 0');
        var serialized = map.serialize();
        equal(serialized.locations, undefined, 'locations doesn\'t serialize');
        equal(serialized.locationIds, '1,2', 'locationIds serializes');
        equal(serialized.name, undefined, 'name doesn\'t serialize');
        equal(serialized.bared, 'foo+bar', 'true adds computed props');
        equal(serialized.ignored, undefined, 'computed props are not serialized by default');
    });
    test('serialize context', function () {
        var context, serializeContext;
        var MyMap = CanMap.extend({
            define: {
                name: {
                    serialize: function (obj) {
                        context = this;
                        return obj;
                    }
                }
            },
            serialize: function () {
                serializeContext = this;
                CanMap.prototype.serialize.apply(this, arguments);
            }
        });
        var map = new MyMap();
        map.serialize();
        equal(context, map);
        equal(serializeContext, map);
    });
    test('methods contexts', function () {
        var contexts = {};
        var MyMap = CanMap.extend({
            define: {
                name: {
                    value: 'John Galt',
                    get: function (obj) {
                        contexts.get = this;
                        return obj;
                    },
                    remove: function (obj) {
                        contexts.remove = this;
                        return obj;
                    },
                    set: function (obj) {
                        contexts.set = this;
                        return obj;
                    },
                    serialize: function (obj) {
                        contexts.serialize = this;
                        return obj;
                    },
                    type: function (val) {
                        contexts.type = this;
                        return val;
                    }
                }
            }
        });
        var map = new MyMap();
        map.serialize();
        map.removeAttr('name');
        equal(contexts.get, map);
        equal(contexts.remove, map);
        equal(contexts.set, map);
        equal(contexts.serialize, map);
        equal(contexts.type, map);
    });
    test('value generator is not called if default passed', function () {
        var TestMap = CanMap.extend({
            define: {
                foo: {
                    value: function () {
                        throw '"foo"\'s value method should not be called.';
                    }
                }
            }
        });
        var tm = new TestMap({ foo: 'baz' });
        equal(tm.attr('foo'), 'baz');
    });
    test('Value generator can read other properties', function () {
        var Map = CanMap.extend({
            letters: 'ABC',
            numbers: [
                1,
                2,
                3
            ],
            define: {
                definedLetters: { value: 'DEF' },
                definedNumbers: {
                    value: [
                        4,
                        5,
                        6
                    ]
                },
                generatedLetters: {
                    value: function () {
                        return 'GHI';
                    }
                },
                generatedNumbers: {
                    value: function () {
                        return new List([
                            7,
                            8,
                            9
                        ]);
                    }
                },
                firstLetter: {
                    value: function () {
                        return this.attr('letters').substr(0, 1);
                    }
                },
                firstNumber: {
                    value: function () {
                        return this.attr('numbers.0');
                    }
                },
                middleLetter: {
                    value: function () {
                        return this.attr('definedLetters').substr(1, 1);
                    }
                },
                middleNumber: {
                    value: function () {
                        return this.attr('definedNumbers.1');
                    }
                },
                lastLetter: {
                    value: function () {
                        return this.attr('generatedLetters').substr(2, 1);
                    }
                },
                lastNumber: {
                    value: function () {
                        return this.attr('generatedNumbers.2');
                    }
                }
            }
        });
        var map = new Map();
        var prefix = 'Was able to read dependent value from ';
        equal(map.attr('firstLetter'), 'A', prefix + 'traditional CanMap style property definition');
        equal(map.attr('firstNumber'), 1, prefix + 'traditional CanMap style property definition');
        equal(map.attr('middleLetter'), 'E', prefix + 'define plugin style default property definition');
        equal(map.attr('middleNumber'), 5, prefix + 'define plugin style default property definition');
        equal(map.attr('lastLetter'), 'I', prefix + 'define plugin style generated default property definition');
        equal(map.attr('lastNumber'), 9, prefix + 'define plugin style generated default property definition');
    });
    test('default behaviors with "*" work for attributes', function () {
        expect(9);
        var DefaultMap = CanMap.extend({
            define: {
                someNumber: { value: '5' },
                '*': {
                    type: 'number',
                    serialize: function (value) {
                        return '' + value;
                    },
                    set: function (newVal) {
                        ok(true, 'set called');
                        return newVal;
                    },
                    remove: function (currentVal) {
                        ok(true, 'remove called');
                        return false;
                    }
                }
            }
        });
        var map = new DefaultMap(), serializedMap;
        equal(map.attr('someNumber'), 5, 'value of someNumber should be converted to a number');
        map.attr('number', '10');
        equal(map.attr('number'), 10, 'value of number should be converted to a number');
        map.removeAttr('number');
        equal(map.attr('number'), 10, 'number should not be removed');
        serializedMap = map.serialize();
        equal(serializedMap.number, '10', 'number serialized as string');
        equal(serializedMap.someNumber, '5', 'someNumber serialized as string');
        equal(serializedMap['*'], undefined, '"*" is not a value in serialized object');
    });
    test('models properly serialize with default behaviors', function () {
        var DefaultMap = CanMap.extend({
            define: {
                name: { value: 'Alex' },
                shirt: {
                    value: 'blue',
                    serialize: true
                },
                '*': { serialize: false }
            }
        });
        var map = new DefaultMap({
                age: 10,
                name: 'John'
            }), serializedMap = map.serialize();
        equal(serializedMap.age, undefined, 'age doesn\'t exist');
        equal(serializedMap.name, undefined, 'name doesn\'t exist');
        equal(serializedMap.shirt, 'blue', 'shirt exists');
    });
    test('nested define', function () {
        var nailedIt = 'Nailed it';
        var Example = CanMap.extend({}, { define: { name: { value: nailedIt } } });
        var NestedMap = CanMap.extend({}, {
            define: {
                isEnabled: { value: true },
                test: { Value: Example },
                examples: {
                    value: {
                        define: {
                            one: { Value: Example },
                            two: { value: { define: { deep: { Value: Example } } } }
                        }
                    }
                }
            }
        });
        var nested = new NestedMap();
        equal(nested.attr('test.name'), nailedIt);
        equal(nested.attr('examples.one.name'), nailedIt);
        equal(nested.attr('examples.two.deep.name'), nailedIt);
        ok(nested.attr('test') instanceof Example);
        ok(nested.attr('examples.one') instanceof Example);
        ok(nested.attr('examples.two.deep') instanceof Example);
    });
    test('Can make an attr alias a compute (#1470)', 9, function () {
        var computeValue = compute(1);
        var GetMap = CanMap.extend({
            define: {
                value: {
                    set: function (newValue, setVal, setErr, oldValue) {
                        if (newValue.isComputed) {
                            return newValue;
                        }
                        if (oldValue && oldValue.isComputed) {
                            oldValue(newValue);
                            return oldValue;
                        }
                        return newValue;
                    },
                    get: function (value) {
                        return value && value.isComputed ? value() : value;
                    }
                }
            }
        });
        var getMap = new GetMap();
        getMap.attr('value', computeValue);
        equal(getMap.attr('value'), 1);
        var bindCallbacks = 0;
        getMap.bind('value', function (ev, newVal, oldVal) {
            switch (bindCallbacks) {
            case 0:
                equal(newVal, 2, '0 - bind called with new val');
                equal(oldVal, 1, '0 - bind called with old val');
                break;
            case 1:
                equal(newVal, 3, '1 - bind called with new val');
                equal(oldVal, 2, '1 - bind called with old val');
                break;
            case 2:
                equal(newVal, 4, '2 - bind called with new val');
                equal(oldVal, 3, '2 - bind called with old val');
                break;
            }
            bindCallbacks++;
        });
        computeValue(2);
        getMap.attr('value', 3);
        equal(getMap.attr('value'), 3, 'read value is 3');
        equal(computeValue(), 3, 'the compute value is 3');
        var newComputeValue = compute(4);
        getMap.attr('value', newComputeValue);
    });
    test('setting a value of a property with type "compute" triggers change events', function () {
        var handler;
        var message = 'The change event passed the correct {prop} when set with {method}';
        var createChangeHandler = function (expectedOldVal, expectedNewVal, method) {
            return function (ev, newVal, oldVal) {
                var subs = {
                    prop: 'newVal',
                    method: method
                };
                equal(newVal, expectedNewVal, string.sub(message, subs));
                subs.prop = 'oldVal';
                equal(oldVal, expectedOldVal, string.sub(message, subs));
            };
        };
        var ComputableMap = CanMap.extend({ define: { computed: { type: 'compute' } } });
        var computed = compute(0);
        var m1 = new ComputableMap({ computed: computed });
        equal(m1.attr('computed'), 0, 'm1 is 1');
        handler = createChangeHandler(0, 1, '.attr(\'computed\', newVal)');
        handler = createChangeHandler(0, 1, '.attr(\'computed\', newVal)');
        m1.bind('computed', handler);
        m1.attr('computed', 1);
        m1.unbind('computed', handler);
        handler = createChangeHandler(1, 2, 'computed()');
        m1.bind('computed', handler);
        computed(2);
        m1.unbind('computed', handler);
    });
    test('replacing the compute on a property with type "compute"', function () {
        var compute1 = compute(0);
        var compute2 = compute(1);
        var ComputableMap = CanMap.extend({ define: { computable: { type: 'compute' } } });
        var m = new ComputableMap();
        m.attr('computable', compute1);
        equal(m.attr('computable'), 0, 'compute1 readable via .attr()');
        m.attr('computable', compute2);
        equal(m.attr('computable'), 1, 'compute2 readable via .attr()');
    });
    test('value and get (#1521)', function () {
        var MyMap = CanMap.extend({
            define: {
                data: {
                    value: function () {
                        return new List(['test']);
                    }
                },
                size: {
                    value: 1,
                    get: function (val) {
                        var list = this.attr('data');
                        var length = list.attr('length');
                        return val + length;
                    }
                }
            }
        });
        var map = new MyMap({});
        equal(map.attr('size'), 2);
    });
    test('One event on getters (#1585)', function () {
        var AppState = CanMap.extend({
            define: {
                person: {
                    get: function (lastSetValue, setAttrValue) {
                        if (lastSetValue) {
                            return lastSetValue;
                        } else if (this.attr('personId')) {
                            setAttrValue(new CanMap({
                                name: 'Jose',
                                id: 5
                            }));
                        } else {
                            return null;
                        }
                    }
                }
            }
        });
        var appState = new AppState();
        var personEvents = 0;
        appState.bind('person', function (ev, person) {
            personEvents++;
        });
        appState.attr('personId', 5);
        appState.attr('person', new CanMap({ name: 'Julia' }));
        equal(personEvents, 2);
    });
    test('Can read a defined property with a set/get method (#1648)', function () {
        var Map = CanMap.extend({
            define: {
                foo: {
                    value: '',
                    set: function (setVal) {
                        return setVal;
                    },
                    get: function (lastSetVal) {
                        return lastSetVal;
                    }
                }
            }
        });
        var map = new Map();
        equal(map.attr('foo'), '', 'Calling .attr(\'foo\') returned the correct value');
        map.attr('foo', 'baz');
        equal(map.attr('foo'), 'baz', 'Calling .attr(\'foo\') returned the correct value');
    });
    test('Can bind to a defined property with a set/get method (#1648)', 3, function () {
        var Map = CanMap.extend({
            define: {
                foo: {
                    value: '',
                    set: function (setVal) {
                        return setVal;
                    },
                    get: function (lastSetVal) {
                        return lastSetVal;
                    }
                }
            }
        });
        var map = new Map();
        map.bind('foo', function () {
            ok(true, 'Bound function is called');
        });
        equal(map.attr('foo'), '', 'Calling .attr(\'foo\') returned the correct value');
        map.attr('foo', 'baz');
        equal(map.attr('foo'), 'baz', 'Calling .attr(\'foo\') returned the correct value');
    });
    test('type converters handle null and undefined in expected ways (1693)', function () {
        var Typer = CanMap.extend({
            define: {
                date: { type: 'date' },
                string: { type: 'string' },
                number: { type: 'number' },
                'boolean': { type: 'boolean' },
                htmlbool: { type: 'htmlbool' },
                leaveAlone: { type: '*' }
            }
        });
        var t = new Typer().attr({
            date: undefined,
            string: undefined,
            number: undefined,
            'boolean': undefined,
            htmlbool: undefined,
            leaveAlone: undefined
        });
        equal(t.attr('date'), undefined, 'converted to date');
        equal(t.attr('string'), undefined, 'converted to string');
        equal(t.attr('number'), undefined, 'converted to number');
        equal(t.attr('boolean'), undefined, 'converted to boolean');
        equal(t.attr('htmlbool'), false, 'converted to htmlbool');
        equal(t.attr('leaveAlone'), undefined, 'left as object');
        t = new Typer().attr({
            date: null,
            string: null,
            number: null,
            'boolean': null,
            htmlbool: null,
            leaveAlone: null
        });
        equal(t.attr('date'), null, 'converted to date');
        equal(t.attr('string'), null, 'converted to string');
        equal(t.attr('number'), null, 'converted to number');
        equal(t.attr('boolean'), null, 'converted to boolean');
        equal(t.attr('htmlbool'), false, 'converted to htmlbool');
        equal(t.attr('leaveAlone'), null, 'left as object');
    });
    test('Initial value does not call getter', function () {
        expect(0);
        var Map = CanMap.extend({
            define: {
                count: {
                    get: function (lastVal) {
                        ok(false, 'Should not be called');
                        return lastVal;
                    }
                }
            }
        });
        new Map({ count: 100 });
    });
    test('getters produce change events', function () {
        var Map = CanMap.extend({
            define: {
                count: {
                    get: function (lastVal) {
                        return lastVal;
                    }
                }
            }
        });
        var map = new Map();
        map.bind('change', function () {
            ok(true, 'change called');
        });
        map.attr('count', 22);
    });
    test('Asynchronous virtual properties cause extra recomputes (#1915)', function () {
        stop();
        var ran = false;
        var VM = CanMap.extend({
            define: {
                foo: {
                    get: function (lastVal, setVal) {
                        setTimeout(function () {
                            if (setVal) {
                                setVal(5);
                            }
                        }, 10);
                    }
                },
                bar: {
                    get: function () {
                        var foo = this.attr('foo');
                        if (foo) {
                            if (ran) {
                                ok(false, 'Getter ran twice');
                            }
                            ran = true;
                            return foo * 2;
                        }
                    }
                }
            }
        });
        var vm = new VM();
        vm.bind('bar', function () {
        });
        setTimeout(function () {
            equal(vm.attr('bar'), 10);
            start();
        }, 200);
    });
    test('double get in a compute (#2230)', function () {
        var VM = CanMap.extend({
            define: {
                names: {
                    get: function (val, setVal) {
                        ok(setVal, 'setVal passed');
                        return 'Hi!';
                    }
                }
            }
        });
        var vm = new VM();
        var c = compute(function () {
            return vm.attr('names');
        });
        c.bind('change', function () {
        });
    });
    test('nullish values are not converted for Type', function (assert) {
        var VM = CanMap.extend({
            define: {
                map: { Type: CanMap },
                notype: {}
            }
        });
        var vm = new VM({
            num: 1,
            bool: true,
            htmlbool: 'foo',
            str: 'foo',
            date: Date.now(),
            map: {},
            notype: {}
        });
        assert.ok(vm.attr('map') instanceof CanMap, 'map is a Map');
        assert.ok(vm.attr('notype') instanceof CanMap, 'notype is a Map');
        vm.attr({
            map: null,
            notype: null
        });
        assert.equal(vm.attr('map'), null, 'map is null');
        assert.equal(vm.attr('map'), null, 'notype is null');
    });
    test('Wildcard serialize doesn\'t apply to getter properties (#4)', function () {
        var VM = CanMap.extend({
            define: {
                explicitlySerialized: {
                    get: function () {
                        return true;
                    },
                    serialize: true
                },
                implicitlySerialized: {
                    get: function () {
                        return true;
                    }
                },
                '*': { serialize: true }
            }
        });
        var vm = new VM();
        vm.bind('change', function () {
        });
        deepEqual(vm.serialize(), {
            explicitlySerialized: true,
            implicitlySerialized: true
        });
    });
    test('compute props can be set to null or undefined (#2372)', function (assert) {
        var VM = CanMap.extend({ define: { foo: { type: 'compute' } } });
        var vmNull = new VM({ foo: null });
        assert.equal(vmNull.foo, null, 'foo is null, no error thrown');
        var vmUndef = new VM({ foo: undefined });
        assert.equal(vmUndef.foo, undefined, 'foo is null, no error thrown');
    });
    test('can inherit computes from another map (#2)', 4, function () {
        var string1 = 'a string';
        var string2 = 'another string';
        var MapA = CanMap.extend({
            define: {
                propA: {
                    get: function () {
                        return string1;
                    }
                },
                propB: {
                    get: function () {
                        return string1;
                    },
                    set: function (newVal) {
                        equal(newVal, string1, 'set was called');
                    }
                }
            }
        });
        var MapB = MapA.extend({
            define: {
                propC: {
                    get: function () {
                        return string2;
                    }
                },
                propB: {
                    get: function () {
                        return string2;
                    }
                }
            }
        });
        var map = new MapB();
        equal(map.attr('propC'), string2, 'props only in the child have the correct values');
        equal(map.attr('propB'), string2, 'props in both have the child values');
        equal(map.attr('propA'), string1, 'props only in the parent have the correct values');
        map.attr('propB', string1);
    });
    test('can inherit primitive values from another map (#2)', function () {
        var string1 = 'a';
        var string2 = 'b';
        var MapA = CanMap.extend({
            define: {
                propA: { value: string1 },
                propB: { value: string1 }
            }
        });
        var MapB = MapA.extend({
            define: {
                propC: { value: string2 },
                propB: { value: string2 }
            }
        });
        var map = new MapB();
        equal(map.propC, string2, 'props only in the child have the correct values');
        equal(map.propB, string2, 'props in both have the child values');
        equal(map.propA, string1, 'props only in the parent have the correct values');
    });
    test('can inherit object values from another map (#2)', function () {
        var object1 = { a: 'a' };
        var object2 = { b: 'b' };
        var MapA = CanMap.extend({
            define: {
                propA: {
                    get: function () {
                        return object1;
                    }
                },
                propB: {
                    get: function () {
                        return object1;
                    }
                }
            }
        });
        var MapB = MapA.extend({
            define: {
                propB: {
                    get: function () {
                        return object2;
                    }
                },
                propC: {
                    get: function () {
                        return object2;
                    }
                }
            }
        });
        var map = new MapB();
        equal(map.attr('propC'), object2, 'props only in the child have the correct values');
        equal(map.attr('propB'), object2, 'props in both have the child values');
        equal(map.attr('propA'), object1, 'props only in the parent have the correct values');
    });
    test('can set properties to undefined', function () {
        var MyMap = CanMap.extend({
            define: {
                foo: {
                    set: function (newVal) {
                        return newVal;
                    }
                }
            }
        });
        var map = new MyMap();
        map.attr('foo', 'bar');
        equal(map.attr('foo'), 'bar', 'foo should be bar');
        map.attr('foo', undefined);
        equal(typeof map.attr('foo'), 'undefined', 'foo should be undefined');
    });
    test('subclass defines do not affect superclass ones', function (assert) {
        var VM = CanMap.extend({
            define: {
                foo: {
                    type: 'string',
                    value: 'bar'
                }
            }
        });
        var VM2 = VM.extend({ define: { foo: { value: 'baz' } } });
        var VM2a = VM.extend({});
        var VM2b = VM.extend({
            define: {
                foo: {
                    get: function () {
                        return 'quux';
                    }
                }
            }
        });
        var VM2c = VM.extend({
            define: {
                foo: {
                    type: function (oldVal) {
                        return oldVal + 'thud';
                    }
                }
            }
        });
        assert.equal(new VM().attr('foo'), 'bar', 'correct define on parent class object');
        assert.equal(new VM2().attr('foo'), 'baz', 'correct define on redefined child class object');
        assert.equal(new VM2a().attr('foo'), 'bar', 'correct define on non-redefined child class object');
        assert.equal(new VM2b().attr('foo'), 'quux', 'correct define on child class object with different define');
        assert.equal(new VM2c().attr('foo'), 'barthud', 'correct define on child class object with extending define');
    });
});
/*can-view-href@3.0.4#can-view-href*/
define('can-view-href@3.0.4#can-view-href', function (require, exports, module) {
    var expression = require('can-stache/src/expression');
    var viewCallbacks = require('can-view-callbacks');
    var compute = require('can-compute');
    var route = require('can-route');
    require('can-util/dom/events/removed/removed');
    var domEvents = require('can-util/dom/events/events');
    var removeCurly = function (value) {
        if (value[0] === '{' && value[value.length - 1] === '}') {
            return value.substr(1, value.length - 2);
        }
        return value;
    };
    viewCallbacks.attr('can-href', function (el, attrData) {
        var attrInfo = expression.parse('tmp(' + removeCurly(el.getAttribute('can-href')) + ')', { baseMethodType: 'Call' });
        var getHash = attrInfo.argExprs[0].value(attrData.scope, null);
        var routeHref = compute(function () {
            return route.url(getHash());
        });
        el.setAttribute('href', routeHref());
        var handler = function (ev, newVal) {
            el.setAttribute('href', newVal);
        };
        routeHref.on('change', handler);
        domEvents.addEventListener.call(el, 'removed', function () {
            routeHref.off('change', handler);
        });
    });
});
/*can-view-href@3.0.4#test/test*/
define('can-view-href@3.0.4#test/test', function (require, exports, module) {
    (function (__dirname) {
        require('can-route');
        require('steal-qunit');
        require('../can-view-href');
        var makeIframe = function (src) {
            var iframe = document.createElement('iframe');
            window.removeMyself = function () {
                delete window.removeMyself;
                delete window.isReady;
                delete window.hasError;
                document.body.removeChild(iframe);
                start();
            };
            window.hasError = function (error) {
                ok(false, error.message);
                window.removeMyself();
            };
            window.isReady = function (el, viewModel, setPrettyUrl) {
                equal(el.getAttribute('href'), '#!&page=recipe&id=5', 'should set unpretty href attribute');
                viewModel.recipe.attr('id', 7);
                equal(el.getAttribute('href'), '#!&page=recipe&id=7', 'should update href');
                setPrettyUrl();
                viewModel.recipe.attr('id', 8);
                equal(el.getAttribute('href'), '#!recipe/8', 'should set pretty href');
                viewModel.recipe.attr('id', 9);
                equal(el.getAttribute('href'), '#!recipe/9', 'should update pretty href');
                window.removeMyself();
            };
            document.body.appendChild(iframe);
            iframe.src = src;
        };
        QUnit.module('can-view-href');
        if (window.steal && __dirname !== '/') {
            asyncTest('the basics are able to work for steal', function () {
                makeIframe(__dirname + '/basics.html?' + Math.random());
            });
        }
    }('/'));
});
/*can-map-backup@3.0.3#can-map-backup*/
define('can-map-backup@3.0.3#can-map-backup', function (require, exports, module) {
    var compute = require('can-compute');
    var CanMap = require('can-map');
    var compare = require('can-set/src/compare');
    var assign = require('can-util/js/assign/assign');
    var flatProps = function (a, cur) {
        var obj = {};
        for (var prop in a) {
            if (typeof a[prop] !== 'object' || a[prop] === null || a[prop] instanceof Date) {
                obj[prop] = a[prop];
            } else {
                obj[prop] = cur.attr(prop);
            }
        }
        return obj;
    };
    var oldSetup = CanMap.prototype.setup;
    assign(CanMap.prototype, {
        setup: function () {
            this._backupStore = compute();
            return oldSetup.apply(this, arguments);
        },
        backup: function () {
            this._backupStore(this.attr());
            return this;
        },
        isDirty: function (checkAssociations) {
            var backupStore = this._backupStore();
            if (!backupStore) {
                return false;
            }
            var currentValue = this.attr();
            var aParent, bParent, parentProp;
            var compares = {};
            var options = { deep: !!checkAssociations };
            return !compare.equal(currentValue, backupStore, aParent, bParent, parentProp, compares, options);
        },
        restore: function (restoreAssociations) {
            var props = restoreAssociations ? this._backupStore() : flatProps(this._backupStore(), this);
            if (this.isDirty(restoreAssociations)) {
                this.attr(props, true);
            }
            return this;
        }
    });
    module.exports = exports = CanMap;
});
/*can-map-backup@3.0.3#can-map-backup_test*/
define('can-map-backup@3.0.3#can-map-backup_test', function (require, exports, module) {
    var compute = require('can-compute');
    var CanMap = require('can-map');
    require('can-map-backup');
    require('can-map-define');
    require('steal-qunit');
    var Recipe;
    QUnit.module('can/map/backup', {
        setup: function () {
            Recipe = CanMap.extend('Recipe');
        }
    });
    test('backing up', function () {
        var recipe = new Recipe({ name: 'cheese' });
        ok(!recipe.isDirty(), 'not backedup, but clean');
        recipe.backup();
        ok(!recipe.isDirty(), 'backedup, but clean');
        recipe.attr('name', 'blah');
        ok(recipe.isDirty(), 'dirty');
        recipe.restore();
        ok(!recipe.isDirty(), 'restored, clean');
        equal(recipe.name, 'cheese', 'name back');
    });
    test('backup / restore with associations', function () {
        var Instruction = CanMap.extend('Instruction');
        var Cookbook = CanMap.extend('Cookbook');
        var Recipe = CanMap.extend('Recipe', {
            define: {
                instructions: { Type: Instruction.List },
                cookbook: { Type: Cookbook }
            }
        }, {});
        var recipe = new Recipe({
            name: 'cheese burger',
            instructions: [
                { description: 'heat meat' },
                { description: 'add cheese' }
            ],
            cookbook: { title: 'Justin\'s Grillin Times' }
        });
        ok(!recipe.isDirty(), 'not backedup, but clean');
        recipe.backup();
        ok(!recipe.isDirty(), 'backedup, but clean');
        recipe.attr('name', 'blah');
        ok(recipe.isDirty(), 'dirty');
        recipe.restore();
        ok(!recipe.isDirty(), 'restored, clean');
        equal(recipe.name, 'cheese burger', 'name back');
        ok(!recipe.cookbook.isDirty(), 'cookbook not backedup, but clean');
        recipe.cookbook.backup();
        recipe.cookbook.attr('title', 'Brian\'s Burgers');
        ok(!recipe.isDirty(), 'recipe itself is clean');
        ok(recipe.isDirty(true), 'recipe is dirty if checking associations');
        recipe.cookbook.restore();
        ok(!recipe.isDirty(true), 'recipe is now clean with checking associations');
        equal(recipe.cookbook.title, 'Justin\'s Grillin Times', 'cookbook title back');
        recipe.cookbook.attr('title', 'Brian\'s Burgers');
        recipe.restore();
        ok(recipe.isDirty(true), 'recipe is dirty if checking associations, after a restore');
        recipe.restore(true);
        ok(!recipe.isDirty(true), 'cleaned all of recipe and its associations');
    });
    test('backup restore nested observables', function () {
        var observe = new CanMap({ nested: { test: 'property' } });
        equal(observe.attr('nested').attr('test'), 'property', 'Nested object got converted');
        observe.backup();
        observe.attr('nested').attr('test', 'changed property');
        equal(observe.attr('nested').attr('test'), 'changed property', 'Nested property changed');
        ok(observe.isDirty(true), 'Observe is dirty');
        observe.restore(true);
        equal(observe.attr('nested').attr('test'), 'property', 'Nested object got restored');
    });
    test('backup removes properties that were added (#607)', function () {
        var map = new CanMap({});
        map.backup();
        map.attr('foo', 'bar');
        ok(map.isDirty(), 'the map with an additional property is dirty');
        map.restore();
        ok(!map.attr('foo'), 'there is no foo property');
    });
    test('isDirty wrapped in a compute should trigger changes #1417', function () {
        expect(2);
        var recipe = new Recipe({ name: 'bread' });
        recipe.backup();
        var c = compute(function () {
            return recipe.isDirty();
        });
        ok(!c(), 'isDirty is false');
        c.bind('change', function () {
            ok(c(), 'isDirty is true and a change has occurred');
        });
        recipe.attr('name', 'cheese');
    });
});
/*can-util@3.3.2#namespace*/
define('can-util@3.3.2#namespace', function (require, exports, module) {
    module.exports = require('can-namespace');
});
/*can-validate-legacy@1.0.2#can-validate*/
define('can-validate-legacy@1.0.2#can-validate', function (require, exports, module) {
    var dev = require('can-util/js/dev/dev');
    var namespace = require('can-util/namespace');
    var Validate = {
        _validatorId: '',
        _validators: {},
        validator: function () {
            return this._validators[this._validatorId];
        },
        register: function (id, validator) {
            this._validatorId = id;
            this._validators[id] = validator;
        },
        isValid: function () {
            return this.validator().isValid.apply(this, arguments);
        },
        once: function () {
            return this.validator().once.apply(this, arguments);
        },
        validate: function () {
            var validateArgs = arguments;
            return this.validator().validate.apply(this, validateArgs);
        }
    };
    namespace.validate = Validate;
    module.exports = Validate;
});
/*can-validate-legacy@1.0.2#map/validate/validate*/
define('can-validate-legacy@1.0.2#map/validate/validate', function (require, exports, module) {
    var $ = require('jquery');
    var namespace = require('can-util/namespace');
    var Map = require('can-map');
    var each = require('can-util/js/each/each');
    var isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');
    var validate = require('can-validate-legacy');
    var compute = require('can-compute');
    var proto = Map.prototype;
    var oldSet = proto.__set;
    var ErrorsObj;
    var defaultValidationOpts;
    var config = {
        errorKeyName: 'errors',
        validateOptionCacheKey: 'validateOptions'
    };
    var resolveComputes = function (itemObj, opts) {
        var processedObj = {};
        each(opts, function (item, key) {
            var actualOpts = item;
            if (typeof item === 'function') {
                actualOpts = item(itemObj.value);
            }
            processedObj[key] = actualOpts;
        });
        return processedObj;
    };
    var getPropDefineBehavior = function (behavior, attr, define) {
        var prop;
        var defaultProp;
        if (define) {
            prop = define[attr];
            defaultProp = define['*'];
            if (prop && prop[behavior] !== undefined) {
                return prop[behavior];
            } else {
                if (defaultProp && defaultProp[behavior] !== undefined) {
                    return defaultProp[behavior];
                }
            }
        }
    };
    ErrorsObj = Map.extend({}, {
        hasErrors: function () {
            return !isEmptyObject(this.attr());
        }
    });
    defaultValidationOpts = {
        mustValidate: false,
        validateOnInit: false
    };
    var getValidateFromCache = function () {
        var validateCacheKey = '__' + config.validateOptionCacheKey;
        if (!this[validateCacheKey]) {
            this[validateCacheKey] = {};
        }
        return this[validateCacheKey];
    };
    var initProperty = function (key, value) {
        var validateOpts;
        var mapValidateCache;
        var propIniting;
        mapValidateCache = getValidateFromCache.call(this);
        if (mapValidateCache[key] && !isEmptyObject(mapValidateCache[key])) {
            validateOpts = mapValidateCache[key];
            propIniting = false;
        } else {
            validateOpts = $.extend({}, getPropDefineBehavior('validate', key, this.define));
            propIniting = true;
        }
        if (typeof validateOpts !== 'undefined') {
            if (propIniting) {
                validateOpts = $.extend({}, defaultValidationOpts, validateOpts, this._processValidateOpts({
                    key: key,
                    value: value
                }, validateOpts));
                mapValidateCache[key] = validateOpts;
            }
            return true;
        }
        return false;
    };
    var oldSetup = proto.setup;
    var oldInit = proto.init;
    proto.setup = function () {
        this._initValidate = true;
        oldSetup.apply(this, arguments);
    };
    proto.init = function () {
        this._initValidation();
        this._initValidate = false;
        if (oldInit) {
            oldInit.apply(this, arguments);
        }
    };
    $.extend(Map.prototype, {
        _initValidation: function () {
            var self = this;
            var validateCache = getValidateFromCache.call(this);
            each(this.define, function (props, key) {
                if (props.validate && !validateCache[key]) {
                    initProperty.call(self, key, self[key]);
                }
            });
        },
        validate: function () {
            return this._validate();
        },
        _validate: function () {
            var validateOpts = getValidateFromCache.call(this);
            var processedOpts = {};
            var self = this;
            each(this.define, function (value, key) {
                if (value.validate) {
                    processedOpts[key] = resolveComputes({
                        key: key,
                        value: self.attr(key)
                    }, validateOpts[key]);
                }
            });
            var errors = validate.validate(this.serialize(), processedOpts);
            this.attr('errors', new ErrorsObj(errors));
            return isEmptyObject(errors);
        },
        _validateOne: function (item, opts) {
            var errors;
            var allowSet = true;
            errors = validate.once(item.value, $.extend({}, opts), item.key);
            if (errors && errors.length > 0) {
                if (!this.attr('errors')) {
                    this.attr('errors', new ErrorsObj({}));
                }
                this.attr('errors').attr(item.key, errors);
                if (opts.mustValidate === true) {
                    allowSet = false;
                }
            } else {
                if (this.attr('errors') && this.attr('errors').attr(item.key)) {
                    this.attr('errors').removeAttr(item.key);
                }
            }
            return allowSet;
        },
        _processValidateOpts: function (itemObj, opts) {
            var processedObj = {};
            var computes = [];
            var self = this;
            each(opts, function (item, key) {
                processedObj[key] = item;
                if (typeof item === 'function') {
                    var newCompute = compute($.proxy(item, self));
                    computes.push({
                        key: key,
                        compute: newCompute
                    });
                    processedObj[key] = newCompute;
                }
            });
            each(computes, function (item) {
                item.compute.bind('change', function () {
                    itemObj.value = self.attr(itemObj.key);
                    self._validateOne(itemObj, processedObj);
                });
            });
            return processedObj;
        }
    });
    proto.__set = function (prop, value, current, success, error) {
        var allowSet = true;
        var checkValidate = initProperty.call(this, prop, value);
        var validateOpts = getValidateFromCache.call(this)[prop];
        var mapIniting = this._initValidate;
        if (checkValidate !== false) {
            validateOpts = resolveComputes({
                key: prop,
                value: value
            }, validateOpts);
            if (validateOpts && !mapIniting || validateOpts && mapIniting && validateOpts.validateOnInit) {
                allowSet = this._validateOne({
                    key: prop,
                    value: value
                }, validateOpts);
            }
        }
        if (allowSet) {
            oldSet.call(this, prop, value, current, success, error);
        }
    };
});
/*validate.js@0.11.1#validate*/
(function (exports, module, define) {
    'use strict';
    var validate = function (attributes, constraints, options) {
        options = v.extend({}, v.options, options);
        var results = v.runValidations(attributes, constraints, options), attr, validator;
        for (attr in results) {
            for (validator in results[attr]) {
                if (v.isPromise(results[attr][validator])) {
                    throw new Error('Use validate.async if you want support for promises');
                }
            }
        }
        return validate.processValidationResults(results, options);
    };
    var v = validate;
    v.extend = function (obj) {
        [].slice.call(arguments, 1).forEach(function (source) {
            for (var attr in source) {
                obj[attr] = source[attr];
            }
        });
        return obj;
    };
    v.extend(validate, {
        version: {
            major: 0,
            minor: 11,
            patch: 1,
            metadata: null,
            toString: function () {
                var version = v.format('%{major}.%{minor}.%{patch}', v.version);
                if (!v.isEmpty(v.version.metadata)) {
                    version += '+' + v.version.metadata;
                }
                return version;
            }
        },
        Promise: typeof Promise !== 'undefined' ? Promise : null,
        EMPTY_STRING_REGEXP: /^\s*$/,
        runValidations: function (attributes, constraints, options) {
            var results = [], attr, validatorName, value, validators, validator, validatorOptions, error;
            if (v.isDomElement(attributes) || v.isJqueryElement(attributes)) {
                attributes = v.collectFormValues(attributes);
            }
            for (attr in constraints) {
                value = v.getDeepObjectValue(attributes, attr);
                validators = v.result(constraints[attr], value, attributes, attr, options, constraints);
                for (validatorName in validators) {
                    validator = v.validators[validatorName];
                    if (!validator) {
                        error = v.format('Unknown validator %{name}', { name: validatorName });
                        throw new Error(error);
                    }
                    validatorOptions = validators[validatorName];
                    validatorOptions = v.result(validatorOptions, value, attributes, attr, options, constraints);
                    if (!validatorOptions) {
                        continue;
                    }
                    results.push({
                        attribute: attr,
                        value: value,
                        validator: validatorName,
                        globalOptions: options,
                        attributes: attributes,
                        options: validatorOptions,
                        error: validator.call(validator, value, validatorOptions, attr, attributes, options)
                    });
                }
            }
            return results;
        },
        processValidationResults: function (errors, options) {
            errors = v.pruneEmptyErrors(errors, options);
            errors = v.expandMultipleErrors(errors, options);
            errors = v.convertErrorMessages(errors, options);
            var format = options.format || 'grouped';
            if (typeof v.formatters[format] === 'function') {
                errors = v.formatters[format](errors);
            } else {
                throw new Error(v.format('Unknown format %{format}', options));
            }
            return v.isEmpty(errors) ? undefined : errors;
        },
        async: function (attributes, constraints, options) {
            options = v.extend({}, v.async.options, options);
            var WrapErrors = options.wrapErrors || function (errors) {
                return errors;
            };
            if (options.cleanAttributes !== false) {
                attributes = v.cleanAttributes(attributes, constraints);
            }
            var results = v.runValidations(attributes, constraints, options);
            return new v.Promise(function (resolve, reject) {
                v.waitForResults(results).then(function () {
                    var errors = v.processValidationResults(results, options);
                    if (errors) {
                        reject(new WrapErrors(errors, options, attributes, constraints));
                    } else {
                        resolve(attributes);
                    }
                }, function (err) {
                    reject(err);
                });
            });
        },
        single: function (value, constraints, options) {
            options = v.extend({}, v.single.options, options, {
                format: 'flat',
                fullMessages: false
            });
            return v({ single: value }, { single: constraints }, options);
        },
        waitForResults: function (results) {
            return results.reduce(function (memo, result) {
                if (!v.isPromise(result.error)) {
                    return memo;
                }
                return memo.then(function () {
                    return result.error.then(function (error) {
                        result.error = error || null;
                    });
                });
            }, new v.Promise(function (r) {
                r();
            }));
        },
        result: function (value) {
            var args = [].slice.call(arguments, 1);
            if (typeof value === 'function') {
                value = value.apply(null, args);
            }
            return value;
        },
        isNumber: function (value) {
            return typeof value === 'number' && !isNaN(value);
        },
        isFunction: function (value) {
            return typeof value === 'function';
        },
        isInteger: function (value) {
            return v.isNumber(value) && value % 1 === 0;
        },
        isBoolean: function (value) {
            return typeof value === 'boolean';
        },
        isObject: function (obj) {
            return obj === Object(obj);
        },
        isDate: function (obj) {
            return obj instanceof Date;
        },
        isDefined: function (obj) {
            return obj !== null && obj !== undefined;
        },
        isPromise: function (p) {
            return !!p && v.isFunction(p.then);
        },
        isJqueryElement: function (o) {
            return o && v.isString(o.jquery);
        },
        isDomElement: function (o) {
            if (!o) {
                return false;
            }
            if (!o.querySelectorAll || !o.querySelector) {
                return false;
            }
            if (v.isObject(document) && o === document) {
                return true;
            }
            if (typeof HTMLElement === 'object') {
                return o instanceof HTMLElement;
            } else {
                return o && typeof o === 'object' && o !== null && o.nodeType === 1 && typeof o.nodeName === 'string';
            }
        },
        isEmpty: function (value) {
            var attr;
            if (!v.isDefined(value)) {
                return true;
            }
            if (v.isFunction(value)) {
                return false;
            }
            if (v.isString(value)) {
                return v.EMPTY_STRING_REGEXP.test(value);
            }
            if (v.isArray(value)) {
                return value.length === 0;
            }
            if (v.isDate(value)) {
                return false;
            }
            if (v.isObject(value)) {
                for (attr in value) {
                    return false;
                }
                return true;
            }
            return false;
        },
        format: v.extend(function (str, vals) {
            if (!v.isString(str)) {
                return str;
            }
            return str.replace(v.format.FORMAT_REGEXP, function (m0, m1, m2) {
                if (m1 === '%') {
                    return '%{' + m2 + '}';
                } else {
                    return String(vals[m2]);
                }
            });
        }, { FORMAT_REGEXP: /(%?)%\{([^\}]+)\}/g }),
        prettify: function (str) {
            if (v.isNumber(str)) {
                if (str * 100 % 1 === 0) {
                    return '' + str;
                } else {
                    return parseFloat(Math.round(str * 100) / 100).toFixed(2);
                }
            }
            if (v.isArray(str)) {
                return str.map(function (s) {
                    return v.prettify(s);
                }).join(', ');
            }
            if (v.isObject(str)) {
                return str.toString();
            }
            str = '' + str;
            return str.replace(/([^\s])\.([^\s])/g, '$1 $2').replace(/\\+/g, '').replace(/[_-]/g, ' ').replace(/([a-z])([A-Z])/g, function (m0, m1, m2) {
                return '' + m1 + ' ' + m2.toLowerCase();
            }).toLowerCase();
        },
        stringifyValue: function (value) {
            return v.prettify(value);
        },
        isString: function (value) {
            return typeof value === 'string';
        },
        isArray: function (value) {
            return {}.toString.call(value) === '[object Array]';
        },
        isHash: function (value) {
            return v.isObject(value) && !v.isArray(value) && !v.isFunction(value);
        },
        contains: function (obj, value) {
            if (!v.isDefined(obj)) {
                return false;
            }
            if (v.isArray(obj)) {
                return obj.indexOf(value) !== -1;
            }
            return value in obj;
        },
        unique: function (array) {
            if (!v.isArray(array)) {
                return array;
            }
            return array.filter(function (el, index, array) {
                return array.indexOf(el) == index;
            });
        },
        forEachKeyInKeypath: function (object, keypath, callback) {
            if (!v.isString(keypath)) {
                return undefined;
            }
            var key = '', i, escape = false;
            for (i = 0; i < keypath.length; ++i) {
                switch (keypath[i]) {
                case '.':
                    if (escape) {
                        escape = false;
                        key += '.';
                    } else {
                        object = callback(object, key, false);
                        key = '';
                    }
                    break;
                case '\\':
                    if (escape) {
                        escape = false;
                        key += '\\';
                    } else {
                        escape = true;
                    }
                    break;
                default:
                    escape = false;
                    key += keypath[i];
                    break;
                }
            }
            return callback(object, key, true);
        },
        getDeepObjectValue: function (obj, keypath) {
            if (!v.isObject(obj)) {
                return undefined;
            }
            return v.forEachKeyInKeypath(obj, keypath, function (obj, key) {
                if (v.isObject(obj)) {
                    return obj[key];
                }
            });
        },
        collectFormValues: function (form, options) {
            var values = {}, i, j, input, inputs, option, value;
            if (v.isJqueryElement(form)) {
                form = form[0];
            }
            if (!form) {
                return values;
            }
            options = options || {};
            inputs = form.querySelectorAll('input[name], textarea[name]');
            for (i = 0; i < inputs.length; ++i) {
                input = inputs.item(i);
                if (v.isDefined(input.getAttribute('data-ignored'))) {
                    continue;
                }
                value = v.sanitizeFormValue(input.value, options);
                if (input.type === 'number') {
                    value = value ? +value : null;
                } else if (input.type === 'checkbox') {
                    if (input.attributes.value) {
                        if (!input.checked) {
                            value = values[input.name] || null;
                        }
                    } else {
                        value = input.checked;
                    }
                } else if (input.type === 'radio') {
                    if (!input.checked) {
                        value = values[input.name] || null;
                    }
                }
                values[input.name] = value;
            }
            inputs = form.querySelectorAll('select[name]');
            for (i = 0; i < inputs.length; ++i) {
                input = inputs.item(i);
                if (input.multiple) {
                    value = [];
                    for (j in input.options) {
                        option = input.options[j];
                        if (option.selected) {
                            value.push(v.sanitizeFormValue(option.value, options));
                        }
                    }
                } else {
                    value = v.sanitizeFormValue(input.options[input.selectedIndex].value, options);
                }
                values[input.name] = value;
            }
            return values;
        },
        sanitizeFormValue: function (value, options) {
            if (options.trim && v.isString(value)) {
                value = value.trim();
            }
            if (options.nullify !== false && value === '') {
                return null;
            }
            return value;
        },
        capitalize: function (str) {
            if (!v.isString(str)) {
                return str;
            }
            return str[0].toUpperCase() + str.slice(1);
        },
        pruneEmptyErrors: function (errors) {
            return errors.filter(function (error) {
                return !v.isEmpty(error.error);
            });
        },
        expandMultipleErrors: function (errors) {
            var ret = [];
            errors.forEach(function (error) {
                if (v.isArray(error.error)) {
                    error.error.forEach(function (msg) {
                        ret.push(v.extend({}, error, { error: msg }));
                    });
                } else {
                    ret.push(error);
                }
            });
            return ret;
        },
        convertErrorMessages: function (errors, options) {
            options = options || {};
            var ret = [];
            errors.forEach(function (errorInfo) {
                var error = v.result(errorInfo.error, errorInfo.value, errorInfo.attribute, errorInfo.options, errorInfo.attributes, errorInfo.globalOptions);
                if (!v.isString(error)) {
                    ret.push(errorInfo);
                    return;
                }
                if (error[0] === '^') {
                    error = error.slice(1);
                } else if (options.fullMessages !== false) {
                    error = v.capitalize(v.prettify(errorInfo.attribute)) + ' ' + error;
                }
                error = error.replace(/\\\^/g, '^');
                error = v.format(error, { value: v.stringifyValue(errorInfo.value) });
                ret.push(v.extend({}, errorInfo, { error: error }));
            });
            return ret;
        },
        groupErrorsByAttribute: function (errors) {
            var ret = {};
            errors.forEach(function (error) {
                var list = ret[error.attribute];
                if (list) {
                    list.push(error);
                } else {
                    ret[error.attribute] = [error];
                }
            });
            return ret;
        },
        flattenErrorsToArray: function (errors) {
            return errors.map(function (error) {
                return error.error;
            }).filter(function (value, index, self) {
                return self.indexOf(value) === index;
            });
        },
        cleanAttributes: function (attributes, whitelist) {
            function whitelistCreator(obj, key, last) {
                if (v.isObject(obj[key])) {
                    return obj[key];
                }
                return obj[key] = last ? true : {};
            }
            function buildObjectWhitelist(whitelist) {
                var ow = {}, lastObject, attr;
                for (attr in whitelist) {
                    if (!whitelist[attr]) {
                        continue;
                    }
                    v.forEachKeyInKeypath(ow, attr, whitelistCreator);
                }
                return ow;
            }
            function cleanRecursive(attributes, whitelist) {
                if (!v.isObject(attributes)) {
                    return attributes;
                }
                var ret = v.extend({}, attributes), w, attribute;
                for (attribute in attributes) {
                    w = whitelist[attribute];
                    if (v.isObject(w)) {
                        ret[attribute] = cleanRecursive(ret[attribute], w);
                    } else if (!w) {
                        delete ret[attribute];
                    }
                }
                return ret;
            }
            if (!v.isObject(whitelist) || !v.isObject(attributes)) {
                return {};
            }
            whitelist = buildObjectWhitelist(whitelist);
            return cleanRecursive(attributes, whitelist);
        },
        exposeModule: function (validate, root, exports, module, define) {
            if (exports) {
                if (module && module.exports) {
                    exports = module.exports = validate;
                }
                exports.validate = validate;
            } else {
                root.validate = validate;
                if (validate.isFunction(define) && define.amd) {
                    define('validate.js@0.11.1#validate', [], function () {
                        return validate;
                    });
                }
            }
        },
        warn: function (msg) {
            if (typeof console !== 'undefined' && console.warn) {
                console.warn('[validate.js] ' + msg);
            }
        },
        error: function (msg) {
            if (typeof console !== 'undefined' && console.error) {
                console.error('[validate.js] ' + msg);
            }
        }
    });
    validate.validators = {
        presence: function (value, options) {
            options = v.extend({}, this.options, options);
            if (options.allowEmpty ? !v.isDefined(value) : v.isEmpty(value)) {
                return options.message || this.message || 'can\'t be blank';
            }
        },
        length: function (value, options, attribute) {
            if (!v.isDefined(value)) {
                return;
            }
            options = v.extend({}, this.options, options);
            var is = options.is, maximum = options.maximum, minimum = options.minimum, tokenizer = options.tokenizer || function (val) {
                    return val;
                }, err, errors = [];
            value = tokenizer(value);
            var length = value.length;
            if (!v.isNumber(length)) {
                v.error(v.format('Attribute %{attr} has a non numeric value for `length`', { attr: attribute }));
                return options.message || this.notValid || 'has an incorrect length';
            }
            if (v.isNumber(is) && length !== is) {
                err = options.wrongLength || this.wrongLength || 'is the wrong length (should be %{count} characters)';
                errors.push(v.format(err, { count: is }));
            }
            if (v.isNumber(minimum) && length < minimum) {
                err = options.tooShort || this.tooShort || 'is too short (minimum is %{count} characters)';
                errors.push(v.format(err, { count: minimum }));
            }
            if (v.isNumber(maximum) && length > maximum) {
                err = options.tooLong || this.tooLong || 'is too long (maximum is %{count} characters)';
                errors.push(v.format(err, { count: maximum }));
            }
            if (errors.length > 0) {
                return options.message || errors;
            }
        },
        numericality: function (value, options) {
            if (!v.isDefined(value)) {
                return;
            }
            options = v.extend({}, this.options, options);
            var errors = [], name, count, checks = {
                    greaterThan: function (v, c) {
                        return v > c;
                    },
                    greaterThanOrEqualTo: function (v, c) {
                        return v >= c;
                    },
                    equalTo: function (v, c) {
                        return v === c;
                    },
                    lessThan: function (v, c) {
                        return v < c;
                    },
                    lessThanOrEqualTo: function (v, c) {
                        return v <= c;
                    },
                    divisibleBy: function (v, c) {
                        return v % c === 0;
                    }
                };
            if (v.isString(value) && options.strict) {
                var pattern = '^(0|[1-9]\\d*)';
                if (!options.onlyInteger) {
                    pattern += '(\\.\\d+)?';
                }
                pattern += '$';
                if (!new RegExp(pattern).test(value)) {
                    return options.message || options.notValid || this.notValid || this.message || 'must be a valid number';
                }
            }
            if (options.noStrings !== true && v.isString(value) && !v.isEmpty(value)) {
                value = +value;
            }
            if (!v.isNumber(value)) {
                return options.message || options.notValid || this.notValid || this.message || 'is not a number';
            }
            if (options.onlyInteger && !v.isInteger(value)) {
                return options.message || options.notInteger || this.notInteger || this.message || 'must be an integer';
            }
            for (name in checks) {
                count = options[name];
                if (v.isNumber(count) && !checks[name](value, count)) {
                    var key = 'not' + v.capitalize(name);
                    var msg = options[key] || this[key] || this.message || 'must be %{type} %{count}';
                    errors.push(v.format(msg, {
                        count: count,
                        type: v.prettify(name)
                    }));
                }
            }
            if (options.odd && value % 2 !== 1) {
                errors.push(options.notOdd || this.notOdd || this.message || 'must be odd');
            }
            if (options.even && value % 2 !== 0) {
                errors.push(options.notEven || this.notEven || this.message || 'must be even');
            }
            if (errors.length) {
                return options.message || errors;
            }
        },
        datetime: v.extend(function (value, options) {
            if (!v.isFunction(this.parse) || !v.isFunction(this.format)) {
                throw new Error('Both the parse and format functions needs to be set to use the datetime/date validator');
            }
            if (!v.isDefined(value)) {
                return;
            }
            options = v.extend({}, this.options, options);
            var err, errors = [], earliest = options.earliest ? this.parse(options.earliest, options) : NaN, latest = options.latest ? this.parse(options.latest, options) : NaN;
            value = this.parse(value, options);
            if (isNaN(value) || options.dateOnly && value % 86400000 !== 0) {
                err = options.notValid || options.message || this.notValid || 'must be a valid date';
                return v.format(err, { value: arguments[0] });
            }
            if (!isNaN(earliest) && value < earliest) {
                err = options.tooEarly || options.message || this.tooEarly || 'must be no earlier than %{date}';
                err = v.format(err, {
                    value: this.format(value, options),
                    date: this.format(earliest, options)
                });
                errors.push(err);
            }
            if (!isNaN(latest) && value > latest) {
                err = options.tooLate || options.message || this.tooLate || 'must be no later than %{date}';
                err = v.format(err, {
                    date: this.format(latest, options),
                    value: this.format(value, options)
                });
                errors.push(err);
            }
            if (errors.length) {
                return v.unique(errors);
            }
        }, {
            parse: null,
            format: null
        }),
        date: function (value, options) {
            options = v.extend({}, options, { dateOnly: true });
            return v.validators.datetime.call(v.validators.datetime, value, options);
        },
        format: function (value, options) {
            if (v.isString(options) || options instanceof RegExp) {
                options = { pattern: options };
            }
            options = v.extend({}, this.options, options);
            var message = options.message || this.message || 'is invalid', pattern = options.pattern, match;
            if (!v.isDefined(value)) {
                return;
            }
            if (!v.isString(value)) {
                return message;
            }
            if (v.isString(pattern)) {
                pattern = new RegExp(options.pattern, options.flags);
            }
            match = pattern.exec(value);
            if (!match || match[0].length != value.length) {
                return message;
            }
        },
        inclusion: function (value, options) {
            if (!v.isDefined(value)) {
                return;
            }
            if (v.isArray(options)) {
                options = { within: options };
            }
            options = v.extend({}, this.options, options);
            if (v.contains(options.within, value)) {
                return;
            }
            var message = options.message || this.message || '^%{value} is not included in the list';
            return v.format(message, { value: value });
        },
        exclusion: function (value, options) {
            if (!v.isDefined(value)) {
                return;
            }
            if (v.isArray(options)) {
                options = { within: options };
            }
            options = v.extend({}, this.options, options);
            if (!v.contains(options.within, value)) {
                return;
            }
            var message = options.message || this.message || '^%{value} is restricted';
            return v.format(message, { value: value });
        },
        email: v.extend(function (value, options) {
            options = v.extend({}, this.options, options);
            var message = options.message || this.message || 'is not a valid email';
            if (!v.isDefined(value)) {
                return;
            }
            if (!v.isString(value)) {
                return message;
            }
            if (!this.PATTERN.exec(value)) {
                return message;
            }
        }, { PATTERN: /^[a-z0-9\u007F-\uffff!#$%&'*+\/=?^_`{|}~-]+(?:\.[a-z0-9\u007F-\uffff!#$%&'*+\/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z]{2,}$/i }),
        equality: function (value, options, attribute, attributes) {
            if (!v.isDefined(value)) {
                return;
            }
            if (v.isString(options)) {
                options = { attribute: options };
            }
            options = v.extend({}, this.options, options);
            var message = options.message || this.message || 'is not equal to %{attribute}';
            if (v.isEmpty(options.attribute) || !v.isString(options.attribute)) {
                throw new Error('The attribute must be a non empty string');
            }
            var otherValue = v.getDeepObjectValue(attributes, options.attribute), comparator = options.comparator || function (v1, v2) {
                    return v1 === v2;
                };
            if (!comparator(value, otherValue, options, attribute, attributes)) {
                return v.format(message, { attribute: v.prettify(options.attribute) });
            }
        },
        url: function (value, options) {
            if (!v.isDefined(value)) {
                return;
            }
            options = v.extend({}, this.options, options);
            var message = options.message || this.message || 'is not a valid url', schemes = options.schemes || this.schemes || [
                    'http',
                    'https'
                ], allowLocal = options.allowLocal || this.allowLocal || false;
            if (!v.isString(value)) {
                return message;
            }
            var regex = '^' + '(?:(?:' + schemes.join('|') + ')://)' + '(?:\\S+(?::\\S*)?@)?' + '(?:';
            var tld = '(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))';
            if (allowLocal) {
                tld += '?';
            } else {
                regex += '(?!(?:10|127)(?:\\.\\d{1,3}){3})' + '(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})' + '(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})';
            }
            regex += '(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])' + '(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}' + '(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))' + '|' + '(?:(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)' + '(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*' + tld + ')' + '(?::\\d{2,5})?' + '(?:[/?#]\\S*)?' + '$';
            var PATTERN = new RegExp(regex, 'i');
            if (!PATTERN.exec(value)) {
                return message;
            }
        }
    };
    validate.formatters = {
        detailed: function (errors) {
            return errors;
        },
        flat: v.flattenErrorsToArray,
        grouped: function (errors) {
            var attr;
            errors = v.groupErrorsByAttribute(errors);
            for (attr in errors) {
                errors[attr] = v.flattenErrorsToArray(errors[attr]);
            }
            return errors;
        },
        constraint: function (errors) {
            var attr;
            errors = v.groupErrorsByAttribute(errors);
            for (attr in errors) {
                errors[attr] = errors[attr].map(function (result) {
                    return result.validator;
                }).sort();
            }
            return errors;
        }
    };
    validate.exposeModule(validate, this, exports, module, define);
}.call(this, typeof exports !== 'undefined' ? exports : null, typeof module !== 'undefined' ? module : null, typeof define !== 'undefined' ? define : null));
/*can-validate-legacy@1.0.2#shims/validatejs*/
define('can-validate-legacy@1.0.2#shims/validatejs', function (require, exports, module) {
    var validate = require('can-validate-legacy');
    var validatejs = require('validate.js');
    var processOptions = function (opts) {
        if (typeof opts.required !== 'undefined') {
            opts.presence = opts.required;
            delete opts.required;
        }
        if (opts.hasOwnProperty('mustValidate')) {
            delete opts.mustValidate;
        }
        if (opts.hasOwnProperty('validateOnInit')) {
            delete opts.validateOnInit;
        }
        return opts;
    };
    var shim = {
        once: function (value, options, name) {
            var errors = [];
            var opts = [];
            var validationOpts = [];
            if (name) {
                opts[name] = value;
                validationOpts[name] = processOptions(options);
                errors = validatejs(opts, validationOpts);
                if (errors) {
                    errors = errors[name];
                }
            } else {
                errors = validatejs.single(value, processOptions(options));
            }
            return errors;
        },
        isValid: function (value, options) {
            var errors = validatejs.single(value, processOptions(options)) || [];
            return errors.length === 0;
        },
        validate: function (values, options) {
            var valueKeys = Object.keys(values);
            var processedOpts = {};
            for (var i = 0; i < valueKeys.length; i++) {
                var prop = valueKeys[i];
                if (options[prop]) {
                    processedOpts[prop] = processOptions(options[prop]);
                }
            }
            return validatejs(values, processedOpts);
        }
    };
    validate.register('validatejs', shim);
});
/*can-validate-legacy@1.0.2#can-validate-test*/
define('can-validate-legacy@1.0.2#can-validate-test', function (require, exports, module) {
    var namespace = require('can-util/namespace');
    var Map = require('can-map');
    var isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');
    var QUnit = require('steal-qunit');
    require('can-map-define');
    require('can-validate-legacy');
    require('can-validate-legacy/map/validate/');
    require('can-validate-legacy/shims/validatejs');
    var validatedMap;
    var secondaryMap;
    var ValidatedMap = Map.extend({
        define: {
            myNumber: {
                value: 100,
                validate: { required: true }
            },
            computedProp: {
                validate: {
                    required: function () {
                        return this.attr('isRequired');
                    }
                },
                value: ''
            },
            isRequired: {
                value: false,
                type: 'boolean'
            }
        }
    });
    QUnit.module('Map Validate Plugin');
    QUnit.test('when validateOnInit is not set, it should not run validation', function () {
        validatedMap = new ValidatedMap();
        QUnit.ok(isEmptyObject(validatedMap.errors));
    });
    QUnit.test('validations run when value is set', function () {
        validatedMap = new ValidatedMap();
        validatedMap.attr('myNumber', '');
        QUnit.equal(validatedMap.errors.myNumber.length, 1);
    });
    QUnit.test('when validate method is called, resolves computes before calling Validate method', function () {
        validatedMap = new ValidatedMap({
            isRequired: true,
            myNumber: 0
        });
        var success = false;
        try {
            validatedMap.validate();
            success = true;
        } catch (err) {
            success = err;
        }
        QUnit.ok(success);
    });
    QUnit.test('when creating multiple instances of the same map, each instance is discrete', function () {
        validatedMap = new ValidatedMap();
        validatedMap.attr('isRequired', true);
        secondaryMap = new ValidatedMap();
        secondaryMap.attr('computedProp', '');
        QUnit.equal(isEmptyObject(secondaryMap.attr('errors')), true, 'control map validates successfully');
        validatedMap.attr('computedProp', '');
        QUnit.equal(validatedMap.attr('computedProp'), '');
        QUnit.ok(typeof validatedMap.attr('errors.computedProp') !== 'undefined', 'other map validates, sets error');
    });
    var ShimValidatedMap = Map.extend({
        define: {
            myNumber: {
                value: 'test',
                validate: {
                    required: true,
                    numericality: true,
                    validateOnInit: true
                }
            },
            myString: {
                value: '12345',
                validate: {
                    required: true,
                    length: 2
                }
            }
        }
    });
    QUnit.module('Validate.js Shim', {
        setup: function () {
            validatedMap = new ShimValidatedMap({});
        }
    });
    QUnit.test('validates on init by default', function () {
        QUnit.equal(validatedMap.attr('errors').myNumber.length, 1);
    });
    QUnit.test('validates on init by default', function () {
        QUnit.equal(validatedMap.errors.myNumber.length, 1);
    });
    QUnit.test('does not validate on init, when validate on init is false', function () {
        QUnit.equal(validatedMap.errors.myString, undefined);
    });
    QUnit.test('runs validation on value', function () {
        validatedMap.attr('myString', '');
        QUnit.equal(validatedMap.errors.myString.length, 1);
    });
});
/*can-legacy-view-helpers@0.5.0#src/view*/
define('can-legacy-view-helpers@0.5.0#src/view', function (require, exports, module) {
    var isFunction = require('can-util/js/is-function/is-function'), makeArray = require('can-util/js/make-array/make-array'), deepAssign = require('can-util/js/deep-assign/deep-assign'), canFrag = require('can-util/dom/frag/frag'), each = require('can-util/js/each/each'), hookupId = 1;
    var $view = function (view, data, helpers, callback) {
        if (isFunction(helpers)) {
            callback = helpers;
            helpers = undefined;
        }
        return $view.renderAs('fragment', view, data, helpers, callback);
    };
    deepAssign($view, {
        frag: function (result, parentNode) {
            return $view.hookup($view.fragment(result), parentNode);
        },
        fragment: function (result) {
            return canFrag(result, document);
        },
        toId: function (src) {
            return src.toString().split(/\/|\./g).map(function (part) {
                if (part) {
                    return part;
                }
            }).join('_');
        },
        toStr: function (txt) {
            return txt == null ? '' : '' + txt;
        },
        hookup: function (fragment, parentNode) {
            var hookupEls = [], id, func;
            each(fragment.childNodes ? makeArray(fragment.childNodes) : fragment, function (node) {
                if (node.nodeType === 1) {
                    hookupEls.push(node);
                    hookupEls.push.apply(hookupEls, makeArray(node.getElementsByTagName('*')));
                }
            });
            each(hookupEls, function (el) {
                if (el.getAttribute && (id = el.getAttribute('data-view-id')) && (func = $view.hookups[id])) {
                    func(el, parentNode, id);
                    delete $view.hookups[id];
                    el.removeAttribute('data-view-id');
                }
            });
            return fragment;
        },
        hookups: {},
        hook: function (cb) {
            $view.hookups[++hookupId] = cb;
            return ' data-view-id=\'' + hookupId + '\'';
        },
        cached: {},
        cachedRenderers: {},
        simpleHelper: function (fn) {
            return function () {
                var realArgs = [];
                var fnArgs = arguments;
                each(fnArgs, function (val, i) {
                    if (i <= fnArgs.length) {
                        while (val && val.isComputed) {
                            val = val();
                        }
                        realArgs.push(val);
                    }
                });
                return fn.apply(this, realArgs);
            };
        }
    });
    module.exports = $view;
});
/*can-legacy-view-helpers@0.5.0#src/node_list*/
define('can-legacy-view-helpers@0.5.0#src/node_list', function (require, exports, module) {
    var makeArray = require('can-util/js/make-array/make-array');
    var CID = require('can-util/js/cid/cid');
    var each = require('can-util/js/each/each');
    var domMutate = require('can-util/dom/mutate/mutate');
    var canExpando = true, readId, nodeLists;
    try {
        document.createTextNode('')._ = 0;
    } catch (ex) {
        canExpando = false;
    }
    var nodeMap = {}, textNodeMap = {}, expando = 'ejs_' + Math.random(), _id = 0, id = function (node, localMap) {
            var _textNodeMap = localMap || textNodeMap;
            var id = readId(node, _textNodeMap);
            if (id) {
                return id;
            } else {
                if (canExpando || node.nodeType !== 3) {
                    ++_id;
                    return node[expando] = (node.nodeName ? 'element_' : 'obj_') + _id;
                } else {
                    ++_id;
                    _textNodeMap['text_' + _id] = node;
                    return 'text_' + _id;
                }
            }
        };
    readId = function (node, textNodeMap) {
        if (canExpando || node.nodeType !== 3) {
            return node[expando];
        } else {
            for (var textNodeID in textNodeMap) {
                if (textNodeMap[textNodeID] === node) {
                    return textNodeID;
                }
            }
        }
    };
    var splice = [].splice, push = [].push, itemsInChildListTree = function (list) {
            var count = 0;
            for (var i = 0, len = list.length; i < len; i++) {
                var item = list[i];
                if (item.nodeType) {
                    count++;
                } else {
                    count += itemsInChildListTree(item);
                }
            }
            return count;
        }, replacementMap = function (replacements, idMap) {
            var map = {};
            for (var i = 0, len = replacements.length; i < len; i++) {
                var node = nodeLists.first(replacements[i]);
                map[id(node, idMap)] = replacements[i];
            }
            return map;
        }, addUnfoundAsDeepChildren = function (list, rMap, foundIds) {
            for (var repId in rMap) {
                if (!foundIds[repId]) {
                    list.newDeepChildren.push(rMap[repId]);
                }
            }
        };
    nodeLists = {
        id: id,
        update: function (nodeList, newNodes) {
            var oldNodes = nodeLists.unregisterChildren(nodeList);
            newNodes = makeArray(newNodes);
            var oldListLength = nodeList.length;
            splice.apply(nodeList, [
                0,
                oldListLength
            ].concat(newNodes));
            if (nodeList.replacements) {
                nodeLists.nestReplacements(nodeList);
                nodeList.deepChildren = nodeList.newDeepChildren;
                nodeList.newDeepChildren = [];
            } else {
                nodeLists.nestList(nodeList);
            }
            return oldNodes;
        },
        nestReplacements: function (list) {
            var index = 0, idMap = {}, rMap = replacementMap(list.replacements, idMap), rCount = list.replacements.length, foundIds = {};
            while (index < list.length && rCount) {
                var node = list[index], nodeId = readId(node, idMap), replacement = rMap[nodeId];
                if (replacement) {
                    list.splice(index, itemsInChildListTree(replacement), replacement);
                    foundIds[nodeId] = true;
                    rCount--;
                }
                index++;
            }
            if (rCount) {
                addUnfoundAsDeepChildren(list, rMap, foundIds);
            }
            list.replacements = [];
        },
        nestList: function (list) {
            var index = 0;
            while (index < list.length) {
                var node = list[index], childNodeList = nodeMap[id(node)];
                if (childNodeList) {
                    if (childNodeList !== list) {
                        list.splice(index, itemsInChildListTree(childNodeList), childNodeList);
                    }
                } else {
                    nodeMap[id(node)] = list;
                }
                index++;
            }
        },
        last: function (nodeList) {
            var last = nodeList[nodeList.length - 1];
            if (last.nodeType) {
                return last;
            } else {
                return nodeLists.last(last);
            }
        },
        first: function (nodeList) {
            var first = nodeList[0];
            if (first.nodeType) {
                return first;
            } else {
                return nodeLists.first(first);
            }
        },
        flatten: function (nodeList) {
            var items = [];
            for (var i = 0; i < nodeList.length; i++) {
                var item = nodeList[i];
                if (item.nodeType) {
                    items.push(item);
                } else {
                    items.push.apply(items, nodeLists.flatten(item));
                }
            }
            return items;
        },
        register: function (nodeList, unregistered, parent, directlyNested) {
            CID(nodeList);
            nodeList.unregistered = unregistered;
            nodeList.parentList = parent;
            nodeList.nesting = parent && typeof parent.nesting !== 'undefined' ? parent.nesting + 1 : 0;
            if (parent) {
                nodeList.deepChildren = [];
                nodeList.newDeepChildren = [];
                nodeList.replacements = [];
                if (parent !== true) {
                    if (directlyNested) {
                        parent.replacements.push(nodeList);
                    } else {
                        parent.newDeepChildren.push(nodeList);
                    }
                }
            } else {
                nodeLists.nestList(nodeList);
            }
            return nodeList;
        },
        unregisterChildren: function (nodeList) {
            var nodes = [];
            each(nodeList, function (node) {
                if (node.nodeType) {
                    if (!nodeList.replacements) {
                        delete nodeMap[id(node)];
                    }
                    nodes.push(node);
                } else {
                    push.apply(nodes, nodeLists.unregister(node, true));
                }
            });
            each(nodeList.deepChildren, function (nodeList) {
                nodeLists.unregister(nodeList, true);
            });
            return nodes;
        },
        unregister: function (nodeList, isChild) {
            var nodes = nodeLists.unregisterChildren(nodeList, true);
            if (nodeList.unregistered) {
                var unregisteredCallback = nodeList.unregistered;
                nodeList.replacements = nodeList.unregistered = null;
                if (!isChild) {
                    var deepChildren = nodeList.parentList && nodeList.parentList.deepChildren;
                    if (deepChildren) {
                        var index = deepChildren.indexOf(nodeList);
                        if (index !== -1) {
                            deepChildren.splice(index, 1);
                        }
                    }
                }
                unregisteredCallback();
            }
            return nodes;
        },
        nodeMap: nodeMap,
        after: function (oldElements, newFrag) {
            var last = oldElements[oldElements.length - 1];
            if (last.nextSibling) {
                domMutate.insertBefore.call(last.parentNode, newFrag, last.nextSibling);
            } else {
                domMutate.appendChild.call(last.parentNode, newFrag);
            }
        },
        replace: function (oldElements, newFrag) {
            var selectedValue, parentNode = oldElements[0].parentNode;
            if (parentNode.nodeName.toUpperCase() === 'SELECT' && parentNode.selectedIndex >= 0) {
                selectedValue = parentNode.value;
            }
            if (oldElements.length === 1) {
                domMutate.replaceChild.call(parentNode, newFrag, oldElements[0]);
            } else {
                nodeLists.after(oldElements, newFrag);
                nodeLists.remove(oldElements);
            }
            if (selectedValue !== undefined) {
                parentNode.value = selectedValue;
            }
        },
        remove: function (elementsToBeRemoved) {
            var parent = elementsToBeRemoved[0] && elementsToBeRemoved[0].parentNode;
            each(elementsToBeRemoved, function (child) {
                domMutate.removeChild.call(parent, child);
            });
        }
    };
    module.exports = nodeLists;
});
/*can-legacy-view-helpers@0.5.0#src/elements*/
define('can-legacy-view-helpers@0.5.0#src/elements', function (require, exports, module) {
    var nodeLists = require('./node_list');
    var doc = typeof document !== 'undefined' ? document : null;
    var elements = {
        tagToContentPropMap: {
            option: doc && 'textContent' in document.createElement('option') ? 'textContent' : 'innerText',
            textarea: 'value'
        },
        tagMap: {
            '': 'span',
            colgroup: 'col',
            table: 'tbody',
            tr: 'td',
            ol: 'li',
            ul: 'li',
            tbody: 'tr',
            thead: 'tr',
            tfoot: 'tr',
            select: 'option',
            optgroup: 'option'
        },
        reverseTagMap: {
            col: 'colgroup',
            tr: 'tbody',
            option: 'select',
            td: 'tr',
            th: 'tr',
            li: 'ul'
        },
        selfClosingTags: { col: true },
        getParentNode: function (el, defaultParentNode) {
            return defaultParentNode && el.parentNode.nodeType === 11 ? defaultParentNode : el.parentNode;
        },
        contentText: function (text) {
            if (typeof text === 'string') {
                return text;
            }
            if (!text && text !== 0) {
                return '';
            }
            return '' + text;
        },
        after: nodeLists.after,
        replace: nodeLists.replace
    };
    module.exports = elements;
});
/*can-legacy-view-helpers@0.5.0#src/live*/
define('can-legacy-view-helpers@0.5.0#src/live', function (require, exports, module) {
    var elements = require('./elements');
    var nodeLists = require('./node_list');
    var parser = require('can-view-parser');
    var diff = require('can-util/js/diff/diff');
    var view = require('./view');
    var domEvent = require('can-util/dom/events/events');
    var canFrag = require('can-util/dom/frag/frag');
    var makeArray = require('can-util/js/make-array/make-array');
    var each = require('can-util/js/each/each');
    var canCompute = require('can-compute');
    var domAttr = require('can-util/dom/attr/attr');
    var domData = require('can-util/dom/data/data');
    var domMutate = require('can-util/dom/mutate/mutate');
    var canBatch = require('can-event/batch/batch');
    require('can-util/dom/events/removed/removed');
    var newLine = /(\r|\n)+/g;
    var getValue = function (val) {
        var regexp = /^["'].*["']$/;
        val = val.replace(elements.attrReg, '').replace(newLine, '');
        return regexp.test(val) ? val.substr(1, val.length - 2) : val;
    };
    var setup = function (el, bind, unbind) {
            var data;
            var tornDown = false, teardown = function () {
                    if (!tornDown) {
                        tornDown = true;
                        unbind(data);
                        domEvent.removeEventListener.call(el, 'removed', teardown);
                    }
                    return true;
                };
            data = {
                teardownCheck: function (parent) {
                    return parent ? false : teardown();
                }
            };
            domEvent.addEventListener.call(el, 'removed', teardown);
            bind(data);
            return data;
        }, getChildNodes = function (node) {
            var childNodes = node.childNodes;
            if ('length' in childNodes) {
                return childNodes;
            } else {
                var cur = node.firstChild;
                var nodes = [];
                while (cur) {
                    nodes.push(cur);
                    cur = cur.nextSibling;
                }
                return nodes;
            }
        }, listen = function (el, compute, change) {
            return setup(el, function () {
                compute.computeInstance.bind('change', change);
            }, function (data) {
                compute.computeInstance.unbind('change', change);
                if (data.nodeList) {
                    nodeLists.unregister(data.nodeList);
                }
            });
        }, getAttributeParts = function (newVal) {
            var attrs = {}, attr;
            parser.parseAttrs(newVal, {
                attrStart: function (name) {
                    attrs[name] = '';
                    attr = name;
                },
                attrValue: function (value) {
                    attrs[attr] += value;
                },
                attrEnd: function () {
                }
            });
            return attrs;
        }, splice = [].splice, isNode = function (obj) {
            return obj && obj.nodeType;
        }, addTextNodeIfNoChildren = function (frag) {
            if (!frag.firstChild) {
                frag.appendChild(frag.ownerDocument.createTextNode(''));
            }
        }, getLiveFragment = function (itemHTML) {
            var gotText = typeof itemHTML === 'string', itemFrag = canFrag(itemHTML);
            return gotText ? view.hookup(itemFrag) : itemFrag;
        }, renderAndAddToNodeLists = function (newNodeLists, parentNodeList, render, context, args) {
            var itemNodeList = [];
            if (parentNodeList) {
                nodeLists.register(itemNodeList, null, true, true);
                itemNodeList.parentList = parentNodeList;
                itemNodeList.expression = '#each SUBEXPRESSION';
            }
            var itemHTML = render.apply(context, args.concat([itemNodeList])), itemFrag = getLiveFragment(itemHTML);
            var childNodes = makeArray(getChildNodes(itemFrag));
            if (parentNodeList) {
                nodeLists.update(itemNodeList, childNodes);
                newNodeLists.push(itemNodeList);
            } else {
                newNodeLists.push(nodeLists.register(childNodes));
            }
            return itemFrag;
        }, removeFromNodeList = function (masterNodeList, index, length) {
            var removedMappings = masterNodeList.splice(index + 1, length), itemsToRemove = [];
            each(removedMappings, function (nodeList) {
                var nodesToRemove = nodeLists.unregister(nodeList);
                [].push.apply(itemsToRemove, nodesToRemove);
            });
            return itemsToRemove;
        }, addFalseyIfEmpty = function (list, falseyRender, masterNodeList, nodeList) {
            if (falseyRender && list.length === 0) {
                var falseyNodeLists = [];
                var falseyFrag = renderAndAddToNodeLists(falseyNodeLists, nodeList, falseyRender, list, [list]);
                elements.after([masterNodeList[0]], falseyFrag);
                masterNodeList.push(falseyNodeLists[0]);
            }
        }, childMutationCallbacks = {};
    var live = {
        registerChildMutationCallback: function (tag, callback) {
            if (callback) {
                childMutationCallbacks[tag] = callback;
            } else {
                return childMutationCallbacks[tag];
            }
        },
        callChildMutationCallback: function (el) {
            var callback = el && childMutationCallbacks[el.nodeName.toLowerCase()];
            if (callback) {
                callback(el);
            }
        },
        list: function (el, compute, render, context, parentNode, nodeList, falseyRender) {
            var remove, text, list, data;
            var masterNodeList = nodeList || [el], indexMap = [], afterPreviousEvents = false, isTornDown = false, add = function (ev, items, index) {
                    if (!afterPreviousEvents) {
                        return;
                    }
                    var frag = text.ownerDocument.createDocumentFragment(), newNodeLists = [], newIndicies = [];
                    each(items, function (item, key) {
                        var itemIndex = canCompute(key + index), itemFrag = renderAndAddToNodeLists(newNodeLists, nodeList, render, context, [
                                item,
                                itemIndex
                            ]);
                        frag.appendChild(itemFrag);
                        newIndicies.push(itemIndex);
                    });
                    var masterListIndex = index + 1;
                    if (!indexMap.length) {
                        var falseyItemsToRemove = removeFromNodeList(masterNodeList, 0, masterNodeList.length - 1);
                        nodeLists.remove(falseyItemsToRemove);
                    }
                    if (!masterNodeList[masterListIndex]) {
                        elements.after(masterListIndex === 1 ? [text] : [nodeLists.last(masterNodeList[masterListIndex - 1])], frag);
                    } else {
                        var el = nodeLists.first(masterNodeList[masterListIndex]);
                        domMutate.insertBefore.call(el.parentNode, frag, el);
                    }
                    splice.apply(masterNodeList, [
                        masterListIndex,
                        0
                    ].concat(newNodeLists));
                    splice.apply(indexMap, [
                        index,
                        0
                    ].concat(newIndicies));
                    for (var i = index + newIndicies.length, len = indexMap.length; i < len; i++) {
                        indexMap[i](i);
                    }
                    if (ev.callChildMutationCallback !== false) {
                        live.callChildMutationCallback(text.parentNode);
                    }
                }, set = function (ev, newVal, index) {
                    remove({}, { length: 1 }, index, true);
                    add({}, [newVal], index);
                };
            remove = function (ev, items, index, duringTeardown, fullTeardown) {
                if (!afterPreviousEvents) {
                    return;
                }
                if (!duringTeardown && data.teardownCheck(text.parentNode)) {
                    return;
                }
                if (index < 0) {
                    index = indexMap.length + index;
                }
                var itemsToRemove = removeFromNodeList(masterNodeList, index, items.length);
                indexMap.splice(index, items.length);
                for (var i = index, len = indexMap.length; i < len; i++) {
                    indexMap[i](i);
                }
                if (!fullTeardown) {
                    addFalseyIfEmpty(list, falseyRender, masterNodeList, nodeList);
                    nodeLists.remove(itemsToRemove);
                    if (ev.callChildMutationCallback !== false) {
                        live.callChildMutationCallback(text.parentNode);
                    }
                } else {
                    nodeLists.unregister(masterNodeList);
                }
            };
            var move = function (ev, item, newIndex, currentIndex) {
                if (!afterPreviousEvents) {
                    return;
                }
                newIndex = newIndex + 1;
                currentIndex = currentIndex + 1;
                var referenceNodeList = masterNodeList[newIndex];
                var movedElements = canFrag(nodeLists.flatten(masterNodeList[currentIndex]));
                var referenceElement;
                if (currentIndex < newIndex) {
                    referenceElement = nodeLists.last(referenceNodeList).nextSibling;
                } else {
                    referenceElement = nodeLists.first(referenceNodeList);
                }
                var parentNode = masterNodeList[0].parentNode;
                parentNode.insertBefore(movedElements, referenceElement);
                var temp = masterNodeList[currentIndex];
                [].splice.apply(masterNodeList, [
                    currentIndex,
                    1
                ]);
                [].splice.apply(masterNodeList, [
                    newIndex,
                    0,
                    temp
                ]);
                newIndex = newIndex - 1;
                currentIndex = currentIndex - 1;
                var indexCompute = indexMap[currentIndex];
                [].splice.apply(indexMap, [
                    currentIndex,
                    1
                ]);
                [].splice.apply(indexMap, [
                    newIndex,
                    0,
                    indexCompute
                ]);
                var i = Math.min(currentIndex, newIndex);
                var len = indexMap.length;
                for (i, len; i < len; i++) {
                    indexMap[i](i);
                }
                if (ev.callChildMutationCallback !== false) {
                    live.callChildMutationCallback(text.parentNode);
                }
            };
            text = el.ownerDocument.createTextNode('');
            var teardownList = function (fullTeardown) {
                    if (list && list.unbind) {
                        list.unbind('add', add).unbind('set', set).unbind('remove', remove).unbind('move', move);
                    }
                    remove({ callChildMutationCallback: !!fullTeardown }, { length: masterNodeList.length - 1 }, 0, true, fullTeardown);
                }, updateList = function (ev, newList, oldList) {
                    if (isTornDown) {
                        return;
                    }
                    afterPreviousEvents = true;
                    if (newList && oldList) {
                        list = newList || [];
                        var patches = diff(oldList, newList);
                        if (oldList.unbind) {
                            oldList.unbind('add', add).unbind('set', set).unbind('remove', remove).unbind('move', move);
                        }
                        for (var i = 0, patchLen = patches.length; i < patchLen; i++) {
                            var patch = patches[i];
                            if (patch.deleteCount) {
                                remove({ callChildMutationCallback: false }, { length: patch.deleteCount }, patch.index, true);
                            }
                            if (patch.insert.length) {
                                add({ callChildMutationCallback: false }, patch.insert, patch.index);
                            }
                        }
                    } else {
                        if (oldList) {
                            teardownList();
                        }
                        list = newList || [];
                        add({ callChildMutationCallback: false }, list, 0);
                        addFalseyIfEmpty(list, falseyRender, masterNodeList, nodeList);
                    }
                    live.callChildMutationCallback(text.parentNode);
                    afterPreviousEvents = false;
                    if (list.bind) {
                        list.bind('add', add).bind('set', set).bind('remove', remove).bind('move', move);
                    }
                    canBatch.afterPreviousEvents(function () {
                        afterPreviousEvents = true;
                    });
                };
            parentNode = elements.getParentNode(el, parentNode);
            data = setup(parentNode, function () {
                if (typeof compute === 'function') {
                    compute.bind('change', updateList);
                }
            }, function () {
                if (typeof compute === 'function') {
                    compute.unbind('change', updateList);
                }
                teardownList(true);
            });
            if (!nodeList) {
                live.replace(masterNodeList, text, data.teardownCheck);
            } else {
                elements.replace(masterNodeList, text);
                nodeLists.update(masterNodeList, [text]);
                nodeList.unregistered = function () {
                    data.teardownCheck();
                    isTornDown = true;
                };
            }
            updateList({}, typeof compute === 'function' ? compute() : compute);
        },
        html: function (el, compute, parentNode, nodeList) {
            var data, nodes, makeAndPut;
            parentNode = elements.getParentNode(el, parentNode);
            data = listen(parentNode, compute, function (ev, newVal) {
                var attached = nodeLists.first(nodes).parentNode;
                if (attached) {
                    makeAndPut(newVal);
                }
                var pn = nodeLists.first(nodes).parentNode;
                data.teardownCheck(pn);
                live.callChildMutationCallback(pn);
            });
            nodes = nodeList || [el];
            makeAndPut = function (val) {
                var isFunction = typeof val === 'function', aNode = isNode(val), frag = canFrag(isFunction ? '' : val), oldNodes = makeArray(nodes);
                addTextNodeIfNoChildren(frag);
                if (!aNode && !isFunction) {
                    frag = view.hookup(frag, parentNode);
                }
                oldNodes = nodeLists.update(nodes, getChildNodes(frag));
                if (isFunction) {
                    val(frag.firstChild);
                }
                elements.replace(oldNodes, frag);
            };
            data.nodeList = nodes;
            if (!nodeList) {
                nodeLists.register(nodes, data.teardownCheck);
            } else {
                nodeList.unregistered = data.teardownCheck;
            }
            makeAndPut(compute());
        },
        replace: function (nodes, val, teardown) {
            var oldNodes = nodes.slice(0), frag = canFrag(val);
            nodeLists.register(nodes, teardown);
            if (typeof val === 'string') {
                frag = view.hookup(frag, nodes[0].parentNode);
            }
            nodeLists.update(nodes, getChildNodes(frag));
            elements.replace(oldNodes, frag);
            return nodes;
        },
        text: function (el, compute, parentNode, nodeList) {
            var parent = elements.getParentNode(el, parentNode), node;
            var data = listen(parent, compute, function (ev, newVal) {
                if (typeof node.nodeValue !== 'unknown') {
                    node.nodeValue = view.toStr(newVal);
                }
                data.teardownCheck(node.parentNode);
            });
            node = el.ownerDocument.createTextNode(view.toStr(compute()));
            if (nodeList) {
                nodeList.unregistered = data.teardownCheck;
                data.nodeList = nodeList;
                nodeLists.update(nodeList, [node]);
                elements.replace([el], node);
            } else {
                data.nodeList = live.replace([el], node, data.teardownCheck);
            }
        },
        setAttributes: function (el, newVal) {
            var attrs = getAttributeParts(newVal);
            for (var name in attrs) {
                domAttr.set(el, name, attrs[name]);
            }
        },
        attributes: function (el, compute, currentValue) {
            var oldAttrs = {};
            var setAttrs = function (newVal) {
                var newAttrs = getAttributeParts(newVal), name;
                for (name in newAttrs) {
                    var newValue = newAttrs[name], oldValue = oldAttrs[name];
                    if (newValue !== oldValue) {
                        domAttr.set(el, name, newValue);
                    }
                    delete oldAttrs[name];
                }
                for (name in oldAttrs) {
                    domAttr.remove(el, name);
                }
                oldAttrs = newAttrs;
            };
            listen(el, compute, function (ev, newVal) {
                setAttrs(newVal);
            });
            if (arguments.length >= 3) {
                oldAttrs = getAttributeParts(currentValue);
            } else {
                setAttrs(compute());
            }
        },
        attributePlaceholder: '__!!__',
        attributeReplace: /__!!__/g,
        attribute: function (el, attributeName, compute) {
            var hook;
            listen(el, compute, function () {
                domAttr.set(el, attributeName, hook.render());
            });
            var hooks;
            hooks = domData.get.call(el, 'hooks');
            if (!hooks) {
                domData.set.call(el, 'hooks', hooks = {});
            }
            var attr = String(domAttr.get(el, attributeName)), parts = attr.split(live.attributePlaceholder), goodParts = [];
            goodParts.push(parts.shift(), parts.join(live.attributePlaceholder));
            if (hooks[attributeName]) {
                hooks[attributeName].computes.push(compute);
            } else {
                hooks[attributeName] = {
                    render: function () {
                        var i = 0, newAttr = attr ? attr.replace(live.attributeReplace, function () {
                                return view.contentText(hook.computes[i++]());
                            }) : view.contentText(hook.computes[i++]());
                        return newAttr;
                    },
                    computes: [compute],
                    batchNum: undefined
                };
            }
            hook = hooks[attributeName];
            goodParts.splice(1, 0, compute());
            domAttr.set(el, attributeName, goodParts.join(''));
        },
        specialAttribute: function (el, attributeName, compute) {
            listen(el, compute, function (ev, newVal) {
                domAttr.set(el, attributeName, getValue(newVal));
            });
            domAttr.set(el, attributeName, getValue(compute()));
        },
        simpleAttribute: function (el, attributeName, compute) {
            listen(el, compute, function (ev, newVal) {
                elements.setAttr(el, attributeName, newVal);
            });
            elements.setAttr(el, attributeName, compute());
        }
    };
    live.attr = live.simpleAttribute;
    live.attrs = live.attributes;
    live.getAttributeParts = getAttributeParts;
    module.exports = live;
});
/*can-legacy-view-helpers@0.5.0#src/render*/
define('can-legacy-view-helpers@0.5.0#src/render', function (require, exports, module) {
    var view = require('./view');
    var elements = require('./elements');
    var string = require('can-util/js/string/string');
    var deepAssign = require('can-util/js/deep-assign/deep-assign');
    var canCompute = require('can-compute');
    var live = require('./live');
    var pendingHookups = [], tagChildren = function (tagName) {
            var newTag = elements.tagMap[tagName] || 'span';
            if (newTag === 'span') {
                return '@@!!@@';
            }
            return '<' + newTag + '>' + tagChildren(newTag) + '</' + newTag + '>';
        }, contentText = function (input, tag) {
            if (typeof input === 'string') {
                return input;
            }
            if (!input && input !== 0) {
                return '';
            }
            var hook = input.hookup && function (el, id) {
                input.hookup.call(input, el, id);
            } || typeof input === 'function' && input;
            if (hook) {
                if (tag) {
                    return '<' + tag + ' ' + view.hook(hook) + '></' + tag + '>';
                } else {
                    pendingHookups.push(hook);
                }
                return '';
            }
            return '' + input;
        }, contentEscape = function (txt, tag) {
            return typeof txt === 'string' || typeof txt === 'number' ? string.esc(txt) : contentText(txt, tag);
        }, withinTemplatedSectionWithinAnElement = false, emptyHandler = function () {
        };
    var lastHookups;
    deepAssign(view, {
        contentText: contentText,
        live: live,
        setupLists: function () {
            var old = view.lists, data;
            view.lists = function (list, renderer) {
                data = {
                    list: list,
                    renderer: renderer
                };
                return Math.random();
            };
            return function () {
                view.lists = old;
                return data;
            };
        },
        getHooks: function () {
            var hooks = pendingHookups.slice(0);
            lastHookups = hooks;
            pendingHookups = [];
            return hooks;
        },
        onlytxt: function (self, func) {
            return contentEscape(func.call(self));
        },
        txt: function (escape, tagName, status, self, func) {
            var tag = elements.tagMap[tagName] || 'span', setupLiveBinding = false, value, listData, compute, unbind = emptyHandler, attributeName;
            if (withinTemplatedSectionWithinAnElement) {
                value = func.call(self);
            } else {
                if (typeof status === 'string' || status === 1) {
                    withinTemplatedSectionWithinAnElement = true;
                }
                var listTeardown = view.setupLists();
                unbind = function () {
                    compute.unbind('change', emptyHandler);
                };
                compute = canCompute(func, self, false);
                compute.bind('change', emptyHandler);
                listData = listTeardown();
                value = compute();
                withinTemplatedSectionWithinAnElement = false;
                setupLiveBinding = compute.computeInstance.hasDependencies;
            }
            if (listData) {
                unbind();
                return '<' + tag + view.hook(function (el, parentNode) {
                    live.list(el, listData.list, listData.renderer, self, parentNode);
                }) + '></' + tag + '>';
            }
            if (!setupLiveBinding || typeof value === 'function') {
                unbind();
                return (withinTemplatedSectionWithinAnElement || escape === 2 || !escape ? contentText : contentEscape)(value, status === 0 && tag);
            }
            var contentProp = elements.tagToContentPropMap[tagName];
            if (status === 0 && !contentProp) {
                var selfClosing = !!elements.selfClosingTags[tag];
                return '<' + tag + view.hook(escape && typeof value !== 'object' ? function (el, parentNode) {
                    live.text(el, compute, parentNode);
                    unbind();
                } : function (el, parentNode) {
                    live.html(el, compute, parentNode);
                    unbind();
                }) + (selfClosing ? '/>' : '>' + tagChildren(tag) + '</' + tag + '>');
            } else if (status === 1) {
                pendingHookups.push(function (el) {
                    live.attributes(el, compute, compute());
                    unbind();
                });
                return compute();
            } else if (escape === 2) {
                attributeName = status;
                pendingHookups.push(function (el) {
                    live.specialAttribute(el, attributeName, compute);
                    unbind();
                });
                return compute();
            } else {
                attributeName = status === 0 ? contentProp : status;
                (status === 0 ? lastHookups : pendingHookups).push(function (el) {
                    live.attribute(el, attributeName, compute);
                    unbind();
                });
                return live.attributePlaceholder;
            }
        }
    });
    module.exports = view;
});
/*can-legacy-view-helpers@0.5.0#src/scanner*/
define('can-legacy-view-helpers@0.5.0#src/scanner', function (require, exports, module) {
    var elements = require('./elements');
    var viewCallbacks = require('can-view-callbacks');
    var deepAssign = require('can-util/js/deep-assign/deep-assign');
    var view = require('./view');
    var each = require('can-util/js/each/each');
    var newLine = /(\r|\n)+/g, notEndTag = /\//, clean = function (content) {
            return content.split('\\').join('\\\\').split('\n').join('\\n').split('"').join('\\"').split('\t').join('\\t');
        }, getTag = function (tagName, tokens, i) {
            if (tagName) {
                return tagName;
            } else {
                while (i < tokens.length) {
                    if (tokens[i] === '<' && !notEndTag.test(tokens[i + 1])) {
                        return elements.reverseTagMap[tokens[i + 1]] || 'span';
                    }
                    i++;
                }
            }
            return '';
        }, bracketNum = function (content) {
            return --content.split('{').length - --content.split('}').length;
        }, myEval = function (script) {
            eval(script);
        }, attrReg = /([^\s]+)[\s]*=[\s]*$/, startTxt = 'var ___v1ew = [];', finishTxt = 'return ___v1ew.join(\'\')', put_cmd = '___v1ew.push(\n', insert_cmd = put_cmd, htmlTag = null, quote = null, beforeQuote = null, rescan = null, getAttrName = function () {
            var matches = beforeQuote.match(attrReg);
            return matches && matches[1];
        }, _status = function () {
            return quote ? '\'' + getAttrName() + '\'' : htmlTag ? 1 : 0;
        }, _top = function (stack) {
            return stack[stack.length - 1];
        }, Scanner;
    var Scanner = function (options) {
        deepAssign(this, {
            text: {},
            tokens: []
        }, options);
        this.text.options = this.text.options || '';
        this.tokenReg = [];
        this.tokenSimple = {
            '<': '<',
            '>': '>',
            '"': '"',
            '\'': '\''
        };
        this.tokenComplex = [];
        this.tokenMap = {};
        for (var i = 0, token; token = this.tokens[i]; i++) {
            if (token[2]) {
                this.tokenReg.push(token[2]);
                this.tokenComplex.push({
                    abbr: token[1],
                    re: new RegExp(token[2]),
                    rescan: token[3]
                });
            } else {
                this.tokenReg.push(token[1]);
                this.tokenSimple[token[1]] = token[0];
            }
            this.tokenMap[token[0]] = token[1];
        }
        this.tokenReg = new RegExp('(' + this.tokenReg.slice(0).concat([
            '<',
            '>',
            '"',
            '\''
        ]).join('|') + ')', 'g');
    };
    Scanner.prototype = {
        helpers: [],
        scan: function (source, name) {
            var tokens = [], last = 0, simple = this.tokenSimple, complex = this.tokenComplex;
            source = source.replace(newLine, '\n');
            if (this.transform) {
                source = this.transform(source);
            }
            source.replace(this.tokenReg, function (whole, part) {
                var offset = arguments[arguments.length - 2];
                if (offset > last) {
                    tokens.push(source.substring(last, offset));
                }
                if (simple[whole]) {
                    tokens.push(whole);
                } else {
                    for (var i = 0, token; token = complex[i]; i++) {
                        if (token.re.test(whole)) {
                            tokens.push(token.abbr);
                            if (token.rescan) {
                                tokens.push(token.rescan(part));
                            }
                            break;
                        }
                    }
                }
                last = offset + part.length;
            });
            if (last < source.length) {
                tokens.push(source.substr(last));
            }
            var content = '', buff = [startTxt + (this.text.start || '')], put = function (content, bonus) {
                    buff.push(put_cmd, '"', clean(content), '"' + (bonus || '') + ');');
                }, endStack = [], lastToken, startTag = null, magicInTag = false, specialStates = {
                    attributeHookups: [],
                    tagHookups: [],
                    lastTagHookup: ''
                }, popTagHookup = function () {
                    specialStates.lastTagHookup = specialStates.tagHookups.pop() + specialStates.tagHookups.length;
                }, tagName = '', tagNames = [], popTagName = false, bracketCount, specialAttribute = false, i = 0, token, tmap = this.tokenMap, attrName;
            htmlTag = quote = beforeQuote = null;
            for (; (token = tokens[i++]) !== undefined;) {
                if (startTag === null) {
                    switch (token) {
                    case tmap.left:
                    case tmap.escapeLeft:
                    case tmap.returnLeft:
                        magicInTag = htmlTag && 1;
                    case tmap.commentLeft:
                        startTag = token;
                        if (content.length) {
                            put(content);
                        }
                        content = '';
                        break;
                    case tmap.escapeFull:
                        magicInTag = htmlTag && 1;
                        rescan = 1;
                        startTag = tmap.escapeLeft;
                        if (content.length) {
                            put(content);
                        }
                        rescan = tokens[i++];
                        content = rescan.content || rescan;
                        if (rescan.before) {
                            put(rescan.before);
                        }
                        tokens.splice(i, 0, tmap.right);
                        break;
                    case tmap.commentFull:
                        break;
                    case tmap.templateLeft:
                        content += tmap.left;
                        break;
                    case '<':
                        if (tokens[i].indexOf('!--') !== 0) {
                            htmlTag = 1;
                            magicInTag = 0;
                        }
                        content += token;
                        break;
                    case '>':
                        htmlTag = 0;
                        var emptyElement = content.substr(content.length - 1) === '/' || content.substr(content.length - 2) === '--', attrs = '';
                        if (specialStates.attributeHookups.length) {
                            attrs = 'attrs: [\'' + specialStates.attributeHookups.join('\',\'') + '\'], ';
                            specialStates.attributeHookups = [];
                        }
                        if (tagName + specialStates.tagHookups.length !== specialStates.lastTagHookup && tagName === _top(specialStates.tagHookups)) {
                            if (emptyElement) {
                                content = content.substr(0, content.length - 1);
                            }
                            buff.push(put_cmd, '"', clean(content), '"', ',CAN_LEGACY_HELPERS.view.pending({tagName:\'' + tagName + '\',' + attrs + 'scope: ' + (this.text.scope || 'this') + this.text.options);
                            if (emptyElement) {
                                buff.push('}));');
                                content = '/>';
                                popTagHookup();
                            } else if (tokens[i] === '<' && tokens[i + 1] === '/' + tagName) {
                                buff.push('}));');
                                content = token;
                                popTagHookup();
                            } else {
                                buff.push(',subtemplate: function(' + this.text.argNames + '){\n' + startTxt + (this.text.start || ''));
                                content = '';
                            }
                        } else if (magicInTag || !popTagName && elements.tagToContentPropMap[tagNames[tagNames.length - 1]] || attrs) {
                            var pendingPart = ',CAN_LEGACY_HELPERS.view.pending({' + attrs + 'scope: ' + (this.text.scope || 'this') + this.text.options + '}),"';
                            if (emptyElement) {
                                put(content.substr(0, content.length - 1), pendingPart + '/>"');
                            } else {
                                put(content, pendingPart + '>"');
                            }
                            content = '';
                            magicInTag = 0;
                        } else {
                            content += token;
                        }
                        if (emptyElement || popTagName) {
                            tagNames.pop();
                            tagName = tagNames[tagNames.length - 1];
                            popTagName = false;
                        }
                        specialStates.attributeHookups = [];
                        break;
                    case '\'':
                    case '"':
                        if (htmlTag) {
                            if (quote && quote === token) {
                                quote = null;
                                var attr = getAttrName();
                                if (viewCallbacks.attr(attr)) {
                                    specialStates.attributeHookups.push(attr);
                                }
                                if (specialAttribute) {
                                    content += token;
                                    put(content);
                                    buff.push(finishTxt, '}));\n');
                                    content = '';
                                    specialAttribute = false;
                                    break;
                                }
                            } else if (quote === null) {
                                quote = token;
                                beforeQuote = lastToken;
                                attrName = getAttrName();
                                if (tagName === 'img' && attrName === 'src' || attrName === 'style') {
                                    put(content.replace(attrReg, ''));
                                    content = '';
                                    specialAttribute = true;
                                    buff.push(insert_cmd, 'CAN_LEGACY_HELPERS.view.txt(2,\'' + getTag(tagName, tokens, i) + '\',' + _status() + ',this,function(){', startTxt);
                                    put(attrName + '=' + token);
                                    break;
                                }
                            }
                        }
                    default:
                        if (lastToken === '<') {
                            tagName = token.substr(0, 3) === '!--' ? '!--' : token.split(/\s/)[0];
                            var isClosingTag = false, cleanedTagName;
                            if (tagName.indexOf('/') === 0) {
                                isClosingTag = true;
                                cleanedTagName = tagName.substr(1);
                            }
                            if (isClosingTag) {
                                if (_top(tagNames) === cleanedTagName) {
                                    tagName = cleanedTagName;
                                    popTagName = true;
                                }
                                if (_top(specialStates.tagHookups) === cleanedTagName) {
                                    put(content.substr(0, content.length - 1));
                                    buff.push(finishTxt + '}}) );');
                                    content = '><';
                                    popTagHookup();
                                }
                            } else {
                                if (tagName.lastIndexOf('/') === tagName.length - 1) {
                                    tagName = tagName.substr(0, tagName.length - 1);
                                }
                                if (tagName !== '!--' && viewCallbacks.tag(tagName)) {
                                    if (tagName === 'content' && elements.tagMap[_top(tagNames)]) {
                                        token = token.replace('content', elements.tagMap[_top(tagNames)]);
                                    }
                                    specialStates.tagHookups.push(tagName);
                                }
                                tagNames.push(tagName);
                            }
                        }
                        content += token;
                        break;
                    }
                } else {
                    switch (token) {
                    case tmap.right:
                    case tmap.returnRight:
                        switch (startTag) {
                        case tmap.left:
                            bracketCount = bracketNum(content);
                            if (bracketCount === 1) {
                                buff.push(insert_cmd, 'CAN_LEGACY_HELPERS.view.txt(0,\'' + getTag(tagName, tokens, i) + '\',' + _status() + ',this,function(){', startTxt, content);
                                endStack.push({
                                    before: '',
                                    after: finishTxt + '}));\n'
                                });
                            } else {
                                last = endStack.length && bracketCount === -1 ? endStack.pop() : { after: ';' };
                                if (last.before) {
                                    buff.push(last.before);
                                }
                                buff.push(content, ';', last.after);
                            }
                            break;
                        case tmap.escapeLeft:
                        case tmap.returnLeft:
                            bracketCount = bracketNum(content);
                            if (bracketCount) {
                                endStack.push({
                                    before: finishTxt,
                                    after: '}));\n'
                                });
                            }
                            var escaped = startTag === tmap.escapeLeft ? 1 : 0, commands = {
                                    insert: insert_cmd,
                                    tagName: getTag(tagName, tokens, i),
                                    status: _status(),
                                    specialAttribute: specialAttribute
                                };
                            for (var ii = 0; ii < this.helpers.length; ii++) {
                                var helper = this.helpers[ii];
                                if (helper.name.test(content)) {
                                    content = helper.fn(content, commands);
                                    if (helper.name.source === /^>[\s]*\w*/.source) {
                                        escaped = 0;
                                    }
                                    break;
                                }
                            }
                            if (typeof content === 'object') {
                                if (content.startTxt && content.end && specialAttribute) {
                                    buff.push(insert_cmd, 'CAN_LEGACY_HELPERS.view.toStr( ', content.content, '() ) );');
                                } else {
                                    if (content.startTxt) {
                                        buff.push(insert_cmd, 'CAN_LEGACY_HELPERS.view.txt(\n' + (typeof _status() === 'string' || (content.escaped != null ? content.escaped : escaped)) + ',\n\'' + tagName + '\',\n' + _status() + ',\nthis,\n');
                                    } else if (content.startOnlyTxt) {
                                        buff.push(insert_cmd, 'CAN_LEGACY_HELPERS.view.onlytxt(this,\n');
                                    }
                                    buff.push(content.content);
                                    if (content.end) {
                                        buff.push('));');
                                    }
                                }
                            } else if (specialAttribute) {
                                buff.push(insert_cmd, content, ');');
                            } else {
                                buff.push(insert_cmd, 'CAN_LEGACY_HELPERS.view.txt(\n' + (typeof _status() === 'string' || escaped) + ',\n\'' + tagName + '\',\n' + _status() + ',\nthis,\nfunction(){ ' + (this.text.escape || '') + 'return ', content, bracketCount ? startTxt : '}));\n');
                            }
                            if (rescan && rescan.after && rescan.after.length) {
                                put(rescan.after.length);
                                rescan = null;
                            }
                            break;
                        }
                        startTag = null;
                        content = '';
                        break;
                    case tmap.templateLeft:
                        content += tmap.left;
                        break;
                    default:
                        content += token;
                        break;
                    }
                }
                lastToken = token;
            }
            if (content.length) {
                put(content);
            }
            buff.push(';');
            var template = buff.join(''), out = { out: (this.text.outStart || '') + template + ' ' + finishTxt + (this.text.outEnd || '') };
            myEval.call(out, 'this.fn = (function(' + this.text.argNames + '){' + out.out + '});\r\n//# sourceURL=' + name + '.js');
            return out;
        }
    };
    view.pending = function (viewData) {
        var hooks = view.getHooks();
        return view.hook(function (el) {
            each(hooks, function (fn) {
                fn(el);
            });
            viewData.templateType = 'legacy';
            if (viewData.tagName) {
                viewCallbacks.tagHandler(el, viewData.tagName, viewData);
            }
            each(viewData && viewData.attrs || [], function (attributeName) {
                viewData.attributeName = attributeName;
                var callback = viewCallbacks.attr(attributeName);
                if (callback) {
                    callback(el, viewData);
                }
            });
        });
    };
    view.Scanner = Scanner;
    module.exports = Scanner;
});
/*can-legacy-view-helpers@0.5.0#can-legacy-view-helpers*/
define('can-legacy-view-helpers@0.5.0#can-legacy-view-helpers', function (require, exports, module) {
    var render = require('./src/render');
    var scanner = require('./src/scanner');
    var view = require('./src/view');
    var elements = require('./src/elements');
    var live = require('./src/live');
    var nodeLists = require('./src/node_list');
    var legacyHelpers = {
        render: render,
        Scanner: scanner,
        view: view,
        elements: elements,
        live: live,
        nodeLists: nodeLists
    };
    window.CAN_LEGACY_HELPERS = legacyHelpers;
    module.exports = legacyHelpers;
});
/*can-ejs@3.0.4#can-ejs*/
define('can-ejs@3.0.4#can-ejs', function (require, exports, module) {
    var legacyHelpers = require('can-legacy-view-helpers');
    var extend = require('can-util/js/assign/assign');
    var namespace = require('can-namespace');
    var each = require('can-util/js/each/each');
    var types = require('can-types');
    var observationReader = require('can-observation/reader/reader');
    var DOCUMENT = require('can-util/dom/document/document');
    var templateId = 0;
    var EJS = function (options) {
        if (!this || this.constructor !== EJS) {
            var ejs = new EJS(options);
            return function (data, helpers) {
                return legacyHelpers.view.frag(ejs.render(data, helpers));
            };
        }
        if (typeof options === 'function') {
            this.template = { fn: options };
            return;
        }
        if (typeof options === 'string') {
            options = {
                text: options,
                name: '' + ++templateId
            };
        }
        extend(this, options);
        this.template = this.scanner.scan(this.text, this.name);
    };
    namespace.EJS = EJS;
    EJS.prototype.render = function (object, extraHelpers) {
        object = object || {};
        return this.template.fn.call(object, object, new EJS.Helpers(object, extraHelpers || {}));
    };
    extend(EJS.prototype, {
        scanner: new legacyHelpers.Scanner({
            text: {
                outStart: 'with(_VIEW) { with (_CONTEXT) {',
                outEnd: '}}',
                argNames: '_CONTEXT,_VIEW',
                context: 'this'
            },
            tokens: [
                [
                    'templateLeft',
                    '<%%'
                ],
                [
                    'templateRight',
                    '%>'
                ],
                [
                    'returnLeft',
                    '<%=='
                ],
                [
                    'escapeLeft',
                    '<%='
                ],
                [
                    'commentLeft',
                    '<%#'
                ],
                [
                    'left',
                    '<%'
                ],
                [
                    'right',
                    '%>'
                ],
                [
                    'returnRight',
                    '%>'
                ]
            ],
            helpers: [{
                    name: /\s*\(([\$\w]+)\)\s*->([^\n]*)/,
                    fn: function (content) {
                        var quickFunc = /\s*\(([\$\w]+)\)\s*->([^\n]*)/, parts = content.match(quickFunc);
                        return '(function(__){var ' + parts[1] + '=__;' + parts[2] + '}).bind(this);';
                    }
                }],
            transform: function (source) {
                return source.replace(/<%([\s\S]+?)%>/gm, function (whole, part) {
                    var brackets = [], foundBracketPair, i;
                    part.replace(/[{}]/gm, function (bracket, offset) {
                        brackets.push([
                            bracket,
                            offset
                        ]);
                    });
                    do {
                        foundBracketPair = false;
                        for (i = brackets.length - 2; i >= 0; i--) {
                            if (brackets[i][0] === '{' && brackets[i + 1][0] === '}') {
                                brackets.splice(i, 2);
                                foundBracketPair = true;
                                break;
                            }
                        }
                    } while (foundBracketPair);
                    if (brackets.length >= 2) {
                        var result = ['<%'], bracket, last = 0;
                        for (i = 0; bracket = brackets[i]; i++) {
                            result.push(part.substring(last, last = bracket[1]));
                            if (bracket[0] === '{' && i < brackets.length - 1 || bracket[0] === '}' && i > 0) {
                                result.push(bracket[0] === '{' ? '{ %><% ' : ' %><% }');
                            } else {
                                result.push(bracket[0]);
                            }
                            ++last;
                        }
                        result.push(part.substring(last), '%>');
                        return result.join('');
                    } else {
                        return '<%' + part + '%>';
                    }
                });
            }
        })
    });
    EJS.Helpers = function (data, extras) {
        this._data = data;
        this._extras = extras;
        extend(this, extras);
    };
    EJS.Helpers.prototype = {
        list: function (list, cb) {
            if (types.isListLike(list)) {
                observationReader.get(list, 'length');
            }
            each(list, function (item, i) {
                cb(item, i, list);
            });
        },
        each: function (list, cb) {
            if (Array.isArray(list)) {
                this.list(list, cb);
            } else {
                legacyHelpers.view.lists(list, cb);
            }
        }
    };
    var templates = {};
    EJS.from = function (id) {
        if (!templates[id]) {
            var el = DOCUMENT().getElementById(id);
            templates[id] = EJS(el.innerHTML);
        }
        return templates[id];
    };
    module.exports = EJS;
});
/*can-ejs@3.0.4#test/can-ejs_test*/
define('can-ejs@3.0.4#test/can-ejs_test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var EJS = require('can-ejs');
    var CanMap = require('can-map');
    var legacyHelpers = require('can-legacy-view-helpers');
    var domData = require('can-util/dom/data/data');
    var CanList = require('can-list');
    var canFrag = require('can-util/dom/frag/frag');
    var canCompute = require('can-compute');
    var domMutate = require('can-util/dom/mutate/mutate');
    QUnit.module('can-ejs, rendering', {
        setup: function () {
            this.animals = [
                'sloth',
                'bear',
                'monkey'
            ];
            if (!this.animals.each) {
                this.animals.each = function (func) {
                    for (var i = 0; i < this.length; i++) {
                        func(this[i]);
                    }
                };
            }
            this.squareBrackets = '<ul><% this.animals.each(function(animal){%>' + '<li><%= animal %></li>' + '<%});%></ul>';
            this.squareBracketsNoThis = '<ul><% animals.each(function(animal){%>' + '<li><%= animal %></li>' + '<%});%></ul>';
            this.angleBracketsNoThis = '<ul><% animals.each(function(animal){%>' + '<li><%= animal %></li>' + '<%});%></ul>';
        }
    });
    var getAttr = function (el, attrName) {
        return attrName === 'class' ? el.className : el.getAttribute(attrName);
    };
    test('render with left bracket', function () {
        var compiled = new EJS({
            text: this.squareBrackets,
            type: '['
        }).render({ animals: this.animals });
        equal(compiled, '<ul><li>sloth</li><li>bear</li><li>monkey</li></ul>', 'renders with bracket');
    });
    test('render with with', function () {
        var compiled = new EJS({
            text: this.squareBracketsNoThis,
            type: '['
        }).render({ animals: this.animals });
        equal(compiled, '<ul><li>sloth</li><li>bear</li><li>monkey</li></ul>', 'renders bracket with no this');
    });
    test('default carrot', function () {
        var compiled = new EJS({ text: this.angleBracketsNoThis }).render({ animals: this.animals });
        equal(compiled, '<ul><li>sloth</li><li>bear</li><li>monkey</li></ul>');
    });
    test('render with double angle', function () {
        var text = '<%% replace_me %>' + '<ul><% animals.each(function(animal){%>' + '<li><%= animal %></li>' + '<%});%></ul>';
        var compiled = new EJS({ text: text }).render({ animals: this.animals });
        equal(compiled, '<% replace_me %><ul><li>sloth</li><li>bear</li><li>monkey</li></ul>', 'works');
    });
    test('comments', function () {
        var text = '<%# replace_me %>' + '<ul><% animals.each(function(animal){%>' + '<li><%= animal %></li>' + '<%});%></ul>';
        var compiled = new EJS({ text: text }).render({ animals: this.animals });
        equal(compiled, '<ul><li>sloth</li><li>bear</li><li>monkey</li></ul>');
    });
    test('multi line', function () {
        var text = 'a \n b \n c', result = new EJS({ text: text }).render({});
        equal(result, text);
    });
    test('multi line elements', function () {
        var text = '<img\n class="<%=myClass%>" />', result = new EJS({ text: text }).render({ myClass: 'a' });
        ok(result.indexOf('<img\n class="a"') !== -1, 'Multi-line elements render correctly.');
        legacyHelpers.view.hookups = {};
    });
    test('escapedContent', function () {
        var text = '<span><%= tags %></span><label>&amp;</label><strong><%= number %></strong><input value=\'<%= quotes %>\'/>';
        var compiled = new EJS({ text: text }).render({
            tags: 'foo < bar < car > zar > poo',
            quotes: 'I use \'quote\' fingers "a lot"',
            number: 123
        });
        var div = document.createElement('div');
        div.innerHTML = compiled;
        equal(div.getElementsByTagName('span')[0].firstChild.nodeValue, 'foo < bar < car > zar > poo');
        equal(div.getElementsByTagName('strong')[0].firstChild.nodeValue, 123);
        equal(div.getElementsByTagName('input')[0].value, 'I use \'quote\' fingers "a lot"');
        equal(div.getElementsByTagName('label')[0].innerHTML, '&amp;');
        legacyHelpers.view.hookups = {};
    });
    test('unescapedContent', function () {
        var text = '<span><%== tags %></span><div><%= tags %></div><input value=\'<%== quotes %>\'/>';
        var compiled = new EJS({ text: text }).render({
            tags: '<strong>foo</strong><strong>bar</strong>',
            quotes: 'I use \'quote\' fingers "a lot"'
        });
        var div = document.createElement('div');
        div.innerHTML = compiled;
        equal(div.getElementsByTagName('span')[0].firstChild.nodeType, 1);
        equal(div.getElementsByTagName('div')[0].firstChild.nodeValue.toLowerCase(), '<strong>foo</strong><strong>bar</strong>');
        equal(div.getElementsByTagName('span')[0].innerHTML.toLowerCase(), '<strong>foo</strong><strong>bar</strong>');
        equal(div.getElementsByTagName('input')[0].value, 'I use \'quote\' fingers "a lot"', 'escapped no matter what');
        legacyHelpers.view.hookups = {};
    });
    test('returning blocks', function () {
        var somethingHelper = function (cb) {
            return cb([
                1,
                2,
                3,
                4
            ]);
        };
        var template = '<%# Test Something Produces Items%>' + '<%== something(function(items){ %>' + ' <%== items.length%> ' + '<% items.map( function(){ %><%# Test Something Produces Items%>' + '<%==  something(function(items){ %>ItemsLength<%== items.length %><% }) %>' + '<% }) %>' + '<% }) %>' + '<% for( var i =0; i < items.length; i++) { %>for <%= items[i] %><% } %>';
        var temp = new EJS(template);
        var res = temp.render({
            something: somethingHelper,
            items: [
                'a',
                'b'
            ]
        });
        ok(/\s4\s/.test(res), 'first block called');
        equal(res.match(/ItemsLength4/g).length, 4, 'innerBlock and each');
    });
    test('easy hookup', function () {
        var div = document.createElement('div');
        var templateStr = '<div <%= (el)-> el.className = text %>>';
        var template = EJS(templateStr);
        var res = template({ text: 'yes' });
        div.appendChild(res);
        ok(div.getElementsByTagName('div')[0].className.indexOf('yes') !== -1, 'has yes');
    });
    test('multiple function hookups in a tag', function () {
        var text = '<span <%= (el)-> domData.set.call(el,\'foo\',\'bar\') %>' + ' <%= (el)-> domData.set.call(el,\'baz\',\'qux\') %>>lorem ipsum</span>', compiled = new EJS({ text: text }).render({ domData: domData }), div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(compiled));
        var span = div.getElementsByTagName('span')[0];
        equal(domData.get.call(span, 'foo'), 'bar', 'first hookup');
        equal(domData.get.call(span, 'baz'), 'qux', 'second hookup');
    });
    test('helpers', function () {
        EJS.Helpers.prototype.simpleHelper = function () {
            return 'Simple';
        };
        EJS.Helpers.prototype.elementHelper = function () {
            return function (el) {
                el.innerHTML = 'Simple';
            };
        };
        var text = '<div><%= simpleHelper() %></div>';
        var compiled = new EJS({ text: text }).render();
        equal(compiled, '<div>Simple</div>');
        text = '<div id="hookup" <%= elementHelper() %>></div>';
        compiled = new EJS({ text: text }).render();
        var qF = document.getElementById('qunit-fixture');
        qF.appendChild(legacyHelpers.view.frag(compiled));
        var hookup = document.getElementById('hookup');
        equal(hookup.innerHTML, 'Simple');
    });
    test('list helper', function () {
        var text = '<% list(todos, function(todo){ %><div><%= todo.name %></div><% }) %>';
        var todos = new CanList([{
                    id: 1,
                    name: 'Dishes'
                }]), compiled = new EJS({ text: text }).render({ todos: todos }), div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(compiled));
        equal(div.getElementsByTagName('div').length, 1, '1 item in list');
        todos.push({
            id: 2,
            name: 'Laundry'
        });
        equal(div.getElementsByTagName('div').length, 2, '2 items in list');
        todos.splice(0, 2);
        equal(div.getElementsByTagName('div').length, 0, '0 items in list');
        todos.push({
            id: 4,
            name: 'Pick up sticks'
        });
        equal(div.getElementsByTagName('div').length, 1, '1 item in list again');
    });
    test('attribute single unescaped, html single unescaped', function () {
        var text = '<div id=\'me\' class=\'<%== task.attr(\'completed\') ? \'complete\' : \'\'%>\'><%== task.attr(\'name\') %></div>';
        var task = new CanMap({ name: 'dishes' });
        var compiled = new EJS({ text: text }).render({ task: task });
        var div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(compiled));
        equal(div.getElementsByTagName('div')[0].innerHTML, 'dishes', 'html correctly dishes');
        equal(div.getElementsByTagName('div')[0].className, '', 'class empty');
        task.attr('name', 'lawn');
        equal(div.getElementsByTagName('div')[0].innerHTML, 'lawn', 'html correctly lawn');
        equal(div.getElementsByTagName('div')[0].className, '', 'class empty');
        task.attr('completed', true);
        equal(div.getElementsByTagName('div')[0].className, 'complete', 'class changed to complete');
    });
    test('select live binding', function () {
        var text = '<select><% todos.each(function(todo){ %><option><%= todo.name %></option><% }) %></select>', Todos = new CanList([{
                    id: 1,
                    name: 'Dishes'
                }]), compiled = new EJS({ text: text }).render({ todos: Todos }), div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(compiled));
        equal(div.getElementsByTagName('option').length, 1, '1 item in list');
        Todos.push({
            id: 2,
            name: 'Laundry'
        });
        equal(div.getElementsByTagName('option').length, 2, '2 items in list');
        Todos.splice(0, 2);
        equal(div.getElementsByTagName('option').length, 0, '0 items in list');
    });
    test('block live binding', function () {
        var text = '<div><% if( obs.attr(\'sex\') == \'male\' ){ %>' + '<span>Mr.</span>' + '<% } else { %>' + '<label>Ms.</label>' + '<% } %>' + '</div>';
        var obs = new CanMap({ sex: 'male' });
        var compiled = new EJS({ text: text }).render({ obs: obs });
        var div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(compiled));
        equal(div.getElementsByTagName('div')[0].firstChild.nodeName.toUpperCase(), 'SPAN', 'initial span tag');
        equal(div.getElementsByTagName('div')[0].firstChild.innerHTML, 'Mr.', 'initial span content');
        obs.attr('sex', 'female');
        equal(div.getElementsByTagName('div')[0].firstChild.nodeName.toUpperCase(), 'LABEL', 'updated label tag');
        equal(div.getElementsByTagName('div')[0].firstChild.innerHTML, 'Ms.', 'updated label content');
    });
    test('hookups in tables', function () {
        var text = '<table><tbody><% if( obs.attr(\'sex\') == \'male\' ){ %>' + '<tr><td>Mr.</td></tr>' + '<% } else { %>' + '<tr><td>Ms.</td></tr>' + '<% } %>' + '</tbody></table>';
        var obs = new CanMap({ sex: 'male' });
        var compiled = new EJS({ text: text }).render({ obs: obs });
        var div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(compiled));
        equal(div.getElementsByTagName('tbody')[0].firstChild.firstChild.nodeName, 'TD', 'initial tag');
        equal(div.getElementsByTagName('tbody')[0].firstChild.firstChild.innerHTML.replace(/(\r|\n)+/g, ''), 'Mr.', 'initial content');
        obs.attr('sex', 'female');
        equal(div.getElementsByTagName('tbody')[0].firstChild.firstChild.nodeName, 'TD', 'updated tag');
        equal(div.getElementsByTagName('tbody')[0].firstChild.firstChild.innerHTML.replace(/(\r|\n)+/g, ''), 'Ms.', 'updated content');
    });
    test('multiple tbodies in table hookup', function () {
        var text = '<table>' + '<% list(people, function(person){ %>' + '<tbody><tr><td><%= person.name %></td></tr></tbody>' + '<% }) %>' + '</table>', people = new CanList([
                { name: 'Steve' },
                { name: 'Doug' }
            ]), compiled = new EJS({ text: text }).render({ people: people }), div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(compiled));
        equal(div.getElementsByTagName('tbody').length, 2, 'two tbodies');
    });
    test('multiple hookups in a single attribute', function () {
        var text = '<div class=\'<%= obs.attr("foo") %>a<%= obs.attr("bar") %>b<%= obs.attr("baz") %>\'></div>', obs = new CanMap({
                foo: '1',
                bar: '2',
                baz: '3'
            }), compiled = new EJS({ text: text }).render({ obs: obs });
        var div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(compiled));
        var innerDiv = div.childNodes[0];
        equal(getAttr(innerDiv, 'class'), '1a2b3', 'initial render');
        obs.attr('bar', '4');
        equal(getAttr(innerDiv, 'class'), '1a4b3', 'initial render');
        obs.attr('bar', '5');
        equal(getAttr(innerDiv, 'class'), '1a5b3', 'initial render');
    });
    test('adding and removing multiple html content within a single element', function () {
        var text = '<div><%== obs.attr("a") %><%== obs.attr("b") %><%== obs.attr("c") %></div>', obs = new CanMap({
                a: 'a',
                b: 'b',
                c: 'c'
            }), compiled = new EJS({ text: text }).render({ obs: obs });
        var div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(compiled));
        equal(div.firstChild.nodeName.toUpperCase(), 'DIV', 'initial render node name');
        equal(div.firstChild.innerHTML, 'abc', 'initial render text');
        obs.attr({
            a: '',
            b: '',
            c: ''
        });
        equal(div.firstChild.nodeName.toUpperCase(), 'DIV', 'updated render node name');
        equal(div.firstChild.innerHTML, '', 'updated render text');
        obs.attr({ c: 'c' });
        equal(div.firstChild.nodeName.toUpperCase(), 'DIV', 'updated render node name');
        equal(div.firstChild.innerHTML, 'c', 'updated render text');
    });
    test('live binding and removeAttr', function () {
        var text = '<% if(obs.attr("show")) { %>' + '<p <%== obs.attr("attributes") %> class="<%= obs.attr("className")%>"><span><%= obs.attr("message") %></span></p>' + '<% } %>', obs = new CanMap({
                show: true,
                className: 'myMessage',
                attributes: 'some="myText"',
                message: 'Live long and prosper'
            }), compiled = new EJS({ text: text }).render({ obs: obs }), div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(compiled));
        var p = div.getElementsByTagName('p')[0], span = p.getElementsByTagName('span')[0];
        equal(p.getAttribute('some'), 'myText', 'initial render attr');
        equal(getAttr(p, 'class'), 'myMessage', 'initial render class');
        equal(span.innerHTML, 'Live long and prosper', 'initial render innerHTML');
        obs.removeAttr('className');
        equal(getAttr(p, 'class'), '', 'class is undefined');
        obs.attr('className', 'newClass');
        equal(getAttr(p, 'class'), 'newClass', 'class updated');
        obs.removeAttr('attributes');
        equal(p.getAttribute('some'), null, 'attribute is undefined');
        obs.attr('attributes', 'some="newText"');
        equal(p.getAttribute('some'), 'newText', 'attribute updated');
        obs.removeAttr('message');
        equal(span.innerHTML, '', 'text node value is empty');
        obs.attr('message', 'Warp drive, Mr. Sulu');
        equal(span.innerHTML, 'Warp drive, Mr. Sulu', 'text node updated');
        obs.removeAttr('show');
        equal(div.innerHTML, '', 'value in block statement is undefined');
        obs.attr('show', true);
        p = div.getElementsByTagName('p')[0];
        span = p.getElementsByTagName('span')[0];
        equal(p.getAttribute('some'), 'newText', 'value in block statement updated attr');
        equal(getAttr(p, 'class'), 'newClass', 'value in block statement updated class');
        equal(span.innerHTML, 'Warp drive, Mr. Sulu', 'value in block statement updated innerHTML');
    });
    test('hookup within a tag', function () {
        var text = '<div <%== obs.attr("foo") %> ' + '<%== obs.attr("baz") %>>lorem ipsum</div>', obs = new CanMap({
                foo: 'class="a"',
                baz: 'some=\'property\''
            }), compiled = new EJS({ text: text }).render({ obs: obs });
        var div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(compiled));
        var anchor = div.getElementsByTagName('div')[0];
        equal(getAttr(anchor, 'class'), 'a');
        equal(anchor.getAttribute('some'), 'property');
        obs.attr('foo', 'class="b"');
        equal(getAttr(anchor, 'class'), 'b');
        equal(anchor.getAttribute('some'), 'property');
        obs.attr('baz', 'some=\'new property\'');
        equal(getAttr(anchor, 'class'), 'b');
        equal(anchor.getAttribute('some'), 'new property');
        obs.attr('foo', 'class=""');
        obs.attr('baz', '');
        equal(getAttr(anchor, 'class'), '', 'anchor class blank');
        equal(anchor.getAttribute('some'), undefined, 'attribute "some" is undefined');
    });
    test('single escaped tag, removeAttr', function () {
        var text = '<div <%= obs.attr("foo") %>>lorem ipsum</div>', obs = new CanMap({ foo: 'data-bar="john doe\'s bar"' }), compiled = new EJS({ text: text }).render({ obs: obs });
        var div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(compiled));
        var anchor = div.getElementsByTagName('div')[0];
        equal(anchor.getAttribute('data-bar'), 'john doe\'s bar');
        obs.removeAttr('foo');
        equal(anchor.getAttribute('data-bar'), null);
        obs.attr('foo', 'data-bar="baz"');
        equal(anchor.getAttribute('data-bar'), 'baz');
    });
    test('html comments', function () {
        var text = '<!-- bind to changes in the todo list --> <div><%= obs.attr("foo") %></div>', obs = new CanMap({ foo: 'foo' }), compiled = new EJS({ text: text }).render({ obs: obs });
        var div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(compiled));
        equal(div.getElementsByTagName('div')[0].innerHTML, 'foo', 'Element as expected');
    });
    test('hookup and live binding', function () {
        var text = '<div class=\'<%= task.attr(\'completed\') ? \'complete\' : \'\' %>\' <%= (el)-> domData.set.call(el,\'task\',task) %>>' + '<%== task.attr(\'name\') %>' + '</div>', task = new CanMap({
                completed: false,
                className: 'someTask',
                name: 'My Name'
            }), compiled = new EJS({ text: text }).render({
                task: task,
                domData: domData
            }), div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(compiled));
        var child = div.getElementsByTagName('div')[0];
        ok(child.className.indexOf('complete') === -1, 'is incomplete');
        ok(!!domData.get.call(child, 'task'), 'has data');
        equal(child.innerHTML, 'My Name', 'has name');
        task.attr({
            completed: true,
            name: 'New Name'
        });
        ok(child.className.indexOf('complete') !== -1, 'is complete');
        equal(child.innerHTML, 'New Name', 'has new name');
    });
    test('unescape bindings change', function () {
        var l = new CanList([
            { complete: true },
            { complete: false },
            { complete: true }
        ]);
        var completed = function () {
            l.attr('length');
            var num = 0;
            l.each(function (item) {
                if (item.attr('complete')) {
                    num++;
                }
            });
            return num;
        };
        var text = '<div><%== completed() %></div>', compiled = new EJS({ text: text }).render({ completed: completed });
        var div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(compiled));
        var child = div.getElementsByTagName('div')[0];
        equal(child.innerHTML, '2', 'at first there are 2 true bindings');
        var item = new CanMap({
            complete: true,
            id: 'THIS ONE'
        });
        l.push(item);
        equal(child.innerHTML, '3', 'now there are 3 complete');
        item.attr('complete', false);
        equal(child.innerHTML, '2', 'now there are 2 complete');
        l.pop();
        item.attr('complete', true);
        equal(child.innerHTML, '2', 'there are still 2 complete');
    });
    test('escape bindings change', function () {
        var l = new CanList([
            { complete: true },
            { complete: false },
            { complete: true }
        ]);
        var completed = function () {
            l.attr('length');
            var num = 0;
            l.each(function (item) {
                if (item.attr('complete')) {
                    num++;
                }
            });
            return num;
        };
        var text = '<div><%= completed() %></div>', compiled = new EJS({ text: text }).render({ completed: completed });
        var div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(compiled));
        var child = div.getElementsByTagName('div')[0];
        equal(child.innerHTML, '2', 'at first there are 2 true bindings');
        var item = new CanMap({ complete: true });
        l.push(item);
        equal(child.innerHTML, '3', 'now there are 3 complete');
        item.attr('complete', false);
        equal(child.innerHTML, '2', 'now there are 2 complete');
    });
    test('tag bindings change', function () {
        var l = new CanList([
            { complete: true },
            { complete: false },
            { complete: true }
        ]);
        var completed = function () {
            l.attr('length');
            var num = 0;
            l.each(function (item) {
                if (item.attr('complete')) {
                    num++;
                }
            });
            return 'items=\'' + num + '\'';
        };
        var text = '<div <%= completed() %>></div>', compiled = new EJS({ text: text }).render({ completed: completed });
        var div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(compiled));
        var child = div.getElementsByTagName('div')[0];
        equal(child.getAttribute('items'), '2', 'at first there are 2 true bindings');
        var item = new CanMap({ complete: true });
        l.push(item);
        equal(child.getAttribute('items'), '3', 'now there are 3 complete');
        item.attr('complete', false);
        equal(child.getAttribute('items'), '2', 'now there are 2 complete');
    });
    test('attribute value bindings change', function () {
        var l = new CanList([
            { complete: true },
            { complete: false },
            { complete: true }
        ]);
        var completed = function () {
            l.attr('length');
            var num = 0;
            l.each(function (item) {
                if (item.attr('complete')) {
                    num++;
                }
            });
            return num;
        };
        var text = '<div items="<%= completed() %>"></div>', compiled = new EJS({ text: text }).render({ completed: completed });
        var div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(compiled));
        var child = div.getElementsByTagName('div')[0];
        equal(child.getAttribute('items'), '2', 'at first there are 2 true bindings');
        var item = new CanMap({ complete: true });
        l.push(item);
        equal(child.getAttribute('items'), '3', 'now there are 3 complete');
        item.attr('complete', false);
        equal(child.getAttribute('items'), '2', 'now there are 2 complete');
    });
    test('in tag toggling', function () {
        var text = '<div <%== obs.attr(\'val\') %>></div>';
        var obs = new CanMap({ val: 'foo="bar"' });
        var compiled = new EJS({ text: text }).render({ obs: obs });
        var div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(compiled));
        obs.attr('val', 'bar=\'foo\'');
        obs.attr('val', 'foo="bar"');
        var d2 = div.getElementsByTagName('div')[0];
        equal(d2.getAttribute('foo'), 'bar', 'bar set');
        equal(d2.getAttribute('bar'), null, 'bar set');
    });
    test('parent is right with bock', function () {
        var text = '<ul><% if(!obs.attr("items").length) { %>' + '<li>No items</li>' + '<% } else { %> <%== obs.attr("content") %>' + '<% } %></ul>', obs = new CanMap({
                content: '<li>Hello</li>',
                items: [{ name: 'Justin' }]
            }), compiled = new EJS({ text: text }).render({ obs: obs });
        var div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(compiled));
        var ul = div.getElementsByTagName('ul')[0];
        var li = div.getElementsByTagName('li')[0];
        ok(ul, 'we have a ul');
        ok(li, 'we have a li');
    });
    test('nested properties', function () {
        var text = '<div><%= obs.attr(\'name.first\')%></div>';
        var obs = new CanMap({ name: { first: 'Justin' } });
        var compiled = new EJS({ text: text }).render({ obs: obs });
        var div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(compiled));
        div = div.getElementsByTagName('div')[0];
        equal(div.innerHTML, 'Justin');
        obs.attr('name.first', 'Brian');
        equal(div.innerHTML, 'Brian');
    });
    test('tags without chidren or ending with /> do not change the state', function () {
        var text = '<table><tr><td></td><%== obs.attr(\'content\') %></tr></div>';
        var obs = new CanMap({ content: '<td>Justin</td>' });
        var compiled = new EJS({ text: text }).render({ obs: obs });
        var div = document.createElement('div');
        var html = legacyHelpers.view.frag(compiled);
        div.appendChild(html);
        equal(div.getElementsByTagName('span').length, 0, 'there are no spans');
        equal(div.getElementsByTagName('td').length, 2, 'there are 2 td');
    });
    test('trailing text', function () {
        var template = EJS('There are <%= this.attr(\'length\') %> todos');
        var div = document.createElement('div');
        div.appendChild(template(new CanList([
            {},
            {}
        ])));
        ok(/There are 2 todos/.test(div.innerHTML), 'got all text');
    });
    test('live binding select', function () {
        var text = '<select><% items.each(function(ob) { %>' + '<option value=\'<%= ob.attr(\'id\') %>\'><%= ob.attr(\'title\') %></option>' + '<% }); %></select>', items = new CanList([
                {
                    title: 'Make bugs',
                    is_done: true,
                    id: 0
                },
                {
                    title: 'Find bugs',
                    is_done: false,
                    id: 1
                },
                {
                    title: 'Fix bugs',
                    is_done: false,
                    id: 2
                }
            ]), compiled = new EJS({ text: text }).render({ items: items }), div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(compiled));
        equal(div.getElementsByTagName('option').length, 3, '3 items in list');
        var option = div.getElementsByTagName('option')[0];
        equal(option.value, '' + items[0].id, 'value attr set');
        equal(option.textContent || option.text, items[0].title, 'content of option');
        items.push({
            id: 3,
            name: 'Go to pub'
        });
        equal(div.getElementsByTagName('option').length, 4, '4 items in list');
    });
    test('live binding textarea', function () {
        var template = EJS('<textarea>Before<%= obs.attr(\'middle\') %>After</textarea>');
        var obs = new CanMap({ middle: 'yes' }), div = document.createElement('div');
        var node = template({ obs: obs });
        div.appendChild(node);
        var textarea = div.firstChild;
        equal(textarea.value, 'BeforeyesAfter');
        obs.attr('middle', 'Middle');
        equal(textarea.value, 'BeforeMiddleAfter');
    });
    test('reset on a live bound input', function () {
        var text = '<input type=\'text\' value=\'<%= person.attr(\'name\') %>\'><button type=\'reset\'>Reset</button>', person = new CanMap({ name: 'Bob' }), compiled = new EJS({ text: text }).render({ person: person }), form = document.createElement('form'), input;
        form.appendChild(legacyHelpers.view.frag(compiled));
        input = form.getElementsByTagName('input')[0];
        form.reset();
        equal(input.value, 'Bob', 'value is correct');
    });
    test('attribute unquoting', function () {
        var text = '<input type="radio" ' + '<%== facet.single ? \'name="facet-\' + facet.attr("id") + \'"\' : "" %> ' + 'value="<%= facet.single ? "facet-" + facet.attr("id") : "" %>" />', facet = new CanMap({
                id: 1,
                single: true
            }), compiled = new EJS({ text: text }).render({ facet: facet }), div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(compiled));
        equal(div.children[0].name, 'facet-1');
        equal(div.children[0].value, 'facet-1');
    });
    test('empty element hooks work correctly', function () {
        var text = '<div <%= function(e){ e.innerHTML = "1 Will show"; } %>></div>' + '<div <%= function(e){ e.innerHTML = "2 Will not show"; } %>></div>' + '3 Will not show';
        var compiled = new EJS({ text: text }).render(), div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(compiled));
        equal(div.childNodes.length, 3, 'all three elements present');
    });
    test('live binding with parent dependent tags but without parent tag present in template', function () {
        var text = [
            '<tbody>',
            '<% if( person.attr("first") ){ %>',
            '<tr><td><%= person.first %></td></tr>',
            '<% }%>',
            '<% if( person.attr("last") ){ %>',
            '<tr><td><%= person.last %></td></tr>',
            '<% } %>',
            '</tbody>'
        ];
        var person = new CanMap({
            first: 'Austin',
            last: 'McDaniel'
        });
        var compiled = new EJS({ text: text.join('\n') }).render({ person: person });
        var table = document.createElement('table');
        table.appendChild(legacyHelpers.view.frag(compiled));
        equal(table.getElementsByTagName('tr')[0].firstChild.nodeName.toUpperCase(), 'TD');
        equal(table.getElementsByTagName('tr')[0].firstChild.innerHTML, 'Austin');
        equal(table.getElementsByTagName('tr')[1].firstChild.nodeName.toUpperCase(), 'TD');
        equal(table.getElementsByTagName('tr')[1].firstChild.innerHTML, 'McDaniel');
        person.removeAttr('first');
        equal(table.getElementsByTagName('tr')[0].firstChild.nodeName.toUpperCase(), 'TD');
        equal(table.getElementsByTagName('tr')[0].firstChild.innerHTML, 'McDaniel');
        person.removeAttr('last');
        equal(table.getElementsByTagName('tr').length, 0);
        person.attr('first', 'Justin');
        equal(table.getElementsByTagName('tr')[0].firstChild.nodeName.toUpperCase(), 'TD');
        equal(table.getElementsByTagName('tr')[0].firstChild.innerHTML, 'Justin');
    });
    test('spaces between attribute name and value', function () {
        var text = '<input type="text" value = "<%= test %>" />', compiled = new EJS({ text: text }).render({ test: 'testing' }), div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(compiled));
        var input = div.getElementsByTagName('input')[0];
        equal(input.value, 'testing');
        equal(input.type, 'text');
    });
    test('live binding with computes', function () {
        var text = '<span><%= compute() %></span>', compute = canCompute(5), compiled = new EJS({ text: text }).render({ compute: compute }), div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(compiled));
        var span = div.getElementsByTagName('span');
        equal(span.length, 1);
        span = span[0];
        equal(span.innerHTML, '5');
        compute(6);
        equal(span.innerHTML, '6');
        compute('Justin');
        equal(span.innerHTML, 'Justin');
        compute(true);
        equal(span.innerHTML, 'true');
    });
    test('testing for clean tables', function () {
        var templateStr = '<table cellpadding="0" cellspacing="0" border="0" class="display">' + '<thead>' + '<tr>' + '<th> Game Name </th>' + '<th> Rating </th>' + '</tr>' + '</thead>' + '<tbody>' + '<% games.each( function(game) { %>' + '<tr class="game">' + '<td> <%= game.attr(\'name\') %></td>' + '<td> <%= game.attr(\'rating\') %></td>' + '</tr>' + '<% }) %>' + '<% games.each( function(game) { %>' + '<tr class="game">' + '<td> <%= game.attr(\'name\') %></td>' + '<td> <%= game.attr(\'rating\') %></td>' + '</tr>' + '<% }) %>' + '</tbody>' + '</table>';
        var template = EJS(templateStr);
        var games = new CanList();
        games.push({
            name: 'The Legend of Zelda',
            rating: 10
        });
        games.push({
            name: 'The Adventures of Link',
            rating: 9
        });
        games.push({
            name: 'Dragon Warrior',
            rating: 9
        });
        games.push({
            name: 'A Dude Named Daffl',
            rating: 8.5
        });
        var res = template({ games: games }), div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(res));
        ok(!/@@!!@@/.test(div.innerHTML), 'no placeholders');
    });
    test('Observe with array attributes', function () {
        var template = EJS('<ul><% list(todos, function(todo, i) { %><li><%= todos.attr(""+i) %></li><% }) %></ul><div><%= this.attr("message") %></div>');
        var div = document.createElement('div');
        var data = new CanMap({
            todos: [
                'Line #1',
                'Line #2',
                'Line #3'
            ],
            message: 'Hello',
            count: 2
        });
        div.appendChild(template(data));
        equal(div.getElementsByTagName('li')[1].innerHTML, 'Line #2', 'Check initial array');
        equal(div.getElementsByTagName('div')[0].innerHTML, 'Hello', 'Check initial message');
        data.attr('todos.1', 'Line #2 changed');
        data.attr('message', 'Hello again');
        equal(div.getElementsByTagName('li')[1].innerHTML, 'Line #2 changed', 'Check updated array');
        equal(div.getElementsByTagName('div')[0].innerHTML, 'Hello again', 'Check updated message');
    });
    test('hookup this correctly', function () {
        var obj = { from: 'cows' };
        var html = '<span <%== (el) -> domData.set.call(el, \'foo\', this.from) %>>tea</span>';
        var compiled = new EJS({ text: html }).render(obj, { domData: domData });
        var div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(compiled));
        var span = div.getElementsByTagName('span')[0];
        equal(domData.get.call(span, 'foo'), obj.from, 'object matches');
    });
    test('live binding with html comment', function () {
        var text = '<table><tr><th>Todo</th></tr><!-- do not bother with me -->' + '<% todos.each(function(todo){ %><tr><td><%= todo.name %></td></tr><% }) %></table>', Todos = new CanList([{
                    id: 1,
                    name: 'Dishes'
                }]), compiled = new EJS({ text: text }).render({ todos: Todos }), div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(compiled));
        equal(div.getElementsByTagName('table')[0].getElementsByTagName('td').length, 1, '1 item in list');
        Todos.push({
            id: 2,
            name: 'Laundry'
        });
        equal(div.getElementsByTagName('table')[0].getElementsByTagName('td').length, 2, '2 items in list');
        Todos.splice(0, 2);
        equal(div.getElementsByTagName('table')[0].getElementsByTagName('td').length, 0, '0 items in list');
    });
    test('HTML comment with element callback', function () {
        var text = [
                '<ul>',
                '<% todos.each(function(todo) { %>',
                '<li<%= (el) -> domData.set.call(el,\'todo\',todo) %>>',
                '<!-- html comment #1 -->',
                '<%= todo.name %>',
                '<!-- html comment #2 -->',
                '</li>',
                '<% }) %>',
                '</ul>'
            ], Todos = new CanList([{
                    id: 1,
                    name: 'Dishes'
                }]), compiled = new EJS({ text: text.join('\n') }).render({
                todos: Todos,
                domData: domData
            }), div = document.createElement('div'), li, comments;
        comments = function (el) {
            var count = 0;
            for (var i = 0; i < el.childNodes.length; i++) {
                if (el.childNodes[i].nodeType === 8) {
                    ++count;
                }
            }
            return count;
        };
        div.appendChild(legacyHelpers.view.frag(compiled));
        li = div.getElementsByTagName('ul')[0].getElementsByTagName('li');
        equal(li.length, 1, '1 item in list');
        equal(comments(li[0]), 2, '2 comments in item #1');
        Todos.push({
            id: 2,
            name: 'Laundry'
        });
        equal(li.length, 2, '2 items in list');
        equal(comments(li[0]), 2, '2 comments in item #1');
        equal(comments(li[1]), 2, '2 comments in item #2');
        Todos.splice(0, 2);
        equal(li.length, 0, '0 items in list');
    });
    test('correctness of data-view-id and only in tag opening', function () {
        var text = [
                '<textarea><select><% list(this.items, function(item) { %>',
                '<option<%= (el) -> el.data(\'item\', item) %>><%= item.title %></option>',
                '<% }) %></select></textarea>'
            ], items = [
                {
                    id: 1,
                    title: 'One'
                },
                {
                    id: 2,
                    title: 'Two'
                }
            ], compiled = new EJS({ text: text.join('') }).render({ items: items }), expected = '^<textarea data-view-id=\'[0-9]+\'><select><option data-view-id=\'[0-9]+\'>One</option>' + '<option data-view-id=\'[0-9]+\'>Two</option></select></textarea>$';
        ok(compiled.search(expected) === 0, 'Rendered output is as expected');
        legacyHelpers.view.hookups = {};
    });
    test('return blocks within element tags', function () {
        var animals = new CanList([
                'sloth',
                'bear'
            ]), template = '<ul>' + '<%==lister(animals, function(animal){%>' + '<li><%=animal %></li>' + '<%})%>' + '</ul>';
        var renderer = EJS(template);
        var div = document.createElement('div');
        var frag = renderer({
            lister: function () {
                return function (el) {
                    equal(el.nodeName.toLowerCase(), 'li', 'got the LI it created');
                };
            },
            animals: animals
        });
        div.appendChild(frag);
    });
    test('Each does not redraw items', function () {
        var animals = new CanList([
                'sloth',
                'bear'
            ]), template = '<div>my<b>favorite</b>animals:' + '<%==each(animals, function(animal){%>' + '<label>Animal=</label> <span><%=animal %></span>' + '<%})%>' + '!</div>';
        var renderer = EJS(template);
        var div = document.createElement('div');
        var frag = renderer({ animals: animals });
        div.appendChild(frag);
        div.getElementsByTagName('label')[0].myexpando = 'EXPANDO-ED';
        equal(div.getElementsByTagName('label').length, 2, 'There are 2 labels');
        animals.push('turtle');
        equal(div.getElementsByTagName('label')[0].myexpando, 'EXPANDO-ED', 'same expando');
        equal(div.getElementsByTagName('span')[2].innerHTML, 'turtle', 'turtle added');
    });
    test('Each works with no elements', function () {
        var animals = new CanList([
                'sloth',
                'bear'
            ]), template = '<%==each(animals, function(animal){%>' + '<%=animal %> ' + '<%})%>';
        var renderer = EJS(template);
        var div = document.createElement('div');
        var frag = renderer({ animals: animals });
        div.appendChild(frag);
        animals.push('turtle');
        equal(div.innerHTML, 'sloth bear turtle ', 'turtle added');
    });
    test('Each does not redraw items (normal array)', function () {
        var animals = [
                'sloth',
                'bear',
                'turtle'
            ], template = '<div>my<b>favorite</b>animals:' + '<%each(animals, function(animal){%>' + '<label>Animal=</label> <span><%=animal %></span>' + '<%})%>' + '!</div>';
        var renderer = EJS(template);
        var div = document.createElement('div');
        var frag = renderer({ animals: animals });
        div.appendChild(frag);
        div.getElementsByTagName('label')[0].myexpando = 'EXPANDO-ED';
        equal(div.getElementsByTagName('label').length, 3, 'There are 2 labels');
        equal(div.getElementsByTagName('label')[0].myexpando, 'EXPANDO-ED', 'same expando');
        equal(div.getElementsByTagName('label')[0].myexpando, 'EXPANDO-ED', 'same expando');
        equal(div.getElementsByTagName('span')[2].innerHTML, 'turtle', 'turtle added');
    });
    test('list works within another branch', function () {
        var animals = new CanList([]), template = '<div>Animals:' + '<% if( animals.attr(\'length\') ){ %>~' + '<% animals.each(function(animal){%>' + '<span><%=animal %></span>' + '<%})%>' + '<% } else { %>' + 'No animals' + '<% } %>' + '!</div>';
        var renderer = EJS(template);
        var div = document.createElement('div');
        var frag = renderer({ animals: animals });
        div.appendChild(frag);
        equal(div.getElementsByTagName('div')[0].innerHTML, 'Animals:No animals!');
        animals.push('sloth');
        equal(div.getElementsByTagName('span').length, 1, 'There is 1 sloth');
        animals.pop();
        equal(div.getElementsByTagName('div')[0].innerHTML, 'Animals:No animals!');
    });
    test('each works within another branch', function () {
        var animals = new CanList([]), template = '<div>Animals:' + '<% if( animals.attr(\'length\') ){ %>~' + '<%==each(animals, function(animal){%>' + '<span><%=animal %></span>' + '<%})%>' + '<% } else { %>' + 'No animals' + '<% } %>' + '!</div>';
        var renderer = EJS(template);
        var div = document.createElement('div');
        var frag = renderer({ animals: animals });
        div.appendChild(frag);
        equal(div.getElementsByTagName('div')[0].innerHTML, 'Animals:No animals!');
        animals.push('sloth');
        equal(div.getElementsByTagName('span').length, 1, 'There is 1 sloth');
        animals.pop();
        equal(div.getElementsByTagName('div')[0].innerHTML, 'Animals:No animals!');
    });
    test('Access .length with nested dot notation', function () {
        var template = '<span id="nested"><%= this.attr("list.length") %></span>' + '<span id="unnested"><%= this.list.attr("length") %></span>', obj = new CanMap({
                list: [
                    0,
                    1,
                    2,
                    3
                ]
            }), renderer = EJS(template), div = document.createElement('div');
        div.appendChild(renderer(obj));
        ok(div.getElementsByTagName('span')[0].innerHTML === '4', 'Nested dot notation.');
        ok(div.getElementsByTagName('span')[1].innerHTML === '4', 'Not-nested dot notation.');
    });
    test('attributes in truthy section', function () {
        var template = EJS('<p <% if(attribute) {%>data-test="<%=attribute%>"<% } %>></p>');
        var data1 = { attribute: 'test-value' };
        var frag1 = template(data1);
        var div1 = document.createElement('div');
        div1.appendChild(frag1);
        equal(div1.children[0].getAttribute('data-test'), 'test-value', 'hyphenated attribute value');
        var data2 = { attribute: 'test value' };
        var frag2 = template(data2);
        var div2 = document.createElement('div');
        div2.appendChild(frag2);
        equal(div2.children[0].getAttribute('data-test'), 'test value', 'whitespace in attribute value');
    });
    test('outputting array of attributes', function () {
        var template = EJS('<p <% for(var i = 0; i < attribute.length; i++) { %><%=attribute[i].name%>="<%=attribute[i].value%>"<%}%>></p>');
        var data = {
            attribute: [
                {
                    'name': 'data-test1',
                    'value': 'value1'
                },
                {
                    'name': 'data-test2',
                    'value': 'value2'
                },
                {
                    'name': 'data-test3',
                    'value': 'value3'
                }
            ]
        };
        var frag = template(data);
        var div = document.createElement('div');
        div.appendChild(frag);
        equal(div.children[0].getAttribute('data-test1'), 'value1', 'first value');
        equal(div.children[0].getAttribute('data-test2'), 'value2', 'second value');
        equal(div.children[0].getAttribute('data-test3'), 'value3', 'third value');
    });
    test('_bindings removed when element removed', function () {
        var template = EJS('<div id="game"><% if(game.attr("league")) { %><%= game.attr("name") %><% } %></div>'), game = new CanMap({
                'name': 'Fantasy Baseball',
                'league': 'Malamonsters'
            });
        var frag = template({ game: game });
        var div = document.getElementById('qunit-fixture');
        div.appendChild(frag);
        domMutate.removeChild.call(div, div.firstChild);
        stop();
        setTimeout(function () {
            start();
            equal(game._bindings, 0, 'No bindings left');
        }, 50);
    });
});
/*can@3.4.1#view/ejs/ejs_test*/
define('can@3.4.1#view/ejs/ejs_test', function (require, exports, module) {
    require('can-ejs/test/can-ejs_test');
});
/*can-fixture@1.0.13#test/fixture_test*/
define('can-fixture@1.0.13#test/fixture_test', function (require, exports, module) {
    (function (__dirname) {
        var QUnit = require('steal-qunit');
        var fixture = require('can-fixture');
        var core = require('../core');
        var set = require('can-set');
        var $ = require('jquery');
        var each = require('can-util/js/each/each');
        var isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');
        var errorCallback = function (xhr, status, error) {
            ok(false, error);
            start();
        };
        var parseHeaders = function (str) {
            var lines = str.split(/\r?\n/);
            var fields = {};
            var index;
            var line;
            var field;
            var val;
            lines.pop();
            for (var i = 0, len = lines.length; i < len; ++i) {
                line = lines[i];
                index = line.indexOf(':');
                field = line.slice(0, index).toLowerCase();
                val = line.slice(index + 1).replace(/(^\s*|\s*$)/g, '');
                fields[field] = val;
            }
            return fields;
        };
        QUnit.module('can-fixture');
        if (__dirname !== '/') {
            test('static fixtures', function () {
                stop();
                fixture('GET something', __dirname + '/fixtures/test.json');
                fixture('POST something', __dirname + '/fixtures/test.json');
                fixture('PATCH something', __dirname + '/fixtures/test.json');
                $.ajax({
                    url: 'something',
                    dataType: 'json'
                }).then(function (data) {
                    equal(data.sweet, 'ness', 'can.get works');
                    $.ajax({
                        url: 'something',
                        method: 'POST',
                        dataType: 'json'
                    }).then(function (data) {
                        equal(data.sweet, 'ness', 'can.post works');
                        $.ajax({
                            url: 'something',
                            method: 'PATCH',
                            dataType: 'json'
                        }).then(function (data) {
                            equal(data.sweet, 'ness', 'can.patch works');
                            start();
                        }, errorCallback);
                    }, errorCallback);
                }, errorCallback);
            });
        }
        if (__dirname !== '/') {
            test('static fixtures (using method signature)', function () {
                stop();
                fixture({
                    method: 'get',
                    url: 'method/{id}'
                }, __dirname + '/fixtures/method.{id}.json');
                $.ajax({
                    url: 'method/4',
                    dataType: 'json'
                }).then(function (data) {
                    equal(data.id, 4, 'Got data with proper id using method');
                    start();
                }, errorCallback);
            });
        }
        if (__dirname !== '/') {
            test('static fixtures (using type signature)', function () {
                stop();
                fixture({
                    type: 'get',
                    url: 'type/{id}'
                }, __dirname + '/fixtures/type.{id}.json');
                $.ajax({
                    url: 'type/4',
                    dataType: 'json'
                }).then(function (data) {
                    equal(data.id, 4, 'Got data with proper id using type');
                    start();
                }, errorCallback);
            });
        }
        if (__dirname !== '/') {
            test('templated static fixtures', function () {
                stop();
                fixture('GET some/{id}', __dirname + '/fixtures/stuff.{id}.json');
                $.ajax({
                    url: 'some/3',
                    dataType: 'json'
                }).then(function (data) {
                    equal(data.id, 3, 'Got data with proper id');
                    start();
                }, errorCallback);
            });
        }
        test('dynamic fixtures', function () {
            stop();
            fixture.delay = 10;
            fixture('something', function () {
                return [{ sweet: 'ness' }];
            });
            $.ajax({
                url: 'something',
                dataType: 'json'
            }).done(function (data) {
                equal(data[0].sweet, 'ness', 'can.get works');
                start();
            });
        });
        if (__dirname !== '/') {
            test('fixture function', 3, function () {
                stop();
                var url = __dirname + '/fixtures/foo.json';
                fixture(url, __dirname + '/fixtures/foobar.json');
                $.ajax({
                    url: url,
                    dataType: 'json'
                }).done(function (data) {
                    equal(data.sweet, 'ner', 'url passed works');
                    fixture(url, __dirname + '/fixtures/test.json');
                    $.ajax({
                        url: url,
                        dataType: 'json'
                    }).done(function (data) {
                        equal(data.sweet, 'ness', 'replaced');
                        fixture(url, null);
                        $.ajax({
                            url: url,
                            dataType: 'json'
                        }).done(function (data) {
                            equal(data.a, 'b', 'removed');
                            start();
                        });
                    });
                });
            });
        }
        test('fixture.store fixtures', function () {
            stop();
            var store = fixture.store('thing', 1000, function (i) {
                return {
                    id: i,
                    name: 'thing ' + i
                };
            }, function (item, settings) {
                if (settings.data.searchText) {
                    var regex = new RegExp('^' + settings.data.searchText);
                    return regex.test(item.name);
                }
            });
            fixture('things', store.findAll);
            $.ajax({
                url: 'things',
                dataType: 'json',
                data: {
                    offset: 100,
                    limit: 200,
                    order: ['name ASC'],
                    searchText: 'thing 2'
                },
                success: function (things) {
                    equal(things.data[0].name, 'thing 29', 'first item is correct');
                    equal(things.data.length, 11, 'there are 11 items');
                    start();
                }
            });
        });
        test('simulating an error', function () {
            fixture('/foo', function (request, response) {
                return response(401, { type: 'unauthorized' });
            });
            stop();
            $.ajax({
                url: '/foo',
                dataType: 'json'
            }).done(function () {
                ok(false, 'success called');
                start();
            }).fail(function (original, type) {
                ok(true, 'error called');
                deepEqual(JSON.parse(original.responseText), { type: 'unauthorized' }, 'Original text passed');
                start();
            });
        });
        test('rand', function () {
            var rand = fixture.rand;
            var num = rand(3);
            equal(typeof num, 'number');
            var matched = {};
            for (var i = 0; i < 100; i++) {
                num = rand(3);
                matched[num] = true;
            }
            for (i = 0; i <= 3; i++) {
                ok(matched[i], 'has ' + i);
            }
            matched = {};
            var result, choices = [
                    'a',
                    'b',
                    'c'
                ];
            for (i = 0; i < 100; i++) {
                result = rand(choices);
                matched[result.length] = true;
                matched[result[0]] = true;
            }
            for (i = 1; i <= 3; i++) {
                ok(matched[i], 'has ' + i);
                delete matched[i];
            }
            each(choices, function (choice) {
                ok(matched[choice], 'has ' + choice);
                delete matched[choice];
            });
            ok(isEmptyObject(matched), 'nothing else unexpected');
        });
        test('core.dataFromUrl', function () {
            var data = core.dataFromUrl('/thingers/{id}', '/thingers/5');
            equal(data.id, 5, 'gets data');
            data = core.dataFromUrl('/thingers/5?hi.there', '/thingers/5?hi.there');
            deepEqual(data, {}, 'gets data');
        });
        test('core.dataFromUrl with double character value', function () {
            var data = core.dataFromUrl('/days/{id}/time_slots.json', '/days/17/time_slots.json');
            equal(data.id, 17, 'gets data');
        });
        test('core.defaultCompare', function () {
            var same = set.equal({ url: '/thingers/5' }, { url: '/thingers/{id}' }, core.defaultCompare);
            ok(same, 'they are similar');
            same = set.equal({ url: '/thingers/5' }, { url: '/thingers' }, core.defaultCompare);
            ok(!same, 'they are not the same');
        });
        test('core.matches', function () {
            var same = core.matches({ url: '/thingers/5' }, { url: '/thingers/{id}' });
            ok(same, 'similar');
            same = core.matches({
                url: '/thingers/5',
                type: 'get'
            }, { url: '/thingers/{id}' });
            ok(same, 'similar with extra pops on settings');
            var exact = core.matches({
                url: '/thingers/5',
                type: 'get'
            }, { url: '/thingers/{id}' }, true);
            ok(!exact, 'not exact');
            exact = core.matches({ url: '/thingers/5' }, { url: '/thingers/5' }, true);
            ok(exact, 'exact');
        });
        test('fixture function gets id', function () {
            fixture('/thingers/{id}', function (settings) {
                return {
                    id: settings.data.id,
                    name: 'justin'
                };
            });
            stop();
            $.ajax({
                url: '/thingers/5',
                dataType: 'json',
                data: { id: 5 }
            }).done(function (data) {
                ok(data.id);
                start();
            });
        });
        if (__dirname !== '/') {
            test('replacing and removing a fixture', function () {
                var url = __dirname + '/fixtures/remove.json';
                fixture('GET ' + url, function () {
                    return { weird: 'ness!' };
                });
                stop();
                $.ajax({
                    url: url,
                    dataType: 'json'
                }).done(function (json) {
                    equal(json.weird, 'ness!', 'fixture set right');
                    fixture('GET ' + url, function () {
                        return { weird: 'ness?' };
                    });
                    $.ajax({
                        url: url,
                        dataType: 'json'
                    }).done(function (json) {
                        equal(json.weird, 'ness?', 'fixture set right');
                        fixture('GET ' + url, null);
                        $.ajax({
                            url: url,
                            dataType: 'json'
                        }).done(function (json) {
                            equal(json.weird, 'ness', 'fixture set right');
                            start();
                        });
                    });
                });
            });
        }
        test('fixture.store with can.Model', function () {
            var store = fixture.store(100, function (i) {
                return {
                    id: i,
                    name: 'Object ' + i
                };
            });
            fixture('GET /models', store.getListData);
            fixture('GET /models/{id}', store.getData);
            fixture('POST /models', store.createData);
            fixture('PUT /models/{id}', store.updateData);
            fixture('DELETE /models/{id}', store.destroyData);
            stop();
            function errorAndStart(e) {
                ok(false, 'borked' + e);
                start();
            }
            var check100Updated = function () {
                return $.ajax({
                    url: '/models/100',
                    dataType: 'json'
                }).then(function (model) {
                    equal(model.name, 'Updated test object', 'Successfully updated object');
                });
            };
            $.ajax({
                url: '/models',
                dataType: 'json'
            }).then(function (modelsData) {
                var models = modelsData.data;
                equal(models.length, 100, 'Got 100 models for findAll with no parameters');
                equal(models[95].name, 'Object 95', 'All models generated properly');
                return $.ajax({
                    url: '/models/51',
                    dataType: 'json'
                }).then(function (data) {
                    equal(data.id, 51, 'Got correct object id');
                    equal('Object 51', data.name, 'Object name generated correctly');
                    return $.ajax({
                        url: '/models',
                        dataType: 'json',
                        type: 'post',
                        data: { name: 'My test object' }
                    }).then(function (newmodel) {
                        equal(newmodel.id, 100, 'Id got incremented');
                        return $.ajax({
                            url: '/models/100',
                            dataType: 'json'
                        }).then(function (model) {
                            equal(model.id, 100, 'Loaded new object');
                            return $.ajax({
                                url: '/models/100',
                                dataType: 'json',
                                type: 'put',
                                data: { name: 'Updated test object' }
                            }).then(function (model) {
                                return check100Updated().then(function () {
                                    return $.ajax({
                                        url: '/models/100',
                                        dataType: 'json',
                                        type: 'delete'
                                    }).then(function (deleted) {
                                        start();
                                    }, errorAndStart);
                                }, errorAndStart);
                            }, errorAndStart);
                        }, errorAndStart);
                    }, errorAndStart);
                }, errorAndStart);
            }, errorAndStart);
        });
        test('fixture.store returns 404 on findOne with bad id (#803)', function () {
            var store = fixture.store(2, function (i) {
                return {
                    id: i,
                    name: 'Object ' + i
                };
            });
            fixture('GET /models/{id}', store.findOne);
            stop();
            $.ajax({
                url: '/models/3',
                dataType: 'json'
            }).then(function () {
            }, function (data) {
                equal(data.statusText, 'error', 'statusText');
                equal(data.responseText, 'Requested resource not found', 'responseText');
                start();
            });
        });
        test('fixture.store returns 404 on update with a bad id (#803)', function () {
            var store = fixture.store(5, function (i) {
                return {
                    id: i,
                    name: 'Object ' + i
                };
            });
            stop();
            fixture('POST /models/{id}', store.update);
            $.ajax({
                url: '/models/6',
                dataType: 'json',
                data: { 'jedan': 'dva' },
                type: 'POST'
            }).then(function () {
            }, function (data) {
                equal(data.statusText, 'error', 'Got an error');
                equal(data.responseText, 'Requested resource not found', 'Got correct status message');
                start();
            });
        });
        test('fixture.store returns 404 on destroy with a bad id (#803)', function () {
            var store = fixture.store(2, function (i) {
                return {
                    id: i,
                    name: 'Object ' + i
                };
            });
            stop();
            fixture('DELETE /models/{id}', store.destroy);
            $.ajax({
                url: '/models/6',
                dataType: 'json',
                type: 'DELETE'
            }).then(function () {
            }, function (data) {
                equal(data.statusText, 'error', 'Got an error');
                equal(data.responseText, 'Requested resource not found', 'Got correct status message');
                start();
            });
        });
        test('fixture.store can use id of different type (#742)', function () {
            var store = fixture.store(100, function (i) {
                return {
                    id: i,
                    parentId: i * 2,
                    name: 'Object ' + i
                };
            });
            fixture('GET /models', store.findAll);
            stop();
            $.ajax({
                url: '/models',
                dataType: 'json',
                data: { parentId: '4' }
            }).then(function (models) {
                equal(models.data.length, 1, 'Got one model');
                deepEqual(models.data[0], {
                    id: 2,
                    parentId: 4,
                    name: 'Object 2'
                });
                start();
            });
        });
        test('fixture with response callback', 4, function () {
            fixture.delay = 10;
            fixture('responseCb', function (orig, response) {
                response({ sweet: 'ness' });
            });
            fixture('responseErrorCb', function (orig, response) {
                response(404, 'This is an error from callback');
            });
            stop();
            $.ajax({
                url: 'responseCb',
                dataType: 'json'
            }).done(function (data) {
                equal(data.sweet, 'ness', 'can.get works');
                start();
            });
            stop();
            $.ajax({
                url: 'responseErrorCb',
                dataType: 'json'
            }).fail(function (orig, error, text) {
                equal(error, 'error', 'Got error status');
                equal(orig.responseText, 'This is an error from callback', 'Got error text');
                start();
            });
            stop();
            fixture('cbWithTimeout', function (orig, response) {
                setTimeout(function () {
                    response([{ epic: 'ness' }]);
                }, 10);
            });
            $.ajax({
                url: 'cbWithTimeout',
                dataType: 'json'
            }).done(function (data) {
                equal(data[0].epic, 'ness', 'Got responsen with timeout');
                start();
            });
        });
        test('store create works with an empty array of items', function () {
            var store = fixture.store(0, function () {
                return {};
            });
            store.create({ data: {} }, function (responseData, responseHeaders) {
                equal(responseData.id, 0, 'the first id is 0');
            });
        });
        test('store creates sequential ids', function () {
            var store = fixture.store(0, function () {
                return {};
            });
            store.create({ data: {} }, function (responseData, responseHeaders) {
                equal(responseData.id, 0, 'the first id is 0');
            });
            store.create({ data: {} }, function (responseData, responseHeaders) {
                equal(responseData.id, 1, 'the second id is 1');
            });
            store.destroy({ data: { id: 0 } });
            store.create({ data: {} }, function (responseData, responseHeaders) {
                equal(responseData.id, 2, 'the third id is 2');
            });
        });
        test('fixture updates request.data with id', function () {
            expect(1);
            stop();
            fixture('foo/{id}', function (request) {
                equal(request.data.id, 5);
                start();
            });
            $.ajax({ url: 'foo/5' });
        });
        test('create a store with array and comparison object', function () {
            var store = fixture.store([
                {
                    id: 1,
                    modelId: 1,
                    year: 2013,
                    name: '2013 Mustang',
                    thumb: 'http://mustangsdaily.com/blog/wp-content/uploads/2012/07/01-2013-ford-mustang-gt-review-585x388.jpg'
                },
                {
                    id: 2,
                    modelId: 1,
                    year: 2014,
                    name: '2014 Mustang',
                    thumb: 'http://mustangsdaily.com/blog/wp-content/uploads/2013/03/2014-roush-mustang.jpg'
                },
                {
                    id: 2,
                    modelId: 2,
                    year: 2013,
                    name: '2013 Focus',
                    thumb: 'http://images.newcars.com/images/car-pictures/original/2013-Ford-Focus-Sedan-S-4dr-Sedan-Exterior.png'
                },
                {
                    id: 2,
                    modelId: 2,
                    year: 2014,
                    name: '2014 Focus',
                    thumb: 'http://ipinvite.iperceptions.com/Invitations/survey705/images_V2/top4.jpg'
                },
                {
                    id: 2,
                    modelId: 3,
                    year: 2013,
                    name: '2013 Altima',
                    thumb: 'http://www.blogcdn.com/www.autoblog.com/media/2012/04/04-2013-nissan-altima-1333416664.jpg'
                },
                {
                    id: 2,
                    modelId: 3,
                    year: 2014,
                    name: '2014 Altima',
                    thumb: 'http://www.blogcdn.com/www.autoblog.com/media/2012/04/01-2013-nissan-altima-ny.jpg'
                },
                {
                    id: 2,
                    modelId: 4,
                    year: 2013,
                    name: '2013 Leaf',
                    thumb: 'http://www.blogcdn.com/www.autoblog.com/media/2012/04/01-2013-nissan-altima-ny.jpg'
                },
                {
                    id: 2,
                    modelId: 4,
                    year: 2014,
                    name: '2014 Leaf',
                    thumb: 'http://images.thecarconnection.com/med/2013-nissan-leaf_100414473_m.jpg'
                }
            ], {
                year: function (a, b) {
                    return a == b;
                },
                modelId: function (a, b) {
                    return a == b;
                }
            });
            fixture('GET /presetStore', store.findAll);
            stop();
            $.ajax({
                url: '/presetStore',
                method: 'get',
                data: {
                    year: 2013,
                    modelId: 1
                },
                dataType: 'json'
            }).then(function (response) {
                equal(response.data[0].id, 1, 'got the first item');
                equal(response.data.length, 1, 'only got one item');
                start();
            });
        });
        test('store with objects allows .create, .update and .destroy (#1471)', 4, function () {
            var store = fixture.store([
                {
                    id: 1,
                    modelId: 1,
                    year: 2013,
                    name: '2013 Mustang',
                    thumb: 'http://mustangsdaily.com/blog/wp-content/uploads/2012/07/01-2013-ford-mustang-gt-review-585x388.jpg'
                },
                {
                    id: 2,
                    modelId: 1,
                    year: 2014,
                    name: '2014 Mustang',
                    thumb: 'http://mustangsdaily.com/blog/wp-content/uploads/2013/03/2014-roush-mustang.jpg'
                },
                {
                    id: 3,
                    modelId: 2,
                    year: 2013,
                    name: '2013 Focus',
                    thumb: 'http://images.newcars.com/images/car-pictures/original/2013-Ford-Focus-Sedan-S-4dr-Sedan-Exterior.png'
                },
                {
                    id: 4,
                    modelId: 2,
                    year: 2014,
                    name: '2014 Focus',
                    thumb: 'http://ipinvite.iperceptions.com/Invitations/survey705/images_V2/top4.jpg'
                },
                {
                    id: 5,
                    modelId: 3,
                    year: 2013,
                    name: '2013 Altima',
                    thumb: 'http://www.blogcdn.com/www.autoblog.com/media/2012/04/04-2013-nissan-altima-1333416664.jpg'
                },
                {
                    id: 6,
                    modelId: 3,
                    year: 2014,
                    name: '2014 Altima',
                    thumb: 'http://www.blogcdn.com/www.autoblog.com/media/2012/04/01-2013-nissan-altima-ny.jpg'
                },
                {
                    id: 7,
                    modelId: 4,
                    year: 2013,
                    name: '2013 Leaf',
                    thumb: 'http://www.blogcdn.com/www.autoblog.com/media/201204/01-2013-nissan-altima-ny.jpg'
                },
                {
                    id: 8,
                    modelId: 4,
                    year: 2014,
                    name: '2014 Leaf',
                    thumb: 'http://images.thecarconnection.com/med/2013-nissan-leaf_100414473_m.jpg'
                }
            ]);
            fixture('GET /cars', store.findAll);
            fixture('POST /cars', store.create);
            fixture('PUT /cars/{id}', store.update);
            fixture('DELETE /cars/{id}', store.destroy);
            var findAll = function () {
                return $.ajax({
                    url: '/cars',
                    dataType: 'json'
                });
            };
            stop();
            findAll().then(function (carsData) {
                equal(carsData.data.length, 8, 'Got all cars');
                return $.ajax({
                    url: '/cars/' + carsData.data[1].id,
                    method: 'DELETE',
                    dataType: 'json'
                });
            }).then(function () {
                return findAll();
            }).then(function (carsData) {
                equal(carsData.data.length, 7, 'One car less');
                equal(carsData.data[1].name, '2013 Focus', 'Car actually deleted');
            }).then(function () {
                return $.ajax({
                    url: '/cars',
                    method: 'post',
                    dataType: 'json',
                    data: {
                        modelId: 3,
                        year: 2015,
                        name: '2015 Altima'
                    }
                });
            }).then(function (saved) {
                return $.ajax({
                    url: '/cars/' + saved.id,
                    method: 'put',
                    dataType: 'json',
                    data: {
                        modelId: 3,
                        year: 2015,
                        name: '2015 Nissan Altima'
                    }
                });
            }).then(function (updated) {
                return findAll();
            }).then(function (cars) {
                equal(cars.data.length, 8, 'New car created');
                start();
            });
        });
        test('filtering works', function () {
            var next;
            var store = fixture.store([
                {
                    state: 'CA',
                    name: 'Casadina'
                },
                {
                    state: 'NT',
                    name: 'Alberny'
                }
            ], {});
            fixture({ 'GET /api/cities': store.findAll });
            stop();
            $.getJSON('/api/cities?state=CA').then(function (data) {
                deepEqual(data, {
                    data: [{
                            state: 'CA',
                            name: 'Casadina'
                        }],
                    count: 1
                });
                next();
            }, function (e) {
                ok(false, '' + e);
                start();
            });
            next = function () {
                var store = fixture.store([
                    {
                        _id: 1,
                        name: 'Cheese City',
                        slug: 'cheese-city',
                        address: {
                            city: 'Casadina',
                            state: 'CA'
                        }
                    },
                    {
                        _id: 2,
                        name: 'Crab Barn',
                        slug: 'crab-barn',
                        address: {
                            city: 'Alberny',
                            state: 'NT'
                        }
                    }
                ], {});
                fixture({ 'GET /restaurants': store.findAll });
                $.getJSON('/api/restaurants?address[city]=Alberny').then(function (responseData) {
                    deepEqual(responseData, {
                        count: 1,
                        data: [{
                                _id: 2,
                                name: 'Crab Barn',
                                slug: 'crab-barn',
                                address: {
                                    city: 'Alberny',
                                    state: 'NT'
                                }
                            }]
                    });
                    last();
                }, function (e) {
                    ok(false);
                    start();
                });
            };
            function last() {
                var store = fixture.store([
                    {
                        _id: 1,
                        name: 'Cheese City',
                        slug: 'cheese-city',
                        address: {
                            city: 'Casadina',
                            state: 'CA'
                        }
                    },
                    {
                        _id: 2,
                        name: 'Crab Barn',
                        slug: 'crab-barn',
                        address: {
                            city: 'Alberny',
                            state: 'NT'
                        }
                    }
                ], {
                    'address.city': function (restaurantValue, paramValue, restaurant, params) {
                        return restaurant.address.city === paramValue;
                    }
                });
                var responseData = store.findAll({ data: { 'address.city': 'Alberny' } });
                deepEqual(responseData, {
                    count: 1,
                    data: [{
                            _id: 2,
                            name: 'Crab Barn',
                            slug: 'crab-barn',
                            address: {
                                city: 'Alberny',
                                state: 'NT'
                            }
                        }]
                });
                start();
            }
        });
        QUnit.test('onreadystatechange, event is passed', function () {
            fixture('GET something', function () {
                return {};
            });
            var xhr = new XMLHttpRequest();
            xhr.open('GET', 'something');
            xhr.onreadystatechange = function (ev) {
                ok(ev.target != null, 'the event object passed to onreadystatechange');
                start();
            };
            xhr.send();
            stop();
        });
        if (__dirname !== '/') {
            asyncTest('doesn\'t break onreadystatechange (#3)', function () {
                var url = __dirname + '/fixtures/test.json';
                var xhr = new XMLHttpRequest();
                xhr.onreadystatechange = function () {
                    if (xhr.readyState === 4) {
                        ok(true, 'we made a successful request');
                        start();
                    }
                };
                xhr.open('GET', url);
                xhr.send();
            });
        }
        QUnit.module('XHR Shim');
        test('Supports onload', function () {
            var xhr = new XMLHttpRequest();
            QUnit.ok('onload' in xhr, 'shim passes onload detection');
        });
        if (__dirname !== '/') {
            asyncTest('supports addEventListener on XHR shim', function () {
                var url = __dirname + '/fixtures/test.json';
                var xhr = new XMLHttpRequest();
                xhr.addEventListener('load', function () {
                    ok(true, 'our shim supports addEventListener');
                    start();
                });
                xhr.open('GET', url);
                xhr.send();
            });
        }
        if (__dirname !== '/') {
            asyncTest('supports removeEventListener on XHR shim', function () {
                var url = __dirname + '/fixtures/test.json';
                var xhr = new XMLHttpRequest();
                var onload = function () {
                    ok(false, 'this should not be called');
                };
                xhr.addEventListener('load', onload);
                xhr.removeEventListener('load', onload);
                xhr.onload = function () {
                    setTimeout(function () {
                        ok(true, 'didn\'t call the event listener');
                        start();
                    });
                };
                xhr.open('GET', url);
                xhr.send();
            });
        }
        test('supports setDisableHeaderCheck', function () {
            var xhr = new XMLHttpRequest();
            try {
                xhr.setDisableHeaderCheck(true);
                ok(true, 'did not throw');
            } catch (e) {
                ok(false, 'do not support setDisableHeaderCheck');
            }
        });
        if (__dirname !== '/') {
            asyncTest('supports setRequestHeader', function () {
                var url = __dirname + '/fixtures/test.json';
                var xhr = new XMLHttpRequest();
                xhr.setRequestHeader('foo', 'bar');
                xhr.onreadystatechange = function () {
                    if (xhr.readyState === 4) {
                        equal(xhr._requestHeaders.foo, 'bar', 'header was set');
                        start();
                    }
                };
                xhr.open('GET', url);
                xhr.send();
            });
        }
        if (__dirname !== '/') {
            asyncTest('supports getResponseHeader', function () {
                var url = __dirname + '/fixtures/test.json';
                var xhr = new XMLHttpRequest();
                xhr.onreadystatechange = function () {
                    if (xhr.readyState === 4) {
                        var header = xhr.getResponseHeader('Content-Type');
                        ok(header.indexOf('application/json') >= 0, 'got correct header back');
                        start();
                    }
                };
                xhr.open('GET', url);
                xhr.send();
            });
        }
        asyncTest('supports getAllResponseHeaders', function () {
            fixture('GET something', function (req, res) {
                res(200, { message: 'this is the body' }, { foo: 'bar' });
            });
            var xhr = new XMLHttpRequest();
            xhr.onreadystatechange = function () {
                if (xhr.readyState === 4) {
                    var headers = xhr.getAllResponseHeaders();
                    var parsed = parseHeaders(headers);
                    ok(typeof headers === 'string', 'got headers back');
                    ok(parsed.foo === 'bar', 'got proper values');
                    start();
                }
            };
            xhr.open('GET', 'something');
            xhr.send();
        });
        asyncTest('pass data to response handler (#13)', function () {
            fixture('GET something', function (req, res) {
                res(403, { message: 'No bad guys' });
            });
            var xhr = new XMLHttpRequest();
            xhr.open('GET', 'something');
            xhr.onreadystatechange = function (ev) {
                deepEqual(JSON.parse(this.responseText), { message: 'No bad guys' }, 'correct response');
                equal(this.status, 403, 'correct status');
                start();
            };
            xhr.send();
        });
        asyncTest('pass return value for fixture', function () {
            fixture('GET something', { foo: 'bar' });
            var xhr = new XMLHttpRequest();
            xhr.open('GET', 'something');
            xhr.onreadystatechange = function (ev) {
                deepEqual(JSON.parse(this.responseText), { foo: 'bar' }, 'correct response');
                equal(this.status, 200, 'correct status');
                start();
            };
            xhr.send();
        });
        if (__dirname !== '/') {
            asyncTest('pass headers in fallthrough', function () {
                var url = __dirname + '/fixtures/foobar.json';
                var xhr = new XMLHttpRequest();
                expect(2);
                xhr.open('GET', url);
                xhr.setRequestHeader('foo', 'bar');
                xhr.onreadystatechange = function (ev) {
                    var originalXhr = ev.target;
                    if (originalXhr.readyState === 1) {
                        originalXhr.setRequestHeader = function (key, val) {
                            equal(key, 'foo');
                            equal(val, 'bar');
                        };
                    }
                    if (originalXhr.readyState === 4) {
                        start();
                    }
                };
                xhr.send();
            });
        }
        test('set.Algebra CRUD works (#12)', 5, function () {
            var algebra = new set.Algebra(new set.Translate('where', 'where'), set.props.id('_id'), set.props.sort('orderBy'), set.props.enum('type', [
                'used',
                'new',
                'certified'
            ]), set.props.rangeInclusive('start', 'end'));
            var store = fixture.store([
                {
                    _id: 1,
                    modelId: 1,
                    year: 2013,
                    name: '2013 Mustang',
                    type: 'used'
                },
                {
                    _id: 2,
                    modelId: 1,
                    year: 2014,
                    name: '2014 Mustang',
                    type: 'new'
                },
                {
                    _id: 3,
                    modelId: 2,
                    year: 2013,
                    name: '2013 Focus',
                    type: 'used'
                },
                {
                    _id: 4,
                    modelId: 2,
                    year: 2014,
                    name: '2014 Focus',
                    type: 'certified'
                },
                {
                    _id: 5,
                    modelId: 3,
                    year: 2013,
                    name: '2013 Altima',
                    type: 'used'
                },
                {
                    _id: 6,
                    modelId: 3,
                    year: 2014,
                    name: '2014 Altima',
                    type: 'certified'
                },
                {
                    _id: 7,
                    modelId: 4,
                    year: 2013,
                    name: '2013 Leaf',
                    type: 'used'
                },
                {
                    _id: 8,
                    modelId: 4,
                    year: 2014,
                    name: '2014 Leaf',
                    type: 'used'
                }
            ], algebra);
            fixture('GET /cars', store.findAll);
            fixture('POST /cars', store.create);
            fixture('PUT /cars/{_id}', store.update);
            fixture('DELETE /cars/{_id}', store.destroy);
            fixture('GET /cars/{_id}', store.findOne);
            var findAll = function () {
                return $.ajax({
                    url: '/cars',
                    dataType: 'json'
                });
            };
            stop();
            findAll().then(function (carsData) {
                equal(carsData.data.length, 8, 'Got all cars');
                return $.ajax({
                    url: '/cars/' + carsData.data[1]._id,
                    method: 'DELETE',
                    dataType: 'json'
                });
            }).then(function () {
                return findAll();
            }).then(function (carsData) {
                equal(carsData.data.length, 7, 'One car less');
                equal(carsData.data[1].name, '2013 Focus', 'Car actually deleted');
            }).then(function () {
                return $.ajax({
                    url: '/cars',
                    method: 'post',
                    dataType: 'json',
                    data: {
                        modelId: 3,
                        year: 2015,
                        name: '2015 Altima',
                        type: 'new'
                    }
                });
            }).then(function (saved) {
                return $.ajax({
                    url: '/cars/' + saved._id,
                    method: 'put',
                    dataType: 'json',
                    data: {
                        modelId: 3,
                        year: 2015,
                        name: '2015 Nissan Altima'
                    }
                });
            }).then(function (updated) {
                return findAll();
            }).then(function (cars) {
                equal(cars.data.length, 8, 'New car created');
                return $.ajax({
                    url: '/cars/5',
                    method: 'get',
                    dataType: 'json'
                });
            }).then(function (car) {
                equal(car.name, '2013 Altima', 'get a single car works');
                start();
            });
        });
        test('set.Algebra CRUD works (#12)', 5, function () {
            var algebra = new set.Algebra(new set.Translate('where', 'where'), set.props.id('_id'), set.props.sort('orderBy'), set.props.enum('type', [
                'used',
                'new',
                'certified'
            ]), set.props.rangeInclusive('start', 'end'));
            var store = fixture.store([
                {
                    _id: 1,
                    modelId: 1,
                    year: 2013,
                    name: '2013 Mustang',
                    type: 'used'
                },
                {
                    _id: 2,
                    modelId: 1,
                    year: 2014,
                    name: '2014 Mustang',
                    type: 'new'
                },
                {
                    _id: 3,
                    modelId: 2,
                    year: 2013,
                    name: '2013 Focus',
                    type: 'used'
                },
                {
                    _id: 4,
                    modelId: 2,
                    year: 2014,
                    name: '2014 Focus',
                    type: 'certified'
                },
                {
                    _id: 5,
                    modelId: 3,
                    year: 2013,
                    name: '2013 Altima',
                    type: 'used'
                },
                {
                    _id: 6,
                    modelId: 3,
                    year: 2014,
                    name: '2014 Altima',
                    type: 'certified'
                },
                {
                    _id: 7,
                    modelId: 4,
                    year: 2013,
                    name: '2013 Leaf',
                    type: 'used'
                },
                {
                    _id: 8,
                    modelId: 4,
                    year: 2014,
                    name: '2014 Leaf',
                    type: 'used'
                }
            ], algebra);
            fixture('GET /cars', store.getListData);
            fixture('POST /cars', store.createData);
            fixture('PUT /cars/{_id}', store.updateData);
            fixture('DELETE /cars/{_id}', store.destroyData);
            fixture('GET /cars/{_id}', store.getData);
            var findAll = function () {
                return $.ajax({
                    url: '/cars',
                    dataType: 'json'
                });
            };
            stop();
            findAll().then(function (carsData) {
                equal(carsData.data.length, 8, 'Got all cars');
                return $.ajax({
                    url: '/cars/' + carsData.data[1]._id,
                    method: 'DELETE',
                    dataType: 'json'
                });
            }).then(function () {
                return findAll();
            }).then(function (carsData) {
                equal(carsData.data.length, 7, 'One car less');
                equal(carsData.data[1].name, '2013 Focus', 'Car actually deleted');
            }).then(function () {
                return $.ajax({
                    url: '/cars',
                    method: 'post',
                    dataType: 'json',
                    data: {
                        modelId: 3,
                        year: 2015,
                        name: '2015 Altima',
                        type: 'new'
                    }
                });
            }).then(function (saved) {
                return $.ajax({
                    url: '/cars/' + saved._id,
                    method: 'put',
                    dataType: 'json',
                    data: {
                        modelId: 3,
                        year: 2015,
                        name: '2015 Nissan Altima'
                    }
                });
            }).then(function (updated) {
                return findAll();
            }).then(function (cars) {
                equal(cars.data.length, 8, 'New car created');
                return $.ajax({
                    url: '/cars/5',
                    method: 'get',
                    dataType: 'json'
                });
            }).then(function (car) {
                equal(car.name, '2013 Altima', 'get a single car works');
                start();
            });
        });
        asyncTest('set.Algebra clauses work', function () {
            var algebra = new set.Algebra(new set.Translate('where', 'where'), set.props.id('_id'), set.props.sort('orderBy'), set.props.enum('type', [
                'used',
                'new',
                'certified'
            ]), set.props.rangeInclusive('start', 'end'), {
                year: function (a, b) {
                    if (a === b) {
                        return true;
                    }
                    if (a && b) {
                        return +a === +b;
                    }
                    return false;
                }
            });
            var store = fixture.store([
                {
                    _id: 1,
                    modelId: 1,
                    year: 2013,
                    name: '2013 Mustang',
                    type: 'used'
                },
                {
                    _id: 2,
                    modelId: 1,
                    year: 2014,
                    name: '2014 Mustang',
                    type: 'new'
                },
                {
                    _id: 3,
                    modelId: 2,
                    year: 2013,
                    name: '2013 Focus',
                    type: 'used'
                },
                {
                    _id: 4,
                    modelId: 2,
                    year: 2014,
                    name: '2014 Focus',
                    type: 'certified'
                },
                {
                    _id: 5,
                    modelId: 3,
                    year: 2013,
                    name: '2013 Altima',
                    type: 'used'
                },
                {
                    _id: 6,
                    modelId: 3,
                    year: 2014,
                    name: '2014 Altima',
                    type: 'certified'
                },
                {
                    _id: 7,
                    modelId: 4,
                    year: 2013,
                    name: '2013 Leaf',
                    type: 'used'
                },
                {
                    _id: 8,
                    modelId: 4,
                    year: 2014,
                    name: '2014 Leaf',
                    type: 'used'
                }
            ], algebra);
            fixture('GET /cars', store.findAll);
            $.ajax({
                url: '/cars?where[year]=2013',
                dataType: 'json'
            }).then(function (carsData) {
                equal(carsData.data.length, 4, 'Where clause works with numbers');
                return $.ajax({
                    url: '/cars?where[year]=2013&orderBy=name',
                    dataType: 'json'
                });
            }).then(function (carsData) {
                var names = carsData.data.map(function (c) {
                    return c.name;
                });
                deepEqual(names, [
                    '2013 Altima',
                    '2013 Focus',
                    '2013 Leaf',
                    '2013 Mustang'
                ], 'sort works');
                return $.ajax({
                    url: '/cars?where[year]=2013&orderBy=name&start=1&end=2',
                    dataType: 'json'
                });
            }).then(function (carsData) {
                var names = carsData.data.map(function (c) {
                    return c.name;
                });
                deepEqual(names, [
                    '2013 Focus',
                    '2013 Leaf'
                ], 'pagination works');
                start();
            });
        });
        test('storeConnection reset', function () {
            var algebra = new set.Algebra(new set.Translate('where', 'where'), set.props.id('_id'));
            var store = fixture.store([
                {
                    _id: 1,
                    modelId: 1,
                    year: 2013,
                    name: '2013 Mustang',
                    type: 'used'
                },
                {
                    _id: 2,
                    modelId: 1,
                    year: 2014,
                    name: '2014 Mustang',
                    type: 'new'
                }
            ], algebra);
            fixture('GET /cars', store.getListData);
            fixture('POST /cars', store.createData);
            fixture('PUT /cars/{_id}', store.updateData);
            fixture('DELETE /cars/{_id}', store.destroyData);
            fixture('GET /cars/{_id}', store.getData);
            var findAll = function () {
                return $.ajax({
                    url: '/cars',
                    dataType: 'json'
                });
            };
            $.ajax({
                url: '/cars/1',
                method: 'DELETE',
                dataType: 'json'
            }).then(function () {
                store.reset();
                return findAll();
            }).then(function (carsData) {
                equal(carsData.data.length, 2, 'Got all cars');
                start();
            });
            stop();
        });
        function makeAlgebraTest(fixtureUrl) {
            return function () {
                var algebra = new set.Algebra(new set.Translate('where', 'where'), set.props.id('_id'), set.props.sort('orderBy'), set.props.enum('type', [
                    'used',
                    'new',
                    'certified'
                ]), set.props.rangeInclusive('start', 'end'));
                var store = fixture.store([
                    {
                        _id: 1,
                        modelId: 1,
                        year: 2013,
                        name: '2013 Mustang',
                        type: 'used'
                    },
                    {
                        _id: 2,
                        modelId: 1,
                        year: 2014,
                        name: '2014 Mustang',
                        type: 'new'
                    },
                    {
                        _id: 3,
                        modelId: 2,
                        year: 2013,
                        name: '2013 Focus',
                        type: 'used'
                    },
                    {
                        _id: 4,
                        modelId: 2,
                        year: 2014,
                        name: '2014 Focus',
                        type: 'certified'
                    },
                    {
                        _id: 5,
                        modelId: 3,
                        year: 2013,
                        name: '2013 Altima',
                        type: 'used'
                    },
                    {
                        _id: 6,
                        modelId: 3,
                        year: 2014,
                        name: '2014 Altima',
                        type: 'certified'
                    },
                    {
                        _id: 7,
                        modelId: 4,
                        year: 2013,
                        name: '2013 Leaf',
                        type: 'used'
                    },
                    {
                        _id: 8,
                        modelId: 4,
                        year: 2014,
                        name: '2014 Leaf',
                        type: 'used'
                    }
                ], algebra);
                fixture(fixtureUrl, store);
                var findAll = function () {
                    return $.ajax({
                        url: '/cars',
                        dataType: 'json'
                    });
                };
                stop();
                findAll().then(function (carsData) {
                    equal(carsData.data.length, 8, 'Got all cars');
                    return $.ajax({
                        url: '/cars/' + carsData.data[1]._id,
                        method: 'DELETE',
                        dataType: 'json'
                    });
                }).then(function () {
                    return findAll();
                }).then(function (carsData) {
                    equal(carsData.data.length, 7, 'One car less');
                    equal(carsData.data[1].name, '2013 Focus', 'Car actually deleted');
                }).then(function () {
                    return $.ajax({
                        url: '/cars',
                        method: 'post',
                        dataType: 'json',
                        data: {
                            modelId: 3,
                            year: 2015,
                            name: '2015 Altima',
                            type: 'new'
                        }
                    });
                }).then(function (saved) {
                    return $.ajax({
                        url: '/cars/' + saved._id,
                        method: 'put',
                        dataType: 'json',
                        data: {
                            modelId: 3,
                            year: 2015,
                            name: '2015 Nissan Altima'
                        }
                    });
                }).then(function (updated) {
                    return findAll();
                }).then(function (cars) {
                    equal(cars.data.length, 8, 'New car created');
                    return $.ajax({
                        url: '/cars/5',
                        method: 'get',
                        dataType: 'json'
                    });
                }).then(function (car) {
                    equal(car.name, '2013 Altima', 'get a single car works');
                    start();
                });
            };
        }
        test('set.Algebra CRUD works with easy hookup (#12)', 5, makeAlgebraTest('/cars/{_id}'));
        test('set.Algebra CRUD works with easy hookup and list-style url (#52)', 5, makeAlgebraTest('/cars'));
        test('store.getList and store.get', function () {
            var algebra = new set.Algebra(set.props.id('_id'));
            var store = fixture.store([
                {
                    _id: 1,
                    modelId: 1,
                    year: 2013,
                    name: '2013 Mustang',
                    type: 'used'
                },
                {
                    _id: 2,
                    modelId: 1,
                    year: 2014,
                    name: '2014 Mustang',
                    type: 'new'
                },
                {
                    _id: 3,
                    modelId: 2,
                    year: 2013,
                    name: '2013 Focus',
                    type: 'used'
                },
                {
                    _id: 4,
                    modelId: 2,
                    year: 2014,
                    name: '2014 Focus',
                    type: 'certified'
                },
                {
                    _id: 5,
                    modelId: 3,
                    year: 2013,
                    name: '2013 Altima',
                    type: 'used'
                },
                {
                    _id: 6,
                    modelId: 3,
                    year: 2014,
                    name: '2014 Altima',
                    type: 'certified'
                },
                {
                    _id: 7,
                    modelId: 4,
                    year: 2013,
                    name: '2013 Leaf',
                    type: 'used'
                },
                {
                    _id: 8,
                    modelId: 4,
                    year: 2014,
                    name: '2014 Leaf',
                    type: 'used'
                }
            ], algebra);
            equal(store.getList({ year: 2013 }).data.length, 4, 'filtered');
            deepEqual(store.get({ _id: 5 }).name, '2013 Altima', 'get');
        });
        asyncTest('supports addEventListener on shim using fixture', function () {
            fixture('/addEventListener', function () {
                return {};
            });
            var xhr = new XMLHttpRequest();
            xhr.addEventListener('load', function () {
                ok(true, 'our shim supports addEventListener');
                start();
            });
            xhr.open('GET', '/addEventListener');
            xhr.send();
        });
        if (__dirname !== '/') {
            test('supports sync on XHR shim (#23)', function () {
                var url = __dirname + '/fixtures/test.json';
                var xhr = new XMLHttpRequest();
                xhr.addEventListener('load', function () {
                    ok(true, 'our shim supports addEventListener');
                });
                xhr.open('GET', url, false);
                xhr.send();
            });
        }
        test('supports sync fixtures (#23)', function () {
            fixture('/sync', function () {
                return {};
            });
            var xhr = new XMLHttpRequest();
            xhr.addEventListener('load', function () {
                ok(true, 'our shim supports sync');
            });
            xhr.open('GET', '/sync', false);
            xhr.send();
        });
        if (__dirname !== '/') {
            test('supports sync redirect fixtures (#23)', function () {
                fixture('/sync_redirect', __dirname + '/fixtures/test.json');
                var xhr = new XMLHttpRequest();
                xhr.addEventListener('load', function () {
                    ok(true, 'our shim supports sync redirect');
                });
                xhr.open('GET', '/sync_redirect', false);
                xhr.send();
            });
        }
        if (__dirname !== '/') {
            asyncTest('slow mode works (#26)', function () {
                var url = __dirname + '/fixtures/test.json';
                fixture({ url: url }, 1000);
                var xhr = new XMLHttpRequest();
                var startTime = new Date();
                xhr.addEventListener('load', function () {
                    var delay = new Date() - startTime;
                    ok(delay >= 900, delay + 'ms >= 900ms');
                    fixture({ url: url }, null);
                    start();
                });
                xhr.open('GET', url);
                xhr.send();
            });
        }
        asyncTest('onload should be triggered for HTTP error responses (#36)', function () {
            fixture('/onload', function (req, res) {
                res(400);
            });
            var xhr = new XMLHttpRequest();
            xhr.addEventListener('load', function () {
                ok(true, 'onload should be invoked');
                fixture('/onload', null);
                start();
            });
            xhr.addEventListener('error', function () {
                ok(false, 'onerror should not be invoked');
                fixture('/onload', null);
                start();
            });
            xhr.open('GET', '/onload');
            xhr.send();
        });
        asyncTest('responseText & responseXML should not be set for arraybuffer types (#38)', function () {
            fixture('/onload', '/test/fixtures/foo.json');
            var oldError = window.onerror;
            window.onerror = function (msg, url, line) {
                ok(false, 'There should not be an error');
                start();
            };
            var xhr = new XMLHttpRequest();
            xhr.addEventListener('load', function () {
                fixture('/onload', null);
                window.onerror = oldError;
                ok(true, 'Got here without an error');
                start();
            });
            xhr.responseType = 'arraybuffer';
            xhr.open('GET', '/onload');
            xhr.send();
        });
        asyncTest('fixture with timeout does not run if $.ajax timeout less than delay', function () {
            var delay = fixture.delay;
            fixture.delay = 1000;
            fixture('/onload', function () {
                fixture('/onload', null);
                ok(false, 'timed out xhr did not abort');
                start();
            });
            $.ajax({
                url: '/onload',
                timeout: 50,
                error: function (xhr) {
                    fixture('/onload', null);
                    ok(true, 'Got to the error handler');
                    equal(xhr.statusText, 'timeout');
                    equal(xhr.status, '0');
                    start();
                }
            });
            fixture.delay = delay;
        });
        asyncTest('response headers are set', function () {
            fixture('GET /todos', function (request, response) {
                response(200, '{}', { foo: 'bar' });
            });
            var xhr = new XMLHttpRequest();
            xhr.addEventListener('load', function () {
                var headers = parseHeaders(xhr.getAllResponseHeaders());
                ok(headers.foo === 'bar', 'header was set');
                start();
            });
            xhr.open('GET', '/todos');
            xhr.send();
        });
        asyncTest('match values in get data', function () {
            fixture({
                method: 'GET',
                url: '/data-value',
                data: { name: 'justin' }
            }, function (request, response) {
                QUnit.ok(true, 'got it');
                return {};
            });
            var xhr = new XMLHttpRequest();
            xhr.addEventListener('load', function () {
                QUnit.start();
            });
            xhr.open('GET', '/data-value?name=justin&age=22');
            xhr.send();
        });
        asyncTest('universal match (#2000)', function () {
            fixture({}, function () {
                ok(true, 'got hit');
                return {};
            });
            var xhr = new XMLHttpRequest();
            xhr.addEventListener('load', function () {
                QUnit.start();
                fixture.fixtures.splice(0, fixture.fixtures.length);
            });
            xhr.open('GET', '/something-totally-unexpected-62');
            xhr.send();
        });
        test('set.Algebra stores provide a count (#58)', function () {
            var algebra = new set.Algebra(new set.Translate('where', 'where'), set.props.id('_id'), set.props.sort('orderBy'), set.props.enum('type', [
                'used',
                'new',
                'certified'
            ]), set.props.rangeInclusive('start', 'end'));
            var store = fixture.store([
                {
                    _id: 1,
                    modelId: 1,
                    year: 2013,
                    name: '2013 Mustang',
                    type: 'used'
                },
                {
                    _id: 2,
                    modelId: 1,
                    year: 2014,
                    name: '2014 Mustang',
                    type: 'new'
                },
                {
                    _id: 3,
                    modelId: 2,
                    year: 2013,
                    name: '2013 Focus',
                    type: 'used'
                },
                {
                    _id: 4,
                    modelId: 2,
                    year: 2014,
                    name: '2014 Focus',
                    type: 'certified'
                },
                {
                    _id: 5,
                    modelId: 3,
                    year: 2013,
                    name: '2013 Altima',
                    type: 'used'
                },
                {
                    _id: 6,
                    modelId: 3,
                    year: 2014,
                    name: '2014 Altima',
                    type: 'certified'
                },
                {
                    _id: 7,
                    modelId: 4,
                    year: 2013,
                    name: '2013 Leaf',
                    type: 'used'
                },
                {
                    _id: 8,
                    modelId: 4,
                    year: 2014,
                    name: '2014 Leaf',
                    type: 'used'
                }
            ], algebra);
            fixture('/cars/{_id}', store);
            stop();
            $.ajax({
                url: '/cars',
                dataType: 'json',
                data: {
                    start: 2,
                    end: 3
                }
            }).then(function (carsData) {
                equal(carsData.data.length, 2, 'Got 2 cars');
                equal(carsData.count, 8, 'got the count');
                QUnit.start();
            }, function () {
                QUnit.ok(false, 'borked');
                QUnit.start();
            });
        });
        if ('onabort' in XMLHttpRequest._XHR.prototype) {
            asyncTest('fixture with timeout aborts if xhr timeout less than delay', function () {
                fixture('/onload', 1000);
                var xhr = new XMLHttpRequest();
                xhr.open('GET', '/onload');
                xhr.send();
                setTimeout(function () {
                    xhr.abort();
                }, 50);
                xhr.addEventListener('abort', function () {
                    fixture('/onload', null);
                    ok(true, 'Got to the error handler');
                    equal(xhr.statusText, '');
                    equal(xhr.status, 0);
                    start();
                });
                xhr.addEventListener('load', function () {
                    fixture('/onload', null);
                    ok(false, 'timed out xhr did not abort');
                    start();
                });
            });
            asyncTest('dynamic fixture with timeout does not run if xhr timeout less than delay', function () {
                var delay = fixture.delay;
                fixture.delay = 1000;
                fixture('/onload', function () {
                    fixture('/onload', null);
                    ok(false, 'timed out xhr did not abort');
                    start();
                });
                var xhr = new XMLHttpRequest();
                xhr.open('GET', '/onload');
                setTimeout(function () {
                    xhr.abort();
                }, 50);
                xhr.send();
                xhr.addEventListener('abort', function () {
                    fixture('/onload', null);
                    ok(true, 'Got to the error handler');
                    equal(xhr.statusText, '');
                    equal(xhr.status, 0);
                    start();
                });
                fixture.delay = delay;
            });
            test('abort() sets readyState correctly', function () {
                stop();
                fixture('/foo', function () {
                    return {};
                });
                var xhr = new XMLHttpRequest();
                xhr.open('GET', '/foo');
                xhr.addEventListener('abort', function () {
                    fixture('/foo', null);
                    ok(true, 'Got to the error handler');
                    equal(xhr.status, 0);
                    equal(xhr.statusText, '');
                    setTimeout(function () {
                        equal(xhr.readyState, 0);
                        start();
                    }, 50);
                });
                xhr.send();
                xhr.abort();
            });
            test('abort() of already completed fixture', function () {
                stop();
                fixture('/foo', function () {
                    return {};
                });
                var xhr = new XMLHttpRequest();
                xhr.open('GET', '/foo');
                xhr.addEventListener('load', function () {
                    fixture('/foo', null);
                    equal(xhr.readyState, 4);
                    xhr.abort();
                    start();
                });
                xhr.send();
            });
            asyncTest('should be able to call getResponseHeader onload', function () {
                fixture('/onload', function (req, res) {
                    res(400);
                });
                var xhr = new XMLHttpRequest();
                xhr.addEventListener('load', function () {
                    fixture('/onload', null);
                    xhr.getResponseHeader('Set-Cookie');
                    ok(true, 'should not throw when calling getResponseHeader');
                    start();
                });
                xhr.open('GET', '/onload');
                xhr.send();
            });
        }
    }('/'));
});
/*syn@0.4.2#dist/cjs/synthetic.js*/
define('syn@0.4.2#dist/cjs/synthetic.js', function (require, exports, module) {
    var opts = window.syn ? window.syn : {};
    var extend = function (d, s) {
            var p;
            for (p in s) {
                d[p] = s[p];
            }
            return d;
        }, browser = {
            msie: !!(window.attachEvent && !window.opera),
            opera: !!window.opera,
            webkit: navigator.userAgent.indexOf('AppleWebKit/') > -1,
            safari: navigator.userAgent.indexOf('AppleWebKit/') > -1 && navigator.userAgent.indexOf('Chrome/') === -1,
            gecko: navigator.userAgent.indexOf('Gecko') > -1,
            mobilesafari: !!navigator.userAgent.match(/Apple.*Mobile.*Safari/),
            rhino: navigator.userAgent.match(/Rhino/) && true
        }, createEventObject = function (type, options, element) {
            var event = element.ownerDocument.createEventObject();
            return extend(event, options);
        }, data = {}, id = 1, expando = '_synthetic' + new Date().getTime(), bind, unbind, schedule, key = /keypress|keyup|keydown/, page = /load|unload|abort|error|select|change|submit|reset|focus|blur|resize|scroll/, activeElement, syn = function (type, element, options, callback) {
            return new syn.init(type, element, options, callback);
        };
    syn.config = opts;
    syn.__tryFocus = function tryFocus(element) {
        try {
            element.focus();
        } catch (e) {
        }
    };
    bind = function (el, ev, f) {
        return el.addEventListener ? el.addEventListener(ev, f, false) : el.attachEvent('on' + ev, f);
    };
    unbind = function (el, ev, f) {
        return el.addEventListener ? el.removeEventListener(ev, f, false) : el.detachEvent('on' + ev, f);
    };
    schedule = syn.config.schedule || function (fn, ms) {
        setTimeout(fn, ms);
    };
    extend(syn, {
        init: function (type, element, options, callback) {
            var args = syn.args(options, element, callback), self = this;
            this.queue = [];
            this.element = args.element;
            if (typeof this[type] === 'function') {
                this[type](args.element, args.options, function (defaults, el) {
                    if (args.callback) {
                        args.callback.apply(self, arguments);
                    }
                    self.done.apply(self, arguments);
                });
            } else {
                this.result = syn.trigger(args.element, type, args.options);
                if (args.callback) {
                    args.callback.call(this, args.element, this.result);
                }
            }
        },
        jquery: function (el, fast) {
            if (window.FuncUnit && window.FuncUnit.jQuery) {
                return window.FuncUnit.jQuery;
            }
            if (el) {
                return syn.helpers.getWindow(el).jQuery || window.jQuery;
            } else {
                return window.jQuery;
            }
        },
        args: function () {
            var res = {}, i = 0;
            for (; i < arguments.length; i++) {
                if (typeof arguments[i] === 'function') {
                    res.callback = arguments[i];
                } else if (arguments[i] && arguments[i].jquery) {
                    res.element = arguments[i][0];
                } else if (arguments[i] && arguments[i].nodeName) {
                    res.element = arguments[i];
                } else if (res.options && typeof arguments[i] === 'string') {
                    res.element = document.getElementById(arguments[i]);
                } else if (arguments[i]) {
                    res.options = arguments[i];
                }
            }
            return res;
        },
        click: function (element, options, callback) {
            syn('click!', element, options, callback);
        },
        defaults: {
            focus: function focus() {
                if (!syn.support.focusChanges) {
                    var element = this, nodeName = element.nodeName.toLowerCase();
                    syn.data(element, 'syntheticvalue', element.value);
                    if (nodeName === 'input' || nodeName === 'textarea') {
                        bind(element, 'blur', function blur() {
                            if (syn.data(element, 'syntheticvalue') !== element.value) {
                                syn.trigger(element, 'change', {});
                            }
                            unbind(element, 'blur', blur);
                        });
                    }
                }
            },
            submit: function () {
                syn.onParents(this, function (el) {
                    if (el.nodeName.toLowerCase() === 'form') {
                        el.submit();
                        return false;
                    }
                });
            }
        },
        changeOnBlur: function (element, prop, value) {
            bind(element, 'blur', function onblur() {
                if (value !== element[prop]) {
                    syn.trigger(element, 'change', {});
                }
                unbind(element, 'blur', onblur);
            });
        },
        closest: function (el, type) {
            while (el && el.nodeName.toLowerCase() !== type.toLowerCase()) {
                el = el.parentNode;
            }
            return el;
        },
        data: function (el, key, value) {
            var d;
            if (!el[expando]) {
                el[expando] = id++;
            }
            if (!data[el[expando]]) {
                data[el[expando]] = {};
            }
            d = data[el[expando]];
            if (value) {
                data[el[expando]][key] = value;
            } else {
                return data[el[expando]][key];
            }
        },
        onParents: function (el, func) {
            var res;
            while (el && res !== false) {
                res = func(el);
                el = el.parentNode;
            }
            return el;
        },
        focusable: /^(a|area|frame|iframe|label|input|select|textarea|button|html|object)$/i,
        isFocusable: function (elem) {
            var attributeNode;
            if (elem.getAttributeNode) {
                attributeNode = elem.getAttributeNode('tabIndex');
            }
            return this.focusable.test(elem.nodeName) || attributeNode && attributeNode.specified && syn.isVisible(elem);
        },
        isVisible: function (elem) {
            return elem.offsetWidth && elem.offsetHeight || elem.clientWidth && elem.clientHeight;
        },
        tabIndex: function (elem) {
            var attributeNode = elem.getAttributeNode('tabIndex');
            return attributeNode && attributeNode.specified && (parseInt(elem.getAttribute('tabIndex')) || 0);
        },
        bind: bind,
        unbind: unbind,
        schedule: schedule,
        browser: browser,
        helpers: {
            createEventObject: createEventObject,
            createBasicStandardEvent: function (type, defaults, doc) {
                var event;
                try {
                    event = doc.createEvent('Events');
                } catch (e2) {
                    event = doc.createEvent('UIEvents');
                } finally {
                    event.initEvent(type, true, true);
                    extend(event, defaults);
                }
                return event;
            },
            inArray: function (item, array) {
                var i = 0;
                for (; i < array.length; i++) {
                    if (array[i] === item) {
                        return i;
                    }
                }
                return -1;
            },
            getWindow: function (element) {
                if (element.ownerDocument) {
                    return element.ownerDocument.defaultView || element.ownerDocument.parentWindow;
                }
            },
            extend: extend,
            scrollOffset: function (win, set) {
                var doc = win.document.documentElement, body = win.document.body;
                if (set) {
                    window.scrollTo(set.left, set.top);
                } else {
                    return {
                        left: (doc && doc.scrollLeft || body && body.scrollLeft || 0) + (doc.clientLeft || 0),
                        top: (doc && doc.scrollTop || body && body.scrollTop || 0) + (doc.clientTop || 0)
                    };
                }
            },
            scrollDimensions: function (win) {
                var doc = win.document.documentElement, body = win.document.body, docWidth = doc.clientWidth, docHeight = doc.clientHeight, compat = win.document.compatMode === 'CSS1Compat';
                return {
                    height: compat && docHeight || body.clientHeight || docHeight,
                    width: compat && docWidth || body.clientWidth || docWidth
                };
            },
            addOffset: function (options, el) {
                var jq = syn.jquery(el), off;
                if (typeof options === 'object' && options.clientX === undefined && options.clientY === undefined && options.pageX === undefined && options.pageY === undefined && jq) {
                    el = jq(el);
                    off = el.offset();
                    options.pageX = off.left + el.width() / 2;
                    options.pageY = off.top + el.height() / 2;
                }
            }
        },
        key: {
            ctrlKey: null,
            altKey: null,
            shiftKey: null,
            metaKey: null
        },
        dispatch: function (event, element, type, autoPrevent) {
            if (element.dispatchEvent && event) {
                var preventDefault = event.preventDefault, prevents = autoPrevent ? -1 : 0;
                if (autoPrevent) {
                    bind(element, type, function ontype(ev) {
                        ev.preventDefault();
                        unbind(this, type, ontype);
                    });
                }
                event.preventDefault = function () {
                    prevents++;
                    if (++prevents > 0) {
                        preventDefault.apply(this, []);
                    }
                };
                element.dispatchEvent(event);
                return prevents <= 0;
            } else {
                try {
                    window.event = event;
                } catch (e) {
                }
                return element.sourceIndex <= 0 || element.fireEvent && element.fireEvent('on' + type, event);
            }
        },
        create: {
            page: {
                event: function (type, options, element) {
                    var doc = syn.helpers.getWindow(element).document || document, event;
                    if (doc.createEvent) {
                        event = doc.createEvent('Events');
                        event.initEvent(type, true, true);
                        return event;
                    } else {
                        try {
                            event = createEventObject(type, options, element);
                        } catch (e) {
                        }
                        return event;
                    }
                }
            },
            focus: {
                event: function (type, options, element) {
                    syn.onParents(element, function (el) {
                        if (syn.isFocusable(el)) {
                            if (el.nodeName.toLowerCase() !== 'html') {
                                syn.__tryFocus(el);
                                activeElement = el;
                            } else if (activeElement) {
                                var doc = syn.helpers.getWindow(element).document;
                                if (doc !== window.document) {
                                    return false;
                                } else if (doc.activeElement) {
                                    doc.activeElement.blur();
                                    activeElement = null;
                                } else {
                                    activeElement.blur();
                                    activeElement = null;
                                }
                            }
                            return false;
                        }
                    });
                    return true;
                }
            }
        },
        support: {
            clickChanges: false,
            clickSubmits: false,
            keypressSubmits: false,
            mouseupSubmits: false,
            radioClickChanges: false,
            focusChanges: false,
            linkHrefJS: false,
            keyCharacters: false,
            backspaceWorks: false,
            mouseDownUpClicks: false,
            tabKeyTabs: false,
            keypressOnAnchorClicks: false,
            optionClickBubbles: false,
            pointerEvents: false,
            touchEvents: false,
            ready: 0
        },
        trigger: function (element, type, options) {
            if (!options) {
                options = {};
            }
            var create = syn.create, setup = create[type] && create[type].setup, kind = key.test(type) ? 'key' : page.test(type) ? 'page' : 'mouse', createType = create[type] || {}, createKind = create[kind], event, ret, autoPrevent, dispatchEl = element;
            if (syn.support.ready === 2 && setup) {
                setup(type, options, element);
            }
            autoPrevent = options._autoPrevent;
            delete options._autoPrevent;
            if (createType.event) {
                ret = createType.event(type, options, element);
            } else {
                options = createKind.options ? createKind.options(type, options, element) : options;
                if (!syn.support.changeBubbles && /option/i.test(element.nodeName)) {
                    dispatchEl = element.parentNode;
                }
                event = createKind.event(type, options, dispatchEl);
                ret = syn.dispatch(event, dispatchEl, type, autoPrevent);
            }
            if (ret && syn.support.ready === 2 && syn.defaults[type]) {
                syn.defaults[type].call(element, options, autoPrevent);
            }
            return ret;
        },
        eventSupported: function (eventName) {
            var el = document.createElement('div');
            eventName = 'on' + eventName;
            var isSupported = eventName in el;
            if (!isSupported) {
                el.setAttribute(eventName, 'return;');
                isSupported = typeof el[eventName] === 'function';
            }
            el = null;
            return isSupported;
        }
    });
    extend(syn.init.prototype, {
        then: function (type, element, options, callback) {
            if (syn.autoDelay) {
                this.delay();
            }
            var args = syn.args(options, element, callback), self = this;
            this.queue.unshift(function (el, prevented) {
                if (typeof this[type] === 'function') {
                    this.element = args.element || el;
                    this[type](this.element, args.options, function (defaults, el) {
                        if (args.callback) {
                            args.callback.apply(self, arguments);
                        }
                        self.done.apply(self, arguments);
                    });
                } else {
                    this.result = syn.trigger(args.element, type, args.options);
                    if (args.callback) {
                        args.callback.call(this, args.element, this.result);
                    }
                    return this;
                }
            });
            return this;
        },
        delay: function (timeout, callback) {
            if (typeof timeout === 'function') {
                callback = timeout;
                timeout = null;
            }
            timeout = timeout || 600;
            var self = this;
            this.queue.unshift(function () {
                schedule(function () {
                    if (callback) {
                        callback.apply(self, []);
                    }
                    self.done.apply(self, arguments);
                }, timeout);
            });
            return this;
        },
        done: function (defaults, el) {
            if (el) {
                this.element = el;
            }
            if (this.queue.length) {
                this.queue.pop().call(this, this.element, defaults);
            }
        },
        '_click': function (element, options, callback, force) {
            syn.helpers.addOffset(options, element);
            if (syn.support.pointerEvents) {
                syn.trigger(element, 'pointerdown', options);
            }
            if (syn.support.touchEvents) {
                syn.trigger(element, 'touchstart', options);
            }
            syn.trigger(element, 'mousedown', options);
            schedule(function () {
                if (syn.support.pointerEvents) {
                    syn.trigger(element, 'pointerup', options);
                }
                if (syn.support.touchEvents) {
                    syn.trigger(element, 'touchend', options);
                }
                syn.trigger(element, 'mouseup', options);
                if (!syn.support.mouseDownUpClicks || force) {
                    syn.trigger(element, 'click', options);
                    callback(true);
                } else {
                    syn.create.click.setup('click', options, element);
                    syn.defaults.click.call(element);
                    schedule(function () {
                        callback(true);
                    }, 1);
                }
            }, 1);
        },
        '_rightClick': function (element, options, callback) {
            syn.helpers.addOffset(options, element);
            var mouseopts = extend(extend({}, syn.mouse.browser.right.mouseup), options);
            syn.trigger(element, 'mousedown', mouseopts);
            schedule(function () {
                syn.trigger(element, 'mouseup', mouseopts);
                if (syn.mouse.browser.right.contextmenu) {
                    syn.trigger(element, 'contextmenu', extend(extend({}, syn.mouse.browser.right.contextmenu), options));
                }
                callback(true);
            }, 1);
        },
        '_dblclick': function (element, options, callback) {
            syn.helpers.addOffset(options, element);
            var self = this;
            this._click(element, options, function () {
                schedule(function () {
                    self._click(element, options, function () {
                        syn.trigger(element, 'dblclick', options);
                        callback(true);
                    }, true);
                }, 2);
            });
        }
    });
    var actions = [
            'click',
            'dblclick',
            'move',
            'drag',
            'key',
            'type',
            'rightClick'
        ], makeAction = function (name) {
            syn[name] = function (element, options, callback) {
                return syn('_' + name, element, options, callback);
            };
            syn.init.prototype[name] = function (element, options, callback) {
                return this.then('_' + name, element, options, callback);
            };
        }, i = 0;
    for (; i < actions.length; i++) {
        makeAction(actions[i]);
    }
    module.exports = syn;
});
/*syn@0.4.2#dist/cjs/mouse.js*/
define('syn@0.4.2#dist/cjs/mouse.js', function (require, exports, module) {
    var syn = require('./synthetic.js');
    var h = syn.helpers, getWin = h.getWindow;
    syn.mouse = {};
    h.extend(syn.defaults, {
        mousedown: function (options) {
            syn.trigger(this, 'focus', {});
        },
        click: function () {
            var element = this, href, type, createChange, radioChanged, nodeName, scope;
            try {
                href = element.href;
                type = element.type;
                createChange = syn.data(element, 'createChange');
                radioChanged = syn.data(element, 'radioChanged');
                scope = getWin(element);
                nodeName = element.nodeName.toLowerCase();
            } catch (e) {
                return;
            }
            if (!syn.support.linkHrefJS && /^\s*javascript:/.test(href)) {
                var code = href.replace(/^\s*javascript:/, '');
                if (code !== '//' && code.indexOf('void(0)') === -1) {
                    if (window.selenium) {
                        eval('with(selenium.browserbot.getCurrentWindow()){' + code + '}');
                    } else {
                        eval('with(scope){' + code + '}');
                    }
                }
            }
            if (!syn.support.clickSubmits && ((nodeName === 'input' || nodeName === 'button') && type === 'submit')) {
                var form = syn.closest(element, 'form');
                if (form) {
                    syn.trigger(form, 'submit', {});
                }
            }
            if (nodeName === 'a' && element.href && !/^\s*javascript:/.test(href)) {
                scope.location.href = href;
            }
            if (nodeName === 'input' && type === 'checkbox') {
                if (!syn.support.clickChanges) {
                    syn.trigger(element, 'change', {});
                }
            }
            if (nodeName === 'input' && type === 'radio') {
                if (radioChanged && !syn.support.radioClickChanges) {
                    syn.trigger(element, 'change', {});
                }
            }
            if (nodeName === 'option' && createChange) {
                syn.trigger(element.parentNode, 'change', {});
                syn.data(element, 'createChange', false);
            }
        }
    });
    h.extend(syn.create, {
        mouse: {
            options: function (type, options, element) {
                var doc = document.documentElement, body = document.body, center = [
                        options.pageX || 0,
                        options.pageY || 0
                    ], left = syn.mouse.browser && syn.mouse.browser.left[type], right = syn.mouse.browser && syn.mouse.browser.right[type];
                return h.extend({
                    bubbles: true,
                    cancelable: true,
                    view: window,
                    detail: 1,
                    screenX: 1,
                    screenY: 1,
                    clientX: options.clientX || center[0] - (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc.clientLeft || 0),
                    clientY: options.clientY || center[1] - (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc.clientTop || 0),
                    ctrlKey: !!syn.key.ctrlKey,
                    altKey: !!syn.key.altKey,
                    shiftKey: !!syn.key.shiftKey,
                    metaKey: !!syn.key.metaKey,
                    button: left && left.button !== null ? left.button : right && right.button || (type === 'contextmenu' ? 2 : 0),
                    relatedTarget: document.documentElement
                }, options);
            },
            event: function (type, defaults, element) {
                var doc = getWin(element).document || document, event;
                if (doc.createEvent) {
                    try {
                        event = doc.createEvent('MouseEvents');
                        event.initMouseEvent(type, defaults.bubbles, defaults.cancelable, defaults.view, defaults.detail, defaults.screenX, defaults.screenY, defaults.clientX, defaults.clientY, defaults.ctrlKey, defaults.altKey, defaults.shiftKey, defaults.metaKey, defaults.button, defaults.relatedTarget);
                    } catch (e) {
                        event = h.createBasicStandardEvent(type, defaults, doc);
                    }
                    event.synthetic = true;
                    return event;
                } else {
                    try {
                        event = h.createEventObject(type, defaults, element);
                    } catch (e) {
                    }
                    return event;
                }
            }
        },
        click: {
            setup: function (type, options, element) {
                var nodeName = element.nodeName.toLowerCase();
                if (!syn.support.clickChecks && !syn.support.changeChecks && nodeName === 'input') {
                    type = element.type.toLowerCase();
                    if (type === 'checkbox') {
                        element.checked = !element.checked;
                    }
                    if (type === 'radio') {
                        if (!element.checked) {
                            try {
                                syn.data(element, 'radioChanged', true);
                            } catch (e) {
                            }
                            element.checked = true;
                        }
                    }
                }
                if (nodeName === 'a' && element.href && !/^\s*javascript:/.test(element.href)) {
                    syn.data(element, 'href', element.href);
                }
                if (/option/i.test(element.nodeName)) {
                    var child = element.parentNode.firstChild, i = -1;
                    while (child) {
                        if (child.nodeType === 1) {
                            i++;
                            if (child === element) {
                                break;
                            }
                        }
                        child = child.nextSibling;
                    }
                    if (i !== element.parentNode.selectedIndex) {
                        element.parentNode.selectedIndex = i;
                        syn.data(element, 'createChange', true);
                    }
                }
            }
        },
        mousedown: {
            setup: function (type, options, element) {
                var nn = element.nodeName.toLowerCase();
                if (syn.browser.safari && (nn === 'select' || nn === 'option')) {
                    options._autoPrevent = true;
                }
            }
        }
    });
});
/*syn@0.4.2#dist/cjs/mouse.support.js*/
define('syn@0.4.2#dist/cjs/mouse.support.js', function (require, exports, module) {
    var syn = require('./synthetic.js');
    require('./mouse.js');
    (function checkSupport() {
        if (!document.body) {
            return syn.schedule(checkSupport, 1);
        }
        window.__synthTest = function () {
            syn.support.linkHrefJS = true;
        };
        var div = document.createElement('div'), checkbox, submit, form, select;
        div.innerHTML = '<form id=\'outer\'>' + '<input name=\'checkbox\' type=\'checkbox\'/>' + '<input name=\'radio\' type=\'radio\' />' + '<input type=\'submit\' name=\'submitter\'/>' + '<input type=\'input\' name=\'inputter\'/>' + '<input name=\'one\'>' + '<input name=\'two\'/>' + '<a href=\'javascript:__synthTest()\' id=\'synlink\'></a>' + '<select><option></option></select>' + '</form>';
        document.documentElement.appendChild(div);
        form = div.firstChild;
        checkbox = form.childNodes[0];
        submit = form.childNodes[2];
        select = form.getElementsByTagName('select')[0];
        syn.trigger(form.childNodes[6], 'click', {});
        checkbox.checked = false;
        checkbox.onchange = function () {
            syn.support.clickChanges = true;
        };
        syn.trigger(checkbox, 'click', {});
        syn.support.clickChecks = checkbox.checked;
        checkbox.checked = false;
        syn.trigger(checkbox, 'change', {});
        syn.support.changeChecks = checkbox.checked;
        form.onsubmit = function (ev) {
            if (ev.preventDefault) {
                ev.preventDefault();
            }
            syn.support.clickSubmits = true;
            return false;
        };
        syn.trigger(submit, 'click', {});
        form.childNodes[1].onchange = function () {
            syn.support.radioClickChanges = true;
        };
        syn.trigger(form.childNodes[1], 'click', {});
        syn.bind(div, 'click', function onclick() {
            syn.support.optionClickBubbles = true;
            syn.unbind(div, 'click', onclick);
        });
        syn.trigger(select.firstChild, 'click', {});
        syn.support.changeBubbles = syn.eventSupported('change');
        div.onclick = function () {
            syn.support.mouseDownUpClicks = true;
        };
        syn.trigger(div, 'mousedown', {});
        syn.trigger(div, 'mouseup', {});
        document.documentElement.removeChild(div);
        syn.support.pointerEvents = syn.eventSupported('pointerdown');
        syn.support.touchEvents = syn.eventSupported('touchstart');
        syn.support.ready++;
    }());
});
/*syn@0.4.2#dist/cjs/browsers.js*/
define('syn@0.4.2#dist/cjs/browsers.js', function (require, exports, module) {
    var syn = require('./synthetic.js');
    require('./mouse.js');
    syn.key.browsers = {
        webkit: {
            'prevent': {
                'keyup': [],
                'keydown': [
                    'char',
                    'keypress'
                ],
                'keypress': ['char']
            },
            'character': {
                'keydown': [
                    0,
                    'key'
                ],
                'keypress': [
                    'char',
                    'char'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'specialChars': {
                'keydown': [
                    0,
                    'char'
                ],
                'keyup': [
                    0,
                    'char'
                ]
            },
            'navigation': {
                'keydown': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'special': {
                'keydown': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'tab': {
                'keydown': [
                    0,
                    'char'
                ],
                'keyup': [
                    0,
                    'char'
                ]
            },
            'pause-break': {
                'keydown': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'caps': {
                'keydown': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'escape': {
                'keydown': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'num-lock': {
                'keydown': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'scroll-lock': {
                'keydown': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'print': {
                'keyup': [
                    0,
                    'key'
                ]
            },
            'function': {
                'keydown': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            '\r': {
                'keydown': [
                    0,
                    'key'
                ],
                'keypress': [
                    'char',
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            }
        },
        gecko: {
            'prevent': {
                'keyup': [],
                'keydown': ['char'],
                'keypress': ['char']
            },
            'character': {
                'keydown': [
                    0,
                    'key'
                ],
                'keypress': [
                    'char',
                    0
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'specialChars': {
                'keydown': [
                    0,
                    'key'
                ],
                'keypress': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'navigation': {
                'keydown': [
                    0,
                    'key'
                ],
                'keypress': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'special': {
                'keydown': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            '\t': {
                'keydown': [
                    0,
                    'key'
                ],
                'keypress': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'pause-break': {
                'keydown': [
                    0,
                    'key'
                ],
                'keypress': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'caps': {
                'keydown': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'escape': {
                'keydown': [
                    0,
                    'key'
                ],
                'keypress': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'num-lock': {
                'keydown': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'scroll-lock': {
                'keydown': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'print': {
                'keyup': [
                    0,
                    'key'
                ]
            },
            'function': {
                'keydown': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            '\r': {
                'keydown': [
                    0,
                    'key'
                ],
                'keypress': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            }
        },
        msie: {
            'prevent': {
                'keyup': [],
                'keydown': [
                    'char',
                    'keypress'
                ],
                'keypress': ['char']
            },
            'character': {
                'keydown': [
                    null,
                    'key'
                ],
                'keypress': [
                    null,
                    'char'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            'specialChars': {
                'keydown': [
                    null,
                    'char'
                ],
                'keyup': [
                    null,
                    'char'
                ]
            },
            'navigation': {
                'keydown': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            'special': {
                'keydown': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            'tab': {
                'keydown': [
                    null,
                    'char'
                ],
                'keyup': [
                    null,
                    'char'
                ]
            },
            'pause-break': {
                'keydown': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            'caps': {
                'keydown': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            'escape': {
                'keydown': [
                    null,
                    'key'
                ],
                'keypress': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            'num-lock': {
                'keydown': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            'scroll-lock': {
                'keydown': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            'print': {
                'keyup': [
                    null,
                    'key'
                ]
            },
            'function': {
                'keydown': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            '\r': {
                'keydown': [
                    null,
                    'key'
                ],
                'keypress': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            }
        },
        opera: {
            'prevent': {
                'keyup': [],
                'keydown': [],
                'keypress': ['char']
            },
            'character': {
                'keydown': [
                    null,
                    'key'
                ],
                'keypress': [
                    null,
                    'char'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            'specialChars': {
                'keydown': [
                    null,
                    'char'
                ],
                'keypress': [
                    null,
                    'char'
                ],
                'keyup': [
                    null,
                    'char'
                ]
            },
            'navigation': {
                'keydown': [
                    null,
                    'key'
                ],
                'keypress': [
                    null,
                    'key'
                ]
            },
            'special': {
                'keydown': [
                    null,
                    'key'
                ],
                'keypress': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            'tab': {
                'keydown': [
                    null,
                    'char'
                ],
                'keypress': [
                    null,
                    'char'
                ],
                'keyup': [
                    null,
                    'char'
                ]
            },
            'pause-break': {
                'keydown': [
                    null,
                    'key'
                ],
                'keypress': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            'caps': {
                'keydown': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            'escape': {
                'keydown': [
                    null,
                    'key'
                ],
                'keypress': [
                    null,
                    'key'
                ]
            },
            'num-lock': {
                'keyup': [
                    null,
                    'key'
                ],
                'keydown': [
                    null,
                    'key'
                ],
                'keypress': [
                    null,
                    'key'
                ]
            },
            'scroll-lock': {
                'keydown': [
                    null,
                    'key'
                ],
                'keypress': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            'print': {},
            'function': {
                'keydown': [
                    null,
                    'key'
                ],
                'keypress': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            '\r': {
                'keydown': [
                    null,
                    'key'
                ],
                'keypress': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            }
        }
    };
    syn.mouse.browsers = {
        webkit: {
            'right': {
                'mousedown': {
                    'button': 2,
                    'which': 3
                },
                'mouseup': {
                    'button': 2,
                    'which': 3
                },
                'contextmenu': {
                    'button': 2,
                    'which': 3
                }
            },
            'left': {
                'mousedown': {
                    'button': 0,
                    'which': 1
                },
                'mouseup': {
                    'button': 0,
                    'which': 1
                },
                'click': {
                    'button': 0,
                    'which': 1
                }
            }
        },
        opera: {
            'right': {
                'mousedown': {
                    'button': 2,
                    'which': 3
                },
                'mouseup': {
                    'button': 2,
                    'which': 3
                }
            },
            'left': {
                'mousedown': {
                    'button': 0,
                    'which': 1
                },
                'mouseup': {
                    'button': 0,
                    'which': 1
                },
                'click': {
                    'button': 0,
                    'which': 1
                }
            }
        },
        msie: {
            'right': {
                'mousedown': { 'button': 2 },
                'mouseup': { 'button': 2 },
                'contextmenu': { 'button': 0 }
            },
            'left': {
                'mousedown': { 'button': 1 },
                'mouseup': { 'button': 1 },
                'click': { 'button': 0 }
            }
        },
        chrome: {
            'right': {
                'mousedown': {
                    'button': 2,
                    'which': 3
                },
                'mouseup': {
                    'button': 2,
                    'which': 3
                },
                'contextmenu': {
                    'button': 2,
                    'which': 3
                }
            },
            'left': {
                'mousedown': {
                    'button': 0,
                    'which': 1
                },
                'mouseup': {
                    'button': 0,
                    'which': 1
                },
                'click': {
                    'button': 0,
                    'which': 1
                }
            }
        },
        gecko: {
            'left': {
                'mousedown': {
                    'button': 0,
                    'which': 1
                },
                'mouseup': {
                    'button': 0,
                    'which': 1
                },
                'click': {
                    'button': 0,
                    'which': 1
                }
            },
            'right': {
                'mousedown': {
                    'button': 2,
                    'which': 3
                },
                'mouseup': {
                    'button': 2,
                    'which': 3
                },
                'contextmenu': {
                    'button': 2,
                    'which': 3
                }
            }
        }
    };
    syn.key.browser = function () {
        if (syn.key.browsers[window.navigator.userAgent]) {
            return syn.key.browsers[window.navigator.userAgent];
        }
        for (var browser in syn.browser) {
            if (syn.browser[browser] && syn.key.browsers[browser]) {
                return syn.key.browsers[browser];
            }
        }
        return syn.key.browsers.gecko;
    }();
    syn.mouse.browser = function () {
        if (syn.mouse.browsers[window.navigator.userAgent]) {
            return syn.mouse.browsers[window.navigator.userAgent];
        }
        for (var browser in syn.browser) {
            if (syn.browser[browser] && syn.mouse.browsers[browser]) {
                return syn.mouse.browsers[browser];
            }
        }
        return syn.mouse.browsers.gecko;
    }();
});
/*syn@0.4.2#dist/cjs/typeable.js*/
define('syn@0.4.2#dist/cjs/typeable.js', function (require, exports, module) {
    var syn = require('./synthetic.js');
    var typeables = [];
    var __indexOf = [].indexOf || function (item) {
        for (var i = 0, l = this.length; i < l; i++) {
            if (i in this && this[i] === item) {
                return i;
            }
        }
        return -1;
    };
    syn.typeable = function (fn) {
        if (__indexOf.call(typeables, fn) === -1) {
            typeables.push(fn);
        }
    };
    syn.typeable.test = function (el) {
        for (var i = 0, len = typeables.length; i < len; i++) {
            if (typeables[i](el)) {
                return true;
            }
        }
        return false;
    };
    var type = syn.typeable;
    var typeableExp = /input|textarea/i;
    type(function (el) {
        return typeableExp.test(el.nodeName);
    });
    type(function (el) {
        return __indexOf.call([
            '',
            'true'
        ], el.getAttribute('contenteditable')) !== -1;
    });
});
/*syn@0.4.2#dist/cjs/key.js*/
define('syn@0.4.2#dist/cjs/key.js', function (require, exports, module) {
    var syn = require('./synthetic.js');
    require('./typeable.js');
    require('./browsers.js');
    var h = syn.helpers, formElExp = /input|textarea/i, supportsSelection = function (el) {
            var result;
            try {
                result = el.selectionStart !== undefined && el.selectionStart !== null;
            } catch (e) {
                result = false;
            }
            return result;
        }, getSelection = function (el) {
            var real, r, start;
            if (supportsSelection(el)) {
                if (document.activeElement && document.activeElement !== el && el.selectionStart === el.selectionEnd && el.selectionStart === 0) {
                    return {
                        start: el.value.length,
                        end: el.value.length
                    };
                }
                return {
                    start: el.selectionStart,
                    end: el.selectionEnd
                };
            } else {
                try {
                    if (el.nodeName.toLowerCase() === 'input') {
                        real = h.getWindow(el).document.selection.createRange();
                        r = el.createTextRange();
                        r.setEndPoint('EndToStart', real);
                        start = r.text.length;
                        return {
                            start: start,
                            end: start + real.text.length
                        };
                    } else {
                        real = h.getWindow(el).document.selection.createRange();
                        r = real.duplicate();
                        var r2 = real.duplicate(), r3 = real.duplicate();
                        r2.collapse();
                        r3.collapse(false);
                        r2.moveStart('character', -1);
                        r3.moveStart('character', -1);
                        r.moveToElementText(el);
                        r.setEndPoint('EndToEnd', real);
                        start = r.text.length - real.text.length;
                        var end = r.text.length;
                        if (start !== 0 && r2.text === '') {
                            start += 2;
                        }
                        if (end !== 0 && r3.text === '') {
                            end += 2;
                        }
                        return {
                            start: start,
                            end: end
                        };
                    }
                } catch (e) {
                    var prop = formElExp.test(el.nodeName) ? 'value' : 'textContent';
                    return {
                        start: el[prop].length,
                        end: el[prop].length
                    };
                }
            }
        }, getFocusable = function (el) {
            var document = h.getWindow(el).document, res = [];
            var els = document.getElementsByTagName('*'), len = els.length;
            for (var i = 0; i < len; i++) {
                if (syn.isFocusable(els[i]) && els[i] !== document.documentElement) {
                    res.push(els[i]);
                }
            }
            return res;
        }, textProperty = function () {
            var el = document.createElement('span');
            return el.textContent != null ? 'textContent' : 'innerText';
        }(), getText = function (el) {
            if (formElExp.test(el.nodeName)) {
                return el.value;
            }
            return el[textProperty];
        }, setText = function (el, value) {
            if (formElExp.test(el.nodeName)) {
                el.value = value;
            } else {
                el[textProperty] = value;
            }
        };
    h.extend(syn, {
        keycodes: {
            '\b': 8,
            '\t': 9,
            '\r': 13,
            'shift': 16,
            'ctrl': 17,
            'alt': 18,
            'pause-break': 19,
            'caps': 20,
            'escape': 27,
            'num-lock': 144,
            'scroll-lock': 145,
            'print': 44,
            'page-up': 33,
            'page-down': 34,
            'end': 35,
            'home': 36,
            'left': 37,
            'up': 38,
            'right': 39,
            'down': 40,
            'insert': 45,
            'delete': 46,
            ' ': 32,
            '0': 48,
            '1': 49,
            '2': 50,
            '3': 51,
            '4': 52,
            '5': 53,
            '6': 54,
            '7': 55,
            '8': 56,
            '9': 57,
            'a': 65,
            'b': 66,
            'c': 67,
            'd': 68,
            'e': 69,
            'f': 70,
            'g': 71,
            'h': 72,
            'i': 73,
            'j': 74,
            'k': 75,
            'l': 76,
            'm': 77,
            'n': 78,
            'o': 79,
            'p': 80,
            'q': 81,
            'r': 82,
            's': 83,
            't': 84,
            'u': 85,
            'v': 86,
            'w': 87,
            'x': 88,
            'y': 89,
            'z': 90,
            'num0': 96,
            'num1': 97,
            'num2': 98,
            'num3': 99,
            'num4': 100,
            'num5': 101,
            'num6': 102,
            'num7': 103,
            'num8': 104,
            'num9': 105,
            '*': 106,
            '+': 107,
            'subtract': 109,
            'decimal': 110,
            'divide': 111,
            ';': 186,
            '=': 187,
            ',': 188,
            'dash': 189,
            '-': 189,
            'period': 190,
            '.': 190,
            'forward-slash': 191,
            '/': 191,
            '`': 192,
            '[': 219,
            '\\': 220,
            ']': 221,
            '\'': 222,
            'left window key': 91,
            'right window key': 92,
            'select key': 93,
            'f1': 112,
            'f2': 113,
            'f3': 114,
            'f4': 115,
            'f5': 116,
            'f6': 117,
            'f7': 118,
            'f8': 119,
            'f9': 120,
            'f10': 121,
            'f11': 122,
            'f12': 123
        },
        selectText: function (el, start, end) {
            if (supportsSelection(el)) {
                if (!end) {
                    syn.__tryFocus(el);
                    el.setSelectionRange(start, start);
                } else {
                    el.selectionStart = start;
                    el.selectionEnd = end;
                }
            } else if (el.createTextRange) {
                var r = el.createTextRange();
                r.moveStart('character', start);
                end = end || start;
                r.moveEnd('character', end - el.value.length);
                r.select();
            }
        },
        getText: function (el) {
            if (syn.typeable.test(el)) {
                var sel = getSelection(el);
                return el.value.substring(sel.start, sel.end);
            }
            var win = syn.helpers.getWindow(el);
            if (win.getSelection) {
                return win.getSelection().toString();
            } else if (win.document.getSelection) {
                return win.document.getSelection().toString();
            } else {
                return win.document.selection.createRange().text;
            }
        },
        getSelection: getSelection
    });
    h.extend(syn.key, {
        data: function (key) {
            if (syn.key.browser[key]) {
                return syn.key.browser[key];
            }
            for (var kind in syn.key.kinds) {
                if (h.inArray(key, syn.key.kinds[kind]) > -1) {
                    return syn.key.browser[kind];
                }
            }
            return syn.key.browser.character;
        },
        isSpecial: function (keyCode) {
            var specials = syn.key.kinds.special;
            for (var i = 0; i < specials.length; i++) {
                if (syn.keycodes[specials[i]] === keyCode) {
                    return specials[i];
                }
            }
        },
        options: function (key, event) {
            var keyData = syn.key.data(key);
            if (!keyData[event]) {
                return null;
            }
            var charCode = keyData[event][0], keyCode = keyData[event][1], result = {};
            if (keyCode === 'key') {
                result.keyCode = syn.keycodes[key];
            } else if (keyCode === 'char') {
                result.keyCode = key.charCodeAt(0);
            } else {
                result.keyCode = keyCode;
            }
            if (charCode === 'char') {
                result.charCode = key.charCodeAt(0);
            } else if (charCode !== null) {
                result.charCode = charCode;
            }
            if (result.keyCode) {
                result.which = result.keyCode;
            } else {
                result.which = result.charCode;
            }
            return result;
        },
        kinds: {
            special: [
                'shift',
                'ctrl',
                'alt',
                'caps'
            ],
            specialChars: ['\b'],
            navigation: [
                'page-up',
                'page-down',
                'end',
                'home',
                'left',
                'up',
                'right',
                'down',
                'insert',
                'delete'
            ],
            'function': [
                'f1',
                'f2',
                'f3',
                'f4',
                'f5',
                'f6',
                'f7',
                'f8',
                'f9',
                'f10',
                'f11',
                'f12'
            ]
        },
        getDefault: function (key) {
            if (syn.key.defaults[key]) {
                return syn.key.defaults[key];
            }
            for (var kind in syn.key.kinds) {
                if (h.inArray(key, syn.key.kinds[kind]) > -1 && syn.key.defaults[kind]) {
                    return syn.key.defaults[kind];
                }
            }
            return syn.key.defaults.character;
        },
        defaults: {
            'character': function (options, scope, key, force, sel) {
                if (/num\d+/.test(key)) {
                    key = key.match(/\d+/)[0];
                }
                if (force || !syn.support.keyCharacters && syn.typeable.test(this)) {
                    var current = getText(this), before = current.substr(0, sel.start), after = current.substr(sel.end), character = key;
                    setText(this, before + character + after);
                    var charLength = character === '\n' && syn.support.textareaCarriage ? 2 : character.length;
                    syn.selectText(this, before.length + charLength);
                }
            },
            'c': function (options, scope, key, force, sel) {
                if (syn.key.ctrlKey) {
                    syn.key.clipboard = syn.getText(this);
                } else {
                    syn.key.defaults.character.apply(this, arguments);
                }
            },
            'v': function (options, scope, key, force, sel) {
                if (syn.key.ctrlKey) {
                    syn.key.defaults.character.call(this, options, scope, syn.key.clipboard, true, sel);
                } else {
                    syn.key.defaults.character.apply(this, arguments);
                }
            },
            'a': function (options, scope, key, force, sel) {
                if (syn.key.ctrlKey) {
                    syn.selectText(this, 0, getText(this).length);
                } else {
                    syn.key.defaults.character.apply(this, arguments);
                }
            },
            'home': function () {
                syn.onParents(this, function (el) {
                    if (el.scrollHeight !== el.clientHeight) {
                        el.scrollTop = 0;
                        return false;
                    }
                });
            },
            'end': function () {
                syn.onParents(this, function (el) {
                    if (el.scrollHeight !== el.clientHeight) {
                        el.scrollTop = el.scrollHeight;
                        return false;
                    }
                });
            },
            'page-down': function () {
                syn.onParents(this, function (el) {
                    if (el.scrollHeight !== el.clientHeight) {
                        var ch = el.clientHeight;
                        el.scrollTop += ch;
                        return false;
                    }
                });
            },
            'page-up': function () {
                syn.onParents(this, function (el) {
                    if (el.scrollHeight !== el.clientHeight) {
                        var ch = el.clientHeight;
                        el.scrollTop -= ch;
                        return false;
                    }
                });
            },
            '\b': function (options, scope, key, force, sel) {
                if (!syn.support.backspaceWorks && syn.typeable.test(this)) {
                    var current = getText(this), before = current.substr(0, sel.start), after = current.substr(sel.end);
                    if (sel.start === sel.end && sel.start > 0) {
                        setText(this, before.substring(0, before.length - 1) + after);
                        syn.selectText(this, sel.start - 1);
                    } else {
                        setText(this, before + after);
                        syn.selectText(this, sel.start);
                    }
                }
            },
            'delete': function (options, scope, key, force, sel) {
                if (!syn.support.backspaceWorks && syn.typeable.test(this)) {
                    var current = getText(this), before = current.substr(0, sel.start), after = current.substr(sel.end);
                    if (sel.start === sel.end && sel.start <= getText(this).length - 1) {
                        setText(this, before + after.substring(1));
                    } else {
                        setText(this, before + after);
                    }
                    syn.selectText(this, sel.start);
                }
            },
            '\r': function (options, scope, key, force, sel) {
                var nodeName = this.nodeName.toLowerCase();
                if (nodeName === 'input') {
                    syn.trigger(this, 'change', {});
                }
                if (!syn.support.keypressSubmits && nodeName === 'input') {
                    var form = syn.closest(this, 'form');
                    if (form) {
                        syn.trigger(form, 'submit', {});
                    }
                }
                if (!syn.support.keyCharacters && nodeName === 'textarea') {
                    syn.key.defaults.character.call(this, options, scope, '\n', undefined, sel);
                }
                if (!syn.support.keypressOnAnchorClicks && nodeName === 'a') {
                    syn.trigger(this, 'click', {});
                }
            },
            '\t': function (options, scope) {
                var focusEls = getFocusable(this), current = null, i = 0, el, firstNotIndexed, orders = [];
                for (; i < focusEls.length; i++) {
                    orders.push([
                        focusEls[i],
                        i
                    ]);
                }
                var sort = function (order1, order2) {
                    var el1 = order1[0], el2 = order2[0], tab1 = syn.tabIndex(el1) || 0, tab2 = syn.tabIndex(el2) || 0;
                    if (tab1 === tab2) {
                        return order1[1] - order2[1];
                    } else {
                        if (tab1 === 0) {
                            return 1;
                        } else if (tab2 === 0) {
                            return -1;
                        } else {
                            return tab1 - tab2;
                        }
                    }
                };
                orders.sort(sort);
                for (i = 0; i < orders.length; i++) {
                    el = orders[i][0];
                    if (this === el) {
                        if (!syn.key.shiftKey) {
                            current = orders[i + 1][0];
                            if (!current) {
                                current = orders[0][0];
                            }
                        } else {
                            current = orders[i - 1][0];
                            if (!current) {
                                current = orders[focusEls.length - 1][0];
                            }
                        }
                    }
                }
                if (!current) {
                    current = firstNotIndexed;
                } else {
                    syn.__tryFocus(current);
                }
                return current;
            },
            'left': function (options, scope, key, force, sel) {
                if (syn.typeable.test(this)) {
                    if (syn.key.shiftKey) {
                        syn.selectText(this, sel.start === 0 ? 0 : sel.start - 1, sel.end);
                    } else {
                        syn.selectText(this, sel.start === 0 ? 0 : sel.start - 1);
                    }
                }
            },
            'right': function (options, scope, key, force, sel) {
                if (syn.typeable.test(this)) {
                    if (syn.key.shiftKey) {
                        syn.selectText(this, sel.start, sel.end + 1 > getText(this).length ? getText(this).length : sel.end + 1);
                    } else {
                        syn.selectText(this, sel.end + 1 > getText(this).length ? getText(this).length : sel.end + 1);
                    }
                }
            },
            'up': function () {
                if (/select/i.test(this.nodeName)) {
                    this.selectedIndex = this.selectedIndex ? this.selectedIndex - 1 : 0;
                }
            },
            'down': function () {
                if (/select/i.test(this.nodeName)) {
                    syn.changeOnBlur(this, 'selectedIndex', this.selectedIndex);
                    this.selectedIndex = this.selectedIndex + 1;
                }
            },
            'shift': function () {
                return null;
            },
            'ctrl': function () {
                return null;
            }
        }
    });
    h.extend(syn.create, {
        keydown: {
            setup: function (type, options, element) {
                if (h.inArray(options, syn.key.kinds.special) !== -1) {
                    syn.key[options + 'Key'] = element;
                }
            }
        },
        keypress: {
            setup: function (type, options, element) {
                if (syn.support.keyCharacters && !syn.support.keysOnNotFocused) {
                    syn.__tryFocus(element);
                }
            }
        },
        keyup: {
            setup: function (type, options, element) {
                if (h.inArray(options, syn.key.kinds.special) !== -1) {
                    syn.key[options + 'Key'] = null;
                }
            }
        },
        key: {
            options: function (type, options, element) {
                options = typeof options !== 'object' ? { character: options } : options;
                options = h.extend({}, options);
                if (options.character) {
                    h.extend(options, syn.key.options(options.character, type));
                    delete options.character;
                }
                options = h.extend({
                    ctrlKey: !!syn.key.ctrlKey,
                    altKey: !!syn.key.altKey,
                    shiftKey: !!syn.key.shiftKey,
                    metaKey: !!syn.key.metaKey
                }, options);
                return options;
            },
            event: function (type, options, element) {
                var doc = h.getWindow(element).document || document, event;
                if (doc.createEvent) {
                    try {
                        event = doc.createEvent('KeyEvents');
                        event.initKeyEvent(type, true, true, window, options.ctrlKey, options.altKey, options.shiftKey, options.metaKey, options.keyCode, options.charCode);
                    } catch (e) {
                        event = h.createBasicStandardEvent(type, options, doc);
                    }
                    event.synthetic = true;
                    return event;
                } else {
                    try {
                        event = h.createEventObject.apply(this, arguments);
                        h.extend(event, options);
                    } catch (e) {
                    }
                    return event;
                }
            }
        }
    });
    var convert = {
        'enter': '\r',
        'backspace': '\b',
        'tab': '\t',
        'space': ' '
    };
    h.extend(syn.init.prototype, {
        _key: function (element, options, callback) {
            if (/-up$/.test(options) && h.inArray(options.replace('-up', ''), syn.key.kinds.special) !== -1) {
                syn.trigger(element, 'keyup', options.replace('-up', ''));
                return callback(true, element);
            }
            var activeElement = h.getWindow(element).document.activeElement, caret = syn.typeable.test(element) && getSelection(element), key = convert[options] || options, runDefaults = syn.trigger(element, 'keydown', key), getDefault = syn.key.getDefault, prevent = syn.key.browser.prevent, defaultResult, keypressOptions = syn.key.options(key, 'keypress');
            if (runDefaults) {
                if (!keypressOptions) {
                    defaultResult = getDefault(key).call(element, keypressOptions, h.getWindow(element), key, undefined, caret);
                } else {
                    if (activeElement !== h.getWindow(element).document.activeElement) {
                        element = h.getWindow(element).document.activeElement;
                    }
                    runDefaults = syn.trigger(element, 'keypress', keypressOptions);
                    if (runDefaults) {
                        defaultResult = getDefault(key).call(element, keypressOptions, h.getWindow(element), key, undefined, caret);
                    }
                }
            } else {
                if (keypressOptions && h.inArray('keypress', prevent.keydown) === -1) {
                    if (activeElement !== h.getWindow(element).document.activeElement) {
                        element = h.getWindow(element).document.activeElement;
                    }
                    syn.trigger(element, 'keypress', keypressOptions);
                }
            }
            if (defaultResult && defaultResult.nodeName) {
                element = defaultResult;
            }
            if (defaultResult !== null) {
                syn.schedule(function () {
                    if (syn.support.oninput) {
                        syn.trigger(element, 'input', syn.key.options(key, 'input'));
                    }
                    syn.trigger(element, 'keyup', syn.key.options(key, 'keyup'));
                    callback(runDefaults, element);
                }, 1);
            } else {
                callback(runDefaults, element);
            }
            return element;
        },
        _type: function (element, options, callback) {
            var parts = (options + '').match(/(\[[^\]]+\])|([^\[])/g), self = this, runNextPart = function (runDefaults, el) {
                    var part = parts.shift();
                    if (!part) {
                        callback(runDefaults, el);
                        return;
                    }
                    el = el || element;
                    if (part.length > 1) {
                        part = part.substr(1, part.length - 2);
                    }
                    self._key(el, part, runNextPart);
                };
            runNextPart();
        }
    });
});
/*syn@0.4.2#dist/cjs/key.support.js*/
define('syn@0.4.2#dist/cjs/key.support.js', function (require, exports, module) {
    var syn = require('./synthetic.js');
    require('./key.js');
    if (!syn.config.support) {
        (function checkForSupport() {
            if (!document.body) {
                return syn.schedule(checkForSupport, 1);
            }
            var div = document.createElement('div'), checkbox, submit, form, anchor, textarea, inputter, one, doc;
            doc = document.documentElement;
            div.innerHTML = '<form id=\'outer\'>' + '<input name=\'checkbox\' type=\'checkbox\'/>' + '<input name=\'radio\' type=\'radio\' />' + '<input type=\'submit\' name=\'submitter\'/>' + '<input type=\'input\' name=\'inputter\'/>' + '<input name=\'one\'>' + '<input name=\'two\'/>' + '<a href=\'#abc\'></a>' + '<textarea>1\n2</textarea>' + '</form>';
            doc.insertBefore(div, doc.firstElementChild || doc.children[0]);
            form = div.firstChild;
            checkbox = form.childNodes[0];
            submit = form.childNodes[2];
            anchor = form.getElementsByTagName('a')[0];
            textarea = form.getElementsByTagName('textarea')[0];
            inputter = form.childNodes[3];
            one = form.childNodes[4];
            form.onsubmit = function (ev) {
                if (ev.preventDefault) {
                    ev.preventDefault();
                }
                syn.support.keypressSubmits = true;
                ev.returnValue = false;
                return false;
            };
            syn.__tryFocus(inputter);
            syn.trigger(inputter, 'keypress', '\r');
            syn.trigger(inputter, 'keypress', 'a');
            syn.support.keyCharacters = inputter.value === 'a';
            inputter.value = 'a';
            syn.trigger(inputter, 'keypress', '\b');
            syn.support.backspaceWorks = inputter.value === '';
            inputter.onchange = function () {
                syn.support.focusChanges = true;
            };
            syn.__tryFocus(inputter);
            syn.trigger(inputter, 'keypress', 'a');
            syn.__tryFocus(form.childNodes[5]);
            syn.trigger(inputter, 'keypress', 'b');
            syn.support.keysOnNotFocused = inputter.value === 'ab';
            syn.bind(anchor, 'click', function (ev) {
                if (ev.preventDefault) {
                    ev.preventDefault();
                }
                syn.support.keypressOnAnchorClicks = true;
                ev.returnValue = false;
                return false;
            });
            syn.trigger(anchor, 'keypress', '\r');
            syn.support.textareaCarriage = textarea.value.length === 4;
            syn.support.oninput = 'oninput' in one;
            doc.removeChild(div);
            syn.support.ready++;
        }());
    } else {
        syn.helpers.extend(syn.support, syn.config.support);
    }
});
/*syn@0.4.2#dist/cjs/drag.js*/
define('syn@0.4.2#dist/cjs/drag.js', function (require, exports, module) {
    var syn = require('./synthetic.js');
    (function dragSupport() {
        if (!document.body) {
            syn.schedule(dragSupport, 1);
            return;
        }
        var div = document.createElement('div');
        document.body.appendChild(div);
        syn.helpers.extend(div.style, {
            width: '100px',
            height: '10000px',
            backgroundColor: 'blue',
            position: 'absolute',
            top: '10px',
            left: '0px',
            zIndex: 19999
        });
        document.body.scrollTop = 11;
        if (!document.elementFromPoint) {
            return;
        }
        var el = document.elementFromPoint(3, 1);
        if (el === div) {
            syn.support.elementFromClient = true;
        } else {
            syn.support.elementFromPage = true;
        }
        document.body.removeChild(div);
        document.body.scrollTop = 0;
    }());
    var elementFromPoint = function (point, element) {
            var clientX = point.clientX, clientY = point.clientY, win = syn.helpers.getWindow(element), el;
            if (syn.support.elementFromPage) {
                var off = syn.helpers.scrollOffset(win);
                clientX = clientX + off.left;
                clientY = clientY + off.top;
            }
            el = win.document.elementFromPoint ? win.document.elementFromPoint(clientX, clientY) : element;
            if (el === win.document.documentElement && (point.clientY < 0 || point.clientX < 0)) {
                return element;
            } else {
                return el;
            }
        }, createEventAtPoint = function (event, point, element) {
            var el = elementFromPoint(point, element);
            syn.trigger(el || element, event, point);
            return el;
        }, mouseMove = function (point, element, last) {
            var el = elementFromPoint(point, element);
            if (last !== el && el && last) {
                var options = syn.helpers.extend({}, point);
                options.relatedTarget = el;
                syn.trigger(last, 'mouseout', options);
                options.relatedTarget = last;
                syn.trigger(el, 'mouseover', options);
            }
            syn.trigger(el || element, 'mousemove', point);
            return el;
        }, startMove = function (start, end, duration, element, callback) {
            var startTime = new Date(), distX = end.clientX - start.clientX, distY = end.clientY - start.clientY, win = syn.helpers.getWindow(element), current = elementFromPoint(start, element), cursor = win.document.createElement('div'), calls = 0, move;
            move = function onmove() {
                var now = new Date(), scrollOffset = syn.helpers.scrollOffset(win), fraction = (calls === 0 ? 0 : now - startTime) / duration, options = {
                        clientX: distX * fraction + start.clientX,
                        clientY: distY * fraction + start.clientY
                    };
                calls++;
                if (fraction < 1) {
                    syn.helpers.extend(cursor.style, {
                        left: options.clientX + scrollOffset.left + 2 + 'px',
                        top: options.clientY + scrollOffset.top + 2 + 'px'
                    });
                    current = mouseMove(options, element, current);
                    syn.schedule(onmove, 15);
                } else {
                    current = mouseMove(end, element, current);
                    win.document.body.removeChild(cursor);
                    callback();
                }
            };
            syn.helpers.extend(cursor.style, {
                height: '5px',
                width: '5px',
                backgroundColor: 'red',
                position: 'absolute',
                zIndex: 19999,
                fontSize: '1px'
            });
            win.document.body.appendChild(cursor);
            move();
        }, startDrag = function (start, end, duration, element, callback) {
            createEventAtPoint('mousedown', start, element);
            startMove(start, end, duration, element, function () {
                createEventAtPoint('mouseup', end, element);
                callback();
            });
        }, center = function (el) {
            var j = syn.jquery()(el), o = j.offset();
            return {
                pageX: o.left + j.outerWidth() / 2,
                pageY: o.top + j.outerHeight() / 2
            };
        }, convertOption = function (option, win, from) {
            var page = /(\d+)[x ](\d+)/, client = /(\d+)X(\d+)/, relative = /([+-]\d+)[xX ]([+-]\d+)/, parts;
            if (typeof option === 'string' && relative.test(option) && from) {
                var cent = center(from);
                parts = option.match(relative);
                option = {
                    pageX: cent.pageX + parseInt(parts[1]),
                    pageY: cent.pageY + parseInt(parts[2])
                };
            }
            if (typeof option === 'string' && page.test(option)) {
                parts = option.match(page);
                option = {
                    pageX: parseInt(parts[1]),
                    pageY: parseInt(parts[2])
                };
            }
            if (typeof option === 'string' && client.test(option)) {
                parts = option.match(client);
                option = {
                    clientX: parseInt(parts[1]),
                    clientY: parseInt(parts[2])
                };
            }
            if (typeof option === 'string') {
                option = syn.jquery()(option, win.document)[0];
            }
            if (option.nodeName) {
                option = center(option);
            }
            if (option.pageX != null) {
                var off = syn.helpers.scrollOffset(win);
                option = {
                    clientX: option.pageX - off.left,
                    clientY: option.pageY - off.top
                };
            }
            return option;
        }, adjust = function (from, to, win) {
            if (from.clientY < 0) {
                var off = syn.helpers.scrollOffset(win);
                var top = off.top + from.clientY - 100, diff = top - off.top;
                if (top > 0) {
                } else {
                    top = 0;
                    diff = -off.top;
                }
                from.clientY = from.clientY - diff;
                to.clientY = to.clientY - diff;
                syn.helpers.scrollOffset(win, {
                    top: top,
                    left: off.left
                });
            }
        };
    syn.helpers.extend(syn.init.prototype, {
        _move: function (from, options, callback) {
            var win = syn.helpers.getWindow(from), fro = convertOption(options.from || from, win, from), to = convertOption(options.to || options, win, from);
            if (options.adjust !== false) {
                adjust(fro, to, win);
            }
            startMove(fro, to, options.duration || 500, from, callback);
        },
        _drag: function (from, options, callback) {
            var win = syn.helpers.getWindow(from), fro = convertOption(options.from || from, win, from), to = convertOption(options.to || options, win, from);
            if (options.adjust !== false) {
                adjust(fro, to, win);
            }
            startDrag(fro, to, options.duration || 500, from, callback);
        }
    });
});
/*syn@0.4.2#dist/cjs/syn*/
define('syn@0.4.2#dist/cjs/syn', function (require, exports, module) {
    var syn = require('./synthetic.js');
    require('./mouse.support.js');
    require('./browsers.js');
    require('./key.support.js');
    require('./drag.js');
    window.syn = syn;
    module.exports = syn;
});
/*jquery@1.11.0#dist/jquery*/
(function (global, factory) {
    if (typeof module === 'object' && typeof module.exports === 'object') {
        module.exports = global.document ? factory(global, true) : function (w) {
            if (!w.document) {
                throw new Error('jQuery requires a window with a document');
            }
            return factory(w);
        };
    } else {
        factory(global);
    }
}(typeof window !== 'undefined' ? window : this, function (window, noGlobal) {
    var deletedIds = [];
    var slice = deletedIds.slice;
    var concat = deletedIds.concat;
    var push = deletedIds.push;
    var indexOf = deletedIds.indexOf;
    var class2type = {};
    var toString = class2type.toString;
    var hasOwn = class2type.hasOwnProperty;
    var trim = ''.trim;
    var support = {};
    var version = '1.11.0', jQuery = function (selector, context) {
            return new jQuery.fn.init(selector, context);
        }, rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, rmsPrefix = /^-ms-/, rdashAlpha = /-([\da-z])/gi, fcamelCase = function (all, letter) {
            return letter.toUpperCase();
        };
    jQuery.fn = jQuery.prototype = {
        jquery: version,
        constructor: jQuery,
        selector: '',
        length: 0,
        toArray: function () {
            return slice.call(this);
        },
        get: function (num) {
            return num != null ? num < 0 ? this[num + this.length] : this[num] : slice.call(this);
        },
        pushStack: function (elems) {
            var ret = jQuery.merge(this.constructor(), elems);
            ret.prevObject = this;
            ret.context = this.context;
            return ret;
        },
        each: function (callback, args) {
            return jQuery.each(this, callback, args);
        },
        map: function (callback) {
            return this.pushStack(jQuery.map(this, function (elem, i) {
                return callback.call(elem, i, elem);
            }));
        },
        slice: function () {
            return this.pushStack(slice.apply(this, arguments));
        },
        first: function () {
            return this.eq(0);
        },
        last: function () {
            return this.eq(-1);
        },
        eq: function (i) {
            var len = this.length, j = +i + (i < 0 ? len : 0);
            return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
        },
        end: function () {
            return this.prevObject || this.constructor(null);
        },
        push: push,
        sort: deletedIds.sort,
        splice: deletedIds.splice
    };
    jQuery.extend = jQuery.fn.extend = function () {
        var src, copyIsArray, copy, name, options, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
        if (typeof target === 'boolean') {
            deep = target;
            target = arguments[i] || {};
            i++;
        }
        if (typeof target !== 'object' && !jQuery.isFunction(target)) {
            target = {};
        }
        if (i === length) {
            target = this;
            i--;
        }
        for (; i < length; i++) {
            if ((options = arguments[i]) != null) {
                for (name in options) {
                    src = target[name];
                    copy = options[name];
                    if (target === copy) {
                        continue;
                    }
                    if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
                        if (copyIsArray) {
                            copyIsArray = false;
                            clone = src && jQuery.isArray(src) ? src : [];
                        } else {
                            clone = src && jQuery.isPlainObject(src) ? src : {};
                        }
                        target[name] = jQuery.extend(deep, clone, copy);
                    } else if (copy !== undefined) {
                        target[name] = copy;
                    }
                }
            }
        }
        return target;
    };
    jQuery.extend({
        expando: 'jQuery' + (version + Math.random()).replace(/\D/g, ''),
        isReady: true,
        error: function (msg) {
            throw new Error(msg);
        },
        noop: function () {
        },
        isFunction: function (obj) {
            return jQuery.type(obj) === 'function';
        },
        isArray: Array.isArray || function (obj) {
            return jQuery.type(obj) === 'array';
        },
        isWindow: function (obj) {
            return obj != null && obj == obj.window;
        },
        isNumeric: function (obj) {
            return obj - parseFloat(obj) >= 0;
        },
        isEmptyObject: function (obj) {
            var name;
            for (name in obj) {
                return false;
            }
            return true;
        },
        isPlainObject: function (obj) {
            var key;
            if (!obj || jQuery.type(obj) !== 'object' || obj.nodeType || jQuery.isWindow(obj)) {
                return false;
            }
            try {
                if (obj.constructor && !hasOwn.call(obj, 'constructor') && !hasOwn.call(obj.constructor.prototype, 'isPrototypeOf')) {
                    return false;
                }
            } catch (e) {
                return false;
            }
            if (support.ownLast) {
                for (key in obj) {
                    return hasOwn.call(obj, key);
                }
            }
            for (key in obj) {
            }
            return key === undefined || hasOwn.call(obj, key);
        },
        type: function (obj) {
            if (obj == null) {
                return obj + '';
            }
            return typeof obj === 'object' || typeof obj === 'function' ? class2type[toString.call(obj)] || 'object' : typeof obj;
        },
        globalEval: function (data) {
            if (data && jQuery.trim(data)) {
                (window.execScript || function (data) {
                    window['eval'].call(window, data);
                })(data);
            }
        },
        camelCase: function (string) {
            return string.replace(rmsPrefix, 'ms-').replace(rdashAlpha, fcamelCase);
        },
        nodeName: function (elem, name) {
            return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
        },
        each: function (obj, callback, args) {
            var value, i = 0, length = obj.length, isArray = isArraylike(obj);
            if (args) {
                if (isArray) {
                    for (; i < length; i++) {
                        value = callback.apply(obj[i], args);
                        if (value === false) {
                            break;
                        }
                    }
                } else {
                    for (i in obj) {
                        value = callback.apply(obj[i], args);
                        if (value === false) {
                            break;
                        }
                    }
                }
            } else {
                if (isArray) {
                    for (; i < length; i++) {
                        value = callback.call(obj[i], i, obj[i]);
                        if (value === false) {
                            break;
                        }
                    }
                } else {
                    for (i in obj) {
                        value = callback.call(obj[i], i, obj[i]);
                        if (value === false) {
                            break;
                        }
                    }
                }
            }
            return obj;
        },
        trim: trim && !trim.call('\uFEFF\xA0') ? function (text) {
            return text == null ? '' : trim.call(text);
        } : function (text) {
            return text == null ? '' : (text + '').replace(rtrim, '');
        },
        makeArray: function (arr, results) {
            var ret = results || [];
            if (arr != null) {
                if (isArraylike(Object(arr))) {
                    jQuery.merge(ret, typeof arr === 'string' ? [arr] : arr);
                } else {
                    push.call(ret, arr);
                }
            }
            return ret;
        },
        inArray: function (elem, arr, i) {
            var len;
            if (arr) {
                if (indexOf) {
                    return indexOf.call(arr, elem, i);
                }
                len = arr.length;
                i = i ? i < 0 ? Math.max(0, len + i) : i : 0;
                for (; i < len; i++) {
                    if (i in arr && arr[i] === elem) {
                        return i;
                    }
                }
            }
            return -1;
        },
        merge: function (first, second) {
            var len = +second.length, j = 0, i = first.length;
            while (j < len) {
                first[i++] = second[j++];
            }
            if (len !== len) {
                while (second[j] !== undefined) {
                    first[i++] = second[j++];
                }
            }
            first.length = i;
            return first;
        },
        grep: function (elems, callback, invert) {
            var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert;
            for (; i < length; i++) {
                callbackInverse = !callback(elems[i], i);
                if (callbackInverse !== callbackExpect) {
                    matches.push(elems[i]);
                }
            }
            return matches;
        },
        map: function (elems, callback, arg) {
            var value, i = 0, length = elems.length, isArray = isArraylike(elems), ret = [];
            if (isArray) {
                for (; i < length; i++) {
                    value = callback(elems[i], i, arg);
                    if (value != null) {
                        ret.push(value);
                    }
                }
            } else {
                for (i in elems) {
                    value = callback(elems[i], i, arg);
                    if (value != null) {
                        ret.push(value);
                    }
                }
            }
            return concat.apply([], ret);
        },
        guid: 1,
        proxy: function (fn, context) {
            var args, proxy, tmp;
            if (typeof context === 'string') {
                tmp = fn[context];
                context = fn;
                fn = tmp;
            }
            if (!jQuery.isFunction(fn)) {
                return undefined;
            }
            args = slice.call(arguments, 2);
            proxy = function () {
                return fn.apply(context || this, args.concat(slice.call(arguments)));
            };
            proxy.guid = fn.guid = fn.guid || jQuery.guid++;
            return proxy;
        },
        now: function () {
            return +new Date();
        },
        support: support
    });
    jQuery.each('Boolean Number String Function Array Date RegExp Object Error'.split(' '), function (i, name) {
        class2type['[object ' + name + ']'] = name.toLowerCase();
    });
    function isArraylike(obj) {
        var length = obj.length, type = jQuery.type(obj);
        if (type === 'function' || jQuery.isWindow(obj)) {
            return false;
        }
        if (obj.nodeType === 1 && length) {
            return true;
        }
        return type === 'array' || length === 0 || typeof length === 'number' && length > 0 && length - 1 in obj;
    }
    var Sizzle = function (window) {
        var i, support, Expr, getText, isXML, compile, outermostContext, sortInput, hasDuplicate, setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = 'sizzle' + -new Date(), preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), sortOrder = function (a, b) {
                if (a === b) {
                    hasDuplicate = true;
                }
                return 0;
            }, strundefined = typeof undefined, MAX_NEGATIVE = 1 << 31, hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push = arr.push, slice = arr.slice, indexOf = arr.indexOf || function (elem) {
                var i = 0, len = this.length;
                for (; i < len; i++) {
                    if (this[i] === elem) {
                        return i;
                    }
                }
                return -1;
            }, booleans = 'checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped', whitespace = '[\\x20\\t\\r\\n\\f]', characterEncoding = '(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+', identifier = characterEncoding.replace('w', 'w#'), attributes = '\\[' + whitespace + '*(' + characterEncoding + ')' + whitespace + '*(?:([*^$|!~]?=)' + whitespace + '*(?:([\'"])((?:\\\\.|[^\\\\])*?)\\3|(' + identifier + ')|)|)' + whitespace + '*\\]', pseudos = ':(' + characterEncoding + ')(?:\\((([\'"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|' + attributes.replace(3, 8) + ')*)|.*)\\)|)', rtrim = new RegExp('^' + whitespace + '+|((?:^|[^\\\\])(?:\\\\.)*)' + whitespace + '+$', 'g'), rcomma = new RegExp('^' + whitespace + '*,' + whitespace + '*'), rcombinators = new RegExp('^' + whitespace + '*([>+~]|' + whitespace + ')' + whitespace + '*'), rattributeQuotes = new RegExp('=' + whitespace + '*([^\\]\'"]*?)' + whitespace + '*\\]', 'g'), rpseudo = new RegExp(pseudos), ridentifier = new RegExp('^' + identifier + '$'), matchExpr = {
                'ID': new RegExp('^#(' + characterEncoding + ')'),
                'CLASS': new RegExp('^\\.(' + characterEncoding + ')'),
                'TAG': new RegExp('^(' + characterEncoding.replace('w', 'w*') + ')'),
                'ATTR': new RegExp('^' + attributes),
                'PSEUDO': new RegExp('^' + pseudos),
                'CHILD': new RegExp('^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(' + whitespace + '*(even|odd|(([+-]|)(\\d*)n|)' + whitespace + '*(?:([+-]|)' + whitespace + '*(\\d+)|))' + whitespace + '*\\)|)', 'i'),
                'bool': new RegExp('^(?:' + booleans + ')$', 'i'),
                'needsContext': new RegExp('^' + whitespace + '*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(' + whitespace + '*((?:-\\d)?\\d*)' + whitespace + '*\\)|)(?=[^-]|$)', 'i')
            }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, rescape = /'|\\/g, runescape = new RegExp('\\\\([\\da-f]{1,6}' + whitespace + '?|(' + whitespace + ')|.)', 'ig'), funescape = function (_, escaped, escapedWhitespace) {
                var high = '0x' + escaped - 65536;
                return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
            };
        try {
            push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
            arr[preferredDoc.childNodes.length].nodeType;
        } catch (e) {
            push = {
                apply: arr.length ? function (target, els) {
                    push_native.apply(target, slice.call(els));
                } : function (target, els) {
                    var j = target.length, i = 0;
                    while (target[j++] = els[i++]) {
                    }
                    target.length = j - 1;
                }
            };
        }
        function Sizzle(selector, context, results, seed) {
            var match, elem, m, nodeType, i, groups, old, nid, newContext, newSelector;
            if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
                setDocument(context);
            }
            context = context || document;
            results = results || [];
            if (!selector || typeof selector !== 'string') {
                return results;
            }
            if ((nodeType = context.nodeType) !== 1 && nodeType !== 9) {
                return [];
            }
            if (documentIsHTML && !seed) {
                if (match = rquickExpr.exec(selector)) {
                    if (m = match[1]) {
                        if (nodeType === 9) {
                            elem = context.getElementById(m);
                            if (elem && elem.parentNode) {
                                if (elem.id === m) {
                                    results.push(elem);
                                    return results;
                                }
                            } else {
                                return results;
                            }
                        } else {
                            if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m) {
                                results.push(elem);
                                return results;
                            }
                        }
                    } else if (match[2]) {
                        push.apply(results, context.getElementsByTagName(selector));
                        return results;
                    } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
                        push.apply(results, context.getElementsByClassName(m));
                        return results;
                    }
                }
                if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                    nid = old = expando;
                    newContext = context;
                    newSelector = nodeType === 9 && selector;
                    if (nodeType === 1 && context.nodeName.toLowerCase() !== 'object') {
                        groups = tokenize(selector);
                        if (old = context.getAttribute('id')) {
                            nid = old.replace(rescape, '\\$&');
                        } else {
                            context.setAttribute('id', nid);
                        }
                        nid = '[id=\'' + nid + '\'] ';
                        i = groups.length;
                        while (i--) {
                            groups[i] = nid + toSelector(groups[i]);
                        }
                        newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                        newSelector = groups.join(',');
                    }
                    if (newSelector) {
                        try {
                            push.apply(results, newContext.querySelectorAll(newSelector));
                            return results;
                        } catch (qsaError) {
                        } finally {
                            if (!old) {
                                context.removeAttribute('id');
                            }
                        }
                    }
                }
            }
            return select(selector.replace(rtrim, '$1'), context, results, seed);
        }
        function createCache() {
            var keys = [];
            function cache(key, value) {
                if (keys.push(key + ' ') > Expr.cacheLength) {
                    delete cache[keys.shift()];
                }
                return cache[key + ' '] = value;
            }
            return cache;
        }
        function markFunction(fn) {
            fn[expando] = true;
            return fn;
        }
        function assert(fn) {
            var div = document.createElement('div');
            try {
                return !!fn(div);
            } catch (e) {
                return false;
            } finally {
                if (div.parentNode) {
                    div.parentNode.removeChild(div);
                }
                div = null;
            }
        }
        function addHandle(attrs, handler) {
            var arr = attrs.split('|'), i = attrs.length;
            while (i--) {
                Expr.attrHandle[arr[i]] = handler;
            }
        }
        function siblingCheck(a, b) {
            var cur = b && a, diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
            if (diff) {
                return diff;
            }
            if (cur) {
                while (cur = cur.nextSibling) {
                    if (cur === b) {
                        return -1;
                    }
                }
            }
            return a ? 1 : -1;
        }
        function createInputPseudo(type) {
            return function (elem) {
                var name = elem.nodeName.toLowerCase();
                return name === 'input' && elem.type === type;
            };
        }
        function createButtonPseudo(type) {
            return function (elem) {
                var name = elem.nodeName.toLowerCase();
                return (name === 'input' || name === 'button') && elem.type === type;
            };
        }
        function createPositionalPseudo(fn) {
            return markFunction(function (argument) {
                argument = +argument;
                return markFunction(function (seed, matches) {
                    var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length;
                    while (i--) {
                        if (seed[j = matchIndexes[i]]) {
                            seed[j] = !(matches[j] = seed[j]);
                        }
                    }
                });
            });
        }
        function testContext(context) {
            return context && typeof context.getElementsByTagName !== strundefined && context;
        }
        support = Sizzle.support = {};
        isXML = Sizzle.isXML = function (elem) {
            var documentElement = elem && (elem.ownerDocument || elem).documentElement;
            return documentElement ? documentElement.nodeName !== 'HTML' : false;
        };
        setDocument = Sizzle.setDocument = function (node) {
            var hasCompare, doc = node ? node.ownerDocument || node : preferredDoc, parent = doc.defaultView;
            if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
                return document;
            }
            document = doc;
            docElem = doc.documentElement;
            documentIsHTML = !isXML(doc);
            if (parent && parent !== parent.top) {
                if (parent.addEventListener) {
                    parent.addEventListener('unload', function () {
                        setDocument();
                    }, false);
                } else if (parent.attachEvent) {
                    parent.attachEvent('onunload', function () {
                        setDocument();
                    });
                }
            }
            support.attributes = assert(function (div) {
                div.className = 'i';
                return !div.getAttribute('className');
            });
            support.getElementsByTagName = assert(function (div) {
                div.appendChild(doc.createComment(''));
                return !div.getElementsByTagName('*').length;
            });
            support.getElementsByClassName = rnative.test(doc.getElementsByClassName) && assert(function (div) {
                div.innerHTML = '<div class=\'a\'></div><div class=\'a i\'></div>';
                div.firstChild.className = 'i';
                return div.getElementsByClassName('i').length === 2;
            });
            support.getById = assert(function (div) {
                docElem.appendChild(div).id = expando;
                return !doc.getElementsByName || !doc.getElementsByName(expando).length;
            });
            if (support.getById) {
                Expr.find['ID'] = function (id, context) {
                    if (typeof context.getElementById !== strundefined && documentIsHTML) {
                        var m = context.getElementById(id);
                        return m && m.parentNode ? [m] : [];
                    }
                };
                Expr.filter['ID'] = function (id) {
                    var attrId = id.replace(runescape, funescape);
                    return function (elem) {
                        return elem.getAttribute('id') === attrId;
                    };
                };
            } else {
                delete Expr.find['ID'];
                Expr.filter['ID'] = function (id) {
                    var attrId = id.replace(runescape, funescape);
                    return function (elem) {
                        var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode('id');
                        return node && node.value === attrId;
                    };
                };
            }
            Expr.find['TAG'] = support.getElementsByTagName ? function (tag, context) {
                if (typeof context.getElementsByTagName !== strundefined) {
                    return context.getElementsByTagName(tag);
                }
            } : function (tag, context) {
                var elem, tmp = [], i = 0, results = context.getElementsByTagName(tag);
                if (tag === '*') {
                    while (elem = results[i++]) {
                        if (elem.nodeType === 1) {
                            tmp.push(elem);
                        }
                    }
                    return tmp;
                }
                return results;
            };
            Expr.find['CLASS'] = support.getElementsByClassName && function (className, context) {
                if (typeof context.getElementsByClassName !== strundefined && documentIsHTML) {
                    return context.getElementsByClassName(className);
                }
            };
            rbuggyMatches = [];
            rbuggyQSA = [];
            if (support.qsa = rnative.test(doc.querySelectorAll)) {
                assert(function (div) {
                    div.innerHTML = '<select t=\'\'><option selected=\'\'></option></select>';
                    if (div.querySelectorAll('[t^=\'\']').length) {
                        rbuggyQSA.push('[*^$]=' + whitespace + '*(?:\'\'|"")');
                    }
                    if (!div.querySelectorAll('[selected]').length) {
                        rbuggyQSA.push('\\[' + whitespace + '*(?:value|' + booleans + ')');
                    }
                    if (!div.querySelectorAll(':checked').length) {
                        rbuggyQSA.push(':checked');
                    }
                });
                assert(function (div) {
                    var input = doc.createElement('input');
                    input.setAttribute('type', 'hidden');
                    div.appendChild(input).setAttribute('name', 'D');
                    if (div.querySelectorAll('[name=d]').length) {
                        rbuggyQSA.push('name' + whitespace + '*[*^$|!~]?=');
                    }
                    if (!div.querySelectorAll(':enabled').length) {
                        rbuggyQSA.push(':enabled', ':disabled');
                    }
                    div.querySelectorAll('*,:x');
                    rbuggyQSA.push(',.*:');
                });
            }
            if (support.matchesSelector = rnative.test(matches = docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
                assert(function (div) {
                    support.disconnectedMatch = matches.call(div, 'div');
                    matches.call(div, '[s!=\'\']:x');
                    rbuggyMatches.push('!=', pseudos);
                });
            }
            rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join('|'));
            rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join('|'));
            hasCompare = rnative.test(docElem.compareDocumentPosition);
            contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {
                var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
                return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
            } : function (a, b) {
                if (b) {
                    while (b = b.parentNode) {
                        if (b === a) {
                            return true;
                        }
                    }
                }
                return false;
            };
            sortOrder = hasCompare ? function (a, b) {
                if (a === b) {
                    hasDuplicate = true;
                    return 0;
                }
                var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                if (compare) {
                    return compare;
                }
                compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;
                if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
                    if (a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
                        return -1;
                    }
                    if (b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
                        return 1;
                    }
                    return sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0;
                }
                return compare & 4 ? -1 : 1;
            } : function (a, b) {
                if (a === b) {
                    hasDuplicate = true;
                    return 0;
                }
                var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [a], bp = [b];
                if (!aup || !bup) {
                    return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0;
                } else if (aup === bup) {
                    return siblingCheck(a, b);
                }
                cur = a;
                while (cur = cur.parentNode) {
                    ap.unshift(cur);
                }
                cur = b;
                while (cur = cur.parentNode) {
                    bp.unshift(cur);
                }
                while (ap[i] === bp[i]) {
                    i++;
                }
                return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
            };
            return doc;
        };
        Sizzle.matches = function (expr, elements) {
            return Sizzle(expr, null, null, elements);
        };
        Sizzle.matchesSelector = function (elem, expr) {
            if ((elem.ownerDocument || elem) !== document) {
                setDocument(elem);
            }
            expr = expr.replace(rattributeQuotes, '=\'$1\']');
            if (support.matchesSelector && documentIsHTML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
                try {
                    var ret = matches.call(elem, expr);
                    if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
                        return ret;
                    }
                } catch (e) {
                }
            }
            return Sizzle(expr, document, null, [elem]).length > 0;
        };
        Sizzle.contains = function (context, elem) {
            if ((context.ownerDocument || context) !== document) {
                setDocument(context);
            }
            return contains(context, elem);
        };
        Sizzle.attr = function (elem, name) {
            if ((elem.ownerDocument || elem) !== document) {
                setDocument(elem);
            }
            var fn = Expr.attrHandle[name.toLowerCase()], val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
            return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        };
        Sizzle.error = function (msg) {
            throw new Error('Syntax error, unrecognized expression: ' + msg);
        };
        Sizzle.uniqueSort = function (results) {
            var elem, duplicates = [], j = 0, i = 0;
            hasDuplicate = !support.detectDuplicates;
            sortInput = !support.sortStable && results.slice(0);
            results.sort(sortOrder);
            if (hasDuplicate) {
                while (elem = results[i++]) {
                    if (elem === results[i]) {
                        j = duplicates.push(i);
                    }
                }
                while (j--) {
                    results.splice(duplicates[j], 1);
                }
            }
            sortInput = null;
            return results;
        };
        getText = Sizzle.getText = function (elem) {
            var node, ret = '', i = 0, nodeType = elem.nodeType;
            if (!nodeType) {
                while (node = elem[i++]) {
                    ret += getText(node);
                }
            } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
                if (typeof elem.textContent === 'string') {
                    return elem.textContent;
                } else {
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                        ret += getText(elem);
                    }
                }
            } else if (nodeType === 3 || nodeType === 4) {
                return elem.nodeValue;
            }
            return ret;
        };
        Expr = Sizzle.selectors = {
            cacheLength: 50,
            createPseudo: markFunction,
            match: matchExpr,
            attrHandle: {},
            find: {},
            relative: {
                '>': {
                    dir: 'parentNode',
                    first: true
                },
                ' ': { dir: 'parentNode' },
                '+': {
                    dir: 'previousSibling',
                    first: true
                },
                '~': { dir: 'previousSibling' }
            },
            preFilter: {
                'ATTR': function (match) {
                    match[1] = match[1].replace(runescape, funescape);
                    match[3] = (match[4] || match[5] || '').replace(runescape, funescape);
                    if (match[2] === '~=') {
                        match[3] = ' ' + match[3] + ' ';
                    }
                    return match.slice(0, 4);
                },
                'CHILD': function (match) {
                    match[1] = match[1].toLowerCase();
                    if (match[1].slice(0, 3) === 'nth') {
                        if (!match[3]) {
                            Sizzle.error(match[0]);
                        }
                        match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === 'even' || match[3] === 'odd'));
                        match[5] = +(match[7] + match[8] || match[3] === 'odd');
                    } else if (match[3]) {
                        Sizzle.error(match[0]);
                    }
                    return match;
                },
                'PSEUDO': function (match) {
                    var excess, unquoted = !match[5] && match[2];
                    if (matchExpr['CHILD'].test(match[0])) {
                        return null;
                    }
                    if (match[3] && match[4] !== undefined) {
                        match[2] = match[4];
                    } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(')', unquoted.length - excess) - unquoted.length)) {
                        match[0] = match[0].slice(0, excess);
                        match[2] = unquoted.slice(0, excess);
                    }
                    return match.slice(0, 3);
                }
            },
            filter: {
                'TAG': function (nodeNameSelector) {
                    var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                    return nodeNameSelector === '*' ? function () {
                        return true;
                    } : function (elem) {
                        return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                    };
                },
                'CLASS': function (className) {
                    var pattern = classCache[className + ' '];
                    return pattern || (pattern = new RegExp('(^|' + whitespace + ')' + className + '(' + whitespace + '|$)')) && classCache(className, function (elem) {
                        return pattern.test(typeof elem.className === 'string' && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute('class') || '');
                    });
                },
                'ATTR': function (name, operator, check) {
                    return function (elem) {
                        var result = Sizzle.attr(elem, name);
                        if (result == null) {
                            return operator === '!=';
                        }
                        if (!operator) {
                            return true;
                        }
                        result += '';
                        return operator === '=' ? result === check : operator === '!=' ? result !== check : operator === '^=' ? check && result.indexOf(check) === 0 : operator === '*=' ? check && result.indexOf(check) > -1 : operator === '$=' ? check && result.slice(-check.length) === check : operator === '~=' ? (' ' + result + ' ').indexOf(check) > -1 : operator === '|=' ? result === check || result.slice(0, check.length + 1) === check + '-' : false;
                    };
                },
                'CHILD': function (type, what, argument, first, last) {
                    var simple = type.slice(0, 3) !== 'nth', forward = type.slice(-4) !== 'last', ofType = what === 'of-type';
                    return first === 1 && last === 0 ? function (elem) {
                        return !!elem.parentNode;
                    } : function (elem, context, xml) {
                        var cache, outerCache, node, diff, nodeIndex, start, dir = simple !== forward ? 'nextSibling' : 'previousSibling', parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType;
                        if (parent) {
                            if (simple) {
                                while (dir) {
                                    node = elem;
                                    while (node = node[dir]) {
                                        if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                                            return false;
                                        }
                                    }
                                    start = dir = type === 'only' && !start && 'nextSibling';
                                }
                                return true;
                            }
                            start = [forward ? parent.firstChild : parent.lastChild];
                            if (forward && useCache) {
                                outerCache = parent[expando] || (parent[expando] = {});
                                cache = outerCache[type] || [];
                                nodeIndex = cache[0] === dirruns && cache[1];
                                diff = cache[0] === dirruns && cache[2];
                                node = nodeIndex && parent.childNodes[nodeIndex];
                                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                                    if (node.nodeType === 1 && ++diff && node === elem) {
                                        outerCache[type] = [
                                            dirruns,
                                            nodeIndex,
                                            diff
                                        ];
                                        break;
                                    }
                                }
                            } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) {
                                diff = cache[1];
                            } else {
                                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                                    if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                                        if (useCache) {
                                            (node[expando] || (node[expando] = {}))[type] = [
                                                dirruns,
                                                diff
                                            ];
                                        }
                                        if (node === elem) {
                                            break;
                                        }
                                    }
                                }
                            }
                            diff -= last;
                            return diff === first || diff % first === 0 && diff / first >= 0;
                        }
                    };
                },
                'PSEUDO': function (pseudo, argument) {
                    var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error('unsupported pseudo: ' + pseudo);
                    if (fn[expando]) {
                        return fn(argument);
                    }
                    if (fn.length > 1) {
                        args = [
                            pseudo,
                            pseudo,
                            '',
                            argument
                        ];
                        return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
                            var idx, matched = fn(seed, argument), i = matched.length;
                            while (i--) {
                                idx = indexOf.call(seed, matched[i]);
                                seed[idx] = !(matches[idx] = matched[i]);
                            }
                        }) : function (elem) {
                            return fn(elem, 0, args);
                        };
                    }
                    return fn;
                }
            },
            pseudos: {
                'not': markFunction(function (selector) {
                    var input = [], results = [], matcher = compile(selector.replace(rtrim, '$1'));
                    return matcher[expando] ? markFunction(function (seed, matches, context, xml) {
                        var elem, unmatched = matcher(seed, null, xml, []), i = seed.length;
                        while (i--) {
                            if (elem = unmatched[i]) {
                                seed[i] = !(matches[i] = elem);
                            }
                        }
                    }) : function (elem, context, xml) {
                        input[0] = elem;
                        matcher(input, null, xml, results);
                        return !results.pop();
                    };
                }),
                'has': markFunction(function (selector) {
                    return function (elem) {
                        return Sizzle(selector, elem).length > 0;
                    };
                }),
                'contains': markFunction(function (text) {
                    return function (elem) {
                        return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
                    };
                }),
                'lang': markFunction(function (lang) {
                    if (!ridentifier.test(lang || '')) {
                        Sizzle.error('unsupported lang: ' + lang);
                    }
                    lang = lang.replace(runescape, funescape).toLowerCase();
                    return function (elem) {
                        var elemLang;
                        do {
                            if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute('xml:lang') || elem.getAttribute('lang')) {
                                elemLang = elemLang.toLowerCase();
                                return elemLang === lang || elemLang.indexOf(lang + '-') === 0;
                            }
                        } while ((elem = elem.parentNode) && elem.nodeType === 1);
                        return false;
                    };
                }),
                'target': function (elem) {
                    var hash = window.location && window.location.hash;
                    return hash && hash.slice(1) === elem.id;
                },
                'root': function (elem) {
                    return elem === docElem;
                },
                'focus': function (elem) {
                    return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                },
                'enabled': function (elem) {
                    return elem.disabled === false;
                },
                'disabled': function (elem) {
                    return elem.disabled === true;
                },
                'checked': function (elem) {
                    var nodeName = elem.nodeName.toLowerCase();
                    return nodeName === 'input' && !!elem.checked || nodeName === 'option' && !!elem.selected;
                },
                'selected': function (elem) {
                    if (elem.parentNode) {
                        elem.parentNode.selectedIndex;
                    }
                    return elem.selected === true;
                },
                'empty': function (elem) {
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                        if (elem.nodeType < 6) {
                            return false;
                        }
                    }
                    return true;
                },
                'parent': function (elem) {
                    return !Expr.pseudos['empty'](elem);
                },
                'header': function (elem) {
                    return rheader.test(elem.nodeName);
                },
                'input': function (elem) {
                    return rinputs.test(elem.nodeName);
                },
                'button': function (elem) {
                    var name = elem.nodeName.toLowerCase();
                    return name === 'input' && elem.type === 'button' || name === 'button';
                },
                'text': function (elem) {
                    var attr;
                    return elem.nodeName.toLowerCase() === 'input' && elem.type === 'text' && ((attr = elem.getAttribute('type')) == null || attr.toLowerCase() === 'text');
                },
                'first': createPositionalPseudo(function () {
                    return [0];
                }),
                'last': createPositionalPseudo(function (matchIndexes, length) {
                    return [length - 1];
                }),
                'eq': createPositionalPseudo(function (matchIndexes, length, argument) {
                    return [argument < 0 ? argument + length : argument];
                }),
                'even': createPositionalPseudo(function (matchIndexes, length) {
                    var i = 0;
                    for (; i < length; i += 2) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),
                'odd': createPositionalPseudo(function (matchIndexes, length) {
                    var i = 1;
                    for (; i < length; i += 2) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),
                'lt': createPositionalPseudo(function (matchIndexes, length, argument) {
                    var i = argument < 0 ? argument + length : argument;
                    for (; --i >= 0;) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),
                'gt': createPositionalPseudo(function (matchIndexes, length, argument) {
                    var i = argument < 0 ? argument + length : argument;
                    for (; ++i < length;) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                })
            }
        };
        Expr.pseudos['nth'] = Expr.pseudos['eq'];
        for (i in {
                radio: true,
                checkbox: true,
                file: true,
                password: true,
                image: true
            }) {
            Expr.pseudos[i] = createInputPseudo(i);
        }
        for (i in {
                submit: true,
                reset: true
            }) {
            Expr.pseudos[i] = createButtonPseudo(i);
        }
        function setFilters() {
        }
        setFilters.prototype = Expr.filters = Expr.pseudos;
        Expr.setFilters = new setFilters();
        function tokenize(selector, parseOnly) {
            var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + ' '];
            if (cached) {
                return parseOnly ? 0 : cached.slice(0);
            }
            soFar = selector;
            groups = [];
            preFilters = Expr.preFilter;
            while (soFar) {
                if (!matched || (match = rcomma.exec(soFar))) {
                    if (match) {
                        soFar = soFar.slice(match[0].length) || soFar;
                    }
                    groups.push(tokens = []);
                }
                matched = false;
                if (match = rcombinators.exec(soFar)) {
                    matched = match.shift();
                    tokens.push({
                        value: matched,
                        type: match[0].replace(rtrim, ' ')
                    });
                    soFar = soFar.slice(matched.length);
                }
                for (type in Expr.filter) {
                    if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                        matched = match.shift();
                        tokens.push({
                            value: matched,
                            type: type,
                            matches: match
                        });
                        soFar = soFar.slice(matched.length);
                    }
                }
                if (!matched) {
                    break;
                }
            }
            return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
        }
        function toSelector(tokens) {
            var i = 0, len = tokens.length, selector = '';
            for (; i < len; i++) {
                selector += tokens[i].value;
            }
            return selector;
        }
        function addCombinator(matcher, combinator, base) {
            var dir = combinator.dir, checkNonElements = base && dir === 'parentNode', doneName = done++;
            return combinator.first ? function (elem, context, xml) {
                while (elem = elem[dir]) {
                    if (elem.nodeType === 1 || checkNonElements) {
                        return matcher(elem, context, xml);
                    }
                }
            } : function (elem, context, xml) {
                var oldCache, outerCache, newCache = [
                        dirruns,
                        doneName
                    ];
                if (xml) {
                    while (elem = elem[dir]) {
                        if (elem.nodeType === 1 || checkNonElements) {
                            if (matcher(elem, context, xml)) {
                                return true;
                            }
                        }
                    }
                } else {
                    while (elem = elem[dir]) {
                        if (elem.nodeType === 1 || checkNonElements) {
                            outerCache = elem[expando] || (elem[expando] = {});
                            if ((oldCache = outerCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                                return newCache[2] = oldCache[2];
                            } else {
                                outerCache[dir] = newCache;
                                if (newCache[2] = matcher(elem, context, xml)) {
                                    return true;
                                }
                            }
                        }
                    }
                }
            };
        }
        function elementMatcher(matchers) {
            return matchers.length > 1 ? function (elem, context, xml) {
                var i = matchers.length;
                while (i--) {
                    if (!matchers[i](elem, context, xml)) {
                        return false;
                    }
                }
                return true;
            } : matchers[0];
        }
        function condense(unmatched, map, filter, context, xml) {
            var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = map != null;
            for (; i < len; i++) {
                if (elem = unmatched[i]) {
                    if (!filter || filter(elem, context, xml)) {
                        newUnmatched.push(elem);
                        if (mapped) {
                            map.push(i);
                        }
                    }
                }
            }
            return newUnmatched;
        }
        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
            if (postFilter && !postFilter[expando]) {
                postFilter = setMatcher(postFilter);
            }
            if (postFinder && !postFinder[expando]) {
                postFinder = setMatcher(postFinder, postSelector);
            }
            return markFunction(function (seed, results, context, xml) {
                var temp, i, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(selector || '*', context.nodeType ? [context] : context, []), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems, matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
                if (matcher) {
                    matcher(matcherIn, matcherOut, context, xml);
                }
                if (postFilter) {
                    temp = condense(matcherOut, postMap);
                    postFilter(temp, [], context, xml);
                    i = temp.length;
                    while (i--) {
                        if (elem = temp[i]) {
                            matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
                        }
                    }
                }
                if (seed) {
                    if (postFinder || preFilter) {
                        if (postFinder) {
                            temp = [];
                            i = matcherOut.length;
                            while (i--) {
                                if (elem = matcherOut[i]) {
                                    temp.push(matcherIn[i] = elem);
                                }
                            }
                            postFinder(null, matcherOut = [], temp, xml);
                        }
                        i = matcherOut.length;
                        while (i--) {
                            if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf.call(seed, elem) : preMap[i]) > -1) {
                                seed[temp] = !(results[temp] = elem);
                            }
                        }
                    }
                } else {
                    matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
                    if (postFinder) {
                        postFinder(null, results, matcherOut, xml);
                    } else {
                        push.apply(results, matcherOut);
                    }
                }
            });
        }
        function matcherFromTokens(tokens) {
            var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[' '], i = leadingRelative ? 1 : 0, matchContext = addCombinator(function (elem) {
                    return elem === checkContext;
                }, implicitRelative, true), matchAnyContext = addCombinator(function (elem) {
                    return indexOf.call(checkContext, elem) > -1;
                }, implicitRelative, true), matchers = [function (elem, context, xml) {
                        return !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
                    }];
            for (; i < len; i++) {
                if (matcher = Expr.relative[tokens[i].type]) {
                    matchers = [addCombinator(elementMatcher(matchers), matcher)];
                } else {
                    matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
                    if (matcher[expando]) {
                        j = ++i;
                        for (; j < len; j++) {
                            if (Expr.relative[tokens[j].type]) {
                                break;
                            }
                        }
                        return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === ' ' ? '*' : '' })).replace(rtrim, '$1'), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
                    }
                    matchers.push(matcher);
                }
            }
            return elementMatcher(matchers);
        }
        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
            var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function (seed, context, xml, results, outermost) {
                    var elem, j, matcher, matchedCount = 0, i = '0', unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find['TAG']('*', outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
                    if (outermost) {
                        outermostContext = context !== document && context;
                    }
                    for (; i !== len && (elem = elems[i]) != null; i++) {
                        if (byElement && elem) {
                            j = 0;
                            while (matcher = elementMatchers[j++]) {
                                if (matcher(elem, context, xml)) {
                                    results.push(elem);
                                    break;
                                }
                            }
                            if (outermost) {
                                dirruns = dirrunsUnique;
                            }
                        }
                        if (bySet) {
                            if (elem = !matcher && elem) {
                                matchedCount--;
                            }
                            if (seed) {
                                unmatched.push(elem);
                            }
                        }
                    }
                    matchedCount += i;
                    if (bySet && i !== matchedCount) {
                        j = 0;
                        while (matcher = setMatchers[j++]) {
                            matcher(unmatched, setMatched, context, xml);
                        }
                        if (seed) {
                            if (matchedCount > 0) {
                                while (i--) {
                                    if (!(unmatched[i] || setMatched[i])) {
                                        setMatched[i] = pop.call(results);
                                    }
                                }
                            }
                            setMatched = condense(setMatched);
                        }
                        push.apply(results, setMatched);
                        if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                            Sizzle.uniqueSort(results);
                        }
                    }
                    if (outermost) {
                        dirruns = dirrunsUnique;
                        outermostContext = contextBackup;
                    }
                    return unmatched;
                };
            return bySet ? markFunction(superMatcher) : superMatcher;
        }
        compile = Sizzle.compile = function (selector, group) {
            var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + ' '];
            if (!cached) {
                if (!group) {
                    group = tokenize(selector);
                }
                i = group.length;
                while (i--) {
                    cached = matcherFromTokens(group[i]);
                    if (cached[expando]) {
                        setMatchers.push(cached);
                    } else {
                        elementMatchers.push(cached);
                    }
                }
                cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
            }
            return cached;
        };
        function multipleContexts(selector, contexts, results) {
            var i = 0, len = contexts.length;
            for (; i < len; i++) {
                Sizzle(selector, contexts[i], results);
            }
            return results;
        }
        function select(selector, context, results, seed) {
            var i, tokens, token, type, find, match = tokenize(selector);
            if (!seed) {
                if (match.length === 1) {
                    tokens = match[0] = match[0].slice(0);
                    if (tokens.length > 2 && (token = tokens[0]).type === 'ID' && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
                        context = (Expr.find['ID'](token.matches[0].replace(runescape, funescape), context) || [])[0];
                        if (!context) {
                            return results;
                        }
                        selector = selector.slice(tokens.shift().value.length);
                    }
                    i = matchExpr['needsContext'].test(selector) ? 0 : tokens.length;
                    while (i--) {
                        token = tokens[i];
                        if (Expr.relative[type = token.type]) {
                            break;
                        }
                        if (find = Expr.find[type]) {
                            if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
                                tokens.splice(i, 1);
                                selector = seed.length && toSelector(tokens);
                                if (!selector) {
                                    push.apply(results, seed);
                                    return results;
                                }
                                break;
                            }
                        }
                    }
                }
            }
            compile(selector, match)(seed, context, !documentIsHTML, results, rsibling.test(selector) && testContext(context.parentNode) || context);
            return results;
        }
        support.sortStable = expando.split('').sort(sortOrder).join('') === expando;
        support.detectDuplicates = !!hasDuplicate;
        setDocument();
        support.sortDetached = assert(function (div1) {
            return div1.compareDocumentPosition(document.createElement('div')) & 1;
        });
        if (!assert(function (div) {
                div.innerHTML = '<a href=\'#\'></a>';
                return div.firstChild.getAttribute('href') === '#';
            })) {
            addHandle('type|href|height|width', function (elem, name, isXML) {
                if (!isXML) {
                    return elem.getAttribute(name, name.toLowerCase() === 'type' ? 1 : 2);
                }
            });
        }
        if (!support.attributes || !assert(function (div) {
                div.innerHTML = '<input/>';
                div.firstChild.setAttribute('value', '');
                return div.firstChild.getAttribute('value') === '';
            })) {
            addHandle('value', function (elem, name, isXML) {
                if (!isXML && elem.nodeName.toLowerCase() === 'input') {
                    return elem.defaultValue;
                }
            });
        }
        if (!assert(function (div) {
                return div.getAttribute('disabled') == null;
            })) {
            addHandle(booleans, function (elem, name, isXML) {
                var val;
                if (!isXML) {
                    return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
                }
            });
        }
        return Sizzle;
    }(window);
    jQuery.find = Sizzle;
    jQuery.expr = Sizzle.selectors;
    jQuery.expr[':'] = jQuery.expr.pseudos;
    jQuery.unique = Sizzle.uniqueSort;
    jQuery.text = Sizzle.getText;
    jQuery.isXMLDoc = Sizzle.isXML;
    jQuery.contains = Sizzle.contains;
    var rneedsContext = jQuery.expr.match.needsContext;
    var rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/;
    var risSimple = /^.[^:#\[\.,]*$/;
    function winnow(elements, qualifier, not) {
        if (jQuery.isFunction(qualifier)) {
            return jQuery.grep(elements, function (elem, i) {
                return !!qualifier.call(elem, i, elem) !== not;
            });
        }
        if (qualifier.nodeType) {
            return jQuery.grep(elements, function (elem) {
                return elem === qualifier !== not;
            });
        }
        if (typeof qualifier === 'string') {
            if (risSimple.test(qualifier)) {
                return jQuery.filter(qualifier, elements, not);
            }
            qualifier = jQuery.filter(qualifier, elements);
        }
        return jQuery.grep(elements, function (elem) {
            return jQuery.inArray(elem, qualifier) >= 0 !== not;
        });
    }
    jQuery.filter = function (expr, elems, not) {
        var elem = elems[0];
        if (not) {
            expr = ':not(' + expr + ')';
        }
        return elems.length === 1 && elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
            return elem.nodeType === 1;
        }));
    };
    jQuery.fn.extend({
        find: function (selector) {
            var i, ret = [], self = this, len = self.length;
            if (typeof selector !== 'string') {
                return this.pushStack(jQuery(selector).filter(function () {
                    for (i = 0; i < len; i++) {
                        if (jQuery.contains(self[i], this)) {
                            return true;
                        }
                    }
                }));
            }
            for (i = 0; i < len; i++) {
                jQuery.find(selector, self[i], ret);
            }
            ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
            ret.selector = this.selector ? this.selector + ' ' + selector : selector;
            return ret;
        },
        filter: function (selector) {
            return this.pushStack(winnow(this, selector || [], false));
        },
        not: function (selector) {
            return this.pushStack(winnow(this, selector || [], true));
        },
        is: function (selector) {
            return !!winnow(this, typeof selector === 'string' && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
        }
    });
    var rootjQuery, document = window.document, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/, init = jQuery.fn.init = function (selector, context) {
            var match, elem;
            if (!selector) {
                return this;
            }
            if (typeof selector === 'string') {
                if (selector.charAt(0) === '<' && selector.charAt(selector.length - 1) === '>' && selector.length >= 3) {
                    match = [
                        null,
                        selector,
                        null
                    ];
                } else {
                    match = rquickExpr.exec(selector);
                }
                if (match && (match[1] || !context)) {
                    if (match[1]) {
                        context = context instanceof jQuery ? context[0] : context;
                        jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));
                        if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                            for (match in context) {
                                if (jQuery.isFunction(this[match])) {
                                    this[match](context[match]);
                                } else {
                                    this.attr(match, context[match]);
                                }
                            }
                        }
                        return this;
                    } else {
                        elem = document.getElementById(match[2]);
                        if (elem && elem.parentNode) {
                            if (elem.id !== match[2]) {
                                return rootjQuery.find(selector);
                            }
                            this.length = 1;
                            this[0] = elem;
                        }
                        this.context = document;
                        this.selector = selector;
                        return this;
                    }
                } else if (!context || context.jquery) {
                    return (context || rootjQuery).find(selector);
                } else {
                    return this.constructor(context).find(selector);
                }
            } else if (selector.nodeType) {
                this.context = this[0] = selector;
                this.length = 1;
                return this;
            } else if (jQuery.isFunction(selector)) {
                return typeof rootjQuery.ready !== 'undefined' ? rootjQuery.ready(selector) : selector(jQuery);
            }
            if (selector.selector !== undefined) {
                this.selector = selector.selector;
                this.context = selector.context;
            }
            return jQuery.makeArray(selector, this);
        };
    init.prototype = jQuery.fn;
    rootjQuery = jQuery(document);
    var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
            children: true,
            contents: true,
            next: true,
            prev: true
        };
    jQuery.extend({
        dir: function (elem, dir, until) {
            var matched = [], cur = elem[dir];
            while (cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery(cur).is(until))) {
                if (cur.nodeType === 1) {
                    matched.push(cur);
                }
                cur = cur[dir];
            }
            return matched;
        },
        sibling: function (n, elem) {
            var r = [];
            for (; n; n = n.nextSibling) {
                if (n.nodeType === 1 && n !== elem) {
                    r.push(n);
                }
            }
            return r;
        }
    });
    jQuery.fn.extend({
        has: function (target) {
            var i, targets = jQuery(target, this), len = targets.length;
            return this.filter(function () {
                for (i = 0; i < len; i++) {
                    if (jQuery.contains(this, targets[i])) {
                        return true;
                    }
                }
            });
        },
        closest: function (selectors, context) {
            var cur, i = 0, l = this.length, matched = [], pos = rneedsContext.test(selectors) || typeof selectors !== 'string' ? jQuery(selectors, context || this.context) : 0;
            for (; i < l; i++) {
                for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
                    if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 : cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
                        matched.push(cur);
                        break;
                    }
                }
            }
            return this.pushStack(matched.length > 1 ? jQuery.unique(matched) : matched);
        },
        index: function (elem) {
            if (!elem) {
                return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
            }
            if (typeof elem === 'string') {
                return jQuery.inArray(this[0], jQuery(elem));
            }
            return jQuery.inArray(elem.jquery ? elem[0] : elem, this);
        },
        add: function (selector, context) {
            return this.pushStack(jQuery.unique(jQuery.merge(this.get(), jQuery(selector, context))));
        },
        addBack: function (selector) {
            return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
        }
    });
    function sibling(cur, dir) {
        do {
            cur = cur[dir];
        } while (cur && cur.nodeType !== 1);
        return cur;
    }
    jQuery.each({
        parent: function (elem) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function (elem) {
            return jQuery.dir(elem, 'parentNode');
        },
        parentsUntil: function (elem, i, until) {
            return jQuery.dir(elem, 'parentNode', until);
        },
        next: function (elem) {
            return sibling(elem, 'nextSibling');
        },
        prev: function (elem) {
            return sibling(elem, 'previousSibling');
        },
        nextAll: function (elem) {
            return jQuery.dir(elem, 'nextSibling');
        },
        prevAll: function (elem) {
            return jQuery.dir(elem, 'previousSibling');
        },
        nextUntil: function (elem, i, until) {
            return jQuery.dir(elem, 'nextSibling', until);
        },
        prevUntil: function (elem, i, until) {
            return jQuery.dir(elem, 'previousSibling', until);
        },
        siblings: function (elem) {
            return jQuery.sibling((elem.parentNode || {}).firstChild, elem);
        },
        children: function (elem) {
            return jQuery.sibling(elem.firstChild);
        },
        contents: function (elem) {
            return jQuery.nodeName(elem, 'iframe') ? elem.contentDocument || elem.contentWindow.document : jQuery.merge([], elem.childNodes);
        }
    }, function (name, fn) {
        jQuery.fn[name] = function (until, selector) {
            var ret = jQuery.map(this, fn, until);
            if (name.slice(-5) !== 'Until') {
                selector = until;
            }
            if (selector && typeof selector === 'string') {
                ret = jQuery.filter(selector, ret);
            }
            if (this.length > 1) {
                if (!guaranteedUnique[name]) {
                    ret = jQuery.unique(ret);
                }
                if (rparentsprev.test(name)) {
                    ret = ret.reverse();
                }
            }
            return this.pushStack(ret);
        };
    });
    var rnotwhite = /\S+/g;
    var optionsCache = {};
    function createOptions(options) {
        var object = optionsCache[options] = {};
        jQuery.each(options.match(rnotwhite) || [], function (_, flag) {
            object[flag] = true;
        });
        return object;
    }
    jQuery.Callbacks = function (options) {
        options = typeof options === 'string' ? optionsCache[options] || createOptions(options) : jQuery.extend({}, options);
        var firing, memory, fired, firingLength, firingIndex, firingStart, list = [], stack = !options.once && [], fire = function (data) {
                memory = options.memory && data;
                fired = true;
                firingIndex = firingStart || 0;
                firingStart = 0;
                firingLength = list.length;
                firing = true;
                for (; list && firingIndex < firingLength; firingIndex++) {
                    if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {
                        memory = false;
                        break;
                    }
                }
                firing = false;
                if (list) {
                    if (stack) {
                        if (stack.length) {
                            fire(stack.shift());
                        }
                    } else if (memory) {
                        list = [];
                    } else {
                        self.disable();
                    }
                }
            }, self = {
                add: function () {
                    if (list) {
                        var start = list.length;
                        (function add(args) {
                            jQuery.each(args, function (_, arg) {
                                var type = jQuery.type(arg);
                                if (type === 'function') {
                                    if (!options.unique || !self.has(arg)) {
                                        list.push(arg);
                                    }
                                } else if (arg && arg.length && type !== 'string') {
                                    add(arg);
                                }
                            });
                        }(arguments));
                        if (firing) {
                            firingLength = list.length;
                        } else if (memory) {
                            firingStart = start;
                            fire(memory);
                        }
                    }
                    return this;
                },
                remove: function () {
                    if (list) {
                        jQuery.each(arguments, function (_, arg) {
                            var index;
                            while ((index = jQuery.inArray(arg, list, index)) > -1) {
                                list.splice(index, 1);
                                if (firing) {
                                    if (index <= firingLength) {
                                        firingLength--;
                                    }
                                    if (index <= firingIndex) {
                                        firingIndex--;
                                    }
                                }
                            }
                        });
                    }
                    return this;
                },
                has: function (fn) {
                    return fn ? jQuery.inArray(fn, list) > -1 : !!(list && list.length);
                },
                empty: function () {
                    list = [];
                    firingLength = 0;
                    return this;
                },
                disable: function () {
                    list = stack = memory = undefined;
                    return this;
                },
                disabled: function () {
                    return !list;
                },
                lock: function () {
                    stack = undefined;
                    if (!memory) {
                        self.disable();
                    }
                    return this;
                },
                locked: function () {
                    return !stack;
                },
                fireWith: function (context, args) {
                    if (list && (!fired || stack)) {
                        args = args || [];
                        args = [
                            context,
                            args.slice ? args.slice() : args
                        ];
                        if (firing) {
                            stack.push(args);
                        } else {
                            fire(args);
                        }
                    }
                    return this;
                },
                fire: function () {
                    self.fireWith(this, arguments);
                    return this;
                },
                fired: function () {
                    return !!fired;
                }
            };
        return self;
    };
    jQuery.extend({
        Deferred: function (func) {
            var tuples = [
                    [
                        'resolve',
                        'done',
                        jQuery.Callbacks('once memory'),
                        'resolved'
                    ],
                    [
                        'reject',
                        'fail',
                        jQuery.Callbacks('once memory'),
                        'rejected'
                    ],
                    [
                        'notify',
                        'progress',
                        jQuery.Callbacks('memory')
                    ]
                ], state = 'pending', promise = {
                    state: function () {
                        return state;
                    },
                    always: function () {
                        deferred.done(arguments).fail(arguments);
                        return this;
                    },
                    then: function () {
                        var fns = arguments;
                        return jQuery.Deferred(function (newDefer) {
                            jQuery.each(tuples, function (i, tuple) {
                                var fn = jQuery.isFunction(fns[i]) && fns[i];
                                deferred[tuple[1]](function () {
                                    var returned = fn && fn.apply(this, arguments);
                                    if (returned && jQuery.isFunction(returned.promise)) {
                                        returned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify);
                                    } else {
                                        newDefer[tuple[0] + 'With'](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments);
                                    }
                                });
                            });
                            fns = null;
                        }).promise();
                    },
                    promise: function (obj) {
                        return obj != null ? jQuery.extend(obj, promise) : promise;
                    }
                }, deferred = {};
            promise.pipe = promise.then;
            jQuery.each(tuples, function (i, tuple) {
                var list = tuple[2], stateString = tuple[3];
                promise[tuple[1]] = list.add;
                if (stateString) {
                    list.add(function () {
                        state = stateString;
                    }, tuples[i ^ 1][2].disable, tuples[2][2].lock);
                }
                deferred[tuple[0]] = function () {
                    deferred[tuple[0] + 'With'](this === deferred ? promise : this, arguments);
                    return this;
                };
                deferred[tuple[0] + 'With'] = list.fireWith;
            });
            promise.promise(deferred);
            if (func) {
                func.call(deferred, deferred);
            }
            return deferred;
        },
        when: function (subordinate) {
            var i = 0, resolveValues = slice.call(arguments), length = resolveValues.length, remaining = length !== 1 || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0, deferred = remaining === 1 ? subordinate : jQuery.Deferred(), updateFunc = function (i, contexts, values) {
                    return function (value) {
                        contexts[i] = this;
                        values[i] = arguments.length > 1 ? slice.call(arguments) : value;
                        if (values === progressValues) {
                            deferred.notifyWith(contexts, values);
                        } else if (!--remaining) {
                            deferred.resolveWith(contexts, values);
                        }
                    };
                }, progressValues, progressContexts, resolveContexts;
            if (length > 1) {
                progressValues = new Array(length);
                progressContexts = new Array(length);
                resolveContexts = new Array(length);
                for (; i < length; i++) {
                    if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
                        resolveValues[i].promise().done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFunc(i, progressContexts, progressValues));
                    } else {
                        --remaining;
                    }
                }
            }
            if (!remaining) {
                deferred.resolveWith(resolveContexts, resolveValues);
            }
            return deferred.promise();
        }
    });
    var readyList;
    jQuery.fn.ready = function (fn) {
        jQuery.ready.promise().done(fn);
        return this;
    };
    jQuery.extend({
        isReady: false,
        readyWait: 1,
        holdReady: function (hold) {
            if (hold) {
                jQuery.readyWait++;
            } else {
                jQuery.ready(true);
            }
        },
        ready: function (wait) {
            if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
                return;
            }
            if (!document.body) {
                return setTimeout(jQuery.ready);
            }
            jQuery.isReady = true;
            if (wait !== true && --jQuery.readyWait > 0) {
                return;
            }
            readyList.resolveWith(document, [jQuery]);
            if (jQuery.fn.trigger) {
                jQuery(document).trigger('ready').off('ready');
            }
        }
    });
    function detach() {
        if (document.addEventListener) {
            document.removeEventListener('DOMContentLoaded', completed, false);
            window.removeEventListener('load', completed, false);
        } else {
            document.detachEvent('onreadystatechange', completed);
            window.detachEvent('onload', completed);
        }
    }
    function completed() {
        if (document.addEventListener || event.type === 'load' || document.readyState === 'complete') {
            detach();
            jQuery.ready();
        }
    }
    jQuery.ready.promise = function (obj) {
        if (!readyList) {
            readyList = jQuery.Deferred();
            if (document.readyState === 'complete') {
                setTimeout(jQuery.ready);
            } else if (document.addEventListener) {
                document.addEventListener('DOMContentLoaded', completed, false);
                window.addEventListener('load', completed, false);
            } else {
                document.attachEvent('onreadystatechange', completed);
                window.attachEvent('onload', completed);
                var top = false;
                try {
                    top = window.frameElement == null && document.documentElement;
                } catch (e) {
                }
                if (top && top.doScroll) {
                    (function doScrollCheck() {
                        if (!jQuery.isReady) {
                            try {
                                top.doScroll('left');
                            } catch (e) {
                                return setTimeout(doScrollCheck, 50);
                            }
                            detach();
                            jQuery.ready();
                        }
                    }());
                }
            }
        }
        return readyList.promise(obj);
    };
    var strundefined = typeof undefined;
    var i;
    for (i in jQuery(support)) {
        break;
    }
    support.ownLast = i !== '0';
    support.inlineBlockNeedsLayout = false;
    jQuery(function () {
        var container, div, body = document.getElementsByTagName('body')[0];
        if (!body) {
            return;
        }
        container = document.createElement('div');
        container.style.cssText = 'border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px';
        div = document.createElement('div');
        body.appendChild(container).appendChild(div);
        if (typeof div.style.zoom !== strundefined) {
            div.style.cssText = 'border:0;margin:0;width:1px;padding:1px;display:inline;zoom:1';
            if (support.inlineBlockNeedsLayout = div.offsetWidth === 3) {
                body.style.zoom = 1;
            }
        }
        body.removeChild(container);
        container = div = null;
    });
    (function () {
        var div = document.createElement('div');
        if (support.deleteExpando == null) {
            support.deleteExpando = true;
            try {
                delete div.test;
            } catch (e) {
                support.deleteExpando = false;
            }
        }
        div = null;
    }());
    jQuery.acceptData = function (elem) {
        var noData = jQuery.noData[(elem.nodeName + ' ').toLowerCase()], nodeType = +elem.nodeType || 1;
        return nodeType !== 1 && nodeType !== 9 ? false : !noData || noData !== true && elem.getAttribute('classid') === noData;
    };
    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /([A-Z])/g;
    function dataAttr(elem, key, data) {
        if (data === undefined && elem.nodeType === 1) {
            var name = 'data-' + key.replace(rmultiDash, '-$1').toLowerCase();
            data = elem.getAttribute(name);
            if (typeof data === 'string') {
                try {
                    data = data === 'true' ? true : data === 'false' ? false : data === 'null' ? null : +data + '' === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data;
                } catch (e) {
                }
                jQuery.data(elem, key, data);
            } else {
                data = undefined;
            }
        }
        return data;
    }
    function isEmptyDataObject(obj) {
        var name;
        for (name in obj) {
            if (name === 'data' && jQuery.isEmptyObject(obj[name])) {
                continue;
            }
            if (name !== 'toJSON') {
                return false;
            }
        }
        return true;
    }
    function internalData(elem, name, data, pvt) {
        if (!jQuery.acceptData(elem)) {
            return;
        }
        var ret, thisCache, internalKey = jQuery.expando, isNode = elem.nodeType, cache = isNode ? jQuery.cache : elem, id = isNode ? elem[internalKey] : elem[internalKey] && internalKey;
        if ((!id || !cache[id] || !pvt && !cache[id].data) && data === undefined && typeof name === 'string') {
            return;
        }
        if (!id) {
            if (isNode) {
                id = elem[internalKey] = deletedIds.pop() || jQuery.guid++;
            } else {
                id = internalKey;
            }
        }
        if (!cache[id]) {
            cache[id] = isNode ? {} : { toJSON: jQuery.noop };
        }
        if (typeof name === 'object' || typeof name === 'function') {
            if (pvt) {
                cache[id] = jQuery.extend(cache[id], name);
            } else {
                cache[id].data = jQuery.extend(cache[id].data, name);
            }
        }
        thisCache = cache[id];
        if (!pvt) {
            if (!thisCache.data) {
                thisCache.data = {};
            }
            thisCache = thisCache.data;
        }
        if (data !== undefined) {
            thisCache[jQuery.camelCase(name)] = data;
        }
        if (typeof name === 'string') {
            ret = thisCache[name];
            if (ret == null) {
                ret = thisCache[jQuery.camelCase(name)];
            }
        } else {
            ret = thisCache;
        }
        return ret;
    }
    function internalRemoveData(elem, name, pvt) {
        if (!jQuery.acceptData(elem)) {
            return;
        }
        var thisCache, i, isNode = elem.nodeType, cache = isNode ? jQuery.cache : elem, id = isNode ? elem[jQuery.expando] : jQuery.expando;
        if (!cache[id]) {
            return;
        }
        if (name) {
            thisCache = pvt ? cache[id] : cache[id].data;
            if (thisCache) {
                if (!jQuery.isArray(name)) {
                    if (name in thisCache) {
                        name = [name];
                    } else {
                        name = jQuery.camelCase(name);
                        if (name in thisCache) {
                            name = [name];
                        } else {
                            name = name.split(' ');
                        }
                    }
                } else {
                    name = name.concat(jQuery.map(name, jQuery.camelCase));
                }
                i = name.length;
                while (i--) {
                    delete thisCache[name[i]];
                }
                if (pvt ? !isEmptyDataObject(thisCache) : !jQuery.isEmptyObject(thisCache)) {
                    return;
                }
            }
        }
        if (!pvt) {
            delete cache[id].data;
            if (!isEmptyDataObject(cache[id])) {
                return;
            }
        }
        if (isNode) {
            jQuery.cleanData([elem], true);
        } else if (support.deleteExpando || cache != cache.window) {
            delete cache[id];
        } else {
            cache[id] = null;
        }
    }
    jQuery.extend({
        cache: {},
        noData: {
            'applet ': true,
            'embed ': true,
            'object ': 'clsid:D27CDB6E-AE6D-11cf-96B8-444553540000'
        },
        hasData: function (elem) {
            elem = elem.nodeType ? jQuery.cache[elem[jQuery.expando]] : elem[jQuery.expando];
            return !!elem && !isEmptyDataObject(elem);
        },
        data: function (elem, name, data) {
            return internalData(elem, name, data);
        },
        removeData: function (elem, name) {
            return internalRemoveData(elem, name);
        },
        _data: function (elem, name, data) {
            return internalData(elem, name, data, true);
        },
        _removeData: function (elem, name) {
            return internalRemoveData(elem, name, true);
        }
    });
    jQuery.fn.extend({
        data: function (key, value) {
            var i, name, data, elem = this[0], attrs = elem && elem.attributes;
            if (key === undefined) {
                if (this.length) {
                    data = jQuery.data(elem);
                    if (elem.nodeType === 1 && !jQuery._data(elem, 'parsedAttrs')) {
                        i = attrs.length;
                        while (i--) {
                            name = attrs[i].name;
                            if (name.indexOf('data-') === 0) {
                                name = jQuery.camelCase(name.slice(5));
                                dataAttr(elem, name, data[name]);
                            }
                        }
                        jQuery._data(elem, 'parsedAttrs', true);
                    }
                }
                return data;
            }
            if (typeof key === 'object') {
                return this.each(function () {
                    jQuery.data(this, key);
                });
            }
            return arguments.length > 1 ? this.each(function () {
                jQuery.data(this, key, value);
            }) : elem ? dataAttr(elem, key, jQuery.data(elem, key)) : undefined;
        },
        removeData: function (key) {
            return this.each(function () {
                jQuery.removeData(this, key);
            });
        }
    });
    jQuery.extend({
        queue: function (elem, type, data) {
            var queue;
            if (elem) {
                type = (type || 'fx') + 'queue';
                queue = jQuery._data(elem, type);
                if (data) {
                    if (!queue || jQuery.isArray(data)) {
                        queue = jQuery._data(elem, type, jQuery.makeArray(data));
                    } else {
                        queue.push(data);
                    }
                }
                return queue || [];
            }
        },
        dequeue: function (elem, type) {
            type = type || 'fx';
            var queue = jQuery.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem, type), next = function () {
                    jQuery.dequeue(elem, type);
                };
            if (fn === 'inprogress') {
                fn = queue.shift();
                startLength--;
            }
            if (fn) {
                if (type === 'fx') {
                    queue.unshift('inprogress');
                }
                delete hooks.stop;
                fn.call(elem, next, hooks);
            }
            if (!startLength && hooks) {
                hooks.empty.fire();
            }
        },
        _queueHooks: function (elem, type) {
            var key = type + 'queueHooks';
            return jQuery._data(elem, key) || jQuery._data(elem, key, {
                empty: jQuery.Callbacks('once memory').add(function () {
                    jQuery._removeData(elem, type + 'queue');
                    jQuery._removeData(elem, key);
                })
            });
        }
    });
    jQuery.fn.extend({
        queue: function (type, data) {
            var setter = 2;
            if (typeof type !== 'string') {
                data = type;
                type = 'fx';
                setter--;
            }
            if (arguments.length < setter) {
                return jQuery.queue(this[0], type);
            }
            return data === undefined ? this : this.each(function () {
                var queue = jQuery.queue(this, type, data);
                jQuery._queueHooks(this, type);
                if (type === 'fx' && queue[0] !== 'inprogress') {
                    jQuery.dequeue(this, type);
                }
            });
        },
        dequeue: function (type) {
            return this.each(function () {
                jQuery.dequeue(this, type);
            });
        },
        clearQueue: function (type) {
            return this.queue(type || 'fx', []);
        },
        promise: function (type, obj) {
            var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function () {
                    if (!--count) {
                        defer.resolveWith(elements, [elements]);
                    }
                };
            if (typeof type !== 'string') {
                obj = type;
                type = undefined;
            }
            type = type || 'fx';
            while (i--) {
                tmp = jQuery._data(elements[i], type + 'queueHooks');
                if (tmp && tmp.empty) {
                    count++;
                    tmp.empty.add(resolve);
                }
            }
            resolve();
            return defer.promise(obj);
        }
    });
    var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
    var cssExpand = [
        'Top',
        'Right',
        'Bottom',
        'Left'
    ];
    var isHidden = function (elem, el) {
        elem = el || elem;
        return jQuery.css(elem, 'display') === 'none' || !jQuery.contains(elem.ownerDocument, elem);
    };
    var access = jQuery.access = function (elems, fn, key, value, chainable, emptyGet, raw) {
        var i = 0, length = elems.length, bulk = key == null;
        if (jQuery.type(key) === 'object') {
            chainable = true;
            for (i in key) {
                jQuery.access(elems, fn, i, key[i], true, emptyGet, raw);
            }
        } else if (value !== undefined) {
            chainable = true;
            if (!jQuery.isFunction(value)) {
                raw = true;
            }
            if (bulk) {
                if (raw) {
                    fn.call(elems, value);
                    fn = null;
                } else {
                    bulk = fn;
                    fn = function (elem, key, value) {
                        return bulk.call(jQuery(elem), value);
                    };
                }
            }
            if (fn) {
                for (; i < length; i++) {
                    fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
                }
            }
        }
        return chainable ? elems : bulk ? fn.call(elems) : length ? fn(elems[0], key) : emptyGet;
    };
    var rcheckableType = /^(?:checkbox|radio)$/i;
    (function () {
        var fragment = document.createDocumentFragment(), div = document.createElement('div'), input = document.createElement('input');
        div.setAttribute('className', 't');
        div.innerHTML = '  <link/><table></table><a href=\'/a\'>a</a>';
        support.leadingWhitespace = div.firstChild.nodeType === 3;
        support.tbody = !div.getElementsByTagName('tbody').length;
        support.htmlSerialize = !!div.getElementsByTagName('link').length;
        support.html5Clone = document.createElement('nav').cloneNode(true).outerHTML !== '<:nav></:nav>';
        input.type = 'checkbox';
        input.checked = true;
        fragment.appendChild(input);
        support.appendChecked = input.checked;
        div.innerHTML = '<textarea>x</textarea>';
        support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
        fragment.appendChild(div);
        div.innerHTML = '<input type=\'radio\' checked=\'checked\' name=\'t\'/>';
        support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
        support.noCloneEvent = true;
        if (div.attachEvent) {
            div.attachEvent('onclick', function () {
                support.noCloneEvent = false;
            });
            div.cloneNode(true).click();
        }
        if (support.deleteExpando == null) {
            support.deleteExpando = true;
            try {
                delete div.test;
            } catch (e) {
                support.deleteExpando = false;
            }
        }
        fragment = div = input = null;
    }());
    (function () {
        var i, eventName, div = document.createElement('div');
        for (i in {
                submit: true,
                change: true,
                focusin: true
            }) {
            eventName = 'on' + i;
            if (!(support[i + 'Bubbles'] = eventName in window)) {
                div.setAttribute(eventName, 't');
                support[i + 'Bubbles'] = div.attributes[eventName].expando === false;
            }
        }
        div = null;
    }());
    var rformElems = /^(?:input|select|textarea)$/i, rkeyEvent = /^key/, rmouseEvent = /^(?:mouse|contextmenu)|click/, rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;
    function returnTrue() {
        return true;
    }
    function returnFalse() {
        return false;
    }
    function safeActiveElement() {
        try {
            return document.activeElement;
        } catch (err) {
        }
    }
    jQuery.event = {
        global: {},
        add: function (elem, types, handler, data, selector) {
            var tmp, events, t, handleObjIn, special, eventHandle, handleObj, handlers, type, namespaces, origType, elemData = jQuery._data(elem);
            if (!elemData) {
                return;
            }
            if (handler.handler) {
                handleObjIn = handler;
                handler = handleObjIn.handler;
                selector = handleObjIn.selector;
            }
            if (!handler.guid) {
                handler.guid = jQuery.guid++;
            }
            if (!(events = elemData.events)) {
                events = elemData.events = {};
            }
            if (!(eventHandle = elemData.handle)) {
                eventHandle = elemData.handle = function (e) {
                    return typeof jQuery !== strundefined && (!e || jQuery.event.triggered !== e.type) ? jQuery.event.dispatch.apply(eventHandle.elem, arguments) : undefined;
                };
                eventHandle.elem = elem;
            }
            types = (types || '').match(rnotwhite) || [''];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || '').split('.').sort();
                if (!type) {
                    continue;
                }
                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                special = jQuery.event.special[type] || {};
                handleObj = jQuery.extend({
                    type: type,
                    origType: origType,
                    data: data,
                    handler: handler,
                    guid: handler.guid,
                    selector: selector,
                    needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                    namespace: namespaces.join('.')
                }, handleObjIn);
                if (!(handlers = events[type])) {
                    handlers = events[type] = [];
                    handlers.delegateCount = 0;
                    if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                        if (elem.addEventListener) {
                            elem.addEventListener(type, eventHandle, false);
                        } else if (elem.attachEvent) {
                            elem.attachEvent('on' + type, eventHandle);
                        }
                    }
                }
                if (special.add) {
                    special.add.call(elem, handleObj);
                    if (!handleObj.handler.guid) {
                        handleObj.handler.guid = handler.guid;
                    }
                }
                if (selector) {
                    handlers.splice(handlers.delegateCount++, 0, handleObj);
                } else {
                    handlers.push(handleObj);
                }
                jQuery.event.global[type] = true;
            }
            elem = null;
        },
        remove: function (elem, types, handler, selector, mappedTypes) {
            var j, handleObj, tmp, origCount, t, events, special, handlers, type, namespaces, origType, elemData = jQuery.hasData(elem) && jQuery._data(elem);
            if (!elemData || !(events = elemData.events)) {
                return;
            }
            types = (types || '').match(rnotwhite) || [''];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || '').split('.').sort();
                if (!type) {
                    for (type in events) {
                        jQuery.event.remove(elem, type + types[t], handler, selector, true);
                    }
                    continue;
                }
                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                handlers = events[type] || [];
                tmp = tmp[2] && new RegExp('(^|\\.)' + namespaces.join('\\.(?:.*\\.|)') + '(\\.|$)');
                origCount = j = handlers.length;
                while (j--) {
                    handleObj = handlers[j];
                    if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === '**' && handleObj.selector)) {
                        handlers.splice(j, 1);
                        if (handleObj.selector) {
                            handlers.delegateCount--;
                        }
                        if (special.remove) {
                            special.remove.call(elem, handleObj);
                        }
                    }
                }
                if (origCount && !handlers.length) {
                    if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                        jQuery.removeEvent(elem, type, elemData.handle);
                    }
                    delete events[type];
                }
            }
            if (jQuery.isEmptyObject(events)) {
                delete elemData.handle;
                jQuery._removeData(elem, 'events');
            }
        },
        trigger: function (event, data, elem, onlyHandlers) {
            var handle, ontype, cur, bubbleType, special, tmp, i, eventPath = [elem || document], type = hasOwn.call(event, 'type') ? event.type : event, namespaces = hasOwn.call(event, 'namespace') ? event.namespace.split('.') : [];
            cur = tmp = elem = elem || document;
            if (elem.nodeType === 3 || elem.nodeType === 8) {
                return;
            }
            if (rfocusMorph.test(type + jQuery.event.triggered)) {
                return;
            }
            if (type.indexOf('.') >= 0) {
                namespaces = type.split('.');
                type = namespaces.shift();
                namespaces.sort();
            }
            ontype = type.indexOf(':') < 0 && 'on' + type;
            event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === 'object' && event);
            event.isTrigger = onlyHandlers ? 2 : 3;
            event.namespace = namespaces.join('.');
            event.namespace_re = event.namespace ? new RegExp('(^|\\.)' + namespaces.join('\\.(?:.*\\.|)') + '(\\.|$)') : null;
            event.result = undefined;
            if (!event.target) {
                event.target = elem;
            }
            data = data == null ? [event] : jQuery.makeArray(data, [event]);
            special = jQuery.event.special[type] || {};
            if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
                return;
            }
            if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
                bubbleType = special.delegateType || type;
                if (!rfocusMorph.test(bubbleType + type)) {
                    cur = cur.parentNode;
                }
                for (; cur; cur = cur.parentNode) {
                    eventPath.push(cur);
                    tmp = cur;
                }
                if (tmp === (elem.ownerDocument || document)) {
                    eventPath.push(tmp.defaultView || tmp.parentWindow || window);
                }
            }
            i = 0;
            while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
                event.type = i > 1 ? bubbleType : special.bindType || type;
                handle = (jQuery._data(cur, 'events') || {})[event.type] && jQuery._data(cur, 'handle');
                if (handle) {
                    handle.apply(cur, data);
                }
                handle = ontype && cur[ontype];
                if (handle && handle.apply && jQuery.acceptData(cur)) {
                    event.result = handle.apply(cur, data);
                    if (event.result === false) {
                        event.preventDefault();
                    }
                }
            }
            event.type = type;
            if (!onlyHandlers && !event.isDefaultPrevented()) {
                if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && jQuery.acceptData(elem)) {
                    if (ontype && elem[type] && !jQuery.isWindow(elem)) {
                        tmp = elem[ontype];
                        if (tmp) {
                            elem[ontype] = null;
                        }
                        jQuery.event.triggered = type;
                        try {
                            elem[type]();
                        } catch (e) {
                        }
                        jQuery.event.triggered = undefined;
                        if (tmp) {
                            elem[ontype] = tmp;
                        }
                    }
                }
            }
            return event.result;
        },
        dispatch: function (event) {
            event = jQuery.event.fix(event);
            var i, ret, handleObj, matched, j, handlerQueue = [], args = slice.call(arguments), handlers = (jQuery._data(this, 'events') || {})[event.type] || [], special = jQuery.event.special[event.type] || {};
            args[0] = event;
            event.delegateTarget = this;
            if (special.preDispatch && special.preDispatch.call(this, event) === false) {
                return;
            }
            handlerQueue = jQuery.event.handlers.call(this, event, handlers);
            i = 0;
            while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
                event.currentTarget = matched.elem;
                j = 0;
                while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
                    if (!event.namespace_re || event.namespace_re.test(handleObj.namespace)) {
                        event.handleObj = handleObj;
                        event.data = handleObj.data;
                        ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                        if (ret !== undefined) {
                            if ((event.result = ret) === false) {
                                event.preventDefault();
                                event.stopPropagation();
                            }
                        }
                    }
                }
            }
            if (special.postDispatch) {
                special.postDispatch.call(this, event);
            }
            return event.result;
        },
        handlers: function (event, handlers) {
            var sel, handleObj, matches, i, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
            if (delegateCount && cur.nodeType && (!event.button || event.type !== 'click')) {
                for (; cur != this; cur = cur.parentNode || this) {
                    if (cur.nodeType === 1 && (cur.disabled !== true || event.type !== 'click')) {
                        matches = [];
                        for (i = 0; i < delegateCount; i++) {
                            handleObj = handlers[i];
                            sel = handleObj.selector + ' ';
                            if (matches[sel] === undefined) {
                                matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) >= 0 : jQuery.find(sel, this, null, [cur]).length;
                            }
                            if (matches[sel]) {
                                matches.push(handleObj);
                            }
                        }
                        if (matches.length) {
                            handlerQueue.push({
                                elem: cur,
                                handlers: matches
                            });
                        }
                    }
                }
            }
            if (delegateCount < handlers.length) {
                handlerQueue.push({
                    elem: this,
                    handlers: handlers.slice(delegateCount)
                });
            }
            return handlerQueue;
        },
        fix: function (event) {
            if (event[jQuery.expando]) {
                return event;
            }
            var i, prop, copy, type = event.type, originalEvent = event, fixHook = this.fixHooks[type];
            if (!fixHook) {
                this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};
            }
            copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;
            event = new jQuery.Event(originalEvent);
            i = copy.length;
            while (i--) {
                prop = copy[i];
                event[prop] = originalEvent[prop];
            }
            if (!event.target) {
                event.target = originalEvent.srcElement || document;
            }
            if (event.target.nodeType === 3) {
                event.target = event.target.parentNode;
            }
            event.metaKey = !!event.metaKey;
            return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
        },
        props: 'altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which'.split(' '),
        fixHooks: {},
        keyHooks: {
            props: 'char charCode key keyCode'.split(' '),
            filter: function (event, original) {
                if (event.which == null) {
                    event.which = original.charCode != null ? original.charCode : original.keyCode;
                }
                return event;
            }
        },
        mouseHooks: {
            props: 'button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement'.split(' '),
            filter: function (event, original) {
                var body, eventDoc, doc, button = original.button, fromElement = original.fromElement;
                if (event.pageX == null && original.clientX != null) {
                    eventDoc = event.target.ownerDocument || document;
                    doc = eventDoc.documentElement;
                    body = eventDoc.body;
                    event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
                    event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
                }
                if (!event.relatedTarget && fromElement) {
                    event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
                }
                if (!event.which && button !== undefined) {
                    event.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
                }
                return event;
            }
        },
        special: {
            load: { noBubble: true },
            focus: {
                trigger: function () {
                    if (this !== safeActiveElement() && this.focus) {
                        try {
                            this.focus();
                            return false;
                        } catch (e) {
                        }
                    }
                },
                delegateType: 'focusin'
            },
            blur: {
                trigger: function () {
                    if (this === safeActiveElement() && this.blur) {
                        this.blur();
                        return false;
                    }
                },
                delegateType: 'focusout'
            },
            click: {
                trigger: function () {
                    if (jQuery.nodeName(this, 'input') && this.type === 'checkbox' && this.click) {
                        this.click();
                        return false;
                    }
                },
                _default: function (event) {
                    return jQuery.nodeName(event.target, 'a');
                }
            },
            beforeunload: {
                postDispatch: function (event) {
                    if (event.result !== undefined) {
                        event.originalEvent.returnValue = event.result;
                    }
                }
            }
        },
        simulate: function (type, elem, event, bubble) {
            var e = jQuery.extend(new jQuery.Event(), event, {
                type: type,
                isSimulated: true,
                originalEvent: {}
            });
            if (bubble) {
                jQuery.event.trigger(e, null, elem);
            } else {
                jQuery.event.dispatch.call(elem, e);
            }
            if (e.isDefaultPrevented()) {
                event.preventDefault();
            }
        }
    };
    jQuery.removeEvent = document.removeEventListener ? function (elem, type, handle) {
        if (elem.removeEventListener) {
            elem.removeEventListener(type, handle, false);
        }
    } : function (elem, type, handle) {
        var name = 'on' + type;
        if (elem.detachEvent) {
            if (typeof elem[name] === strundefined) {
                elem[name] = null;
            }
            elem.detachEvent(name, handle);
        }
    };
    jQuery.Event = function (src, props) {
        if (!(this instanceof jQuery.Event)) {
            return new jQuery.Event(src, props);
        }
        if (src && src.type) {
            this.originalEvent = src;
            this.type = src.type;
            this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && (src.returnValue === false || src.getPreventDefault && src.getPreventDefault()) ? returnTrue : returnFalse;
        } else {
            this.type = src;
        }
        if (props) {
            jQuery.extend(this, props);
        }
        this.timeStamp = src && src.timeStamp || jQuery.now();
        this[jQuery.expando] = true;
    };
    jQuery.Event.prototype = {
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,
        preventDefault: function () {
            var e = this.originalEvent;
            this.isDefaultPrevented = returnTrue;
            if (!e) {
                return;
            }
            if (e.preventDefault) {
                e.preventDefault();
            } else {
                e.returnValue = false;
            }
        },
        stopPropagation: function () {
            var e = this.originalEvent;
            this.isPropagationStopped = returnTrue;
            if (!e) {
                return;
            }
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            e.cancelBubble = true;
        },
        stopImmediatePropagation: function () {
            this.isImmediatePropagationStopped = returnTrue;
            this.stopPropagation();
        }
    };
    jQuery.each({
        mouseenter: 'mouseover',
        mouseleave: 'mouseout'
    }, function (orig, fix) {
        jQuery.event.special[orig] = {
            delegateType: fix,
            bindType: fix,
            handle: function (event) {
                var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
                if (!related || related !== target && !jQuery.contains(target, related)) {
                    event.type = handleObj.origType;
                    ret = handleObj.handler.apply(this, arguments);
                    event.type = fix;
                }
                return ret;
            }
        };
    });
    if (!support.submitBubbles) {
        jQuery.event.special.submit = {
            setup: function () {
                if (jQuery.nodeName(this, 'form')) {
                    return false;
                }
                jQuery.event.add(this, 'click._submit keypress._submit', function (e) {
                    var elem = e.target, form = jQuery.nodeName(elem, 'input') || jQuery.nodeName(elem, 'button') ? elem.form : undefined;
                    if (form && !jQuery._data(form, 'submitBubbles')) {
                        jQuery.event.add(form, 'submit._submit', function (event) {
                            event._submit_bubble = true;
                        });
                        jQuery._data(form, 'submitBubbles', true);
                    }
                });
            },
            postDispatch: function (event) {
                if (event._submit_bubble) {
                    delete event._submit_bubble;
                    if (this.parentNode && !event.isTrigger) {
                        jQuery.event.simulate('submit', this.parentNode, event, true);
                    }
                }
            },
            teardown: function () {
                if (jQuery.nodeName(this, 'form')) {
                    return false;
                }
                jQuery.event.remove(this, '._submit');
            }
        };
    }
    if (!support.changeBubbles) {
        jQuery.event.special.change = {
            setup: function () {
                if (rformElems.test(this.nodeName)) {
                    if (this.type === 'checkbox' || this.type === 'radio') {
                        jQuery.event.add(this, 'propertychange._change', function (event) {
                            if (event.originalEvent.propertyName === 'checked') {
                                this._just_changed = true;
                            }
                        });
                        jQuery.event.add(this, 'click._change', function (event) {
                            if (this._just_changed && !event.isTrigger) {
                                this._just_changed = false;
                            }
                            jQuery.event.simulate('change', this, event, true);
                        });
                    }
                    return false;
                }
                jQuery.event.add(this, 'beforeactivate._change', function (e) {
                    var elem = e.target;
                    if (rformElems.test(elem.nodeName) && !jQuery._data(elem, 'changeBubbles')) {
                        jQuery.event.add(elem, 'change._change', function (event) {
                            if (this.parentNode && !event.isSimulated && !event.isTrigger) {
                                jQuery.event.simulate('change', this.parentNode, event, true);
                            }
                        });
                        jQuery._data(elem, 'changeBubbles', true);
                    }
                });
            },
            handle: function (event) {
                var elem = event.target;
                if (this !== elem || event.isSimulated || event.isTrigger || elem.type !== 'radio' && elem.type !== 'checkbox') {
                    return event.handleObj.handler.apply(this, arguments);
                }
            },
            teardown: function () {
                jQuery.event.remove(this, '._change');
                return !rformElems.test(this.nodeName);
            }
        };
    }
    if (!support.focusinBubbles) {
        jQuery.each({
            focus: 'focusin',
            blur: 'focusout'
        }, function (orig, fix) {
            var handler = function (event) {
                jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);
            };
            jQuery.event.special[fix] = {
                setup: function () {
                    var doc = this.ownerDocument || this, attaches = jQuery._data(doc, fix);
                    if (!attaches) {
                        doc.addEventListener(orig, handler, true);
                    }
                    jQuery._data(doc, fix, (attaches || 0) + 1);
                },
                teardown: function () {
                    var doc = this.ownerDocument || this, attaches = jQuery._data(doc, fix) - 1;
                    if (!attaches) {
                        doc.removeEventListener(orig, handler, true);
                        jQuery._removeData(doc, fix);
                    } else {
                        jQuery._data(doc, fix, attaches);
                    }
                }
            };
        });
    }
    jQuery.fn.extend({
        on: function (types, selector, data, fn, one) {
            var type, origFn;
            if (typeof types === 'object') {
                if (typeof selector !== 'string') {
                    data = data || selector;
                    selector = undefined;
                }
                for (type in types) {
                    this.on(type, selector, data, types[type], one);
                }
                return this;
            }
            if (data == null && fn == null) {
                fn = selector;
                data = selector = undefined;
            } else if (fn == null) {
                if (typeof selector === 'string') {
                    fn = data;
                    data = undefined;
                } else {
                    fn = data;
                    data = selector;
                    selector = undefined;
                }
            }
            if (fn === false) {
                fn = returnFalse;
            } else if (!fn) {
                return this;
            }
            if (one === 1) {
                origFn = fn;
                fn = function (event) {
                    jQuery().off(event);
                    return origFn.apply(this, arguments);
                };
                fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
            }
            return this.each(function () {
                jQuery.event.add(this, types, fn, data, selector);
            });
        },
        one: function (types, selector, data, fn) {
            return this.on(types, selector, data, fn, 1);
        },
        off: function (types, selector, fn) {
            var handleObj, type;
            if (types && types.preventDefault && types.handleObj) {
                handleObj = types.handleObj;
                jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + '.' + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
                return this;
            }
            if (typeof types === 'object') {
                for (type in types) {
                    this.off(type, selector, types[type]);
                }
                return this;
            }
            if (selector === false || typeof selector === 'function') {
                fn = selector;
                selector = undefined;
            }
            if (fn === false) {
                fn = returnFalse;
            }
            return this.each(function () {
                jQuery.event.remove(this, types, fn, selector);
            });
        },
        trigger: function (type, data) {
            return this.each(function () {
                jQuery.event.trigger(type, data, this);
            });
        },
        triggerHandler: function (type, data) {
            var elem = this[0];
            if (elem) {
                return jQuery.event.trigger(type, data, elem, true);
            }
        }
    });
    function createSafeFragment(document) {
        var list = nodeNames.split('|'), safeFrag = document.createDocumentFragment();
        if (safeFrag.createElement) {
            while (list.length) {
                safeFrag.createElement(list.pop());
            }
        }
        return safeFrag;
    }
    var nodeNames = 'abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|' + 'header|hgroup|mark|meter|nav|output|progress|section|summary|time|video', rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g, rnoshimcache = new RegExp('<(?:' + nodeNames + ')[\\s/>]', 'i'), rleadingWhitespace = /^\s+/, rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, rtagName = /<([\w:]+)/, rtbody = /<tbody/i, rhtml = /<|&#?\w+;/, rnoInnerhtml = /<(?:script|style|link)/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rscriptType = /^$|\/(?:java|ecma)script/i, rscriptTypeMasked = /^true\/(.*)/, rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g, wrapMap = {
            option: [
                1,
                '<select multiple=\'multiple\'>',
                '</select>'
            ],
            legend: [
                1,
                '<fieldset>',
                '</fieldset>'
            ],
            area: [
                1,
                '<map>',
                '</map>'
            ],
            param: [
                1,
                '<object>',
                '</object>'
            ],
            thead: [
                1,
                '<table>',
                '</table>'
            ],
            tr: [
                2,
                '<table><tbody>',
                '</tbody></table>'
            ],
            col: [
                2,
                '<table><tbody></tbody><colgroup>',
                '</colgroup></table>'
            ],
            td: [
                3,
                '<table><tbody><tr>',
                '</tr></tbody></table>'
            ],
            _default: support.htmlSerialize ? [
                0,
                '',
                ''
            ] : [
                1,
                'X<div>',
                '</div>'
            ]
        }, safeFragment = createSafeFragment(document), fragmentDiv = safeFragment.appendChild(document.createElement('div'));
    wrapMap.optgroup = wrapMap.option;
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;
    function getAll(context, tag) {
        var elems, elem, i = 0, found = typeof context.getElementsByTagName !== strundefined ? context.getElementsByTagName(tag || '*') : typeof context.querySelectorAll !== strundefined ? context.querySelectorAll(tag || '*') : undefined;
        if (!found) {
            for (found = [], elems = context.childNodes || context; (elem = elems[i]) != null; i++) {
                if (!tag || jQuery.nodeName(elem, tag)) {
                    found.push(elem);
                } else {
                    jQuery.merge(found, getAll(elem, tag));
                }
            }
        }
        return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([context], found) : found;
    }
    function fixDefaultChecked(elem) {
        if (rcheckableType.test(elem.type)) {
            elem.defaultChecked = elem.checked;
        }
    }
    function manipulationTarget(elem, content) {
        return jQuery.nodeName(elem, 'table') && jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, 'tr') ? elem.getElementsByTagName('tbody')[0] || elem.appendChild(elem.ownerDocument.createElement('tbody')) : elem;
    }
    function disableScript(elem) {
        elem.type = (jQuery.find.attr(elem, 'type') !== null) + '/' + elem.type;
        return elem;
    }
    function restoreScript(elem) {
        var match = rscriptTypeMasked.exec(elem.type);
        if (match) {
            elem.type = match[1];
        } else {
            elem.removeAttribute('type');
        }
        return elem;
    }
    function setGlobalEval(elems, refElements) {
        var elem, i = 0;
        for (; (elem = elems[i]) != null; i++) {
            jQuery._data(elem, 'globalEval', !refElements || jQuery._data(refElements[i], 'globalEval'));
        }
    }
    function cloneCopyEvent(src, dest) {
        if (dest.nodeType !== 1 || !jQuery.hasData(src)) {
            return;
        }
        var type, i, l, oldData = jQuery._data(src), curData = jQuery._data(dest, oldData), events = oldData.events;
        if (events) {
            delete curData.handle;
            curData.events = {};
            for (type in events) {
                for (i = 0, l = events[type].length; i < l; i++) {
                    jQuery.event.add(dest, type, events[type][i]);
                }
            }
        }
        if (curData.data) {
            curData.data = jQuery.extend({}, curData.data);
        }
    }
    function fixCloneNodeIssues(src, dest) {
        var nodeName, e, data;
        if (dest.nodeType !== 1) {
            return;
        }
        nodeName = dest.nodeName.toLowerCase();
        if (!support.noCloneEvent && dest[jQuery.expando]) {
            data = jQuery._data(dest);
            for (e in data.events) {
                jQuery.removeEvent(dest, e, data.handle);
            }
            dest.removeAttribute(jQuery.expando);
        }
        if (nodeName === 'script' && dest.text !== src.text) {
            disableScript(dest).text = src.text;
            restoreScript(dest);
        } else if (nodeName === 'object') {
            if (dest.parentNode) {
                dest.outerHTML = src.outerHTML;
            }
            if (support.html5Clone && (src.innerHTML && !jQuery.trim(dest.innerHTML))) {
                dest.innerHTML = src.innerHTML;
            }
        } else if (nodeName === 'input' && rcheckableType.test(src.type)) {
            dest.defaultChecked = dest.checked = src.checked;
            if (dest.value !== src.value) {
                dest.value = src.value;
            }
        } else if (nodeName === 'option') {
            dest.defaultSelected = dest.selected = src.defaultSelected;
        } else if (nodeName === 'input' || nodeName === 'textarea') {
            dest.defaultValue = src.defaultValue;
        }
    }
    jQuery.extend({
        clone: function (elem, dataAndEvents, deepDataAndEvents) {
            var destElements, node, clone, i, srcElements, inPage = jQuery.contains(elem.ownerDocument, elem);
            if (support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test('<' + elem.nodeName + '>')) {
                clone = elem.cloneNode(true);
            } else {
                fragmentDiv.innerHTML = elem.outerHTML;
                fragmentDiv.removeChild(clone = fragmentDiv.firstChild);
            }
            if ((!support.noCloneEvent || !support.noCloneChecked) && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
                destElements = getAll(clone);
                srcElements = getAll(elem);
                for (i = 0; (node = srcElements[i]) != null; ++i) {
                    if (destElements[i]) {
                        fixCloneNodeIssues(node, destElements[i]);
                    }
                }
            }
            if (dataAndEvents) {
                if (deepDataAndEvents) {
                    srcElements = srcElements || getAll(elem);
                    destElements = destElements || getAll(clone);
                    for (i = 0; (node = srcElements[i]) != null; i++) {
                        cloneCopyEvent(node, destElements[i]);
                    }
                } else {
                    cloneCopyEvent(elem, clone);
                }
            }
            destElements = getAll(clone, 'script');
            if (destElements.length > 0) {
                setGlobalEval(destElements, !inPage && getAll(elem, 'script'));
            }
            destElements = srcElements = node = null;
            return clone;
        },
        buildFragment: function (elems, context, scripts, selection) {
            var j, elem, contains, tmp, tag, tbody, wrap, l = elems.length, safe = createSafeFragment(context), nodes = [], i = 0;
            for (; i < l; i++) {
                elem = elems[i];
                if (elem || elem === 0) {
                    if (jQuery.type(elem) === 'object') {
                        jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
                    } else if (!rhtml.test(elem)) {
                        nodes.push(context.createTextNode(elem));
                    } else {
                        tmp = tmp || safe.appendChild(context.createElement('div'));
                        tag = (rtagName.exec(elem) || [
                            '',
                            ''
                        ])[1].toLowerCase();
                        wrap = wrapMap[tag] || wrapMap._default;
                        tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, '<$1></$2>') + wrap[2];
                        j = wrap[0];
                        while (j--) {
                            tmp = tmp.lastChild;
                        }
                        if (!support.leadingWhitespace && rleadingWhitespace.test(elem)) {
                            nodes.push(context.createTextNode(rleadingWhitespace.exec(elem)[0]));
                        }
                        if (!support.tbody) {
                            elem = tag === 'table' && !rtbody.test(elem) ? tmp.firstChild : wrap[1] === '<table>' && !rtbody.test(elem) ? tmp : 0;
                            j = elem && elem.childNodes.length;
                            while (j--) {
                                if (jQuery.nodeName(tbody = elem.childNodes[j], 'tbody') && !tbody.childNodes.length) {
                                    elem.removeChild(tbody);
                                }
                            }
                        }
                        jQuery.merge(nodes, tmp.childNodes);
                        tmp.textContent = '';
                        while (tmp.firstChild) {
                            tmp.removeChild(tmp.firstChild);
                        }
                        tmp = safe.lastChild;
                    }
                }
            }
            if (tmp) {
                safe.removeChild(tmp);
            }
            if (!support.appendChecked) {
                jQuery.grep(getAll(nodes, 'input'), fixDefaultChecked);
            }
            i = 0;
            while (elem = nodes[i++]) {
                if (selection && jQuery.inArray(elem, selection) !== -1) {
                    continue;
                }
                contains = jQuery.contains(elem.ownerDocument, elem);
                tmp = getAll(safe.appendChild(elem), 'script');
                if (contains) {
                    setGlobalEval(tmp);
                }
                if (scripts) {
                    j = 0;
                    while (elem = tmp[j++]) {
                        if (rscriptType.test(elem.type || '')) {
                            scripts.push(elem);
                        }
                    }
                }
            }
            tmp = null;
            return safe;
        },
        cleanData: function (elems, acceptData) {
            var elem, type, id, data, i = 0, internalKey = jQuery.expando, cache = jQuery.cache, deleteExpando = support.deleteExpando, special = jQuery.event.special;
            for (; (elem = elems[i]) != null; i++) {
                if (acceptData || jQuery.acceptData(elem)) {
                    id = elem[internalKey];
                    data = id && cache[id];
                    if (data) {
                        if (data.events) {
                            for (type in data.events) {
                                if (special[type]) {
                                    jQuery.event.remove(elem, type);
                                } else {
                                    jQuery.removeEvent(elem, type, data.handle);
                                }
                            }
                        }
                        if (cache[id]) {
                            delete cache[id];
                            if (deleteExpando) {
                                delete elem[internalKey];
                            } else if (typeof elem.removeAttribute !== strundefined) {
                                elem.removeAttribute(internalKey);
                            } else {
                                elem[internalKey] = null;
                            }
                            deletedIds.push(id);
                        }
                    }
                }
            }
        }
    });
    jQuery.fn.extend({
        text: function (value) {
            return access(this, function (value) {
                return value === undefined ? jQuery.text(this) : this.empty().append((this[0] && this[0].ownerDocument || document).createTextNode(value));
            }, null, value, arguments.length);
        },
        append: function () {
            return this.domManip(arguments, function (elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.appendChild(elem);
                }
            });
        },
        prepend: function () {
            return this.domManip(arguments, function (elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.insertBefore(elem, target.firstChild);
                }
            });
        },
        before: function () {
            return this.domManip(arguments, function (elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this);
                }
            });
        },
        after: function () {
            return this.domManip(arguments, function (elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this.nextSibling);
                }
            });
        },
        remove: function (selector, keepData) {
            var elem, elems = selector ? jQuery.filter(selector, this) : this, i = 0;
            for (; (elem = elems[i]) != null; i++) {
                if (!keepData && elem.nodeType === 1) {
                    jQuery.cleanData(getAll(elem));
                }
                if (elem.parentNode) {
                    if (keepData && jQuery.contains(elem.ownerDocument, elem)) {
                        setGlobalEval(getAll(elem, 'script'));
                    }
                    elem.parentNode.removeChild(elem);
                }
            }
            return this;
        },
        empty: function () {
            var elem, i = 0;
            for (; (elem = this[i]) != null; i++) {
                if (elem.nodeType === 1) {
                    jQuery.cleanData(getAll(elem, false));
                }
                while (elem.firstChild) {
                    elem.removeChild(elem.firstChild);
                }
                if (elem.options && jQuery.nodeName(elem, 'select')) {
                    elem.options.length = 0;
                }
            }
            return this;
        },
        clone: function (dataAndEvents, deepDataAndEvents) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
            return this.map(function () {
                return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
            });
        },
        html: function (value) {
            return access(this, function (value) {
                var elem = this[0] || {}, i = 0, l = this.length;
                if (value === undefined) {
                    return elem.nodeType === 1 ? elem.innerHTML.replace(rinlinejQuery, '') : undefined;
                }
                if (typeof value === 'string' && !rnoInnerhtml.test(value) && (support.htmlSerialize || !rnoshimcache.test(value)) && (support.leadingWhitespace || !rleadingWhitespace.test(value)) && !wrapMap[(rtagName.exec(value) || [
                        '',
                        ''
                    ])[1].toLowerCase()]) {
                    value = value.replace(rxhtmlTag, '<$1></$2>');
                    try {
                        for (; i < l; i++) {
                            elem = this[i] || {};
                            if (elem.nodeType === 1) {
                                jQuery.cleanData(getAll(elem, false));
                                elem.innerHTML = value;
                            }
                        }
                        elem = 0;
                    } catch (e) {
                    }
                }
                if (elem) {
                    this.empty().append(value);
                }
            }, null, value, arguments.length);
        },
        replaceWith: function () {
            var arg = arguments[0];
            this.domManip(arguments, function (elem) {
                arg = this.parentNode;
                jQuery.cleanData(getAll(this));
                if (arg) {
                    arg.replaceChild(elem, this);
                }
            });
            return arg && (arg.length || arg.nodeType) ? this : this.remove();
        },
        detach: function (selector) {
            return this.remove(selector, true);
        },
        domManip: function (args, callback) {
            args = concat.apply([], args);
            var first, node, hasScripts, scripts, doc, fragment, i = 0, l = this.length, set = this, iNoClone = l - 1, value = args[0], isFunction = jQuery.isFunction(value);
            if (isFunction || l > 1 && typeof value === 'string' && !support.checkClone && rchecked.test(value)) {
                return this.each(function (index) {
                    var self = set.eq(index);
                    if (isFunction) {
                        args[0] = value.call(this, index, self.html());
                    }
                    self.domManip(args, callback);
                });
            }
            if (l) {
                fragment = jQuery.buildFragment(args, this[0].ownerDocument, false, this);
                first = fragment.firstChild;
                if (fragment.childNodes.length === 1) {
                    fragment = first;
                }
                if (first) {
                    scripts = jQuery.map(getAll(fragment, 'script'), disableScript);
                    hasScripts = scripts.length;
                    for (; i < l; i++) {
                        node = fragment;
                        if (i !== iNoClone) {
                            node = jQuery.clone(node, true, true);
                            if (hasScripts) {
                                jQuery.merge(scripts, getAll(node, 'script'));
                            }
                        }
                        callback.call(this[i], node, i);
                    }
                    if (hasScripts) {
                        doc = scripts[scripts.length - 1].ownerDocument;
                        jQuery.map(scripts, restoreScript);
                        for (i = 0; i < hasScripts; i++) {
                            node = scripts[i];
                            if (rscriptType.test(node.type || '') && !jQuery._data(node, 'globalEval') && jQuery.contains(doc, node)) {
                                if (node.src) {
                                    if (jQuery._evalUrl) {
                                        jQuery._evalUrl(node.src);
                                    }
                                } else {
                                    jQuery.globalEval((node.text || node.textContent || node.innerHTML || '').replace(rcleanScript, ''));
                                }
                            }
                        }
                    }
                    fragment = first = null;
                }
            }
            return this;
        }
    });
    jQuery.each({
        appendTo: 'append',
        prependTo: 'prepend',
        insertBefore: 'before',
        insertAfter: 'after',
        replaceAll: 'replaceWith'
    }, function (name, original) {
        jQuery.fn[name] = function (selector) {
            var elems, i = 0, ret = [], insert = jQuery(selector), last = insert.length - 1;
            for (; i <= last; i++) {
                elems = i === last ? this : this.clone(true);
                jQuery(insert[i])[original](elems);
                push.apply(ret, elems.get());
            }
            return this.pushStack(ret);
        };
    });
    var iframe, elemdisplay = {};
    function actualDisplay(name, doc) {
        var elem = jQuery(doc.createElement(name)).appendTo(doc.body), display = window.getDefaultComputedStyle ? window.getDefaultComputedStyle(elem[0]).display : jQuery.css(elem[0], 'display');
        elem.detach();
        return display;
    }
    function defaultDisplay(nodeName) {
        var doc = document, display = elemdisplay[nodeName];
        if (!display) {
            display = actualDisplay(nodeName, doc);
            if (display === 'none' || !display) {
                iframe = (iframe || jQuery('<iframe frameborder=\'0\' width=\'0\' height=\'0\'/>')).appendTo(doc.documentElement);
                doc = (iframe[0].contentWindow || iframe[0].contentDocument).document;
                doc.write();
                doc.close();
                display = actualDisplay(nodeName, doc);
                iframe.detach();
            }
            elemdisplay[nodeName] = display;
        }
        return display;
    }
    (function () {
        var a, shrinkWrapBlocksVal, div = document.createElement('div'), divReset = '-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;' + 'display:block;padding:0;margin:0;border:0';
        div.innerHTML = '  <link/><table></table><a href=\'/a\'>a</a><input type=\'checkbox\'/>';
        a = div.getElementsByTagName('a')[0];
        a.style.cssText = 'float:left;opacity:.5';
        support.opacity = /^0.5/.test(a.style.opacity);
        support.cssFloat = !!a.style.cssFloat;
        div.style.backgroundClip = 'content-box';
        div.cloneNode(true).style.backgroundClip = '';
        support.clearCloneStyle = div.style.backgroundClip === 'content-box';
        a = div = null;
        support.shrinkWrapBlocks = function () {
            var body, container, div, containerStyles;
            if (shrinkWrapBlocksVal == null) {
                body = document.getElementsByTagName('body')[0];
                if (!body) {
                    return;
                }
                containerStyles = 'border:0;width:0;height:0;position:absolute;top:0;left:-9999px';
                container = document.createElement('div');
                div = document.createElement('div');
                body.appendChild(container).appendChild(div);
                shrinkWrapBlocksVal = false;
                if (typeof div.style.zoom !== strundefined) {
                    div.style.cssText = divReset + ';width:1px;padding:1px;zoom:1';
                    div.innerHTML = '<div></div>';
                    div.firstChild.style.width = '5px';
                    shrinkWrapBlocksVal = div.offsetWidth !== 3;
                }
                body.removeChild(container);
                body = container = div = null;
            }
            return shrinkWrapBlocksVal;
        };
    }());
    var rmargin = /^margin/;
    var rnumnonpx = new RegExp('^(' + pnum + ')(?!px)[a-z%]+$', 'i');
    var getStyles, curCSS, rposition = /^(top|right|bottom|left)$/;
    if (window.getComputedStyle) {
        getStyles = function (elem) {
            return elem.ownerDocument.defaultView.getComputedStyle(elem, null);
        };
        curCSS = function (elem, name, computed) {
            var width, minWidth, maxWidth, ret, style = elem.style;
            computed = computed || getStyles(elem);
            ret = computed ? computed.getPropertyValue(name) || computed[name] : undefined;
            if (computed) {
                if (ret === '' && !jQuery.contains(elem.ownerDocument, elem)) {
                    ret = jQuery.style(elem, name);
                }
                if (rnumnonpx.test(ret) && rmargin.test(name)) {
                    width = style.width;
                    minWidth = style.minWidth;
                    maxWidth = style.maxWidth;
                    style.minWidth = style.maxWidth = style.width = ret;
                    ret = computed.width;
                    style.width = width;
                    style.minWidth = minWidth;
                    style.maxWidth = maxWidth;
                }
            }
            return ret === undefined ? ret : ret + '';
        };
    } else if (document.documentElement.currentStyle) {
        getStyles = function (elem) {
            return elem.currentStyle;
        };
        curCSS = function (elem, name, computed) {
            var left, rs, rsLeft, ret, style = elem.style;
            computed = computed || getStyles(elem);
            ret = computed ? computed[name] : undefined;
            if (ret == null && style && style[name]) {
                ret = style[name];
            }
            if (rnumnonpx.test(ret) && !rposition.test(name)) {
                left = style.left;
                rs = elem.runtimeStyle;
                rsLeft = rs && rs.left;
                if (rsLeft) {
                    rs.left = elem.currentStyle.left;
                }
                style.left = name === 'fontSize' ? '1em' : ret;
                ret = style.pixelLeft + 'px';
                style.left = left;
                if (rsLeft) {
                    rs.left = rsLeft;
                }
            }
            return ret === undefined ? ret : ret + '' || 'auto';
        };
    }
    function addGetHookIf(conditionFn, hookFn) {
        return {
            get: function () {
                var condition = conditionFn();
                if (condition == null) {
                    return;
                }
                if (condition) {
                    delete this.get;
                    return;
                }
                return (this.get = hookFn).apply(this, arguments);
            }
        };
    }
    (function () {
        var a, reliableHiddenOffsetsVal, boxSizingVal, boxSizingReliableVal, pixelPositionVal, reliableMarginRightVal, div = document.createElement('div'), containerStyles = 'border:0;width:0;height:0;position:absolute;top:0;left:-9999px', divReset = '-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;' + 'display:block;padding:0;margin:0;border:0';
        div.innerHTML = '  <link/><table></table><a href=\'/a\'>a</a><input type=\'checkbox\'/>';
        a = div.getElementsByTagName('a')[0];
        a.style.cssText = 'float:left;opacity:.5';
        support.opacity = /^0.5/.test(a.style.opacity);
        support.cssFloat = !!a.style.cssFloat;
        div.style.backgroundClip = 'content-box';
        div.cloneNode(true).style.backgroundClip = '';
        support.clearCloneStyle = div.style.backgroundClip === 'content-box';
        a = div = null;
        jQuery.extend(support, {
            reliableHiddenOffsets: function () {
                if (reliableHiddenOffsetsVal != null) {
                    return reliableHiddenOffsetsVal;
                }
                var container, tds, isSupported, div = document.createElement('div'), body = document.getElementsByTagName('body')[0];
                if (!body) {
                    return;
                }
                div.setAttribute('className', 't');
                div.innerHTML = '  <link/><table></table><a href=\'/a\'>a</a><input type=\'checkbox\'/>';
                container = document.createElement('div');
                container.style.cssText = containerStyles;
                body.appendChild(container).appendChild(div);
                div.innerHTML = '<table><tr><td></td><td>t</td></tr></table>';
                tds = div.getElementsByTagName('td');
                tds[0].style.cssText = 'padding:0;margin:0;border:0;display:none';
                isSupported = tds[0].offsetHeight === 0;
                tds[0].style.display = '';
                tds[1].style.display = 'none';
                reliableHiddenOffsetsVal = isSupported && tds[0].offsetHeight === 0;
                body.removeChild(container);
                div = body = null;
                return reliableHiddenOffsetsVal;
            },
            boxSizing: function () {
                if (boxSizingVal == null) {
                    computeStyleTests();
                }
                return boxSizingVal;
            },
            boxSizingReliable: function () {
                if (boxSizingReliableVal == null) {
                    computeStyleTests();
                }
                return boxSizingReliableVal;
            },
            pixelPosition: function () {
                if (pixelPositionVal == null) {
                    computeStyleTests();
                }
                return pixelPositionVal;
            },
            reliableMarginRight: function () {
                var body, container, div, marginDiv;
                if (reliableMarginRightVal == null && window.getComputedStyle) {
                    body = document.getElementsByTagName('body')[0];
                    if (!body) {
                        return;
                    }
                    container = document.createElement('div');
                    div = document.createElement('div');
                    container.style.cssText = containerStyles;
                    body.appendChild(container).appendChild(div);
                    marginDiv = div.appendChild(document.createElement('div'));
                    marginDiv.style.cssText = div.style.cssText = divReset;
                    marginDiv.style.marginRight = marginDiv.style.width = '0';
                    div.style.width = '1px';
                    reliableMarginRightVal = !parseFloat((window.getComputedStyle(marginDiv, null) || {}).marginRight);
                    body.removeChild(container);
                }
                return reliableMarginRightVal;
            }
        });
        function computeStyleTests() {
            var container, div, body = document.getElementsByTagName('body')[0];
            if (!body) {
                return;
            }
            container = document.createElement('div');
            div = document.createElement('div');
            container.style.cssText = containerStyles;
            body.appendChild(container).appendChild(div);
            div.style.cssText = '-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;' + 'position:absolute;display:block;padding:1px;border:1px;width:4px;' + 'margin-top:1%;top:1%';
            jQuery.swap(body, body.style.zoom != null ? { zoom: 1 } : {}, function () {
                boxSizingVal = div.offsetWidth === 4;
            });
            boxSizingReliableVal = true;
            pixelPositionVal = false;
            reliableMarginRightVal = true;
            if (window.getComputedStyle) {
                pixelPositionVal = (window.getComputedStyle(div, null) || {}).top !== '1%';
                boxSizingReliableVal = (window.getComputedStyle(div, null) || { width: '4px' }).width === '4px';
            }
            body.removeChild(container);
            div = body = null;
        }
    }());
    jQuery.swap = function (elem, options, callback, args) {
        var ret, name, old = {};
        for (name in options) {
            old[name] = elem.style[name];
            elem.style[name] = options[name];
        }
        ret = callback.apply(elem, args || []);
        for (name in options) {
            elem.style[name] = old[name];
        }
        return ret;
    };
    var ralpha = /alpha\([^)]*\)/i, ropacity = /opacity\s*=\s*([^)]*)/, rdisplayswap = /^(none|table(?!-c[ea]).+)/, rnumsplit = new RegExp('^(' + pnum + ')(.*)$', 'i'), rrelNum = new RegExp('^([+-])=(' + pnum + ')', 'i'), cssShow = {
            position: 'absolute',
            visibility: 'hidden',
            display: 'block'
        }, cssNormalTransform = {
            letterSpacing: 0,
            fontWeight: 400
        }, cssPrefixes = [
            'Webkit',
            'O',
            'Moz',
            'ms'
        ];
    function vendorPropName(style, name) {
        if (name in style) {
            return name;
        }
        var capName = name.charAt(0).toUpperCase() + name.slice(1), origName = name, i = cssPrefixes.length;
        while (i--) {
            name = cssPrefixes[i] + capName;
            if (name in style) {
                return name;
            }
        }
        return origName;
    }
    function showHide(elements, show) {
        var display, elem, hidden, values = [], index = 0, length = elements.length;
        for (; index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
                continue;
            }
            values[index] = jQuery._data(elem, 'olddisplay');
            display = elem.style.display;
            if (show) {
                if (!values[index] && display === 'none') {
                    elem.style.display = '';
                }
                if (elem.style.display === '' && isHidden(elem)) {
                    values[index] = jQuery._data(elem, 'olddisplay', defaultDisplay(elem.nodeName));
                }
            } else {
                if (!values[index]) {
                    hidden = isHidden(elem);
                    if (display && display !== 'none' || !hidden) {
                        jQuery._data(elem, 'olddisplay', hidden ? display : jQuery.css(elem, 'display'));
                    }
                }
            }
        }
        for (index = 0; index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
                continue;
            }
            if (!show || elem.style.display === 'none' || elem.style.display === '') {
                elem.style.display = show ? values[index] || '' : 'none';
            }
        }
        return elements;
    }
    function setPositiveNumber(elem, value, subtract) {
        var matches = rnumsplit.exec(value);
        return matches ? Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || 'px') : value;
    }
    function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
        var i = extra === (isBorderBox ? 'border' : 'content') ? 4 : name === 'width' ? 1 : 0, val = 0;
        for (; i < 4; i += 2) {
            if (extra === 'margin') {
                val += jQuery.css(elem, extra + cssExpand[i], true, styles);
            }
            if (isBorderBox) {
                if (extra === 'content') {
                    val -= jQuery.css(elem, 'padding' + cssExpand[i], true, styles);
                }
                if (extra !== 'margin') {
                    val -= jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles);
                }
            } else {
                val += jQuery.css(elem, 'padding' + cssExpand[i], true, styles);
                if (extra !== 'padding') {
                    val += jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles);
                }
            }
        }
        return val;
    }
    function getWidthOrHeight(elem, name, extra) {
        var valueIsBorderBox = true, val = name === 'width' ? elem.offsetWidth : elem.offsetHeight, styles = getStyles(elem), isBorderBox = support.boxSizing() && jQuery.css(elem, 'boxSizing', false, styles) === 'border-box';
        if (val <= 0 || val == null) {
            val = curCSS(elem, name, styles);
            if (val < 0 || val == null) {
                val = elem.style[name];
            }
            if (rnumnonpx.test(val)) {
                return val;
            }
            valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]);
            val = parseFloat(val) || 0;
        }
        return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? 'border' : 'content'), valueIsBorderBox, styles) + 'px';
    }
    jQuery.extend({
        cssHooks: {
            opacity: {
                get: function (elem, computed) {
                    if (computed) {
                        var ret = curCSS(elem, 'opacity');
                        return ret === '' ? '1' : ret;
                    }
                }
            }
        },
        cssNumber: {
            'columnCount': true,
            'fillOpacity': true,
            'fontWeight': true,
            'lineHeight': true,
            'opacity': true,
            'order': true,
            'orphans': true,
            'widows': true,
            'zIndex': true,
            'zoom': true
        },
        cssProps: { 'float': support.cssFloat ? 'cssFloat' : 'styleFloat' },
        style: function (elem, name, value, extra) {
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
                return;
            }
            var ret, type, hooks, origName = jQuery.camelCase(name), style = elem.style;
            name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName));
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            if (value !== undefined) {
                type = typeof value;
                if (type === 'string' && (ret = rrelNum.exec(value))) {
                    value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name));
                    type = 'number';
                }
                if (value == null || value !== value) {
                    return;
                }
                if (type === 'number' && !jQuery.cssNumber[origName]) {
                    value += 'px';
                }
                if (!support.clearCloneStyle && value === '' && name.indexOf('background') === 0) {
                    style[name] = 'inherit';
                }
                if (!hooks || !('set' in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
                    try {
                        style[name] = '';
                        style[name] = value;
                    } catch (e) {
                    }
                }
            } else {
                if (hooks && 'get' in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
                    return ret;
                }
                return style[name];
            }
        },
        css: function (elem, name, extra, styles) {
            var num, val, hooks, origName = jQuery.camelCase(name);
            name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName));
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            if (hooks && 'get' in hooks) {
                val = hooks.get(elem, true, extra);
            }
            if (val === undefined) {
                val = curCSS(elem, name, styles);
            }
            if (val === 'normal' && name in cssNormalTransform) {
                val = cssNormalTransform[name];
            }
            if (extra === '' || extra) {
                num = parseFloat(val);
                return extra === true || jQuery.isNumeric(num) ? num || 0 : val;
            }
            return val;
        }
    });
    jQuery.each([
        'height',
        'width'
    ], function (i, name) {
        jQuery.cssHooks[name] = {
            get: function (elem, computed, extra) {
                if (computed) {
                    return elem.offsetWidth === 0 && rdisplayswap.test(jQuery.css(elem, 'display')) ? jQuery.swap(elem, cssShow, function () {
                        return getWidthOrHeight(elem, name, extra);
                    }) : getWidthOrHeight(elem, name, extra);
                }
            },
            set: function (elem, value, extra) {
                var styles = extra && getStyles(elem);
                return setPositiveNumber(elem, value, extra ? augmentWidthOrHeight(elem, name, extra, support.boxSizing() && jQuery.css(elem, 'boxSizing', false, styles) === 'border-box', styles) : 0);
            }
        };
    });
    if (!support.opacity) {
        jQuery.cssHooks.opacity = {
            get: function (elem, computed) {
                return ropacity.test((computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || '') ? 0.01 * parseFloat(RegExp.$1) + '' : computed ? '1' : '';
            },
            set: function (elem, value) {
                var style = elem.style, currentStyle = elem.currentStyle, opacity = jQuery.isNumeric(value) ? 'alpha(opacity=' + value * 100 + ')' : '', filter = currentStyle && currentStyle.filter || style.filter || '';
                style.zoom = 1;
                if ((value >= 1 || value === '') && jQuery.trim(filter.replace(ralpha, '')) === '' && style.removeAttribute) {
                    style.removeAttribute('filter');
                    if (value === '' || currentStyle && !currentStyle.filter) {
                        return;
                    }
                }
                style.filter = ralpha.test(filter) ? filter.replace(ralpha, opacity) : filter + ' ' + opacity;
            }
        };
    }
    jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight, function (elem, computed) {
        if (computed) {
            return jQuery.swap(elem, { 'display': 'inline-block' }, curCSS, [
                elem,
                'marginRight'
            ]);
        }
    });
    jQuery.each({
        margin: '',
        padding: '',
        border: 'Width'
    }, function (prefix, suffix) {
        jQuery.cssHooks[prefix + suffix] = {
            expand: function (value) {
                var i = 0, expanded = {}, parts = typeof value === 'string' ? value.split(' ') : [value];
                for (; i < 4; i++) {
                    expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
                }
                return expanded;
            }
        };
        if (!rmargin.test(prefix)) {
            jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
        }
    });
    jQuery.fn.extend({
        css: function (name, value) {
            return access(this, function (elem, name, value) {
                var styles, len, map = {}, i = 0;
                if (jQuery.isArray(name)) {
                    styles = getStyles(elem);
                    len = name.length;
                    for (; i < len; i++) {
                        map[name[i]] = jQuery.css(elem, name[i], false, styles);
                    }
                    return map;
                }
                return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
            }, name, value, arguments.length > 1);
        },
        show: function () {
            return showHide(this, true);
        },
        hide: function () {
            return showHide(this);
        },
        toggle: function (state) {
            if (typeof state === 'boolean') {
                return state ? this.show() : this.hide();
            }
            return this.each(function () {
                if (isHidden(this)) {
                    jQuery(this).show();
                } else {
                    jQuery(this).hide();
                }
            });
        }
    });
    function Tween(elem, options, prop, end, easing) {
        return new Tween.prototype.init(elem, options, prop, end, easing);
    }
    jQuery.Tween = Tween;
    Tween.prototype = {
        constructor: Tween,
        init: function (elem, options, prop, end, easing, unit) {
            this.elem = elem;
            this.prop = prop;
            this.easing = easing || 'swing';
            this.options = options;
            this.start = this.now = this.cur();
            this.end = end;
            this.unit = unit || (jQuery.cssNumber[prop] ? '' : 'px');
        },
        cur: function () {
            var hooks = Tween.propHooks[this.prop];
            return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
        },
        run: function (percent) {
            var eased, hooks = Tween.propHooks[this.prop];
            if (this.options.duration) {
                this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
            } else {
                this.pos = eased = percent;
            }
            this.now = (this.end - this.start) * eased + this.start;
            if (this.options.step) {
                this.options.step.call(this.elem, this.now, this);
            }
            if (hooks && hooks.set) {
                hooks.set(this);
            } else {
                Tween.propHooks._default.set(this);
            }
            return this;
        }
    };
    Tween.prototype.init.prototype = Tween.prototype;
    Tween.propHooks = {
        _default: {
            get: function (tween) {
                var result;
                if (tween.elem[tween.prop] != null && (!tween.elem.style || tween.elem.style[tween.prop] == null)) {
                    return tween.elem[tween.prop];
                }
                result = jQuery.css(tween.elem, tween.prop, '');
                return !result || result === 'auto' ? 0 : result;
            },
            set: function (tween) {
                if (jQuery.fx.step[tween.prop]) {
                    jQuery.fx.step[tween.prop](tween);
                } else if (tween.elem.style && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
                    jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
                } else {
                    tween.elem[tween.prop] = tween.now;
                }
            }
        }
    };
    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function (tween) {
            if (tween.elem.nodeType && tween.elem.parentNode) {
                tween.elem[tween.prop] = tween.now;
            }
        }
    };
    jQuery.easing = {
        linear: function (p) {
            return p;
        },
        swing: function (p) {
            return 0.5 - Math.cos(p * Math.PI) / 2;
        }
    };
    jQuery.fx = Tween.prototype.init;
    jQuery.fx.step = {};
    var fxNow, timerId, rfxtypes = /^(?:toggle|show|hide)$/, rfxnum = new RegExp('^(?:([+-])=|)(' + pnum + ')([a-z%]*)$', 'i'), rrun = /queueHooks$/, animationPrefilters = [defaultPrefilter], tweeners = {
            '*': [function (prop, value) {
                    var tween = this.createTween(prop, value), target = tween.cur(), parts = rfxnum.exec(value), unit = parts && parts[3] || (jQuery.cssNumber[prop] ? '' : 'px'), start = (jQuery.cssNumber[prop] || unit !== 'px' && +target) && rfxnum.exec(jQuery.css(tween.elem, prop)), scale = 1, maxIterations = 20;
                    if (start && start[3] !== unit) {
                        unit = unit || start[3];
                        parts = parts || [];
                        start = +target || 1;
                        do {
                            scale = scale || '.5';
                            start = start / scale;
                            jQuery.style(tween.elem, prop, start + unit);
                        } while (scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations);
                    }
                    if (parts) {
                        start = tween.start = +start || +target || 0;
                        tween.unit = unit;
                        tween.end = parts[1] ? start + (parts[1] + 1) * parts[2] : +parts[2];
                    }
                    return tween;
                }]
        };
    function createFxNow() {
        setTimeout(function () {
            fxNow = undefined;
        });
        return fxNow = jQuery.now();
    }
    function genFx(type, includeWidth) {
        var which, attrs = { height: type }, i = 0;
        includeWidth = includeWidth ? 1 : 0;
        for (; i < 4; i += 2 - includeWidth) {
            which = cssExpand[i];
            attrs['margin' + which] = attrs['padding' + which] = type;
        }
        if (includeWidth) {
            attrs.opacity = attrs.width = type;
        }
        return attrs;
    }
    function createTween(value, prop, animation) {
        var tween, collection = (tweeners[prop] || []).concat(tweeners['*']), index = 0, length = collection.length;
        for (; index < length; index++) {
            if (tween = collection[index].call(animation, prop, value)) {
                return tween;
            }
        }
    }
    function defaultPrefilter(elem, props, opts) {
        var prop, value, toggle, tween, hooks, oldfire, display, dDisplay, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHidden(elem), dataShow = jQuery._data(elem, 'fxshow');
        if (!opts.queue) {
            hooks = jQuery._queueHooks(elem, 'fx');
            if (hooks.unqueued == null) {
                hooks.unqueued = 0;
                oldfire = hooks.empty.fire;
                hooks.empty.fire = function () {
                    if (!hooks.unqueued) {
                        oldfire();
                    }
                };
            }
            hooks.unqueued++;
            anim.always(function () {
                anim.always(function () {
                    hooks.unqueued--;
                    if (!jQuery.queue(elem, 'fx').length) {
                        hooks.empty.fire();
                    }
                });
            });
        }
        if (elem.nodeType === 1 && ('height' in props || 'width' in props)) {
            opts.overflow = [
                style.overflow,
                style.overflowX,
                style.overflowY
            ];
            display = jQuery.css(elem, 'display');
            dDisplay = defaultDisplay(elem.nodeName);
            if (display === 'none') {
                display = dDisplay;
            }
            if (display === 'inline' && jQuery.css(elem, 'float') === 'none') {
                if (!support.inlineBlockNeedsLayout || dDisplay === 'inline') {
                    style.display = 'inline-block';
                } else {
                    style.zoom = 1;
                }
            }
        }
        if (opts.overflow) {
            style.overflow = 'hidden';
            if (!support.shrinkWrapBlocks()) {
                anim.always(function () {
                    style.overflow = opts.overflow[0];
                    style.overflowX = opts.overflow[1];
                    style.overflowY = opts.overflow[2];
                });
            }
        }
        for (prop in props) {
            value = props[prop];
            if (rfxtypes.exec(value)) {
                delete props[prop];
                toggle = toggle || value === 'toggle';
                if (value === (hidden ? 'hide' : 'show')) {
                    if (value === 'show' && dataShow && dataShow[prop] !== undefined) {
                        hidden = true;
                    } else {
                        continue;
                    }
                }
                orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
            }
        }
        if (!jQuery.isEmptyObject(orig)) {
            if (dataShow) {
                if ('hidden' in dataShow) {
                    hidden = dataShow.hidden;
                }
            } else {
                dataShow = jQuery._data(elem, 'fxshow', {});
            }
            if (toggle) {
                dataShow.hidden = !hidden;
            }
            if (hidden) {
                jQuery(elem).show();
            } else {
                anim.done(function () {
                    jQuery(elem).hide();
                });
            }
            anim.done(function () {
                var prop;
                jQuery._removeData(elem, 'fxshow');
                for (prop in orig) {
                    jQuery.style(elem, prop, orig[prop]);
                }
            });
            for (prop in orig) {
                tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
                if (!(prop in dataShow)) {
                    dataShow[prop] = tween.start;
                    if (hidden) {
                        tween.end = tween.start;
                        tween.start = prop === 'width' || prop === 'height' ? 1 : 0;
                    }
                }
            }
        }
    }
    function propFilter(props, specialEasing) {
        var index, name, easing, value, hooks;
        for (index in props) {
            name = jQuery.camelCase(index);
            easing = specialEasing[name];
            value = props[index];
            if (jQuery.isArray(value)) {
                easing = value[1];
                value = props[index] = value[0];
            }
            if (index !== name) {
                props[name] = value;
                delete props[index];
            }
            hooks = jQuery.cssHooks[name];
            if (hooks && 'expand' in hooks) {
                value = hooks.expand(value);
                delete props[name];
                for (index in value) {
                    if (!(index in props)) {
                        props[index] = value[index];
                        specialEasing[index] = easing;
                    }
                }
            } else {
                specialEasing[name] = easing;
            }
        }
    }
    function Animation(elem, properties, options) {
        var result, stopped, index = 0, length = animationPrefilters.length, deferred = jQuery.Deferred().always(function () {
                delete tick.elem;
            }), tick = function () {
                if (stopped) {
                    return false;
                }
                var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0, length = animation.tweens.length;
                for (; index < length; index++) {
                    animation.tweens[index].run(percent);
                }
                deferred.notifyWith(elem, [
                    animation,
                    percent,
                    remaining
                ]);
                if (percent < 1 && length) {
                    return remaining;
                } else {
                    deferred.resolveWith(elem, [animation]);
                    return false;
                }
            }, animation = deferred.promise({
                elem: elem,
                props: jQuery.extend({}, properties),
                opts: jQuery.extend(true, { specialEasing: {} }, options),
                originalProperties: properties,
                originalOptions: options,
                startTime: fxNow || createFxNow(),
                duration: options.duration,
                tweens: [],
                createTween: function (prop, end) {
                    var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
                    animation.tweens.push(tween);
                    return tween;
                },
                stop: function (gotoEnd) {
                    var index = 0, length = gotoEnd ? animation.tweens.length : 0;
                    if (stopped) {
                        return this;
                    }
                    stopped = true;
                    for (; index < length; index++) {
                        animation.tweens[index].run(1);
                    }
                    if (gotoEnd) {
                        deferred.resolveWith(elem, [
                            animation,
                            gotoEnd
                        ]);
                    } else {
                        deferred.rejectWith(elem, [
                            animation,
                            gotoEnd
                        ]);
                    }
                    return this;
                }
            }), props = animation.props;
        propFilter(props, animation.opts.specialEasing);
        for (; index < length; index++) {
            result = animationPrefilters[index].call(animation, elem, props, animation.opts);
            if (result) {
                return result;
            }
        }
        jQuery.map(props, createTween, animation);
        if (jQuery.isFunction(animation.opts.start)) {
            animation.opts.start.call(elem, animation);
        }
        jQuery.fx.timer(jQuery.extend(tick, {
            elem: elem,
            anim: animation,
            queue: animation.opts.queue
        }));
        return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
    }
    jQuery.Animation = jQuery.extend(Animation, {
        tweener: function (props, callback) {
            if (jQuery.isFunction(props)) {
                callback = props;
                props = ['*'];
            } else {
                props = props.split(' ');
            }
            var prop, index = 0, length = props.length;
            for (; index < length; index++) {
                prop = props[index];
                tweeners[prop] = tweeners[prop] || [];
                tweeners[prop].unshift(callback);
            }
        },
        prefilter: function (callback, prepend) {
            if (prepend) {
                animationPrefilters.unshift(callback);
            } else {
                animationPrefilters.push(callback);
            }
        }
    });
    jQuery.speed = function (speed, easing, fn) {
        var opt = speed && typeof speed === 'object' ? jQuery.extend({}, speed) : {
            complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
            duration: speed,
            easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
        };
        opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === 'number' ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;
        if (opt.queue == null || opt.queue === true) {
            opt.queue = 'fx';
        }
        opt.old = opt.complete;
        opt.complete = function () {
            if (jQuery.isFunction(opt.old)) {
                opt.old.call(this);
            }
            if (opt.queue) {
                jQuery.dequeue(this, opt.queue);
            }
        };
        return opt;
    };
    jQuery.fn.extend({
        fadeTo: function (speed, to, easing, callback) {
            return this.filter(isHidden).css('opacity', 0).show().end().animate({ opacity: to }, speed, easing, callback);
        },
        animate: function (prop, speed, easing, callback) {
            var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function () {
                    var anim = Animation(this, jQuery.extend({}, prop), optall);
                    if (empty || jQuery._data(this, 'finish')) {
                        anim.stop(true);
                    }
                };
            doAnimation.finish = doAnimation;
            return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
        },
        stop: function (type, clearQueue, gotoEnd) {
            var stopQueue = function (hooks) {
                var stop = hooks.stop;
                delete hooks.stop;
                stop(gotoEnd);
            };
            if (typeof type !== 'string') {
                gotoEnd = clearQueue;
                clearQueue = type;
                type = undefined;
            }
            if (clearQueue && type !== false) {
                this.queue(type || 'fx', []);
            }
            return this.each(function () {
                var dequeue = true, index = type != null && type + 'queueHooks', timers = jQuery.timers, data = jQuery._data(this);
                if (index) {
                    if (data[index] && data[index].stop) {
                        stopQueue(data[index]);
                    }
                } else {
                    for (index in data) {
                        if (data[index] && data[index].stop && rrun.test(index)) {
                            stopQueue(data[index]);
                        }
                    }
                }
                for (index = timers.length; index--;) {
                    if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                        timers[index].anim.stop(gotoEnd);
                        dequeue = false;
                        timers.splice(index, 1);
                    }
                }
                if (dequeue || !gotoEnd) {
                    jQuery.dequeue(this, type);
                }
            });
        },
        finish: function (type) {
            if (type !== false) {
                type = type || 'fx';
            }
            return this.each(function () {
                var index, data = jQuery._data(this), queue = data[type + 'queue'], hooks = data[type + 'queueHooks'], timers = jQuery.timers, length = queue ? queue.length : 0;
                data.finish = true;
                jQuery.queue(this, type, []);
                if (hooks && hooks.stop) {
                    hooks.stop.call(this, true);
                }
                for (index = timers.length; index--;) {
                    if (timers[index].elem === this && timers[index].queue === type) {
                        timers[index].anim.stop(true);
                        timers.splice(index, 1);
                    }
                }
                for (index = 0; index < length; index++) {
                    if (queue[index] && queue[index].finish) {
                        queue[index].finish.call(this);
                    }
                }
                delete data.finish;
            });
        }
    });
    jQuery.each([
        'toggle',
        'show',
        'hide'
    ], function (i, name) {
        var cssFn = jQuery.fn[name];
        jQuery.fn[name] = function (speed, easing, callback) {
            return speed == null || typeof speed === 'boolean' ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
        };
    });
    jQuery.each({
        slideDown: genFx('show'),
        slideUp: genFx('hide'),
        slideToggle: genFx('toggle'),
        fadeIn: { opacity: 'show' },
        fadeOut: { opacity: 'hide' },
        fadeToggle: { opacity: 'toggle' }
    }, function (name, props) {
        jQuery.fn[name] = function (speed, easing, callback) {
            return this.animate(props, speed, easing, callback);
        };
    });
    jQuery.timers = [];
    jQuery.fx.tick = function () {
        var timer, timers = jQuery.timers, i = 0;
        fxNow = jQuery.now();
        for (; i < timers.length; i++) {
            timer = timers[i];
            if (!timer() && timers[i] === timer) {
                timers.splice(i--, 1);
            }
        }
        if (!timers.length) {
            jQuery.fx.stop();
        }
        fxNow = undefined;
    };
    jQuery.fx.timer = function (timer) {
        jQuery.timers.push(timer);
        if (timer()) {
            jQuery.fx.start();
        } else {
            jQuery.timers.pop();
        }
    };
    jQuery.fx.interval = 13;
    jQuery.fx.start = function () {
        if (!timerId) {
            timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval);
        }
    };
    jQuery.fx.stop = function () {
        clearInterval(timerId);
        timerId = null;
    };
    jQuery.fx.speeds = {
        slow: 600,
        fast: 200,
        _default: 400
    };
    jQuery.fn.delay = function (time, type) {
        time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
        type = type || 'fx';
        return this.queue(type, function (next, hooks) {
            var timeout = setTimeout(next, time);
            hooks.stop = function () {
                clearTimeout(timeout);
            };
        });
    };
    (function () {
        var a, input, select, opt, div = document.createElement('div');
        div.setAttribute('className', 't');
        div.innerHTML = '  <link/><table></table><a href=\'/a\'>a</a><input type=\'checkbox\'/>';
        a = div.getElementsByTagName('a')[0];
        select = document.createElement('select');
        opt = select.appendChild(document.createElement('option'));
        input = div.getElementsByTagName('input')[0];
        a.style.cssText = 'top:1px';
        support.getSetAttribute = div.className !== 't';
        support.style = /top/.test(a.getAttribute('style'));
        support.hrefNormalized = a.getAttribute('href') === '/a';
        support.checkOn = !!input.value;
        support.optSelected = opt.selected;
        support.enctype = !!document.createElement('form').enctype;
        select.disabled = true;
        support.optDisabled = !opt.disabled;
        input = document.createElement('input');
        input.setAttribute('value', '');
        support.input = input.getAttribute('value') === '';
        input.value = 't';
        input.setAttribute('type', 'radio');
        support.radioValue = input.value === 't';
        a = input = select = opt = div = null;
    }());
    var rreturn = /\r/g;
    jQuery.fn.extend({
        val: function (value) {
            var hooks, ret, isFunction, elem = this[0];
            if (!arguments.length) {
                if (elem) {
                    hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
                    if (hooks && 'get' in hooks && (ret = hooks.get(elem, 'value')) !== undefined) {
                        return ret;
                    }
                    ret = elem.value;
                    return typeof ret === 'string' ? ret.replace(rreturn, '') : ret == null ? '' : ret;
                }
                return;
            }
            isFunction = jQuery.isFunction(value);
            return this.each(function (i) {
                var val;
                if (this.nodeType !== 1) {
                    return;
                }
                if (isFunction) {
                    val = value.call(this, i, jQuery(this).val());
                } else {
                    val = value;
                }
                if (val == null) {
                    val = '';
                } else if (typeof val === 'number') {
                    val += '';
                } else if (jQuery.isArray(val)) {
                    val = jQuery.map(val, function (value) {
                        return value == null ? '' : value + '';
                    });
                }
                hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
                if (!hooks || !('set' in hooks) || hooks.set(this, val, 'value') === undefined) {
                    this.value = val;
                }
            });
        }
    });
    jQuery.extend({
        valHooks: {
            option: {
                get: function (elem) {
                    var val = jQuery.find.attr(elem, 'value');
                    return val != null ? val : jQuery.text(elem);
                }
            },
            select: {
                get: function (elem) {
                    var value, option, options = elem.options, index = elem.selectedIndex, one = elem.type === 'select-one' || index < 0, values = one ? null : [], max = one ? index + 1 : options.length, i = index < 0 ? max : one ? index : 0;
                    for (; i < max; i++) {
                        option = options[i];
                        if ((option.selected || i === index) && (support.optDisabled ? !option.disabled : option.getAttribute('disabled') === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, 'optgroup'))) {
                            value = jQuery(option).val();
                            if (one) {
                                return value;
                            }
                            values.push(value);
                        }
                    }
                    return values;
                },
                set: function (elem, value) {
                    var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length;
                    while (i--) {
                        option = options[i];
                        if (jQuery.inArray(jQuery.valHooks.option.get(option), values) >= 0) {
                            try {
                                option.selected = optionSet = true;
                            } catch (_) {
                                option.scrollHeight;
                            }
                        } else {
                            option.selected = false;
                        }
                    }
                    if (!optionSet) {
                        elem.selectedIndex = -1;
                    }
                    return options;
                }
            }
        }
    });
    jQuery.each([
        'radio',
        'checkbox'
    ], function () {
        jQuery.valHooks[this] = {
            set: function (elem, value) {
                if (jQuery.isArray(value)) {
                    return elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0;
                }
            }
        };
        if (!support.checkOn) {
            jQuery.valHooks[this].get = function (elem) {
                return elem.getAttribute('value') === null ? 'on' : elem.value;
            };
        }
    });
    var nodeHook, boolHook, attrHandle = jQuery.expr.attrHandle, ruseDefault = /^(?:checked|selected)$/i, getSetAttribute = support.getSetAttribute, getSetInput = support.input;
    jQuery.fn.extend({
        attr: function (name, value) {
            return access(this, jQuery.attr, name, value, arguments.length > 1);
        },
        removeAttr: function (name) {
            return this.each(function () {
                jQuery.removeAttr(this, name);
            });
        }
    });
    jQuery.extend({
        attr: function (elem, name, value) {
            var hooks, ret, nType = elem.nodeType;
            if (!elem || nType === 3 || nType === 8 || nType === 2) {
                return;
            }
            if (typeof elem.getAttribute === strundefined) {
                return jQuery.prop(elem, name, value);
            }
            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                name = name.toLowerCase();
                hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : nodeHook);
            }
            if (value !== undefined) {
                if (value === null) {
                    jQuery.removeAttr(elem, name);
                } else if (hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret;
                } else {
                    elem.setAttribute(name, value + '');
                    return value;
                }
            } else if (hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null) {
                return ret;
            } else {
                ret = jQuery.find.attr(elem, name);
                return ret == null ? undefined : ret;
            }
        },
        removeAttr: function (elem, value) {
            var name, propName, i = 0, attrNames = value && value.match(rnotwhite);
            if (attrNames && elem.nodeType === 1) {
                while (name = attrNames[i++]) {
                    propName = jQuery.propFix[name] || name;
                    if (jQuery.expr.match.bool.test(name)) {
                        if (getSetInput && getSetAttribute || !ruseDefault.test(name)) {
                            elem[propName] = false;
                        } else {
                            elem[jQuery.camelCase('default-' + name)] = elem[propName] = false;
                        }
                    } else {
                        jQuery.attr(elem, name, '');
                    }
                    elem.removeAttribute(getSetAttribute ? name : propName);
                }
            }
        },
        attrHooks: {
            type: {
                set: function (elem, value) {
                    if (!support.radioValue && value === 'radio' && jQuery.nodeName(elem, 'input')) {
                        var val = elem.value;
                        elem.setAttribute('type', value);
                        if (val) {
                            elem.value = val;
                        }
                        return value;
                    }
                }
            }
        }
    });
    boolHook = {
        set: function (elem, value, name) {
            if (value === false) {
                jQuery.removeAttr(elem, name);
            } else if (getSetInput && getSetAttribute || !ruseDefault.test(name)) {
                elem.setAttribute(!getSetAttribute && jQuery.propFix[name] || name, name);
            } else {
                elem[jQuery.camelCase('default-' + name)] = elem[name] = true;
            }
            return name;
        }
    };
    jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
        var getter = attrHandle[name] || jQuery.find.attr;
        attrHandle[name] = getSetInput && getSetAttribute || !ruseDefault.test(name) ? function (elem, name, isXML) {
            var ret, handle;
            if (!isXML) {
                handle = attrHandle[name];
                attrHandle[name] = ret;
                ret = getter(elem, name, isXML) != null ? name.toLowerCase() : null;
                attrHandle[name] = handle;
            }
            return ret;
        } : function (elem, name, isXML) {
            if (!isXML) {
                return elem[jQuery.camelCase('default-' + name)] ? name.toLowerCase() : null;
            }
        };
    });
    if (!getSetInput || !getSetAttribute) {
        jQuery.attrHooks.value = {
            set: function (elem, value, name) {
                if (jQuery.nodeName(elem, 'input')) {
                    elem.defaultValue = value;
                } else {
                    return nodeHook && nodeHook.set(elem, value, name);
                }
            }
        };
    }
    if (!getSetAttribute) {
        nodeHook = {
            set: function (elem, value, name) {
                var ret = elem.getAttributeNode(name);
                if (!ret) {
                    elem.setAttributeNode(ret = elem.ownerDocument.createAttribute(name));
                }
                ret.value = value += '';
                if (name === 'value' || value === elem.getAttribute(name)) {
                    return value;
                }
            }
        };
        attrHandle.id = attrHandle.name = attrHandle.coords = function (elem, name, isXML) {
            var ret;
            if (!isXML) {
                return (ret = elem.getAttributeNode(name)) && ret.value !== '' ? ret.value : null;
            }
        };
        jQuery.valHooks.button = {
            get: function (elem, name) {
                var ret = elem.getAttributeNode(name);
                if (ret && ret.specified) {
                    return ret.value;
                }
            },
            set: nodeHook.set
        };
        jQuery.attrHooks.contenteditable = {
            set: function (elem, value, name) {
                nodeHook.set(elem, value === '' ? false : value, name);
            }
        };
        jQuery.each([
            'width',
            'height'
        ], function (i, name) {
            jQuery.attrHooks[name] = {
                set: function (elem, value) {
                    if (value === '') {
                        elem.setAttribute(name, 'auto');
                        return value;
                    }
                }
            };
        });
    }
    if (!support.style) {
        jQuery.attrHooks.style = {
            get: function (elem) {
                return elem.style.cssText || undefined;
            },
            set: function (elem, value) {
                return elem.style.cssText = value + '';
            }
        };
    }
    var rfocusable = /^(?:input|select|textarea|button|object)$/i, rclickable = /^(?:a|area)$/i;
    jQuery.fn.extend({
        prop: function (name, value) {
            return access(this, jQuery.prop, name, value, arguments.length > 1);
        },
        removeProp: function (name) {
            name = jQuery.propFix[name] || name;
            return this.each(function () {
                try {
                    this[name] = undefined;
                    delete this[name];
                } catch (e) {
                }
            });
        }
    });
    jQuery.extend({
        propFix: {
            'for': 'htmlFor',
            'class': 'className'
        },
        prop: function (elem, name, value) {
            var ret, hooks, notxml, nType = elem.nodeType;
            if (!elem || nType === 3 || nType === 8 || nType === 2) {
                return;
            }
            notxml = nType !== 1 || !jQuery.isXMLDoc(elem);
            if (notxml) {
                name = jQuery.propFix[name] || name;
                hooks = jQuery.propHooks[name];
            }
            if (value !== undefined) {
                return hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined ? ret : elem[name] = value;
            } else {
                return hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null ? ret : elem[name];
            }
        },
        propHooks: {
            tabIndex: {
                get: function (elem) {
                    var tabindex = jQuery.find.attr(elem, 'tabindex');
                    return tabindex ? parseInt(tabindex, 10) : rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ? 0 : -1;
                }
            }
        }
    });
    if (!support.hrefNormalized) {
        jQuery.each([
            'href',
            'src'
        ], function (i, name) {
            jQuery.propHooks[name] = {
                get: function (elem) {
                    return elem.getAttribute(name, 4);
                }
            };
        });
    }
    if (!support.optSelected) {
        jQuery.propHooks.selected = {
            get: function (elem) {
                var parent = elem.parentNode;
                if (parent) {
                    parent.selectedIndex;
                    if (parent.parentNode) {
                        parent.parentNode.selectedIndex;
                    }
                }
                return null;
            }
        };
    }
    jQuery.each([
        'tabIndex',
        'readOnly',
        'maxLength',
        'cellSpacing',
        'cellPadding',
        'rowSpan',
        'colSpan',
        'useMap',
        'frameBorder',
        'contentEditable'
    ], function () {
        jQuery.propFix[this.toLowerCase()] = this;
    });
    if (!support.enctype) {
        jQuery.propFix.enctype = 'encoding';
    }
    var rclass = /[\t\r\n\f]/g;
    jQuery.fn.extend({
        addClass: function (value) {
            var classes, elem, cur, clazz, j, finalValue, i = 0, len = this.length, proceed = typeof value === 'string' && value;
            if (jQuery.isFunction(value)) {
                return this.each(function (j) {
                    jQuery(this).addClass(value.call(this, j, this.className));
                });
            }
            if (proceed) {
                classes = (value || '').match(rnotwhite) || [];
                for (; i < len; i++) {
                    elem = this[i];
                    cur = elem.nodeType === 1 && (elem.className ? (' ' + elem.className + ' ').replace(rclass, ' ') : ' ');
                    if (cur) {
                        j = 0;
                        while (clazz = classes[j++]) {
                            if (cur.indexOf(' ' + clazz + ' ') < 0) {
                                cur += clazz + ' ';
                            }
                        }
                        finalValue = jQuery.trim(cur);
                        if (elem.className !== finalValue) {
                            elem.className = finalValue;
                        }
                    }
                }
            }
            return this;
        },
        removeClass: function (value) {
            var classes, elem, cur, clazz, j, finalValue, i = 0, len = this.length, proceed = arguments.length === 0 || typeof value === 'string' && value;
            if (jQuery.isFunction(value)) {
                return this.each(function (j) {
                    jQuery(this).removeClass(value.call(this, j, this.className));
                });
            }
            if (proceed) {
                classes = (value || '').match(rnotwhite) || [];
                for (; i < len; i++) {
                    elem = this[i];
                    cur = elem.nodeType === 1 && (elem.className ? (' ' + elem.className + ' ').replace(rclass, ' ') : '');
                    if (cur) {
                        j = 0;
                        while (clazz = classes[j++]) {
                            while (cur.indexOf(' ' + clazz + ' ') >= 0) {
                                cur = cur.replace(' ' + clazz + ' ', ' ');
                            }
                        }
                        finalValue = value ? jQuery.trim(cur) : '';
                        if (elem.className !== finalValue) {
                            elem.className = finalValue;
                        }
                    }
                }
            }
            return this;
        },
        toggleClass: function (value, stateVal) {
            var type = typeof value;
            if (typeof stateVal === 'boolean' && type === 'string') {
                return stateVal ? this.addClass(value) : this.removeClass(value);
            }
            if (jQuery.isFunction(value)) {
                return this.each(function (i) {
                    jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
                });
            }
            return this.each(function () {
                if (type === 'string') {
                    var className, i = 0, self = jQuery(this), classNames = value.match(rnotwhite) || [];
                    while (className = classNames[i++]) {
                        if (self.hasClass(className)) {
                            self.removeClass(className);
                        } else {
                            self.addClass(className);
                        }
                    }
                } else if (type === strundefined || type === 'boolean') {
                    if (this.className) {
                        jQuery._data(this, '__className__', this.className);
                    }
                    this.className = this.className || value === false ? '' : jQuery._data(this, '__className__') || '';
                }
            });
        },
        hasClass: function (selector) {
            var className = ' ' + selector + ' ', i = 0, l = this.length;
            for (; i < l; i++) {
                if (this[i].nodeType === 1 && (' ' + this[i].className + ' ').replace(rclass, ' ').indexOf(className) >= 0) {
                    return true;
                }
            }
            return false;
        }
    });
    jQuery.each(('blur focus focusin focusout load resize scroll unload click dblclick ' + 'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave ' + 'change select submit keydown keypress keyup error contextmenu').split(' '), function (i, name) {
        jQuery.fn[name] = function (data, fn) {
            return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
        };
    });
    jQuery.fn.extend({
        hover: function (fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
        },
        bind: function (types, data, fn) {
            return this.on(types, null, data, fn);
        },
        unbind: function (types, fn) {
            return this.off(types, null, fn);
        },
        delegate: function (selector, types, data, fn) {
            return this.on(types, selector, data, fn);
        },
        undelegate: function (selector, types, fn) {
            return arguments.length === 1 ? this.off(selector, '**') : this.off(types, selector || '**', fn);
        }
    });
    var nonce = jQuery.now();
    var rquery = /\?/;
    var rvalidtokens = /(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;
    jQuery.parseJSON = function (data) {
        if (window.JSON && window.JSON.parse) {
            return window.JSON.parse(data + '');
        }
        var requireNonComma, depth = null, str = jQuery.trim(data + '');
        return str && !jQuery.trim(str.replace(rvalidtokens, function (token, comma, open, close) {
            if (requireNonComma && comma) {
                depth = 0;
            }
            if (depth === 0) {
                return token;
            }
            requireNonComma = open || comma;
            depth += !close - !open;
            return '';
        })) ? Function('return ' + str)() : jQuery.error('Invalid JSON: ' + data);
    };
    jQuery.parseXML = function (data) {
        var xml, tmp;
        if (!data || typeof data !== 'string') {
            return null;
        }
        try {
            if (window.DOMParser) {
                tmp = new DOMParser();
                xml = tmp.parseFromString(data, 'text/xml');
            } else {
                xml = new ActiveXObject('Microsoft.XMLDOM');
                xml.async = 'false';
                xml.loadXML(data);
            }
        } catch (e) {
            xml = undefined;
        }
        if (!xml || !xml.documentElement || xml.getElementsByTagName('parsererror').length) {
            jQuery.error('Invalid XML: ' + data);
        }
        return xml;
    };
    var ajaxLocParts, ajaxLocation, rhash = /#.*$/, rts = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/gm, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/, prefilters = {}, transports = {}, allTypes = '*/'.concat('*');
    try {
        ajaxLocation = location.href;
    } catch (e) {
        ajaxLocation = document.createElement('a');
        ajaxLocation.href = '';
        ajaxLocation = ajaxLocation.href;
    }
    ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];
    function addToPrefiltersOrTransports(structure) {
        return function (dataTypeExpression, func) {
            if (typeof dataTypeExpression !== 'string') {
                func = dataTypeExpression;
                dataTypeExpression = '*';
            }
            var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];
            if (jQuery.isFunction(func)) {
                while (dataType = dataTypes[i++]) {
                    if (dataType.charAt(0) === '+') {
                        dataType = dataType.slice(1) || '*';
                        (structure[dataType] = structure[dataType] || []).unshift(func);
                    } else {
                        (structure[dataType] = structure[dataType] || []).push(func);
                    }
                }
            }
        };
    }
    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
        var inspected = {}, seekingTransport = structure === transports;
        function inspect(dataType) {
            var selected;
            inspected[dataType] = true;
            jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
                var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                if (typeof dataTypeOrTransport === 'string' && !seekingTransport && !inspected[dataTypeOrTransport]) {
                    options.dataTypes.unshift(dataTypeOrTransport);
                    inspect(dataTypeOrTransport);
                    return false;
                } else if (seekingTransport) {
                    return !(selected = dataTypeOrTransport);
                }
            });
            return selected;
        }
        return inspect(options.dataTypes[0]) || !inspected['*'] && inspect('*');
    }
    function ajaxExtend(target, src) {
        var deep, key, flatOptions = jQuery.ajaxSettings.flatOptions || {};
        for (key in src) {
            if (src[key] !== undefined) {
                (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
            }
        }
        if (deep) {
            jQuery.extend(true, target, deep);
        }
        return target;
    }
    function ajaxHandleResponses(s, jqXHR, responses) {
        var firstDataType, ct, finalDataType, type, contents = s.contents, dataTypes = s.dataTypes;
        while (dataTypes[0] === '*') {
            dataTypes.shift();
            if (ct === undefined) {
                ct = s.mimeType || jqXHR.getResponseHeader('Content-Type');
            }
        }
        if (ct) {
            for (type in contents) {
                if (contents[type] && contents[type].test(ct)) {
                    dataTypes.unshift(type);
                    break;
                }
            }
        }
        if (dataTypes[0] in responses) {
            finalDataType = dataTypes[0];
        } else {
            for (type in responses) {
                if (!dataTypes[0] || s.converters[type + ' ' + dataTypes[0]]) {
                    finalDataType = type;
                    break;
                }
                if (!firstDataType) {
                    firstDataType = type;
                }
            }
            finalDataType = finalDataType || firstDataType;
        }
        if (finalDataType) {
            if (finalDataType !== dataTypes[0]) {
                dataTypes.unshift(finalDataType);
            }
            return responses[finalDataType];
        }
    }
    function ajaxConvert(s, response, jqXHR, isSuccess) {
        var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s.dataTypes.slice();
        if (dataTypes[1]) {
            for (conv in s.converters) {
                converters[conv.toLowerCase()] = s.converters[conv];
            }
        }
        current = dataTypes.shift();
        while (current) {
            if (s.responseFields[current]) {
                jqXHR[s.responseFields[current]] = response;
            }
            if (!prev && isSuccess && s.dataFilter) {
                response = s.dataFilter(response, s.dataType);
            }
            prev = current;
            current = dataTypes.shift();
            if (current) {
                if (current === '*') {
                    current = prev;
                } else if (prev !== '*' && prev !== current) {
                    conv = converters[prev + ' ' + current] || converters['* ' + current];
                    if (!conv) {
                        for (conv2 in converters) {
                            tmp = conv2.split(' ');
                            if (tmp[1] === current) {
                                conv = converters[prev + ' ' + tmp[0]] || converters['* ' + tmp[0]];
                                if (conv) {
                                    if (conv === true) {
                                        conv = converters[conv2];
                                    } else if (converters[conv2] !== true) {
                                        current = tmp[0];
                                        dataTypes.unshift(tmp[1]);
                                    }
                                    break;
                                }
                            }
                        }
                    }
                    if (conv !== true) {
                        if (conv && s['throws']) {
                            response = conv(response);
                        } else {
                            try {
                                response = conv(response);
                            } catch (e) {
                                return {
                                    state: 'parsererror',
                                    error: conv ? e : 'No conversion from ' + prev + ' to ' + current
                                };
                            }
                        }
                    }
                }
            }
        }
        return {
            state: 'success',
            data: response
        };
    }
    jQuery.extend({
        active: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: {
            url: ajaxLocation,
            type: 'GET',
            isLocal: rlocalProtocol.test(ajaxLocParts[1]),
            global: true,
            processData: true,
            async: true,
            contentType: 'application/x-www-form-urlencoded; charset=UTF-8',
            accepts: {
                '*': allTypes,
                text: 'text/plain',
                html: 'text/html',
                xml: 'application/xml, text/xml',
                json: 'application/json, text/javascript'
            },
            contents: {
                xml: /xml/,
                html: /html/,
                json: /json/
            },
            responseFields: {
                xml: 'responseXML',
                text: 'responseText',
                json: 'responseJSON'
            },
            converters: {
                '* text': String,
                'text html': true,
                'text json': jQuery.parseJSON,
                'text xml': jQuery.parseXML
            },
            flatOptions: {
                url: true,
                context: true
            }
        },
        ajaxSetup: function (target, settings) {
            return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
        },
        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),
        ajax: function (url, options) {
            if (typeof url === 'object') {
                options = url;
                url = undefined;
            }
            options = options || {};
            var parts, i, cacheURL, responseHeadersString, timeoutTimer, fireGlobals, transport, responseHeaders, s = jQuery.ajaxSetup({}, options), callbackContext = s.context || s, globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks('once memory'), statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, state = 0, strAbort = 'canceled', jqXHR = {
                    readyState: 0,
                    getResponseHeader: function (key) {
                        var match;
                        if (state === 2) {
                            if (!responseHeaders) {
                                responseHeaders = {};
                                while (match = rheaders.exec(responseHeadersString)) {
                                    responseHeaders[match[1].toLowerCase()] = match[2];
                                }
                            }
                            match = responseHeaders[key.toLowerCase()];
                        }
                        return match == null ? null : match;
                    },
                    getAllResponseHeaders: function () {
                        return state === 2 ? responseHeadersString : null;
                    },
                    setRequestHeader: function (name, value) {
                        var lname = name.toLowerCase();
                        if (!state) {
                            name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
                            requestHeaders[name] = value;
                        }
                        return this;
                    },
                    overrideMimeType: function (type) {
                        if (!state) {
                            s.mimeType = type;
                        }
                        return this;
                    },
                    statusCode: function (map) {
                        var code;
                        if (map) {
                            if (state < 2) {
                                for (code in map) {
                                    statusCode[code] = [
                                        statusCode[code],
                                        map[code]
                                    ];
                                }
                            } else {
                                jqXHR.always(map[jqXHR.status]);
                            }
                        }
                        return this;
                    },
                    abort: function (statusText) {
                        var finalText = statusText || strAbort;
                        if (transport) {
                            transport.abort(finalText);
                        }
                        done(0, finalText);
                        return this;
                    }
                };
            deferred.promise(jqXHR).complete = completeDeferred.add;
            jqXHR.success = jqXHR.done;
            jqXHR.error = jqXHR.fail;
            s.url = ((url || s.url || ajaxLocation) + '').replace(rhash, '').replace(rprotocol, ajaxLocParts[1] + '//');
            s.type = options.method || options.type || s.method || s.type;
            s.dataTypes = jQuery.trim(s.dataType || '*').toLowerCase().match(rnotwhite) || [''];
            if (s.crossDomain == null) {
                parts = rurl.exec(s.url.toLowerCase());
                s.crossDomain = !!(parts && (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] || (parts[3] || (parts[1] === 'http:' ? '80' : '443')) !== (ajaxLocParts[3] || (ajaxLocParts[1] === 'http:' ? '80' : '443'))));
            }
            if (s.data && s.processData && typeof s.data !== 'string') {
                s.data = jQuery.param(s.data, s.traditional);
            }
            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
            if (state === 2) {
                return jqXHR;
            }
            fireGlobals = s.global;
            if (fireGlobals && jQuery.active++ === 0) {
                jQuery.event.trigger('ajaxStart');
            }
            s.type = s.type.toUpperCase();
            s.hasContent = !rnoContent.test(s.type);
            cacheURL = s.url;
            if (!s.hasContent) {
                if (s.data) {
                    cacheURL = s.url += (rquery.test(cacheURL) ? '&' : '?') + s.data;
                    delete s.data;
                }
                if (s.cache === false) {
                    s.url = rts.test(cacheURL) ? cacheURL.replace(rts, '$1_=' + nonce++) : cacheURL + (rquery.test(cacheURL) ? '&' : '?') + '_=' + nonce++;
                }
            }
            if (s.ifModified) {
                if (jQuery.lastModified[cacheURL]) {
                    jqXHR.setRequestHeader('If-Modified-Since', jQuery.lastModified[cacheURL]);
                }
                if (jQuery.etag[cacheURL]) {
                    jqXHR.setRequestHeader('If-None-Match', jQuery.etag[cacheURL]);
                }
            }
            if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
                jqXHR.setRequestHeader('Content-Type', s.contentType);
            }
            jqXHR.setRequestHeader('Accept', s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== '*' ? ', ' + allTypes + '; q=0.01' : '') : s.accepts['*']);
            for (i in s.headers) {
                jqXHR.setRequestHeader(i, s.headers[i]);
            }
            if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
                return jqXHR.abort();
            }
            strAbort = 'abort';
            for (i in {
                    success: 1,
                    error: 1,
                    complete: 1
                }) {
                jqXHR[i](s[i]);
            }
            transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
            if (!transport) {
                done(-1, 'No Transport');
            } else {
                jqXHR.readyState = 1;
                if (fireGlobals) {
                    globalEventContext.trigger('ajaxSend', [
                        jqXHR,
                        s
                    ]);
                }
                if (s.async && s.timeout > 0) {
                    timeoutTimer = setTimeout(function () {
                        jqXHR.abort('timeout');
                    }, s.timeout);
                }
                try {
                    state = 1;
                    transport.send(requestHeaders, done);
                } catch (e) {
                    if (state < 2) {
                        done(-1, e);
                    } else {
                        throw e;
                    }
                }
            }
            function done(status, nativeStatusText, responses, headers) {
                var isSuccess, success, error, response, modified, statusText = nativeStatusText;
                if (state === 2) {
                    return;
                }
                state = 2;
                if (timeoutTimer) {
                    clearTimeout(timeoutTimer);
                }
                transport = undefined;
                responseHeadersString = headers || '';
                jqXHR.readyState = status > 0 ? 4 : 0;
                isSuccess = status >= 200 && status < 300 || status === 304;
                if (responses) {
                    response = ajaxHandleResponses(s, jqXHR, responses);
                }
                response = ajaxConvert(s, response, jqXHR, isSuccess);
                if (isSuccess) {
                    if (s.ifModified) {
                        modified = jqXHR.getResponseHeader('Last-Modified');
                        if (modified) {
                            jQuery.lastModified[cacheURL] = modified;
                        }
                        modified = jqXHR.getResponseHeader('etag');
                        if (modified) {
                            jQuery.etag[cacheURL] = modified;
                        }
                    }
                    if (status === 204 || s.type === 'HEAD') {
                        statusText = 'nocontent';
                    } else if (status === 304) {
                        statusText = 'notmodified';
                    } else {
                        statusText = response.state;
                        success = response.data;
                        error = response.error;
                        isSuccess = !error;
                    }
                } else {
                    error = statusText;
                    if (status || !statusText) {
                        statusText = 'error';
                        if (status < 0) {
                            status = 0;
                        }
                    }
                }
                jqXHR.status = status;
                jqXHR.statusText = (nativeStatusText || statusText) + '';
                if (isSuccess) {
                    deferred.resolveWith(callbackContext, [
                        success,
                        statusText,
                        jqXHR
                    ]);
                } else {
                    deferred.rejectWith(callbackContext, [
                        jqXHR,
                        statusText,
                        error
                    ]);
                }
                jqXHR.statusCode(statusCode);
                statusCode = undefined;
                if (fireGlobals) {
                    globalEventContext.trigger(isSuccess ? 'ajaxSuccess' : 'ajaxError', [
                        jqXHR,
                        s,
                        isSuccess ? success : error
                    ]);
                }
                completeDeferred.fireWith(callbackContext, [
                    jqXHR,
                    statusText
                ]);
                if (fireGlobals) {
                    globalEventContext.trigger('ajaxComplete', [
                        jqXHR,
                        s
                    ]);
                    if (!--jQuery.active) {
                        jQuery.event.trigger('ajaxStop');
                    }
                }
            }
            return jqXHR;
        },
        getJSON: function (url, data, callback) {
            return jQuery.get(url, data, callback, 'json');
        },
        getScript: function (url, callback) {
            return jQuery.get(url, undefined, callback, 'script');
        }
    });
    jQuery.each([
        'get',
        'post'
    ], function (i, method) {
        jQuery[method] = function (url, data, callback, type) {
            if (jQuery.isFunction(data)) {
                type = type || callback;
                callback = data;
                data = undefined;
            }
            return jQuery.ajax({
                url: url,
                type: method,
                dataType: type,
                data: data,
                success: callback
            });
        };
    });
    jQuery.each([
        'ajaxStart',
        'ajaxStop',
        'ajaxComplete',
        'ajaxError',
        'ajaxSuccess',
        'ajaxSend'
    ], function (i, type) {
        jQuery.fn[type] = function (fn) {
            return this.on(type, fn);
        };
    });
    jQuery._evalUrl = function (url) {
        return jQuery.ajax({
            url: url,
            type: 'GET',
            dataType: 'script',
            async: false,
            global: false,
            'throws': true
        });
    };
    jQuery.fn.extend({
        wrapAll: function (html) {
            if (jQuery.isFunction(html)) {
                return this.each(function (i) {
                    jQuery(this).wrapAll(html.call(this, i));
                });
            }
            if (this[0]) {
                var wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
                if (this[0].parentNode) {
                    wrap.insertBefore(this[0]);
                }
                wrap.map(function () {
                    var elem = this;
                    while (elem.firstChild && elem.firstChild.nodeType === 1) {
                        elem = elem.firstChild;
                    }
                    return elem;
                }).append(this);
            }
            return this;
        },
        wrapInner: function (html) {
            if (jQuery.isFunction(html)) {
                return this.each(function (i) {
                    jQuery(this).wrapInner(html.call(this, i));
                });
            }
            return this.each(function () {
                var self = jQuery(this), contents = self.contents();
                if (contents.length) {
                    contents.wrapAll(html);
                } else {
                    self.append(html);
                }
            });
        },
        wrap: function (html) {
            var isFunction = jQuery.isFunction(html);
            return this.each(function (i) {
                jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
            });
        },
        unwrap: function () {
            return this.parent().each(function () {
                if (!jQuery.nodeName(this, 'body')) {
                    jQuery(this).replaceWith(this.childNodes);
                }
            }).end();
        }
    });
    jQuery.expr.filters.hidden = function (elem) {
        return elem.offsetWidth <= 0 && elem.offsetHeight <= 0 || !support.reliableHiddenOffsets() && (elem.style && elem.style.display || jQuery.css(elem, 'display')) === 'none';
    };
    jQuery.expr.filters.visible = function (elem) {
        return !jQuery.expr.filters.hidden(elem);
    };
    var r20 = /%20/g, rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
    function buildParams(prefix, obj, traditional, add) {
        var name;
        if (jQuery.isArray(obj)) {
            jQuery.each(obj, function (i, v) {
                if (traditional || rbracket.test(prefix)) {
                    add(prefix, v);
                } else {
                    buildParams(prefix + '[' + (typeof v === 'object' ? i : '') + ']', v, traditional, add);
                }
            });
        } else if (!traditional && jQuery.type(obj) === 'object') {
            for (name in obj) {
                buildParams(prefix + '[' + name + ']', obj[name], traditional, add);
            }
        } else {
            add(prefix, obj);
        }
    }
    jQuery.param = function (a, traditional) {
        var prefix, s = [], add = function (key, value) {
                value = jQuery.isFunction(value) ? value() : value == null ? '' : value;
                s[s.length] = encodeURIComponent(key) + '=' + encodeURIComponent(value);
            };
        if (traditional === undefined) {
            traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
        }
        if (jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
            jQuery.each(a, function () {
                add(this.name, this.value);
            });
        } else {
            for (prefix in a) {
                buildParams(prefix, a[prefix], traditional, add);
            }
        }
        return s.join('&').replace(r20, '+');
    };
    jQuery.fn.extend({
        serialize: function () {
            return jQuery.param(this.serializeArray());
        },
        serializeArray: function () {
            return this.map(function () {
                var elements = jQuery.prop(this, 'elements');
                return elements ? jQuery.makeArray(elements) : this;
            }).filter(function () {
                var type = this.type;
                return this.name && !jQuery(this).is(':disabled') && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
            }).map(function (i, elem) {
                var val = jQuery(this).val();
                return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function (val) {
                    return {
                        name: elem.name,
                        value: val.replace(rCRLF, '\r\n')
                    };
                }) : {
                    name: elem.name,
                    value: val.replace(rCRLF, '\r\n')
                };
            }).get();
        }
    });
    jQuery.ajaxSettings.xhr = window.ActiveXObject !== undefined ? function () {
        return !this.isLocal && /^(get|post|head|put|delete|options)$/i.test(this.type) && createStandardXHR() || createActiveXHR();
    } : createStandardXHR;
    var xhrId = 0, xhrCallbacks = {}, xhrSupported = jQuery.ajaxSettings.xhr();
    if (window.ActiveXObject) {
        jQuery(window).on('unload', function () {
            for (var key in xhrCallbacks) {
                xhrCallbacks[key](undefined, true);
            }
        });
    }
    support.cors = !!xhrSupported && 'withCredentials' in xhrSupported;
    xhrSupported = support.ajax = !!xhrSupported;
    if (xhrSupported) {
        jQuery.ajaxTransport(function (options) {
            if (!options.crossDomain || support.cors) {
                var callback;
                return {
                    send: function (headers, complete) {
                        var i, xhr = options.xhr(), id = ++xhrId;
                        xhr.open(options.type, options.url, options.async, options.username, options.password);
                        if (options.xhrFields) {
                            for (i in options.xhrFields) {
                                xhr[i] = options.xhrFields[i];
                            }
                        }
                        if (options.mimeType && xhr.overrideMimeType) {
                            xhr.overrideMimeType(options.mimeType);
                        }
                        if (!options.crossDomain && !headers['X-Requested-With']) {
                            headers['X-Requested-With'] = 'XMLHttpRequest';
                        }
                        for (i in headers) {
                            if (headers[i] !== undefined) {
                                xhr.setRequestHeader(i, headers[i] + '');
                            }
                        }
                        xhr.send(options.hasContent && options.data || null);
                        callback = function (_, isAbort) {
                            var status, statusText, responses;
                            if (callback && (isAbort || xhr.readyState === 4)) {
                                delete xhrCallbacks[id];
                                callback = undefined;
                                xhr.onreadystatechange = jQuery.noop;
                                if (isAbort) {
                                    if (xhr.readyState !== 4) {
                                        xhr.abort();
                                    }
                                } else {
                                    responses = {};
                                    status = xhr.status;
                                    if (typeof xhr.responseText === 'string') {
                                        responses.text = xhr.responseText;
                                    }
                                    try {
                                        statusText = xhr.statusText;
                                    } catch (e) {
                                        statusText = '';
                                    }
                                    if (!status && options.isLocal && !options.crossDomain) {
                                        status = responses.text ? 200 : 404;
                                    } else if (status === 1223) {
                                        status = 204;
                                    }
                                }
                            }
                            if (responses) {
                                complete(status, statusText, responses, xhr.getAllResponseHeaders());
                            }
                        };
                        if (!options.async) {
                            callback();
                        } else if (xhr.readyState === 4) {
                            setTimeout(callback);
                        } else {
                            xhr.onreadystatechange = xhrCallbacks[id] = callback;
                        }
                    },
                    abort: function () {
                        if (callback) {
                            callback(undefined, true);
                        }
                    }
                };
            }
        });
    }
    function createStandardXHR() {
        try {
            return new window.XMLHttpRequest();
        } catch (e) {
        }
    }
    function createActiveXHR() {
        try {
            return new window.ActiveXObject('Microsoft.XMLHTTP');
        } catch (e) {
        }
    }
    jQuery.ajaxSetup({
        accepts: { script: 'text/javascript, application/javascript, application/ecmascript, application/x-ecmascript' },
        contents: { script: /(?:java|ecma)script/ },
        converters: {
            'text script': function (text) {
                jQuery.globalEval(text);
                return text;
            }
        }
    });
    jQuery.ajaxPrefilter('script', function (s) {
        if (s.cache === undefined) {
            s.cache = false;
        }
        if (s.crossDomain) {
            s.type = 'GET';
            s.global = false;
        }
    });
    jQuery.ajaxTransport('script', function (s) {
        if (s.crossDomain) {
            var script, head = document.head || jQuery('head')[0] || document.documentElement;
            return {
                send: function (_, callback) {
                    script = document.createElement('script');
                    script.async = true;
                    if (s.scriptCharset) {
                        script.charset = s.scriptCharset;
                    }
                    script.src = s.url;
                    script.onload = script.onreadystatechange = function (_, isAbort) {
                        if (isAbort || !script.readyState || /loaded|complete/.test(script.readyState)) {
                            script.onload = script.onreadystatechange = null;
                            if (script.parentNode) {
                                script.parentNode.removeChild(script);
                            }
                            script = null;
                            if (!isAbort) {
                                callback(200, 'success');
                            }
                        }
                    };
                    head.insertBefore(script, head.firstChild);
                },
                abort: function () {
                    if (script) {
                        script.onload(undefined, true);
                    }
                }
            };
        }
    });
    var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
    jQuery.ajaxSetup({
        jsonp: 'callback',
        jsonpCallback: function () {
            var callback = oldCallbacks.pop() || jQuery.expando + '_' + nonce++;
            this[callback] = true;
            return callback;
        }
    });
    jQuery.ajaxPrefilter('json jsonp', function (s, originalSettings, jqXHR) {
        var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? 'url' : typeof s.data === 'string' && !(s.contentType || '').indexOf('application/x-www-form-urlencoded') && rjsonp.test(s.data) && 'data');
        if (jsonProp || s.dataTypes[0] === 'jsonp') {
            callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
            if (jsonProp) {
                s[jsonProp] = s[jsonProp].replace(rjsonp, '$1' + callbackName);
            } else if (s.jsonp !== false) {
                s.url += (rquery.test(s.url) ? '&' : '?') + s.jsonp + '=' + callbackName;
            }
            s.converters['script json'] = function () {
                if (!responseContainer) {
                    jQuery.error(callbackName + ' was not called');
                }
                return responseContainer[0];
            };
            s.dataTypes[0] = 'json';
            overwritten = window[callbackName];
            window[callbackName] = function () {
                responseContainer = arguments;
            };
            jqXHR.always(function () {
                window[callbackName] = overwritten;
                if (s[callbackName]) {
                    s.jsonpCallback = originalSettings.jsonpCallback;
                    oldCallbacks.push(callbackName);
                }
                if (responseContainer && jQuery.isFunction(overwritten)) {
                    overwritten(responseContainer[0]);
                }
                responseContainer = overwritten = undefined;
            });
            return 'script';
        }
    });
    jQuery.parseHTML = function (data, context, keepScripts) {
        if (!data || typeof data !== 'string') {
            return null;
        }
        if (typeof context === 'boolean') {
            keepScripts = context;
            context = false;
        }
        context = context || document;
        var parsed = rsingleTag.exec(data), scripts = !keepScripts && [];
        if (parsed) {
            return [context.createElement(parsed[1])];
        }
        parsed = jQuery.buildFragment([data], context, scripts);
        if (scripts && scripts.length) {
            jQuery(scripts).remove();
        }
        return jQuery.merge([], parsed.childNodes);
    };
    var _load = jQuery.fn.load;
    jQuery.fn.load = function (url, params, callback) {
        if (typeof url !== 'string' && _load) {
            return _load.apply(this, arguments);
        }
        var selector, response, type, self = this, off = url.indexOf(' ');
        if (off >= 0) {
            selector = url.slice(off, url.length);
            url = url.slice(0, off);
        }
        if (jQuery.isFunction(params)) {
            callback = params;
            params = undefined;
        } else if (params && typeof params === 'object') {
            type = 'POST';
        }
        if (self.length > 0) {
            jQuery.ajax({
                url: url,
                type: type,
                dataType: 'html',
                data: params
            }).done(function (responseText) {
                response = arguments;
                self.html(selector ? jQuery('<div>').append(jQuery.parseHTML(responseText)).find(selector) : responseText);
            }).complete(callback && function (jqXHR, status) {
                self.each(callback, response || [
                    jqXHR.responseText,
                    status,
                    jqXHR
                ]);
            });
        }
        return this;
    };
    jQuery.expr.filters.animated = function (elem) {
        return jQuery.grep(jQuery.timers, function (fn) {
            return elem === fn.elem;
        }).length;
    };
    var docElem = window.document.documentElement;
    function getWindow(elem) {
        return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 ? elem.defaultView || elem.parentWindow : false;
    }
    jQuery.offset = {
        setOffset: function (elem, options, i) {
            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, 'position'), curElem = jQuery(elem), props = {};
            if (position === 'static') {
                elem.style.position = 'relative';
            }
            curOffset = curElem.offset();
            curCSSTop = jQuery.css(elem, 'top');
            curCSSLeft = jQuery.css(elem, 'left');
            calculatePosition = (position === 'absolute' || position === 'fixed') && jQuery.inArray('auto', [
                curCSSTop,
                curCSSLeft
            ]) > -1;
            if (calculatePosition) {
                curPosition = curElem.position();
                curTop = curPosition.top;
                curLeft = curPosition.left;
            } else {
                curTop = parseFloat(curCSSTop) || 0;
                curLeft = parseFloat(curCSSLeft) || 0;
            }
            if (jQuery.isFunction(options)) {
                options = options.call(elem, i, curOffset);
            }
            if (options.top != null) {
                props.top = options.top - curOffset.top + curTop;
            }
            if (options.left != null) {
                props.left = options.left - curOffset.left + curLeft;
            }
            if ('using' in options) {
                options.using.call(elem, props);
            } else {
                curElem.css(props);
            }
        }
    };
    jQuery.fn.extend({
        offset: function (options) {
            if (arguments.length) {
                return options === undefined ? this : this.each(function (i) {
                    jQuery.offset.setOffset(this, options, i);
                });
            }
            var docElem, win, box = {
                    top: 0,
                    left: 0
                }, elem = this[0], doc = elem && elem.ownerDocument;
            if (!doc) {
                return;
            }
            docElem = doc.documentElement;
            if (!jQuery.contains(docElem, elem)) {
                return box;
            }
            if (typeof elem.getBoundingClientRect !== strundefined) {
                box = elem.getBoundingClientRect();
            }
            win = getWindow(doc);
            return {
                top: box.top + (win.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0),
                left: box.left + (win.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0)
            };
        },
        position: function () {
            if (!this[0]) {
                return;
            }
            var offsetParent, offset, parentOffset = {
                    top: 0,
                    left: 0
                }, elem = this[0];
            if (jQuery.css(elem, 'position') === 'fixed') {
                offset = elem.getBoundingClientRect();
            } else {
                offsetParent = this.offsetParent();
                offset = this.offset();
                if (!jQuery.nodeName(offsetParent[0], 'html')) {
                    parentOffset = offsetParent.offset();
                }
                parentOffset.top += jQuery.css(offsetParent[0], 'borderTopWidth', true);
                parentOffset.left += jQuery.css(offsetParent[0], 'borderLeftWidth', true);
            }
            return {
                top: offset.top - parentOffset.top - jQuery.css(elem, 'marginTop', true),
                left: offset.left - parentOffset.left - jQuery.css(elem, 'marginLeft', true)
            };
        },
        offsetParent: function () {
            return this.map(function () {
                var offsetParent = this.offsetParent || docElem;
                while (offsetParent && (!jQuery.nodeName(offsetParent, 'html') && jQuery.css(offsetParent, 'position') === 'static')) {
                    offsetParent = offsetParent.offsetParent;
                }
                return offsetParent || docElem;
            });
        }
    });
    jQuery.each({
        scrollLeft: 'pageXOffset',
        scrollTop: 'pageYOffset'
    }, function (method, prop) {
        var top = /Y/.test(prop);
        jQuery.fn[method] = function (val) {
            return access(this, function (elem, method, val) {
                var win = getWindow(elem);
                if (val === undefined) {
                    return win ? prop in win ? win[prop] : win.document.documentElement[method] : elem[method];
                }
                if (win) {
                    win.scrollTo(!top ? val : jQuery(win).scrollLeft(), top ? val : jQuery(win).scrollTop());
                } else {
                    elem[method] = val;
                }
            }, method, val, arguments.length, null);
        };
    });
    jQuery.each([
        'top',
        'left'
    ], function (i, prop) {
        jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {
            if (computed) {
                computed = curCSS(elem, prop);
                return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + 'px' : computed;
            }
        });
    });
    jQuery.each({
        Height: 'height',
        Width: 'width'
    }, function (name, type) {
        jQuery.each({
            padding: 'inner' + name,
            content: type,
            '': 'outer' + name
        }, function (defaultExtra, funcName) {
            jQuery.fn[funcName] = function (margin, value) {
                var chainable = arguments.length && (defaultExtra || typeof margin !== 'boolean'), extra = defaultExtra || (margin === true || value === true ? 'margin' : 'border');
                return access(this, function (elem, type, value) {
                    var doc;
                    if (jQuery.isWindow(elem)) {
                        return elem.document.documentElement['client' + name];
                    }
                    if (elem.nodeType === 9) {
                        doc = elem.documentElement;
                        return Math.max(elem.body['scroll' + name], doc['scroll' + name], elem.body['offset' + name], doc['offset' + name], doc['client' + name]);
                    }
                    return value === undefined ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra);
                }, type, chainable ? margin : undefined, chainable, null);
            };
        });
    });
    jQuery.fn.size = function () {
        return this.length;
    };
    jQuery.fn.andSelf = jQuery.fn.addBack;
    if (typeof define === 'function' && define.amd) {
        define('jquery@1.11.0#dist/jquery', [], function () {
            return jQuery;
        });
    }
    var _jQuery = window.jQuery, _$ = window.$;
    jQuery.noConflict = function (deep) {
        if (window.$ === jQuery) {
            window.$ = _$;
        }
        if (deep && window.jQuery === jQuery) {
            window.jQuery = _jQuery;
        }
        return jQuery;
    };
    if (typeof noGlobal === strundefined) {
        window.jQuery = window.$ = jQuery;
    }
    return jQuery;
}));
/*funcunit@3.2.0#browser/jquery*/
define('funcunit@3.2.0#browser/jquery', function (require, exports, module) {
    var $ = require('jquery');
    module.exports = $.noConflict(true);
});
/*funcunit@3.2.0#browser/init*/
define('funcunit@3.2.0#browser/init', function (require, exports, module) {
    var jQuery = require('funcunit/browser/jquery');
    var FuncUnit = window.FuncUnit || {};
    window.jQuery = jQuery;
    jQuery.sub = function () {
        function jQuerySub(selector, context) {
            return new jQuerySub.fn.init(selector, context);
        }
        jQuery.extend(true, jQuerySub, this);
        jQuerySub.superclass = this;
        jQuerySub.fn = jQuerySub.prototype = this();
        jQuerySub.fn.constructor = jQuerySub;
        jQuerySub.sub = this.sub;
        jQuerySub.fn.init = function init(selector, context) {
            if (context && context instanceof jQuery && !(context instanceof jQuerySub)) {
                context = jQuerySub(context);
            }
            return jQuery.fn.init.call(this, selector, context, rootjQuerySub);
        };
        jQuerySub.fn.init.prototype = jQuerySub.fn;
        var rootjQuerySub = jQuerySub(document);
        return jQuerySub;
    };
    FuncUnit.jQuery = jQuery;
    module.exports = FuncUnit;
});
/*funcunit@3.2.0#browser/core*/
define('funcunit@3.2.0#browser/core', function (require, exports, module) {
    var jQuery = require('funcunit/browser/jquery');
    var oldFuncUnit = require('funcunit/browser/init');
    var FuncUnit = oldFuncUnit.jQuery.sub();
    var origFuncUnit = FuncUnit;
    FuncUnit = function (selector, frame) {
        var frame, forceSync, isSyncOnly = false;
        if (frame && frame.forceSync) {
            forceSync = frame.forceSync;
        }
        if (frame && typeof frame.frame !== 'undefined') {
            frame = frame.frame;
        }
        isSyncOnly = typeof forceSync === 'boolean' ? forceSync : isSyncOnly;
        if (typeof selector == 'function') {
            return FuncUnit.wait(0, selector);
        }
        this.selector = selector;
        if (isSyncOnly === true) {
            var collection = performSyncQuery(selector, frame);
            return collection;
        } else {
            performAsyncQuery(selector, frame, this);
            var collection = performSyncQuery(selector, frame);
            return collection;
        }
    };
    var getContext = function (context) {
            if (typeof context === 'number' || typeof context === 'string') {
                var sel = typeof context === 'number' ? 'iframe:eq(' + context + ')' : 'iframe[name=\'' + context + '\']', frames = new origFuncUnit.fn.init(sel, FuncUnit.win.document.documentElement, true);
                var frame = (frames.length ? frames.get(0).contentWindow : FuncUnit.win).document.documentElement;
            } else {
                frame = FuncUnit.win.document.documentElement;
            }
            return frame;
        }, performAsyncQuery = function (selector, frame, self) {
            FuncUnit.add({
                method: function (success, error) {
                    this.frame = frame;
                    if (FuncUnit.win) {
                        frame = getContext(frame);
                    }
                    this.selector = selector;
                    this.bind = new origFuncUnit.fn.init(selector, frame, true);
                    success();
                    return this;
                },
                error: 'selector failed: ' + selector,
                type: 'query'
            });
        }, performSyncQuery = function (selector, frame) {
            var origFrame = frame;
            if (FuncUnit.win) {
                frame = getContext(frame);
            }
            var obj = new origFuncUnit.fn.init(selector, frame, true);
            obj.frame = origFrame;
            return obj;
        };
    oldFuncUnit.jQuery.extend(FuncUnit, oldFuncUnit, origFuncUnit);
    FuncUnit.prototype = origFuncUnit.prototype;
    module.exports = FuncUnit;
});
/*funcunit@3.2.0#browser/adapters/jasmine*/
define('funcunit@3.2.0#browser/adapters/jasmine', function (require, exports, module) {
    module.exports = function (jasmine) {
        var paused = false;
        return {
            pauseTest: function () {
                paused = true;
                waitsFor(function () {
                    return paused === false;
                }, 60000);
            },
            resumeTest: function () {
                paused = false;
            },
            assertOK: function (assertion, message) {
                expect(assertion).toBeTruthy();
            },
            equiv: function (expected, actual) {
                return jasmine.getEnv().equals_(expected, actual);
            }
        };
    };
});
/*funcunit@3.2.0#browser/adapters/jasmine2*/
define('funcunit@3.2.0#browser/adapters/jasmine2', function (require, exports, module) {
    var FuncUnit = require('funcunit/browser/core');
    module.exports = function (jasmine) {
        FuncUnit.timeout = 4900;
        return {
            pauseTest: function () {
            },
            resumeTest: function () {
            },
            assertOK: function (assertion, message) {
                expect(assertion).toBeTruthy();
            },
            equiv: function (expected, actual) {
                return expected == actual;
            }
        };
    };
});
/*funcunit@3.2.0#browser/adapters/qunit*/
define('funcunit@3.2.0#browser/adapters/qunit', function (require, exports, module) {
    module.exports = function (QUnit) {
        return {
            pauseTest: function () {
                QUnit.stop();
            },
            resumeTest: function () {
                QUnit.start();
            },
            assertOK: function (assertion, message) {
                QUnit.ok(assertion, message);
            },
            equiv: function (expected, actual) {
                return QUnit.equiv(expected, actual);
            }
        };
    };
});
/*funcunit@3.2.0#browser/adapters/mocha*/
define('funcunit@3.2.0#browser/adapters/mocha', function (require, exports, module) {
    var FuncUnit = require('funcunit/browser/core');
    var ok = function (expr, msg) {
        if (!expr)
            throw new Error(msg);
    };
    module.exports = function (mocha) {
        FuncUnit.timeout = 1900;
        return {
            pauseTest: function () {
            },
            resumeTest: function () {
            },
            assertOK: function (assertion, message) {
                ok(assertion, message);
            },
            equiv: function (expected, actual) {
                return expected == actual;
            }
        };
    };
});
/*funcunit@3.2.0#browser/adapters/adapters*/
define('funcunit@3.2.0#browser/adapters/adapters', function (require, exports, module) {
    (function (global) {
        var jasmineAdapter = require('funcunit/browser/adapters/jasmine');
        var jasmine2Adapter = require('funcunit/browser/adapters/jasmine2');
        var qunitAdapter = require('funcunit/browser/adapters/qunit');
        var mochaAdapter = require('funcunit/browser/adapters/mocha');
        var FuncUnit = require('funcunit/browser/core');
        var noop = function () {
        };
        var defaultAdapter = {
            pauseTest: noop,
            resumeTest: noop,
            assertOK: noop,
            equiv: function (expected, actual) {
                return expected == actual;
            }
        };
        FuncUnit.unit = defaultAdapter;
        FuncUnit.attach = function (runner) {
            var unit;
            if (isQUnit(runner)) {
                unit = qunitAdapter(runner);
            } else if (isMocha(runner)) {
                unit = mochaAdapter(runner);
            } else if (isJasmine(runner)) {
                unit = jasmineAdapter(runner);
            } else if (isJasmine2(runner)) {
                unit = jasmine2Adapter(runner);
            } else {
                unit = defaultAdapter;
            }
            FuncUnit.unit = unit;
        };
        function isQUnit(runner) {
            return !!(runner.ok && runner.start && runner.stop);
        }
        function isMocha(runner) {
            return !!(runner.setup && runner.globals && runner.reporter);
        }
        function isJasmine(runner) {
            return !!(runner.getEnv && typeof window.waitsFor === 'function');
        }
        function isJasmine2(runner) {
            return !!(runner.getEnv && typeof runner.clock === 'function' && !window.waitsFor);
        }
        FuncUnit.detach = function () {
            FuncUnit.unit = defaultAdapter;
        };
    }(function () {
        return this;
    }()));
});
/*funcunit@3.2.0#browser/open*/
define('funcunit@3.2.0#browser/open', function (require, exports, module) {
    var $ = require('funcunit/browser/jquery');
    var FuncUnit = require('funcunit/browser/core');
    var syn = require('syn');
    if (FuncUnit.frameMode) {
        var ifrm = document.createElement('iframe');
        ifrm.id = 'funcunit_app';
        document.body.insertBefore(ifrm, document.body.firstChild);
    }
    var confirms = [], prompts = [], currentDocument, currentHref, appWin, lookingForNewDocument = false, urlWithoutHash = function (url) {
            return url.replace(/\#.*$/, '');
        }, isCurrentPage = function (url) {
            var pathname = urlWithoutHash(FuncUnit.win.location.pathname), href = urlWithoutHash(FuncUnit.win.location.href), url = urlWithoutHash(url);
            if (pathname === url || href === url) {
                return true;
            }
            return false;
        };
    $.extend(FuncUnit, {
        open: function (path, success, timeout) {
            if (typeof success != 'function') {
                timeout = success;
                success = undefined;
            }
            FuncUnit.add({
                method: function (success, error) {
                    if (typeof path === 'string') {
                        var fullPath = FuncUnit.getAbsolutePath(path);
                        FuncUnit._open(fullPath, error);
                        FuncUnit._onload(function () {
                            success();
                        }, error);
                    } else {
                        FuncUnit.win = path;
                        success();
                    }
                },
                success: success,
                error: 'Page ' + path + ' not loaded in time!',
                timeout: timeout || 30000
            });
        },
        _open: function (url) {
            FuncUnit.win = appWin;
            hasSteal = false;
            FuncUnit.frame = $('#funcunit_app').length ? $('#funcunit_app')[0] : null;
            if (newPage) {
                if (FuncUnit.frame) {
                    FuncUnit.win = FuncUnit.frame.contentWindow;
                    FuncUnit.win.location = url;
                } else {
                    var width = $(window).width();
                    FuncUnit.win = window.open(url, 'funcunit', 'height=1000,toolbar=yes,status=yes,width=' + width / 2 + ',left=' + width / 2);
                    if (FuncUnit.win && FuncUnit.win.___FUNCUNIT_OPENED) {
                        FuncUnit.win.close();
                        FuncUnit.win = window.open(url, 'funcunit', 'height=1000,toolbar=yes,status=yes,left=' + width / 2);
                    }
                    if (!FuncUnit.win) {
                        throw 'Could not open a popup window.  Your popup blocker is probably on.  Please turn it off and try again';
                    }
                }
                appWin = FuncUnit.win;
            } else {
                lookingForNewDocument = true;
                if (isCurrentPage(url)) {
                    FuncUnit.win.document.body.parentNode.removeChild(FuncUnit.win.document.body);
                    FuncUnit.win.location.hash = url.split('#')[1] || '';
                    FuncUnit.win.location.reload(true);
                } else {
                    FuncUnit.win.location = url;
                }
                currentDocument = null;
            }
            lookingForNewDocument = true;
        },
        confirm: function (answer) {
            confirms.push(!!answer);
        },
        prompt: function (answer) {
            prompts.push(answer);
        },
        _opened: function () {
            if (!this._isOverridden('alert')) {
                FuncUnit.win.alert = function () {
                };
            }
            if (!this._isOverridden('confirm')) {
                FuncUnit.win.confirm = function () {
                    var res = confirms.shift();
                    return res;
                };
            }
            if (!this._isOverridden('prompt')) {
                FuncUnit.win.prompt = function () {
                    return prompts.shift();
                };
            }
        },
        _isOverridden: function (type) {
            return !/(native code)|(source code not available)/.test(FuncUnit.win[type]);
        },
        _onload: function (success, error) {
            loadSuccess = function () {
                if (FuncUnit.win.steal) {
                    hasSteal = true;
                }
                if (!hasSteal) {
                    return success();
                }
                FuncUnit.win.steal.done().then(success);
            };
            if (!newPage) {
                return;
            }
            newPage = false;
            if (FuncUnit.support.readystate) {
                poller();
            } else {
                unloadLoader();
            }
        },
        getAbsolutePath: function (path) {
            if (/^\/\//.test(path)) {
                path = path.substr(2);
            }
            return path;
        },
        win: window,
        support: { readystate: 'readyState' in document },
        eval: function (str) {
            return FuncUnit.win.eval(str);
        },
        documentLoaded: function () {
            var loaded = FuncUnit.win.document.readyState === 'complete' && FuncUnit.win.location.href != 'about:blank' && FuncUnit.win.document.body;
            return loaded;
        },
        checkForNewDocument: function () {
            var documentFound = false;
            try {
                documentFound = (FuncUnit.win.document !== currentDocument && !FuncUnit.win.___FUNCUNIT_OPENED || currentHref != FuncUnit.win.location.href) && FuncUnit.documentLoaded();
            } catch (e) {
            }
            if (documentFound) {
                lookingForNewDocument = false;
                currentDocument = FuncUnit.win.document;
                currentHref = FuncUnit.win.location.href;
                FuncUnit.win.___FUNCUNIT_OPENED = true;
                FuncUnit._opened();
            }
            return documentFound;
        }
    });
    var newPage = true, hasSteal = false, unloadLoader, loadSuccess, firstLoad = true, onload = function () {
            FuncUnit.win.document.documentElement.tabIndex = 0;
            setTimeout(function () {
                FuncUnit.win.focus();
                var ls = loadSuccess;
                loadSuccess = null;
                if (ls) {
                    ls();
                }
            }, 0);
            syn.unbind(FuncUnit.win, 'load', onload);
        }, onunload = function () {
            FuncUnit.stop = true;
            removeListeners();
            setTimeout(unloadLoader, 0);
        }, removeListeners = function () {
            syn.unbind(FuncUnit.win, 'unload', onunload);
            Syn.unbind(FuncUnit.win, 'load', onload);
        };
    unloadLoader = function () {
        if (!firstLoad)
            removeListeners();
        syn.bind(FuncUnit.win, 'load', onload);
        syn.bind(FuncUnit.win, 'unload', onunload);
    };
    var newDocument = false, poller = function () {
            var ls;
            if (lookingForNewDocument && FuncUnit.checkForNewDocument()) {
                ls = loadSuccess;
                loadSuccess = null;
                if (ls) {
                    FuncUnit.win.focus();
                    FuncUnit.win.document.documentElement.tabIndex = 0;
                    ls();
                }
            }
            setTimeout(arguments.callee, 500);
        };
    $(window).unload(function () {
        if (FuncUnit.win && FuncUnit.win !== window.top) {
            FuncUnit.win.close();
        }
    });
    module.exports = FuncUnit;
});
/*funcunit@3.2.0#browser/actions*/
define('funcunit@3.2.0#browser/actions', function (require, exports, module) {
    var $ = require('funcunit/browser/jquery');
    var FuncUnit = require('funcunit/browser/core');
    var syn = window.syn = require('syn');
    var clicks = [
            'click',
            'dblclick',
            'rightClick'
        ], makeClick = function (name) {
            FuncUnit.prototype[name] = function (options, success) {
                this._addExists();
                if (typeof options == 'function') {
                    success = options;
                    options = {};
                }
                var selector = this.selector;
                FuncUnit.add({
                    method: function (success, error) {
                        options = options || {};
                        syn('_' + name, this.bind[0], options, success);
                    },
                    success: success,
                    error: 'Could not ' + name + ' \'' + this.selector + '\'',
                    bind: this,
                    type: 'action'
                });
                return this;
            };
        };
    for (var i = 0; i < clicks.length; i++) {
        makeClick(clicks[i]);
    }
    $.extend(FuncUnit.prototype, {
        _addExists: function () {
            this.exists(false);
        },
        type: function (text, success) {
            this._addExists();
            this.click();
            var selector = this.selector;
            if (text === '') {
                text = '[ctrl]a[ctrl-up]\b';
            }
            FuncUnit.add({
                method: function (success, error) {
                    syn('_type', this.bind[0], text, success);
                },
                success: success,
                error: 'Could not type ' + text + ' into ' + this.selector,
                bind: this,
                type: 'action'
            });
            return this;
        },
        sendKeys: function (keys, success) {
            this._addExists();
            var selector = this.selector;
            if (keys === '') {
                keys = '[ctrl]a[ctrl-up]\b';
            }
            FuncUnit.add({
                method: function (success, error) {
                    syn('_type', this.bind[0], keys, success);
                },
                success: success,
                error: 'Could not send the keys ' + keys + ' into ' + this.selector,
                bind: this,
                type: 'action'
            });
            return this;
        },
        trigger: function (evName, success) {
            this._addExists();
            FuncUnit.add({
                method: function (success, error) {
                    if (!FuncUnit.win.jQuery) {
                        throw 'Can not trigger custom event, no jQuery found on target page.';
                    }
                    FuncUnit.win.jQuery(this.bind.selector).trigger(evName);
                    success();
                },
                success: success,
                error: 'Could not trigger ' + evName,
                bind: this,
                type: 'action'
            });
            return this;
        },
        drag: function (options, success) {
            this._addExists();
            if (typeof options == 'string') {
                options = { to: options };
            }
            options.from = this.selector;
            var selector = this.selector;
            FuncUnit.add({
                method: function (success, error) {
                    syn('_drag', this.bind[0], options, success);
                },
                success: success,
                error: 'Could not drag ' + this.selector,
                bind: this,
                type: 'action'
            });
            return this;
        },
        move: function (options, success) {
            this._addExists();
            if (typeof options == 'string') {
                options = { to: options };
            }
            options.from = this.selector;
            var selector = this.selector;
            FuncUnit.add({
                method: function (success, error) {
                    syn('_move', this.bind[0], options, success);
                },
                success: success,
                error: 'Could not move ' + this.selector,
                bind: this,
                type: 'action'
            });
            return this;
        },
        scroll: function (direction, amount, success) {
            this._addExists();
            var selector = this.selector, direction;
            if (direction == 'left' || direction == 'right') {
                direction = 'Left';
            } else if (direction == 'top' || direction == 'bottom') {
                direction = 'Top';
            }
            FuncUnit.add({
                method: function (success, error) {
                    this.bind.each(function (i, el) {
                        this['scroll' + direction] = amount;
                    });
                    success();
                },
                success: success,
                error: 'Could not scroll ' + this.selector,
                bind: this,
                type: 'action'
            });
            return this;
        }
    });
    module.exports = FuncUnit;
});
/*funcunit@3.2.0#browser/getters*/
define('funcunit@3.2.0#browser/getters', function (require, exports, module) {
    var $ = require('funcunit/browser/jquery');
    var FuncUnit = require('funcunit/browser/core');
    FuncUnit.funcs = {
        'size': 0,
        'attr': 1,
        'hasClass': 1,
        'html': 0,
        'text': 0,
        'val': 0,
        'css': 1,
        'prop': 1,
        'offset': 0,
        'position': 0,
        'scrollTop': 0,
        'scrollLeft': 0,
        'height': 0,
        'width': 0,
        'innerHeight': 0,
        'innerWidth': 0,
        'outerHeight': 0,
        'outerWidth': 0
    };
    FuncUnit.makeFunc = function (fname, argIndex) {
        var orig = FuncUnit.fn[fname];
        FuncUnit.prototype[fname] = function () {
            var args = FuncUnit.makeArray(arguments), isWait = args.length > argIndex, success, self = this;
            args.unshift(this.selector, this.frame, fname);
            if (isWait) {
                var tester = args[argIndex + 3], timeout = args[argIndex + 4], success = args[argIndex + 5], message = args[argIndex + 6], testVal = tester, errorMessage = 'waiting for ' + fname + ' on ' + this.selector, frame = this.frame, logMessage = 'Checking ' + fname + ' on \'' + this.selector + '\'', ret;
                if (typeof tester == 'object' && !(tester instanceof RegExp)) {
                    timeout = tester.timeout;
                    success = tester.success;
                    message = tester.message;
                    if (tester.errorMessage) {
                        errorMessage = tester.errorMessage;
                    }
                    if (typeof tester.logMessage !== 'undefined') {
                        logMessage = tester.logMessage;
                    }
                    tester = tester.condition;
                }
                if (typeof timeout == 'function') {
                    message = success;
                    success = timeout;
                    timeout = undefined;
                }
                if (typeof timeout == 'string') {
                    message = timeout;
                    timeout = undefined;
                    success = undefined;
                }
                if (typeof message !== 'string') {
                    message = undefined;
                }
                args.splice(argIndex + 3, args.length - argIndex - 3);
                if (typeof tester != 'function') {
                    errorMessage += ' !== ' + testVal;
                    tester = function (val) {
                        return FuncUnit.unit.equiv(val, testVal) || testVal instanceof RegExp && testVal.test(val);
                    };
                }
                if (message) {
                    errorMessage = message;
                }
                FuncUnit.repeat({
                    method: function (print) {
                        if (this.bind.prevObject && this.bind.prevTraverser) {
                            var prev = this.bind;
                            this.bind = this.bind.prevObject[this.bind.prevTraverser](this.bind.prevTraverserSelector);
                            this.bind.prevTraverser = prev.prevTraverser;
                            this.bind.prevTraverserSelector = prev.prevTraverserSelector;
                        } else {
                            this.bind = F(this.selector, {
                                frame: frame,
                                forceSync: true
                            });
                        }
                        if (logMessage) {
                            print(logMessage);
                        }
                        var methodArgs = [];
                        if (argIndex > 0) {
                            methodArgs.push(args[3]);
                        }
                        FuncUnit._ignoreGetterError = true;
                        ret = this.bind[fname].apply(this.bind, methodArgs);
                        FuncUnit._ignoreGetterError = false;
                        var passed = tester.call(this.bind, ret);
                        if (this.bind.length === 0 && fname !== 'size') {
                            passed = false;
                        }
                        if (passed) {
                            if (!FuncUnit.documentLoaded()) {
                                passed = false;
                            } else {
                                FuncUnit.checkForNewDocument();
                            }
                        }
                        return passed;
                    },
                    success: function () {
                        if (message) {
                            FuncUnit.unit.assertOK(true, message);
                        }
                        success && success.apply(this, arguments);
                    },
                    error: function () {
                        var msg = errorMessage;
                        if (ret) {
                            msg += ', actual value: ' + ret;
                        }
                        FuncUnit.unit.assertOK(false, msg);
                    },
                    timeout: timeout,
                    bind: this,
                    type: 'wait'
                });
                return this;
            } else {
                if (!FuncUnit._ignoreGetterError && !FuncUnit._incallback && FuncUnit._haveAsyncQueries()) {
                    console && console.error('You can\'t run getters after actions and waits. Please put your getters in a callback or at the beginning of the test.');
                }
                var methodArgs = [];
                if (argIndex > 0) {
                    methodArgs.push(args[3]);
                }
                return orig.apply(this, methodArgs);
            }
        };
    };
    for (var prop in FuncUnit.funcs) {
        FuncUnit.makeFunc(prop, FuncUnit.funcs[prop]);
    }
    module.exports = FuncUnit;
});
/*funcunit@3.2.0#browser/traversers*/
define('funcunit@3.2.0#browser/traversers', function (require, exports, module) {
    var $ = require('funcunit/browser/jquery');
    var FuncUnit = require('funcunit/browser/core');
    var traversers = [
            'closest',
            'next',
            'prev',
            'siblings',
            'last',
            'first',
            'find'
        ], makeTraverser = function (name) {
            var orig = FuncUnit.prototype[name];
            FuncUnit.prototype[name] = function (selector) {
                var args = arguments;
                if (FuncUnit.win && this[0] && this[0].parentNode && this[0].parentNode.nodeType !== 9) {
                    FuncUnit.add({
                        method: function (success, error) {
                            var newBind = orig.apply(this.bind, args);
                            newBind.prevTraverser = name;
                            newBind.prevTraverserSelector = selector;
                            success(newBind);
                        },
                        error: 'Could not traverse: ' + name + ' ' + selector,
                        bind: this
                    });
                }
                return orig.apply(this, arguments);
            };
        };
    for (var i = 0; i < traversers.length; i++) {
        makeTraverser(traversers[i]);
    }
    module.exports = FuncUnit;
});
/*funcunit@3.2.0#browser/queue*/
define('funcunit@3.2.0#browser/queue', function (require, exports, module) {
    (function (global) {
        var FuncUnit = require('funcunit/browser/core');
        FuncUnit._incallback = false;
        var currentPosition = 0, startedQueue = false;
        FuncUnit.speed = 0;
        FuncUnit.timeout = 10000;
        FuncUnit._queue = [];
        FuncUnit._needSyncQuery = function () {
            if (FuncUnit._queue.length === 1) {
                if (FuncUnit._queue[0].type === 'query') {
                    FuncUnit._queue = [];
                    return true;
                }
            }
            if (FuncUnit._queue.length === 0) {
                return true;
            }
            return false;
        };
        FuncUnit._lastQueuedItem = function () {
            if (!FuncUnit._queue.length) {
                return null;
            }
            return FuncUnit._queue[FuncUnit._queue.length - 1];
        };
        FuncUnit._haveAsyncQueries = function () {
            for (var i = 0; i < FuncUnit._queue.length; i++) {
                if (FuncUnit._queue[i].type === 'action' || FuncUnit._queue[i].type === 'wait')
                    return true;
            }
            return false;
        };
        FuncUnit.add = function (handler, error, context) {
            if (handler instanceof Function) {
                if (typeof error === 'object') {
                    context = error;
                    delete error;
                }
                error = error && error.toString() || 'Custom method has failed.';
                var cb = handler;
                handler = {
                    method: function (success, error) {
                        success();
                    },
                    success: cb,
                    error: error,
                    bind: context
                };
            }
            if (FuncUnit._incallback) {
                FuncUnit._queue.splice(currentPosition, 0, handler);
                currentPosition++;
            } else {
                FuncUnit._queue.push(handler);
            }
            if (FuncUnit._queue.length == 1 && !FuncUnit._incallback) {
                FuncUnit.unit.pauseTest();
                setTimeout(FuncUnit._done, 13);
            }
        };
        var currentEl;
        FuncUnit._done = function (el, selector) {
            var next, timer, speed = FuncUnit.speed || 0;
            if (FuncUnit.speed === 'slow') {
                speed = 500;
            }
            if (FuncUnit._queue.length > 0) {
                next = FuncUnit._queue.shift();
                currentPosition = 0;
                setTimeout(function () {
                    timer = setTimeout(function () {
                        next.stop && next.stop();
                        if (typeof next.error === 'function') {
                            next.error();
                        } else {
                            FuncUnit.unit.assertOK(false, next.error);
                        }
                        FuncUnit._done();
                    }, (next.timeout || FuncUnit.timeout) + speed);
                    if (el && el.jquery) {
                        currentEl = el;
                    }
                    if (currentEl) {
                        next.bind = currentEl;
                    }
                    next.selector = selector;
                    next.method(function (el) {
                        if (el && el.jquery) {
                            next.bind = el;
                        }
                        clearTimeout(timer);
                        FuncUnit._incallback = true;
                        if (next.success) {
                            next.success.apply(next.bind, arguments);
                        }
                        FuncUnit._incallback = false;
                        FuncUnit._done(next.bind, next.selector);
                    }, function (message) {
                        clearTimeout(timer);
                        FuncUnit.unit.assertOK(false, message);
                        FuncUnit._done();
                    });
                }, speed);
            } else {
                FuncUnit.unit.resumeTest();
            }
        };
        module.exports = FuncUnit;
    }(function () {
        return this;
    }()));
});
/*funcunit@3.2.0#browser/waits*/
define('funcunit@3.2.0#browser/waits', function (require, exports, module) {
    var $ = require('funcunit/browser/jquery');
    var FuncUnit = require('funcunit/browser/core');
    FuncUnit.wait = function (time, success) {
        if (typeof time == 'function') {
            success = time;
            time = undefined;
        }
        time = time != null ? time : 5000;
        FuncUnit.add({
            method: function (success, error) {
                setTimeout(success, time);
            },
            success: success,
            error: 'Couldn\'t wait!',
            timeout: time + 1000
        });
        return this;
    };
    FuncUnit.branch = function (check1, success1, check2, success2, timeout) {
        FuncUnit.repeat({
            method: function (print) {
                print('Running a branch statement');
                if (check1()) {
                    success1();
                    return true;
                }
                if (check2()) {
                    success2();
                    return true;
                }
            },
            error: 'no branch condition was ever true',
            timeout: timeout,
            type: 'branch'
        });
    };
    FuncUnit.repeat = function (options) {
        var interval, stopped = false, stop = function () {
                clearTimeout(interval);
                stopped = true;
            };
        FuncUnit.add({
            method: function (success, error) {
                options.bind = this.bind;
                options.selector = this.selector;
                var printed = false, print = function (msg) {
                        if (!printed) {
                            printed = true;
                        }
                    };
                interval = setTimeout(function () {
                    var result = null;
                    try {
                        result = options.method(print);
                    } catch (e) {
                    }
                    if (result) {
                        success(options.bind);
                    } else if (!stopped) {
                        interval = setTimeout(arguments.callee, 10);
                    }
                }, 10);
            },
            success: options.success,
            error: options.error,
            timeout: options.timeout,
            stop: stop,
            bind: options.bind,
            type: options.type
        });
    };
    FuncUnit.animationEnd = function () {
        F('body').wait(200).size(function () {
            return F.win.$(':animated').length === 0;
        });
    };
    FuncUnit.animationsDone = FuncUnit.animationEnd;
    $.extend(FuncUnit.prototype, {
        exists: function (timeout, success, message) {
            var logMessage = 'Waiting for \'' + this.selector + '\' to exist';
            if (timeout === false) {
                logMessage = false;
            }
            return this.size({
                condition: function (size) {
                    return size > 0;
                },
                timeout: timeout,
                success: success,
                message: message,
                errorMessage: 'Exist failed: element with selector \'' + this.selector + '\' not found',
                logMessage: logMessage
            });
        },
        missing: function (timeout, success, message) {
            return this.size(0, timeout, success, message);
        },
        visible: function (timeout, success, message) {
            var self = this, sel = this.selector, ret;
            return this.size(function (size) {
                return this.is(':visible') === true;
            }, timeout, success, message);
        },
        invisible: function (timeout, success, message) {
            var self = this, sel = this.selector, ret;
            return this.size(function (size) {
                return this.is(':visible') === false;
            }, timeout, success, message);
        },
        wait: function (checker, timeout, success, message) {
            if (typeof checker === 'number') {
                timeout = checker;
                FuncUnit.wait(timeout, success);
                return this;
            } else {
                return this.size(checker, timeout, success, message);
            }
        },
        then: function (success) {
            var self = this;
            FuncUnit.wait(0, function () {
                success.call(this, this);
            });
            return this;
        }
    });
    module.exports = FuncUnit;
});
/*funcunit@3.2.0#funcunit*/
define('funcunit@3.2.0#funcunit', function (require, exports, module) {
    var syn = require('syn');
    var FuncUnit = require('funcunit/browser/core');
    require('funcunit/browser/adapters/');
    require('funcunit/browser/open');
    require('funcunit/browser/actions');
    require('funcunit/browser/getters');
    require('funcunit/browser/traversers');
    require('funcunit/browser/queue');
    require('funcunit/browser/waits');
    window.FuncUnit = window.S = window.F = FuncUnit;
    module.exports = FuncUnit;
});
/*can@3.4.1#docs/can-guides/experiment/todomvc/test*/
define('can@3.4.1#docs/can-guides/experiment/todomvc/test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var F = require('funcunit');
    F.attach(QUnit);
    QUnit.module('todomvc', {
        beforeEach: function (assert) {
            localStorage.clear();
        }
    });
    QUnit.test('basics work', function () {
        F('li.todo', 0).size(3, 'there are 3 todos');
        F('#new-todo', 0).type('new thing\r');
        F('li.todo', 0).size(4, 'new todo added');
    });
});
/*can@3.4.1#test/integration/all/test*/
define('can@3.4.1#test/integration/all/test', function (require, exports, module) {
    (function (__dirname) {
        var QUnit = require('steal-qunit');
        var makeIframe = function (src) {
            var iframe = document.createElement('iframe');
            window.removeMyself = function () {
                delete window.removeMyself;
                document.body.removeChild(iframe);
                QUnit.start();
            };
            document.body.appendChild(iframe);
            iframe.src = src;
        };
        QUnit.module('can.all.js');
        if (__dirname !== '/') {
            QUnit.asyncTest('works without jquery', function () {
                makeIframe(__dirname + '/no-jquery.html?' + Math.random());
            });
        }
    }('/'));
});
/*can@3.4.1#test/test*/
define('can@3.4.1#test/test', function (require, exports, module) {
    require('../component/component_test');
    require('../compute/compute_test');
    require('can-connect/test/test');
    require('../construct/construct_test');
    require('can-construct-super/test/can-construct-super_test');
    require('can-define/test/test');
    require('can-set/test/test');
    require('../view/stache/stache_test');
    require('can-stache-converters/test/test');
    require('../event/event_test');
    if (!System.isEnv('production')) {
        System.import('can-observation/can-observation_test');
    }
    require('../util/util_test');
    if (!System.isEnv('production')) {
        System.import('can-view-callbacks/test/callbacks-test');
    }
    require('../view/import/import_test');
    require('../view/live/live_test');
    require('can-view-model/test/test');
    require('../view/node_lists/node_lists_test');
    require('../view/parser/parser_test');
    require('../view/scope/scope_test');
    require('../view/autorender/autorender_test');
    if (!System.isEnv('production')) {
        System.import('can-simple-map/can-simple-map_test');
    }
    require('can-view-target/test/test');
    require('can-simple-dom/test/test');
    if (!System.isEnv('production')) {
        System.import('can-cid/test/test');
    }
    if (!System.isEnv('production')) {
        System.import('can-types/test/test');
    }
    require('../control/control_test');
    require('../list/list_test');
    require('../map/map_test');
    require('can-map-define/can-map-define_test');
    require('can-view-href/test/test');
    require('can-map-backup/can-map-backup_test');
    require('can-validate-legacy/can-validate-test');
    require('../view/ejs/ejs_test');
    require('can-fixture/test/fixture_test');
    require('../docs/can-guides/experiment/todomvc/test');
    require('./integration/all/test');
});