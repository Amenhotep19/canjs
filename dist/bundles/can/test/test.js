/*[system-bundles-config]*/
System.bundles = {"bundles/can/test/test.css!":["qunitjs@1.23.1#qunit/qunit.css!steal-css@1.2.5#css"]};
/*npm-utils*/
define('npm-utils', function (require, exports, module) {
    (function (global) {
        var slice = Array.prototype.slice;
        var npmModuleRegEx = /.+@.+\..+\..+#.+/;
        var conditionalModuleRegEx = /#\{[^\}]+\}|#\?.+$/;
        var gitUrlEx = /(git|http(s?)):\/\//;
        var supportsSet = typeof Set === 'function';
        var utils = {
            extend: function (d, s, deep, existingSet) {
                var val;
                var set = existingSet;
                if (deep) {
                    if (!set) {
                        if (supportsSet) {
                            set = new Set();
                        } else {
                            set = [];
                        }
                    }
                    if (supportsSet) {
                        if (set.has(s)) {
                            return s;
                        } else {
                            set.add(s);
                        }
                    } else {
                        if (set.indexOf(s) !== -1) {
                            return s;
                        } else {
                            set.push(s);
                        }
                    }
                }
                for (var prop in s) {
                    val = s[prop];
                    if (deep) {
                        if (utils.isArray(val)) {
                            d[prop] = slice.call(val);
                        } else if (utils.isPlainObject(val)) {
                            d[prop] = utils.extend({}, val, deep, set);
                        } else {
                            d[prop] = s[prop];
                        }
                    } else {
                        d[prop] = s[prop];
                    }
                }
                return d;
            },
            map: function (arr, fn) {
                var i = 0, len = arr.length, out = [];
                for (; i < len; i++) {
                    out.push(fn.call(arr, arr[i]));
                }
                return out;
            },
            filter: function (arr, fn) {
                var i = 0, len = arr.length, out = [], res;
                for (; i < len; i++) {
                    res = fn.call(arr, arr[i]);
                    if (res) {
                        out.push(arr[i]);
                    }
                }
                return out;
            },
            forEach: function (arr, fn) {
                var i = 0, len = arr.length;
                for (; i < len; i++) {
                    fn.call(arr, arr[i], i);
                }
            },
            isObject: function (obj) {
                return typeof obj === 'object';
            },
            isPlainObject: function (obj) {
                return utils.isObject(obj) && (!obj || obj.__proto__ === Object.prototype);
            },
            isArray: Array.isArray || function (arr) {
                return Object.prototype.toString.call(arr) === '[object Array]';
            },
            isEnv: function (name) {
                return this.isEnv ? this.isEnv(name) : this.env === name;
            },
            isGitUrl: function (str) {
                return gitUrlEx.test(str);
            },
            warnOnce: function (msg) {
                var w = this._warnings = this._warnings || {};
                if (w[msg])
                    return;
                w[msg] = true;
                this.warn(msg);
            },
            warn: function (msg) {
                if (typeof steal !== 'undefined' && typeof console !== 'undefined' && console.warn) {
                    steal.done().then(function () {
                        if (steal.dev && steal.dev.warn) {
                        } else if (console.warn) {
                            console.warn('steal.js WARNING: ' + msg);
                        } else {
                            console.log(msg);
                        }
                    });
                }
            },
            relativeURI: function (baseURL, url) {
                return typeof steal !== 'undefined' ? steal.relativeURI(baseURL, url) : url;
            },
            moduleName: {
                create: function (descriptor, standard) {
                    if (standard) {
                        return descriptor.moduleName;
                    } else {
                        if (descriptor === '@empty') {
                            return descriptor;
                        }
                        var modulePath;
                        if (descriptor.modulePath) {
                            modulePath = descriptor.modulePath.substr(0, 2) === './' ? descriptor.modulePath.substr(2) : descriptor.modulePath;
                        }
                        return descriptor.packageName + (descriptor.version ? '@' + descriptor.version : '') + (modulePath ? '#' + modulePath : '') + (descriptor.plugin ? descriptor.plugin : '');
                    }
                },
                isNpm: function (moduleName) {
                    return npmModuleRegEx.test(moduleName);
                },
                isConditional: function (moduleName) {
                    return conditionalModuleRegEx.test(moduleName);
                },
                isFullyConvertedNpm: function (parsedModuleName) {
                    return !!(parsedModuleName.packageName && parsedModuleName.version && parsedModuleName.modulePath);
                },
                isScoped: function (moduleName) {
                    return moduleName[0] === '@';
                },
                parse: function (moduleName, currentPackageName, global, context) {
                    var pluginParts = moduleName.split('!');
                    var modulePathParts = pluginParts[0].split('#');
                    var versionParts = modulePathParts[0].split('@');
                    if (!modulePathParts[1] && !versionParts[0]) {
                        versionParts = ['@' + versionParts[1]];
                    }
                    if (versionParts.length === 3 && utils.moduleName.isScoped(moduleName)) {
                        versionParts.splice(0, 1);
                        versionParts[0] = '@' + versionParts[0];
                    }
                    var packageName, modulePath;
                    if (currentPackageName && utils.path.isRelative(moduleName)) {
                        packageName = currentPackageName;
                        modulePath = versionParts[0];
                    } else if (currentPackageName && utils.path.isInHomeDir(moduleName, context)) {
                        packageName = currentPackageName;
                        modulePath = versionParts[0].split('/').slice(1).join('/');
                    } else {
                        if (modulePathParts[1]) {
                            packageName = versionParts[0];
                            modulePath = modulePathParts[1];
                        } else {
                            var folderParts = versionParts[0].split('/');
                            if (folderParts.length && folderParts[0][0] === '@') {
                                packageName = folderParts.splice(0, 2).join('/');
                            } else {
                                packageName = folderParts.shift();
                            }
                            modulePath = folderParts.join('/');
                        }
                    }
                    modulePath = utils.path.removeJS(modulePath);
                    return {
                        plugin: pluginParts.length === 2 ? '!' + pluginParts[1] : undefined,
                        version: versionParts[1],
                        modulePath: modulePath,
                        packageName: packageName,
                        moduleName: moduleName,
                        isGlobal: global
                    };
                },
                parseFromPackage: function (loader, refPkg, name, parentName) {
                    var packageName = utils.pkg.name(refPkg), parsedModuleName = utils.moduleName.parse(name, packageName, undefined, { loader: loader }), isRelative = utils.path.isRelative(parsedModuleName.modulePath);
                    if (isRelative && !parentName) {
                        throw new Error('Cannot resolve a relative module identifier ' + 'with no parent module:', name);
                    }
                    if (isRelative) {
                        var parentParsed = utils.moduleName.parse(parentName, packageName);
                        if (parentParsed.packageName === parsedModuleName.packageName && parentParsed.modulePath) {
                            var makePathRelative = true;
                            if (name === '../' || name === './' || name === '..') {
                                var relativePath = utils.path.relativeTo(parentParsed.modulePath, name);
                                var isInRoot = utils.path.isPackageRootDir(relativePath);
                                if (isInRoot) {
                                    parsedModuleName.modulePath = utils.pkg.main(refPkg);
                                    makePathRelative = false;
                                } else {
                                    parsedModuleName.modulePath = name + (utils.path.endsWithSlash(name) ? '' : '/') + 'index';
                                }
                            }
                            if (makePathRelative) {
                                parsedModuleName.modulePath = utils.path.makeRelative(utils.path.joinURIs(parentParsed.modulePath, parsedModuleName.modulePath));
                            }
                        }
                    }
                    var mapName = utils.moduleName.create(parsedModuleName), refSteal = utils.pkg.config(refPkg), mappedName;
                    if (refPkg.browser && typeof refPkg.browser !== 'string' && mapName in refPkg.browser && (!refSteal || !refSteal.ignoreBrowser)) {
                        mappedName = refPkg.browser[mapName] === false ? '@empty' : refPkg.browser[mapName];
                    }
                    var global = loader && loader.globalBrowser && loader.globalBrowser[mapName];
                    if (global) {
                        mappedName = global.moduleName === false ? '@empty' : global.moduleName;
                    }
                    if (mappedName) {
                        return utils.moduleName.parse(mappedName, packageName, !!global);
                    } else {
                        return parsedModuleName;
                    }
                },
                nameAndVersion: function (parsedModuleName) {
                    return parsedModuleName.packageName + '@' + parsedModuleName.version;
                }
            },
            pkg: {
                name: function (pkg) {
                    var steal = utils.pkg.config(pkg);
                    return steal && steal.name || pkg.name;
                },
                main: function (pkg) {
                    var main;
                    var steal = utils.pkg.config(pkg);
                    if (steal && steal.main) {
                        main = steal.main;
                    } else if (typeof pkg.browser === 'string') {
                        if (utils.path.endsWithSlash(pkg.browser)) {
                            main = pkg.browser + 'index';
                        } else {
                            main = pkg.browser;
                        }
                    } else if (typeof pkg.jam === 'object' && pkg.jam.main) {
                        main = pkg.jam.main;
                    } else if (pkg.main) {
                        main = pkg.main;
                    } else {
                        main = 'index';
                    }
                    return utils.path.removeJS(utils.path.removeDotSlash(main));
                },
                rootDir: function (pkg, isRoot) {
                    var root = isRoot ? utils.path.removePackage(pkg.fileUrl) : utils.path.pkgDir(pkg.fileUrl);
                    var lib = utils.pkg.directoriesLib(pkg);
                    if (lib) {
                        root = utils.path.joinURIs(utils.path.addEndingSlash(root), lib);
                    }
                    return root;
                },
                isRoot: function (loader, pkg) {
                    var root = utils.pkg.getDefault(loader);
                    return pkg.name === root.name && pkg.version === root.version;
                },
                homeAlias: function (context) {
                    return context && context.loader && context.loader.homeAlias || '~';
                },
                getDefault: function (loader) {
                    return loader.npmPaths.__default;
                },
                findByModuleNameOrAddress: function (loader, moduleName, moduleAddress) {
                    if (loader.npm) {
                        if (moduleName) {
                            var parsed = utils.moduleName.parse(moduleName);
                            if (parsed.version && parsed.packageName) {
                                var name = parsed.packageName + '@' + parsed.version;
                                if (name in loader.npm) {
                                    return loader.npm[name];
                                }
                            }
                        }
                        if (moduleAddress) {
                            var startingAddress = utils.relativeURI(loader.baseURL, moduleAddress);
                            var packageFolder = utils.pkg.folderAddress(startingAddress);
                            return packageFolder ? loader.npmPaths[packageFolder] : utils.pkg.getDefault(loader);
                        } else {
                            return utils.pkg.getDefault(loader);
                        }
                    }
                },
                folderAddress: function (address) {
                    var nodeModules = '/node_modules/', nodeModulesIndex = address.lastIndexOf(nodeModules), nextSlash = address.indexOf('/', nodeModulesIndex + nodeModules.length);
                    if (nodeModulesIndex >= 0) {
                        return nextSlash >= 0 ? address.substr(0, nextSlash) : address;
                    }
                },
                findDep: function (loader, refPkg, name) {
                    if (loader.npm && refPkg && !utils.path.startsWithDotSlash(name)) {
                        var nameAndVersion = name + '@' + refPkg.resolutions[name];
                        var pkg = loader.npm[nameAndVersion];
                        return pkg;
                    }
                },
                findDepWalking: function (loader, refPackage, name) {
                    if (loader.npm && refPackage && !utils.path.startsWithDotSlash(name)) {
                        var curPackage = utils.path.depPackageDir(refPackage.fileUrl, name);
                        while (curPackage) {
                            var pkg = loader.npmPaths[curPackage];
                            if (pkg) {
                                return pkg;
                            }
                            var parentAddress = utils.path.parentNodeModuleAddress(curPackage);
                            if (!parentAddress) {
                                return;
                            }
                            curPackage = parentAddress + '/' + name;
                        }
                    }
                },
                findByName: function (loader, name) {
                    if (loader.npm && !utils.path.startsWithDotSlash(name)) {
                        return loader.npm[name];
                    }
                },
                findByNameAndVersion: function (loader, name, version) {
                    if (loader.npm && !utils.path.startsWithDotSlash(name)) {
                        var nameAndVersion = name + '@' + version;
                        return loader.npm[nameAndVersion];
                    }
                },
                findByUrl: function (loader, url) {
                    if (loader.npm) {
                        var fullUrl = utils.pkg.folderAddress(url);
                        return loader.npmPaths[fullUrl];
                    }
                },
                directoriesLib: function (pkg) {
                    var steal = utils.pkg.config(pkg);
                    var lib = steal && steal.directories && steal.directories.lib;
                    var ignores = [
                            '.',
                            '/'
                        ], ignore;
                    if (!lib)
                        return undefined;
                    while (!!(ignore = ignores.shift())) {
                        if (lib[0] === ignore) {
                            lib = lib.substr(1);
                        }
                    }
                    return lib;
                },
                hasDirectoriesLib: function (pkg) {
                    var steal = utils.pkg.config(pkg);
                    return steal && steal.directories && !!steal.directories.lib;
                },
                findPackageInfo: function (context, pkg) {
                    var pkgInfo = context.pkgInfo;
                    if (pkgInfo) {
                        var out;
                        utils.forEach(pkgInfo, function (p) {
                            if (pkg.name === p.name && pkg.version === p.version) {
                                out = p;
                            }
                        });
                        return out;
                    }
                },
                saveResolution: function (context, refPkg, pkg) {
                    var npmPkg = utils.pkg.findPackageInfo(context, refPkg);
                    npmPkg.resolutions[pkg.name] = refPkg.resolutions[pkg.name] = pkg.version;
                },
                config: function (pkg) {
                    return pkg.steal || pkg.system;
                }
            },
            path: {
                makeRelative: function (path) {
                    if (utils.path.isRelative(path) && path.substr(0, 1) !== '/') {
                        return path;
                    } else {
                        return './' + path;
                    }
                },
                removeJS: function (path) {
                    return path.replace(/\.js(!|$)/, function (whole, part) {
                        return part;
                    });
                },
                removePackage: function (path) {
                    return path.replace(/\/package\.json.*/, '');
                },
                addJS: function (path) {
                    if (/\.js(on)?$/.test(path)) {
                        return path;
                    } else {
                        return path + '.js';
                    }
                },
                isRelative: function (path) {
                    return path.substr(0, 1) === '.';
                },
                isInHomeDir: function (path, context) {
                    return path.substr(0, 2) === utils.pkg.homeAlias(context) + '/';
                },
                joinURIs: function (baseUri, rel) {
                    function removeDotSegments(input) {
                        var output = [];
                        input.replace(/^(\.\.?(\/|$))+/, '').replace(/\/(\.(\/|$))+/g, '/').replace(/\/\.\.$/, '/../').replace(/\/?[^\/]*/g, function (p) {
                            if (p === '/..') {
                                output.pop();
                            } else {
                                output.push(p);
                            }
                        });
                        return output.join('').replace(/^\//, input.charAt(0) === '/' ? '/' : '');
                    }
                    var href = parseURI(rel || '');
                    var base = parseURI(baseUri || '');
                    return !href || !base ? null : (href.protocol || base.protocol) + (href.protocol || href.authority ? href.authority : base.authority) + removeDotSegments(href.protocol || href.authority || href.pathname.charAt(0) === '/' ? href.pathname : href.pathname ? (base.authority && !base.pathname ? '/' : '') + base.pathname.slice(0, base.pathname.lastIndexOf('/') + 1) + href.pathname : base.pathname) + (href.protocol || href.authority || href.pathname ? href.search : href.search || base.search) + href.hash;
                },
                startsWithDotSlash: function (path) {
                    return path.substr(0, 2) === './';
                },
                removeDotSlash: function (path) {
                    return utils.path.startsWithDotSlash(path) ? path.substr(2) : path;
                },
                endsWithSlash: function (path) {
                    return path[path.length - 1] === '/';
                },
                addEndingSlash: function (path) {
                    return utils.path.endsWithSlash(path) ? path : path + '/';
                },
                depPackage: function (parentPackageAddress, childName) {
                    var packageFolderName = parentPackageAddress.replace(/\/package\.json.*/, '');
                    return (packageFolderName ? packageFolderName + '/' : '') + 'node_modules/' + childName + '/package.json';
                },
                peerPackage: function (parentPackageAddress, childName) {
                    var packageFolderName = parentPackageAddress.replace(/\/package\.json.*/, '');
                    return packageFolderName.substr(0, packageFolderName.lastIndexOf('/')) + '/' + childName + '/package.json';
                },
                depPackageDir: function (parentPackageAddress, childName) {
                    return utils.path.depPackage(parentPackageAddress, childName).replace(/\/package\.json.*/, '');
                },
                peerNodeModuleAddress: function (address) {
                    var nodeModules = '/node_modules/', nodeModulesIndex = address.lastIndexOf(nodeModules);
                    if (nodeModulesIndex >= 0) {
                        return address.substr(0, nodeModulesIndex + nodeModules.length - 1);
                    }
                },
                parentNodeModuleAddress: function (address) {
                    var nodeModules = '/node_modules/', nodeModulesIndex = address.lastIndexOf(nodeModules), prevModulesIndex = address.lastIndexOf(nodeModules, nodeModulesIndex - 1);
                    if (prevModulesIndex >= 0) {
                        return address.substr(0, prevModulesIndex + nodeModules.length - 1);
                    }
                },
                pkgDir: function (address) {
                    var nodeModules = '/node_modules/', nodeModulesIndex = address.lastIndexOf(nodeModules), nextSlash = address.indexOf('/', nodeModulesIndex + nodeModules.length);
                    if (address[nodeModulesIndex + nodeModules.length] === '@') {
                        nextSlash = address.indexOf('/', nextSlash + 1);
                    }
                    if (nodeModulesIndex >= 0) {
                        return nextSlash >= 0 ? address.substr(0, nextSlash) : address;
                    }
                },
                basename: function (address) {
                    var parts = address.split('/');
                    return parts[parts.length - 1];
                },
                relativeTo: function (modulePath, rel) {
                    var parts = modulePath.split('/');
                    var idx = 1;
                    while (rel[idx] === '.') {
                        parts.pop();
                        idx++;
                    }
                    return parts.join('/');
                },
                isPackageRootDir: function (pth) {
                    return pth.indexOf('/') === -1;
                }
            },
            json: {
                transform: function (loader, load, data) {
                    data.steal = utils.pkg.config(data);
                    var fn = loader.jsonOptions && loader.jsonOptions.transform;
                    if (!fn)
                        return data;
                    return fn.call(loader, load, data);
                }
            },
            includeInBuild: true
        };
        function parseURI(url) {
            var m = String(url).replace(/^\s+|\s+$/g, '').match(/^([^:\/?#]+:)?(\/\/(?:[^:@]*(?::[^:@]*)?@)?(([^:\/?#]*)(?::(\d*))?))?([^?#]*)(\?[^#]*)?(#[\s\S]*)?/);
            return m ? {
                href: m[0] || '',
                protocol: m[1] || '',
                authority: m[2] || '',
                host: m[3] || '',
                hostname: m[4] || '',
                port: m[5] || '',
                pathname: m[6] || '',
                search: m[7] || '',
                hash: m[8] || ''
            } : null;
        }
        module.exports = utils;
    }(function () {
        return this;
    }()));
});
/*npm-extension*/
define('npm-extension', function (require, exports, module) {
    (function (global) {
        'format cjs';
        var steal = require('@steal');
        var utils = require('./npm-utils');
        exports.includeInBuild = true;
        var isNode = typeof process === 'object' && {}.toString.call(process) === '[object process]';
        var isWorker = typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope;
        var isBrowser = typeof window !== 'undefined' && !isNode && !isWorker;
        exports.addExtension = function (System) {
            if (System._extensions) {
                System._extensions.push(exports.addExtension);
            }
            var oldNormalize = System.normalize;
            System.normalize = function (identifier, parentModuleName, parentAddress, pluginNormalize) {
                var name = identifier;
                var parentName = parentModuleName;
                if (parentName && this.npmParentMap && this.npmParentMap[parentName]) {
                    parentName = this.npmParentMap[parentName];
                }
                var hasNoParent = !parentName;
                var nameIsRelative = utils.path.isRelative(name);
                var parentIsNpmModule = utils.moduleName.isNpm(parentName);
                var identifierEndsWithSlash = utils.path.endsWithSlash(name);
                if (parentName && nameIsRelative && !parentIsNpmModule) {
                    return oldNormalize.call(this, name, parentName, parentAddress, pluginNormalize);
                }
                if (utils.moduleName.isConditional(name)) {
                    return oldNormalize.call(this, name, parentName, parentAddress, pluginNormalize);
                }
                var hasContextualMap = typeof this.map[parentName] === 'object' && this.map[parentName][name];
                if (hasContextualMap) {
                    return oldNormalize.call(this, name, parentName, parentAddress, pluginNormalize);
                }
                var refPkg = utils.pkg.findByModuleNameOrAddress(this, parentName, parentAddress);
                if (!refPkg) {
                    return oldNormalize.call(this, name, parentName, parentAddress, pluginNormalize);
                }
                var isPointingAtParentFolder = name === '../' || name === './';
                if (parentIsNpmModule && isPointingAtParentFolder) {
                    var parsedParentModuleName = utils.moduleName.parse(parentName);
                    var parentModulePath = parsedParentModuleName.modulePath || '';
                    var relativePath = utils.path.relativeTo(parentModulePath, name);
                    var isInRoot = utils.path.isPackageRootDir(relativePath);
                    if (isInRoot) {
                        name = refPkg.name + '#' + utils.path.removeJS(refPkg.main);
                    } else {
                        name = name + 'index';
                    }
                }
                var parsedModuleName = utils.moduleName.parseFromPackage(this, refPkg, name, parentName);
                var isRoot = utils.pkg.isRoot(this, refPkg);
                var parsedPackageNameIsReferringPackage = parsedModuleName.packageName === refPkg.name;
                var isRelativeToParentNpmModule = parentIsNpmModule && nameIsRelative && parsedPackageNameIsReferringPackage;
                var depPkg, wantedPkg;
                if (isRelativeToParentNpmModule) {
                    depPkg = refPkg;
                }
                var context = this.npmContext;
                var crawl = context && context.crawl;
                var isDev = !!crawl;
                if (!depPkg) {
                    if (crawl) {
                        var parentPkg = nameIsRelative ? null : crawl.matchedVersion(context, refPkg.name, refPkg.version);
                        if (parentPkg) {
                            var depMap = crawl.getFullDependencyMap(this, parentPkg, isRoot);
                            wantedPkg = depMap[parsedModuleName.packageName];
                            if (wantedPkg) {
                                var wantedVersion = refPkg.resolutions && refPkg.resolutions[wantedPkg.name] || wantedPkg.version;
                                var foundPkg = crawl.matchedVersion(this.npmContext, wantedPkg.name, wantedVersion);
                                if (foundPkg) {
                                    depPkg = utils.pkg.findByUrl(this, foundPkg.fileUrl);
                                }
                            }
                        }
                    } else {
                        if (isRoot) {
                            depPkg = utils.pkg.findDepWalking(this, refPkg, parsedModuleName.packageName);
                        } else {
                            depPkg = utils.pkg.findDep(this, refPkg, parsedModuleName.packageName);
                        }
                    }
                }
                if (parsedPackageNameIsReferringPackage) {
                    depPkg = utils.pkg.findByNameAndVersion(this, parsedModuleName.packageName, refPkg.version);
                }
                var lookupByName = parsedModuleName.isGlobal || hasNoParent;
                if (!depPkg) {
                    depPkg = utils.pkg.findByName(this, parsedModuleName.packageName);
                }
                var isThePackageWeWant = !isDev || !depPkg || (wantedPkg ? crawl.pkgSatisfies(depPkg, wantedPkg.version) : true);
                if (!isThePackageWeWant) {
                    depPkg = undefined;
                } else if (isDev && depPkg) {
                    utils.pkg.saveResolution(context, refPkg, depPkg);
                }
                if (!depPkg) {
                    var browserPackageName = this.globalBrowser[parsedModuleName.packageName];
                    if (browserPackageName) {
                        parsedModuleName.packageName = browserPackageName.moduleName;
                        depPkg = utils.pkg.findByName(this, parsedModuleName.packageName);
                    }
                }
                if (!depPkg && isRoot && name === refPkg.main && utils.pkg.hasDirectoriesLib(refPkg)) {
                    parsedModuleName.version = refPkg.version;
                    parsedModuleName.packageName = refPkg.name;
                    parsedModuleName.modulePath = utils.pkg.main(refPkg);
                    return oldNormalize.call(this, utils.moduleName.create(parsedModuleName), parentName, parentAddress, pluginNormalize);
                }
                var loader = this;
                if (!depPkg) {
                    if (crawl) {
                        var parentPkg = crawl.matchedVersion(this.npmContext, refPkg.name, refPkg.version);
                        if (parentPkg) {
                            var depMap = crawl.getFullDependencyMap(this, parentPkg, isRoot);
                            depPkg = depMap[parsedModuleName.packageName];
                            if (!depPkg) {
                                var parents = crawl.findPackageAndParents(this.npmContext, parsedModuleName.packageName);
                                if (parents) {
                                    depPkg = parents.package;
                                }
                            }
                        }
                    }
                    if (!depPkg) {
                        if (refPkg.browser && refPkg.browser[name]) {
                            return oldNormalize.call(this, refPkg.browser[name], parentName, parentAddress, pluginNormalize);
                        }
                        return oldNormalize.call(this, name, parentName, parentAddress, pluginNormalize);
                    }
                    return crawl.dep(this.npmContext, parentPkg, refPkg, depPkg, isRoot).then(createModuleNameAndNormalize);
                } else {
                    return createModuleNameAndNormalize(depPkg);
                }
                function createModuleNameAndNormalize(depPkg) {
                    parsedModuleName.version = depPkg.version;
                    if (!parsedModuleName.modulePath) {
                        parsedModuleName.modulePath = utils.pkg.main(depPkg);
                    }
                    var moduleName = utils.moduleName.create(parsedModuleName);
                    var steal = utils.pkg.config(refPkg);
                    if (steal && steal.map && typeof steal.map[moduleName] === 'string') {
                        moduleName = steal.map[moduleName];
                    }
                    var p = oldNormalize.call(loader, moduleName, parentName, parentAddress, pluginNormalize);
                    if (identifierEndsWithSlash) {
                        p.then(function (name) {
                            if (context && context.forwardSlashMap) {
                                context.forwardSlashMap[name] = true;
                            }
                        });
                    }
                    return p;
                }
            };
            var oldLocate = System.locate;
            System.locate = function (load) {
                var parsedModuleName = utils.moduleName.parse(load.name), loader = this;
                if (parsedModuleName.version && this.npm && !loader.paths[load.name]) {
                    var pkg = this.npm[utils.moduleName.nameAndVersion(parsedModuleName)];
                    if (pkg) {
                        return oldLocate.call(this, load).then(function (locatedAddress) {
                            var address = locatedAddress;
                            var expectedAddress = utils.path.joinURIs(System.baseURL, load.name);
                            if (isBrowser) {
                                expectedAddress = expectedAddress.replace(/#/g, '%23');
                            }
                            if (address !== expectedAddress + '.js' && address !== expectedAddress) {
                                return address;
                            }
                            var root = utils.pkg.rootDir(pkg, utils.pkg.isRoot(loader, pkg));
                            if (parsedModuleName.modulePath) {
                                var npmAddress = utils.path.joinURIs(utils.path.addEndingSlash(root), parsedModuleName.plugin ? parsedModuleName.modulePath : utils.path.addJS(parsedModuleName.modulePath));
                                address = typeof steal !== 'undefined' ? utils.path.joinURIs(loader.baseURL, npmAddress) : npmAddress;
                            }
                            return address;
                        });
                    }
                }
                return oldLocate.call(this, load);
            };
            var oldFetch = System.fetch;
            System.fetch = function (load) {
                if (load.metadata.dryRun) {
                    return oldFetch.apply(this, arguments);
                }
                var loader = this;
                var context = loader.npmContext;
                var fetchPromise = Promise.resolve(oldFetch.apply(this, arguments));
                if (utils.moduleName.isNpm(load.name)) {
                    fetchPromise = fetchPromise.then(null, function (err) {
                        if (err.statusCode !== 404) {
                            return Promise.reject(err);
                        }
                        var types = [].slice.call(retryTypes);
                        return retryAll(types, err);
                        function retryAll(types, err) {
                            if (!types.length) {
                                throw err;
                            }
                            var type = types.shift();
                            if (!type.test(load)) {
                                throw err;
                            }
                            return Promise.resolve(retryFetch.call(loader, load, type)).then(null, function (err) {
                                return retryAll(types, err);
                            });
                        }
                    });
                }
                return fetchPromise;
            };
            var convertName = function (loader, name) {
                var pkg = utils.pkg.findByName(loader, name.split('/')[0]);
                if (pkg) {
                    var parsed = utils.moduleName.parse(name, pkg.name);
                    parsed.version = pkg.version;
                    if (!parsed.modulePath) {
                        parsed.modulePath = utils.pkg.main(pkg);
                    }
                    return utils.moduleName.create(parsed);
                }
                return name;
            };
            var configSpecial = {
                map: function (map) {
                    var newMap = {}, val;
                    for (var name in map) {
                        val = map[name];
                        newMap[convertName(this, name)] = typeof val === 'object' ? configSpecial.map(val) : convertName(this, val);
                    }
                    return newMap;
                },
                meta: function (map) {
                    var newMap = {};
                    for (var name in map) {
                        newMap[convertName(this, name)] = map[name];
                    }
                    return newMap;
                },
                paths: function (paths) {
                    var newPaths = {};
                    for (var name in paths) {
                        newPaths[convertName(this, name)] = paths[name];
                    }
                    return newPaths;
                }
            };
            var oldConfig = System.config;
            System.config = function (cfg) {
                var loader = this;
                if (loader.npmContext) {
                    var context = loader.npmContext;
                    var pkg = context.versions.__default;
                    context.convert.steal(context, pkg, cfg, true, false, false);
                    oldConfig.apply(loader, arguments);
                    return;
                }
                for (var name in cfg) {
                    if (configSpecial[name]) {
                        cfg[name] = configSpecial[name].call(loader, cfg[name]);
                    }
                }
                oldConfig.apply(loader, arguments);
            };
            steal.addNpmPackages = function (npmPackages) {
                var packages = npmPackages || [];
                var loader = this.loader;
                for (var i = 0; i < packages.length; i += 1) {
                    var pkg = packages[i];
                    var path = pkg && pkg.fileUrl;
                    if (path) {
                        loader.npmContext.paths[path] = pkg;
                    }
                }
            };
            steal.getNpmPackages = function () {
                var context = this.loader.npmContext;
                return context ? context.packages || [] : [];
            };
            function retryFetch(load, type) {
                var loader = this;
                var moduleName = typeof type.name === 'function' ? type.name(loader, load) : load.name + type.name;
                var local = utils.extend({}, load);
                local.name = moduleName;
                local.metadata = { dryRun: true };
                return Promise.resolve(loader.locate(local)).then(function (address) {
                    local.address = address;
                    return loader.fetch(local);
                }).then(function (source) {
                    load.metadata.address = local.address;
                    loader.npmParentMap[load.name] = local.name;
                    var npmLoad = loader.npmContext && loader.npmContext.npmLoad;
                    if (npmLoad) {
                        npmLoad.saveLoadIfNeeded(loader.npmContext);
                        if (!isNode) {
                            utils.warnOnce('Some 404s were encountered ' + 'while loading. Don\'t panic! ' + 'These will only happen in dev ' + 'and are harmless.');
                        }
                    }
                    return source;
                });
            }
            var retryTypes = [
                {
                    name: function (loader, load) {
                        var context = loader.npmContext;
                        if (context.forwardSlashMap[load.name]) {
                            var parts = load.name.split('/');
                            parts.pop();
                            return parts.concat(['index']).join('/');
                        }
                        return load.name + '/index';
                    },
                    test: function () {
                        return true;
                    }
                },
                {
                    name: '.json',
                    test: function (load) {
                        return utils.moduleName.isNpm(load.name) && utils.path.basename(load.address) === 'package.js';
                    }
                }
            ];
        };
    }(function () {
        return this;
    }()));
});
/*npm-load*/
define('npm-load', [], function(){ return {}; });
/*semver*/
define('semver', [], function(){ return {}; });
/*npm-crawl*/
define('npm-crawl', [], function(){ return {}; });
/*npm-convert*/
define('npm-convert', [], function(){ return {}; });
/*npm*/
define('npm', [], function(){ return {}; });
/*package.json!npm*/
define('package.json!npm', [
    '@loader',
    'npm-extension',
    'module'
], function (loader, npmExtension, module) {
    npmExtension.addExtension(loader);
    if (!loader.main) {
        loader.main = 'can@3.9.0-pre.0#can';
    }
    loader._npmExtensions = [].slice.call(arguments, 2);
    (function (loader, packages, options) {
        var g = loader.global;
        if (!g.process) {
            g.process = {
                argv: [],
                cwd: function () {
                    var baseURL = loader.baseURL;
                    return baseURL;
                },
                browser: true,
                env: { NODE_ENV: loader.env },
                version: '',
                platform: navigator && navigator.userAgent && /Windows/.test(navigator.userAgent) ? 'win' : ''
            };
        }
        if (!loader.npm) {
            loader.npm = {};
            loader.npmPaths = {};
            loader.globalBrowser = {};
        }
        if (!loader.npmParentMap) {
            loader.npmParentMap = options.npmParentMap || {};
        }
        var rootPkg = loader.npmPaths.__default = packages[0];
        var rootConfig = rootPkg.steal || rootPkg.system;
        var lib = rootConfig && rootConfig.directories && rootConfig.directories.lib;
        var setGlobalBrowser = function (globals, pkg) {
            for (var name in globals) {
                loader.globalBrowser[name] = {
                    pkg: pkg,
                    moduleName: globals[name]
                };
            }
        };
        var setInNpm = function (name, pkg) {
            if (!loader.npm[name]) {
                loader.npm[name] = pkg;
            }
            loader.npm[name + '@' + pkg.version] = pkg;
        };
        var forEach = function (arr, fn) {
            var i = 0, len = arr.length;
            for (; i < len; i++) {
                res = fn.call(arr, arr[i], i);
                if (res === false)
                    break;
            }
        };
        var setupLiveReload = function () {
            if (loader.liveReloadInstalled) {
                loader['import']('live-reload', { name: module.id }).then(function (reload) {
                    reload.dispose(function () {
                        var pkgInfo = loader.npmContext.pkgInfo;
                        delete pkgInfo[rootPkg.name + '@' + rootPkg.version];
                        var idx = -1;
                        forEach(pkgInfo, function (pkg, i) {
                            if (pkg.name === rootPkg.name && pkg.version === rootPkg.version) {
                                idx = i;
                                return false;
                            }
                        });
                        pkgInfo.splice(idx, 1);
                    });
                });
            }
        };
        var ignoredConfig = [
            'bundle',
            'configDependencies',
            'transpiler'
        ];
        packages.reverse();
        forEach(packages, function (pkg) {
            var steal = pkg.steal || pkg.system;
            if (steal) {
                var main = steal.main;
                delete steal.main;
                var configDeps = steal.configDependencies;
                if (pkg !== rootPkg) {
                    forEach(ignoredConfig, function (name) {
                        delete steal[name];
                    });
                }
                loader.config(steal);
                if (pkg === rootPkg) {
                    steal.configDependencies = configDeps;
                }
                steal.main = main;
            }
            if (pkg.globalBrowser) {
                var doNotApplyGlobalBrowser = pkg.name === 'steal' && rootConfig.builtins === false;
                if (!doNotApplyGlobalBrowser) {
                    setGlobalBrowser(pkg.globalBrowser, pkg);
                }
            }
            var systemName = steal && steal.name;
            if (systemName) {
                setInNpm(systemName, pkg);
            } else {
                setInNpm(pkg.name, pkg);
            }
            if (!loader.npm[pkg.name]) {
                loader.npm[pkg.name] = pkg;
            }
            loader.npm[pkg.name + '@' + pkg.version] = pkg;
            var pkgAddress = pkg.fileUrl.replace(/\/package\.json.*/, '');
            loader.npmPaths[pkgAddress] = pkg;
        });
        setupLiveReload();
        forEach(loader._npmExtensions || [], function (ext) {
            if (ext.systemConfig) {
                loader.config(ext.systemConfig);
            }
        });
    }(loader, [
        {
            'name': 'can',
            'version': '3.9.0-pre.0',
            'fileUrl': './package.json',
            'main': 'can.js',
            'steal': {
                'npmAlgorithm': 'flat',
                'main': 'can',
                'npmIgnore': {
                    'bit-docs': true,
                    'testee': true,
                    'async': true,
                    'saucelabs': true,
                    'test-saucelabs': true,
                    'wd': true,
                    'http-server': true
                },
                'meta': { 'socket.io-client/dist/socket.io': { 'format': 'cjs' } }
            },
            'resolutions': {
                'can': '3.9.0-pre.0',
                'can-construct-super': '3.1.0',
                'can-set': '1.3.0',
                'can-stache-converters': '3.2.0',
                'can-define': '1.3.2',
                'can-deparam': '1.0.1',
                'can-param': '1.0.1',
                'can-view-model': '3.4.0',
                'can-view-target': '3.1.0',
                'can-symbol': '1.0.0',
                'can-simple-dom': '1.0.10',
                'can-map-define': '3.1.1',
                'can-reflect': '1.2.3',
                'can-view-href': '3.1.0',
                'can-map-backup': '3.1.0',
                'can-validate-legacy': '1.1.0',
                'can-fixture': '1.1.0',
                'can-connect-signalr': '0.2.0',
                'can-connect-cloneable': '0.2.0',
                'can-stream': '0.3.1',
                'can-stream-kefir': '0.3.1',
                'can-ndjson-stream': '0.1.4',
                'can-connect-ndjson': '0.1.1',
                'can-define-stream': '0.2.1',
                'can-define-stream-kefir': '0.1.0',
                'react-view-model': '0.5.6',
                'can-react-component': '0.1.6',
                'can-component': '3.3.0',
                'can-compute': '3.3.1',
                'can-construct': '3.2.0',
                'can-util': '3.9.6',
                'can-stache': '3.2.0',
                'can-stache-bindings': '3.4.4',
                'can-event': '3.5.0',
                'can-view-import': '3.1.0',
                'can-view-live': '3.2.0',
                'can-view-nodelist': '3.1.0',
                'can-view-parser': '3.4.0',
                'can-view-scope': '3.3.0',
                'can-view-autorender': '3.1.0',
                'can-control': '3.2.0',
                'can-list': '3.2.0',
                'can-map': '3.3.1',
                'can-ejs': '3.1.2',
                'funcunit': '3.4.2',
                'steal-qunit': '1.0.1'
            }
        },
        {
            'name': 'can-construct-super',
            'version': '3.1.0',
            'fileUrl': './node_modules/can-construct-super/package.json',
            'main': 'can-construct-super',
            'steal': {
                'npmIgnore': {
                    'documentjs': true,
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-construct-super'
            },
            'resolutions': {
                'can-construct-super': '3.1.0',
                'steal-qunit': '1.0.1',
                'can-util': '3.9.6',
                'can-construct': '3.2.0'
            }
        },
        {
            'name': 'can-set',
            'version': '1.3.0',
            'fileUrl': './node_modules/can-set/package.json',
            'main': 'src/set.js',
            'steal': { 'plugins': ['steal-qunit'] },
            'resolutions': {
                'can-set': '1.3.0',
                'steal-qunit': '1.0.1',
                'can-util': '3.9.6',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-stache-converters',
            'version': '3.2.0',
            'fileUrl': './node_modules/can-stache-converters/package.json',
            'main': 'can-stache-converters',
            'steal': { 'main': 'can-stache-converters' },
            'resolutions': {
                'can-stache-converters': '3.2.0',
                'can-define': '1.3.2',
                'can-stache': '3.2.0',
                'can-util': '3.9.6',
                'can-compute': '3.3.1',
                'can-event': '3.5.0',
                'steal-qunit': '1.0.1',
                'can-stache-bindings': '3.4.4'
            }
        },
        {
            'name': 'can-define',
            'version': '1.3.2',
            'fileUrl': './node_modules/can-define/package.json',
            'main': 'can-define.js',
            'resolutions': {
                'can-define': '1.3.2',
                'can-util': '3.9.6',
                'can-types': '1.1.0',
                'steal-qunit': '1.0.1',
                'can-construct': '3.2.0',
                'can-event': '3.5.0',
                'can-reflect': '1.2.3',
                'can-symbol': '1.0.0',
                'can-compute': '3.3.1',
                'can-observation': '3.3.1',
                'can-namespace': '1.0.0',
                'can-cid': '1.0.3'
            }
        },
        {
            'name': 'can-deparam',
            'version': '1.0.1',
            'fileUrl': './node_modules/can-deparam/package.json',
            'main': 'dist/cjs/can-deparam',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-deparam'
            },
            'resolutions': {
                'can-deparam': '1.0.1',
                'steal-qunit': '1.0.1',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-param',
            'version': '1.0.1',
            'fileUrl': './node_modules/can-param/package.json',
            'main': 'dist/cjs/can-param',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-param'
            },
            'resolutions': {
                'can-param': '1.0.1',
                'steal-qunit': '1.0.1',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-view-model',
            'version': '3.4.0',
            'fileUrl': './node_modules/can-view-model/package.json',
            'main': 'can-view-model',
            'resolutions': {
                'can-view-model': '3.4.0',
                'can-define': '1.3.2',
                'can-types': '1.1.0',
                'can-map': '3.3.1',
                'can-simple-map': '3.3.0',
                'steal-qunit': '1.0.1',
                'can-util': '3.9.6',
                'can-reflect': '1.2.3',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-view-target',
            'version': '3.1.0',
            'fileUrl': './node_modules/can-view-target/package.json',
            'main': 'can-view-target',
            'resolutions': {
                'can-view-target': '3.1.0',
                'can-simple-dom': '1.0.10',
                'can-util': '3.9.6',
                'steal-qunit': '1.0.1',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-symbol',
            'version': '1.0.0',
            'fileUrl': './node_modules/can-symbol/package.json',
            'main': 'can-symbol',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-symbol'
            },
            'resolutions': {
                'can-symbol': '1.0.0',
                'steal-qunit': '1.0.1',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-simple-dom',
            'version': '1.0.10',
            'fileUrl': './node_modules/can-simple-dom/package.json',
            'main': 'dist/cjs/simple-dom.js',
            'steal': {
                'directories': { 'lib': 'lib' },
                'npmIgnore': { 'testee': true },
                'main': 'simple-dom.js'
            },
            'resolutions': {
                'can-simple-dom': '1.0.10',
                'steal-qunit': '1.0.1',
                'he': '1.1.1',
                'simple-html-tokenizer': '0.2.6',
                'micro-location': '0.1.5'
            }
        },
        {
            'name': 'can-map-define',
            'version': '3.1.1',
            'fileUrl': './node_modules/can-map-define/package.json',
            'main': 'can-map-define',
            'steal': { 'main': 'can-map-define' },
            'resolutions': {
                'can-map-define': '3.1.1',
                'can-compute': '3.3.1',
                'can-list': '3.2.0',
                'can-map': '3.3.1',
                'steal-qunit': '1.0.1',
                'can-util': '3.9.6',
                'can-event': '3.5.0'
            }
        },
        {
            'name': 'can-reflect',
            'version': '1.2.3',
            'fileUrl': './node_modules/can-reflect/package.json',
            'main': 'can-reflect',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-reflect'
            },
            'browser': {},
            'resolutions': {
                'can-reflect': '1.2.3',
                'can-symbol': '1.0.0',
                'steal-qunit': '1.0.1',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-view-href',
            'version': '3.1.0',
            'fileUrl': './node_modules/can-view-href/package.json',
            'main': 'can-view-href',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-view-href'
            },
            'resolutions': {
                'can-view-href': '3.1.0',
                'can-route': '3.2.0',
                'steal-qunit': '1.0.1',
                'can-stache': '3.2.0',
                'can-compute': '3.3.1',
                'can-util': '3.9.6',
                'can-view-callbacks': '3.2.0'
            }
        },
        {
            'name': 'can-map-backup',
            'version': '3.1.0',
            'fileUrl': './node_modules/can-map-backup/package.json',
            'main': 'can-map-backup',
            'steal': {
                'npmIgnore': {
                    'documentjs': true,
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-map-backup'
            },
            'resolutions': {
                'can-map-backup': '3.1.0',
                'can-map-define': '3.1.1',
                'can-compute': '3.3.1',
                'can-map': '3.3.1',
                'steal-qunit': '1.0.1',
                'can-set': '1.3.0',
                'can-util': '3.9.6'
            }
        },
        {
            'name': 'can-validate-legacy',
            'version': '1.1.0',
            'fileUrl': './node_modules/can-validate-legacy/package.json',
            'main': 'can-validate.js',
            'steal': {
                'ignoreBrowser': true,
                'npmDependencies': { 'steal-qunit': true },
                'npmIgnore': {
                    'documentjs': true,
                    'testee': true,
                    'steal-tools': true
                },
                'paths': { 'validate.js@0.11.1#validate': './node_modules/validate.js/validate.js' }
            },
            'browser': {
                'can-validate-legacy#can-validate': 'can-validate-legacy#dist/cjs/can-validate/can-validate',
                'can-validate-legacy#map/validate': 'can-validate-legacy#dist/cjs/can-validate/map/validate/validate',
                'can-validate-legacy#shims/validatejs.shim': 'can-validate-legacy#dist/cjs/can-validate/shims/validatejs.shim',
                'can-validate-legacy#validations': 'can-validate-legacy#dist/cjs/can-validate/validations'
            },
            'resolutions': {
                'can-map-define': '3.1.1',
                'can-validate-legacy': '1.1.0',
                'can-map': '3.3.1',
                'can-util': '3.9.6',
                'steal-qunit': '1.0.1',
                'jquery': '3.2.1',
                'can-compute': '3.3.1',
                'validate.js': '0.11.1'
            },
            'system': {
                'ignoreBrowser': true,
                'npmDependencies': { 'steal-qunit': true },
                'npmIgnore': {
                    'documentjs': true,
                    'testee': true,
                    'steal-tools': true
                },
                'paths': { 'validate.js@0.11.1#validate': './node_modules/validate.js/validate.js' }
            }
        },
        {
            'name': 'can-fixture',
            'version': '1.1.0',
            'fileUrl': './node_modules/can-fixture/package.json',
            'main': 'fixture.js',
            'resolutions': {
                'can-fixture': '1.1.0',
                'can-set': '1.3.0',
                'jquery': '3.2.1',
                'steal-qunit': '1.0.1',
                'can-util': '3.9.6',
                'can-namespace': '1.0.0',
                'can-connect': '1.5.3',
                'can-deparam': '1.0.1'
            }
        },
        {
            'name': 'can-connect-signalr',
            'version': '0.2.0',
            'fileUrl': './node_modules/can-connect-signalr/package.json',
            'main': 'can-connect-signalr',
            'steal': {},
            'resolutions': {
                'can-define': '1.3.2',
                'can-connect-signalr': '0.2.0',
                'jquery': '3.2.1',
                'can-connect': '1.5.3',
                'steal-qunit': '1.0.1',
                'ms-signalr-client': '2.2.7'
            }
        },
        {
            'name': 'can-connect-cloneable',
            'version': '0.2.0',
            'fileUrl': './node_modules/can-connect-cloneable/package.json',
            'main': 'can-connect-cloneable',
            'steal': { 'npmAlgorithm': 'flat' },
            'resolutions': {
                'can-connect-cloneable': '0.2.0',
                'can-define': '1.3.2',
                'can-map': '3.3.1',
                'can-map-define': '3.1.1',
                'can-list': '3.2.0',
                'can-fixture': '1.1.0',
                'steal-qunit': '1.0.1',
                'can-connect': '1.5.3',
                'can-util': '3.9.6'
            }
        },
        {
            'name': 'can-stream',
            'version': '0.3.1',
            'fileUrl': './node_modules/can-stream/package.json',
            'main': 'can-stream',
            'steal': {},
            'resolutions': {
                'can-define': '1.3.2',
                'can-stream': '0.3.1',
                'can-compute': '3.3.1',
                'steal-qunit': '1.0.1',
                'can-util': '3.9.6'
            }
        },
        {
            'name': 'can-stream-kefir',
            'version': '0.3.1',
            'fileUrl': './node_modules/can-stream-kefir/package.json',
            'main': 'can-stream-kefir',
            'steal': {},
            'resolutions': {
                'can-stream-kefir': '0.3.1',
                'can-define': '1.3.2',
                'can-compute': '3.3.1',
                'steal-qunit': '1.0.1',
                'can-stream': '0.3.1',
                'kefir': '3.7.2'
            }
        },
        {
            'name': 'can-ndjson-stream',
            'version': '0.1.4',
            'fileUrl': './node_modules/can-ndjson-stream/package.json',
            'main': 'can-ndjson-stream',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-ndjson-stream'
            },
            'resolutions': {
                'can-ndjson-stream': '0.1.4',
                'steal-qunit': '1.0.1',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-connect-ndjson',
            'version': '0.1.1',
            'fileUrl': './node_modules/can-connect-ndjson/package.json',
            'main': 'can-connect-ndjson',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-connect-ndjson'
            },
            'resolutions': {
                'can-connect-ndjson': '0.1.1',
                'can-define': '1.3.2',
                'can-connect': '1.5.3',
                'steal-qunit': '1.0.1',
                'can-ndjson-stream': '0.1.4',
                'can-reflect': '1.2.3',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-define-stream',
            'version': '0.2.1',
            'fileUrl': './node_modules/can-define-stream/package.json',
            'main': 'can-define-stream',
            'steal': {},
            'resolutions': {
                'can-define': '1.3.2',
                'can-define-stream': '0.2.1',
                'can-stream': '0.3.1',
                'steal-qunit': '1.0.1',
                'can-compute': '3.3.1',
                'can-util': '3.9.6'
            }
        },
        {
            'name': 'can-define-stream-kefir',
            'version': '0.1.0',
            'fileUrl': './node_modules/can-define-stream-kefir/package.json',
            'main': 'can-define-stream-kefir',
            'steal': { 'npmAlgorithm': 'flat' },
            'resolutions': {
                'can-define': '1.3.2',
                'can-define-stream-kefir': '0.1.0',
                'steal-qunit': '1.0.1',
                'can-util': '3.9.6',
                'can-define-stream': '0.2.1',
                'can-stream-kefir': '0.3.1'
            }
        },
        {
            'name': 'react-view-model',
            'version': '0.5.6',
            'fileUrl': './node_modules/react-view-model/package.json',
            'main': 'react-view-model',
            'resolutions': {
                'can-define': '1.3.2',
                'react-view-model': '0.5.6',
                'react': '15.6.1',
                'prop-types': '15.5.10',
                'react-dom': '15.6.1',
                'steal-qunit': '1.0.1',
                'can-util': '3.9.6',
                'can-namespace': '1.0.0',
                'can-observation': '3.3.1'
            }
        },
        {
            'name': 'can-react-component',
            'version': '0.1.6',
            'fileUrl': './node_modules/can-react-component/package.json',
            'main': 'can-react-component',
            'steal': {
                'npmIgnore': {
                    'babel-eslint': true,
                    'bit-docs': true,
                    'done-serve': true,
                    'eslint': true,
                    'eslint-plugin-react': true,
                    'testee': true
                },
                'main': 'can-react-component'
            },
            'resolutions': {
                'can-define': '1.3.2',
                'can-react-component': '0.1.6',
                'can-component': '3.3.0',
                'can-stache': '3.2.0',
                'react': '15.6.1',
                'react-dom': '15.6.1',
                'steal-qunit': '1.0.1',
                'can-view-scope': '3.3.0',
                'can-util': '3.9.6',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-component',
            'version': '3.3.0',
            'fileUrl': './node_modules/can-component/package.json',
            'main': 'can-component',
            'steal': {},
            'resolutions': {
                'can-component': '3.3.0',
                'can-stache': '3.2.0',
                'steal-qunit': '1.0.1',
                'can-define': '1.3.2',
                'can-view-model': '3.4.0',
                'can-types': '1.1.0',
                'can-construct': '3.2.0',
                'can-compute': '3.3.1',
                'can-map': '3.3.1',
                'can-list': '3.2.0',
                'can-event': '3.5.0',
                'can-util': '3.9.6',
                'can-view-scope': '3.3.0',
                'can-stache-bindings': '3.4.4',
                'can-view-nodelist': '3.1.0',
                'can-reflect': '1.2.3',
                'can-vdom': '3.1.0',
                'can-view-callbacks': '3.2.0',
                'can-namespace': '1.0.0',
                'can-control': '3.2.0',
                'can-stache-key': '0.0.2'
            }
        },
        {
            'name': 'can-compute',
            'version': '3.3.1',
            'fileUrl': './node_modules/can-compute/package.json',
            'main': 'can-compute',
            'resolutions': {
                'can-compute': '3.3.1',
                'steal-qunit': '1.0.1',
                'can-event': '3.5.0',
                'can-util': '3.9.6',
                'can-symbol': '1.0.0',
                'can-reflect': '1.2.3',
                'can-observation': '3.3.1',
                'can-cid': '1.0.3',
                'can-namespace': '1.0.0',
                'can-stache-key': '0.0.2'
            }
        },
        {
            'name': 'can-construct',
            'version': '3.2.0',
            'fileUrl': './node_modules/can-construct/package.json',
            'main': 'can-construct',
            'steal': {},
            'resolutions': {
                'can-construct': '3.2.0',
                'can-util': '3.9.6',
                'steal-qunit': '1.0.1',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'steal-qunit',
            'version': '1.0.1',
            'fileUrl': './node_modules/steal-qunit/package.json',
            'main': 'steal-qunit',
            'steal': {
                'meta': {
                    'qunitjs@1.23.1#qunit/qunit': {
                        'deps': ['steal-qunit/add-dom'],
                        'exports': 'QUnit',
                        'format': 'global'
                    }
                },
                'plugins': ['steal-css']
            },
            'resolutions': {
                'qunitjs': '1.23.1',
                'steal-css': '1.2.5'
            },
            'system': {
                'meta': {
                    'qunitjs@1.23.1#qunit/qunit': {
                        'deps': ['steal-qunit/add-dom'],
                        'exports': 'QUnit',
                        'format': 'global'
                    }
                },
                'plugins': ['steal-css']
            }
        },
        {
            'name': 'can-util',
            'version': '3.9.6',
            'fileUrl': './node_modules/can-util/package.json',
            'main': 'can-util',
            'resolutions': {
                'can-util': '3.9.6',
                'can-symbol': '1.0.0',
                'steal-qunit': '1.0.1',
                'can-types': '1.1.0',
                'can-vdom': '3.1.0',
                'can-namespace': '1.0.0',
                'can-cid': '1.0.3',
                'can-reflect': '1.2.3',
                'can-param': '1.0.1'
            }
        },
        {
            'name': 'can-types',
            'version': '1.1.0',
            'fileUrl': './node_modules/can-types/package.json',
            'main': 'can-types',
            'resolutions': {
                'can-reflect': '1.2.3',
                'can-symbol': '1.0.0',
                'can-util': '3.9.6',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-stache',
            'version': '3.2.0',
            'fileUrl': './node_modules/can-stache/package.json',
            'main': 'can-stache',
            'resolutions': {
                'can-stache': '3.2.0',
                'steal-qunit': '1.0.1',
                'can-map': '3.3.1',
                'can-list': '3.2.0',
                'can-compute': '3.3.1',
                'can-define': '1.3.2',
                'can-view-scope': '3.3.0',
                'can-view-parser': '3.4.0',
                'can-view-nodelist': '3.1.0',
                'can-event': '3.5.0',
                'can-util': '3.9.6',
                'can-view-target': '3.1.0',
                'can-vdom': '3.1.0',
                'can-view-callbacks': '3.2.0',
                'can-namespace': '1.0.0',
                'can-reflect': '1.2.3',
                'can-symbol': '1.0.0',
                'can-route': '3.2.0',
                'can-stache-key': '0.0.2',
                'can-view-live': '3.2.0',
                'can-observation': '3.3.1'
            }
        },
        {
            'name': 'can-stache-bindings',
            'version': '3.4.4',
            'fileUrl': './node_modules/can-stache-bindings/package.json',
            'main': 'can-stache-bindings',
            'steal': { 'main': 'can-stache-bindings' },
            'resolutions': {
                'can-stache-bindings': '3.4.4',
                'steal-qunit': '1.0.1',
                'can-list': '3.2.0',
                'can-map': '3.3.1',
                'can-stache': '3.2.0',
                'can-event': '3.5.0',
                'can-compute': '3.3.1',
                'can-view-model': '3.4.0',
                'can-symbol': '1.0.0',
                'can-reflect': '1.2.3',
                'can-util': '3.9.6',
                'can-types': '1.1.0',
                'can-view-callbacks': '3.2.0',
                'can-vdom': '3.1.0',
                'can-view-live': '3.2.0',
                'can-view-scope': '3.3.0',
                'can-observation': '3.3.1',
                'can-cid': '1.0.3',
                'can-define': '1.3.2',
                'can-view-nodelist': '3.1.0',
                'can-event-dom-enter': '1.0.1',
                'can-event-dom-radiochange': '1.0.0',
                'can-stache-key': '0.0.2'
            }
        },
        {
            'name': 'can-event',
            'version': '3.5.0',
            'fileUrl': './node_modules/can-event/package.json',
            'main': 'can-event',
            'steal': { 'npmAlgorithm': 'flat' },
            'resolutions': {
                'can-event': '3.5.0',
                'steal-qunit': '1.0.1',
                'can-util': '3.9.6',
                'can-cid': '1.0.3',
                'can-namespace': '1.0.0',
                'can-types': '1.1.0'
            }
        },
        {
            'name': 'can-view-import',
            'version': '3.1.0',
            'fileUrl': './node_modules/can-view-import/package.json',
            'main': 'can-view-import',
            'resolutions': {
                'can-map': '3.3.1',
                'can-component': '3.3.0',
                'can-stache': '3.2.0',
                'can-compute': '3.3.1',
                'steal-qunit': '1.0.1',
                'can-util': '3.9.6',
                'can-view-import': '3.1.0',
                'can-view-callbacks': '3.2.0',
                'can-view-nodelist': '3.1.0',
                'can-event': '3.5.0'
            }
        },
        {
            'name': 'can-view-live',
            'version': '3.2.0',
            'fileUrl': './node_modules/can-view-live/package.json',
            'main': 'can-view-live',
            'steal': {
                'npmIgnore': {
                    'documentjs': true,
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-view-live'
            },
            'resolutions': {
                'can-view-live': '3.2.0',
                'can-compute': '3.3.1',
                'can-map': '3.3.1',
                'can-list': '3.2.0',
                'can-view-nodelist': '3.1.0',
                'can-event': '3.5.0',
                'can-util': '3.9.6',
                'steal-qunit': '1.0.1',
                'can-observation': '3.3.1',
                'can-view-parser': '3.4.0',
                'can-reflect': '1.2.3',
                'can-view-callbacks': '3.2.0',
                'can-types': '1.1.0'
            }
        },
        {
            'name': 'can-view-nodelist',
            'version': '3.1.0',
            'fileUrl': './node_modules/can-view-nodelist/package.json',
            'main': 'can-view-nodelist',
            'resolutions': {
                'can-view-nodelist': '3.1.0',
                'can-util': '3.9.6',
                'steal-qunit': '1.0.1',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-view-parser',
            'version': '3.4.0',
            'fileUrl': './node_modules/can-view-parser/package.json',
            'main': 'can-view-parser',
            'resolutions': {
                'can-view-parser': '3.4.0',
                'steal-qunit': '1.0.1',
                'can-util': '3.9.6',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-view-scope',
            'version': '3.3.0',
            'fileUrl': './node_modules/can-view-scope/package.json',
            'main': 'can-view-scope',
            'resolutions': {
                'can-view-scope': '3.3.0',
                'can-define': '1.3.2',
                'can-compute': '3.3.1',
                'steal-qunit': '1.0.1',
                'can-map': '3.3.1',
                'can-list': '3.2.0',
                'can-symbol': '1.0.0',
                'can-event': '3.5.0',
                'can-reflect': '1.2.3',
                'can-observation': '3.3.1',
                'can-util': '3.9.6',
                'can-namespace': '1.0.0',
                'can-stache-key': '0.0.2',
                'can-simple-map': '3.3.0',
                'can-cid': '1.0.3'
            }
        },
        {
            'name': 'can-view-autorender',
            'version': '3.1.0',
            'fileUrl': './node_modules/can-view-autorender/package.json',
            'main': 'can-view-autorender',
            'steal': {},
            'resolutions': { 'steal-qunit': '1.0.1' }
        },
        {
            'name': 'can-control',
            'version': '3.2.0',
            'fileUrl': './node_modules/can-control/package.json',
            'main': 'can-control',
            'steal': {},
            'resolutions': {
                'can-control': '3.2.0',
                'steal-qunit': '1.0.1',
                'can-util': '3.9.6',
                'can-event': '3.5.0',
                'can-types': '1.1.0',
                'can-map': '3.3.1',
                'can-define': '1.3.2',
                'can-construct': '3.2.0',
                'can-compute': '3.3.1',
                'can-reflect': '1.2.3',
                'can-namespace': '1.0.0',
                'can-stache-key': '0.0.2'
            }
        },
        {
            'name': 'can-list',
            'version': '3.2.0',
            'fileUrl': './node_modules/can-list/package.json',
            'main': 'can-list',
            'steal': { 'npmAlgorithm': 'flat' },
            'resolutions': {
                'can-list': '3.2.0',
                'steal-qunit': '1.0.1',
                'can-map': '3.3.1',
                'can-reflect': '1.2.3',
                'can-symbol': '1.0.0',
                'can-event': '3.5.0',
                'can-util': '3.9.6',
                'can-types': '1.1.0',
                'can-observation': '3.3.1',
                'can-namespace': '1.0.0',
                'can-cid': '1.0.3'
            }
        },
        {
            'name': 'can-map',
            'version': '3.3.1',
            'fileUrl': './node_modules/can-map/package.json',
            'main': 'can-map',
            'steal': {},
            'resolutions': {
                'can-map': '3.3.1',
                'steal-qunit': '1.0.1',
                'can-construct': '3.2.0',
                'can-reflect': '1.2.3',
                'can-symbol': '1.0.0',
                'can-compute': '3.3.1',
                'can-event': '3.5.0',
                'can-util': '3.9.6',
                'can-types': '1.1.0',
                'can-cid': '1.0.3',
                'can-observation': '3.3.1',
                'can-stache-key': '0.0.2',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-route',
            'version': '3.2.0',
            'fileUrl': './node_modules/can-route/package.json',
            'main': 'can-route',
            'steal': {},
            'resolutions': {
                'can-event': '3.5.0',
                'can-compute': '3.3.1',
                'can-param': '1.0.1',
                'can-deparam': '1.0.1',
                'can-util': '3.9.6',
                'can-types': '1.1.0',
                'can-reflect': '1.2.3',
                'can-symbol': '1.0.0',
                'can-observation': '3.3.1',
                'can-namespace': '1.0.0',
                'can-route': '3.2.0'
            }
        },
        {
            'name': 'can-ejs',
            'version': '3.1.2',
            'fileUrl': './node_modules/can-ejs/package.json',
            'main': 'can-ejs',
            'steal': {
                'ext': { 'ejs': 'src/system' },
                'npmIgnore': {
                    'documentjs': true,
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-ejs'
            },
            'resolutions': {
                'steal-qunit': '1.0.1',
                'can-ejs': '3.1.2',
                'can-map': '3.3.1',
                'can-util': '3.9.6',
                'can-list': '3.2.0',
                'can-compute': '3.3.1',
                'can-legacy-view-helpers': '0.6.0',
                'can-namespace': '1.0.0',
                'can-reflect': '1.2.3',
                'can-stache-key': '0.0.3'
            }
        },
        {
            'name': 'jquery',
            'version': '3.2.1',
            'fileUrl': './node_modules/jquery/package.json',
            'main': 'dist/jquery.js',
            'resolutions': {}
        },
        {
            'name': 'can-connect',
            'version': '1.5.3',
            'fileUrl': './node_modules/can-connect/package.json',
            'main': 'can-connect.js',
            'steal': {
                'plugins': [
                    'steal-stache',
                    'steal-css'
                ]
            },
            'resolutions': {
                'can-connect': '1.5.3',
                'can-util': '3.9.6',
                'can-event': '3.5.0',
                'can-observation': '3.3.1',
                'can-types': '1.1.0',
                'can-reflect': '1.2.3',
                'can-set': '1.3.0',
                'can-namespace': '1.0.0',
                'can-make-rest': '0.1.1',
                'can-validate-interface': '0.1.0'
            }
        },
        {
            'name': 'react',
            'version': '15.6.1',
            'fileUrl': './node_modules/react/package.json',
            'main': 'react.js',
            'browser': { 'transform': ['loose-envify'] },
            'resolutions': {
                'react': '15.6.1',
                'object-assign': '4.1.0',
                'fbjs': '0.8.12',
                'prop-types': '15.5.10',
                'create-react-class': '15.6.0'
            }
        },
        {
            'name': 'prop-types',
            'version': '15.5.10',
            'fileUrl': './node_modules/prop-types/package.json',
            'main': 'index.js',
            'browser': { 'transform': ['loose-envify'] },
            'resolutions': {
                'prop-types': '15.5.10',
                'fbjs': '0.8.12'
            }
        },
        {
            'name': 'react-dom',
            'version': '15.6.1',
            'fileUrl': './node_modules/react-dom/package.json',
            'main': 'index.js',
            'browser': { 'transform': ['loose-envify'] },
            'resolutions': {
                'react-dom': '15.6.1',
                'react': '15.6.1',
                'object-assign': '4.1.0',
                'fbjs': '0.8.12'
            }
        },
        {
            'name': 'funcunit',
            'version': '3.4.2',
            'fileUrl': './node_modules/funcunit/package.json',
            'main': 'dist/cjs/funcunit.js',
            'steal': {
                'map': { 'chai': 'chai/chai' },
                'npmIgnore': {
                    'documentjs': true,
                    'steal': true,
                    'steal-tools': true,
                    'testee': true
                },
                'main': 'funcunit'
            },
            'resolutions': {
                'funcunit': '3.4.2',
                'syn': '0.10.0',
                'jquery': '1.11.0'
            }
        },
        {
            'name': 'steal-css',
            'version': '1.2.5',
            'fileUrl': './node_modules/steal-css/package.json',
            'main': 'css.js',
            'steal': {
                'ext': { 'css': 'steal-css' },
                'map': { '$css': 'steal-css@1.2.5#css' }
            },
            'resolutions': {}
        },
        {
            'name': 'can-simple-map',
            'version': '3.3.0',
            'fileUrl': './node_modules/can-simple-map/package.json',
            'main': 'can-simple-map',
            'steal': {
                'npmIgnore': {
                    'documentjs': true,
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-simple-map'
            },
            'resolutions': {
                'can-construct': '3.2.0',
                'can-event': '3.5.0',
                'can-util': '3.9.6',
                'can-types': '1.1.0',
                'can-observation': '3.3.1',
                'can-reflect': '1.2.3'
            }
        },
        {
            'name': 'steal-stache',
            'version': '3.1.0',
            'fileUrl': './node_modules/steal-stache/package.json',
            'main': 'steal-stache.js',
            'steal': {
                'ext': { 'stache': 'steal-stache' },
                'npmAlgorithm': 'flat',
                'npmIgnore': {
                    'documentjs': true,
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'steal-stache'
            },
            'resolutions': {}
        },
        {
            'name': 'can-observation',
            'version': '3.3.1',
            'fileUrl': './node_modules/can-observation/package.json',
            'main': 'can-observation',
            'steal': { 'npmAlgorithm': 'flat' },
            'resolutions': {
                'can-event': '3.5.0',
                'can-util': '3.9.6',
                'can-namespace': '1.0.0',
                'can-reflect': '1.2.3',
                'can-symbol': '1.0.0',
                'can-cid': '1.0.3'
            }
        },
        {
            'name': 'can-view-callbacks',
            'version': '3.2.0',
            'fileUrl': './node_modules/can-view-callbacks/package.json',
            'main': 'can-view-callbacks',
            'steal': {},
            'resolutions': {
                'can-observation': '3.3.1',
                'can-util': '3.9.6',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-vdom',
            'version': '3.1.0',
            'fileUrl': './node_modules/can-vdom/package.json',
            'main': 'can-vdom.js',
            'steal': {
                'map': { 'can-vdom@3.1.0#assert': 'chai/chai' },
                'meta': {
                    'chai/chai': {
                        'exports': 'chai.assert',
                        'format': 'global'
                    }
                },
                'plugins': ['chai'],
                'main': 'can-vdom'
            },
            'resolutions': {
                'can-simple-dom': '1.0.10',
                'can-vdom': '3.1.0',
                'can-view-parser': '3.4.0'
            }
        },
        {
            'name': 'can-legacy-view-helpers',
            'version': '0.6.0',
            'fileUrl': './node_modules/can-legacy-view-helpers/package.json',
            'main': 'can-legacy-view-helpers',
            'steal': {
                'npmIgnore': {
                    'documentjs': true,
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-legacy-view-helpers'
            },
            'resolutions': {
                'can-legacy-view-helpers': '0.6.0',
                'can-util': '3.9.6',
                'can-compute': '3.3.1',
                'can-view-callbacks': '3.2.0',
                'can-view-parser': '3.4.0',
                'can-event': '3.5.0',
                'can-cid': '1.0.3'
            }
        },
        {
            'name': 'qunitjs',
            'version': '1.23.1',
            'fileUrl': './node_modules/qunitjs/package.json',
            'main': 'qunit/qunit.js',
            'resolutions': { 'steal-qunit': '1.0.1' }
        },
        {
            'name': 'he',
            'version': '1.1.1',
            'fileUrl': './node_modules/he/package.json',
            'main': 'he.js',
            'resolutions': {}
        },
        {
            'name': 'simple-html-tokenizer',
            'version': '0.2.6',
            'fileUrl': './node_modules/simple-html-tokenizer/package.json',
            'main': 'dist/simple-html-tokenizer.js',
            'resolutions': { 'simple-html-tokenizer': '0.2.6' }
        },
        {
            'name': 'can-namespace',
            'version': '1.0.0',
            'fileUrl': './node_modules/can-namespace/package.json',
            'main': 'can-namespace',
            'steal': { 'npmAlgorithm': 'flat' },
            'resolutions': {}
        },
        {
            'name': 'can-cid',
            'version': '1.0.3',
            'fileUrl': './node_modules/can-cid/package.json',
            'main': 'can-cid',
            'resolutions': { 'can-namespace': '1.0.0' }
        },
        {
            'name': 'validate.js',
            'version': '0.11.1',
            'fileUrl': './node_modules/validate.js/package.json',
            'main': 'validate.js',
            'resolutions': {}
        },
        {
            'name': 'kefir',
            'version': '3.7.2',
            'fileUrl': './node_modules/kefir/package.json',
            'main': 'dist/kefir.js',
            'resolutions': {}
        },
        {
            'name': 'syn',
            'version': '0.10.0',
            'fileUrl': './node_modules/syn/package.json',
            'main': 'dist/cjs/syn.js',
            'steal': {
                'directories': { 'lib': 'src' },
                'ignoreBrowser': true,
                'map': {},
                'main': 'syn'
            },
            'resolutions': { 'syn': '0.10.0' }
        },
        {
            'name': 'can-stache-key',
            'version': '0.0.2',
            'fileUrl': './node_modules/can-view-scope/node_modules/can-stache-key/package.json',
            'main': 'dist/cjs/can-stache-key',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'plugins': [
                    'steal-less',
                    'steal-stache'
                ],
                'main': 'can-stache-key'
            },
            'browser': {},
            'resolutions': {
                'can-observation': '3.3.1',
                'can-util': '3.9.6',
                'can-symbol': '1.0.0',
                'can-reflect': '1.2.3',
                'can-reflect-promise': '1.1.0'
            }
        },
        {
            'name': 'can-stache-key',
            'version': '0.0.3',
            'fileUrl': './node_modules/can-stache-key/package.json',
            'main': 'dist/cjs/can-stache-key',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'plugins': [
                    'steal-less',
                    'steal-stache'
                ],
                'main': 'can-stache-key'
            },
            'browser': {},
            'resolutions': {
                'can-observation': '3.3.1',
                'can-util': '3.9.6',
                'can-symbol': '1.0.0',
                'can-reflect': '1.2.3',
                'can-reflect-promise': '1.1.0'
            }
        },
        {
            'name': 'ms-signalr-client',
            'version': '2.2.7',
            'fileUrl': './node_modules/ms-signalr-client/package.json',
            'main': 'jquery.signalR.js',
            'jspm': {},
            'resolutions': {}
        },
        {
            'name': 'can-make-rest',
            'version': '0.1.1',
            'fileUrl': './node_modules/can-make-rest/package.json',
            'main': 'dist/cjs/can-make-rest',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'plugins': [
                    'steal-less',
                    'steal-stache'
                ],
                'main': 'can-make-rest'
            },
            'browser': {},
            'resolutions': { 'can-util': '3.9.6' }
        },
        {
            'name': 'micro-location',
            'version': '0.1.5',
            'fileUrl': './node_modules/micro-location/package.json',
            'main': 'lib/micro-location.js',
            'resolutions': {}
        },
        {
            'name': 'object-assign',
            'version': '4.1.0',
            'fileUrl': './node_modules/object-assign/package.json',
            'resolutions': {}
        },
        {
            'name': 'fbjs',
            'version': '0.8.12',
            'fileUrl': './node_modules/fbjs/package.json',
            'main': 'index.js',
            'browser': { 'transform': ['loose-envify'] },
            'resolutions': { 'fbjs': '0.8.12' }
        },
        {
            'name': 'can-event-dom-enter',
            'version': '1.0.1',
            'fileUrl': './node_modules/can-event-dom-enter/package.json',
            'main': 'can-event-dom-enter',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'steal-tools': true
                },
                'main': 'can-event-dom-enter'
            },
            'resolutions': {
                'can-event-dom-enter': '1.0.1',
                'can-dom-events': '1.0.3',
                'can-util': '3.9.6'
            }
        },
        {
            'name': 'can-event-dom-radiochange',
            'version': '1.0.0',
            'fileUrl': './node_modules/can-event-dom-radiochange/package.json',
            'main': 'can-event-dom-radiochange',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'steal-tools': true
                },
                'main': 'can-event-dom-radiochange'
            },
            'resolutions': {
                'can-event-dom-radiochange': '1.0.0',
                'can-dom-events': '1.0.3',
                'can-util': '3.9.6'
            }
        },
        {
            'name': 'can-validate-interface',
            'version': '0.1.0',
            'fileUrl': './node_modules/can-validate-interface/package.json',
            'main': 'index.js',
            'resolutions': {}
        },
        {
            'name': 'can-reflect-promise',
            'version': '1.1.0',
            'fileUrl': './node_modules/can-reflect-promise/package.json',
            'main': 'can-reflect-promise',
            'steal': { 'npmAlgorithm': 'flat' },
            'resolutions': {
                'can-reflect': '1.2.3',
                'can-symbol': '1.0.0',
                'can-util': '3.9.6',
                'can-observation': '3.3.1',
                'can-cid': '1.0.3',
                'can-event': '3.5.0'
            }
        },
        {
            'name': 'create-react-class',
            'version': '15.6.0',
            'fileUrl': './node_modules/create-react-class/package.json',
            'main': 'index.js',
            'browser': { 'transform': ['loose-envify'] },
            'resolutions': {
                'fbjs': '0.8.12',
                'object-assign': '4.1.1'
            }
        },
        {
            'name': 'jquery',
            'version': '1.11.0',
            'fileUrl': './node_modules/funcunit/node_modules/jquery/package.json',
            'main': 'dist/jquery.js',
            'resolutions': {}
        },
        {
            'name': 'can-dom-events',
            'version': '1.0.3',
            'fileUrl': './node_modules/can-dom-events/package.json',
            'main': 'can-dom-events',
            'resolutions': { 'can-dom-events': '1.0.3' }
        },
        {
            'name': 'object-assign',
            'version': '4.1.1',
            'fileUrl': './node_modules/create-react-class/node_modules/object-assign/package.json',
            'resolutions': {}
        }
    ], { 'npmParentMap': {} }));
});
/*can-util@3.9.6#js/assign/assign*/
define('can-util@3.9.6#js/assign/assign', function (require, exports, module) {
    module.exports = function (d, s) {
        for (var prop in s) {
            d[prop] = s[prop];
        }
        return d;
    };
});
/*can-util@3.9.6#js/is-array/is-array*/
define('can-util@3.9.6#js/is-array/is-array', function (require, exports, module) {
    'use strict';
    module.exports = function (arr) {
        return Array.isArray(arr);
    };
});
/*can-util@3.9.6#js/is-function/is-function*/
define('can-util@3.9.6#js/is-function/is-function', function (require, exports, module) {
    'use strict';
    var isFunction = function () {
        if (typeof document !== 'undefined' && typeof document.getElementsByTagName('body') === 'function') {
            return function (value) {
                return Object.prototype.toString.call(value) === '[object Function]';
            };
        }
        return function (value) {
            return typeof value === 'function';
        };
    }();
    module.exports = isFunction;
});
/*can-util@3.9.6#js/is-plain-object/is-plain-object*/
define('can-util@3.9.6#js/is-plain-object/is-plain-object', function (require, exports, module) {
    'use strict';
    var core_hasOwn = Object.prototype.hasOwnProperty;
    function isWindow(obj) {
        return obj !== null && obj == obj.window;
    }
    function isPlainObject(obj) {
        if (!obj || typeof obj !== 'object' || obj.nodeType || isWindow(obj) || obj.constructor && obj.constructor.shortName) {
            return false;
        }
        try {
            if (obj.constructor && !core_hasOwn.call(obj, 'constructor') && !core_hasOwn.call(obj.constructor.prototype, 'isPrototypeOf')) {
                return false;
            }
        } catch (e) {
            return false;
        }
        var key;
        for (key in obj) {
        }
        return key === undefined || core_hasOwn.call(obj, key);
    }
    module.exports = isPlainObject;
});
/*can-util@3.9.6#js/deep-assign/deep-assign*/
define('can-util@3.9.6#js/deep-assign/deep-assign', function (require, exports, module) {
    'use strict';
    var isArray = require('../is-array/is-array');
    var isFunction = require('../is-function/is-function');
    var isPlainObject = require('../is-plain-object/is-plain-object');
    function deepAssign() {
        var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length;
        if (typeof target !== 'object' && !isFunction(target)) {
            target = {};
        }
        if (length === i) {
            target = this;
            --i;
        }
        for (; i < length; i++) {
            if ((options = arguments[i]) != null) {
                for (name in options) {
                    src = target[name];
                    copy = options[name];
                    if (target === copy) {
                        continue;
                    }
                    if (copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
                        if (copyIsArray) {
                            copyIsArray = false;
                            clone = src && isArray(src) ? src : [];
                        } else {
                            clone = src && isPlainObject(src) ? src : {};
                        }
                        target[name] = deepAssign(clone, copy);
                    } else if (copy !== undefined) {
                        target[name] = copy;
                    }
                }
            }
        }
        return target;
    }
    module.exports = deepAssign;
});
/*can-util@3.9.6#js/log/log*/
define('can-util@3.9.6#js/log/log', function (require, exports, module) {
    'use strict';
    exports.warnTimeout = 5000;
    exports.logLevel = 0;
    exports.warn = function (out) {
        var ll = this.logLevel;
        if (ll < 2) {
            Array.prototype.unshift.call(arguments, 'WARN:');
            if (typeof console !== 'undefined' && console.warn) {
                this._logger('warn', Array.prototype.slice.call(arguments));
            } else if (typeof console !== 'undefined' && console.log) {
                this._logger('log', Array.prototype.slice.call(arguments));
            } else if (window && window.opera && window.opera.postError) {
                window.opera.postError('CanJS WARNING: ' + out);
            }
        }
    };
    exports.log = function (out) {
        var ll = this.logLevel;
        if (ll < 1) {
            if (typeof console !== 'undefined' && console.log) {
                Array.prototype.unshift.call(arguments, 'INFO:');
                this._logger('log', Array.prototype.slice.call(arguments));
            } else if (window && window.opera && window.opera.postError) {
                window.opera.postError('CanJS INFO: ' + out);
            }
        }
    };
    exports.error = function (out) {
        var ll = this.logLevel;
        if (ll < 1) {
            if (typeof console !== 'undefined' && console.error) {
                Array.prototype.unshift.call(arguments, 'ERROR:');
                this._logger('error', Array.prototype.slice.call(arguments));
            } else if (window && window.opera && window.opera.postError) {
                window.opera.postError('ERROR: ' + out);
            }
        }
    };
    exports._logger = function (type, arr) {
        try {
            console[type].apply(console, arr);
        } catch (e) {
            console[type](arr);
        }
    };
});
/*can-util@3.9.6#js/dev/dev*/
define('can-util@3.9.6#js/dev/dev', function (require, exports, module) {
    'use strict';
    var canLog = require('../log/log');
    module.exports = {
        warnTimeout: 5000,
        logLevel: 0,
        stringify: function (value) {
            var flagUndefined = function flagUndefined(key, value) {
                return value === undefined ? '/* void(undefined) */' : value;
            };
            return JSON.stringify(value, flagUndefined, '  ').replace(/"\/\* void\(undefined\) \*\/"/g, 'undefined');
        },
        warn: function () {
        },
        log: function () {
        },
        error: function () {
        },
        _logger: canLog._logger
    };
});
/*can-util@3.9.6#js/is-array-like/is-array-like*/
define('can-util@3.9.6#js/is-array-like/is-array-like', function (require, exports, module) {
    'use strict';
    function isArrayLike(obj) {
        var type = typeof obj;
        if (type === 'string') {
            return true;
        } else if (type === 'number') {
            return false;
        }
        var length = obj && type !== 'boolean' && typeof obj !== 'number' && 'length' in obj && obj.length;
        return typeof obj !== 'function' && (length === 0 || typeof length === 'number' && length > 0 && length - 1 in obj);
    }
    module.exports = isArrayLike;
});
/*can-namespace@1.0.0#can-namespace*/
define('can-namespace@1.0.0#can-namespace', function (require, exports, module) {
    module.exports = {};
});
/*can-symbol@1.0.0#can-symbol*/
define('can-symbol@1.0.0#can-symbol', function (require, exports, module) {
    (function (global) {
        var namespace = require('can-namespace');
        var CanSymbol;
        if (typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') {
            CanSymbol = Symbol;
        } else {
            var symbolNum = 0;
            CanSymbol = function CanSymbolPolyfill(description) {
                var symbolValue = '@@symbol' + symbolNum++ + description;
                var symbol = {};
                Object.defineProperties(symbol, {
                    toString: {
                        value: function () {
                            return symbolValue;
                        }
                    }
                });
                return symbol;
            };
            var descriptionToSymbol = {};
            var symbolToDescription = {};
            CanSymbol.for = function (description) {
                var symbol = descriptionToSymbol[description];
                if (!symbol) {
                    symbol = descriptionToSymbol[description] = CanSymbol(description);
                    symbolToDescription[symbol] = description;
                }
                return symbol;
            };
            CanSymbol.keyFor = function (symbol) {
                return symbolToDescription[symbol];
            };
            [
                'hasInstance',
                'isConcatSpreadable',
                'iterator',
                'match',
                'prototype',
                'replace',
                'search',
                'species',
                'split',
                'toPrimitive',
                'toStringTag',
                'unscopables'
            ].forEach(function (name) {
                CanSymbol[name] = CanSymbol.for(name);
            });
        }
        [
            'isMapLike',
            'isListLike',
            'isValueLike',
            'isFunctionLike',
            'getOwnKeys',
            'getOwnKeyDescriptor',
            'proto',
            'getOwnEnumerableKeys',
            'hasOwnKey',
            'getValue',
            'setValue',
            'getKeyValue',
            'setKeyValue',
            'apply',
            'new',
            'onValue',
            'offValue',
            'onKeyValue',
            'offKeyValue',
            'getKeyDependencies',
            'getValueDependencies',
            'keyHasDependencies',
            'valueHasDependencies',
            'onKeys',
            'onKeysAdded',
            'onKeysRemoved'
        ].forEach(function (name) {
            CanSymbol.for('can.' + name);
        });
        module.exports = namespace.Symbol = CanSymbol;
    }(function () {
        return this;
    }()));
});
/*can-util@3.9.6#js/is-iterable/is-iterable*/
define('can-util@3.9.6#js/is-iterable/is-iterable', function (require, exports, module) {
    'use strict';
    var canSymbol = require('can-symbol');
    module.exports = function (obj) {
        return obj && !!obj[canSymbol.iterator || canSymbol.for('iterator')];
    };
});
/*can-util@3.9.6#js/each/each*/
define('can-util@3.9.6#js/each/each', function (require, exports, module) {
    'use strict';
    var isArrayLike = require('../is-array-like/is-array-like');
    var has = Object.prototype.hasOwnProperty;
    var isIterable = require('../is-iterable/is-iterable');
    var canSymbol = require('can-symbol');
    function each(elements, callback, context) {
        var i = 0, key, len, item;
        if (elements) {
            if (isArrayLike(elements)) {
                for (len = elements.length; i < len; i++) {
                    item = elements[i];
                    if (callback.call(context || item, item, i, elements) === false) {
                        break;
                    }
                }
            } else if (isIterable(elements)) {
                var iter = elements[canSymbol.iterator || canSymbol.for('iterator')]();
                var res, value;
                while (!(res = iter.next()).done) {
                    value = res.value;
                    callback.call(context || elements, Array.isArray(value) ? value[1] : value, value[0]);
                }
            } else if (typeof elements === 'object') {
                for (key in elements) {
                    if (has.call(elements, key) && callback.call(context || elements[key], elements[key], key, elements) === false) {
                        break;
                    }
                }
            }
        }
        return elements;
    }
    module.exports = each;
});
/*can-util@3.9.6#js/make-array/make-array*/
define('can-util@3.9.6#js/make-array/make-array', function (require, exports, module) {
    'use strict';
    var each = require('../each/each');
    var isArrayLike = require('../is-array-like/is-array-like');
    function makeArray(element) {
        var ret = [];
        if (isArrayLike(element)) {
            each(element, function (a, i) {
                ret[i] = a;
            });
        } else if (element === 0 || element) {
            ret.push(element);
        }
        return ret;
    }
    module.exports = makeArray;
});
/*can-util@3.9.6#js/is-container/is-container*/
define('can-util@3.9.6#js/is-container/is-container', function (require, exports, module) {
    'use strict';
    module.exports = function (current) {
        return /^f|^o/.test(typeof current);
    };
});
/*can-util@3.9.6#js/get/get*/
define('can-util@3.9.6#js/get/get', function (require, exports, module) {
    'use strict';
    var isContainer = require('../is-container/is-container');
    function get(obj, name) {
        var parts = typeof name !== 'undefined' ? (name + '').replace(/\[/g, '.').replace(/]/g, '').split('.') : [], length = parts.length, current, i, container;
        if (!length) {
            return obj;
        }
        current = obj;
        for (i = 0; i < length && isContainer(current); i++) {
            container = current;
            current = container[parts[i]];
        }
        return current;
    }
    module.exports = get;
});
/*can-util@3.9.6#js/string/string*/
define('can-util@3.9.6#js/string/string', function (require, exports, module) {
    'use strict';
    var get = require('../get/get');
    var isContainer = require('../is-container/is-container');
    var canDev = require('../dev/dev');
    var isArray = require('../is-array/is-array');
    var strUndHash = /_|-/, strColons = /\=\=/, strWords = /([A-Z]+)([A-Z][a-z])/g, strLowUp = /([a-z\d])([A-Z])/g, strDash = /([a-z\d])([A-Z])/g, strReplacer = /\{([^\}]+)\}/g, strQuote = /"/g, strSingleQuote = /'/g, strHyphenMatch = /-+(.)?/g, strCamelMatch = /[a-z][A-Z]/g, convertBadValues = function (content) {
            var isInvalid = content === null || content === undefined || isNaN(content) && '' + content === 'NaN';
            return '' + (isInvalid ? '' : content);
        }, deleteAtPath = function (data, path) {
            var parts = path ? path.replace(/\[/g, '.').replace(/]/g, '').split('.') : [];
            var current = data;
            for (var i = 0; i < parts.length - 1; i++) {
                if (current) {
                    current = current[parts[i]];
                }
            }
            if (current) {
                delete current[parts[parts.length - 1]];
            }
        };
    var string = {
        esc: function (content) {
            return convertBadValues(content).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(strQuote, '&#34;').replace(strSingleQuote, '&#39;');
        },
        getObject: function (name, roots) {
            roots = isArray(roots) ? roots : [roots || window];
            var result, l = roots.length;
            for (var i = 0; i < l; i++) {
                result = get(roots[i], name);
                if (result) {
                    return result;
                }
            }
        },
        capitalize: function (s, cache) {
            return s.charAt(0).toUpperCase() + s.slice(1);
        },
        camelize: function (str) {
            return convertBadValues(str).replace(strHyphenMatch, function (match, chr) {
                return chr ? chr.toUpperCase() : '';
            });
        },
        hyphenate: function (str) {
            return convertBadValues(str).replace(strCamelMatch, function (str, offset) {
                return str.charAt(0) + '-' + str.charAt(1).toLowerCase();
            });
        },
        underscore: function (s) {
            return s.replace(strColons, '/').replace(strWords, '$1_$2').replace(strLowUp, '$1_$2').replace(strDash, '_').toLowerCase();
        },
        sub: function (str, data, remove) {
            var obs = [];
            str = str || '';
            obs.push(str.replace(strReplacer, function (whole, inside) {
                var ob = get(data, inside);
                if (remove === true) {
                    deleteAtPath(data, inside);
                }
                if (ob === undefined || ob === null) {
                    obs = null;
                    return '';
                }
                if (isContainer(ob) && obs) {
                    obs.push(ob);
                    return '';
                }
                return '' + ob;
            }));
            return obs === null ? obs : obs.length <= 1 ? obs[0] : obs;
        },
        replacer: strReplacer,
        undHash: strUndHash
    };
    module.exports = string;
});
/*can-construct@3.2.0#can-construct*/
define('can-construct@3.2.0#can-construct', function (require, exports, module) {
    'use strict';
    var assign = require('can-util/js/assign/assign');
    var deepAssign = require('can-util/js/deep-assign/deep-assign');
    var dev = require('can-util/js/dev/dev');
    var makeArray = require('can-util/js/make-array/make-array');
    var namespace = require('can-namespace');
    var initializing = 0;
    var Construct = function () {
        if (arguments.length) {
            return Construct.extend.apply(Construct, arguments);
        }
    };
    var canGetDescriptor;
    try {
        Object.getOwnPropertyDescriptor({});
        canGetDescriptor = true;
    } catch (e) {
        canGetDescriptor = false;
    }
    var getDescriptor = function (newProps, name) {
            var descriptor = Object.getOwnPropertyDescriptor(newProps, name);
            if (descriptor && (descriptor.get || descriptor.set)) {
                return descriptor;
            }
            return null;
        }, inheritGetterSetter = function (newProps, oldProps, addTo) {
            addTo = addTo || newProps;
            var descriptor;
            for (var name in newProps) {
                if (descriptor = getDescriptor(newProps, name)) {
                    this._defineProperty(addTo, oldProps, name, descriptor);
                } else {
                    Construct._overwrite(addTo, oldProps, name, newProps[name]);
                }
            }
        }, simpleInherit = function (newProps, oldProps, addTo) {
            addTo = addTo || newProps;
            for (var name in newProps) {
                Construct._overwrite(addTo, oldProps, name, newProps[name]);
            }
        };
    assign(Construct, {
        constructorExtends: true,
        newInstance: function () {
            var inst = this.instance(), args;
            if (inst.setup) {
                Object.defineProperty(inst, '__inSetup', {
                    configurable: true,
                    enumerable: false,
                    value: true,
                    writable: true
                });
                args = inst.setup.apply(inst, arguments);
                if (args instanceof Construct.ReturnValue) {
                    return args.value;
                }
                inst.__inSetup = false;
            }
            if (inst.init) {
                inst.init.apply(inst, args || arguments);
            }
            return inst;
        },
        _inherit: canGetDescriptor ? inheritGetterSetter : simpleInherit,
        _defineProperty: function (what, oldProps, propName, descriptor) {
            Object.defineProperty(what, propName, descriptor);
        },
        _overwrite: function (what, oldProps, propName, val) {
            Object.defineProperty(what, propName, {
                value: val,
                configurable: true,
                enumerable: true,
                writable: true
            });
        },
        setup: function (base) {
            this.defaults = deepAssign(true, {}, base.defaults, this.defaults);
        },
        instance: function () {
            initializing = 1;
            var inst = new this();
            initializing = 0;
            return inst;
        },
        extend: function (name, staticProperties, instanceProperties) {
            var shortName = name, klass = staticProperties, proto = instanceProperties;
            if (typeof shortName !== 'string') {
                proto = klass;
                klass = shortName;
                shortName = null;
            }
            if (!proto) {
                proto = klass;
                klass = null;
            }
            proto = proto || {};
            var _super_class = this, _super = this.prototype, Constructor, prototype;
            prototype = this.instance();
            Construct._inherit(proto, _super, prototype);
            if (shortName) {
            } else if (klass && klass.shortName) {
                shortName = klass.shortName;
            } else if (this.shortName) {
                shortName = this.shortName;
            }
            function init() {
                if (!initializing) {
                    return (!this || this.constructor !== Constructor) && arguments.length && Constructor.constructorExtends ? Constructor.extend.apply(Constructor, arguments) : Constructor.newInstance.apply(Constructor, arguments);
                }
            }
            Constructor = typeof namedCtor === 'function' ? namedCtor(constructorName, init) : function () {
                return init.apply(this, arguments);
            };
            for (var propName in _super_class) {
                if (_super_class.hasOwnProperty(propName)) {
                    Constructor[propName] = _super_class[propName];
                }
            }
            Construct._inherit(klass, _super_class, Constructor);
            assign(Constructor, {
                constructor: Constructor,
                prototype: prototype
            });
            if (shortName !== undefined) {
                Constructor.shortName = shortName;
            }
            Constructor.prototype.constructor = Constructor;
            var t = [_super_class].concat(makeArray(arguments)), args = Constructor.setup.apply(Constructor, t);
            if (Constructor.init) {
                Constructor.init.apply(Constructor, args || t);
            }
            return Constructor;
        },
        ReturnValue: function (value) {
            this.value = value;
        }
    });
    Construct.prototype.setup = function () {
    };
    Construct.prototype.init = function () {
    };
    module.exports = namespace.Construct = Construct;
});
/*can-reflect@1.2.3#reflections/helpers*/
define('can-reflect@1.2.3#reflections/helpers', function (require, exports, module) {
    var canSymbol = require('can-symbol');
    module.exports = {
        makeGetFirstSymbolValue: function (symbolNames) {
            var symbols = symbolNames.map(function (name) {
                return canSymbol.for(name);
            });
            var length = symbols.length;
            return function getFirstSymbol(obj) {
                var index = -1;
                while (++index < length) {
                    if (obj[symbols[index]] !== undefined) {
                        return obj[symbols[index]];
                    }
                }
            };
        }
    };
});
/*can-reflect@1.2.3#reflections/type/type*/
define('can-reflect@1.2.3#reflections/type/type', function (require, exports, module) {
    var canSymbol = require('can-symbol');
    var helpers = require('../helpers');
    var plainFunctionPrototypePropertyNames = Object.getOwnPropertyNames(function () {
    }.prototype);
    var plainFunctionPrototypeProto = Object.getPrototypeOf(function () {
    }.prototype);
    function isConstructorLike(func) {
        var value = func[canSymbol.for('can.new')];
        if (value !== undefined) {
            return value;
        }
        if (typeof func !== 'function') {
            return false;
        }
        var prototype = func.prototype;
        if (!prototype) {
            return false;
        }
        if (plainFunctionPrototypeProto !== Object.getPrototypeOf(prototype)) {
            return true;
        }
        var propertyNames = Object.getOwnPropertyNames(prototype);
        if (propertyNames.length === plainFunctionPrototypePropertyNames.length) {
            for (var i = 0, len = propertyNames.length; i < len; i++) {
                if (propertyNames[i] !== plainFunctionPrototypePropertyNames[i]) {
                    return true;
                }
            }
            return false;
        } else {
            return true;
        }
    }
    var getNewOrApply = helpers.makeGetFirstSymbolValue([
        'can.new',
        'can.apply'
    ]);
    function isFunctionLike(obj) {
        var result, symbolValue = obj[canSymbol.for('can.isFunctionLike')];
        if (symbolValue !== undefined) {
            return symbolValue;
        }
        result = getNewOrApply(obj);
        if (result !== undefined) {
            return !!result;
        }
        return typeof obj === 'function';
    }
    function isPrimitive(obj) {
        var type = typeof obj;
        if (obj == null || type !== 'function' && type !== 'object') {
            return true;
        } else {
            return false;
        }
    }
    function isValueLike(obj) {
        var symbolValue;
        if (isPrimitive(obj)) {
            return true;
        }
        symbolValue = obj[canSymbol.for('can.isValueLike')];
        if (typeof symbolValue !== 'undefined') {
            return symbolValue;
        }
        var value = obj[canSymbol.for('can.getValue')];
        if (value !== undefined) {
            return !!value;
        }
    }
    function isMapLike(obj) {
        if (isPrimitive(obj)) {
            return false;
        }
        var isMapLike = obj[canSymbol.for('can.isMapLike')];
        if (typeof isMapLike !== 'undefined') {
            return !!isMapLike;
        }
        var value = obj[canSymbol.for('can.getKeyValue')];
        if (value !== undefined) {
            return !!value;
        }
        return true;
    }
    var getObservableLikeSymbol = helpers.makeGetFirstSymbolValue([
        'can.onValue',
        'can.onKeyValue',
        'can.onKeys',
        'can.onKeysAdded'
    ]);
    function isObservableLike(obj) {
        if (isPrimitive(obj)) {
            return false;
        }
        var result = getObservableLikeSymbol(obj);
        if (result !== undefined) {
            return !!result;
        }
    }
    function isListLike(list) {
        var symbolValue, type = typeof list;
        if (type === 'string') {
            return true;
        }
        if (isPrimitive(list)) {
            return false;
        }
        symbolValue = list[canSymbol.for('can.isListLike')];
        if (typeof symbolValue !== 'undefined') {
            return symbolValue;
        }
        var value = list[canSymbol.iterator];
        if (value !== undefined) {
            return !!value;
        }
        if (Array.isArray(list)) {
            return true;
        }
        var length = list && type !== 'boolean' && typeof list !== 'number' && 'length' in list && list.length;
        return typeof list !== 'function' && (length === 0 || typeof length === 'number' && length > 0 && length - 1 in list);
    }
    var supportsSymbols = typeof Symbol !== 'undefined' && typeof Symbol.for === 'function';
    var isSymbolLike;
    if (supportsSymbols) {
        isSymbolLike = function (symbol) {
            return typeof symbol === 'symbol';
        };
    } else {
        var symbolStart = '@@symbol';
        isSymbolLike = function (symbol) {
            if (typeof symbol === 'object' && !Array.isArray(symbol)) {
                return symbol.toString().substr(0, symbolStart.length) === symbolStart;
            } else {
                return false;
            }
        };
    }
    var coreHasOwn = Object.prototype.hasOwnProperty;
    var funcToString = Function.prototype.toString;
    var objectCtorString = funcToString.call(Object);
    function isPlainObject(obj) {
        if (!obj || typeof obj !== 'object') {
            return false;
        }
        var proto = Object.getPrototypeOf(obj);
        if (proto === Object.prototype || proto === null) {
            return true;
        }
        var Constructor = coreHasOwn.call(proto, 'constructor') && proto.constructor;
        return typeof Constructor === 'function' && Constructor instanceof Constructor && funcToString.call(Constructor) === objectCtorString;
    }
    module.exports = {
        isConstructorLike: isConstructorLike,
        isFunctionLike: isFunctionLike,
        isListLike: isListLike,
        isMapLike: isMapLike,
        isObservableLike: isObservableLike,
        isPrimitive: isPrimitive,
        isValueLike: isValueLike,
        isSymbolLike: isSymbolLike,
        isMoreListLikeThanMapLike: function (obj) {
            if (Array.isArray(obj)) {
                return true;
            }
            var value = obj[canSymbol.for('can.isMoreListLikeThanMapLike')];
            if (value !== undefined) {
                return value;
            }
            var isListLike = this.isListLike(obj), isMapLike = this.isMapLike(obj);
            if (isListLike && !isMapLike) {
                return true;
            } else if (!isListLike && isMapLike) {
                return false;
            }
        },
        isIteratorLike: function (obj) {
            return obj && typeof obj === 'object' && typeof obj.next === 'function' && obj.next.length === 0;
        },
        isPromise: function (obj) {
            return obj instanceof Promise || Object.prototype.toString.call(obj) === '[object Promise]';
        },
        isPlainObject: isPlainObject
    };
});
/*can-reflect@1.2.3#reflections/call/call*/
define('can-reflect@1.2.3#reflections/call/call', function (require, exports, module) {
    var canSymbol = require('can-symbol');
    var typeReflections = require('../type/type');
    module.exports = {
        call: function (func, context) {
            var args = [].slice.call(arguments, 2);
            var apply = func[canSymbol.for('can.apply')];
            if (apply) {
                return apply.call(func, context, args);
            } else {
                return func.apply(context, args);
            }
        },
        apply: function (func, context, args) {
            var apply = func[canSymbol.for('can.apply')];
            if (apply) {
                return apply.call(func, context, args);
            } else {
                return func.apply(context, args);
            }
        },
        'new': function (func) {
            var args = [].slice.call(arguments, 1);
            var makeNew = func[canSymbol.for('can.new')];
            if (makeNew) {
                return makeNew.apply(func, args);
            } else {
                var context = Object.create(func.prototype);
                var ret = func.apply(context, args);
                if (typeReflections.isPrimitive(ret)) {
                    return context;
                } else {
                    return ret;
                }
            }
        }
    };
});
/*can-reflect@1.2.3#reflections/get-set/get-set*/
define('can-reflect@1.2.3#reflections/get-set/get-set', function (require, exports, module) {
    var canSymbol = require('can-symbol');
    var typeReflections = require('../type/type');
    var setKeyValueSymbol = canSymbol.for('can.setKeyValue'), getKeyValueSymbol = canSymbol.for('can.getKeyValue'), getValueSymbol = canSymbol.for('can.getValue'), setValueSymbol = canSymbol.for('can.setValue');
    var reflections = {
        setKeyValue: function (obj, key, value) {
            if (typeReflections.isSymbolLike(key)) {
                if (typeof key === 'symbol') {
                    obj[key] = value;
                } else {
                    Object.defineProperty(obj, key, {
                        enumerable: false,
                        configurable: true,
                        value: value,
                        writable: true
                    });
                }
                return;
            }
            var setKeyValue = obj[setKeyValueSymbol];
            if (setKeyValue !== undefined) {
                return setKeyValue.call(obj, key, value);
            } else {
                obj[key] = value;
            }
        },
        getKeyValue: function (obj, key) {
            var getKeyValue = obj[getKeyValueSymbol];
            if (getKeyValue) {
                return getKeyValue.call(obj, key);
            }
            return obj[key];
        },
        deleteKeyValue: function (obj, key) {
            var deleteKeyValue = obj[canSymbol.for('can.deleteKeyValue')];
            if (deleteKeyValue) {
                return deleteKeyValue.call(obj, key);
            }
            delete obj[key];
        },
        getValue: function (value) {
            if (typeReflections.isPrimitive(value)) {
                return value;
            }
            var getValue = value[getValueSymbol];
            if (getValue) {
                return getValue.call(value);
            }
            return value;
        },
        setValue: function (item, value) {
            var setValue = item && item[setValueSymbol];
            if (setValue) {
                return setValue.call(item, value);
            } else {
                throw new Error('can-reflect.setValue - Can not set value.');
            }
        },
        splice: function (obj, index, howMany, values) {
            var splice = obj[canSymbol.for('can.splice')];
            if (splice) {
                return splice.call(obj, index, howMany, values);
            }
            return [].splice.apply(obj, [
                index,
                howMany
            ].concat(values));
        }
    };
    reflections.get = reflections.getKeyValue;
    reflections.set = reflections.setKeyValue;
    reflections['delete'] = reflections.deleteKeyValue;
    module.exports = reflections;
});
/*can-reflect@1.2.3#reflections/observe/observe*/
define('can-reflect@1.2.3#reflections/observe/observe', function (require, exports, module) {
    var canSymbol = require('can-symbol');
    var slice = [].slice;
    function makeFallback(symbolName, fallbackName) {
        return function (obj, event, handler) {
            var method = obj[canSymbol.for(symbolName)];
            if (method !== undefined) {
                return method.call(obj, event, handler);
            }
            return this[fallbackName].apply(this, arguments);
        };
    }
    function makeErrorIfMissing(symbolName, errorMessage) {
        return function (obj, arg1, arg2) {
            var method = obj[canSymbol.for(symbolName)];
            if (method !== undefined) {
                return method.call(obj, arg1, arg2);
            }
            throw new Error(errorMessage);
        };
    }
    module.exports = {
        onKeyValue: makeFallback('can.onKeyValue', 'onEvent'),
        offKeyValue: makeFallback('can.offKeyValue', 'offEvent'),
        onKeys: makeErrorIfMissing('can.onKeys', 'can-reflect: can not observe an onKeys event'),
        onKeysAdded: makeErrorIfMissing('can.onKeysAdded', 'can-reflect: can not observe an onKeysAdded event'),
        onKeysRemoved: makeErrorIfMissing('can.onKeysRemoved', 'can-reflect: can not unobserve an onKeysRemoved event'),
        getKeyDependencies: makeErrorIfMissing('can.getKeyDependencies', 'can-reflect: can not determine dependencies'),
        keyHasDependencies: makeErrorIfMissing('can.keyHasDependencies', 'can-reflect: can not determine if this has key dependencies'),
        onValue: makeErrorIfMissing('can.onValue', 'can-reflect: can not observe value change'),
        offValue: makeErrorIfMissing('can.offValue', 'can-reflect: can not unobserve value change'),
        getValueDependencies: makeErrorIfMissing('can.getValueDependencies', 'can-reflect: can not determine dependencies'),
        valueHasDependencies: makeErrorIfMissing('can.valueHasDependencies', 'can-reflect: can not determine if value has dependencies'),
        onEvent: function (obj, eventName, callback) {
            if (obj) {
                var onEvent = obj[canSymbol.for('can.onEvent')];
                if (onEvent !== undefined) {
                    return onEvent.call(obj, eventName, callback);
                } else if (obj.addEventListener) {
                    obj.addEventListener(eventName, callback);
                }
            }
        },
        offEvent: function (obj, eventName, callback) {
            if (obj) {
                var offEvent = obj[canSymbol.for('can.offEvent')];
                if (offEvent !== undefined) {
                    return offEvent.call(obj, eventName, callback);
                } else if (obj.removeEventListener) {
                    obj.removeEventListener(eventName, callback);
                }
            }
        }
    };
});
/*can-reflect@1.2.3#reflections/shape/shape*/
define('can-reflect@1.2.3#reflections/shape/shape', function (require, exports, module) {
    var canSymbol = require('can-symbol');
    var getSetReflections = require('../get-set/get-set');
    var typeReflections = require('../type/type');
    var helpers = require('../helpers');
    var shiftFirstArgumentToThis = function (func) {
        return function () {
            var args = [this];
            args.push.apply(args, arguments);
            return func.apply(null, args);
        };
    };
    var getKeyValueSymbol = canSymbol.for('can.getKeyValue');
    var shiftedGetKeyValue = shiftFirstArgumentToThis(getSetReflections.getKeyValue);
    var setKeyValueSymbol = canSymbol.for('can.setKeyValue');
    var shiftedSetKeyValue = shiftFirstArgumentToThis(getSetReflections.setKeyValue);
    var serializeMap = null;
    function shouldSerialize(obj) {
        return typeof obj !== 'function';
    }
    var hasUpdateSymbol = helpers.makeGetFirstSymbolValue([
        'can.updateDeep',
        'can.assignDeep',
        'can.setKeyValue'
    ]);
    var shouldUpdateOrAssign = function (obj) {
        return typeReflections.isPlainObject(obj) || Array.isArray(obj) || !!hasUpdateSymbol(obj);
    };
    var Object_Keys;
    try {
        Object.keys(1);
        Object_Keys = Object.keys;
    } catch (e) {
        Object_Keys = function (obj) {
            if (typeReflections.isPrimitive(obj)) {
                return [];
            } else {
                return Object.keys(obj);
            }
        };
    }
    function makeSerializer(methodName, symbolsToCheck) {
        return function serializer(value, MapType) {
            if (typeReflections.isPrimitive(value)) {
                return value;
            }
            var firstSerialize;
            if (MapType && !serializeMap) {
                serializeMap = {
                    unwrap: new MapType(),
                    serialize: new MapType()
                };
                firstSerialize = true;
            }
            var serialized;
            if (typeReflections.isValueLike(value)) {
                serialized = this[methodName](getSetReflections.getValue(value));
            } else {
                var isListLike = typeReflections.isIteratorLike(value) || typeReflections.isMoreListLikeThanMapLike(value);
                serialized = isListLike ? [] : {};
                if (serializeMap) {
                    if (serializeMap[methodName].has(value)) {
                        return serializeMap[methodName].get(value);
                    } else {
                        serializeMap[methodName].set(value, serialized);
                    }
                }
                for (var i = 0, len = symbolsToCheck.length; i < len; i++) {
                    var serializer = value[symbolsToCheck[i]];
                    if (serializer) {
                        var result = serializer.call(value, serialized);
                        if (firstSerialize) {
                            serializeMap = null;
                        }
                        return result;
                    }
                }
                if (!shouldSerialize(value)) {
                    if (serializeMap) {
                        serializeMap[methodName].set(value, value);
                    }
                    serialized = value;
                } else if (isListLike) {
                    this.eachIndex(value, function (childValue, index) {
                        serialized[index] = this[methodName](childValue);
                    }, this);
                } else {
                    this.eachKey(value, function (childValue, prop) {
                        serialized[prop] = this[methodName](childValue);
                    }, this);
                }
            }
            if (firstSerialize) {
                serializeMap = null;
            }
            return serialized;
        };
    }
    function makeMap(keys) {
        var map = {};
        keys.forEach(function (key) {
            map[key] = true;
        });
        return map;
    }
    function addPatch(patches, patch) {
        var lastPatch = patches[patches.length - 1];
        if (lastPatch) {
            if (lastPatch.deleteCount === lastPatch.insert.length && patch.index - lastPatch.index === lastPatch.deleteCount) {
                lastPatch.insert.push.apply(lastPatch.insert, patch.insert);
                lastPatch.deleteCount += patch.deleteCount;
                return;
            }
        }
        patches.push(patch);
    }
    function updateDeepList(target, source, isAssign) {
        var sourceArray = this.toArray(source);
        var patches = [], lastIndex = -1;
        this.eachIndex(target, function (curVal, index) {
            lastIndex = index;
            if (index >= sourceArray.length) {
                if (!isAssign) {
                    addPatch(patches, {
                        index: index,
                        deleteCount: sourceArray.length - index + 1,
                        insert: []
                    });
                }
                return false;
            }
            var newVal = sourceArray[index];
            if (typeReflections.isPrimitive(curVal) || typeReflections.isPrimitive(newVal) || shouldUpdateOrAssign(curVal) === false) {
                addPatch(patches, {
                    index: index,
                    deleteCount: 1,
                    insert: [newVal]
                });
            } else {
                this.updateDeep(curVal, newVal);
            }
        }, this);
        if (sourceArray.length > lastIndex) {
            addPatch(patches, {
                index: lastIndex + 1,
                deleteCount: 0,
                insert: sourceArray.slice(lastIndex + 1)
            });
        }
        for (var i = 0, patchLen = patches.length; i < patchLen; i++) {
            var patch = patches[i];
            getSetReflections.splice(target, patch.index, patch.deleteCount, patch.insert);
        }
        return target;
    }
    var shapeReflections = {
        each: function (obj, callback, context) {
            if (typeReflections.isIteratorLike(obj) || typeReflections.isMoreListLikeThanMapLike(obj)) {
                return this.eachIndex(obj, callback, context);
            } else {
                return this.eachKey(obj, callback, context);
            }
        },
        eachIndex: function (list, callback, context) {
            if (Array.isArray(list)) {
                return this.eachListLike(list, callback, context);
            } else {
                var iter, iterator = list[canSymbol.iterator];
                if (typeReflections.isIteratorLike(list)) {
                    iter = list;
                } else if (iterator) {
                    iter = iterator.call(list);
                }
                if (iter) {
                    var res, index = 0;
                    while (!(res = iter.next()).done) {
                        if (callback.call(context || list, res.value, index++, list) === false) {
                            break;
                        }
                    }
                } else {
                    this.eachListLike(list, callback, context);
                }
            }
            return list;
        },
        eachListLike: function (list, callback, context) {
            var index = -1;
            var length = list.length;
            while (++index < length) {
                var item = list[index];
                if (callback.call(context || item, item, index, list) === false) {
                    break;
                }
            }
            return list;
        },
        toArray: function (obj) {
            var arr = [];
            this.each(obj, function (value) {
                arr.push(value);
            });
            return arr;
        },
        eachKey: function (obj, callback, context) {
            if (obj) {
                var enumerableKeys = this.getOwnEnumerableKeys(obj);
                var getKeyValue = obj[getKeyValueSymbol] || shiftedGetKeyValue;
                return this.eachIndex(enumerableKeys, function (key) {
                    var value = getKeyValue.call(obj, key);
                    return callback.call(context || obj, value, key, obj);
                });
            }
            return obj;
        },
        'hasOwnKey': function (obj, key) {
            var hasOwnKey = obj[canSymbol.for('can.hasOwnKey')];
            if (hasOwnKey) {
                return hasOwnKey.call(obj, key);
            }
            var getOwnKeys = obj[canSymbol.for('can.getOwnKeys')];
            if (getOwnKeys) {
                var found = false;
                this.eachIndex(getOwnKeys.call(obj), function (objKey) {
                    if (objKey === key) {
                        found = true;
                        return false;
                    }
                });
                return found;
            }
            return obj.hasOwnProperty(key);
        },
        getOwnEnumerableKeys: function (obj) {
            var getOwnEnumerableKeys = obj[canSymbol.for('can.getOwnEnumerableKeys')];
            if (getOwnEnumerableKeys) {
                return getOwnEnumerableKeys.call(obj);
            }
            if (obj[canSymbol.for('can.getOwnKeys')] && obj[canSymbol.for('can.getOwnKeyDescriptor')]) {
                var keys = [];
                this.eachIndex(this.getOwnKeys(obj), function (key) {
                    var descriptor = this.getOwnKeyDescriptor(obj, key);
                    if (descriptor.enumerable) {
                        keys.push(key);
                    }
                }, this);
                return keys;
            } else {
                return Object_Keys(obj);
            }
        },
        getOwnKeys: function (obj) {
            var getOwnKeys = obj[canSymbol.for('can.getOwnKeys')];
            if (getOwnKeys) {
                return getOwnKeys.call(obj);
            } else {
                return Object.getOwnPropertyNames(obj);
            }
        },
        getOwnKeyDescriptor: function (obj, key) {
            var getOwnKeyDescriptor = obj[canSymbol.for('can.getOwnKeyDescriptor')];
            if (getOwnKeyDescriptor) {
                return getOwnKeyDescriptor.call(obj, key);
            } else {
                return Object.getOwnPropertyDescriptor(obj, key);
            }
        },
        unwrap: makeSerializer('unwrap', [canSymbol.for('can.unwrap')]),
        serialize: makeSerializer('serialize', [
            canSymbol.for('can.serialize'),
            canSymbol.for('can.unwrap')
        ]),
        assignMap: function (target, source) {
            var targetKeyMap = makeMap(this.getOwnEnumerableKeys(target));
            var getKeyValue = target[getKeyValueSymbol] || shiftedGetKeyValue;
            var setKeyValue = target[setKeyValueSymbol] || shiftedSetKeyValue;
            this.eachKey(source, function (value, key) {
                if (!targetKeyMap[key] || getKeyValue.call(target, key) !== value) {
                    setKeyValue.call(target, key, value);
                }
            });
            return target;
        },
        assignList: function (target, source) {
            var inserting = this.toArray(source);
            getSetReflections.splice(target, 0, inserting.length, inserting);
            return target;
        },
        assign: function (target, source) {
            if (typeReflections.isIteratorLike(source) || typeReflections.isMoreListLikeThanMapLike(source)) {
                this.assignList(target, source);
            } else {
                this.assignMap(target, source);
            }
            return target;
        },
        assignDeepMap: function (target, source) {
            var targetKeyMap = makeMap(this.getOwnEnumerableKeys(target));
            var getKeyValue = target[getKeyValueSymbol] || shiftedGetKeyValue;
            var setKeyValue = target[setKeyValueSymbol] || shiftedSetKeyValue;
            this.eachKey(source, function (newVal, key) {
                if (!targetKeyMap[key]) {
                    getSetReflections.setKeyValue(target, key, newVal);
                } else {
                    var curVal = getKeyValue.call(target, key);
                    if (newVal === curVal) {
                    } else if (typeReflections.isPrimitive(curVal) || typeReflections.isPrimitive(newVal) || shouldUpdateOrAssign(curVal) === false) {
                        setKeyValue.call(target, key, newVal);
                    } else {
                        this.assignDeep(curVal, newVal);
                    }
                }
            }, this);
            return target;
        },
        assignDeepList: function (target, source) {
            return updateDeepList.call(this, target, source, true);
        },
        assignDeep: function (target, source) {
            var assignDeep = target[canSymbol.for('can.assignDeep')];
            if (assignDeep) {
                assignDeep.call(target, source);
            } else if (typeReflections.isMoreListLikeThanMapLike(source)) {
                this.assignDeepList(target, source);
            } else {
                this.assignDeepMap(target, source);
            }
            return target;
        },
        updateMap: function (target, source) {
            var sourceKeyMap = makeMap(this.getOwnEnumerableKeys(source));
            var sourceGetKeyValue = source[getKeyValueSymbol] || shiftedGetKeyValue;
            var targetSetKeyValue = target[setKeyValueSymbol] || shiftedSetKeyValue;
            this.eachKey(target, function (curVal, key) {
                if (!sourceKeyMap[key]) {
                    getSetReflections.deleteKeyValue(target, key);
                    return;
                }
                sourceKeyMap[key] = false;
                var newVal = sourceGetKeyValue.call(source, key);
                if (newVal !== curVal) {
                    targetSetKeyValue.call(target, key, newVal);
                }
            }, this);
            for (var key in sourceKeyMap) {
                if (sourceKeyMap[key]) {
                    targetSetKeyValue.call(target, key, sourceGetKeyValue.call(source, key));
                }
            }
            return target;
        },
        updateList: function (target, source) {
            var inserting = this.toArray(source);
            getSetReflections.splice(target, 0, target.length, inserting);
            return target;
        },
        update: function (target, source) {
            if (typeReflections.isIteratorLike(source) || typeReflections.isMoreListLikeThanMapLike(source)) {
                this.updateList(target, source);
            } else {
                this.updateMap(target, source);
            }
            return target;
        },
        updateDeepMap: function (target, source) {
            var sourceKeyMap = makeMap(this.getOwnEnumerableKeys(source));
            var sourceGetKeyValue = source[getKeyValueSymbol] || shiftedGetKeyValue;
            var targetSetKeyValue = target[setKeyValueSymbol] || shiftedSetKeyValue;
            this.eachKey(target, function (curVal, key) {
                if (!sourceKeyMap[key]) {
                    getSetReflections.deleteKeyValue(target, key);
                    return;
                }
                sourceKeyMap[key] = false;
                var newVal = sourceGetKeyValue.call(source, key);
                if (typeReflections.isPrimitive(curVal) || typeReflections.isPrimitive(newVal) || shouldUpdateOrAssign(curVal) === false) {
                    targetSetKeyValue.call(target, key, newVal);
                } else {
                    this.updateDeep(curVal, newVal);
                }
            }, this);
            for (var key in sourceKeyMap) {
                if (sourceKeyMap[key]) {
                    targetSetKeyValue.call(target, key, sourceGetKeyValue.call(source, key));
                }
            }
            return target;
        },
        updateDeepList: function (target, source) {
            return updateDeepList.call(this, target, source);
        },
        updateDeep: function (target, source) {
            var updateDeep = target[canSymbol.for('can.updateDeep')];
            if (updateDeep) {
                updateDeep.call(target, source);
            } else if (typeReflections.isMoreListLikeThanMapLike(source)) {
                this.updateDeepList(target, source);
            } else {
                this.updateDeepMap(target, source);
            }
            return target;
        },
        'in': function () {
        },
        getAllEnumerableKeys: function () {
        },
        getAllKeys: function () {
        },
        assignSymbols: function (target, source) {
            this.eachKey(source, function (value, key) {
                getSetReflections.setKeyValue(target, canSymbol.for(key), value);
            });
            return target;
        }
    };
    shapeReflections.keys = shapeReflections.getOwnEnumerableKeys;
    module.exports = shapeReflections;
});
/*can-reflect@1.2.3#can-reflect*/
define('can-reflect@1.2.3#can-reflect', function (require, exports, module) {
    var functionReflections = require('./reflections/call/call');
    var getSet = require('./reflections/get-set/get-set');
    var observe = require('./reflections/observe/observe');
    var shape = require('./reflections/shape/shape');
    var type = require('./reflections/type/type');
    var namespace = require('can-namespace');
    var reflect = {};
    [
        functionReflections,
        getSet,
        observe,
        shape,
        type
    ].forEach(function (reflections) {
        for (var prop in reflections) {
            reflect[prop] = reflections[prop];
        }
    });
    module.exports = namespace.Reflect = reflect;
});
/*can-types@1.1.0#can-types*/
define('can-types@1.1.0#can-types', function (require, exports, module) {
    var namespace = require('can-namespace');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var dev = require('can-util/js/dev/dev');
    var types = {
        isMapLike: function (obj) {
            return canReflect.isObservableLike(obj) && canReflect.isMapLike(obj);
        },
        isListLike: function (obj) {
            return canReflect.isObservableLike(obj) && canReflect.isListLike(obj);
        },
        isPromise: function (obj) {
            return canReflect.isPromise(obj);
        },
        isConstructor: function (func) {
            return canReflect.isConstructorLike(func);
        },
        isCallableForValue: function (obj) {
            return obj && canReflect.isFunctionLike(obj) && !canReflect.isConstructorLike(obj);
        },
        isCompute: function (obj) {
            return obj && obj.isComputed;
        },
        get iterator() {
            return canSymbol.iterator || canSymbol.for('iterator');
        },
        DefaultMap: null,
        DefaultList: null,
        queueTask: function (task) {
            var args = task[2] || [];
            task[0].apply(task[1], args);
        },
        wrapElement: function (element) {
            return element;
        },
        unwrapElement: function (element) {
            return element;
        }
    };
    if (namespace.types) {
        throw new Error('You can\'t have two versions of can-types, check your dependencies');
    } else {
        module.exports = namespace.types = types;
    }
});
/*can-util@3.9.6#js/is-empty-object/is-empty-object*/
define('can-util@3.9.6#js/is-empty-object/is-empty-object', function (require, exports, module) {
    'use strict';
    module.exports = function (obj) {
        for (var prop in obj) {
            return false;
        }
        return true;
    };
});
/*can-util@3.9.6#dom/data/core*/
define('can-util@3.9.6#dom/data/core', function (require, exports, module) {
    'use strict';
    var isEmptyObject = require('../../js/is-empty-object/is-empty-object');
    var data = {};
    var expando = 'can' + new Date();
    var uuid = 0;
    var setData = function (name, value) {
        var id = this[expando] || (this[expando] = ++uuid), store = data[id], newStore = false;
        if (!data[id]) {
            newStore = true;
            store = data[id] = {};
        }
        if (name !== undefined) {
            store[name] = value;
        }
        return newStore;
    };
    var deleteNode = function () {
        var id = this[expando];
        var nodeDeleted = false;
        if (id && data[id]) {
            nodeDeleted = true;
            delete data[id];
        }
        return nodeDeleted;
    };
    module.exports = {
        _data: data,
        getCid: function () {
            return this[expando];
        },
        cid: function () {
            return this[expando] || (this[expando] = ++uuid);
        },
        expando: expando,
        get: function (key) {
            var id = this[expando], store = id && data[id];
            return key === undefined ? store || setData(this) : store && store[key];
        },
        set: setData,
        clean: function (prop) {
            var id = this[expando];
            var itemData = data[id];
            if (itemData && itemData[prop]) {
                delete itemData[prop];
            }
            if (isEmptyObject(itemData)) {
                deleteNode.call(this);
            }
        },
        delete: deleteNode
    };
});
/*can-util@3.9.6#js/global/global*/
define('can-util@3.9.6#js/global/global', function (require, exports, module) {
    (function (global) {
        'use strict';
        var GLOBAL;
        module.exports = function (setGlobal) {
            if (setGlobal !== undefined) {
                GLOBAL = setGlobal;
            }
            if (GLOBAL) {
                return GLOBAL;
            } else {
                return GLOBAL = typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope ? self : typeof process === 'object' && {}.toString.call(process) === '[object process]' ? global : window;
            }
        };
    }(function () {
        return this;
    }()));
});
/*can-util@3.9.6#dom/document/document*/
define('can-util@3.9.6#dom/document/document', function (require, exports, module) {
    (function (global) {
        'use strict';
        var global = require('../../js/global/global');
        var setDocument;
        module.exports = function (setDoc) {
            if (setDoc) {
                setDocument = setDoc;
            }
            return setDocument || global().document;
        };
    }(function () {
        return this;
    }()));
});
/*can-util@3.9.6#dom/mutation-observer/mutation-observer*/
define('can-util@3.9.6#dom/mutation-observer/mutation-observer', function (require, exports, module) {
    (function (global) {
        'use strict';
        var global = require('../../js/global/global')();
        var setMutationObserver;
        module.exports = function (setMO) {
            if (setMO !== undefined) {
                setMutationObserver = setMO;
            }
            return setMutationObserver !== undefined ? setMutationObserver : global.MutationObserver || global.WebKitMutationObserver || global.MozMutationObserver;
        };
    }(function () {
        return this;
    }()));
});
/*can-cid@1.0.3#can-cid*/
define('can-cid@1.0.3#can-cid', function (require, exports, module) {
    var namespace = require('can-namespace');
    var _cid = 0;
    var cid = function (object, name) {
        if (!object._cid) {
            _cid++;
            object._cid = (name || '') + _cid;
        }
        return object._cid;
    };
    if (namespace.cid) {
        throw new Error('You can\'t have two versions of can-cid, check your dependencies');
    } else {
        module.exports = namespace.cid = cid;
    }
});
/*can-util@3.9.6#js/cid/get-cid*/
define('can-util@3.9.6#js/cid/get-cid', function (require, exports, module) {
    'use strict';
    var CID = require('can-cid');
    var domDataCore = require('../../dom/data/core');
    module.exports = function (obj) {
        if (typeof obj.nodeType === 'number') {
            return domDataCore.cid.call(obj);
        } else {
            var type = typeof obj;
            var isObject = type !== null && (type === 'object' || type === 'function');
            return type + ':' + (isObject ? CID(obj) : obj);
        }
    };
});
/*can-util@3.9.6#js/cid-set/cid-set*/
define('can-util@3.9.6#js/cid-set/cid-set', function (require, exports, module) {
    (function (global) {
        'use strict';
        var GLOBAL = require('../global/global');
        var each = require('../each/each');
        var getCID = require('../cid/get-cid');
        var CIDSet;
        if (GLOBAL().Set) {
            CIDSet = GLOBAL().Set;
        } else {
            var CIDSet = function () {
                this.values = {};
            };
            CIDSet.prototype.add = function (value) {
                this.values[getCID(value)] = value;
            };
            CIDSet.prototype['delete'] = function (key) {
                var has = getCID(key) in this.values;
                if (has) {
                    delete this.values[getCID(key)];
                }
                return has;
            };
            CIDSet.prototype.forEach = function (cb, thisArg) {
                each(this.values, cb, thisArg);
            };
            CIDSet.prototype.has = function (value) {
                return getCID(value) in this.values;
            };
            CIDSet.prototype.clear = function (key) {
                return this.values = {};
            };
            Object.defineProperty(CIDSet.prototype, 'size', {
                get: function () {
                    var size = 0;
                    each(this.values, function () {
                        size++;
                    });
                    return size;
                }
            });
        }
        module.exports = CIDSet;
    }(function () {
        return this;
    }()));
});
/*can-util@3.9.6#dom/mutation-observer/document/document*/
define('can-util@3.9.6#dom/mutation-observer/document/document', function (require, exports, module) {
    (function (global) {
        'use strict';
        var getDocument = require('../../document/document');
        var domDataCore = require('../../data/core');
        var MUTATION_OBSERVER = require('../../mutation-observer/mutation-observer');
        var each = require('../../../js/each/each');
        var CIDStore = require('../../../js/cid-set/cid-set');
        var makeArray = require('../../../js/make-array/make-array');
        var string = require('../../../js/string/string');
        var dispatchIfListening = function (mutatedNode, nodes, dispatched) {
            if (dispatched.has(mutatedNode)) {
                return true;
            }
            dispatched.add(mutatedNode);
            if (nodes.name === 'removedNodes') {
                var documentElement = getDocument().documentElement;
                if (documentElement.contains(mutatedNode)) {
                    return;
                }
            }
            nodes.handlers.forEach(function (handler) {
                handler(mutatedNode);
            });
            nodes.afterHandlers.forEach(function (handler) {
                handler(mutatedNode);
            });
        };
        var mutationObserverDocument = {
            add: function (handler) {
                var MO = MUTATION_OBSERVER();
                if (MO) {
                    var documentElement = getDocument().documentElement;
                    var globalObserverData = domDataCore.get.call(documentElement, 'globalObserverData');
                    if (!globalObserverData) {
                        var observer = new MO(function (mutations) {
                            globalObserverData.handlers.forEach(function (handler) {
                                handler(mutations);
                            });
                        });
                        observer.observe(documentElement, {
                            childList: true,
                            subtree: true
                        });
                        globalObserverData = {
                            observer: observer,
                            handlers: []
                        };
                        domDataCore.set.call(documentElement, 'globalObserverData', globalObserverData);
                    }
                    globalObserverData.handlers.push(handler);
                }
            },
            remove: function (handler) {
                var documentElement = getDocument().documentElement;
                var globalObserverData = domDataCore.get.call(documentElement, 'globalObserverData');
                if (globalObserverData) {
                    var index = globalObserverData.handlers.indexOf(handler);
                    if (index >= 0) {
                        globalObserverData.handlers.splice(index, 1);
                    }
                    if (globalObserverData.handlers.length === 0) {
                        globalObserverData.observer.disconnect();
                        domDataCore.clean.call(documentElement, 'globalObserverData');
                    }
                }
            }
        };
        var makeMutationMethods = function (name) {
            var mutationName = name.toLowerCase() + 'Nodes';
            var getMutationData = function () {
                var documentElement = getDocument().documentElement;
                var mutationData = domDataCore.get.call(documentElement, mutationName + 'MutationData');
                if (!mutationData) {
                    mutationData = {
                        name: mutationName,
                        handlers: [],
                        afterHandlers: [],
                        hander: null
                    };
                    if (MUTATION_OBSERVER()) {
                        domDataCore.set.call(documentElement, mutationName + 'MutationData', mutationData);
                    }
                }
                return mutationData;
            };
            var setup = function () {
                var mutationData = getMutationData();
                if (mutationData.handlers.length === 0 || mutationData.afterHandlers.length === 0) {
                    mutationData.handler = function (mutations) {
                        var dispatched = new CIDStore();
                        mutations.forEach(function (mutation) {
                            each(mutation[mutationName], function (mutatedNode) {
                                var children = mutatedNode.getElementsByTagName && makeArray(mutatedNode.getElementsByTagName('*'));
                                var alreadyChecked = dispatchIfListening(mutatedNode, mutationData, dispatched);
                                if (children && !alreadyChecked) {
                                    for (var j = 0, child; (child = children[j]) !== undefined; j++) {
                                        dispatchIfListening(child, mutationData, dispatched);
                                    }
                                }
                            });
                        });
                    };
                    this.add(mutationData.handler);
                }
                return mutationData;
            };
            var teardown = function () {
                var documentElement = getDocument().documentElement;
                var mutationData = getMutationData();
                if (mutationData.handlers.length === 0 && mutationData.afterHandlers.length === 0) {
                    this.remove(mutationData.handler);
                    domDataCore.clean.call(documentElement, mutationName + 'MutationData');
                }
            };
            var createOnOffHandlers = function (name, handlerList) {
                mutationObserverDocument['on' + name] = function (handler) {
                    var mutationData = setup.call(this);
                    mutationData[handlerList].push(handler);
                };
                mutationObserverDocument['off' + name] = function (handler) {
                    var mutationData = getMutationData();
                    var index = mutationData[handlerList].indexOf(handler);
                    if (index >= 0) {
                        mutationData[handlerList].splice(index, 1);
                    }
                    teardown.call(this);
                };
            };
            var createHandlers = function (name) {
                createOnOffHandlers(name, 'handlers');
                createOnOffHandlers('After' + name, 'afterHandlers');
            };
            createHandlers(string.capitalize(mutationName));
        };
        makeMutationMethods('added');
        makeMutationMethods('removed');
        module.exports = mutationObserverDocument;
    }(function () {
        return this;
    }()));
});
/*can-util@3.9.6#dom/data/data*/
define('can-util@3.9.6#dom/data/data', function (require, exports, module) {
    'use strict';
    var domDataCore = require('./core');
    var mutationDocument = require('../mutation-observer/document/document');
    var deleteNode = function () {
        return domDataCore.delete.call(this);
    };
    var elementSetCount = 0;
    var cleanupDomData = function (node) {
        elementSetCount -= deleteNode.call(node) ? 1 : 0;
        if (elementSetCount === 0) {
            mutationDocument.offAfterRemovedNodes(cleanupDomData);
        }
    };
    module.exports = {
        getCid: domDataCore.getCid,
        cid: domDataCore.cid,
        expando: domDataCore.expando,
        clean: domDataCore.clean,
        get: domDataCore.get,
        set: function (name, value) {
            if (elementSetCount === 0) {
                mutationDocument.onAfterRemovedNodes(cleanupDomData);
            }
            elementSetCount += domDataCore.set.call(this, name, value) ? 1 : 0;
        },
        delete: deleteNode
    };
});
/*can-util@3.9.6#dom/class-name/class-name*/
define('can-util@3.9.6#dom/class-name/class-name', function (require, exports, module) {
    'use strict';
    var has = function (className) {
        if (this.classList) {
            return this.classList.contains(className);
        } else {
            return !!this.className.match(new RegExp('(\\s|^)' + className + '(\\s|$)'));
        }
    };
    module.exports = {
        has: has,
        add: function (className) {
            if (this.classList) {
                this.classList.add(className);
            } else if (!has.call(this, className)) {
                this.className += ' ' + className;
            }
        },
        remove: function (className) {
            if (this.classList) {
                this.classList.remove(className);
            } else if (has.call(this, className)) {
                var reg = new RegExp('(\\s|^)' + className + '(\\s|$)');
                this.className = this.className.replace(reg, ' ');
            }
        }
    };
});
/*can-util@3.9.6#js/is-browser-window/is-browser-window*/
define('can-util@3.9.6#js/is-browser-window/is-browser-window', function (require, exports, module) {
    (function (global) {
        'use strict';
        module.exports = function () {
            return typeof window !== 'undefined' && typeof document !== 'undefined' && typeof SimpleDOM === 'undefined';
        };
    }(function () {
        return this;
    }()));
});
/*can-util@3.9.6#dom/events/events*/
define('can-util@3.9.6#dom/events/events', function (require, exports, module) {
    'use strict';
    var _document = require('../document/document');
    var isBrowserWindow = require('../../js/is-browser-window/is-browser-window');
    var isPlainObject = require('../../js/is-plain-object/is-plain-object');
    var fixSyntheticEventsOnDisabled = false;
    var dev = require('../../js/dev/dev');
    function isDispatchingOnDisabled(element, ev) {
        var isInsertedOrRemoved = isPlainObject(ev) ? ev.type === 'inserted' || ev.type === 'removed' : ev === 'inserted' || ev === 'removed';
        var isDisabled = !!element.disabled;
        return isInsertedOrRemoved && isDisabled;
    }
    module.exports = {
        addEventListener: function () {
            this.addEventListener.apply(this, arguments);
        },
        removeEventListener: function () {
            this.removeEventListener.apply(this, arguments);
        },
        canAddEventListener: function () {
            return this.nodeName && (this.nodeType === 1 || this.nodeType === 9) || this === window;
        },
        dispatch: function (event, args, bubbles) {
            var ret;
            var dispatchingOnDisabled = fixSyntheticEventsOnDisabled && isDispatchingOnDisabled(this, event);
            var doc = this.ownerDocument || _document();
            var ev = doc.createEvent('HTMLEvents');
            var isString = typeof event === 'string';
            ev.initEvent(isString ? event : event.type, bubbles === undefined ? true : bubbles, false);
            if (!isString) {
                for (var prop in event) {
                    if (ev[prop] === undefined) {
                        ev[prop] = event[prop];
                    }
                }
            }
            if (this.disabled === true && ev.type !== 'fix_synthetic_events_on_disabled_test') {
            }
            ev.args = args;
            if (dispatchingOnDisabled) {
                this.disabled = false;
            }
            ret = this.dispatchEvent(ev);
            if (dispatchingOnDisabled) {
                this.disabled = true;
            }
            return ret;
        }
    };
    (function () {
        if (!isBrowserWindow()) {
            return;
        }
        var testEventName = 'fix_synthetic_events_on_disabled_test';
        var input = document.createElement('input');
        input.disabled = true;
        var timer = setTimeout(function () {
            fixSyntheticEventsOnDisabled = true;
        }, 50);
        var onTest = function onTest() {
            clearTimeout(timer);
            module.exports.removeEventListener.call(input, testEventName, onTest);
        };
        module.exports.addEventListener.call(input, testEventName, onTest);
        try {
            module.exports.dispatch.call(input, testEventName, [], false);
        } catch (e) {
            onTest();
            fixSyntheticEventsOnDisabled = true;
        }
    }());
});
/*can-util@3.9.6#dom/dispatch/dispatch*/
define('can-util@3.9.6#dom/dispatch/dispatch', function (require, exports, module) {
    'use strict';
    var domEvents = require('../events/events');
    module.exports = function () {
        return domEvents.dispatch.apply(this, arguments);
    };
});
/*can-util@3.9.6#dom/matches/matches*/
define('can-util@3.9.6#dom/matches/matches', function (require, exports, module) {
    'use strict';
    var matchesMethod = function (element) {
        return element.matches || element.webkitMatchesSelector || element.webkitMatchesSelector || element.mozMatchesSelector || element.msMatchesSelector || element.oMatchesSelector;
    };
    module.exports = function () {
        var method = matchesMethod(this);
        return method ? method.apply(this, arguments) : false;
    };
});
/*can-util@3.9.6#dom/events/delegate/delegate*/
define('can-util@3.9.6#dom/events/delegate/delegate', function (require, exports, module) {
    'use strict';
    var domEvents = require('../events');
    var domData = require('../../data/data');
    var domMatches = require('../../matches/matches');
    var each = require('../../../js/each/each');
    var isEmptyObject = require('../../../js/is-empty-object/is-empty-object');
    var dataName = 'delegateEvents';
    var useCapture = function (eventType) {
        return eventType === 'focus' || eventType === 'blur';
    };
    var handleEvent = function (ev) {
        var events = domData.get.call(this, dataName);
        var eventTypeEvents = events[ev.type];
        var matches = [];
        if (eventTypeEvents) {
            var selectorDelegates = [];
            each(eventTypeEvents, function (delegates) {
                selectorDelegates.push(delegates);
            });
            var cur = ev.target;
            do {
                selectorDelegates.forEach(function (delegates) {
                    if (domMatches.call(cur, delegates[0].selector)) {
                        matches.push({
                            target: cur,
                            delegates: delegates
                        });
                    }
                });
                cur = cur.parentNode;
            } while (cur && cur !== ev.currentTarget);
        }
        var oldStopProp = ev.stopPropagation;
        ev.stopPropagation = function () {
            oldStopProp.apply(this, arguments);
            this.cancelBubble = true;
        };
        for (var i = 0; i < matches.length; i++) {
            var match = matches[i];
            var delegates = match.delegates;
            for (var d = 0, dLen = delegates.length; d < dLen; d++) {
                if (delegates[d].handler.call(match.target, ev) === false) {
                    return false;
                }
                if (ev.cancelBubble) {
                    return;
                }
            }
        }
    };
    domEvents.addDelegateListener = function (eventType, selector, handler) {
        var events = domData.get.call(this, dataName), eventTypeEvents;
        if (!events) {
            domData.set.call(this, dataName, events = {});
        }
        if (!(eventTypeEvents = events[eventType])) {
            eventTypeEvents = events[eventType] = {};
            domEvents.addEventListener.call(this, eventType, handleEvent, useCapture(eventType));
        }
        if (!eventTypeEvents[selector]) {
            eventTypeEvents[selector] = [];
        }
        eventTypeEvents[selector].push({
            handler: handler,
            selector: selector
        });
    };
    domEvents.removeDelegateListener = function (eventType, selector, handler) {
        var events = domData.get.call(this, dataName);
        if (events[eventType] && events[eventType][selector]) {
            var eventTypeEvents = events[eventType], delegates = eventTypeEvents[selector], i = 0;
            while (i < delegates.length) {
                if (delegates[i].handler === handler) {
                    delegates.splice(i, 1);
                } else {
                    i++;
                }
            }
            if (delegates.length === 0) {
                delete eventTypeEvents[selector];
                if (isEmptyObject(eventTypeEvents)) {
                    domEvents.removeEventListener.call(this, eventType, handleEvent, useCapture(eventType));
                    delete events[eventType];
                    if (isEmptyObject(events)) {
                        domData.clean.call(this, dataName);
                    }
                }
            }
        }
    };
});
/*can-util@3.9.6#js/single-reference/single-reference*/
define('can-util@3.9.6#js/single-reference/single-reference', function (require, exports, module) {
    (function (global) {
        var CID = require('can-cid');
        var singleReference;
        function getKeyName(key, extraKey) {
            var keyName = extraKey ? CID(key) + ':' + extraKey : CID(key);
            return keyName || key;
        }
        singleReference = {
            set: function (obj, key, value, extraKey) {
                obj[getKeyName(key, extraKey)] = value;
            },
            getAndDelete: function (obj, key, extraKey) {
                var keyName = getKeyName(key, extraKey);
                var value = obj[keyName];
                delete obj[keyName];
                return value;
            }
        };
        module.exports = singleReference;
    }(function () {
        return this;
    }()));
});
/*can-util@3.9.6#dom/events/delegate/enter-leave*/
define('can-util@3.9.6#dom/events/delegate/enter-leave', function (require, exports, module) {
    'use strict';
    var domEvents = require('../events'), singleRef = require('../../../js/single-reference/single-reference'), cid = require('../../../js/cid/get-cid');
    var eventMap = {
            mouseenter: 'mouseover',
            mouseleave: 'mouseout',
            pointerenter: 'pointerover',
            pointerleave: 'pointerout'
        }, classMap = {
            mouseenter: 'MouseEvent',
            mouseleave: 'MouseEvent',
            pointerenter: 'PointerEvent',
            pointerleave: 'PointerEvent'
        }, _addDelegateListener = domEvents.addDelegateListener, _removeDelegateListener = domEvents.removeDelegateListener;
    domEvents.addDelegateListener = function (eventType, selector, handler) {
        if (eventMap[eventType] !== undefined) {
            var origHandler = handler, origType = eventType;
            eventType = eventMap[eventType];
            handler = function (event) {
                var target = this, related = event.relatedTarget;
                if (!related || related !== target && !target.contains(related)) {
                    var eventClass = classMap[origType];
                    if (eventClass === 'MouseEvent') {
                        var newEv = document.createEvent(eventClass);
                        newEv.initMouseEvent(origType, false, false, event.view, event.detail, event.screenX, event.screenY, event.clientX, event.clientY, event.ctrlKey, event.altKey, event.shiftKey, event.metaKey, event.button, event.relatedTarget);
                        event = newEv;
                    } else if (eventClass === 'PointerEvent') {
                        event = new PointerEvent(origType, event);
                    }
                    return origHandler.call(this, event);
                }
            };
            singleRef.set(origHandler, cid(this) + eventType, handler);
        }
        _addDelegateListener.call(this, eventType, selector, handler);
    };
    domEvents.removeDelegateListener = function (eventType, selector, handler) {
        if (eventMap[eventType] !== undefined) {
            eventType = eventMap[eventType];
            handler = singleRef.getAndDelete(handler, cid(this) + eventType);
        }
        _removeDelegateListener.call(this, eventType, selector, handler);
    };
});
/*can-event@3.5.0#can-event*/
define('can-event@3.5.0#can-event', function (require, exports, module) {
    var domEvents = require('can-util/dom/events/events');
    var CID = require('can-cid');
    var isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');
    var domDispatch = require('can-util/dom/dispatch/dispatch');
    var namespace = require('can-namespace');
    require('can-util/dom/events/delegate/delegate');
    require('can-util/dom/events/delegate/enter-leave');
    function makeHandlerArgs(event, args) {
        if (typeof event === 'string') {
            event = { type: event };
        }
        var handlerArgs = [event];
        if (args) {
            handlerArgs.push.apply(handlerArgs, args);
        }
        return handlerArgs;
    }
    function getHandlers(eventName) {
        var events = this.__bindEvents;
        if (!events) {
            return;
        }
        return events[eventName];
    }
    var canEvent = {
        addEventListener: function (event, handler) {
            var allEvents = this.__bindEvents || (this.__bindEvents = {}), eventList = allEvents[event] || (allEvents[event] = []);
            eventList.push(handler);
            return this;
        },
        removeEventListener: function (event, fn) {
            if (!this.__bindEvents) {
                return this;
            }
            var handlers = this.__bindEvents[event] || [], i = 0, handler, isFunction = typeof fn === 'function';
            while (i < handlers.length) {
                handler = handlers[i];
                if (isFunction && handler === fn || !isFunction && (handler.cid === fn || !fn)) {
                    handlers.splice(i, 1);
                } else {
                    i++;
                }
            }
            return this;
        },
        dispatchSync: function (event, args) {
            var handlerArgs = makeHandlerArgs(event, args);
            var handlers = getHandlers.call(this, handlerArgs[0].type);
            if (!handlers) {
                return;
            }
            handlers = handlers.slice(0);
            for (var i = 0, len = handlers.length; i < len; i++) {
                handlers[i].apply(this, handlerArgs);
            }
            return handlerArgs[0];
        },
        on: function (eventName, selector, handler) {
            var method = typeof selector === 'string' ? 'addDelegateListener' : 'addEventListener';
            var listenWithDOM = domEvents.canAddEventListener.call(this);
            var eventBinder = listenWithDOM ? domEvents[method] : this[method] || canEvent[method];
            return eventBinder.apply(this, arguments);
        },
        off: function (eventName, selector, handler) {
            var method = typeof selector === 'string' ? 'removeDelegateListener' : 'removeEventListener';
            var listenWithDOM = domEvents.canAddEventListener.call(this);
            var eventBinder = listenWithDOM ? domEvents[method] : this[method] || canEvent[method];
            return eventBinder.apply(this, arguments);
        },
        trigger: function () {
            var listenWithDOM = domEvents.canAddEventListener.call(this);
            var dispatch = listenWithDOM ? domDispatch : canEvent.dispatch;
            return dispatch.apply(this, arguments);
        },
        one: function (event, handler) {
            var one = function () {
                canEvent.off.call(this, event, one);
                return handler.apply(this, arguments);
            };
            canEvent.on.call(this, event, one);
            return this;
        },
        listenTo: function (other, event, handler) {
            var idedEvents = this.__listenToEvents;
            if (!idedEvents) {
                idedEvents = this.__listenToEvents = {};
            }
            var otherId = CID(other);
            var othersEvents = idedEvents[otherId];
            if (!othersEvents) {
                othersEvents = idedEvents[otherId] = {
                    obj: other,
                    events: {}
                };
            }
            var eventsEvents = othersEvents.events[event];
            if (!eventsEvents) {
                eventsEvents = othersEvents.events[event] = [];
            }
            eventsEvents.push(handler);
            canEvent.on.call(other, event, handler);
        },
        stopListening: function (other, event, handler) {
            var idedEvents = this.__listenToEvents, iterIdedEvents = idedEvents, i = 0;
            if (!idedEvents) {
                return this;
            }
            if (other) {
                var othercid = CID(other);
                (iterIdedEvents = {})[othercid] = idedEvents[othercid];
                if (!idedEvents[othercid]) {
                    return this;
                }
            }
            for (var cid in iterIdedEvents) {
                var othersEvents = iterIdedEvents[cid], eventsEvents;
                other = idedEvents[cid].obj;
                if (!event) {
                    eventsEvents = othersEvents.events;
                } else {
                    (eventsEvents = {})[event] = othersEvents.events[event];
                }
                for (var eventName in eventsEvents) {
                    var handlers = eventsEvents[eventName] || [];
                    i = 0;
                    while (i < handlers.length) {
                        if (handler && handler === handlers[i] || !handler) {
                            canEvent.off.call(other, eventName, handlers[i]);
                            handlers.splice(i, 1);
                        } else {
                            i++;
                        }
                    }
                    if (!handlers.length) {
                        delete othersEvents.events[eventName];
                    }
                }
                if (isEmptyObject(othersEvents.events)) {
                    delete idedEvents[cid];
                }
            }
            return this;
        }
    };
    canEvent.addEvent = canEvent.bind = function () {
        return canEvent.addEventListener.apply(this, arguments);
    };
    canEvent.unbind = canEvent.removeEvent = function () {
        return canEvent.removeEventListener.apply(this, arguments);
    };
    canEvent.delegate = canEvent.on;
    canEvent.undelegate = canEvent.off;
    canEvent.dispatch = canEvent.dispatchSync;
    Object.defineProperty(canEvent, 'makeHandlerArgs', {
        enumerable: false,
        value: makeHandlerArgs
    });
    Object.defineProperty(canEvent, 'handlers', {
        enumerable: false,
        value: getHandlers
    });
    Object.defineProperty(canEvent, 'flush', {
        enumerable: false,
        writable: true,
        value: function () {
        }
    });
    module.exports = namespace.event = canEvent;
});
/*can-util@3.9.6#js/last/last*/
define('can-util@3.9.6#js/last/last', function (require, exports, module) {
    'use strict';
    module.exports = function (arr) {
        return arr && arr[arr.length - 1];
    };
});
/*can-event@3.5.0#batch/batch*/
define('can-event@3.5.0#batch/batch', function (require, exports, module) {
    'use strict';
    var canEvent = require('../can-event');
    var last = require('can-util/js/last/last');
    var namespace = require('can-namespace');
    var canTypes = require('can-types');
    var canDev = require('can-util/js/dev/dev');
    var canLog = require('can-util/js/log/log');
    var batchNum = 1, collectionQueue = null, queues = [], dispatchingQueues = false, makeHandlerArgs = canEvent.makeHandlerArgs, getHandlers = canEvent.handlers;
    function addToCollectionQueue(item, event, args, handlers) {
        var handlerArgs = makeHandlerArgs(event, args);
        var tasks = [];
        for (var i = 0, len = handlers.length; i < len; i++) {
            tasks[i] = [
                handlers[i],
                item,
                handlerArgs
            ];
        }
        [].push.apply(collectionQueue.tasks, tasks);
    }
    var canBatch = {
        transactions: 0,
        start: function (batchStopHandler) {
            canBatch.transactions++;
            if (canBatch.transactions === 1) {
                var queue = {
                    number: batchNum++,
                    index: 0,
                    tasks: [],
                    batchEnded: false,
                    callbacksIndex: 0,
                    callbacks: [],
                    complete: false
                };
                if (batchStopHandler) {
                    queue.callbacks.push(batchStopHandler);
                }
                collectionQueue = queue;
            }
        },
        collecting: function () {
            return collectionQueue;
        },
        dispatching: function () {
            return queues[0];
        },
        stop: function (force, callStart) {
            if (force) {
                canBatch.transactions = 0;
            } else {
                canBatch.transactions--;
            }
            if (canBatch.transactions === 0) {
                queues.push(collectionQueue);
                collectionQueue = null;
                if (!dispatchingQueues) {
                    canEvent.flush();
                }
            }
        },
        flush: function () {
            dispatchingQueues = true;
            while (queues.length) {
                var queue = queues[0];
                var tasks = queue.tasks, callbacks = queue.callbacks;
                canBatch.batchNum = queue.number;
                var len = tasks.length;
                while (queue.index < len) {
                    var task = tasks[queue.index++];
                    task[0].apply(task[1], task[2]);
                }
                if (!queue.batchEnded) {
                    queue.batchEnded = true;
                    canEvent.dispatchSync.call(canBatch, 'batchEnd', [queue.number]);
                }
                while (queue.callbacksIndex < callbacks.length) {
                    callbacks[queue.callbacksIndex++]();
                }
                if (!queue.complete) {
                    queue.complete = true;
                    canBatch.batchNum = undefined;
                    queues.shift();
                }
            }
            dispatchingQueues = false;
        },
        dispatch: function (event, args) {
            var item = this, handlers;
            if (!item.__inSetup) {
                event = typeof event === 'string' ? { type: event } : event;
                if (event.batchNum) {
                    canBatch.batchNum = event.batchNum;
                    canEvent.dispatchSync.call(item, event, args);
                } else if (collectionQueue) {
                    handlers = getHandlers.call(this, event.type);
                    if (handlers) {
                        event.batchNum = collectionQueue.number;
                        addToCollectionQueue(item, event, args, handlers);
                    }
                } else if (queues.length) {
                    handlers = getHandlers.call(this, event.type);
                    if (handlers) {
                        canBatch.start();
                        event.batchNum = collectionQueue.number;
                        addToCollectionQueue(item, event, args, handlers);
                        last(queues).callbacks.push(canBatch.stop);
                    }
                } else {
                    handlers = getHandlers.call(this, event.type);
                    if (handlers) {
                        canBatch.start();
                        event.batchNum = collectionQueue.number;
                        addToCollectionQueue(item, event, args, handlers);
                        canBatch.stop();
                    }
                }
            }
        },
        queue: function (task, inCurrentBatch) {
            if (collectionQueue) {
                collectionQueue.tasks.push(task);
            } else if (queues.length) {
                if (inCurrentBatch && queues[0].index < queues.tasks.length) {
                    queues[0].tasks.push(task);
                } else {
                    canBatch.start();
                    collectionQueue.tasks.push(task);
                    last(queues).callbacks.push(canBatch.stop);
                }
            } else {
                canBatch.start();
                collectionQueue.tasks.push(task);
                canBatch.stop();
            }
        },
        queues: function () {
            return queues;
        },
        afterPreviousEvents: function (handler) {
            this.queue([handler]);
        },
        after: function (handler) {
            var queue = collectionQueue || queues[0];
            if (queue) {
                queue.callbacks.push(handler);
            } else {
                handler({});
            }
        }
    };
    canEvent.flush = canBatch.flush;
    canEvent.dispatch = canBatch.dispatch;
    canBatch.trigger = function () {
        canLog.warn('use canEvent.dispatch instead');
        return canEvent.dispatch.apply(this, arguments);
    };
    canTypes.queueTask = canBatch.queue;
    if (namespace.batch) {
        throw new Error('You can\'t have two versions of can-event/batch/batch, check your dependencies');
    } else {
        module.exports = namespace.batch = canBatch;
    }
});
/*can-util@3.9.6#js/cid-map/cid-map*/
define('can-util@3.9.6#js/cid-map/cid-map', function (require, exports, module) {
    (function (global) {
        'use strict';
        var GLOBAL = require('../global/global');
        var each = require('../each/each');
        var getCID = require('../cid/get-cid');
        var CIDMap;
        if (GLOBAL().Map) {
            CIDMap = GLOBAL().Map;
        } else {
            var CIDMap = function () {
                this.values = {};
            };
            CIDMap.prototype.set = function (key, value) {
                this.values[getCID(key)] = {
                    key: key,
                    value: value
                };
            };
            CIDMap.prototype['delete'] = function (key) {
                var has = getCID(key) in this.values;
                if (has) {
                    delete this.values[getCID(key)];
                }
                return has;
            };
            CIDMap.prototype.forEach = function (cb, thisArg) {
                each(this.values, function (pair) {
                    return cb.call(thisArg || this, pair.value, pair.key, this);
                }, this);
            };
            CIDMap.prototype.has = function (key) {
                return getCID(key) in this.values;
            };
            CIDMap.prototype.get = function (key) {
                var obj = this.values[getCID(key)];
                return obj && obj.value;
            };
            CIDMap.prototype.clear = function (key) {
                return this.values = {};
            };
            Object.defineProperty(CIDMap.prototype, 'size', {
                get: function () {
                    var size = 0;
                    each(this.values, function () {
                        size++;
                    });
                    return size;
                }
            });
        }
        module.exports = CIDMap;
    }(function () {
        return this;
    }()));
});
/*can-observation@3.3.1#can-observation*/
define('can-observation@3.3.1#can-observation', function (require, exports, module) {
    (function (global) {
        require('can-event');
        var canEvent = require('can-event');
        var canBatch = require('can-event/batch/batch');
        var assign = require('can-util/js/assign/assign');
        var isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');
        var namespace = require('can-namespace');
        var canLog = require('can-util/js/log/log');
        var canReflect = require('can-reflect');
        var canSymbol = require('can-symbol');
        var CID = require('can-cid');
        var CIDMap = require('can-util/js/cid-map/cid-map');
        var CIDSet = require('can-util/js/cid-set/cid-set');
        function Observation(func, context, compute) {
            this.newObserved = {};
            this.oldObserved = null;
            this.func = func;
            this.context = context;
            this.compute = compute && (compute.updater || 'isObservable' in compute) ? compute : { updater: compute };
            this.isObservable = typeof compute === 'object' ? compute.isObservable : true;
            var observation = this;
            this.onDependencyChange = function (value, legacyValue) {
                observation.dependencyChange(this, value, legacyValue);
            };
            this.ignore = 0;
            this.needsUpdate = false;
            this.handlers = null;
            CID(this);
        }
        var observationStack = [];
        Observation.observationStack = observationStack;
        var remaining = {
            updates: 0,
            notifications: 0
        };
        Observation.remaining = remaining;
        assign(Observation.prototype, {
            get: function () {
                if (this.isObservable && Observation.isRecording()) {
                    Observation.add(this);
                    if (!this.bound) {
                        Observation.temporarilyBind(this);
                    }
                }
                if (this.bound === true) {
                    canEvent.flush();
                    if (remaining.updates > 0) {
                        Observation.updateChildrenAndSelf(this);
                    }
                    return this.value;
                } else {
                    return this.func.call(this.context);
                }
            },
            getPrimaryDepth: function () {
                return this.compute._primaryDepth || 0;
            },
            addEdge: function (objEv) {
                if (objEv.event === 'undefined') {
                    canReflect.onValue(objEv.obj, this.onDependencyChange);
                } else {
                    canReflect.onKeyValue(objEv.obj, objEv.event, this.onDependencyChange);
                }
            },
            removeEdge: function (objEv) {
                if (objEv.event === 'undefined') {
                    canReflect.offValue(objEv.obj, this.onDependencyChange);
                } else {
                    canReflect.offKeyValue(objEv.obj, objEv.event, this.onDependencyChange);
                }
            },
            dependencyChange: function () {
                if (this.bound === true) {
                    if (canBatch.batchNum === undefined || canBatch.batchNum !== this.batchNum) {
                        Observation.registerUpdate(this, canBatch.batchNum);
                        this.batchNum = canBatch.batchNum;
                    }
                }
            },
            onDependencyChange: function (value) {
                this.dependencyChange(value);
            },
            update: function (batchNum) {
                if (this.needsUpdate === true) {
                    remaining.updates--;
                }
                this.needsUpdate = false;
                if (this.bound === true) {
                    var oldValue = this.value;
                    this.oldValue = null;
                    this.start();
                    if (oldValue !== this.value) {
                        this.compute.updater(this.value, oldValue, batchNum);
                        return true;
                    }
                }
            },
            getValueAndBind: function () {
                canLog.warn('can-observation: call start instead of getValueAndBind');
                return this.start();
            },
            start: function () {
                this.bound = true;
                this.oldObserved = this.newObserved || {};
                this.ignore = 0;
                this.newObserved = {};
                observationStack.push(this);
                this.value = this.func.call(this.context);
                observationStack.pop();
                this.updateBindings();
            },
            updateBindings: function () {
                var newObserved = this.newObserved, oldObserved = this.oldObserved, name, obEv;
                for (name in newObserved) {
                    obEv = newObserved[name];
                    if (!oldObserved[name]) {
                        this.addEdge(obEv);
                    } else {
                        oldObserved[name] = undefined;
                    }
                }
                for (name in oldObserved) {
                    obEv = oldObserved[name];
                    if (obEv !== undefined) {
                        this.removeEdge(obEv);
                    }
                }
            },
            teardown: function () {
                canLog.warn('can-observation: call stop instead of teardown');
                return this.stop();
            },
            stop: function () {
                this.bound = false;
                for (var name in this.newObserved) {
                    var ob = this.newObserved[name];
                    this.removeEdge(ob);
                }
                this.newObserved = {};
            }
        });
        var updateOrder = [], curPrimaryDepth = Infinity, maxPrimaryDepth = 0, currentBatchNum, isUpdating = false;
        var updateUpdateOrder = function (observation) {
            var primaryDepth = observation.getPrimaryDepth();
            if (primaryDepth < curPrimaryDepth) {
                curPrimaryDepth = primaryDepth;
            }
            if (primaryDepth > maxPrimaryDepth) {
                maxPrimaryDepth = primaryDepth;
            }
            var primary = updateOrder[primaryDepth] || (updateOrder[primaryDepth] = []);
            return primary;
        };
        Observation.registerUpdate = function (observation, batchNum) {
            if (observation.needsUpdate === true) {
                return;
            }
            remaining.updates++;
            observation.needsUpdate = true;
            var objs = updateUpdateOrder(observation);
            objs.push(observation);
        };
        var afterCallbacks = [];
        Observation.updateAndNotify = function (ev, batchNum) {
            currentBatchNum = batchNum;
            if (isUpdating === true) {
                return;
            }
            isUpdating = true;
            while (true) {
                if (curPrimaryDepth <= maxPrimaryDepth) {
                    var primary = updateOrder[curPrimaryDepth];
                    var lastUpdate = primary && primary.pop();
                    if (lastUpdate !== undefined) {
                        lastUpdate.update(currentBatchNum);
                    } else {
                        curPrimaryDepth++;
                    }
                } else {
                    updateOrder = [];
                    curPrimaryDepth = Infinity;
                    maxPrimaryDepth = 0;
                    isUpdating = false;
                    var afterCB = afterCallbacks;
                    afterCallbacks = [];
                    afterCB.forEach(function (cb) {
                        cb();
                    });
                    return;
                }
            }
        };
        canEvent.addEventListener.call(canBatch, 'batchEnd', Observation.updateAndNotify);
        Observation.afterUpdateAndNotify = function (callback) {
            canBatch.after(function () {
                if (isUpdating === true) {
                    afterCallbacks.push(callback);
                } else {
                    callback();
                }
            });
        };
        Observation.updateChildrenAndSelf = function (observation) {
            if (observation.needsUpdate === true) {
                return Observation.unregisterAndUpdate(observation);
            }
            var childHasChanged = false;
            for (var prop in observation.newObserved) {
                if (observation.newObserved[prop].obj.observation) {
                    if (Observation.updateChildrenAndSelf(observation.newObserved[prop].obj.observation)) {
                        childHasChanged = true;
                    }
                }
            }
            if (childHasChanged === true) {
                return observation.update(currentBatchNum);
            }
        };
        Observation.unregisterAndUpdate = function (observation) {
            var primaryDepth = observation.getPrimaryDepth();
            var primary = updateOrder[primaryDepth];
            if (primary !== undefined) {
                var index = primary.indexOf(observation);
                if (index !== -1) {
                    primary.splice(index, 1);
                }
            }
            return observation.update(currentBatchNum);
        };
        Observation.add = function (obj, event) {
            var top = observationStack[observationStack.length - 1];
            if (top !== undefined && !top.ignore) {
                var evStr = event + '', name = obj._cid + '|' + evStr;
                if (top.traps !== undefined) {
                    top.traps.push({
                        obj: obj,
                        event: evStr,
                        name: name
                    });
                } else {
                    top.newObserved[name] = {
                        obj: obj,
                        event: evStr
                    };
                }
            }
        };
        Observation.addAll = function (observes) {
            var top = observationStack[observationStack.length - 1];
            if (top !== undefined) {
                if (top.traps !== undefined) {
                    top.traps.push.apply(top.traps, observes);
                } else {
                    for (var i = 0, len = observes.length; i < len; i++) {
                        var trap = observes[i], name = trap.name;
                        if (top.newObserved[name] === undefined) {
                            top.newObserved[name] = trap;
                        }
                    }
                }
            }
        };
        Observation.ignore = function (fn) {
            return function () {
                if (observationStack.length > 0) {
                    var top = observationStack[observationStack.length - 1];
                    top.ignore++;
                    var res = fn.apply(this, arguments);
                    top.ignore--;
                    return res;
                } else {
                    return fn.apply(this, arguments);
                }
            };
        };
        Observation.trap = function () {
            if (observationStack.length > 0) {
                var top = observationStack[observationStack.length - 1];
                var oldTraps = top.traps;
                var traps = top.traps = [];
                return function () {
                    top.traps = oldTraps;
                    return traps;
                };
            } else {
                return function () {
                    return [];
                };
            }
        };
        Observation.trapsCount = function () {
            if (observationStack.length > 0) {
                var top = observationStack[observationStack.length - 1];
                return top.traps.length;
            } else {
                return 0;
            }
        };
        Observation.isRecording = function () {
            var len = observationStack.length;
            var last = len > 0 && observationStack[len - 1];
            return last && last.ignore === 0 && last;
        };
        var noop = function () {
        };
        var observables;
        var unbindComputes = function () {
            for (var i = 0, len = observables.length; i < len; i++) {
                canReflect.offValue(observables[i], noop);
            }
            observables = null;
        };
        Observation.temporarilyBind = function (compute) {
            var computeInstance = compute.computeInstance || compute;
            canReflect.onValue(computeInstance, noop);
            if (!observables) {
                observables = [];
                setTimeout(unbindComputes, 10);
            }
            observables.push(computeInstance);
        };
        var callHandlers = function (newValue) {
            this.handlers.forEach(function (handler) {
                handler.call(this.compute, newValue);
            }, this);
        };
        canReflect.set(Observation.prototype, canSymbol.for('can.onValue'), function (handler) {
            if (!this.handlers) {
                this.handlers = [];
                this.compute.updater = callHandlers.bind(this);
                this.start();
            }
            this.handlers.push(handler);
        });
        canReflect.set(Observation.prototype, canSymbol.for('can.offValue'), function (handler) {
            if (this.handlers) {
                var index = this.handlers.indexOf(handler);
                this.handlers.splice(index, 1);
                if (this.handlers.length === 0) {
                    this.stop();
                }
            }
        });
        canReflect.set(Observation.prototype, canSymbol.for('can.getValue'), Observation.prototype.get);
        Observation.prototype.hasDependencies = function () {
            return this.bound ? !isEmptyObject(this.newObserved) : undefined;
        };
        canReflect.set(Observation.prototype, canSymbol.for('can.isValueLike'), true);
        canReflect.set(Observation.prototype, canSymbol.for('can.isMapLike'), false);
        canReflect.set(Observation.prototype, canSymbol.for('can.isListLike'), false);
        canReflect.set(Observation.prototype, canSymbol.for('can.valueHasDependencies'), Observation.prototype.hasDependencies);
        canReflect.set(Observation.prototype, canSymbol.for('can.getValueDependencies'), function () {
            var rets;
            if (this.bound === true) {
                rets = {};
                canReflect.eachKey(this.newObserved || {}, function (dep) {
                    if (canReflect.isValueLike(dep.obj)) {
                        rets.valueDependencies = rets.valueDependencies || new CIDSet();
                        rets.valueDependencies.add(dep.obj);
                    } else {
                        rets.keyDependencies = rets.keyDependencies || new CIDMap();
                        if (rets.keyDependencies.get(dep.obj)) {
                            rets.keyDependencies.get(dep.obj).push(dep.event);
                        } else {
                            rets.keyDependencies.set(dep.obj, [dep.event]);
                        }
                    }
                });
            }
            return rets;
        });
        if (namespace.Observation) {
            throw new Error('You can\'t have two versions of can-observation, check your dependencies');
        } else {
            module.exports = namespace.Observation = Observation;
        }
    }(function () {
        return this;
    }()));
});
/*can-event@3.5.0#lifecycle/lifecycle*/
define('can-event@3.5.0#lifecycle/lifecycle', function (require, exports, module) {
    var canEvent = require('can-event');
    var lifecycle = function (prototype) {
        var baseAddEventListener = prototype.addEventListener;
        var baseRemoveEventListener = prototype.removeEventListener;
        prototype.addEventListener = function () {
            var ret = baseAddEventListener.apply(this, arguments);
            if (!this.__inSetup) {
                this.__bindEvents = this.__bindEvents || {};
                if (!this.__bindEvents._lifecycleBindings) {
                    this.__bindEvents._lifecycleBindings = 1;
                    if (this._eventSetup) {
                        this._eventSetup();
                    }
                } else {
                    this.__bindEvents._lifecycleBindings++;
                }
            }
            return ret;
        };
        prototype.removeEventListener = function (event, handler) {
            if (!this.__bindEvents) {
                return this;
            }
            var handlers = this.__bindEvents[event] || [];
            var handlerCount = handlers.length;
            var ret = baseRemoveEventListener.apply(this, arguments);
            if (this.__bindEvents._lifecycleBindings === null) {
                this.__bindEvents._lifecycleBindings = 0;
            } else {
                this.__bindEvents._lifecycleBindings -= handlerCount - handlers.length;
            }
            if (!this.__bindEvents._lifecycleBindings && this._eventTeardown) {
                this._eventTeardown();
            }
            return ret;
        };
        return prototype;
    };
    var baseEvents = lifecycle({
        addEventListener: canEvent.addEventListener,
        removeEventListener: canEvent.removeEventListener
    });
    lifecycle.addAndSetup = baseEvents.addEventListener;
    lifecycle.removeAndTeardown = baseEvents.removeEventListener;
    module.exports = lifecycle;
});
/*can-util@3.9.6#js/is-promise-like/is-promise-like*/
define('can-util@3.9.6#js/is-promise-like/is-promise-like', function (require, exports, module) {
    'use strict';
    module.exports = function (obj) {
        return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';
    };
});
/*can-reflect-promise@1.1.0#can-reflect-promise*/
define('can-reflect-promise@1.1.0#can-reflect-promise', function (require, exports, module) {
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var dev = require('can-util/js/dev/dev');
    var Observation = require('can-observation');
    var CID = require('can-cid');
    var assign = require('can-util/js/assign/assign');
    var canEvent = require('can-event');
    var singleReference = require('can-util/js/single-reference/single-reference');
    var getValueSymbol = canSymbol.for('can.getValue'), getKeyValueSymbol = canSymbol.for('can.getKeyValue'), onValueSymbol = canSymbol.for('can.onValue'), onKeyValueSymbol = canSymbol.for('can.onKeyValue'), offKeyValueSymbol = canSymbol.for('can.offKeyValue'), observeDataSymbol = canSymbol.for('can.observeData');
    var promiseDataPrototype = {
        isPending: true,
        state: 'pending',
        isResolved: false,
        isRejected: false,
        value: undefined,
        reason: undefined
    };
    assign(promiseDataPrototype, canEvent);
    canReflect.set(promiseDataPrototype, onKeyValueSymbol, function (key, handler) {
        var observeData = this;
        var translated = function () {
            handler(observeData[key]);
        };
        singleReference.set(handler, this, translated, key);
        canEvent.on.call(this, 'state', translated);
    });
    canReflect.set(promiseDataPrototype, offKeyValueSymbol, function (key, handler) {
        var translated = singleReference.getAndDelete(handler, this, key);
        canEvent.off.call(this, 'state', translated);
    });
    function initPromise(promise) {
        var observeData = promise[observeDataSymbol];
        if (!observeData) {
            Object.defineProperty(promise, observeDataSymbol, {
                enumerable: false,
                configurable: false,
                writable: false,
                value: Object.create(promiseDataPrototype)
            });
            observeData = promise[observeDataSymbol];
            CID(observeData);
        }
        promise.then(function (value) {
            observeData.isPending = false;
            observeData.isResolved = true;
            observeData.value = value;
            observeData.state = 'resolved';
            observeData.dispatch('state', [
                'resolved',
                'pending'
            ]);
        }, function (reason) {
            observeData.isPending = false;
            observeData.isRejected = true;
            observeData.reason = reason;
            observeData.state = 'rejected';
            observeData.dispatch('state', [
                'rejected',
                'pending'
            ]);
        });
    }
    function setupPromise(value) {
        var oldPromiseFn;
        var proto = 'getPrototypeOf' in Object ? Object.getPrototypeOf(value) : value.__proto__;
        if (value[getKeyValueSymbol] && value[observeDataSymbol]) {
            return;
        }
        if (proto === null || proto === Object.prototype) {
            proto = value;
            if (typeof proto.promise === 'function') {
                oldPromiseFn = proto.promise;
                proto.promise = function () {
                    var result = oldPromiseFn.call(proto);
                    setupPromise(result);
                    return result;
                };
            }
        }
        [
            getKeyValueSymbol,
            function (key) {
                if (!this[observeDataSymbol]) {
                    initPromise(this);
                }
                Observation.add(this[observeDataSymbol], 'state');
                switch (key) {
                case 'state':
                case 'isPending':
                case 'isResolved':
                case 'isRejected':
                case 'value':
                case 'reason':
                    return this[observeDataSymbol][key];
                default:
                    return this[key];
                }
            },
            getValueSymbol,
            function () {
                return this[getKeyValueSymbol]('value');
            },
            canSymbol.for('can.isValueLike'),
            false,
            onValueSymbol,
            function (handler) {
                return this[onKeyValueSymbol]('value', handler);
            },
            onKeyValueSymbol,
            function (key, handler) {
                if (!this[observeDataSymbol]) {
                    initPromise(this);
                }
                var promise = this;
                var translated = function () {
                    handler(promise[getKeyValueSymbol](key));
                };
                singleReference.set(handler, this, translated, key);
                canEvent.on.call(this[observeDataSymbol], 'state', translated);
            },
            canSymbol.for('can.offValue'),
            function (handler) {
                return this[offKeyValueSymbol]('value', handler);
            },
            offKeyValueSymbol,
            function (key, handler) {
                var translated = singleReference.getAndDelete(handler, this, key);
                if (translated) {
                    canEvent.off.call(this[observeDataSymbol], 'state', translated);
                }
            }
        ].forEach(function (symbol, index, list) {
            if (index % 2 === 0) {
                canReflect.set(proto, symbol, list[index + 1]);
            }
        });
    }
    module.exports = setupPromise;
});
/*can-stache-key@0.0.2#can-stache-key*/
define('can-stache-key@0.0.2#can-stache-key', function (require, exports, module) {
    var Observation = require('can-observation');
    var dev = require('can-util/js/dev/dev');
    var each = require('can-util/js/each/each');
    var canSymbol = require('can-symbol');
    var canReflect = require('can-reflect');
    var isPromiseLike = require('can-util/js/is-promise-like/is-promise-like');
    var canReflectPromise = require('can-reflect-promise');
    var getValueSymbol = canSymbol.for('can.getValue');
    var setValueSymbol = canSymbol.for('can.setValue');
    var isValueLikeSymbol = canSymbol.for('can.isValueLike');
    var observeReader;
    var isAt = function (index, reads) {
        var prevRead = reads[index - 1];
        return prevRead && prevRead.at;
    };
    var readValue = function (value, index, reads, options, state, prev) {
        var usedValueReader;
        do {
            usedValueReader = false;
            for (var i = 0, len = observeReader.valueReaders.length; i < len; i++) {
                if (observeReader.valueReaders[i].test(value, index, reads, options)) {
                    value = observeReader.valueReaders[i].read(value, index, reads, options, state, prev);
                }
            }
        } while (usedValueReader);
        return value;
    };
    var specialRead = {
        index: true,
        key: true,
        event: true,
        element: true,
        viewModel: true
    };
    var checkForObservableAndNotify = function (options, state, getObserves, value, index) {
        if (options.foundObservable && !state.foundObservable) {
            if (Observation.trapsCount()) {
                Observation.addAll(getObserves());
                options.foundObservable(value, index);
                state.foundObservable = true;
            }
        }
    };
    observeReader = {
        read: function (parent, reads, options) {
            options = options || {};
            var state = { foundObservable: false };
            var getObserves;
            if (options.foundObservable) {
                getObserves = Observation.trap();
            }
            var cur = readValue(parent, 0, reads, options, state), type, prev, readLength = reads.length, i = 0, last;
            checkForObservableAndNotify(options, state, getObserves, parent, 0);
            while (i < readLength) {
                prev = cur;
                for (var r = 0, readersLength = observeReader.propertyReaders.length; r < readersLength; r++) {
                    var reader = observeReader.propertyReaders[r];
                    if (reader.test(cur)) {
                        cur = reader.read(cur, reads[i], i, options, state);
                        break;
                    }
                }
                checkForObservableAndNotify(options, state, getObserves, prev, i);
                last = cur;
                i = i + 1;
                cur = readValue(cur, i, reads, options, state, prev);
                checkForObservableAndNotify(options, state, getObserves, prev, i - 1);
                type = typeof cur;
                if (i < reads.length && (cur === null || cur === undefined)) {
                    if (options.earlyExit) {
                        options.earlyExit(prev, i - 1, cur);
                    }
                    return {
                        value: undefined,
                        parent: prev
                    };
                }
            }
            if (cur === undefined) {
                if (options.earlyExit) {
                    options.earlyExit(prev, i - 1);
                }
            }
            return {
                value: cur,
                parent: prev
            };
        },
        get: function (parent, reads, options) {
            return observeReader.read(parent, observeReader.reads(reads), options || {}).value;
        },
        valueReadersMap: {},
        valueReaders: [
            {
                name: 'function',
                test: function (value) {
                    return value && canReflect.isFunctionLike(value) && !canReflect.isConstructorLike(value);
                },
                read: function (value, i, reads, options, state, prev) {
                    if (isAt(i, reads)) {
                        return i === reads.length ? value.bind(prev) : value;
                    } else if (options.callMethodsOnObservables && canReflect.isObservableLike(prev) && canReflect.isMapLike(prev)) {
                        return value.apply(prev, options.args || []);
                    } else if (options.isArgument && i === reads.length) {
                        return options.proxyMethods !== false ? value.bind(prev) : value;
                    }
                    return value.apply(prev, options.args || []);
                }
            },
            {
                name: 'isValueLike',
                test: function (value, i, reads, options) {
                    return value && value[getValueSymbol] && value[isValueLikeSymbol] !== false && (options.foundAt || !isAt(i, reads));
                },
                read: function (value, i, reads, options) {
                    if (options.readCompute === false && i === reads.length) {
                        return value;
                    }
                    return canReflect.getValue(value);
                },
                write: function (base, newVal) {
                    if (base[setValueSymbol]) {
                        base[setValueSymbol](newVal);
                    } else if (base.set) {
                        base.set(newVal);
                    } else {
                        base(newVal);
                    }
                }
            }
        ],
        propertyReadersMap: {},
        propertyReaders: [
            {
                name: 'map',
                test: function (value) {
                    if (isPromiseLike(value) || typeof value === 'object' && typeof value.then === 'function') {
                        canReflectPromise(value);
                    }
                    return canReflect.isObservableLike(value) && canReflect.isMapLike(value);
                },
                read: function (value, prop) {
                    var res = canReflect.getKeyValue(value, prop.key);
                    if (res !== undefined) {
                        return res;
                    } else {
                        return value[prop.key];
                    }
                },
                write: canReflect.setKeyValue
            },
            {
                name: 'object',
                test: function () {
                    return true;
                },
                read: function (value, prop, i, options) {
                    if (value == null) {
                        return undefined;
                    } else {
                        if (typeof value === 'object') {
                            if (prop.key in value) {
                                return value[prop.key];
                            } else if (prop.at && specialRead[prop.key] && '@' + prop.key in value) {
                                options.foundAt = true;
                                return value['@' + prop.key];
                            }
                        } else {
                            return value[prop.key];
                        }
                    }
                },
                write: function (base, prop, newVal) {
                    base[prop] = newVal;
                }
            }
        ],
        reads: function (keyArg) {
            var key = '' + keyArg;
            var keys = [];
            var last = 0;
            var at = false;
            if (key.charAt(0) === '@') {
                last = 1;
                at = true;
            }
            var keyToAdd = '';
            for (var i = last; i < key.length; i++) {
                var character = key.charAt(i);
                if (character === '.' || character === '@') {
                    if (key.charAt(i - 1) !== '\\') {
                        keys.push({
                            key: keyToAdd,
                            at: at
                        });
                        at = character === '@';
                        keyToAdd = '';
                    } else {
                        keyToAdd = keyToAdd.substr(0, keyToAdd.length - 1) + '.';
                    }
                } else {
                    keyToAdd += character;
                }
            }
            keys.push({
                key: keyToAdd,
                at: at
            });
            return keys;
        },
        write: function (parent, key, value, options) {
            var keys = typeof key === 'string' ? observeReader.reads(key) : key;
            var last;
            options = options || {};
            if (keys.length > 1) {
                last = keys.pop();
                parent = observeReader.read(parent, keys, options).value;
                keys.push(last);
            } else {
                last = keys[0];
            }
            if (observeReader.valueReadersMap.isValueLike.test(parent[last.key], keys.length - 1, keys, options)) {
                observeReader.valueReadersMap.isValueLike.write(parent[last.key], value, options);
            } else {
                if (observeReader.valueReadersMap.isValueLike.test(parent, keys.length - 1, keys, options)) {
                    parent = parent[getValueSymbol]();
                }
                if (observeReader.propertyReadersMap.map.test(parent)) {
                    observeReader.propertyReadersMap.map.write(parent, last.key, value, options);
                } else if (observeReader.propertyReadersMap.object.test(parent)) {
                    observeReader.propertyReadersMap.object.write(parent, last.key, value, options);
                    if (options.observation) {
                        options.observation.update();
                    }
                }
            }
        }
    };
    each(observeReader.propertyReaders, function (reader) {
        observeReader.propertyReadersMap[reader.name] = reader;
    });
    each(observeReader.valueReaders, function (reader) {
        observeReader.valueReadersMap[reader.name] = reader;
    });
    observeReader.set = observeReader.write;
    module.exports = observeReader;
});
/*can-compute@3.3.1#proto-compute*/
define('can-compute@3.3.1#proto-compute', function (require, exports, module) {
    var Observation = require('can-observation');
    var canEvent = require('can-event');
    var eventLifecycle = require('can-event/lifecycle/lifecycle');
    require('can-event/batch/batch');
    var observeReader = require('can-stache-key');
    var getObject = require('can-util/js/get/get');
    var CID = require('can-cid');
    var assign = require('can-util/js/assign/assign');
    var canLog = require('can-util/js/log/log');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var CIDSet = require('can-util/js/cid-set/cid-set');
    var singleReference = require('can-util/js/single-reference/single-reference');
    var Compute = function (getterSetter, context, eventName, bindOnce) {
        CID(this, 'compute');
        var args = [];
        for (var i = 0, arglen = arguments.length; i < arglen; i++) {
            args[i] = arguments[i];
        }
        var contextType = typeof args[1];
        if (typeof args[0] === 'function') {
            this._setupGetterSetterFn(args[0], args[1], args[2], args[3]);
        } else if (args[1] !== undefined) {
            if (contextType === 'string' || contextType === 'number') {
                var isListLike = canReflect.isObservableLike(args[0]) && canReflect.isListLike(args[0]);
                var isMapLike = canReflect.isObservableLike(args[0]) && canReflect.isMapLike(args[0]);
                if (isMapLike || isListLike) {
                    var map = args[0];
                    var propertyName = args[1];
                    var mapGetterSetter = function (newValue) {
                        if (arguments.length) {
                            observeReader.set(map, propertyName, newValue);
                        } else {
                            if (isListLike) {
                                observeReader.get(map, 'length');
                            }
                            return observeReader.get(map, '' + propertyName);
                        }
                    };
                    this._setupGetterSetterFn(mapGetterSetter, args[1], args[2], args[3]);
                } else {
                    this._setupProperty(args[0], args[1], args[2]);
                }
            } else if (contextType === 'function') {
                this._setupSetter(args[0], args[1], args[2]);
            } else {
                if (args[1] && args[1].fn) {
                    this._setupAsyncCompute(args[0], args[1]);
                } else {
                    this._setupSettings(args[0], args[1]);
                }
            }
        } else {
            this._setupSimpleValue(args[0]);
        }
        this._args = args;
        this._primaryDepth = 0;
        this.isComputed = true;
    };
    var updateOnChange = function (compute, newValue, oldValue, batchNum) {
        var valueChanged = newValue !== oldValue && !(newValue !== newValue && oldValue !== oldValue);
        if (valueChanged) {
            canEvent.dispatch.call(compute, {
                type: 'change',
                batchNum: batchNum
            }, [
                newValue,
                oldValue
            ]);
        }
    };
    var setupComputeHandlers = function (compute, func, context) {
        var observation = new Observation(func, context, compute);
        compute.observation = observation;
        return {
            _on: function () {
                observation.start();
                compute.value = observation.value;
            },
            _off: function () {
                observation.stop();
            },
            getDepth: function () {
                return observation.getDepth();
            }
        };
    };
    assign(Compute.prototype, {
        setPrimaryDepth: function (depth) {
            this._primaryDepth = depth;
        },
        _setupGetterSetterFn: function (getterSetter, context, eventName) {
            this._set = context ? getterSetter.bind(context) : getterSetter;
            this._get = context ? getterSetter.bind(context) : getterSetter;
            this._canObserve = eventName === false ? false : true;
            var handlers = setupComputeHandlers(this, getterSetter, context || this);
            assign(this, handlers);
        },
        _setupProperty: function (target, propertyName, eventName) {
            var self = this, handler;
            handler = function () {
                self.updater(self._get(), self.value);
            };
            this._get = function () {
                return getObject(target, propertyName);
            };
            this._set = function (value) {
                var properties = propertyName.split('.'), leafPropertyName = properties.pop();
                if (properties.length) {
                    var targetProperty = getObject(target, properties.join('.'));
                    targetProperty[leafPropertyName] = value;
                } else {
                    target[propertyName] = value;
                }
            };
            this._on = function (update) {
                canEvent.on.call(target, eventName || propertyName, handler);
                this.value = this._get();
            };
            this._off = function () {
                return canEvent.off.call(target, eventName || propertyName, handler);
            };
        },
        _setupSetter: function (initialValue, setter, eventName) {
            this.value = initialValue;
            this._set = setter;
            assign(this, eventName);
        },
        _setupSettings: function (initialValue, settings) {
            this.value = initialValue;
            this._set = settings.set || this._set;
            this._get = settings.get || this._get;
            if (!settings.__selfUpdater) {
                var self = this, oldUpdater = this.updater;
                this.updater = function () {
                    oldUpdater.call(self, self._get(), self.value);
                };
            }
            this._on = settings.on ? settings.on : this._on;
            this._off = settings.off ? settings.off : this._off;
        },
        _setupAsyncCompute: function (initialValue, settings) {
            var self = this;
            var getter = settings.fn;
            var bindings;
            this.value = initialValue;
            this._setUpdates = true;
            this.lastSetValue = new Compute(initialValue);
            this._set = function (newVal) {
                if (newVal === self.lastSetValue.get()) {
                    return this.value;
                }
                return self.lastSetValue.set(newVal);
            };
            this._get = function () {
                return getter.call(settings.context, self.lastSetValue.get());
            };
            if (getter.length === 0) {
                bindings = setupComputeHandlers(this, getter, settings.context);
            } else if (getter.length === 1) {
                bindings = setupComputeHandlers(this, function () {
                    return getter.call(settings.context, self.lastSetValue.get());
                }, settings);
            } else {
                var oldUpdater = this.updater, resolve = Observation.ignore(function (newVal) {
                        oldUpdater.call(self, newVal, self.value);
                    });
                this.updater = function (newVal) {
                    oldUpdater.call(self, newVal, self.value);
                };
                bindings = setupComputeHandlers(this, function () {
                    var res = getter.call(settings.context, self.lastSetValue.get(), resolve);
                    return res !== undefined ? res : this.value;
                }, this);
            }
            assign(this, bindings);
        },
        _setupSimpleValue: function (initialValue) {
            this.value = initialValue;
        },
        _eventSetup: Observation.ignore(function () {
            this.bound = true;
            this._on(this.updater);
        }),
        _eventTeardown: function () {
            this._off(this.updater);
            this.bound = false;
        },
        addEventListener: eventLifecycle.addAndSetup,
        removeEventListener: eventLifecycle.removeAndTeardown,
        clone: function (context) {
            if (context && typeof this._args[0] === 'function') {
                this._args[1] = context;
            } else if (context) {
                this._args[2] = context;
            }
            return new Compute(this._args[0], this._args[1], this._args[2], this._args[3]);
        },
        _on: function () {
        },
        _off: function () {
        },
        get: function () {
            var recordingObservation = Observation.isRecording();
            if (recordingObservation && this._canObserve !== false) {
                Observation.add(this, 'change');
                if (!this.bound) {
                    Compute.temporarilyBind(this);
                }
            }
            if (this.bound) {
                if (this.observation) {
                    return this.observation.get();
                } else {
                    return this.value;
                }
            } else {
                return this._get();
            }
        },
        _get: function () {
            return this.value;
        },
        set: function (newVal) {
            var old = this.value;
            var setVal = this._set(newVal, old);
            if (this._setUpdates) {
                return this.value;
            }
            if (this.hasDependencies) {
                return this._get();
            }
            this.updater(setVal === undefined ? this._get() : setVal, old);
            return this.value;
        },
        _set: function (newVal) {
            return this.value = newVal;
        },
        updater: function (newVal, oldVal, batchNum) {
            this.value = newVal;
            if (this.observation) {
                this.observation.value = newVal;
            }
            updateOnChange(this, newVal, oldVal, batchNum);
        },
        toFunction: function () {
            return this._computeFn.bind(this);
        },
        _computeFn: function (newVal) {
            if (arguments.length) {
                return this.set(newVal);
            }
            return this.get();
        }
    });
    var hasDependencies = function () {
        return this.observation && this.observation.hasDependencies();
    };
    Object.defineProperty(Compute.prototype, 'hasDependencies', { get: hasDependencies });
    canReflect.set(Compute.prototype, canSymbol.for('can.valueHasDependencies'), hasDependencies);
    Compute.prototype.on = Compute.prototype.bind = Compute.prototype.addEventListener;
    Compute.prototype.off = Compute.prototype.unbind = Compute.prototype.removeEventListener;
    canReflect.set(Compute.prototype, canSymbol.for('can.onValue'), function (handler) {
        var translationHandler = function (ev, newValue) {
            handler(newValue);
        };
        singleReference.set(handler, this, translationHandler);
        this.addEventListener('change', translationHandler);
    });
    canReflect.set(Compute.prototype, canSymbol.for('can.offValue'), function (handler) {
        this.removeEventListener('change', singleReference.getAndDelete(handler, this));
    });
    canReflect.set(Compute.prototype, canSymbol.for('can.getValue'), Compute.prototype.get);
    canReflect.set(Compute.prototype, canSymbol.for('can.setValue'), Compute.prototype.set);
    Compute.temporarilyBind = Observation.temporarilyBind;
    Compute.async = function (initialValue, asyncComputer, context) {
        return new Compute(initialValue, {
            fn: asyncComputer,
            context: context
        });
    };
    Compute.truthy = function (compute) {
        return new Compute(function () {
            var res = compute.get();
            if (typeof res === 'function') {
                res = res.get();
            }
            return !!res;
        });
    };
    canReflect.set(Compute.prototype, canSymbol.for('can.setValue'), Compute.prototype.set);
    canReflect.set(Compute.prototype, canSymbol.for('can.isValueLike'), true);
    canReflect.set(Compute.prototype, canSymbol.for('can.isMapLike'), false);
    canReflect.set(Compute.prototype, canSymbol.for('can.isListLike'), false);
    canReflect.set(Compute.prototype, canSymbol.for('can.valueHasDependencies'), function () {
        return !!this.observation;
    });
    canReflect.set(Compute.prototype, canSymbol.for('can.getValueDependencies'), function () {
        var ret;
        if (this.observation) {
            ret = { valueDependencies: new CIDSet() };
            ret.valueDependencies.add(this.observation);
        }
        return ret;
    });
    module.exports = exports = Compute;
});
/*can-compute@3.3.1#can-compute*/
define('can-compute@3.3.1#can-compute', function (require, exports, module) {
    require('can-event');
    require('can-event/batch/batch');
    var Compute = require('./proto-compute');
    var CID = require('can-cid');
    var namespace = require('can-namespace');
    var singleReference = require('can-util/js/single-reference/single-reference');
    var canReflect = require('can-reflect/reflections/get-set/get-set');
    var canSymbol = require('can-symbol');
    var canOnValueSymbol = canSymbol.for('can.onValue'), canOffValueSymbol = canSymbol.for('can.offValue'), canGetValue = canSymbol.for('can.getValue'), canSetValue = canSymbol.for('can.setValue'), isValueLike = canSymbol.for('can.isValueLike'), isMapLike = canSymbol.for('can.isMapLike'), isListLike = canSymbol.for('can.isListLike'), isFunctionLike = canSymbol.for('can.isFunctionLike'), canValueHasDependencies = canSymbol.for('can.valueHasDependencies'), canGetValueDependencies = canSymbol.for('can.getValueDependencies');
    var addEventListener = function (ev, handler) {
        var compute = this;
        var translationHandler;
        if (handler) {
            translationHandler = function () {
                handler.apply(compute, arguments);
            };
            singleReference.set(handler, this, translationHandler);
        }
        return compute.computeInstance.addEventListener(ev, translationHandler);
    };
    var removeEventListener = function (ev, handler) {
        return this.computeInstance.removeEventListener(ev, handler && singleReference.getAndDelete(handler, this));
    };
    var onValue = function (handler) {
            return this.computeInstance[canOnValueSymbol](handler);
        }, offValue = function (handler) {
            return this.computeInstance[canOffValueSymbol](handler);
        }, getValue = function () {
            return this.computeInstance.get();
        }, setValue = function (value) {
            return this.computeInstance.set(value);
        }, hasDependencies = function () {
            return this.computeInstance.hasDependencies;
        }, getDependencies = function () {
            return this.computeInstance[canGetValueDependencies]();
        };
    var COMPUTE = function (getterSetter, context, eventName, bindOnce) {
        function compute(val) {
            if (arguments.length) {
                return compute.computeInstance.set(val);
            }
            return compute.computeInstance.get();
        }
        var cid = CID(compute, 'compute');
        compute.computeInstance = new Compute(getterSetter, context, eventName, bindOnce);
        compute.handlerKey = '__handler' + cid;
        compute.on = compute.bind = compute.addEventListener = addEventListener;
        compute.off = compute.unbind = compute.removeEventListener = removeEventListener;
        compute.isComputed = compute.computeInstance.isComputed;
        compute.clone = function (ctx) {
            if (typeof getterSetter === 'function') {
                context = ctx;
            }
            return COMPUTE(getterSetter, context, ctx, bindOnce);
        };
        canReflect.set(compute, canOnValueSymbol, onValue);
        canReflect.set(compute, canOffValueSymbol, offValue);
        canReflect.set(compute, canGetValue, getValue);
        canReflect.set(compute, canSetValue, setValue);
        canReflect.set(compute, isValueLike, true);
        canReflect.set(compute, isMapLike, false);
        canReflect.set(compute, isListLike, false);
        canReflect.set(compute, isFunctionLike, false);
        canReflect.set(compute, canValueHasDependencies, hasDependencies);
        canReflect.set(compute, canGetValueDependencies, getDependencies);
        return compute;
    };
    COMPUTE.truthy = function (compute) {
        return COMPUTE(function () {
            var res = compute();
            return !!res;
        });
    };
    COMPUTE.async = function (initialValue, asyncComputer, context) {
        return COMPUTE(initialValue, {
            fn: asyncComputer,
            context: context
        });
    };
    COMPUTE.temporarilyBind = Compute.temporarilyBind;
    module.exports = namespace.compute = COMPUTE;
});
/*can-control@3.2.0#can-control*/
define('can-control@3.2.0#can-control', function (require, exports, module) {
    var Construct = require('can-construct');
    var namespace = require('can-namespace');
    var string = require('can-util/js/string/string');
    var assign = require('can-util/js/assign/assign');
    var isFunction = require('can-util/js/is-function/is-function');
    var each = require('can-util/js/each/each');
    var dev = require('can-util/js/dev/dev');
    var types = require('can-types');
    var get = require('can-util/js/get/get');
    var domData = require('can-util/dom/data/data');
    var className = require('can-util/dom/class-name/class-name');
    var domEvents = require('can-util/dom/events/events');
    var canEvent = require('can-event');
    var canCompute = require('can-compute');
    var observeReader = require('can-stache-key');
    var canReflect = require('can-reflect');
    var processors;
    require('can-util/dom/dispatch/dispatch');
    require('can-util/dom/events/delegate/delegate');
    var bind = function (el, ev, callback) {
            canEvent.on.call(el, ev, callback);
            return function () {
                canEvent.off.call(el, ev, callback);
            };
        }, slice = [].slice, paramReplacer = /\{([^\}]+)\}/g, delegate = function (el, selector, ev, callback) {
            canEvent.on.call(el, ev, selector, callback);
            return function () {
                canEvent.off.call(el, ev, selector, callback);
            };
        }, binder = function (el, ev, callback, selector) {
            return selector ? delegate(el, selector.trim(), ev, callback) : bind(el, ev, callback);
        }, basicProcessor;
    var Control = Construct.extend({
        setup: function () {
            Construct.setup.apply(this, arguments);
            if (Control) {
                var control = this, funcName;
                control.actions = {};
                for (funcName in control.prototype) {
                    if (control._isAction(funcName)) {
                        control.actions[funcName] = control._action(funcName);
                    }
                }
            }
        },
        _shifter: function (context, name) {
            var method = typeof name === 'string' ? context[name] : name;
            if (!isFunction(method)) {
                method = context[method];
            }
            return function () {
                var wrapped = types.wrapElement(this);
                context.called = name;
                return method.apply(context, [wrapped].concat(slice.call(arguments, 0)));
            };
        },
        _isAction: function (methodName) {
            var val = this.prototype[methodName], type = typeof val;
            return methodName !== 'constructor' && (type === 'function' || type === 'string' && isFunction(this.prototype[val])) && !!(Control.isSpecial(methodName) || processors[methodName] || /[^\w]/.test(methodName));
        },
        _action: function (methodName, options, controlInstance) {
            var readyCompute;
            paramReplacer.lastIndex = 0;
            if (options || !paramReplacer.test(methodName)) {
                readyCompute = canCompute(function () {
                    var delegate;
                    var name = methodName.replace(paramReplacer, function (matched, key) {
                        var value, parent;
                        if (this._isDelegate(options, key)) {
                            delegate = this._getDelegate(options, key);
                            return '';
                        }
                        key = this._removeDelegateFromKey(key);
                        parent = this._lookup(options)[0];
                        value = observeReader.read(parent, observeReader.reads(key), { readCompute: false }).value;
                        if (value === undefined && typeof window !== 'undefined') {
                            value = get(window, key);
                        }
                        if (!parent || !(canReflect.isObservableLike(parent) && canReflect.isMapLike(parent)) && !value) {
                            return null;
                        }
                        if (typeof value === 'string') {
                            return value;
                        } else {
                            delegate = value;
                            return '';
                        }
                    }.bind(this));
                    name = name.trim();
                    var parts = name.split(/\s+/g), event = parts.pop();
                    return {
                        processor: this.processors[event] || basicProcessor,
                        parts: [
                            name,
                            parts.join(' '),
                            event
                        ],
                        delegate: delegate || undefined
                    };
                }, this);
                if (controlInstance) {
                    var handler = function (ev, ready) {
                        controlInstance._bindings.control[methodName](controlInstance.element);
                        controlInstance._bindings.control[methodName] = ready.processor(ready.delegate || controlInstance.element, ready.parts[2], ready.parts[1], methodName, controlInstance);
                    };
                    readyCompute.bind('change', handler);
                    controlInstance._bindings.readyComputes[methodName] = {
                        compute: readyCompute,
                        handler: handler
                    };
                }
                return readyCompute();
            }
        },
        _lookup: function (options) {
            return [
                options,
                window
            ];
        },
        _removeDelegateFromKey: function (key) {
            return key;
        },
        _isDelegate: function (options, key) {
            return key === 'element';
        },
        _getDelegate: function (options, key) {
            return undefined;
        },
        processors: {},
        defaults: {},
        convertElement: function (element) {
            element = typeof element === 'string' ? document.querySelector(element) : element;
            return types.wrapElement(element);
        },
        isSpecial: function (eventName) {
            return eventName === 'inserted' || eventName === 'removed';
        }
    }, {
        setup: function (element, options) {
            var cls = this.constructor, pluginname = cls.pluginName || cls.shortName, arr;
            if (!element) {
                throw new Error('Creating an instance of a named control without passing an element');
            }
            this.element = cls.convertElement(element);
            if (pluginname && pluginname !== 'can_control') {
                className.add.call(this.element, pluginname);
            }
            arr = domData.get.call(this.element, 'controls');
            if (!arr) {
                arr = [];
                domData.set.call(this.element, 'controls', arr);
            }
            arr.push(this);
            if (canReflect.isObservableLike(options) && canReflect.isMapLike(options)) {
                for (var prop in cls.defaults) {
                    if (!options.hasOwnProperty(prop)) {
                        observeReader.set(options, prop, cls.defaults[prop]);
                    }
                }
                this.options = options;
            } else {
                this.options = assign(assign({}, cls.defaults), options);
            }
            this.on();
            return [
                this.element,
                this.options
            ];
        },
        on: function (el, selector, eventName, func) {
            if (!el) {
                this.off();
                var cls = this.constructor, bindings = this._bindings, actions = cls.actions, element = types.unwrapElement(this.element), destroyCB = Control._shifter(this, 'destroy'), funcName, ready;
                for (funcName in actions) {
                    if (actions.hasOwnProperty(funcName)) {
                        ready = actions[funcName] || cls._action(funcName, this.options, this);
                        if (ready) {
                            bindings.control[funcName] = ready.processor(ready.delegate || element, ready.parts[2], ready.parts[1], funcName, this);
                        }
                    }
                }
                domEvents.addEventListener.call(element, 'removed', destroyCB);
                bindings.user.push(function (el) {
                    domEvents.removeEventListener.call(el, 'removed', destroyCB);
                });
                return bindings.user.length;
            }
            if (typeof el === 'string') {
                func = eventName;
                eventName = selector;
                selector = el;
                el = this.element;
            }
            if (func === undefined) {
                func = eventName;
                eventName = selector;
                selector = null;
            }
            if (typeof func === 'string') {
                func = Control._shifter(this, func);
            }
            this._bindings.user.push(binder(el, eventName, func, selector));
            return this._bindings.user.length;
        },
        off: function () {
            var el = types.unwrapElement(this.element), bindings = this._bindings;
            if (bindings) {
                each(bindings.user || [], function (value) {
                    value(el);
                });
                each(bindings.control || {}, function (value) {
                    value(el);
                });
                each(bindings.readyComputes || {}, function (value) {
                    value.compute.unbind('change', value.handler);
                });
            }
            this._bindings = {
                user: [],
                control: {},
                readyComputes: {}
            };
        },
        destroy: function () {
            if (this.element === null) {
                return;
            }
            var Class = this.constructor, pluginName = Class.pluginName || Class.shortName && string.underscore(Class.shortName), controls;
            this.off();
            if (pluginName && pluginName !== 'can_control') {
                className.remove.call(this.element, pluginName);
            }
            controls = domData.get.call(this.element, 'controls');
            if (controls) {
                controls.splice(controls.indexOf(this), 1);
            }
            canEvent.dispatch.call(this, 'destroyed');
            this.element = null;
        }
    });
    processors = Control.processors;
    basicProcessor = function (el, event, selector, methodName, control) {
        return binder(el, event, Control._shifter(control, methodName), selector);
    };
    each([
        'beforeremove',
        'change',
        'click',
        'contextmenu',
        'dblclick',
        'keydown',
        'keyup',
        'keypress',
        'mousedown',
        'mousemove',
        'mouseout',
        'mouseover',
        'mouseup',
        'reset',
        'resize',
        'scroll',
        'select',
        'submit',
        'focusin',
        'focusout',
        'mouseenter',
        'mouseleave',
        'touchstart',
        'touchmove',
        'touchcancel',
        'touchend',
        'touchleave',
        'inserted',
        'removed',
        'dragstart',
        'dragenter',
        'dragover',
        'dragleave',
        'drag',
        'drop',
        'dragend'
    ], function (v) {
        processors[v] = basicProcessor;
    });
    module.exports = namespace.Control = Control;
});
/*can-component@3.3.0#control/control*/
define('can-component@3.3.0#control/control', function (require, exports, module) {
    var Control = require('can-control');
    var canEach = require('can-util/js/each/each');
    var string = require('can-util/js/string/string');
    var canCompute = require('can-compute');
    var observeReader = require('can-stache-key');
    var paramReplacer = /\{([^\}]+)\}/g;
    var ComponentControl = Control.extend({
        _lookup: function (options) {
            return [
                options.scope,
                options,
                window
            ];
        },
        _removeDelegateFromKey: function (key) {
            return key.replace(/^(scope|^viewModel)\./, '');
        },
        _isDelegate: function (options, key) {
            return key === 'scope' || key === 'viewModel';
        },
        _getDelegate: function (options, key) {
            return options[key];
        },
        _action: function (methodName, options, controlInstance) {
            var hasObjectLookup;
            paramReplacer.lastIndex = 0;
            hasObjectLookup = paramReplacer.test(methodName);
            if (!controlInstance && hasObjectLookup) {
                return;
            } else {
                return Control._action.apply(this, arguments);
            }
        }
    }, {
        setup: function (el, options) {
            this.scope = options.scope;
            this.viewModel = options.viewModel;
            return Control.prototype.setup.call(this, el, options);
        },
        off: function () {
            if (this._bindings) {
                canEach(this._bindings.readyComputes || {}, function (value) {
                    value.compute.unbind('change', value.handler);
                });
            }
            Control.prototype.off.apply(this, arguments);
            this._bindings.readyComputes = {};
        },
        destroy: function () {
            Control.prototype.destroy.apply(this, arguments);
            if (typeof this.options.destroy === 'function') {
                this.options.destroy.apply(this, arguments);
            }
        }
    });
    module.exports = ComponentControl;
});
/*can-simple-map@3.3.0#can-simple-map*/
define('can-simple-map@3.3.0#can-simple-map', function (require, exports, module) {
    var Construct = require('can-construct');
    var canEvent = require('can-event');
    var canBatch = require('can-event/batch/batch');
    var assign = require('can-util/js/assign/assign');
    var each = require('can-util/js/each/each');
    var types = require('can-types');
    var Observation = require('can-observation');
    var canReflect = require('can-reflect');
    var singleReference = require('can-util/js/single-reference/single-reference');
    var CIDMap = require('can-util/js/cid-map/cid-map');
    var SimpleMap = Construct.extend({
        setup: function (initialData) {
            this._data = {};
            this.attr(initialData);
        },
        attr: function (prop, value) {
            var self = this;
            if (arguments.length === 0) {
                Observation.add(this, '__keys');
                var data = {};
                each(this._data, function (value, prop) {
                    Observation.add(this, prop);
                    data[prop] = value;
                }, this);
                return data;
            } else if (arguments.length > 1) {
                var had = this._data.hasOwnProperty(prop);
                var old = this._data[prop];
                this._data[prop] = value;
                canBatch.start();
                if (!had) {
                    canEvent.dispatch.call(this, '__keys', []);
                }
                canEvent.dispatch.call(this, prop, [
                    value,
                    old
                ]);
                canBatch.stop();
            } else if (typeof prop === 'object') {
                canReflect.eachKey(prop, function (value, key) {
                    self.attr(key, value);
                });
            } else {
                if (prop !== 'constructor') {
                    Observation.add(this, prop);
                    return this._data[prop];
                }
                return this.constructor;
            }
        },
        serialize: function () {
            return canReflect.serialize(this, CIDMap);
        },
        get: function () {
            return this.attr.apply(this, arguments);
        },
        set: function () {
            return this.attr.apply(this, arguments);
        }
    });
    assign(SimpleMap.prototype, canEvent);
    if (!types.DefaultMap) {
        types.DefaultMap = SimpleMap;
    }
    canReflect.assignSymbols(SimpleMap.prototype, {
        'can.isMapLike': true,
        'can.isListLike': false,
        'can.isValueLike': false,
        'can.getKeyValue': SimpleMap.prototype.get,
        'can.setKeyValue': SimpleMap.prototype.set,
        'can.deleteKeyValue': function (prop) {
            return this.attr(prop, undefined);
        },
        'can.getOwnEnumerableKeys': function () {
            Observation.add(this, '__keys');
            return Object.keys(this._data);
        },
        'can.assignDeep': function (source) {
            canBatch.start();
            canReflect.assignMap(this, source);
            canBatch.stop();
        },
        'can.updateDeep': function (source) {
            canBatch.start();
            canReflect.updateMap(this, source);
            canBatch.stop();
        },
        'can.onKeyValue': function (key, handler) {
            var translationHandler = function (ev, newValue, oldValue) {
                handler.call(this, newValue, oldValue);
            };
            singleReference.set(handler, this, translationHandler, key);
            this.addEventListener(key, translationHandler);
        },
        'can.offKeyValue': function (key, handler) {
            this.removeEventListener(key, singleReference.getAndDelete(handler, this, key));
        },
        'can.keyHasDependencies': function (key) {
            return false;
        },
        'can.getKeyDependencies': function (key) {
            return undefined;
        }
    });
    module.exports = SimpleMap;
});
/*can-view-scope@3.3.0#reference-map*/
define('can-view-scope@3.3.0#reference-map', function (require, exports, module) {
    var SimpleMap = require('can-simple-map');
    var ReferenceMap = SimpleMap.extend({});
    module.exports = ReferenceMap;
});
/*can-view-scope@3.3.0#compute_data*/
define('can-view-scope@3.3.0#compute_data', function (require, exports, module) {
    'use strict';
    var Observation = require('can-observation');
    var observeReader = require('can-stache-key');
    var makeCompute = require('can-compute');
    var assign = require('can-util/js/assign/assign');
    var isFunction = require('can-util/js/is-function/is-function');
    var canBatch = require('can-event/batch/batch');
    var CID = require('can-cid');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var getFastPathRoot = function (computeData) {
        if (computeData.reads && computeData.reads.length === 1) {
            var root = computeData.root;
            if (root && root[canSymbol.for('can.getValue')]) {
                root = canReflect.getValue(root);
            }
            return root && canReflect.isObservableLike(root) && canReflect.isMapLike(root) && !isFunction(root[computeData.reads[0].key]) && root;
        }
        return;
    };
    var isEventObject = function (obj) {
        return obj && typeof obj.batchNum === 'number' && typeof obj.type === 'string';
    };
    var ScopeKeyData = function (scope, key, options) {
        CID(this);
        this.startingScope = scope;
        this.key = key;
        this.observation = new Observation(this.read, this);
        this.options = assign({ observation: this.observation }, options);
        this.handlers = [];
        this.dispatchHandler = this.dispatch.bind(this);
        this.fastPath = undefined;
        this.root = undefined;
        this.initialValue = undefined;
        this.reads = undefined;
        this.setRoot = undefined;
    };
    ScopeKeyData.prototype.getValue = function () {
        Observation.add(this);
        return this.getObservationValue();
    };
    ScopeKeyData.prototype.getObservationValue = Observation.ignore(function () {
        return this.observation.get();
    });
    ScopeKeyData.prototype.read = function () {
        if (this.root) {
            return observeReader.read(this.root, this.reads, this.options).value;
        }
        var data = this.startingScope.read(this.key, this.options);
        this.scope = data.scope;
        this.reads = data.reads;
        this.root = data.rootObserve;
        this.setRoot = data.setRoot;
        return this.initialValue = data.value;
    };
    ScopeKeyData.prototype.setValue = function (newVal) {
        var root = this.root || this.setRoot;
        if (root) {
            observeReader.write(root, this.reads, newVal, this.options);
        } else {
            this.startingScope.set(this.key, newVal, this.options);
        }
    };
    ScopeKeyData.prototype.hasDependencies = function () {
        return this.observation.hasDependencies();
    };
    var canOnValue = canSymbol.for('can.onValue'), canOffValue = canSymbol.for('can.offValue');
    canReflect.set(ScopeKeyData.prototype, canOnValue, function (handler) {
        if (!this.handlers.length) {
            canReflect.onValue(this.observation, this.dispatchHandler);
            var fastPathRoot = getFastPathRoot(this);
            if (fastPathRoot) {
                var self = this, observation = this.observation;
                this.fastPath = true;
                observation.dependencyChange = function (target, newVal, altNewValue) {
                    if (isEventObject(newVal)) {
                        newVal = altNewValue;
                    }
                    if (target === fastPathRoot && typeof newVal !== 'function') {
                        this.newVal = newVal;
                    } else {
                        observation.dependencyChange = Observation.prototype.dependencyChange;
                        observation.start = Observation.prototype.start;
                        self.fastPath = false;
                    }
                    return Observation.prototype.dependencyChange.call(this, target, newVal, altNewValue);
                };
                observation.start = function () {
                    this.value = this.newVal;
                };
            }
        }
        this.handlers.push(handler);
    });
    ScopeKeyData.prototype.dispatch = function () {
        var handlers = this.handlers.slice(0);
        for (var i = 0, len = handlers.length; i < len; i++) {
            canBatch.batchNum = this.observation.batchNum;
            handlers[i].apply(this, arguments);
        }
    };
    canReflect.set(ScopeKeyData.prototype, canOffValue, function (handler) {
        var index = this.handlers.indexOf(handler);
        this.handlers.splice(index, 1);
        if (!this.handlers.length) {
            canReflect.offValue(this.observation, this.dispatchHandler);
        }
    });
    canReflect.set(ScopeKeyData.prototype, canSymbol.for('can.getValue'), ScopeKeyData.prototype.getValue);
    canReflect.set(ScopeKeyData.prototype, canSymbol.for('can.setValue'), ScopeKeyData.prototype.setValue);
    canReflect.set(ScopeKeyData.prototype, canSymbol.for('can.valueHasDependencies'), ScopeKeyData.prototype.hasDependencies);
    Object.defineProperty(ScopeKeyData.prototype, 'compute', {
        get: function () {
            var scopeKeyData = this;
            var compute = makeCompute(undefined, {
                on: function (updater) {
                    scopeKeyData[canOnValue](updater);
                    this.value = scopeKeyData.observation.value;
                },
                off: function (updater) {
                    scopeKeyData[canOffValue](updater);
                },
                get: function () {
                    return scopeKeyData.observation.get();
                },
                set: function (newValue) {
                    return scopeKeyData.setValue(newValue);
                }
            });
            compute.computeInstance.observation = this.observation;
            compute.computeInstance._canObserve = false;
            Object.defineProperty(this, 'compute', {
                value: compute,
                writable: false,
                configurable: false
            });
            return compute;
        },
        configurable: true
    });
    module.exports = function (scope, key, options) {
        return new ScopeKeyData(scope, key, options || { args: [] });
    };
});
/*can-view-scope@3.3.0#can-view-scope*/
define('can-view-scope@3.3.0#can-view-scope', function (require, exports, module) {
    var observeReader = require('can-stache-key');
    var Observation = require('can-observation');
    var ReferenceMap = require('./reference-map');
    var makeComputeData = require('./compute_data');
    var assign = require('can-util/js/assign/assign');
    var each = require('can-util/js/each/each');
    var namespace = require('can-namespace');
    var dev = require('can-util/js/dev/dev');
    var canReflect = require('can-reflect');
    var canLog = require('can-util/js/log/log');
    function Scope(context, parent, meta) {
        this._context = context;
        this._parent = parent;
        this._meta = meta || {};
        this.__cache = {};
    }
    assign(Scope, {
        read: observeReader.read,
        Refs: ReferenceMap,
        refsScope: function () {
            return new Scope(new this.Refs());
        },
        keyInfo: function (attr) {
            var info = {};
            info.isDotSlash = attr.substr(0, 2) === './';
            info.isThisDot = attr.substr(0, 5) === 'this.';
            info.isInCurrentContext = info.isDotSlash || info.isThisDot;
            info.isInParentContext = attr.substr(0, 3) === '../';
            info.isCurrentContext = attr === '.' || attr === 'this';
            info.isParentContext = attr === '..';
            info.isContextBased = info.isInCurrentContext || info.isInParentContext || info.isCurrentContext || info.isParentContext;
            return info;
        }
    });
    assign(Scope.prototype, {
        add: function (context, meta) {
            if (context !== this._context) {
                return new this.constructor(context, this, meta);
            } else {
                return this;
            }
        },
        read: function (attr, options) {
            if (attr === '%root') {
                return { value: this.getRoot() };
            }
            if (attr === '%scope') {
                return { value: this };
            }
            var keyInfo = Scope.keyInfo(attr);
            if (keyInfo.isContextBased && this._meta.notContext) {
                return this._parent.read(attr, options);
            }
            var currentScopeOnly;
            if (keyInfo.isInCurrentContext) {
                currentScopeOnly = true;
                attr = keyInfo.isDotSlash ? attr.substr(2) : attr.substr(5);
            } else if (keyInfo.isInParentContext || keyInfo.isParentContext) {
                var parent = this._parent;
                while (parent._meta.notContext) {
                    parent = parent._parent;
                }
                if (keyInfo.isParentContext) {
                    return observeReader.read(parent._context, [], options);
                }
                return parent.read(attr.substr(3) || '.', options);
            } else if (keyInfo.isCurrentContext) {
                return observeReader.read(this._context, [], options);
            }
            var keyReads = observeReader.reads(attr);
            if (keyReads[0].key.charAt(0) === '*') {
                return this.getRefs()._read(keyReads, options, true);
            } else {
                return this._read(keyReads, options, currentScopeOnly);
            }
        },
        _read: function (keyReads, options, currentScopeOnly) {
            var currentScope = this, currentContext, undefinedObserves = [], currentObserve, currentReads, setObserveDepth = -1, currentSetReads, currentSetObserve, readOptions = assign({
                    foundObservable: function (observe, nameIndex) {
                        currentObserve = observe;
                        currentReads = keyReads.slice(nameIndex);
                    },
                    earlyExit: function (parentValue, nameIndex) {
                        if (nameIndex > setObserveDepth || nameIndex === setObserveDepth && (typeof parentValue === 'object' && keyReads[nameIndex].key in parentValue)) {
                            currentSetObserve = currentObserve;
                            currentSetReads = currentReads;
                            setObserveDepth = nameIndex;
                        }
                    }
                }, options);
            while (currentScope) {
                currentContext = currentScope._context;
                if (currentContext !== null && (typeof currentContext === 'object' || typeof currentContext === 'function')) {
                    var getObserves = Observation.trap();
                    var data = observeReader.read(currentContext, keyReads, readOptions);
                    var observes = getObserves();
                    if (data.value !== undefined) {
                        Observation.addAll(observes);
                        return {
                            scope: currentScope,
                            rootObserve: currentObserve,
                            value: data.value,
                            reads: currentReads
                        };
                    } else {
                        undefinedObserves.push.apply(undefinedObserves, observes);
                    }
                }
                if (currentScopeOnly) {
                    currentScope = null;
                } else {
                    currentScope = currentScope._parent;
                }
            }
            Observation.addAll(undefinedObserves);
            return {
                setRoot: currentSetObserve,
                reads: currentSetReads,
                value: undefined
            };
        },
        get: function (key, options) {
            options = assign({ isArgument: true }, options);
            var res = this.read(key, options);
            return res.value;
        },
        peek: Observation.ignore(function (key, options) {
            return this.get(key, options);
        }),
        peak: Observation.ignore(function (key, options) {
            return this.peek(key, options);
        }),
        getScope: function (tester) {
            var scope = this;
            while (scope) {
                if (tester(scope)) {
                    return scope;
                }
                scope = scope._parent;
            }
        },
        getContext: function (tester) {
            var res = this.getScope(tester);
            return res && res._context;
        },
        getRefs: function () {
            return this.getScope(function (scope) {
                return scope._context instanceof Scope.Refs;
            });
        },
        getRoot: function () {
            var cur = this, child = this;
            while (cur._parent) {
                child = cur;
                cur = cur._parent;
            }
            if (cur._context instanceof Scope.Refs) {
                cur = child;
            }
            return cur._context;
        },
        set: function (key, value, options) {
            options = options || {};
            var keyInfo = Scope.keyInfo(key);
            if (keyInfo.isCurrentContext) {
                return canReflect.setValue(this._context, value);
            } else if (keyInfo.isInParentContext || keyInfo.isParentContext) {
                var parent = this._parent;
                while (parent._meta.notContext) {
                    parent = parent._parent;
                }
                if (keyInfo.isParentContext) {
                    return canReflect.setValue(parent._context, value);
                }
                return parent.set(key.substr(3) || '.', value, options);
            }
            var dotIndex = key.lastIndexOf('.'), slashIndex = key.lastIndexOf('/'), contextPath, propName;
            if (slashIndex > dotIndex) {
                contextPath = key.substring(0, slashIndex);
                propName = key.substring(slashIndex + 1, key.length);
            } else {
                if (dotIndex !== -1) {
                    contextPath = key.substring(0, dotIndex);
                    propName = key.substring(dotIndex + 1, key.length);
                } else {
                    contextPath = '.';
                    propName = key;
                }
            }
            if (key.charAt(0) === '*') {
                observeReader.write(this.getRefs()._context, key, value, options);
            } else {
                var context = this.read(contextPath, options).value;
                if (!canReflect.isObservableLike(context) && canReflect.isObservableLike(context[propName])) {
                    if (canReflect.isMapLike(context[propName])) {
                        dev.warn('can-view-scope: Merging data into "' + propName + '" because its parent is non-observable');
                        canReflect.updateDeep(context[propName], value);
                    } else if (canReflect.isValueLike(context[propName])) {
                        canReflect.setValue(context[propName], value);
                    } else {
                        observeReader.write(context, propName, value, options);
                    }
                } else {
                    observeReader.write(context, propName, value, options);
                }
            }
        },
        attr: Observation.ignore(function (key, value, options) {
            canLog.warn('can-view-scope::attr is deprecated, please use peek, get or set');
            options = assign({ isArgument: true }, options);
            if (arguments.length === 2) {
                return this.set(key, value, options);
            } else {
                return this.get(key, options);
            }
        }),
        computeData: function (key, options) {
            return makeComputeData(this, key, options);
        },
        compute: function (key, options) {
            return this.computeData(key, options).compute;
        },
        cloneFromRef: function () {
            var contexts = [];
            var scope = this, context, parent;
            while (scope) {
                context = scope._context;
                if (context instanceof Scope.Refs) {
                    parent = scope._parent;
                    break;
                }
                contexts.unshift(context);
                scope = scope._parent;
            }
            if (parent) {
                each(contexts, function (context) {
                    parent = parent.add(context);
                });
                return parent;
            } else {
                return this;
            }
        }
    });
    function Options(data, parent, meta) {
        if (!data.helpers && !data.partials && !data.tags) {
            data = { helpers: data };
        }
        Scope.call(this, data, parent, meta);
    }
    Options.prototype = new Scope();
    Options.prototype.constructor = Options;
    Scope.Options = Options;
    namespace.view = namespace.view || {};
    module.exports = namespace.view.Scope = Scope;
});
/*can-stache@3.2.0#src/utils*/
define('can-stache@3.2.0#src/utils', function (require, exports, module) {
    var Scope = require('can-view-scope');
    var Observation = require('can-observation');
    var observationReader = require('can-stache-key');
    var compute = require('can-compute');
    var canReflect = require('can-reflect');
    var isArrayLike = require('can-util/js/is-array-like/is-array-like');
    var Options = Scope.Options;
    module.exports = {
        isArrayLike: isArrayLike,
        emptyHandler: function () {
        },
        jsonParse: function (str) {
            if (str[0] === '\'') {
                return str.substr(1, str.length - 2);
            } else if (str === 'undefined') {
                return undefined;
            } else {
                return JSON.parse(str);
            }
        },
        mixins: {
            last: function () {
                return this.stack[this.stack.length - 1];
            },
            add: function (chars) {
                this.last().add(chars);
            },
            subSectionDepth: function () {
                return this.stack.length - 1;
            }
        },
        convertToScopes: function (helperOptions, scope, options, nodeList, truthyRenderer, falseyRenderer, isStringOnly) {
            if (truthyRenderer) {
                helperOptions.fn = this.makeRendererConvertScopes(truthyRenderer, scope, options, nodeList, isStringOnly);
            }
            if (falseyRenderer) {
                helperOptions.inverse = this.makeRendererConvertScopes(falseyRenderer, scope, options, nodeList, isStringOnly);
            }
        },
        makeRendererConvertScopes: function (renderer, parentScope, parentOptions, nodeList, observeObservables) {
            var rendererWithScope = function (ctx, opts, parentNodeList) {
                return renderer(ctx || parentScope, opts, parentNodeList);
            };
            var convertedRenderer = function (newScope, newOptions, parentNodeList) {
                if (newScope !== undefined && !(newScope instanceof Scope)) {
                    if (parentScope) {
                        newScope = parentScope.add(newScope);
                    } else {
                        newScope = Scope.refsScope().add(newScope || {});
                    }
                }
                if (newOptions !== undefined && !(newOptions instanceof Options)) {
                    newOptions = parentOptions.add(newOptions);
                }
                var result = rendererWithScope(newScope, newOptions || parentOptions, parentNodeList || nodeList);
                return result;
            };
            return observeObservables ? convertedRenderer : Observation.ignore(convertedRenderer);
        },
        getItemsStringContent: function (items, isObserveList, helperOptions, options) {
            var txt = '', len = observationReader.get(items, 'length'), isObservable = canReflect.isObservableLike(items);
            for (var i = 0; i < len; i++) {
                var item = isObservable ? compute(items, '' + i) : items[i];
                txt += helperOptions.fn(item, options);
            }
            return txt;
        },
        getItemsFragContent: function (items, helperOptions, scope, asVariable) {
            var result = [], len = observationReader.get(items, 'length'), isObservable = canReflect.isObservableLike(items);
            for (var i = 0; i < len; i++) {
                var aliases = {
                    '%index': i,
                    '@index': i
                };
                var item = isObservable ? compute(items, '' + i) : items[i];
                if (asVariable) {
                    aliases[asVariable] = item;
                }
                result.push(helperOptions.fn(scope.add(aliases, { notContext: true }).add(item)));
            }
            return result;
        },
        Options: Options
    };
});
/*can-view-parser@3.4.0#can-view-parser*/
define('can-view-parser@3.4.0#can-view-parser', function (require, exports, module) {
    var namespace = require('can-namespace'), dev = require('can-util/js/dev/dev');
    function each(items, callback) {
        for (var i = 0; i < items.length; i++) {
            callback(items[i], i);
        }
    }
    function makeMap(str) {
        var obj = {}, items = str.split(',');
        each(items, function (name) {
            obj[name] = true;
        });
        return obj;
    }
    function handleIntermediate(intermediate, handler) {
        for (var i = 0, len = intermediate.length; i < len; i++) {
            var item = intermediate[i];
            handler[item.tokenType].apply(handler, item.args);
        }
        return intermediate;
    }
    var alphaNumeric = 'A-Za-z0-9', alphaNumericHU = '-:_' + alphaNumeric, camelCase = /([a-z])([A-Z])/g, defaultMagicStart = '{{', endTag = new RegExp('^<\\/([' + alphaNumericHU + ']+)[^>]*>'), defaultMagicMatch = new RegExp('\\{\\{(![\\s\\S]*?!|[\\s\\S]*?)\\}\\}\\}?', 'g'), space = /\s/, spacesRegex = /\s/g, alphaRegex = new RegExp('[' + alphaNumeric + ']'), forwardSlashRegex = /\//g;
    var empty = makeMap('area,base,basefont,br,col,frame,hr,img,input,isindex,link,meta,param,embed');
    var caseMattersAttributes = makeMap('allowReorder,attributeName,attributeType,autoReverse,baseFrequency,baseProfile,calcMode,clipPathUnits,contentScriptType,contentStyleType,diffuseConstant,edgeMode,externalResourcesRequired,filterRes,filterUnits,glyphRef,gradientTransform,gradientUnits,kernelMatrix,kernelUnitLength,keyPoints,keySplines,keyTimes,lengthAdjust,limitingConeAngle,markerHeight,markerUnits,markerWidth,maskContentUnits,maskUnits,patternContentUnits,patternTransform,patternUnits,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,repeatCount,repeatDur,requiredExtensions,requiredFeatures,specularConstant,specularExponent,spreadMethod,startOffset,stdDeviation,stitchTiles,surfaceScale,systemLanguage,tableValues,textLength,viewBox,viewTarget,xChannelSelector,yChannelSelector');
    var caseMattersElements = makeMap('altGlyph,altGlyphDef,altGlyphItem,animateColor,animateMotion,animateTransform,clipPath,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,foreignObject,glyphRef,linearGradient,radialGradient,textPath');
    var closeSelf = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr');
    var special = makeMap('script');
    var tokenTypes = 'start,end,close,attrStart,attrEnd,attrValue,chars,comment,special,done'.split(',');
    var startOppositesMap = {
        '{': '}',
        '(': ')'
    };
    var fn = function () {
    };
    var HTMLParser = function (html, handler, returnIntermediate) {
        if (typeof html === 'object') {
            return handleIntermediate(html, handler);
        }
        var intermediate = [];
        handler = handler || {};
        if (returnIntermediate) {
            each(tokenTypes, function (name) {
                var callback = handler[name] || fn;
                handler[name] = function () {
                    if (callback.apply(this, arguments) !== false) {
                        intermediate.push({
                            tokenType: name,
                            args: [].slice.call(arguments, 0)
                        });
                    }
                };
            });
        }
        var magicMatch = handler.magicMatch || defaultMagicMatch, magicStart = handler.magicStart || defaultMagicStart;
        function parseStartTag(tag, tagName, rest, unary) {
            tagName = caseMattersElements[tagName] ? tagName : tagName.toLowerCase();
            if (closeSelf[tagName] && stack.last() === tagName) {
                parseEndTag('', tagName);
            }
            unary = empty[tagName] || !!unary;
            handler.start(tagName, unary);
            if (!unary) {
                stack.push(tagName);
            }
            HTMLParser.parseAttrs(rest, handler);
            handler.end(tagName, unary);
        }
        function parseEndTag(tag, tagName) {
            var pos;
            if (!tagName) {
                pos = 0;
            } else {
                tagName = caseMattersElements[tagName] ? tagName : tagName.toLowerCase();
                for (pos = stack.length - 1; pos >= 0; pos--) {
                    if (stack[pos] === tagName) {
                        break;
                    }
                }
            }
            if (pos >= 0) {
                for (var i = stack.length - 1; i >= pos; i--) {
                    if (handler.close) {
                        handler.close(stack[i]);
                    }
                }
                stack.length = pos;
            }
        }
        function parseMustache(mustache, inside) {
            if (handler.special) {
                handler.special(inside);
            }
        }
        var callChars = function () {
            if (charsText) {
                if (handler.chars) {
                    handler.chars(charsText);
                }
            }
            charsText = '';
        };
        var index, chars, match, stack = [], last = html, charsText = '';
        stack.last = function () {
            return this[this.length - 1];
        };
        while (html) {
            chars = true;
            if (!stack.last() || !special[stack.last()]) {
                if (html.indexOf('<!--') === 0) {
                    index = html.indexOf('-->');
                    if (index >= 0) {
                        callChars();
                        if (handler.comment) {
                            handler.comment(html.substring(4, index));
                        }
                        html = html.substring(index + 3);
                        chars = false;
                    }
                } else if (html.indexOf('</') === 0) {
                    match = html.match(endTag);
                    if (match) {
                        callChars();
                        html = html.substring(match[0].length);
                        match[0].replace(endTag, parseEndTag);
                        chars = false;
                    }
                } else if (html.indexOf('<') === 0) {
                    var res = HTMLParser.searchStartTag(html);
                    if (res) {
                        callChars();
                        html = res.html;
                        parseStartTag.apply(null, res.match);
                        chars = false;
                    }
                } else if (html.indexOf(magicStart) === 0) {
                    match = html.match(magicMatch);
                    if (match) {
                        callChars();
                        html = html.substring(match[0].length);
                        match[0].replace(magicMatch, parseMustache);
                    }
                }
                if (chars) {
                    index = findBreak(html, magicStart);
                    if (index === 0 && html === last) {
                        charsText += html.charAt(0);
                        html = html.substr(1);
                        index = findBreak(html, magicStart);
                    }
                    var text = index < 0 ? html : html.substring(0, index);
                    html = index < 0 ? '' : html.substring(index);
                    if (text) {
                        charsText += text;
                    }
                }
            } else {
                html = html.replace(new RegExp('([\\s\\S]*?)</' + stack.last() + '[^>]*>'), function (all, text) {
                    text = text.replace(/<!--([\s\S]*?)-->|<!\[CDATA\[([\s\S]*?)]]>/g, '$1$2');
                    if (handler.chars) {
                        handler.chars(text);
                    }
                    return '';
                });
                parseEndTag('', stack.last());
            }
            if (html === last) {
                throw new Error('Parse Error: ' + html);
            }
            last = html;
        }
        callChars();
        parseEndTag();
        handler.done();
        return intermediate;
    };
    var callAttrStart = function (state, curIndex, handler, rest) {
        var attrName = rest.substring(typeof state.nameStart === 'number' ? state.nameStart : curIndex, curIndex), newAttrName = attrName, oldAttrName = attrName;
        if (!caseMattersAttributes[attrName] && camelCase.test(attrName)) {
            newAttrName = attrName.replace(camelCase, camelCaseToSpinalCase);
        }
        newAttrName = newAttrName.replace(spacesRegex, '\\s');
        newAttrName = newAttrName.replace(forwardSlashRegex, '\\f');
        state.attrStart = newAttrName;
        handler.attrStart(state.attrStart);
        state.inName = false;
    };
    var callAttrEnd = function (state, curIndex, handler, rest) {
        if (state.valueStart !== undefined && state.valueStart < curIndex) {
            handler.attrValue(rest.substring(state.valueStart, curIndex));
        } else if (!state.inValue) {
        }
        handler.attrEnd(state.attrStart);
        state.attrStart = undefined;
        state.valueStart = undefined;
        state.inValue = false;
        state.inName = false;
        state.lookingForEq = false;
        state.inQuote = false;
        state.lookingForName = true;
    };
    var findBreak = function (str, magicStart) {
        var magicLength = magicStart.length;
        for (var i = 0, len = str.length; i < len; i++) {
            if (str[i] === '<' || str.substr(i, magicLength) === magicStart) {
                return i;
            }
        }
        return -1;
    };
    var camelCaseToSpinalCase = function (match, lowerCaseChar, upperCaseChar) {
        return lowerCaseChar + '-' + upperCaseChar.toLowerCase();
    };
    HTMLParser.parseAttrs = function (rest, handler) {
        if (!rest) {
            return;
        }
        var magicMatch = handler.magicMatch || defaultMagicMatch, magicStart = handler.magicStart || defaultMagicStart;
        var i = 0;
        var curIndex;
        var state = {
            inName: false,
            nameStart: undefined,
            inValue: false,
            valueStart: undefined,
            inQuote: false,
            attrStart: undefined,
            lookingForName: true,
            lookingForValue: false,
            lookingForEq: false
        };
        while (i < rest.length) {
            curIndex = i;
            var cur = rest.charAt(i);
            i++;
            if (magicStart === rest.substr(curIndex, magicStart.length)) {
                if (state.inValue && curIndex > state.valueStart) {
                    handler.attrValue(rest.substring(state.valueStart, curIndex));
                } else if (state.inName && state.nameStart < curIndex) {
                    callAttrStart(state, curIndex, handler, rest);
                    callAttrEnd(state, curIndex, handler, rest);
                } else if (state.lookingForValue) {
                    state.inValue = true;
                } else if (state.lookingForEq && state.attrStart) {
                    callAttrEnd(state, curIndex, handler, rest);
                }
                magicMatch.lastIndex = curIndex;
                var match = magicMatch.exec(rest);
                if (match) {
                    handler.special(match[1]);
                    i = curIndex + match[0].length;
                    if (state.inValue) {
                        state.valueStart = curIndex + match[0].length;
                    }
                }
            } else if (state.inValue) {
                if (state.inQuote) {
                    if (cur === state.inQuote) {
                        callAttrEnd(state, curIndex, handler, rest);
                    }
                } else if (space.test(cur)) {
                    callAttrEnd(state, curIndex, handler, rest);
                }
            } else if (cur === '=' && (state.lookingForEq || state.lookingForName || state.inName)) {
                if (!state.attrStart) {
                    callAttrStart(state, curIndex, handler, rest);
                }
                state.lookingForValue = true;
                state.lookingForEq = false;
                state.lookingForName = false;
            } else if (state.inName) {
                var started = rest[state.nameStart], otherStart, otherOpposite;
                if (startOppositesMap[started] === cur) {
                    otherStart = started === '{' ? '(' : '{';
                    otherOpposite = startOppositesMap[otherStart];
                    if (rest[curIndex + 1] === otherOpposite) {
                        callAttrStart(state, curIndex + 2, handler, rest);
                        i++;
                    } else {
                        callAttrStart(state, curIndex + 1, handler, rest);
                    }
                    state.lookingForEq = true;
                } else if (space.test(cur) && started !== '{' && started !== '(') {
                    callAttrStart(state, curIndex, handler, rest);
                    state.lookingForEq = true;
                }
            } else if (state.lookingForName) {
                if (!space.test(cur)) {
                    if (state.attrStart) {
                        callAttrEnd(state, curIndex, handler, rest);
                    }
                    state.nameStart = curIndex;
                    state.inName = true;
                }
            } else if (state.lookingForValue) {
                if (!space.test(cur)) {
                    state.lookingForValue = false;
                    state.inValue = true;
                    if (cur === '\'' || cur === '"') {
                        state.inQuote = cur;
                        state.valueStart = curIndex + 1;
                    } else {
                        state.valueStart = curIndex;
                    }
                } else if (i === rest.length) {
                    callAttrEnd(state, curIndex, handler, rest);
                }
            }
        }
        if (state.inName) {
            callAttrStart(state, curIndex + 1, handler, rest);
            callAttrEnd(state, curIndex + 1, handler, rest);
        } else if (state.lookingForEq || state.lookingForValue || state.inValue) {
            callAttrEnd(state, curIndex + 1, handler, rest);
        }
        magicMatch.lastIndex = 0;
    };
    HTMLParser.searchStartTag = function (html) {
        var closingIndex = html.indexOf('>');
        if (closingIndex === -1 || !alphaRegex.test(html[1])) {
            return null;
        }
        var tagName, tagContent, match, rest = '', unary = '';
        var startTag = html.substring(0, closingIndex + 1);
        var isUnary = startTag[startTag.length - 2] === '/';
        var spaceIndex = startTag.search(space);
        if (isUnary) {
            unary = '/';
            tagContent = startTag.substring(1, startTag.length - 2).trim();
        } else {
            tagContent = startTag.substring(1, startTag.length - 1).trim();
        }
        if (spaceIndex === -1) {
            tagName = tagContent;
        } else {
            spaceIndex--;
            tagName = tagContent.substring(0, spaceIndex);
            rest = tagContent.substring(spaceIndex);
        }
        match = [
            startTag,
            tagName,
            rest,
            unary
        ];
        return {
            match: match,
            html: html.substring(startTag.length)
        };
    };
    module.exports = namespace.HTMLParser = HTMLParser;
});
/*can-util@3.9.6#js/set-immediate/set-immediate*/
define('can-util@3.9.6#js/set-immediate/set-immediate', function (require, exports, module) {
    (function (global) {
        'use strict';
        var global = require('../global/global')();
        module.exports = global.setImmediate || function (cb) {
            return setTimeout(cb, 0);
        };
    }(function () {
        return this;
    }()));
});
/*can-util@3.9.6#dom/child-nodes/child-nodes*/
define('can-util@3.9.6#dom/child-nodes/child-nodes', function (require, exports, module) {
    'use strict';
    function childNodes(node) {
        var childNodes = node.childNodes;
        if ('length' in childNodes) {
            return childNodes;
        } else {
            var cur = node.firstChild;
            var nodes = [];
            while (cur) {
                nodes.push(cur);
                cur = cur.nextSibling;
            }
            return nodes;
        }
    }
    module.exports = childNodes;
});
/*can-util@3.9.6#dom/contains/contains*/
define('can-util@3.9.6#dom/contains/contains', function (require, exports, module) {
    'use strict';
    module.exports = function (child) {
        return this.contains(child);
    };
});
/*can-util@3.9.6#dom/mutate/mutate*/
define('can-util@3.9.6#dom/mutate/mutate', function (require, exports, module) {
    'use strict';
    var makeArray = require('../../js/make-array/make-array');
    var setImmediate = require('../../js/set-immediate/set-immediate');
    var CID = require('can-cid');
    var getMutationObserver = require('../mutation-observer/mutation-observer');
    var childNodes = require('../child-nodes/child-nodes');
    var domContains = require('../contains/contains');
    var domDispatch = require('../dispatch/dispatch');
    var DOCUMENT = require('../document/document');
    var domData = require('../data/data');
    var mutatedElements;
    var checks = {
        inserted: function (root, elem) {
            return domContains.call(root, elem);
        },
        removed: function (root, elem) {
            return !domContains.call(root, elem);
        }
    };
    var fireOn = function (elems, root, check, event, dispatched) {
        if (!elems.length) {
            return;
        }
        var children, cid;
        for (var i = 0, elem; (elem = elems[i]) !== undefined; i++) {
            cid = CID(elem);
            if (elem.getElementsByTagName && check(root, elem) && !dispatched[cid]) {
                dispatched[cid] = true;
                children = makeArray(elem.getElementsByTagName('*'));
                domDispatch.call(elem, event, [], false);
                if (event === 'removed') {
                    domData.delete.call(elem);
                }
                for (var j = 0, child; (child = children[j]) !== undefined; j++) {
                    cid = CID(child);
                    if (!dispatched[cid]) {
                        domDispatch.call(child, event, [], false);
                        if (event === 'removed') {
                            domData.delete.call(child);
                        }
                        dispatched[cid] = true;
                    }
                }
            }
        }
    };
    var fireMutations = function () {
        var mutations = mutatedElements;
        mutatedElements = null;
        var firstElement = mutations[0][1][0];
        var doc = DOCUMENT() || firstElement.ownerDocument || firstElement;
        var root = doc.contains ? doc : doc.documentElement;
        var dispatched = {
            inserted: {},
            removed: {}
        };
        mutations.forEach(function (mutation) {
            fireOn(mutation[1], root, checks[mutation[0]], mutation[0], dispatched[mutation[0]]);
        });
    };
    var mutated = function (elements, type) {
        if (!getMutationObserver() && elements.length) {
            var firstElement = elements[0];
            var doc = DOCUMENT() || firstElement.ownerDocument || firstElement;
            var root = doc.contains ? doc : doc.documentElement;
            if (checks.inserted(root, firstElement)) {
                if (!mutatedElements) {
                    mutatedElements = [];
                    setImmediate(fireMutations);
                }
                mutatedElements.push([
                    type,
                    elements
                ]);
            }
        }
    };
    module.exports = {
        appendChild: function (child) {
            if (getMutationObserver()) {
                this.appendChild(child);
            } else {
                var children;
                if (child.nodeType === 11) {
                    children = makeArray(childNodes(child));
                } else {
                    children = [child];
                }
                this.appendChild(child);
                mutated(children, 'inserted');
            }
        },
        insertBefore: function (child, ref, document) {
            if (getMutationObserver()) {
                this.insertBefore(child, ref);
            } else {
                var children;
                if (child.nodeType === 11) {
                    children = makeArray(childNodes(child));
                } else {
                    children = [child];
                }
                this.insertBefore(child, ref);
                mutated(children, 'inserted');
            }
        },
        removeChild: function (child) {
            if (getMutationObserver()) {
                this.removeChild(child);
            } else {
                mutated([child], 'removed');
                this.removeChild(child);
            }
        },
        replaceChild: function (newChild, oldChild) {
            if (getMutationObserver()) {
                this.replaceChild(newChild, oldChild);
            } else {
                var children;
                if (newChild.nodeType === 11) {
                    children = makeArray(childNodes(newChild));
                } else {
                    children = [newChild];
                }
                mutated([oldChild], 'removed');
                this.replaceChild(newChild, oldChild);
                mutated(children, 'inserted');
            }
        },
        inserted: function (elements) {
            mutated(elements, 'inserted');
        },
        removed: function (elements) {
            mutated(elements, 'removed');
        }
    };
});
/*can-view-nodelist@3.1.0#can-view-nodelist*/
define('can-view-nodelist@3.1.0#can-view-nodelist', function (require, exports, module) {
    var makeArray = require('can-util/js/make-array/make-array');
    var each = require('can-util/js/each/each');
    var namespace = require('can-namespace');
    var domMutate = require('can-util/dom/mutate/mutate');
    var CIDMap = require('can-util/js/cid-map/cid-map');
    var nodeMap = new CIDMap(), splice = [].splice, push = [].push, itemsInChildListTree = function (list) {
            var count = 0;
            for (var i = 0, len = list.length; i < len; i++) {
                var item = list[i];
                if (item.nodeType) {
                    count++;
                } else {
                    count += itemsInChildListTree(item);
                }
            }
            return count;
        }, replacementMap = function (replacements) {
            var map = new CIDMap();
            for (var i = 0, len = replacements.length; i < len; i++) {
                var node = nodeLists.first(replacements[i]);
                map.set(node, replacements[i]);
            }
            return map;
        }, addUnfoundAsDeepChildren = function (list, rMap) {
            rMap.forEach(function (replacement) {
                list.newDeepChildren.push(replacement);
            });
        };
    var nodeLists = {
        update: function (nodeList, newNodes) {
            var oldNodes = nodeLists.unregisterChildren(nodeList);
            newNodes = makeArray(newNodes);
            var oldListLength = nodeList.length;
            splice.apply(nodeList, [
                0,
                oldListLength
            ].concat(newNodes));
            if (nodeList.replacements) {
                nodeLists.nestReplacements(nodeList);
                nodeList.deepChildren = nodeList.newDeepChildren;
                nodeList.newDeepChildren = [];
            } else {
                nodeLists.nestList(nodeList);
            }
            return oldNodes;
        },
        nestReplacements: function (list) {
            var index = 0, rMap = replacementMap(list.replacements), rCount = list.replacements.length;
            while (index < list.length && rCount) {
                var node = list[index], replacement = rMap.get(node);
                if (replacement) {
                    rMap['delete'](node);
                    list.splice(index, itemsInChildListTree(replacement), replacement);
                    rCount--;
                }
                index++;
            }
            if (rCount) {
                addUnfoundAsDeepChildren(list, rMap);
            }
            list.replacements = [];
        },
        nestList: function (list) {
            var index = 0;
            while (index < list.length) {
                var node = list[index], childNodeList = nodeMap.get(node);
                if (childNodeList) {
                    if (childNodeList !== list) {
                        list.splice(index, itemsInChildListTree(childNodeList), childNodeList);
                    }
                } else {
                    nodeMap.set(node, list);
                }
                index++;
            }
        },
        last: function (nodeList) {
            var last = nodeList[nodeList.length - 1];
            if (last.nodeType) {
                return last;
            } else {
                return nodeLists.last(last);
            }
        },
        first: function (nodeList) {
            var first = nodeList[0];
            if (first.nodeType) {
                return first;
            } else {
                return nodeLists.first(first);
            }
        },
        flatten: function (nodeList) {
            var items = [];
            for (var i = 0; i < nodeList.length; i++) {
                var item = nodeList[i];
                if (item.nodeType) {
                    items.push(item);
                } else {
                    items.push.apply(items, nodeLists.flatten(item));
                }
            }
            return items;
        },
        register: function (nodeList, unregistered, parent, directlyNested) {
            nodeList.unregistered = unregistered;
            nodeList.parentList = parent;
            nodeList.nesting = parent && typeof parent.nesting !== 'undefined' ? parent.nesting + 1 : 0;
            if (parent) {
                nodeList.deepChildren = [];
                nodeList.newDeepChildren = [];
                nodeList.replacements = [];
                if (parent !== true) {
                    if (directlyNested) {
                        parent.replacements.push(nodeList);
                    } else {
                        parent.newDeepChildren.push(nodeList);
                    }
                }
            } else {
                nodeLists.nestList(nodeList);
            }
            return nodeList;
        },
        unregisterChildren: function (nodeList) {
            var nodes = [];
            each(nodeList, function (node) {
                if (node.nodeType) {
                    if (!nodeList.replacements) {
                        nodeMap['delete'](node);
                    }
                    nodes.push(node);
                } else {
                    push.apply(nodes, nodeLists.unregister(node, true));
                }
            });
            each(nodeList.deepChildren, function (nodeList) {
                nodeLists.unregister(nodeList, true);
            });
            return nodes;
        },
        unregister: function (nodeList, isChild) {
            var nodes = nodeLists.unregisterChildren(nodeList, true);
            if (nodeList.unregistered) {
                var unregisteredCallback = nodeList.unregistered;
                nodeList.replacements = nodeList.unregistered = null;
                if (!isChild) {
                    var deepChildren = nodeList.parentList && nodeList.parentList.deepChildren;
                    if (deepChildren) {
                        var index = deepChildren.indexOf(nodeList);
                        if (index !== -1) {
                            deepChildren.splice(index, 1);
                        }
                    }
                }
                unregisteredCallback();
            }
            return nodes;
        },
        after: function (oldElements, newFrag) {
            var last = oldElements[oldElements.length - 1];
            if (last.nextSibling) {
                domMutate.insertBefore.call(last.parentNode, newFrag, last.nextSibling);
            } else {
                domMutate.appendChild.call(last.parentNode, newFrag);
            }
        },
        replace: function (oldElements, newFrag) {
            var selectedValue, parentNode = oldElements[0].parentNode;
            if (parentNode.nodeName.toUpperCase() === 'SELECT' && parentNode.selectedIndex >= 0) {
                selectedValue = parentNode.value;
            }
            if (oldElements.length === 1) {
                domMutate.replaceChild.call(parentNode, newFrag, oldElements[0]);
            } else {
                nodeLists.after(oldElements, newFrag);
                nodeLists.remove(oldElements);
            }
            if (selectedValue !== undefined) {
                parentNode.value = selectedValue;
            }
        },
        remove: function (elementsToBeRemoved) {
            var parent = elementsToBeRemoved[0] && elementsToBeRemoved[0].parentNode;
            each(elementsToBeRemoved, function (child) {
                domMutate.removeChild.call(parent, child);
            });
        },
        nodeMap: nodeMap
    };
    module.exports = namespace.nodeLists = nodeLists;
});
/*can-util@3.9.6#dom/fragment/fragment*/
define('can-util@3.9.6#dom/fragment/fragment', function (require, exports, module) {
    'use strict';
    var getDocument = require('../document/document'), childNodes = require('../child-nodes/child-nodes');
    var fragmentRE = /^\s*<(\w+)[^>]*>/, toString = {}.toString, fragment = function (html, name, doc) {
            if (name === undefined) {
                name = fragmentRE.test(html) && RegExp.$1;
            }
            if (html && toString.call(html.replace) === '[object Function]') {
                html = html.replace(/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, '<$1></$2>');
            }
            var container = doc.createElement('div'), temp = doc.createElement('div');
            if (name === 'tbody' || name === 'tfoot' || name === 'thead' || name === 'colgroup') {
                temp.innerHTML = '<table>' + html + '</table>';
                container = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild;
            } else if (name === 'col') {
                temp.innerHTML = '<table><colgroup>' + html + '</colgroup></table>';
                container = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild.firstChild;
            } else if (name === 'tr') {
                temp.innerHTML = '<table><tbody>' + html + '</tbody></table>';
                container = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild.firstChild;
            } else if (name === 'td' || name === 'th') {
                temp.innerHTML = '<table><tbody><tr>' + html + '</tr></tbody></table>';
                container = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild.firstChild.firstChild;
            } else if (name === 'option') {
                temp.innerHTML = '<select>' + html + '</select>';
                container = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild;
            } else {
                container.innerHTML = '' + html;
            }
            var tmp = {}, children = childNodes(container);
            tmp.length = children.length;
            for (var i = 0; i < children.length; i++) {
                tmp[i] = children[i];
            }
            return [].slice.call(tmp);
        };
    var buildFragment = function (html, doc) {
        if (html && html.nodeType === 11) {
            return html;
        }
        if (!doc) {
            doc = getDocument();
        } else if (doc.length) {
            doc = doc[0];
        }
        var parts = fragment(html, undefined, doc), frag = (doc || document).createDocumentFragment();
        for (var i = 0, length = parts.length; i < length; i++) {
            frag.appendChild(parts[i]);
        }
        return frag;
    };
    module.exports = buildFragment;
});
/*can-util@3.9.6#dom/frag/frag*/
define('can-util@3.9.6#dom/frag/frag', function (require, exports, module) {
    'use strict';
    var getDocument = require('../document/document');
    var fragment = require('../fragment/fragment');
    var each = require('../../js/each/each');
    var childNodes = require('../child-nodes/child-nodes');
    var makeFrag = function (item, doc) {
        var document = doc || getDocument();
        var frag;
        if (!item || typeof item === 'string') {
            frag = fragment(item == null ? '' : '' + item, document);
            if (!frag.childNodes.length) {
                frag.appendChild(document.createTextNode(''));
            }
            return frag;
        } else if (item.nodeType === 11) {
            return item;
        } else if (typeof item.nodeType === 'number') {
            frag = document.createDocumentFragment();
            frag.appendChild(item);
            return frag;
        } else if (typeof item.length === 'number') {
            frag = document.createDocumentFragment();
            each(item, function (item) {
                frag.appendChild(makeFrag(item));
            });
            if (!childNodes(frag).length) {
                frag.appendChild(document.createTextNode(''));
            }
            return frag;
        } else {
            frag = fragment('' + item, document);
            if (!childNodes(frag).length) {
                frag.appendChild(document.createTextNode(''));
            }
            return frag;
        }
    };
    module.exports = makeFrag;
});
/*can-util@3.9.6#dom/is-of-global-document/is-of-global-document*/
define('can-util@3.9.6#dom/is-of-global-document/is-of-global-document', function (require, exports, module) {
    'use strict';
    var getDocument = require('../document/document');
    module.exports = function (el) {
        return (el.ownerDocument || el) === getDocument();
    };
});
/*can-util@3.9.6#dom/events/make-mutation-event/make-mutation-event*/
define('can-util@3.9.6#dom/events/make-mutation-event/make-mutation-event', function (require, exports, module) {
    (function (global) {
        'use strict';
        var events = require('../events');
        var domData = require('../../data/data');
        var getMutationObserver = require('../../mutation-observer/mutation-observer');
        var domDispatch = require('../../dispatch/dispatch');
        var mutationDocument = require('../../mutation-observer/document/document');
        var getDocument = require('../../document/document');
        var CIDMap = require('../../../js/cid-map/cid-map');
        var string = require('../../../js/string/string');
        require('../../is-of-global-document/is-of-global-document');
        module.exports = function (specialEventName, mutationNodesProperty) {
            var originalAdd = events.addEventListener, originalRemove = events.removeEventListener;
            events.addEventListener = function (eventName) {
                if (eventName === specialEventName && getMutationObserver()) {
                    var documentElement = getDocument().documentElement;
                    var specialEventData = domData.get.call(documentElement, specialEventName + 'Data');
                    if (!specialEventData) {
                        specialEventData = {
                            handler: function (mutatedNode) {
                                if (specialEventData.nodeIdsRespondingToInsert.has(mutatedNode)) {
                                    domDispatch.call(mutatedNode, specialEventName, [], false);
                                    specialEventData.nodeIdsRespondingToInsert.delete(mutatedNode);
                                }
                            },
                            nodeIdsRespondingToInsert: new CIDMap()
                        };
                        mutationDocument['on' + string.capitalize(mutationNodesProperty)](specialEventData.handler);
                        domData.set.call(documentElement, specialEventName + 'Data', specialEventData);
                    }
                    var count = specialEventData.nodeIdsRespondingToInsert.get(this) || 0;
                    specialEventData.nodeIdsRespondingToInsert.set(this, count + 1);
                }
                return originalAdd.apply(this, arguments);
            };
            events.removeEventListener = function (eventName) {
                if (eventName === specialEventName && getMutationObserver()) {
                    var documentElement = getDocument().documentElement;
                    var specialEventData = domData.get.call(documentElement, specialEventName + 'Data');
                    if (specialEventData) {
                        var newCount = specialEventData.nodeIdsRespondingToInsert.get(this) - 1;
                        if (newCount) {
                            specialEventData.nodeIdsRespondingToInsert.set(this, newCount);
                        } else {
                            specialEventData.nodeIdsRespondingToInsert.delete(this);
                        }
                        if (!specialEventData.nodeIdsRespondingToInsert.size) {
                            mutationDocument['off' + string.capitalize(mutationNodesProperty)](specialEventData.handler);
                            domData.clean.call(documentElement, specialEventName + 'Data');
                        }
                    }
                }
                return originalRemove.apply(this, arguments);
            };
        };
    }(function () {
        return this;
    }()));
});
/*can-util@3.9.6#dom/events/removed/removed*/
define('can-util@3.9.6#dom/events/removed/removed', function (require, exports, module) {
    'use strict';
    var makeMutationEvent = require('../make-mutation-event/make-mutation-event');
    makeMutationEvent('removed', 'removedNodes');
});
/*can-view-live@3.2.0#lib/core*/
define('can-view-live@3.2.0#lib/core', function (require, exports, module) {
    var parser = require('can-view-parser');
    var domEvents = require('can-util/dom/events/events');
    var nodeLists = require('can-view-nodelist');
    var makeFrag = require('can-util/dom/frag/frag');
    var childNodes = require('can-util/dom/child-nodes/child-nodes');
    var canReflect = require('can-reflect');
    require('can-util/dom/events/removed/removed');
    var childMutationCallbacks = {};
    var live = {
        setup: function (el, bind, unbind) {
            var tornDown = false, teardown = function () {
                    if (!tornDown) {
                        tornDown = true;
                        unbind(data);
                        domEvents.removeEventListener.call(el, 'removed', teardown);
                    }
                    return true;
                }, data = {
                    teardownCheck: function (parent) {
                        return parent ? false : teardown();
                    }
                };
            domEvents.addEventListener.call(el, 'removed', teardown);
            bind(data);
            return data;
        },
        listen: function (el, compute, change) {
            return live.setup(el, function () {
                canReflect.onValue(compute, change);
            }, function (data) {
                canReflect.offValue(compute, change);
                if (data.nodeList) {
                    nodeLists.unregister(data.nodeList);
                }
            });
        },
        getAttributeParts: function (newVal) {
            var attrs = {}, attr;
            parser.parseAttrs(newVal, {
                attrStart: function (name) {
                    attrs[name] = '';
                    attr = name;
                },
                attrValue: function (value) {
                    attrs[attr] += value;
                },
                attrEnd: function () {
                }
            });
            return attrs;
        },
        isNode: function (obj) {
            return obj && obj.nodeType;
        },
        addTextNodeIfNoChildren: function (frag) {
            if (!frag.firstChild) {
                frag.appendChild(frag.ownerDocument.createTextNode(''));
            }
        },
        registerChildMutationCallback: function (tag, callback) {
            if (callback) {
                childMutationCallbacks[tag] = callback;
            } else {
                return childMutationCallbacks[tag];
            }
        },
        callChildMutationCallback: function (el) {
            var callback = el && childMutationCallbacks[el.nodeName.toLowerCase()];
            if (callback) {
                callback(el);
            }
        },
        replace: function (nodes, val, teardown) {
            var oldNodes = nodes.slice(0), frag = makeFrag(val);
            nodeLists.register(nodes, teardown);
            nodeLists.update(nodes, childNodes(frag));
            nodeLists.replace(oldNodes, frag);
            return nodes;
        },
        getParentNode: function (el, defaultParentNode) {
            return defaultParentNode && el.parentNode.nodeType === 11 ? defaultParentNode : el.parentNode;
        },
        makeString: function (txt) {
            return txt == null ? '' : '' + txt;
        }
    };
    module.exports = live;
});
/*can-util@3.9.6#js/diff/diff*/
define('can-util@3.9.6#js/diff/diff', function (require, exports, module) {
    'use strict';
    var slice = [].slice;
    var defaultIdentity = function (a, b) {
        return a === b;
    };
    function reverseDiff(oldDiffStopIndex, newDiffStopIndex, oldList, newList, identity) {
        var oldIndex = oldList.length - 1, newIndex = newList.length - 1;
        while (oldIndex > oldDiffStopIndex && newIndex > newDiffStopIndex) {
            var oldItem = oldList[oldIndex], newItem = newList[newIndex];
            if (identity(oldItem, newItem)) {
                oldIndex--;
                newIndex--;
                continue;
            } else {
                return [{
                        index: newDiffStopIndex,
                        deleteCount: oldIndex - oldDiffStopIndex + 1,
                        insert: slice.call(newList, newDiffStopIndex, newIndex + 1)
                    }];
            }
        }
        return [{
                index: newDiffStopIndex,
                deleteCount: oldIndex - oldDiffStopIndex + 1,
                insert: slice.call(newList, newDiffStopIndex, newIndex + 1)
            }];
    }
    module.exports = exports = function (oldList, newList, identity) {
        identity = identity || defaultIdentity;
        var oldIndex = 0, newIndex = 0, oldLength = oldList.length, newLength = newList.length, patches = [];
        while (oldIndex < oldLength && newIndex < newLength) {
            var oldItem = oldList[oldIndex], newItem = newList[newIndex];
            if (identity(oldItem, newItem)) {
                oldIndex++;
                newIndex++;
                continue;
            }
            if (newIndex + 1 < newLength && identity(oldItem, newList[newIndex + 1])) {
                patches.push({
                    index: newIndex,
                    deleteCount: 0,
                    insert: [newList[newIndex]]
                });
                oldIndex++;
                newIndex += 2;
                continue;
            } else if (oldIndex + 1 < oldLength && identity(oldList[oldIndex + 1], newItem)) {
                patches.push({
                    index: newIndex,
                    deleteCount: 1,
                    insert: []
                });
                oldIndex += 2;
                newIndex++;
                continue;
            } else {
                patches.push.apply(patches, reverseDiff(oldIndex, newIndex, oldList, newList, identity));
                return patches;
            }
        }
        if (newIndex === newLength && oldIndex === oldLength) {
            return patches;
        }
        patches.push({
            index: newIndex,
            deleteCount: oldLength - oldIndex,
            insert: slice.call(newList, newIndex)
        });
        return patches;
    };
});
/*can-util@3.9.6#dom/events/attributes/attributes*/
define('can-util@3.9.6#dom/events/attributes/attributes', function (require, exports, module) {
    (function (global) {
        'use strict';
        var events = require('../events');
        var isOfGlobalDocument = require('../../is-of-global-document/is-of-global-document');
        var domData = require('../../data/data');
        var getMutationObserver = require('../../mutation-observer/mutation-observer');
        var assign = require('../../../js/assign/assign');
        var domDispatch = require('../../dispatch/dispatch');
        var originalAdd = events.addEventListener, originalRemove = events.removeEventListener;
        events.addEventListener = function (eventName) {
            if (eventName === 'attributes') {
                var MutationObserver = getMutationObserver();
                if (isOfGlobalDocument(this) && MutationObserver) {
                    var existingObserver = domData.get.call(this, 'canAttributesObserver');
                    if (!existingObserver) {
                        var self = this;
                        var observer = new MutationObserver(function (mutations) {
                            mutations.forEach(function (mutation) {
                                var copy = assign({}, mutation);
                                domDispatch.call(self, copy, [], false);
                            });
                        });
                        observer.observe(this, {
                            attributes: true,
                            attributeOldValue: true
                        });
                        domData.set.call(this, 'canAttributesObserver', observer);
                    }
                } else {
                    domData.set.call(this, 'canHasAttributesBindings', true);
                }
            }
            return originalAdd.apply(this, arguments);
        };
        events.removeEventListener = function (eventName) {
            if (eventName === 'attributes') {
                var MutationObserver = getMutationObserver();
                var observer;
                if (isOfGlobalDocument(this) && MutationObserver) {
                    observer = domData.get.call(this, 'canAttributesObserver');
                    if (observer && observer.disconnect) {
                        observer.disconnect();
                        domData.clean.call(this, 'canAttributesObserver');
                    }
                } else {
                    domData.clean.call(this, 'canHasAttributesBindings');
                }
            }
            return originalRemove.apply(this, arguments);
        };
    }(function () {
        return this;
    }()));
});
/*can-util@3.9.6#dom/events/inserted/inserted*/
define('can-util@3.9.6#dom/events/inserted/inserted', function (require, exports, module) {
    'use strict';
    var makeMutationEvent = require('../make-mutation-event/make-mutation-event');
    makeMutationEvent('inserted', 'addedNodes');
});
/*can-util@3.9.6#dom/attr/attr*/
define('can-util@3.9.6#dom/attr/attr', function (require, exports, module) {
    (function (global) {
        'use strict';
        var setImmediate = require('../../js/set-immediate/set-immediate');
        var getDocument = require('../document/document');
        var global = require('../../js/global/global')();
        var isOfGlobalDocument = require('../is-of-global-document/is-of-global-document');
        var setData = require('../data/data');
        var domContains = require('../contains/contains');
        var domEvents = require('../events/events');
        var domDispatch = require('../dispatch/dispatch');
        var MUTATION_OBSERVER = require('../mutation-observer/mutation-observer');
        var each = require('../../js/each/each');
        var types = require('can-types');
        var diff = require('../../js/diff/diff');
        require('../events/attributes/attributes');
        require('../events/inserted/inserted');
        var namespaces = { 'xlink': 'http://www.w3.org/1999/xlink' };
        var formElements = {
                'INPUT': true,
                'TEXTAREA': true,
                'SELECT': true
            }, toString = function (value) {
                if (value == null) {
                    return '';
                } else {
                    return '' + value;
                }
            }, isSVG = function (el) {
                return el.namespaceURI === 'http://www.w3.org/2000/svg';
            }, truthy = function () {
                return true;
            }, getSpecialTest = function (special) {
                return special && special.test || truthy;
            }, propProp = function (prop, obj) {
                obj = obj || {};
                obj.get = function () {
                    return this[prop];
                };
                obj.set = function (value) {
                    if (this[prop] !== value) {
                        this[prop] = value;
                    }
                    return value;
                };
                return obj;
            }, booleanProp = function (prop) {
                return {
                    isBoolean: true,
                    set: function (value) {
                        if (prop in this) {
                            this[prop] = value !== false;
                        } else {
                            this.setAttribute(prop, '');
                        }
                    },
                    remove: function () {
                        this[prop] = false;
                    }
                };
            }, setupMO = function (el, callback) {
                var attrMO = setData.get.call(el, 'attrMO');
                if (!attrMO) {
                    var onMutation = function () {
                        callback.call(el);
                    };
                    var MO = MUTATION_OBSERVER();
                    if (MO) {
                        var observer = new MO(onMutation);
                        observer.observe(el, {
                            childList: true,
                            subtree: true
                        });
                        setData.set.call(el, 'attrMO', observer);
                    } else {
                        setData.set.call(el, 'attrMO', true);
                        setData.set.call(el, 'canBindingCallback', { onMutation: onMutation });
                    }
                }
            }, _findOptionToSelect = function (parent, value) {
                var child = parent.firstChild;
                while (child) {
                    if (child.nodeName === 'OPTION' && value === child.value) {
                        return child;
                    }
                    if (child.nodeName === 'OPTGROUP') {
                        var groupChild = _findOptionToSelect(child, value);
                        if (groupChild) {
                            return groupChild;
                        }
                    }
                    child = child.nextSibling;
                }
            }, setChildOptions = function (el, value) {
                var option;
                if (value != null) {
                    option = _findOptionToSelect(el, value);
                }
                if (option) {
                    option.selected = true;
                } else {
                    el.selectedIndex = -1;
                }
            }, forEachOption = function (parent, fn) {
                var child = parent.firstChild;
                while (child) {
                    if (child.nodeName === 'OPTION') {
                        fn(child);
                    }
                    if (child.nodeName === 'OPTGROUP') {
                        forEachOption(child, fn);
                    }
                    child = child.nextSibling;
                }
            }, collectSelectedOptions = function (parent) {
                var selectedValues = [];
                forEachOption(parent, function (option) {
                    if (option.selected) {
                        selectedValues.push(option.value);
                    }
                });
                return selectedValues;
            }, markSelectedOptions = function (parent, values) {
                forEachOption(parent, function (option) {
                    option.selected = values.indexOf(option.value) !== -1;
                });
            }, setChildOptionsOnChange = function (select, aEL) {
                var handler = setData.get.call(select, 'attrSetChildOptions');
                if (handler) {
                    return Function.prototype;
                }
                handler = function () {
                    setChildOptions(select, select.value);
                };
                setData.set.call(select, 'attrSetChildOptions', handler);
                aEL.call(select, 'change', handler);
                return function (rEL) {
                    setData.clean.call(select, 'attrSetChildOptions');
                    rEL.call(select, 'change', handler);
                };
            }, attr = {
                special: {
                    checked: {
                        get: function () {
                            return this.checked;
                        },
                        set: function (val) {
                            var notFalse = !!val || val === '' || arguments.length === 0;
                            this.checked = notFalse;
                            if (notFalse && this.type === 'radio') {
                                this.defaultChecked = true;
                            }
                            return val;
                        },
                        remove: function () {
                            this.checked = false;
                        },
                        test: function () {
                            return this.nodeName === 'INPUT';
                        }
                    },
                    'class': {
                        get: function () {
                            if (isSVG(this)) {
                                return this.getAttribute('class');
                            }
                            return this.className;
                        },
                        set: function (val) {
                            val = val || '';
                            if (isSVG(this)) {
                                this.setAttribute('class', '' + val);
                            } else {
                                this.className = val;
                            }
                            return val;
                        }
                    },
                    disabled: booleanProp('disabled'),
                    focused: {
                        get: function () {
                            return this === document.activeElement;
                        },
                        set: function (val) {
                            var cur = attr.get(this, 'focused');
                            var docEl = this.ownerDocument.documentElement;
                            var element = this;
                            function focusTask() {
                                if (val) {
                                    element.focus();
                                } else {
                                    element.blur();
                                }
                            }
                            if (cur !== val) {
                                if (!domContains.call(docEl, element)) {
                                    var initialSetHandler = function () {
                                        domEvents.removeEventListener.call(element, 'inserted', initialSetHandler);
                                        focusTask();
                                    };
                                    domEvents.addEventListener.call(element, 'inserted', initialSetHandler);
                                } else {
                                    types.queueTask([
                                        focusTask,
                                        this,
                                        []
                                    ]);
                                }
                            }
                            return !!val;
                        },
                        addEventListener: function (eventName, handler, aEL) {
                            aEL.call(this, 'focus', handler);
                            aEL.call(this, 'blur', handler);
                            return function (rEL) {
                                rEL.call(this, 'focus', handler);
                                rEL.call(this, 'blur', handler);
                            };
                        },
                        test: function () {
                            return this.nodeName === 'INPUT';
                        }
                    },
                    'for': propProp('htmlFor'),
                    innertext: propProp('innerText'),
                    innerhtml: propProp('innerHTML'),
                    innerHTML: propProp('innerHTML', {
                        addEventListener: function (eventName, handler, aEL) {
                            var handlers = [];
                            var el = this;
                            each([
                                'change',
                                'blur'
                            ], function (eventName) {
                                var localHandler = function () {
                                    handler.apply(this, arguments);
                                };
                                domEvents.addEventListener.call(el, eventName, localHandler);
                                handlers.push([
                                    eventName,
                                    localHandler
                                ]);
                            });
                            return function (rEL) {
                                each(handlers, function (info) {
                                    rEL.call(el, info[0], info[1]);
                                });
                            };
                        }
                    }),
                    required: booleanProp('required'),
                    readonly: booleanProp('readOnly'),
                    selected: {
                        get: function () {
                            return this.selected;
                        },
                        set: function (val) {
                            val = !!val;
                            setData.set.call(this, 'lastSetValue', val);
                            return this.selected = val;
                        },
                        addEventListener: function (eventName, handler, aEL) {
                            var option = this;
                            var select = this.parentNode;
                            var lastVal = option.selected;
                            var localHandler = function (changeEvent) {
                                var curVal = option.selected;
                                lastVal = setData.get.call(option, 'lastSetValue') || lastVal;
                                if (curVal !== lastVal) {
                                    lastVal = curVal;
                                    domDispatch.call(option, eventName);
                                }
                            };
                            var removeChangeHandler = setChildOptionsOnChange(select, aEL);
                            domEvents.addEventListener.call(select, 'change', localHandler);
                            aEL.call(option, eventName, handler);
                            return function (rEL) {
                                removeChangeHandler(rEL);
                                domEvents.removeEventListener.call(select, 'change', localHandler);
                                rEL.call(option, eventName, handler);
                            };
                        },
                        test: function () {
                            return this.nodeName === 'OPTION' && this.parentNode && this.parentNode.nodeName === 'SELECT';
                        }
                    },
                    src: {
                        set: function (val) {
                            if (val == null || val === '') {
                                this.removeAttribute('src');
                                return null;
                            } else {
                                this.setAttribute('src', val);
                                return val;
                            }
                        }
                    },
                    style: {
                        set: function () {
                            var el = global.document && getDocument().createElement('div');
                            if (el && el.style && 'cssText' in el.style) {
                                return function (val) {
                                    return this.style.cssText = val || '';
                                };
                            } else {
                                return function (val) {
                                    return this.setAttribute('style', val);
                                };
                            }
                        }()
                    },
                    textcontent: propProp('textContent'),
                    value: {
                        get: function () {
                            var value = this.value;
                            if (this.nodeName === 'SELECT') {
                                if ('selectedIndex' in this && this.selectedIndex === -1) {
                                    value = undefined;
                                }
                            }
                            return value;
                        },
                        set: function (value) {
                            var nodeName = this.nodeName.toLowerCase();
                            if (nodeName === 'input') {
                                value = toString(value);
                            }
                            if (this.value !== value || nodeName === 'option') {
                                this.value = value;
                            }
                            if (attr.defaultValue[nodeName]) {
                                this.defaultValue = value;
                            }
                            if (nodeName === 'select') {
                                setData.set.call(this, 'attrValueLastVal', value);
                                setChildOptions(this, value === null ? value : this.value);
                                var docEl = this.ownerDocument.documentElement;
                                if (!domContains.call(docEl, this)) {
                                    var select = this;
                                    var initialSetHandler = function () {
                                        domEvents.removeEventListener.call(select, 'inserted', initialSetHandler);
                                        setChildOptions(select, value === null ? value : select.value);
                                    };
                                    domEvents.addEventListener.call(this, 'inserted', initialSetHandler);
                                }
                                setupMO(this, function () {
                                    var value = setData.get.call(this, 'attrValueLastVal');
                                    attr.set(this, 'value', value);
                                    domDispatch.call(this, 'change');
                                });
                            }
                            return value;
                        },
                        test: function () {
                            return formElements[this.nodeName];
                        }
                    },
                    values: {
                        get: function () {
                            return collectSelectedOptions(this);
                        },
                        set: function (values) {
                            values = values || [];
                            markSelectedOptions(this, values);
                            setData.set.call(this, 'stickyValues', attr.get(this, 'values'));
                            setupMO(this, function () {
                                var previousValues = setData.get.call(this, 'stickyValues');
                                attr.set(this, 'values', previousValues);
                                var currentValues = setData.get.call(this, 'stickyValues');
                                var changes = diff(previousValues.slice().sort(), currentValues.slice().sort());
                                if (changes.length) {
                                    domDispatch.call(this, 'values');
                                }
                            });
                            return values;
                        },
                        addEventListener: function (eventName, handler, aEL) {
                            var localHandler = function () {
                                domDispatch.call(this, 'values');
                            };
                            domEvents.addEventListener.call(this, 'change', localHandler);
                            aEL.call(this, eventName, handler);
                            return function (rEL) {
                                domEvents.removeEventListener.call(this, 'change', localHandler);
                                rEL.call(this, eventName, handler);
                            };
                        }
                    }
                },
                defaultValue: {
                    input: true,
                    textarea: true
                },
                setAttrOrProp: function (el, attrName, val) {
                    attrName = attrName.toLowerCase();
                    var special = attr.special[attrName];
                    if (special && special.isBoolean && !val) {
                        this.remove(el, attrName);
                    } else {
                        this.set(el, attrName, val);
                    }
                },
                set: function (el, attrName, val) {
                    var usingMutationObserver = isOfGlobalDocument(el) && MUTATION_OBSERVER();
                    attrName = attrName.toLowerCase();
                    var oldValue;
                    if (!usingMutationObserver) {
                        oldValue = attr.get(el, attrName);
                    }
                    var newValue;
                    var special = attr.special[attrName];
                    var setter = special && special.set;
                    var test = getSpecialTest(special);
                    if (typeof setter === 'function' && test.call(el)) {
                        if (arguments.length === 2) {
                            newValue = setter.call(el);
                        } else {
                            newValue = setter.call(el, val);
                        }
                    } else {
                        attr.setAttribute(el, attrName, val);
                    }
                    if (!usingMutationObserver && newValue !== oldValue) {
                        attr.trigger(el, attrName, oldValue);
                    }
                },
                setSelectValue: function (el, value) {
                    attr.set(el, 'value', value);
                },
                setAttribute: function () {
                    var doc = getDocument();
                    if (doc && document.createAttribute) {
                        try {
                            doc.createAttribute('{}');
                        } catch (e) {
                            var invalidNodes = {}, attributeDummy = document.createElement('div');
                            return function (el, attrName, val) {
                                var first = attrName.charAt(0), cachedNode, node, attr;
                                if ((first === '{' || first === '(' || first === '*') && el.setAttributeNode) {
                                    cachedNode = invalidNodes[attrName];
                                    if (!cachedNode) {
                                        attributeDummy.innerHTML = '<div ' + attrName + '=""></div>';
                                        cachedNode = invalidNodes[attrName] = attributeDummy.childNodes[0].attributes[0];
                                    }
                                    node = cachedNode.cloneNode();
                                    node.value = val;
                                    el.setAttributeNode(node);
                                } else {
                                    attr = attrName.split(':');
                                    if (attr.length !== 1) {
                                        el.setAttributeNS(namespaces[attr[0]], attrName, val);
                                    } else {
                                        el.setAttribute(attrName, val);
                                    }
                                }
                            };
                        }
                    }
                    return function (el, attrName, val) {
                        el.setAttribute(attrName, val);
                    };
                }(),
                trigger: function (el, attrName, oldValue) {
                    if (setData.get.call(el, 'canHasAttributesBindings')) {
                        attrName = attrName.toLowerCase();
                        return setImmediate(function () {
                            domDispatch.call(el, {
                                type: 'attributes',
                                attributeName: attrName,
                                target: el,
                                oldValue: oldValue,
                                bubbles: false
                            }, []);
                        });
                    }
                },
                get: function (el, attrName) {
                    attrName = attrName.toLowerCase();
                    var special = attr.special[attrName];
                    var getter = special && special.get;
                    var test = getSpecialTest(special);
                    if (typeof getter === 'function' && test.call(el)) {
                        return getter.call(el);
                    } else {
                        return el.getAttribute(attrName);
                    }
                },
                remove: function (el, attrName) {
                    attrName = attrName.toLowerCase();
                    var oldValue;
                    if (!MUTATION_OBSERVER()) {
                        oldValue = attr.get(el, attrName);
                    }
                    var special = attr.special[attrName];
                    var setter = special && special.set;
                    var remover = special && special.remove;
                    var test = getSpecialTest(special);
                    if (typeof remover === 'function' && test.call(el)) {
                        remover.call(el);
                    } else if (typeof setter === 'function' && test.call(el)) {
                        setter.call(el, undefined);
                    } else {
                        el.removeAttribute(attrName);
                    }
                    if (!MUTATION_OBSERVER() && oldValue != null) {
                        attr.trigger(el, attrName, oldValue);
                    }
                },
                has: function () {
                    var el = getDocument() && document.createElement('div');
                    if (el && el.hasAttribute) {
                        return function (el, name) {
                            return el.hasAttribute(name);
                        };
                    } else {
                        return function (el, name) {
                            return el.getAttribute(name) !== null;
                        };
                    }
                }()
            };
        var oldAddEventListener = domEvents.addEventListener;
        domEvents.addEventListener = function (eventName, handler) {
            var special = attr.special[eventName];
            if (special && special.addEventListener) {
                var teardown = special.addEventListener.call(this, eventName, handler, oldAddEventListener);
                var teardowns = setData.get.call(this, 'attrTeardowns');
                if (!teardowns) {
                    setData.set.call(this, 'attrTeardowns', teardowns = {});
                }
                if (!teardowns[eventName]) {
                    teardowns[eventName] = [];
                }
                teardowns[eventName].push({
                    teardown: teardown,
                    handler: handler
                });
                return;
            }
            return oldAddEventListener.apply(this, arguments);
        };
        var oldRemoveEventListener = domEvents.removeEventListener;
        domEvents.removeEventListener = function (eventName, handler) {
            var special = attr.special[eventName];
            if (special && special.addEventListener) {
                var teardowns = setData.get.call(this, 'attrTeardowns');
                if (teardowns && teardowns[eventName]) {
                    var eventTeardowns = teardowns[eventName];
                    for (var i = 0, len = eventTeardowns.length; i < len; i++) {
                        if (eventTeardowns[i].handler === handler) {
                            eventTeardowns[i].teardown.call(this, oldRemoveEventListener);
                            eventTeardowns.splice(i, 1);
                            break;
                        }
                    }
                    if (eventTeardowns.length === 0) {
                        delete teardowns[eventName];
                    }
                }
                return;
            }
            return oldRemoveEventListener.apply(this, arguments);
        };
        module.exports = exports = attr;
    }(function () {
        return this;
    }()));
});
/*can-view-live@3.2.0#lib/attr*/
define('can-view-live@3.2.0#lib/attr', function (require, exports, module) {
    var attr = require('can-util/dom/attr/attr');
    var live = require('./core');
    var canReflect = require('can-reflect');
    live.attr = function (el, attributeName, compute) {
        live.listen(el, compute, function (newVal) {
            attr.set(el, attributeName, newVal);
        });
        attr.set(el, attributeName, canReflect.getValue(compute));
    };
});
/*can-view-callbacks@3.2.0#can-view-callbacks*/
define('can-view-callbacks@3.2.0#can-view-callbacks', function (require, exports, module) {
    (function (global) {
        var Observation = require('can-observation');
        var dev = require('can-util/js/dev/dev');
        var getGlobal = require('can-util/js/global/global');
        var domMutate = require('can-util/dom/mutate/mutate');
        var namespace = require('can-namespace');
        var attr = function (attributeName, attrHandler) {
            if (attrHandler) {
                if (typeof attributeName === 'string') {
                    attributes[attributeName] = attrHandler;
                } else {
                    regExpAttributes.push({
                        match: attributeName,
                        handler: attrHandler
                    });
                }
            } else {
                var cb = attributes[attributeName];
                if (!cb) {
                    for (var i = 0, len = regExpAttributes.length; i < len; i++) {
                        var attrMatcher = regExpAttributes[i];
                        if (attrMatcher.match.test(attributeName)) {
                            cb = attrMatcher.handler;
                            break;
                        }
                    }
                }
                return cb;
            }
        };
        var attributes = {}, regExpAttributes = [], automaticCustomElementCharacters = /[-\:]/;
        var tag = function (tagName, tagHandler) {
            if (tagHandler) {
                if (getGlobal().html5) {
                    getGlobal().html5.elements += ' ' + tagName;
                    getGlobal().html5.shivDocument();
                }
                tags[tagName.toLowerCase()] = tagHandler;
            } else {
                var cb;
                if (tagHandler === null) {
                    delete tags[tagName.toLowerCase()];
                } else {
                    cb = tags[tagName.toLowerCase()];
                }
                if (!cb && automaticCustomElementCharacters.test(tagName)) {
                    cb = function () {
                    };
                }
                return cb;
            }
        };
        var tags = {};
        var callbacks = {
            _tags: tags,
            _attributes: attributes,
            _regExpAttributes: regExpAttributes,
            tag: tag,
            attr: attr,
            tagHandler: function (el, tagName, tagData) {
                var helperTagCallback = tagData.options.get('tags.' + tagName, { proxyMethods: false }), tagCallback = helperTagCallback || tags[tagName];
                var scope = tagData.scope, res;
                if (tagCallback) {
                    res = Observation.ignore(tagCallback)(el, tagData);
                } else {
                    res = scope;
                }
                if (res && tagData.subtemplate) {
                    if (scope !== res) {
                        scope = scope.add(res);
                    }
                    var result = tagData.subtemplate(scope, tagData.options);
                    var frag = typeof result === 'string' ? can.view.frag(result) : result;
                    domMutate.appendChild.call(el, frag);
                }
            }
        };
        namespace.view = namespace.view || {};
        if (namespace.view.callbacks) {
            throw new Error('You can\'t have two versions of can-view-callbacks, check your dependencies');
        } else {
            module.exports = namespace.view.callbacks = callbacks;
        }
    }(function () {
        return this;
    }()));
});
/*can-view-live@3.2.0#lib/attrs*/
define('can-view-live@3.2.0#lib/attrs', function (require, exports, module) {
    var live = require('./core');
    var viewCallbacks = require('can-view-callbacks');
    var attr = require('can-util/dom/attr/attr');
    var domEvents = require('can-util/dom/events/events');
    var types = require('can-types');
    var canReflect = require('can-reflect');
    live.attrs = function (el, compute, scope, options) {
        if (!canReflect.isObservableLike(compute)) {
            var attrs = live.getAttributeParts(compute);
            for (var name in attrs) {
                attr.set(el, name, attrs[name]);
            }
            return;
        }
        var oldAttrs = {};
        var setAttrs = function (newVal) {
            var newAttrs = live.getAttributeParts(newVal), name;
            for (name in newAttrs) {
                var newValue = newAttrs[name], oldValue = oldAttrs[name];
                if (newValue !== oldValue) {
                    attr.set(el, name, newValue);
                    var callback = viewCallbacks.attr(name);
                    if (callback) {
                        callback(el, {
                            attributeName: name,
                            scope: scope,
                            options: options
                        });
                    }
                }
                delete oldAttrs[name];
            }
            for (name in oldAttrs) {
                attr.remove(el, name);
            }
            oldAttrs = newAttrs;
        };
        var handler = function (newVal) {
            setAttrs(newVal);
        };
        canReflect.onValue(compute, handler);
        var teardownHandler = function () {
            canReflect.offValue(compute, handler);
            domEvents.removeEventListener.call(el, 'removed', teardownHandler);
        };
        domEvents.addEventListener.call(el, 'removed', teardownHandler);
        setAttrs(canReflect.getValue(compute));
    };
});
/*can-view-live@3.2.0#lib/html*/
define('can-view-live@3.2.0#lib/html', function (require, exports, module) {
    var live = require('./core');
    var nodeLists = require('can-view-nodelist');
    var makeFrag = require('can-util/dom/frag/frag');
    var makeArray = require('can-util/js/make-array/make-array');
    var childNodes = require('can-util/dom/child-nodes/child-nodes');
    var canReflect = require('can-reflect');
    live.html = function (el, compute, parentNode, nodeList) {
        var data, makeAndPut, nodes;
        parentNode = live.getParentNode(el, parentNode);
        data = live.listen(parentNode, compute, function (newVal) {
            var attached = nodeLists.first(nodes).parentNode;
            if (attached) {
                makeAndPut(newVal);
            }
            var pn = nodeLists.first(nodes).parentNode;
            data.teardownCheck(pn);
            live.callChildMutationCallback(pn);
        });
        nodes = nodeList || [el];
        makeAndPut = function (val) {
            var isFunction = typeof val === 'function', frag = makeFrag(isFunction ? '' : val), oldNodes = makeArray(nodes);
            live.addTextNodeIfNoChildren(frag);
            oldNodes = nodeLists.update(nodes, childNodes(frag));
            if (isFunction) {
                val(frag.firstChild);
            }
            nodeLists.replace(oldNodes, frag);
        };
        data.nodeList = nodes;
        if (!nodeList) {
            nodeLists.register(nodes, data.teardownCheck);
        } else {
            nodeList.unregistered = data.teardownCheck;
        }
        makeAndPut(canReflect.getValue(compute));
    };
});
/*can-view-live@3.2.0#lib/util/runInOrder*/
define('can-view-live@3.2.0#lib/util/runInOrder', function (require, exports, module) {
    module.exports = function makeRunInOrder() {
        var running = 0;
        var tasks = [];
        return function runInOrder(fn) {
            return function () {
                var fnArgs = arguments;
                if (running) {
                    tasks.push({
                        fn: fn,
                        args: fnArgs
                    });
                    return;
                }
                running++;
                fn.apply(null, fnArgs);
                running--;
                while (tasks.length) {
                    running++;
                    tasks[0].fn.apply(null, tasks[0].args);
                    tasks.shift();
                    running--;
                }
            };
        };
    };
});
/*can-view-live@3.2.0#lib/list*/
define('can-view-live@3.2.0#lib/list', function (require, exports, module) {
    var live = require('./core');
    var makeRunInOrder = require('./util/runInOrder');
    var runInOrder = makeRunInOrder();
    var nodeLists = require('can-view-nodelist');
    var makeCompute = require('can-compute');
    var canBatch = require('can-event/batch/batch');
    var frag = require('can-util/dom/frag/frag');
    var domMutate = require('can-util/dom/mutate/mutate');
    var childNodes = require('can-util/dom/child-nodes/child-nodes');
    var makeArray = require('can-util/js/make-array/make-array');
    var each = require('can-util/js/each/each');
    var isFunction = require('can-util/js/is-function/is-function');
    var diff = require('can-util/js/diff/diff');
    var splice = [].splice;
    var Compute = require('can-compute/proto-compute');
    var canReflect = require('can-reflect');
    var renderAndAddToNodeLists = function (newNodeLists, parentNodeList, render, context, args) {
            var itemNodeList = [];
            if (parentNodeList) {
                nodeLists.register(itemNodeList, null, parentNodeList, true);
                itemNodeList.parentList = parentNodeList;
                itemNodeList.expression = '#each SUBEXPRESSION';
            }
            var itemHTML = render.apply(context, args.concat([itemNodeList])), itemFrag = frag(itemHTML);
            var children = makeArray(childNodes(itemFrag));
            if (parentNodeList) {
                nodeLists.update(itemNodeList, children);
                newNodeLists.push(itemNodeList);
            } else {
                newNodeLists.push(nodeLists.register(children));
            }
            return itemFrag;
        }, removeFromNodeList = function (masterNodeList, index, length) {
            var removedMappings = masterNodeList.splice(index + 1, length), itemsToRemove = [];
            each(removedMappings, function (nodeList) {
                var nodesToRemove = nodeLists.unregister(nodeList);
                [].push.apply(itemsToRemove, nodesToRemove);
            });
            return itemsToRemove;
        }, addFalseyIfEmpty = function (list, falseyRender, masterNodeList, nodeList) {
            if (falseyRender && list.length === 0) {
                var falseyNodeLists = [];
                var falseyFrag = renderAndAddToNodeLists(falseyNodeLists, nodeList, falseyRender, list, [list]);
                nodeLists.after([masterNodeList[0]], falseyFrag);
                masterNodeList.push(falseyNodeLists[0]);
            }
        };
    live.list = function (el, compute, render, context, parentNode, nodeList, falseyRender) {
        var masterNodeList = nodeList || [el], indexMap = [], afterPreviousEvents = false, isTornDown = false, add = runInOrder(function add(ev, items, index) {
                if (!afterPreviousEvents) {
                    return;
                }
                var frag = text.ownerDocument.createDocumentFragment(), newNodeLists = [], newIndicies = [];
                each(items, function (item, key) {
                    var itemIndex = new Compute(key + index), itemCompute = new Compute(function (newVal) {
                            if (arguments.length) {
                                if ('set' in list) {
                                    list.set(itemIndex.get(), newVal);
                                } else {
                                    list.attr(itemIndex.get(), newVal);
                                }
                            } else {
                                return item;
                            }
                        }), itemFrag = renderAndAddToNodeLists(newNodeLists, nodeList, render, context, [
                            itemCompute,
                            itemIndex
                        ]);
                    frag.appendChild(itemFrag);
                    newIndicies.push(itemIndex);
                });
                var masterListIndex = index + 1;
                if (!indexMap.length) {
                    var falseyItemsToRemove = removeFromNodeList(masterNodeList, 0, masterNodeList.length - 1);
                    nodeLists.remove(falseyItemsToRemove);
                }
                if (!masterNodeList[masterListIndex]) {
                    nodeLists.after(masterListIndex === 1 ? [text] : [nodeLists.last(masterNodeList[masterListIndex - 1])], frag);
                } else {
                    var el = nodeLists.first(masterNodeList[masterListIndex]);
                    domMutate.insertBefore.call(el.parentNode, frag, el);
                }
                splice.apply(masterNodeList, [
                    masterListIndex,
                    0
                ].concat(newNodeLists));
                splice.apply(indexMap, [
                    index,
                    0
                ].concat(newIndicies));
                for (var i = index + newIndicies.length, len = indexMap.length; i < len; i++) {
                    indexMap[i].set(i);
                }
                if (ev.callChildMutationCallback !== false) {
                    live.callChildMutationCallback(text.parentNode);
                }
            }), set = function (ev, newVal, index) {
                remove({}, { length: 1 }, index, true);
                add({}, [newVal], index);
            }, remove = runInOrder(function remove(ev, items, index, duringTeardown, fullTeardown) {
                if (!afterPreviousEvents) {
                    return;
                }
                if (!duringTeardown && data.teardownCheck(text.parentNode)) {
                    return;
                }
                if (index < 0) {
                    index = indexMap.length + index;
                }
                var itemsToRemove = removeFromNodeList(masterNodeList, index, items.length);
                indexMap.splice(index, items.length);
                for (var i = index, len = indexMap.length; i < len; i++) {
                    indexMap[i].set(i);
                }
                if (!fullTeardown) {
                    addFalseyIfEmpty(list, falseyRender, masterNodeList, nodeList);
                    nodeLists.remove(itemsToRemove);
                    if (ev.callChildMutationCallback !== false) {
                        live.callChildMutationCallback(text.parentNode);
                    }
                } else {
                    nodeLists.unregister(masterNodeList);
                }
            }), move = function (ev, item, newIndex, currentIndex) {
                if (!afterPreviousEvents) {
                    return;
                }
                newIndex = newIndex + 1;
                currentIndex = currentIndex + 1;
                var referenceNodeList = masterNodeList[newIndex];
                var movedElements = frag(nodeLists.flatten(masterNodeList[currentIndex]));
                var referenceElement;
                if (currentIndex < newIndex) {
                    referenceElement = nodeLists.last(referenceNodeList).nextSibling;
                } else {
                    referenceElement = nodeLists.first(referenceNodeList);
                }
                var parentNode = masterNodeList[0].parentNode;
                parentNode.insertBefore(movedElements, referenceElement);
                var temp = masterNodeList[currentIndex];
                [].splice.apply(masterNodeList, [
                    currentIndex,
                    1
                ]);
                [].splice.apply(masterNodeList, [
                    newIndex,
                    0,
                    temp
                ]);
                newIndex = newIndex - 1;
                currentIndex = currentIndex - 1;
                var indexCompute = indexMap[currentIndex];
                [].splice.apply(indexMap, [
                    currentIndex,
                    1
                ]);
                [].splice.apply(indexMap, [
                    newIndex,
                    0,
                    indexCompute
                ]);
                var i = Math.min(currentIndex, newIndex);
                var len = indexMap.length;
                for (i, len; i < len; i++) {
                    indexMap[i](i);
                }
                if (ev.callChildMutationCallback !== false) {
                    live.callChildMutationCallback(text.parentNode);
                }
            }, text = el.ownerDocument.createTextNode(''), list, teardownList = function (fullTeardown) {
                if (list && list.removeEventListener) {
                    list.removeEventListener('add', add);
                    list.removeEventListener('set', set);
                    list.removeEventListener('remove', remove);
                    list.removeEventListener('move', move);
                }
                remove({ callChildMutationCallback: !!fullTeardown }, { length: masterNodeList.length - 1 }, 0, true, fullTeardown);
            }, oldList, updateList = function (newList) {
                if (isTornDown) {
                    return;
                }
                afterPreviousEvents = true;
                if (newList && oldList) {
                    list = newList || [];
                    var patches = diff(oldList, newList);
                    oldList = newList;
                    if (oldList.removeEventListener) {
                        oldList.removeEventListener('add', add);
                        oldList.removeEventListener('set', set);
                        oldList.removeEventListener('remove', remove);
                        oldList.removeEventListener('move', move);
                    }
                    for (var i = 0, patchLen = patches.length; i < patchLen; i++) {
                        var patch = patches[i];
                        if (patch.deleteCount) {
                            remove({ callChildMutationCallback: false }, { length: patch.deleteCount }, patch.index, true);
                        }
                        if (patch.insert.length) {
                            add({ callChildMutationCallback: false }, patch.insert, patch.index);
                        }
                    }
                } else {
                    if (oldList) {
                        teardownList();
                    }
                    list = newList || [];
                    oldList = list;
                    add({ callChildMutationCallback: false }, list, 0);
                    addFalseyIfEmpty(list, falseyRender, masterNodeList, nodeList);
                }
                live.callChildMutationCallback(text.parentNode);
                afterPreviousEvents = false;
                if (list.addEventListener) {
                    list.addEventListener('add', add);
                    list.addEventListener('set', set);
                    list.addEventListener('remove', remove);
                    list.addEventListener('move', move);
                }
                canBatch.afterPreviousEvents(function () {
                    afterPreviousEvents = true;
                });
            };
        var isValueLike = canReflect.isValueLike(compute), isObservableLike = canReflect.isObservableLike(compute);
        parentNode = live.getParentNode(el, parentNode);
        var data = live.setup(parentNode, function () {
            if (isValueLike && isObservableLike) {
                canReflect.onValue(compute, updateList);
            }
        }, function () {
            if (isValueLike && isObservableLike) {
                canReflect.offValue(compute, updateList);
            }
            teardownList(true);
        });
        if (!nodeList) {
            live.replace(masterNodeList, text, data.teardownCheck);
        } else {
            nodeLists.replace(masterNodeList, text);
            nodeLists.update(masterNodeList, [text]);
            nodeList.unregistered = function () {
                data.teardownCheck();
                isTornDown = true;
            };
        }
        updateList(isValueLike ? canReflect.getValue(compute) : compute);
    };
});
/*can-view-live@3.2.0#lib/text*/
define('can-view-live@3.2.0#lib/text', function (require, exports, module) {
    var live = require('./core');
    var nodeLists = require('can-view-nodelist');
    var canReflect = require('can-reflect');
    live.text = function (el, compute, parentNode, nodeList) {
        var parent = live.getParentNode(el, parentNode);
        var data = live.listen(parent, compute, function (newVal) {
            if (typeof node.nodeValue !== 'unknown') {
                node.nodeValue = live.makeString(newVal);
            }
        });
        var node = el.ownerDocument.createTextNode(live.makeString(canReflect.getValue(compute)));
        if (nodeList) {
            nodeList.unregistered = data.teardownCheck;
            data.nodeList = nodeList;
            nodeLists.update(nodeList, [node]);
            nodeLists.replace([el], node);
        } else {
            data.nodeList = live.replace([el], node, data.teardownCheck);
        }
    };
});
/*can-view-live@3.2.0#can-view-live*/
define('can-view-live@3.2.0#can-view-live', function (require, exports, module) {
    var live = require('./lib/core');
    require('./lib/attr');
    require('./lib/attrs');
    require('./lib/html');
    require('./lib/list');
    require('./lib/text');
    module.exports = live;
});
/*can-util@3.9.6#js/base-url/base-url*/
define('can-util@3.9.6#js/base-url/base-url', function (require, exports, module) {
    (function (global) {
        'use strict';
        var getGlobal = require('../global/global');
        var getDomDocument = require('../../dom/document/document');
        var setBaseUrl;
        module.exports = function (setUrl) {
            if (setUrl !== undefined) {
                setBaseUrl = setUrl;
            }
            if (setBaseUrl !== undefined) {
                return setBaseUrl;
            }
            var global = getGlobal();
            var domDocument = getDomDocument();
            if (domDocument && 'baseURI' in domDocument) {
                return domDocument.baseURI;
            } else if (global.location) {
                var href = global.location.href;
                var lastSlash = href.lastIndexOf('/');
                return lastSlash !== -1 ? href.substr(0, lastSlash) : href;
            } else if (typeof process !== 'undefined') {
                return process.cwd();
            }
        };
    }(function () {
        return this;
    }()));
});
/*can-util@3.9.6#js/parse-uri/parse-uri*/
define('can-util@3.9.6#js/parse-uri/parse-uri', function (require, exports, module) {
    'use strict';
    module.exports = function (url) {
        var m = String(url).replace(/^\s+|\s+$/g, '').match(/^([^:\/?#]+:)?(\/\/(?:[^:@]*(?::[^:@]*)?@)?(([^:\/?#]*)(?::(\d*))?))?([^?#]*)(\?[^#]*)?(#[\s\S]*)?/);
        return m ? {
            href: m[0] || '',
            protocol: m[1] || '',
            authority: m[2] || '',
            host: m[3] || '',
            hostname: m[4] || '',
            port: m[5] || '',
            pathname: m[6] || '',
            search: m[7] || '',
            hash: m[8] || ''
        } : null;
    };
});
/*can-util@3.9.6#js/join-uris/join-uris*/
define('can-util@3.9.6#js/join-uris/join-uris', function (require, exports, module) {
    'use strict';
    var parseURI = require('../parse-uri/parse-uri');
    module.exports = function (base, href) {
        function removeDotSegments(input) {
            var output = [];
            input.replace(/^(\.\.?(\/|$))+/, '').replace(/\/(\.(\/|$))+/g, '/').replace(/\/\.\.$/, '/../').replace(/\/?[^\/]*/g, function (p) {
                if (p === '/..') {
                    output.pop();
                } else {
                    output.push(p);
                }
            });
            return output.join('').replace(/^\//, input.charAt(0) === '/' ? '/' : '');
        }
        href = parseURI(href || '');
        base = parseURI(base || '');
        return !href || !base ? null : (href.protocol || base.protocol) + (href.protocol || href.authority ? href.authority : base.authority) + removeDotSegments(href.protocol || href.authority || href.pathname.charAt(0) === '/' ? href.pathname : href.pathname ? (base.authority && !base.pathname ? '/' : '') + base.pathname.slice(0, base.pathname.lastIndexOf('/') + 1) + href.pathname : base.pathname) + (href.protocol || href.authority || href.pathname ? href.search : href.search || base.search) + href.hash;
    };
});
/*can-stache@3.2.0#helpers/core*/
define('can-stache@3.2.0#helpers/core', function (require, exports, module) {
    var live = require('can-view-live');
    var nodeLists = require('can-view-nodelist');
    var compute = require('can-compute');
    var utils = require('../src/utils');
    var isFunction = require('can-util/js/is-function/is-function');
    var getBaseURL = require('can-util/js/base-url/base-url');
    var joinURIs = require('can-util/js/join-uris/join-uris');
    var each = require('can-util/js/each/each');
    var assign = require('can-util/js/assign/assign');
    var isIterable = require('can-util/js/is-iterable/is-iterable');
    var dev = require('can-util/js/dev/dev');
    var canSymbol = require('can-symbol');
    var canReflect = require('can-reflect');
    var domData = require('can-util/dom/data/data');
    var looksLikeOptions = function (options) {
        return options && typeof options.fn === 'function' && typeof options.inverse === 'function';
    };
    var resolve = function (value) {
        if (value && value[canSymbol.for('can.isValueLike')] && value[canSymbol.for('can.getValue')]) {
            return canReflect.getValue(value);
        } else {
            return value;
        }
    };
    var resolveHash = function (hash) {
        var params = {};
        for (var prop in hash) {
            params[prop] = resolve(hash[prop]);
        }
        return params;
    };
    var helpers = {
        'each': function (items) {
            var args = [].slice.call(arguments), options = args.pop(), argsLen = args.length, argExprs = options.exprData.argExprs, resolved = resolve(items), asVariable, aliases, key;
            if (argsLen === 2 || argsLen === 3 && argExprs[1].key === 'as') {
                asVariable = args[argsLen - 1];
                if (typeof asVariable !== 'string') {
                    asVariable = argExprs[argsLen - 1].key;
                }
            }
            if ((canReflect.isObservableLike(resolved) && canReflect.isListLike(resolved) || utils.isArrayLike(resolved) && items.isComputed) && !options.stringOnly) {
                return function (el) {
                    var nodeList = [el];
                    nodeList.expression = 'live.list';
                    nodeLists.register(nodeList, null, options.nodeList, true);
                    nodeLists.update(options.nodeList, [el]);
                    var cb = function (item, index, parentNodeList) {
                        var aliases = {
                            '%index': index,
                            '@index': index
                        };
                        if (asVariable) {
                            aliases[asVariable] = item;
                        }
                        return options.fn(options.scope.add(aliases, { notContext: true }).add(item), options.options, parentNodeList);
                    };
                    live.list(el, items, cb, options.context, el.parentNode, nodeList, function (list, parentNodeList) {
                        return options.inverse(options.scope.add(list), options.options, parentNodeList);
                    });
                };
            }
            var expr = resolved, result;
            if (!!expr && utils.isArrayLike(expr)) {
                result = utils.getItemsFragContent(expr, options, options.scope, asVariable);
                return options.stringOnly ? result.join('') : result;
            } else if (isIterable(expr)) {
                result = [];
                each(expr, function (value, key) {
                    aliases = { '%key': key };
                    if (asVariable) {
                        aliases[asVariable] = value;
                    }
                    result.push(options.fn(options.scope.add(aliases, { notContext: true }).add(value)));
                });
                return options.stringOnly ? result.join('') : result;
            } else if (canReflect.isObservableLike(expr) && canReflect.isMapLike(expr)) {
                result = [];
                (expr.forEach || expr.each).call(expr, function (val, key) {
                    var value = compute(expr, key);
                    aliases = {
                        '%key': key,
                        '@key': key
                    };
                    if (asVariable) {
                        aliases[asVariable] = expr[key];
                    }
                    result.push(options.fn(options.scope.add(aliases, { notContext: true }).add(value)));
                });
                return options.stringOnly ? result.join('') : result;
            } else if (expr instanceof Object) {
                result = [];
                for (key in expr) {
                    aliases = {
                        '%key': key,
                        '@key': key
                    };
                    if (asVariable) {
                        aliases[asVariable] = expr[key];
                    }
                    result.push(options.fn(options.scope.add(aliases, { notContext: true }).add(expr[key])));
                }
                return options.stringOnly ? result.join('') : result;
            }
        },
        '@index': function (offset, options) {
            if (!options) {
                options = offset;
                offset = 0;
            }
            var index = options.scope.peek('@index');
            return '' + ((isFunction(index) ? index() : index) + offset);
        },
        'if': function (expr, options) {
            var value;
            if (expr && expr.isComputed) {
                value = compute.truthy(expr)();
            } else {
                value = !!resolve(expr);
            }
            if (value) {
                return options.fn(options.scope || this);
            } else {
                return options.inverse(options.scope || this);
            }
        },
        'is': function () {
            var lastValue, curValue, options = arguments[arguments.length - 1];
            if (arguments.length - 2 <= 0) {
                return options.inverse();
            }
            var args = arguments;
            var callFn = compute(function () {
                for (var i = 0; i < args.length - 1; i++) {
                    curValue = resolve(args[i]);
                    curValue = isFunction(curValue) ? curValue() : curValue;
                    if (i > 0) {
                        if (curValue !== lastValue) {
                            return false;
                        }
                    }
                    lastValue = curValue;
                }
                return true;
            });
            return callFn() ? options.fn() : options.inverse();
        },
        'eq': function () {
            return helpers.is.apply(this, arguments);
        },
        'unless': function (expr, options) {
            return helpers['if'].apply(this, [
                expr,
                assign(assign({}, options), {
                    fn: options.inverse,
                    inverse: options.fn
                })
            ]);
        },
        'with': function (expr, options) {
            var ctx = expr;
            expr = resolve(expr);
            if (!!expr) {
                return options.fn(ctx);
            }
        },
        'log': function (options) {
            var logs = [];
            each(arguments, function (val) {
                if (!looksLikeOptions(val)) {
                    logs.push(val);
                }
            });
            if (typeof console !== 'undefined' && console.log) {
                if (!logs.length) {
                    console.log(options.context);
                } else {
                    console.log.apply(console, logs);
                }
            }
        },
        'data': function (attr) {
            var data = arguments.length === 2 ? this : arguments[1];
            return function (el) {
                domData.set.call(el, attr, data || this.context);
            };
        },
        'switch': function (expression, options) {
            resolve(expression);
            var found = false;
            var newOptions = options.helpers.add({
                'case': function (value, options) {
                    if (!found && resolve(expression) === resolve(value)) {
                        found = true;
                        return options.fn(options.scope || this);
                    }
                },
                'default': function (options) {
                    if (!found) {
                        return options.fn(options.scope || this);
                    }
                }
            });
            return options.fn(options.scope, newOptions);
        },
        'joinBase': function (firstExpr) {
            var args = [].slice.call(arguments);
            var options = args.pop();
            var moduleReference = args.map(function (expr) {
                var value = resolve(expr);
                return isFunction(value) ? value() : value;
            }).join('');
            var templateModule = options.helpers.peek('helpers.module');
            var parentAddress = templateModule ? templateModule.uri : undefined;
            var isRelative = moduleReference[0] === '.';
            if (isRelative && parentAddress) {
                return joinURIs(parentAddress, moduleReference);
            } else {
                var baseURL = typeof System !== 'undefined' && (System.renderingBaseURL || System.baseURL) || getBaseURL();
                if (moduleReference[0] !== '/' && baseURL[baseURL.length - 1] !== '/') {
                    baseURL += '/';
                }
                return joinURIs(baseURL, moduleReference);
            }
        }
    };
    helpers.eachOf = helpers.each;
    var registerHelper = function (name, callback) {
        helpers[name] = callback;
    };
    var makeSimpleHelper = function (fn) {
        return function () {
            var realArgs = [];
            each(arguments, function (val, i) {
                if (i <= arguments.length) {
                    while (val && val.isComputed) {
                        val = val();
                    }
                    realArgs.push(val);
                }
            });
            return fn.apply(this, realArgs);
        };
    };
    module.exports = {
        registerHelper: registerHelper,
        registerSimpleHelper: function (name, callback) {
            registerHelper(name, makeSimpleHelper(callback));
        },
        getHelper: function (name, options) {
            var helper = options && options.get && options.get('helpers.' + name, { proxyMethods: false });
            if (!helper) {
                helper = helpers[name];
            }
            if (helper) {
                return { fn: helper };
            }
        },
        resolve: resolve,
        resolveHash: resolveHash,
        looksLikeOptions: looksLikeOptions
    };
});
/*can-stache@3.2.0#src/expression*/
define('can-stache@3.2.0#src/expression', function (require, exports, module) {
    var compute = require('can-compute');
    var observeReader = require('can-stache-key');
    var utils = require('./utils');
    var mustacheHelpers = require('../helpers/core');
    var each = require('can-util/js/each/each');
    var isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');
    var dev = require('can-util/js/dev/dev');
    var assign = require('can-util/js/assign/assign');
    var last = require('can-util/js/last/last');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var getObservableValue_fromKey = function (key, scope, readOptions) {
            var data = scope.computeData(key, readOptions);
            compute.temporarilyBind(data);
            return data;
        }, computeHasDependencies = function (compute) {
            return compute[canSymbol.for('can.valueHasDependencies')] ? canReflect.valueHasDependencies(compute) : compute.computeInstance.hasDependencies;
        }, lookupValueOrHelper = function (key, scope, helperOptions, readOptions) {
            var scopeKeyData = getObservableValue_fromKey(key, scope, readOptions);
            var result = { value: scopeKeyData };
            if (scopeKeyData.initialValue === undefined) {
                if (key.charAt(0) === '@' && key !== '@index') {
                    key = key.substr(1);
                }
                var helper = mustacheHelpers.getHelper(key, helperOptions);
                result.helper = helper && helper.fn;
            }
            return result;
        }, getObservableValue_fromDynamicKey = function (key, scope, helperOptions, readOptions) {
            var c = compute(function (newVal) {
                var keyValue = canReflect.getValue(key);
                if (arguments.length) {
                    scope.set('' + keyValue, newVal, readOptions);
                } else {
                    return scope.get(('' + keyValue).replace('.', '\\.'), readOptions);
                }
            });
            compute.temporarilyBind(c);
            return c;
        }, getObservableValue_fromDynamicKey_fromObservable = function (key, root, helperOptions, readOptions) {
            var computeValue = compute(function (newVal) {
                var keyValue = canReflect.getValue(key);
                var rootValue = canReflect.getValue(root);
                if (arguments.length) {
                    observeReader.write(rootValue, observeReader.reads('' + keyValue), newVal);
                } else {
                    return observeReader.get(rootValue, ('' + keyValue).replace('.', '\\.'));
                }
            });
            compute.temporarilyBind(computeValue);
            return computeValue;
        }, convertToArgExpression = function (expr) {
            if (!(expr instanceof Arg) && !(expr instanceof Literal)) {
                return new Arg(expr);
            } else {
                return expr;
            }
        }, toComputeOrValue = function (value) {
            if (canReflect.isObservableLike(value)) {
                if (canReflect.valueHasDependencies(value) === false) {
                    return canReflect.getValue(value);
                }
                if (value.compute) {
                    return value.compute;
                }
            }
            return value;
        }, toCompute = function (value) {
            if (value) {
                if (value.isComputed) {
                    return value;
                }
                if (value.compute) {
                    return value.compute;
                }
            }
            return value;
        };
    var Bracket = function (key, root) {
        this.root = root;
        this.key = key;
    };
    Bracket.prototype.value = function (scope, helpers) {
        if (!this.root) {
            return getObservableValue_fromDynamicKey(this.key.value(scope, helpers), scope, {}, {});
        } else {
            return getObservableValue_fromDynamicKey_fromObservable(this.key.value(scope, helpers), this.root.value(scope, helpers), scope, helpers, {});
        }
    };
    var Literal = function (value) {
        this._value = value;
    };
    Literal.prototype.value = function () {
        return this._value;
    };
    var Lookup = function (key, root) {
        this.key = key;
        this.rootExpr = root;
    };
    Lookup.prototype.value = function (scope, helperOptions) {
        if (this.rootExpr) {
            return getObservableValue_fromDynamicKey_fromObservable(this.key, this.rootExpr.value(scope, helperOptions), scope, {}, {});
        } else {
            var result = lookupValueOrHelper(this.key, scope, helperOptions);
            this.isHelper = result.helper && !result.helper.callAsMethod;
            return result.helper || result.value;
        }
    };
    var ScopeLookup = function (key, root) {
        Lookup.apply(this, arguments);
    };
    ScopeLookup.prototype.value = function (scope, helperOptions) {
        if (this.rootExpr) {
            return getObservableValue_fromDynamicKey_fromObservable(this.key, this.rootExpr.value(scope, helperOptions), scope, {}, {});
        }
        return getObservableValue_fromKey(this.key, scope, helperOptions);
    };
    var Arg = function (expression, modifiers) {
        this.expr = expression;
        this.modifiers = modifiers || {};
        this.isCompute = false;
    };
    Arg.prototype.value = function () {
        return this.expr.value.apply(this.expr, arguments);
    };
    var Hash = function () {
    };
    var Hashes = function (hashes) {
        this.hashExprs = hashes;
    };
    Hashes.prototype.value = function (scope, helperOptions) {
        var hash = {};
        for (var prop in this.hashExprs) {
            var val = convertToArgExpression(this.hashExprs[prop]), value = val.value.apply(val, arguments);
            hash[prop] = {
                call: !val.modifiers || !val.modifiers.compute,
                value: value
            };
        }
        return compute(function () {
            var finalHash = {};
            for (var prop in hash) {
                finalHash[prop] = hash[prop].call ? canReflect.getValue(hash[prop].value) : toComputeOrValue(hash[prop].value);
            }
            return finalHash;
        });
    };
    var Call = function (methodExpression, argExpressions) {
        this.methodExpr = methodExpression;
        this.argExprs = argExpressions.map(convertToArgExpression);
    };
    Call.prototype.args = function (scope, helperOptions) {
        var args = [];
        for (var i = 0, len = this.argExprs.length; i < len; i++) {
            var arg = this.argExprs[i];
            var value = arg.value.apply(arg, arguments);
            args.push({
                call: !arg.modifiers || !arg.modifiers.compute,
                value: value
            });
        }
        return function () {
            var finalArgs = [];
            for (var i = 0, len = args.length; i < len; i++) {
                finalArgs[i] = args[i].call ? canReflect.getValue(args[i].value) : toCompute(args[i].value);
            }
            return finalArgs;
        };
    };
    Call.prototype.value = function (scope, helperScope, helperOptions) {
        var method = this.methodExpr.value(scope, helperScope);
        var isHelper = this.isHelper = this.methodExpr.isHelper;
        var getArgs = this.args(scope, helperScope);
        var computeValue = compute(function (newVal) {
            var func = canReflect.getValue(method);
            if (typeof func === 'function') {
                var args = getArgs();
                if (isHelper && helperOptions) {
                    args.push(helperOptions);
                }
                if (arguments.length) {
                    args.unshift(new expression.SetIdentifier(newVal));
                }
                return func.apply(null, args);
            }
        });
        compute.temporarilyBind(computeValue);
        return computeValue;
    };
    Call.prototype.closingTag = function () {
        return this.methodExpr.key.slice(1);
    };
    var HelperLookup = function () {
        Lookup.apply(this, arguments);
    };
    HelperLookup.prototype.value = function (scope, helperOptions) {
        var result = lookupValueOrHelper(this.key, scope, helperOptions, {
            isArgument: true,
            args: [
                scope.peek('.'),
                scope
            ]
        });
        return result.helper || result.value;
    };
    var HelperScopeLookup = function () {
        Lookup.apply(this, arguments);
    };
    HelperScopeLookup.prototype.value = function (scope, helperOptions) {
        return getObservableValue_fromKey(this.key, scope, {
            callMethodsOnObservables: true,
            isArgument: true,
            args: [
                scope.peek('.'),
                scope
            ]
        });
    };
    var Helper = function (methodExpression, argExpressions, hashExpressions) {
        this.methodExpr = methodExpression;
        this.argExprs = argExpressions;
        this.hashExprs = hashExpressions;
        this.mode = null;
    };
    Helper.prototype.args = function (scope, helperOptions) {
        var args = [];
        for (var i = 0, len = this.argExprs.length; i < len; i++) {
            var arg = this.argExprs[i];
            args.push(toComputeOrValue(arg.value.apply(arg, arguments)));
        }
        return args;
    };
    Helper.prototype.hash = function (scope, helperOptions) {
        var hash = {};
        for (var prop in this.hashExprs) {
            var val = this.hashExprs[prop];
            hash[prop] = toComputeOrValue(val.value.apply(val, arguments));
        }
        return hash;
    };
    Helper.prototype.helperAndValue = function (scope, helperOptions) {
        var looksLikeAHelper = this.argExprs.length || !isEmptyObject(this.hashExprs), helper, computeData, methodKey = this.methodExpr instanceof Literal ? '' + this.methodExpr._value : this.methodExpr.key, initialValue, args;
        if (looksLikeAHelper) {
            helper = mustacheHelpers.getHelper(methodKey, helperOptions);
        }
        if (!helper) {
            computeData = getObservableValue_fromKey(methodKey, scope, { isArgument: true });
            if (typeof computeData.initialValue === 'function') {
                args = this.args(scope, helperOptions).map(toComputeOrValue);
                var functionResult = compute(function () {
                    return computeData.initialValue.apply(null, args);
                });
                compute.temporarilyBind(functionResult);
                return { value: functionResult };
            } else if (typeof computeData.initialValue !== 'undefined') {
                return { value: computeData };
            }
            if (!looksLikeAHelper && initialValue === undefined) {
                helper = mustacheHelpers.getHelper(methodKey, helperOptions);
            }
        }
        return {
            value: computeData,
            args: args,
            helper: helper && helper.fn
        };
    };
    Helper.prototype.evaluator = function (helper, scope, helperOptions, readOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly) {
        var helperOptionArg = {
                fn: function () {
                },
                inverse: function () {
                },
                stringOnly: stringOnly
            }, context = scope.peek('.'), args = this.args(scope, helperOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly), hash = this.hash(scope, helperOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly);
        utils.convertToScopes(helperOptionArg, scope, helperOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly);
        assign(helperOptionArg, {
            context: context,
            scope: scope,
            contexts: scope,
            hash: hash,
            nodeList: nodeList,
            exprData: this,
            helperOptions: helperOptions,
            helpers: helperOptions
        });
        args.push(helperOptionArg);
        return function () {
            return helper.apply(context, args);
        };
    };
    Helper.prototype.value = function (scope, helperOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly) {
        var helperAndValue = this.helperAndValue(scope, helperOptions);
        var helper = helperAndValue.helper;
        if (!helper) {
            return helperAndValue.value;
        }
        var fn = this.evaluator(helper, scope, helperOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly);
        var computeValue = compute(fn);
        compute.temporarilyBind(computeValue);
        if (!computeHasDependencies(computeValue)) {
            return computeValue();
        } else {
            return computeValue;
        }
    };
    Helper.prototype.closingTag = function () {
        return this.methodExpr.key;
    };
    var keyRegExp = /[\w\.\\\-_@\/\&%]+/, tokensRegExp = /('.*?'|".*?"|=|[\w\.\\\-_@\/*%\$]+|[\(\)]|,|\~|\[|\]\s*|\s*(?=\[))/g, bracketSpaceRegExp = /\]\s+/, literalRegExp = /^('.*?'|".*?"|[0-9]+\.?[0-9]*|true|false|null|undefined)$/;
    var isTokenKey = function (token) {
        return keyRegExp.test(token);
    };
    var testDot = /^[\.@]\w/;
    var isAddingToExpression = function (token) {
        return isTokenKey(token) && testDot.test(token);
    };
    var ensureChildren = function (type) {
        if (!type.children) {
            type.children = [];
        }
        return type;
    };
    var Stack = function () {
        this.root = {
            children: [],
            type: 'Root'
        };
        this.current = this.root;
        this.stack = [this.root];
    };
    assign(Stack.prototype, {
        top: function () {
            return last(this.stack);
        },
        isRootTop: function () {
            return this.top() === this.root;
        },
        popTo: function (types) {
            this.popUntil(types);
            this.pop();
        },
        pop: function () {
            if (!this.isRootTop()) {
                this.stack.pop();
            }
        },
        first: function (types) {
            var curIndex = this.stack.length - 1;
            while (curIndex > 0 && types.indexOf(this.stack[curIndex].type) === -1) {
                curIndex--;
            }
            return this.stack[curIndex];
        },
        firstParent: function (types) {
            var curIndex = this.stack.length - 2;
            while (curIndex > 0 && types.indexOf(this.stack[curIndex].type) === -1) {
                curIndex--;
            }
            return this.stack[curIndex];
        },
        popUntil: function (types) {
            while (types.indexOf(this.top().type) === -1 && !this.isRootTop()) {
                this.stack.pop();
            }
            return this.top();
        },
        addTo: function (types, type) {
            var cur = this.popUntil(types);
            ensureChildren(cur).children.push(type);
        },
        addToAndPush: function (types, type) {
            this.addTo(types, type);
            this.stack.push(type);
        },
        push: function (type) {
            this.stack.push(type);
        },
        topLastChild: function () {
            return last(this.top().children);
        },
        replaceTopLastChild: function (type) {
            var children = ensureChildren(this.top()).children;
            children.pop();
            children.push(type);
            return type;
        },
        replaceTopLastChildAndPush: function (type) {
            this.replaceTopLastChild(type);
            this.stack.push(type);
        },
        replaceTopAndPush: function (type) {
            var children;
            if (this.top() === this.root) {
                children = ensureChildren(this.top()).children;
            } else {
                this.stack.pop();
                children = ensureChildren(this.top()).children;
            }
            children.pop();
            children.push(type);
            this.stack.push(type);
            return type;
        }
    });
    var convertKeyToLookup = function (key) {
        var lastPath = key.lastIndexOf('./');
        var lastDot = key.lastIndexOf('.');
        if (lastDot > lastPath) {
            return key.substr(0, lastDot) + '@' + key.substr(lastDot + 1);
        }
        var firstNonPathCharIndex = lastPath === -1 ? 0 : lastPath + 2;
        var firstNonPathChar = key.charAt(firstNonPathCharIndex);
        if (firstNonPathChar === '.' || firstNonPathChar === '@') {
            return key.substr(0, firstNonPathCharIndex) + '@' + key.substr(firstNonPathCharIndex + 1);
        } else {
            return key.substr(0, firstNonPathCharIndex) + '@' + key.substr(firstNonPathCharIndex);
        }
    };
    var convertToAtLookup = function (ast) {
        if (ast.type === 'Lookup') {
            ast.key = convertKeyToLookup(ast.key);
        }
        return ast;
    };
    var convertToHelperIfTopIsLookup = function (stack) {
        var top = stack.top();
        if (top && top.type === 'Lookup') {
            var base = stack.stack[stack.stack.length - 2];
            if (base.type !== 'Helper' && base) {
                stack.replaceTopAndPush({
                    type: 'Helper',
                    method: top
                });
            }
        }
    };
    var expression = {
        toComputeOrValue: toComputeOrValue,
        convertKeyToLookup: convertKeyToLookup,
        Literal: Literal,
        Lookup: Lookup,
        ScopeLookup: ScopeLookup,
        Arg: Arg,
        Hash: Hash,
        Hashes: Hashes,
        Call: Call,
        Helper: Helper,
        HelperLookup: HelperLookup,
        HelperScopeLookup: HelperScopeLookup,
        Bracket: Bracket,
        SetIdentifier: function (value) {
            this.value = value;
        },
        tokenize: function (expression) {
            var tokens = [];
            (expression.trim() + ' ').replace(tokensRegExp, function (whole, arg) {
                if (bracketSpaceRegExp.test(arg)) {
                    tokens.push(arg[0]);
                    tokens.push(arg.slice(1));
                } else {
                    tokens.push(arg);
                }
            });
            return tokens;
        },
        lookupRules: {
            'default': function (ast, methodType, isArg) {
                var name = (methodType === 'Helper' && !ast.root ? 'Helper' : '') + (isArg ? 'Scope' : '') + 'Lookup';
                return expression[name];
            },
            'method': function (ast, methodType, isArg) {
                return ScopeLookup;
            }
        },
        methodRules: {
            'default': function (ast) {
                return ast.type === 'Call' ? Call : Helper;
            },
            'call': function (ast) {
                return Call;
            }
        },
        parse: function (expressionString, options) {
            options = options || {};
            var ast = this.ast(expressionString);
            if (!options.lookupRule) {
                options.lookupRule = 'default';
            }
            if (typeof options.lookupRule === 'string') {
                options.lookupRule = expression.lookupRules[options.lookupRule];
            }
            if (!options.methodRule) {
                options.methodRule = 'default';
            }
            if (typeof options.methodRule === 'string') {
                options.methodRule = expression.methodRules[options.methodRule];
            }
            var expr = this.hydrateAst(ast, options, options.baseMethodType || 'Helper');
            return expr;
        },
        hydrateAst: function (ast, options, methodType, isArg) {
            var hashes;
            if (ast.type === 'Lookup') {
                return new (options.lookupRule(ast, methodType, isArg))(ast.key, ast.root && this.hydrateAst(ast.root, options, methodType));
            } else if (ast.type === 'Literal') {
                return new Literal(ast.value);
            } else if (ast.type === 'Arg') {
                return new Arg(this.hydrateAst(ast.children[0], options, methodType, isArg), { compute: true });
            } else if (ast.type === 'Hash') {
                throw new Error('');
            } else if (ast.type === 'Hashes') {
                hashes = {};
                each(ast.children, function (hash) {
                    hashes[hash.prop] = this.hydrateAst(hash.children[0], options, methodType, true);
                }, this);
                return new Hashes(hashes);
            } else if (ast.type === 'Call' || ast.type === 'Helper') {
                hashes = {};
                var args = [], children = ast.children, ExpressionType = options.methodRule(ast);
                if (children) {
                    for (var i = 0; i < children.length; i++) {
                        var child = children[i];
                        if (child.type === 'Hashes' && ast.type === 'Helper' && ExpressionType !== Call) {
                            each(child.children, function (hash) {
                                hashes[hash.prop] = this.hydrateAst(hash.children[0], options, ast.type, true);
                            }, this);
                        } else {
                            args.push(this.hydrateAst(child, options, ast.type, true));
                        }
                    }
                }
                return new ExpressionType(this.hydrateAst(ast.method, options, ast.type), args, hashes);
            } else if (ast.type === 'Bracket') {
                return new Bracket(this.hydrateAst(ast.children[0], options), ast.root ? this.hydrateAst(ast.root, options) : undefined);
            }
        },
        ast: function (expression) {
            var tokens = this.tokenize(expression);
            return this.parseAst(tokens, { index: 0 });
        },
        parseAst: function (tokens, cursor) {
            var stack = new Stack(), top, firstParent, lastToken;
            while (cursor.index < tokens.length) {
                var token = tokens[cursor.index], nextToken = tokens[cursor.index + 1];
                cursor.index++;
                if (literalRegExp.test(token)) {
                    convertToHelperIfTopIsLookup(stack);
                    firstParent = stack.first([
                        'Helper',
                        'Call',
                        'Hash',
                        'Bracket'
                    ]);
                    if (firstParent.type === 'Hash' && (firstParent.children && firstParent.children.length > 0)) {
                        stack.addTo([
                            'Helper',
                            'Call',
                            'Bracket'
                        ], {
                            type: 'Literal',
                            value: utils.jsonParse(token)
                        });
                    } else if (firstParent.type === 'Bracket' && (firstParent.children && firstParent.children.length > 0)) {
                        stack.addTo([
                            'Helper',
                            'Call',
                            'Hash'
                        ], {
                            type: 'Literal',
                            value: utils.jsonParse(token)
                        });
                    } else {
                        stack.addTo([
                            'Helper',
                            'Call',
                            'Hash',
                            'Bracket'
                        ], {
                            type: 'Literal',
                            value: utils.jsonParse(token)
                        });
                    }
                } else if (nextToken === '=') {
                    top = stack.top();
                    if (top && top.type === 'Lookup') {
                        firstParent = stack.firstParent([
                            'Call',
                            'Helper',
                            'Hash'
                        ]);
                        if (firstParent.type === 'Call' || firstParent.type === 'Root') {
                            stack.popUntil(['Call']);
                            top = stack.top();
                            stack.replaceTopAndPush({
                                type: 'Helper',
                                method: top.type === 'Root' ? last(top.children) : top
                            });
                        }
                    }
                    firstParent = stack.firstParent([
                        'Call',
                        'Helper',
                        'Hashes'
                    ]);
                    var hash = {
                        type: 'Hash',
                        prop: token
                    };
                    if (firstParent.type === 'Hashes') {
                        stack.addToAndPush(['Hashes'], hash);
                    } else {
                        stack.addToAndPush([
                            'Helper',
                            'Call'
                        ], {
                            type: 'Hashes',
                            children: [hash]
                        });
                        stack.push(hash);
                    }
                    cursor.index++;
                } else if (keyRegExp.test(token)) {
                    lastToken = stack.topLastChild();
                    firstParent = stack.first([
                        'Helper',
                        'Call',
                        'Hash',
                        'Bracket'
                    ]);
                    if (lastToken && (lastToken.type === 'Call' || lastToken.type === 'Bracket') && isAddingToExpression(token)) {
                        stack.replaceTopLastChildAndPush({
                            type: 'Lookup',
                            root: lastToken,
                            key: token.slice(1)
                        });
                    } else if (firstParent.type === 'Bracket') {
                        if (!(firstParent.children && firstParent.children.length > 0)) {
                            stack.addToAndPush(['Bracket'], {
                                type: 'Lookup',
                                key: token
                            });
                        } else {
                            if (stack.first([
                                    'Helper',
                                    'Call',
                                    'Hash',
                                    'Arg'
                                ]).type === 'Helper' && token[0] !== '.') {
                                stack.addToAndPush(['Helper'], {
                                    type: 'Lookup',
                                    key: token
                                });
                            } else {
                                stack.replaceTopAndPush({
                                    type: 'Lookup',
                                    key: token.slice(1),
                                    root: firstParent
                                });
                            }
                        }
                    } else {
                        convertToHelperIfTopIsLookup(stack);
                        stack.addToAndPush([
                            'Helper',
                            'Call',
                            'Hash',
                            'Arg',
                            'Bracket'
                        ], {
                            type: 'Lookup',
                            key: token
                        });
                    }
                } else if (token === '~') {
                    convertToHelperIfTopIsLookup(stack);
                    stack.addToAndPush([
                        'Helper',
                        'Call',
                        'Hash'
                    ], {
                        type: 'Arg',
                        key: token
                    });
                } else if (token === '(') {
                    top = stack.top();
                    if (top.type === 'Lookup') {
                        stack.replaceTopAndPush({
                            type: 'Call',
                            method: convertToAtLookup(top)
                        });
                    } else {
                        throw new Error('Unable to understand expression ' + tokens.join(''));
                    }
                } else if (token === ')') {
                    stack.popTo(['Call']);
                } else if (token === ',') {
                    stack.popUntil(['Call']);
                } else if (token === '[') {
                    top = stack.top();
                    lastToken = stack.topLastChild();
                    if (lastToken && (lastToken.type === 'Call' || lastToken.type === 'Bracket')) {
                        stack.replaceTopAndPush({
                            type: 'Bracket',
                            root: lastToken
                        });
                    } else if (top.type === 'Lookup' || top.type === 'Bracket') {
                        stack.replaceTopAndPush({
                            type: 'Bracket',
                            root: top
                        });
                    } else if (top.type === 'Call') {
                        stack.addToAndPush(['Call'], { type: 'Bracket' });
                    } else if (top === ' ') {
                        stack.popUntil(['Lookup']);
                        convertToHelperIfTopIsLookup(stack);
                        stack.addToAndPush([
                            'Helper',
                            'Call',
                            'Hash'
                        ], { type: 'Bracket' });
                    } else {
                        stack.replaceTopAndPush({ type: 'Bracket' });
                    }
                } else if (token === ']') {
                    stack.pop();
                } else if (token === ' ') {
                    stack.push(token);
                }
            }
            return stack.root.children[0];
        }
    };
    module.exports = expression;
});
/*can-view-model@3.4.0#can-view-model*/
define('can-view-model@3.4.0#can-view-model', function (require, exports, module) {
    'use strict';
    var domData = require('can-util/dom/data/data');
    var SimpleMap = require('can-simple-map');
    var types = require('can-types');
    var ns = require('can-namespace');
    var getDocument = require('can-util/dom/document/document');
    var isArrayLike = require('can-util/js/is-array-like/is-array-like');
    var canReflect = require('can-reflect');
    module.exports = ns.viewModel = function (el, attr, val) {
        var scope;
        if (typeof el === 'string') {
            el = getDocument().querySelector(el);
        } else if (isArrayLike(el) && !el.nodeType) {
            el = el[0];
        }
        if (canReflect.isObservableLike(attr) && canReflect.isMapLike(attr)) {
            return domData.set.call(el, 'viewModel', attr);
        }
        scope = domData.get.call(el, 'viewModel');
        if (!scope) {
            scope = types.DefaultMap ? new types.DefaultMap() : new SimpleMap();
            domData.set.call(el, 'viewModel', scope);
        }
        switch (arguments.length) {
        case 0:
        case 1:
            return scope;
        case 2:
            return 'attr' in scope ? scope.attr(attr) : scope[attr];
        default:
            if ('attr' in scope) {
                scope.attr(attr, val);
            } else {
                scope[attr] = val;
            }
            return el;
        }
    };
});
/*can-dom-events@1.0.3#helpers/util*/
define('can-dom-events@1.0.3#helpers/util', function (require, exports, module) {
    'use strict';
    var getCurrentDocument = require('can-util/dom/document/document');
    var isBrowserWindow = require('can-util/js/is-browser-window/is-browser-window');
    function getTargetDocument(target) {
        return target.ownerDocument || getCurrentDocument();
    }
    function createEvent(target, eventData, bubbles, cancelable) {
        var doc = getTargetDocument(target);
        var event = doc.createEvent('HTMLEvents');
        var eventType;
        if (typeof eventData === 'string') {
            eventType = eventData;
        } else {
            eventType = eventData.type;
            for (var prop in eventData) {
                if (event[prop] === undefined) {
                    event[prop] = eventData[prop];
                }
            }
        }
        if (bubbles === undefined) {
            bubbles = true;
        }
        event.initEvent(eventType, bubbles, cancelable);
        return event;
    }
    function isDomEventTarget(obj) {
        if (!(obj && obj.nodeName)) {
            return obj === window;
        }
        var nodeType = obj.nodeType;
        return nodeType === Node.DOCUMENT_NODE || nodeType === Node.ELEMENT_NODE;
    }
    function addDomContext(context, args) {
        if (isDomEventTarget(context)) {
            args = Array.prototype.slice.call(args, 0);
            args.unshift(context);
        }
        return args;
    }
    function removeDomContext(context, args) {
        if (!isDomEventTarget(context)) {
            args = Array.prototype.slice.call(args, 0);
            context = args.shift();
        }
        return {
            context: context,
            args: args
        };
    }
    var fixSyntheticEventsOnDisabled = false;
    (function () {
        if (!isBrowserWindow()) {
            return;
        }
        var testEventName = 'fix_synthetic_events_on_disabled_test';
        var input = document.createElement('input');
        input.disabled = true;
        var timer = setTimeout(function () {
            fixSyntheticEventsOnDisabled = true;
        }, 50);
        var onTest = function onTest() {
            clearTimeout(timer);
            input.removeEventListener(testEventName, onTest);
        };
        input.addEventListener(testEventName, onTest);
        try {
            var event = document.create('HTMLEvents');
            event.initEvent(testEventName, false);
            input.dispatchEvent(event);
        } catch (e) {
            onTest();
            fixSyntheticEventsOnDisabled = true;
        }
    }());
    function isDispatchingOnDisabled(element, event) {
        var eventType = event.type;
        var isInsertedOrRemoved = eventType === 'inserted' || eventType === 'removed';
        var isDisabled = !!element.disabled;
        return isInsertedOrRemoved && isDisabled;
    }
    function forceEnabledForDispatch(element, event) {
        return fixSyntheticEventsOnDisabled && isDispatchingOnDisabled(element, event);
    }
    module.exports = {
        createEvent: createEvent,
        addDomContext: addDomContext,
        removeDomContext: removeDomContext,
        isDomEventTarget: isDomEventTarget,
        getTargetDocument: getTargetDocument,
        forceEnabledForDispatch: forceEnabledForDispatch
    };
});
/*can-dom-events@1.0.3#helpers/add-event-compat*/
define('can-dom-events@1.0.3#helpers/add-event-compat', function (require, exports, module) {
    'use strict';
    var util = require('./util');
    var addDomContext = util.addDomContext;
    var removeDomContext = util.removeDomContext;
    function isDomEvents(obj) {
        return !!(obj && obj.addEventListener && obj.removeEventListener && obj.dispatch);
    }
    function isNewEvents(obj) {
        return typeof obj.addEvent === 'function';
    }
    module.exports = function addEventCompat(domEvents, customEvent, customEventType) {
        if (!isDomEvents(domEvents)) {
            throw new Error('addEventCompat() must be passed can-dom-events or can-util/dom/events/events');
        }
        customEventType = customEventType || customEvent.defaultEventType;
        if (isNewEvents(domEvents)) {
            return domEvents.addEvent(customEvent, customEventType);
        }
        var registry = domEvents._compatRegistry;
        if (!registry) {
            registry = domEvents._compatRegistry = {};
        }
        if (registry[customEventType]) {
            return function noopRemoveOverride() {
            };
        }
        registry[customEventType] = customEvent;
        var newEvents = {
            addEventListener: function () {
                var data = removeDomContext(this, arguments);
                return domEvents.addEventListener.apply(data.context, data.args);
            },
            removeEventListener: function () {
                var data = removeDomContext(this, arguments);
                return domEvents.removeEventListener.apply(data.context, data.args);
            },
            dispatch: function () {
                var data = removeDomContext(this, arguments);
                var eventData = data.args[0];
                var eventArgs = typeof eventData === 'object' ? eventData.args : [];
                data.args.splice(1, 0, eventArgs);
                return domEvents.dispatch.apply(data.context, data.args);
            }
        };
        var isOverriding = true;
        var oldAddEventListener = domEvents.addEventListener;
        var addEventListener = domEvents.addEventListener = function addEventListener(eventName) {
            if (isOverriding && eventName === customEventType) {
                var args = addDomContext(this, arguments);
                customEvent.addEventListener.apply(newEvents, args);
            }
            return oldAddEventListener.apply(this, arguments);
        };
        var oldRemoveEventListener = domEvents.removeEventListener;
        var removeEventListener = domEvents.removeEventListener = function removeEventListener(eventName) {
            if (isOverriding && eventName === customEventType) {
                var args = addDomContext(this, arguments);
                customEvent.removeEventListener.apply(newEvents, args);
            }
            return oldRemoveEventListener.apply(this, arguments);
        };
        return function removeOverride() {
            isOverriding = false;
            registry[customEventType] = null;
            if (domEvents.addEventListener === addEventListener) {
                domEvents.addEventListener = oldAddEventListener;
            }
            if (domEvents.removeEventListener === removeEventListener) {
                domEvents.removeEventListener = oldRemoveEventListener;
            }
        };
    };
});
/*can-event-dom-enter@1.0.1#can-event-dom-enter*/
define('can-event-dom-enter@1.0.1#can-event-dom-enter', function (require, exports, module) {
    'use strict';
    var domData = require('can-util/dom/data/data');
    var getCid = require('can-util/js/cid/get-cid');
    var baseEventType = 'keyup';
    function isEnterEvent(event) {
        var hasEnterKey = event.key === 'Enter';
        var hasEnterCode = event.keyCode === 13;
        return hasEnterKey || hasEnterCode;
    }
    function getHandlerKey(eventType, handler) {
        return eventType + ':' + getCid(handler);
    }
    function associateHandler(target, eventType, handler, otherHandler) {
        var key = getHandlerKey(eventType, handler);
        domData.set.call(target, key, otherHandler);
    }
    function disassociateHandler(target, eventType, handler) {
        var key = getHandlerKey(eventType, handler);
        var otherHandler = domData.get.call(target, key);
        if (otherHandler) {
            domData.clean.call(target, key);
        }
        return otherHandler;
    }
    module.exports = {
        defaultEventType: 'enter',
        addEventListener: function (target, eventType, handler) {
            var keyHandler = function (event) {
                if (isEnterEvent(event)) {
                    return handler.apply(this, arguments);
                }
            };
            associateHandler(target, eventType, handler, keyHandler);
            this.addEventListener(target, baseEventType, keyHandler);
        },
        removeEventListener: function (target, eventType, handler) {
            var keyHandler = disassociateHandler(target, eventType, handler);
            if (keyHandler) {
                this.removeEventListener(target, baseEventType, keyHandler);
            }
        }
    };
});
/*can-event-dom-enter@1.0.1#compat*/
define('can-event-dom-enter@1.0.1#compat', function (require, exports, module) {
    var addEventCompat = require('can-dom-events/helpers/add-event-compat');
    var radioChange = require('./can-event-dom-enter');
    module.exports = function (domEvents, eventType) {
        return addEventCompat(domEvents, radioChange, eventType);
    };
});
/*can-dom-events@1.0.3#helpers/make-event-registry*/
define('can-dom-events@1.0.3#helpers/make-event-registry', function (require, exports, module) {
    'use strict';
    function EventRegistry() {
        this._registry = {};
    }
    module.exports = function makeEventRegistry() {
        return new EventRegistry();
    };
    EventRegistry.prototype.has = function (eventType) {
        return !!this._registry[eventType];
    };
    EventRegistry.prototype.get = function (eventType) {
        return this._registry[eventType];
    };
    EventRegistry.prototype.add = function (event, eventType) {
        if (!event) {
            throw new Error('An EventDefinition must be provided');
        }
        if (typeof event.addEventListener !== 'function') {
            throw new TypeError('EventDefinition addEventListener must be a function');
        }
        if (typeof event.removeEventListener !== 'function') {
            throw new TypeError('EventDefinition removeEventListener must be a function');
        }
        eventType = eventType || event.defaultEventType;
        if (typeof eventType !== 'string') {
            throw new TypeError('Event type must be a string, not ' + eventType);
        }
        if (this.has(eventType)) {
            throw new Error('Event "' + eventType + '" is already registered');
        }
        this._registry[eventType] = event;
        var self = this;
        return function remove() {
            self._registry[eventType] = undefined;
        };
    };
});
/*can-dom-events@1.0.3#can-dom-events*/
define('can-dom-events@1.0.3#can-dom-events', function (require, exports, module) {
    (function (global) {
        'use strict';
        var namespace = require('can-namespace');
        var util = require('./helpers/util');
        var makeEventRegistry = require('./helpers/make-event-registry');
        var domEvents = {
            _eventRegistry: makeEventRegistry(),
            addEvent: function (event, eventType) {
                return this._eventRegistry.add(event, eventType);
            },
            addEventListener: function (target, eventType) {
                var hasCustomEvent = domEvents._eventRegistry.has(eventType);
                if (hasCustomEvent) {
                    var event = domEvents._eventRegistry.get(eventType);
                    return event.addEventListener.apply(domEvents, arguments);
                }
                var eventArgs = Array.prototype.slice.call(arguments, 1);
                return target.addEventListener.apply(target, eventArgs);
            },
            removeEventListener: function (target, eventType) {
                var hasCustomEvent = domEvents._eventRegistry.has(eventType);
                if (hasCustomEvent) {
                    var event = domEvents._eventRegistry.get(eventType);
                    return event.removeEventListener.apply(domEvents, arguments);
                }
                var eventArgs = Array.prototype.slice.call(arguments, 1);
                return target.removeEventListener.apply(target, eventArgs);
            },
            dispatch: function (target, eventData, bubbles, cancelable) {
                var event = util.createEvent(target, eventData, bubbles, cancelable);
                var enableForDispatch = util.forceEnabledForDispatch(target, event);
                if (enableForDispatch) {
                    target.disabled = false;
                }
                var ret = target.dispatchEvent(event);
                if (enableForDispatch) {
                    target.disabled = true;
                }
                return ret;
            }
        };
        module.exports = namespace.domEvents = domEvents;
    }(function () {
        return this;
    }()));
});
/*can-event-dom-radiochange@1.0.0#can-event-dom-radiochange*/
define('can-event-dom-radiochange@1.0.0#can-event-dom-radiochange', function (require, exports, module) {
    'use strict';
    var events = require('can-util/dom/events/events');
    var domData = require('can-util/dom/data/data');
    var getDocument = require('can-util/dom/document/document');
    var domEvents = require('can-dom-events');
    var CIDMap = require('can-util/js/cid-map/cid-map');
    function getRoot(el) {
        return el.ownerDocument || getDocument().documentElement;
    }
    function getRegistryName(eventName) {
        return 'can-event-radiochange:' + eventName + ':registry';
    }
    function getListenerName(eventName) {
        return 'can-event-radiochange:' + eventName + ':listener';
    }
    function getRegistry(root, eventName) {
        var name = getRegistryName(eventName);
        var registry = domData.get.call(root, name);
        if (!registry) {
            registry = new CIDMap();
            domData.set.call(root, name, registry);
        }
        return registry;
    }
    function findParentForm(el) {
        while (el) {
            if (el.nodeName === 'FORM') {
                break;
            }
            el = el.parentNode;
        }
        return el;
    }
    function shouldReceiveEventFromRadio(source, dest) {
        var name = source.getAttribute('name');
        return name && name === dest.getAttribute('name') && findParentForm(source) === findParentForm(dest);
    }
    function isRadioInput(el) {
        return el.nodeName === 'INPUT' && el.type === 'radio';
    }
    function dispatch(eventName, target) {
        var root = getRoot(target);
        var registry = getRegistry(root, eventName);
        registry.forEach(function (el) {
            if (shouldReceiveEventFromRadio(target, el)) {
                domEvents.dispatch(el, eventName);
            }
        });
    }
    function attachRootListener(root, eventName) {
        var listenerName = getListenerName(eventName);
        var listener = domData.get.call(root, listenerName);
        if (listener) {
            return;
        }
        var newListener = function (event) {
            var target = event.target;
            if (isRadioInput(target)) {
                dispatch(eventName, target);
            }
        };
        events.addEventListener.call(root, 'change', newListener);
        domData.set.call(root, listenerName, newListener);
    }
    function detachRootListener(root, eventName) {
        var listenerName = getListenerName(eventName);
        var listener = domData.get.call(root, listenerName);
        if (!listener) {
            return;
        }
        var registry = getRegistry(root, eventName);
        if (registry.size > 0) {
            return;
        }
        events.removeEventListener.call(root, 'change', listener);
        domData.clean.call(root, listenerName);
    }
    function addListener(eventName, el) {
        if (!isRadioInput(el)) {
            throw new Error('Listeners for ' + eventName + ' must be radio inputs');
        }
        var root = getRoot(el);
        getRegistry(root, eventName).set(el, el);
        attachRootListener(root, eventName);
    }
    function removeListener(eventName, el) {
        var root = getRoot(el);
        getRegistry(root, eventName).delete(el);
        detachRootListener(root, eventName);
    }
    module.exports = {
        defaultEventType: 'radiochange',
        addEventListener: function (target, eventName, handler) {
            addListener(eventName, target);
            target.addEventListener(eventName, handler);
        },
        removeEventListener: function (target, eventName, handler) {
            removeListener(eventName, target);
            target.removeEventListener(eventName, handler);
        }
    };
});
/*can-event-dom-radiochange@1.0.0#compat*/
define('can-event-dom-radiochange@1.0.0#compat', function (require, exports, module) {
    var addEventCompat = require('can-dom-events/helpers/add-event-compat');
    var radioChange = require('./can-event-dom-radiochange');
    module.exports = function (domEvents, eventType) {
        return addEventCompat(domEvents, radioChange, eventType);
    };
});
/*can-stache-bindings@3.4.4#can-stache-bindings*/
define('can-stache-bindings@3.4.4#can-stache-bindings', function (require, exports, module) {
    var expression = require('can-stache/src/expression');
    var viewCallbacks = require('can-view-callbacks');
    var live = require('can-view-live');
    var Scope = require('can-view-scope');
    var canViewModel = require('can-view-model');
    var canEvent = require('can-event');
    var canBatch = require('can-event/batch/batch');
    var compute = require('can-compute');
    var observeReader = require('can-stache-key');
    var Observation = require('can-observation');
    var CID = require('can-cid');
    var assign = require('can-util/js/assign/assign');
    var makeArray = require('can-util/js/make-array/make-array');
    var each = require('can-util/js/each/each');
    var string = require('can-util/js/string/string');
    var dev = require('can-util/js/dev/dev');
    var types = require('can-types');
    var last = require('can-util/js/last/last');
    var getMutationObserver = require('can-util/dom/mutation-observer/mutation-observer');
    var domEvents = require('can-util/dom/events/events');
    require('can-util/dom/events/removed/removed');
    var domData = require('can-util/dom/data/data');
    var attr = require('can-util/dom/attr/attr');
    var canLog = require('can-util/js/log/log');
    var stacheHelperCore = require('can-stache/helpers/core');
    var canSymbol = require('can-symbol');
    var canReflect = require('can-reflect');
    var singleReference = require('can-util/js/single-reference/single-reference');
    var addEnterEvent = require('can-event-dom-enter/compat');
    addEnterEvent(domEvents);
    var addRadioChange = require('can-event-dom-radiochange/compat');
    addRadioChange(domEvents);
    var noop = function () {
    };
    var reflectiveValue = function (value) {
        var handlers = [];
        var fn = function (newValue) {
            if (arguments.length) {
                value = newValue;
                handlers.forEach(function (handler) {
                    canBatch.queue([
                        handler,
                        fn,
                        [newValue]
                    ]);
                }, this);
            } else {
                Observation.add(fn);
                return value;
            }
        };
        CID(fn);
        canReflect.set(fn, canSymbol.for('can.onValue'), function (handler) {
            handlers.push(handler);
        });
        canReflect.set(fn, canSymbol.for('can.offValue'), function (handler) {
            var index = handlers.indexOf(handler);
            handlers.splice(index, 1);
        });
        canReflect.set(fn, canSymbol.for('can.setValue'), function (newValue) {
            return fn(newValue);
        });
        canReflect.set(fn, canSymbol.for('can.getValue'), function () {
            return fn();
        });
        fn.isComputed = true;
        return fn;
    };
    function setPriority(observable, priority) {
        if (observable instanceof Observation) {
            observable.compute._primaryDepth = priority;
        } else if (observable.computeInstance) {
            observable.computeInstance.setPrimaryDepth(priority);
        } else if (observable.observation) {
            observable.observation.compute._primaryDepth = priority;
        }
    }
    var throwOnlyOneTypeOfBindingError = function () {
        throw new Error('can-stache-bindings - you can not have contextual bindings ( {this}=\'value\' ) and key bindings ( {prop}=\'value\' ) on one element.');
    };
    var checkBindingState = function (bindingState, dataBinding) {
        var isSettingOnViewModel = dataBinding.bindingInfo.parentToChild && dataBinding.bindingInfo.child === 'viewModel';
        if (isSettingOnViewModel) {
            var bindingName = dataBinding.bindingInfo.childName;
            var isSettingViewModel = isSettingOnViewModel && (bindingName === 'this' || bindingName === '.');
            if (isSettingViewModel) {
                if (bindingState.isSettingViewModel || bindingState.isSettingOnViewModel) {
                    throwOnlyOneTypeOfBindingError();
                } else {
                    return {
                        isSettingViewModel: true,
                        initialViewModelData: undefined
                    };
                }
            } else {
                if (bindingState.isSettingViewModel) {
                    throwOnlyOneTypeOfBindingError();
                } else {
                    return {
                        isSettingOnViewModel: true,
                        initialViewModelData: bindingState.initialViewModelData
                    };
                }
            }
        } else {
            return bindingState;
        }
    };
    var behaviors = {
        viewModel: function (el, tagData, makeViewModel, initialViewModelData, staticDataBindingsOnly) {
            var bindingsSemaphore = {}, viewModel, onCompleteBindings = [], onTeardowns = {}, bindingInfos = {}, attributeViewModelBindings = assign({}, initialViewModelData), bindingsState = {
                    isSettingOnViewModel: false,
                    isSettingViewModel: false,
                    initialViewModelData: initialViewModelData || {}
                }, hasDataBinding = false;
            each(makeArray(el.attributes), function (node) {
                var dataBinding = makeDataBinding(node, el, {
                    templateType: tagData.templateType,
                    scope: tagData.scope,
                    semaphore: bindingsSemaphore,
                    getViewModel: function () {
                        return viewModel;
                    },
                    attributeViewModelBindings: attributeViewModelBindings,
                    alreadyUpdatedChild: true,
                    nodeList: tagData.parentNodeList
                });
                if (dataBinding) {
                    bindingsState = checkBindingState(bindingsState, dataBinding);
                    hasDataBinding = true;
                    if (dataBinding.onCompleteBinding) {
                        if (dataBinding.bindingInfo.parentToChild && dataBinding.value !== undefined) {
                            if (bindingsState.isSettingViewModel) {
                                bindingsState.initialViewModelData = dataBinding.value;
                            } else {
                                bindingsState.initialViewModelData[cleanVMName(dataBinding.bindingInfo.childName)] = dataBinding.value;
                            }
                        }
                        onCompleteBindings.push(dataBinding.onCompleteBinding);
                    }
                    onTeardowns[node.name] = dataBinding.onTeardown;
                }
            });
            if (staticDataBindingsOnly && !hasDataBinding) {
                return;
            }
            viewModel = makeViewModel(bindingsState.initialViewModelData, hasDataBinding);
            for (var i = 0, len = onCompleteBindings.length; i < len; i++) {
                onCompleteBindings[i]();
            }
            if (!bindingsState.isSettingViewModel) {
                domEvents.addEventListener.call(el, 'attributes', function (ev) {
                    var attrName = ev.attributeName, value = el.getAttribute(attrName);
                    if (onTeardowns[attrName]) {
                        onTeardowns[attrName]();
                    }
                    var parentBindingWasAttribute = bindingInfos[attrName] && bindingInfos[attrName].parent === 'attribute';
                    if (value !== null || parentBindingWasAttribute) {
                        var dataBinding = makeDataBinding({
                            name: attrName,
                            value: value
                        }, el, {
                            templateType: tagData.templateType,
                            scope: tagData.scope,
                            semaphore: {},
                            getViewModel: function () {
                                return viewModel;
                            },
                            attributeViewModelBindings: attributeViewModelBindings,
                            initializeValues: true,
                            nodeList: tagData.parentNodeList
                        });
                        if (dataBinding) {
                            if (dataBinding.onCompleteBinding) {
                                dataBinding.onCompleteBinding();
                            }
                            bindingInfos[attrName] = dataBinding.bindingInfo;
                            onTeardowns[attrName] = dataBinding.onTeardown;
                        }
                    }
                });
            }
            return function () {
                for (var attrName in onTeardowns) {
                    onTeardowns[attrName]();
                }
            };
        },
        data: function (el, attrData) {
            if (domData.get.call(el, 'preventDataBindings')) {
                return;
            }
            var viewModel = canViewModel(el), semaphore = {}, teardown;
            var twoWay = bindingsRegExp.exec(attrData.attributeName)[1];
            var dataBinding = makeDataBinding({
                name: attrData.attributeName,
                value: el.getAttribute(attrData.attributeName),
                nodeList: attrData.nodeList
            }, el, {
                templateType: attrData.templateType,
                scope: attrData.scope,
                semaphore: semaphore,
                getViewModel: function () {
                    return viewModel;
                },
                syncChildWithParent: twoWay
            });
            if (dataBinding.onCompleteBinding) {
                dataBinding.onCompleteBinding();
            }
            teardown = dataBinding.onTeardown;
            canEvent.one.call(el, 'removed', function () {
                teardown();
            });
            domEvents.addEventListener.call(el, 'attributes', function (ev) {
                var attrName = ev.attributeName, value = el.getAttribute(attrName);
                if (attrName === attrData.attributeName) {
                    if (teardown) {
                        teardown();
                    }
                    if (value !== null) {
                        var dataBinding = makeDataBinding({
                            name: attrName,
                            value: value
                        }, el, {
                            templateType: attrData.templateType,
                            scope: attrData.scope,
                            semaphore: semaphore,
                            getViewModel: function () {
                                return viewModel;
                            },
                            initializeValues: true,
                            nodeList: attrData.nodeList,
                            syncChildWithParent: twoWay
                        });
                        if (dataBinding) {
                            if (dataBinding.onCompleteBinding) {
                                dataBinding.onCompleteBinding();
                            }
                            teardown = dataBinding.onTeardown;
                        }
                    }
                }
            });
        },
        reference: function (el, attrData) {
            if (el.getAttribute(attrData.attributeName)) {
                canLog.warn('*reference attributes can only export the view model.');
            }
            var name = string.camelize(attrData.attributeName.substr(1).toLowerCase());
            var viewModel = canViewModel(el);
            var refs = attrData.scope.getRefs();
            refs._context.attr('*' + name, viewModel);
        },
        event: function (el, data) {
            var attributeName = data.attributeName, legacyBinding = attributeName.indexOf('can-') === 0, event = attributeName.indexOf('can-') === 0 ? attributeName.substr('can-'.length) : removeBrackets(attributeName, '(', ')'), onBindElement = legacyBinding;
            event = decodeAttrName(event);
            if (event.charAt(0) === '$') {
                event = event.substr(1);
                onBindElement = true;
            }
            var handler = function (ev) {
                var attrVal = el.getAttribute(attributeName);
                if (!attrVal) {
                    return;
                }
                var viewModel = canViewModel(el);
                var expr = expression.parse(removeBrackets(attrVal), {
                    lookupRule: function () {
                        return expression.Lookup;
                    },
                    methodRule: 'call'
                });
                if (!(expr instanceof expression.Call) && !(expr instanceof expression.Helper)) {
                    var defaultArgs = [
                        data.scope._context,
                        el
                    ].concat(makeArray(arguments)).map(function (data) {
                        return new expression.Arg(new expression.Literal(data));
                    });
                    expr = new expression.Call(expr, defaultArgs, {});
                }
                var localScope = data.scope.add({
                    '@element': el,
                    '@event': ev,
                    '@viewModel': viewModel,
                    '@scope': data.scope,
                    '@context': data.scope._context,
                    '%element': this,
                    '$element': types.wrapElement(el),
                    '%event': ev,
                    '%viewModel': viewModel,
                    '%scope': data.scope,
                    '%context': data.scope._context,
                    '%arguments': arguments
                }, { notContext: true });
                var scopeData = localScope.read(expr.methodExpr.key, { isArgument: true }), args, stacheHelper, stacheHelperResult;
                if (!scopeData.value) {
                    var name = observeReader.reads(expr.methodExpr.key).map(function (part) {
                        return part.key;
                    }).join('.');
                    stacheHelper = stacheHelperCore.getHelper(name);
                    if (stacheHelper) {
                        args = expr.args(localScope, null)();
                        stacheHelperResult = stacheHelper.fn.apply(localScope.peek('.'), args);
                        if (typeof stacheHelperResult === 'function') {
                            stacheHelperResult(el);
                        }
                        return stacheHelperResult;
                    }
                    return null;
                }
                args = expr.args(localScope, null)();
                return scopeData.value.apply(scopeData.parent, args);
            };
            var context;
            if (onBindElement) {
                context = el;
            } else {
                if (event.indexOf(' ') >= 0) {
                    var eventSplit = event.split(' ');
                    context = data.scope.get(eventSplit[0]);
                    event = eventSplit[1];
                } else {
                    context = canViewModel(el);
                }
            }
            var attributesHandler = function (ev) {
                var isEventAttribute = ev.attributeName === attributeName;
                var isRemoved = !this.getAttribute(attributeName);
                var isEventAttributeRemoved = isEventAttribute && isRemoved;
                if (isEventAttributeRemoved) {
                    unbindEvent();
                }
            };
            var removedHandler = function (ev) {
                unbindEvent();
            };
            var unbindEvent = function () {
                canEvent.off.call(context, event, handler);
                canEvent.off.call(el, 'attributes', attributesHandler);
                canEvent.off.call(el, 'removed', removedHandler);
            };
            canEvent.on.call(context, event, handler);
            canEvent.on.call(el, 'attributes', attributesHandler);
            canEvent.on.call(el, 'removed', removedHandler);
        },
        value: function (el, data) {
            var propName = '$value', attrValue = removeBrackets(el.getAttribute('can-value')).trim(), nodeName = el.nodeName.toLowerCase(), elType = nodeName === 'input' && (el.type || el.getAttribute('type')), getterSetter;
            if (nodeName === 'input' && (elType === 'checkbox' || elType === 'radio')) {
                var property = getObservableFrom.scope(el, data.scope, attrValue, {}, true);
                if (el.type === 'checkbox') {
                    var trueValue = attr.has(el, 'can-true-value') ? el.getAttribute('can-true-value') : true, falseValue = attr.has(el, 'can-false-value') ? el.getAttribute('can-false-value') : false;
                    getterSetter = compute(function (newValue) {
                        var isSet = arguments.length !== 0;
                        if (property && property[canSymbol.for('can.getValue')]) {
                            if (isSet) {
                                canReflect.setValue(property, newValue ? trueValue : falseValue);
                            } else {
                                return canReflect.getValue(property) == trueValue;
                            }
                        } else {
                            if (isSet) {
                            } else {
                                return property == trueValue;
                            }
                        }
                    });
                } else if (elType === 'radio') {
                    getterSetter = compute(function (newValue) {
                        var isSet = arguments.length !== 0 && newValue;
                        if (property && property[canSymbol.for('can.getValue')]) {
                            if (isSet) {
                                canReflect.setValue(property, el.value);
                            } else {
                                return canReflect.getValue(property) == el.value;
                            }
                        } else {
                            if (isSet) {
                            } else {
                                return property == el.value;
                            }
                        }
                    });
                }
                propName = '$checked';
                attrValue = 'getterSetter';
                data.scope = new Scope({ getterSetter: getterSetter });
            } else if (isContentEditable(el)) {
                propName = '$innerHTML';
            }
            var dataBinding = makeDataBinding({
                name: '{(' + propName + '})',
                value: attrValue
            }, el, {
                templateType: data.templateType,
                scope: data.scope,
                semaphore: {},
                initializeValues: true,
                legacyBindings: true
            });
            canEvent.one.call(el, 'removed', function () {
                dataBinding.onTeardown();
            });
        }
    };
    viewCallbacks.attr(/^\{[^\}]+\}$/, behaviors.data);
    viewCallbacks.attr(/\*[\w\.\-_]+/, behaviors.reference);
    viewCallbacks.attr(/^\([\$?\w\.\\]+\)$/, behaviors.event);
    viewCallbacks.attr(/can-[\w\.]+/, behaviors.event);
    viewCallbacks.attr('can-value', behaviors.value);
    var getObservableFrom = {
        scope: function (el, scope, scopeProp, bindingData, mustBeSettable, stickyCompute) {
            if (!scopeProp) {
                return reflectiveValue();
            } else {
                if (mustBeSettable) {
                    var parentExpression = expression.parse(scopeProp, { baseMethodType: 'Call' });
                    return parentExpression.value(scope, new Scope.Options({}));
                } else {
                    var observation = new Observation(function () {
                    });
                    observation[canSymbol.for('can.setValue')] = function (newVal) {
                        scope.set(cleanVMName(scopeProp), newVal);
                    };
                    return observation;
                }
            }
        },
        viewModel: function (el, scope, vmName, bindingData, mustBeSettable, stickyCompute) {
            var setName = cleanVMName(vmName);
            var isBoundToContext = vmName === '.' || vmName === 'this';
            var keysToRead = isBoundToContext ? [] : observeReader.reads(vmName);
            var observation = new Observation(function () {
                var viewModel = bindingData.getViewModel();
                return observeReader.read(viewModel, keysToRead, {}).value;
            });
            observation[canSymbol.for('can.setValue')] = function (newVal) {
                var viewModel = bindingData.getViewModel();
                if (arguments.length) {
                    if (stickyCompute) {
                        var oldValue = canReflect.getKeyValue(viewModel, setName);
                        if (canReflect.isObservableLike(oldValue)) {
                            canReflect.setValue(oldValue, newVal);
                        } else {
                            canReflect.setKeyValue(viewModel, setName, reflectiveValue(canReflect.getValue(stickyCompute)));
                        }
                    } else {
                        if (isBoundToContext) {
                            canReflect.setValue(viewModel, newVal);
                        } else {
                            canReflect.setKeyValue(viewModel, setName, newVal);
                        }
                    }
                }
            };
            return observation;
        },
        attribute: function (el, scope, prop, bindingData, mustBeSettable, stickyCompute, event) {
            if (!event) {
                event = 'change';
                var isRadioInput = el.nodeName === 'INPUT' && el.type === 'radio';
                var isValidProp = prop === 'checked' && !bindingData.legacyBindings;
                if (isRadioInput && isValidProp) {
                    event = 'radiochange';
                }
                var isSpecialProp = attr.special[prop] && attr.special[prop].addEventListener;
                if (isSpecialProp) {
                    event = prop;
                }
            }
            var hasChildren = el.nodeName.toLowerCase() === 'select', isMultiselectValue = prop === 'value' && hasChildren && el.multiple, set = function (newVal) {
                    if (bindingData.legacyBindings && hasChildren && 'selectedIndex' in el && prop === 'value') {
                        attr.setAttrOrProp(el, prop, newVal == null ? '' : newVal);
                    } else {
                        attr.setAttrOrProp(el, prop, newVal);
                    }
                    return newVal;
                }, get = function () {
                    return attr.get(el, prop);
                };
            if (isMultiselectValue) {
                prop = 'values';
            }
            var observation = new Observation(get);
            observation[canSymbol.for('can.setValue')] = set;
            observation[canSymbol.for('can.getValue')] = get;
            observation[canSymbol.for('can.onValue')] = function (updater) {
                var translationHandler = function () {
                    updater(get());
                };
                singleReference.set(updater, this, translationHandler);
                if (event === 'radiochange') {
                    canEvent.on.call(el, 'change', translationHandler);
                }
                canEvent.on.call(el, event, translationHandler);
            };
            observation[canSymbol.for('can.offValue')] = function (updater) {
                var translationHandler = singleReference.getAndDelete(updater, this);
                if (event === 'radiochange') {
                    canEvent.off.call(el, 'change', translationHandler);
                }
                canEvent.off.call(el, event, translationHandler);
            };
            return observation;
        }
    };
    var bind = {
        childToParent: function (el, parentObservable, childObservable, bindingsSemaphore, attrName, syncChild) {
            var updateParent = function (newVal) {
                if (!bindingsSemaphore[attrName]) {
                    if (parentObservable && parentObservable[canSymbol.for('can.getValue')]) {
                        if (canReflect.getValue(parentObservable) !== newVal) {
                            canReflect.setValue(parentObservable, newVal);
                        }
                        if (syncChild) {
                            if (canReflect.getValue(parentObservable) !== canReflect.getValue(childObservable)) {
                                bindingsSemaphore[attrName] = (bindingsSemaphore[attrName] || 0) + 1;
                                canReflect.setValue(childObservable, canReflect.getValue(parentObservable));
                                Observation.afterUpdateAndNotify(function () {
                                    --bindingsSemaphore[attrName];
                                });
                            }
                        }
                    } else if (canReflect.isMapLike(parentObservable)) {
                        var attrValue = el.getAttribute(attrName);
                        dev.warn('can-stache-bindings: Merging ' + attrName + ' into ' + attrValue + ' because its parent is non-observable');
                        canReflect.eachKey(parentObservable, function (prop) {
                            canReflect.deleteKeyValue(parentObservable, prop);
                        });
                        canReflect.setValue(parentObservable, newVal && newVal.serialize ? newVal.serialize() : newVal, true);
                    }
                }
            };
            if (childObservable && childObservable[canSymbol.for('can.getValue')]) {
                canReflect.onValue(childObservable, updateParent);
            }
            return updateParent;
        },
        parentToChild: function (el, parentObservable, childUpdate, bindingsSemaphore, attrName) {
            var updateChild = function (newValue) {
                bindingsSemaphore[attrName] = (bindingsSemaphore[attrName] || 0) + 1;
                canReflect.setValue(childUpdate, newValue);
                Observation.afterUpdateAndNotify(function () {
                    --bindingsSemaphore[attrName];
                });
            };
            if (parentObservable && parentObservable[canSymbol.for('can.getValue')]) {
                canReflect.onValue(parentObservable, updateChild);
            }
            return updateChild;
        }
    };
    var bindingsRegExp = /\{(\()?(\^)?([^\}\)]+)\)?\}/, ignoreAttributesRegExp = /^(data-view-id|class|name|id|\[[\w\.-]+\]|#[\w\.-])$/i, DOUBLE_CURLY_BRACE_REGEX = /\{\{/g, encodedSpacesRegExp = /\\s/g, encodedForwardSlashRegExp = /\\f/g;
    var getBindingInfo = function (node, attributeViewModelBindings, templateType, tagName) {
        var bindingInfo, attributeName = node.name, attributeValue = node.value || '';
        var matches = attributeName.match(bindingsRegExp);
        if (!matches) {
            var ignoreAttribute = ignoreAttributesRegExp.test(attributeName);
            var vmName = string.camelize(attributeName);
            if (ignoreAttribute || viewCallbacks.attr(attributeName)) {
                return;
            }
            var syntaxRight = attributeValue[0] === '{' && last(attributeValue) === '}';
            var isAttributeToChild = templateType === 'legacy' ? attributeViewModelBindings[vmName] : !syntaxRight;
            var scopeName = syntaxRight ? attributeValue.substr(1, attributeValue.length - 2) : attributeValue;
            if (isAttributeToChild) {
                return {
                    bindingAttributeName: attributeName,
                    parent: 'attribute',
                    parentName: attributeName,
                    child: 'viewModel',
                    childName: vmName,
                    parentToChild: true,
                    childToParent: true,
                    syncChildWithParent: true
                };
            } else {
                return {
                    bindingAttributeName: attributeName,
                    parent: 'scope',
                    parentName: scopeName,
                    child: 'viewModel',
                    childName: vmName,
                    parentToChild: true,
                    childToParent: true,
                    syncChildWithParent: true
                };
            }
        }
        var twoWay = !!matches[1], childToParent = twoWay || !!matches[2], parentToChild = twoWay || !childToParent;
        var childName = matches[3];
        var isDOM = childName.charAt(0) === '$';
        if (isDOM) {
            bindingInfo = {
                parent: 'scope',
                child: 'attribute',
                childToParent: childToParent,
                parentToChild: parentToChild,
                bindingAttributeName: attributeName,
                childName: childName.substr(1),
                parentName: attributeValue,
                initializeValues: true,
                syncChildWithParent: twoWay
            };
            if (tagName === 'select') {
                bindingInfo.stickyParentToChild = true;
            }
            return bindingInfo;
        } else {
            bindingInfo = {
                parent: 'scope',
                child: 'viewModel',
                childToParent: childToParent,
                parentToChild: parentToChild,
                bindingAttributeName: attributeName,
                childName: decodeAttrName(string.camelize(childName)),
                parentName: attributeValue,
                initializeValues: true,
                syncChildWithParent: twoWay
            };
            if (attributeValue.trim().charAt(0) === '~') {
                bindingInfo.stickyParentToChild = true;
            }
            return bindingInfo;
        }
    };
    var decodeAttrName = function (name) {
        return name.replace(encodedSpacesRegExp, ' ').replace(encodedForwardSlashRegExp, '/');
    };
    var makeDataBinding = function (node, el, bindingData) {
        var bindingInfo = getBindingInfo(node, bindingData.attributeViewModelBindings, bindingData.templateType, el.nodeName.toLowerCase());
        if (!bindingInfo) {
            return;
        }
        bindingInfo.alreadyUpdatedChild = bindingData.alreadyUpdatedChild;
        if (bindingData.initializeValues) {
            bindingInfo.initializeValues = true;
        }
        var parentObservable = getObservableFrom[bindingInfo.parent](el, bindingData.scope, bindingInfo.parentName, bindingData, bindingInfo.parentToChild), childObservable = getObservableFrom[bindingInfo.child](el, bindingData.scope, bindingInfo.childName, bindingData, bindingInfo.childToParent, bindingInfo.stickyParentToChild && parentObservable), updateParent, updateChild;
        if (bindingData.nodeList) {
            if (parentObservable) {
                setPriority(parentObservable, bindingData.nodeList.nesting + 1);
            }
            if (childObservable) {
                setPriority(childObservable, bindingData.nodeList.nesting + 1);
            }
        }
        if (bindingInfo.parentToChild) {
            updateChild = bind.parentToChild(el, parentObservable, childObservable, bindingData.semaphore, bindingInfo.bindingAttributeName);
        }
        var completeBinding = function () {
            if (bindingInfo.childToParent) {
                updateParent = bind.childToParent(el, parentObservable, childObservable, bindingData.semaphore, bindingInfo.bindingAttributeName, bindingInfo.syncChildWithParent);
            } else if (bindingInfo.stickyParentToChild && childObservable[canSymbol.for('can.onValue')]) {
                canReflect.onValue(childObservable, noop);
            }
            if (bindingInfo.initializeValues) {
                initializeValues(bindingInfo, childObservable, parentObservable, updateChild, updateParent);
            }
        };
        var onTeardown = function () {
            unbindUpdate(parentObservable, updateChild);
            unbindUpdate(childObservable, updateParent);
            unbindUpdate(childObservable, noop);
        };
        if (bindingInfo.child === 'viewModel') {
            return {
                value: bindingInfo.stickyParentToChild ? reflectiveValue(getValue(parentObservable)) : getValue(parentObservable),
                onCompleteBinding: completeBinding,
                bindingInfo: bindingInfo,
                onTeardown: onTeardown
            };
        } else {
            completeBinding();
            return {
                bindingInfo: bindingInfo,
                onTeardown: onTeardown
            };
        }
    };
    var initializeValues = function (bindingInfo, childObservable, parentObservable, updateChild, updateParent) {
        var doUpdateParent = false;
        if (bindingInfo.parentToChild && !bindingInfo.childToParent) {
        } else if (!bindingInfo.parentToChild && bindingInfo.childToParent) {
            doUpdateParent = true;
        } else if (getValue(childObservable) === undefined) {
        } else if (getValue(parentObservable) === undefined) {
            doUpdateParent = true;
        }
        if (doUpdateParent) {
            updateParent(getValue(childObservable));
        } else {
            if (!bindingInfo.alreadyUpdatedChild) {
                updateChild(getValue(parentObservable));
            }
        }
    };
    if (!getMutationObserver()) {
        var updateSelectValue = function (el) {
            var bindingCallback = domData.get.call(el, 'canBindingCallback');
            if (bindingCallback) {
                bindingCallback.onMutation(el);
            }
        };
        live.registerChildMutationCallback('select', updateSelectValue);
        live.registerChildMutationCallback('optgroup', function (el) {
            updateSelectValue(el.parentNode);
        });
    }
    var isContentEditable = function () {
            var values = {
                '': true,
                'true': true,
                'false': false
            };
            var editable = function (el) {
                if (!el || !el.getAttribute) {
                    return;
                }
                var attr = el.getAttribute('contenteditable');
                return values[attr];
            };
            return function (el) {
                var val = editable(el);
                if (typeof val === 'boolean') {
                    return val;
                } else {
                    return !!editable(el.parentNode);
                }
            };
        }(), removeBrackets = function (value, open, close) {
            open = open || '{';
            close = close || '}';
            if (value[0] === open && value[value.length - 1] === close) {
                return value.substr(1, value.length - 2);
            }
            return value;
        }, getValue = function (value) {
            return value && value[canSymbol.for('can.getValue')] ? canReflect.getValue(value) : value;
        }, unbindUpdate = function (observable, updater) {
            if (observable && observable[canSymbol.for('can.getValue')] && typeof updater === 'function') {
                canReflect.offValue(observable, updater);
            }
        }, cleanVMName = function (name) {
            return name.replace(/@/g, '');
        };
    module.exports = {
        behaviors: behaviors,
        getBindingInfo: getBindingInfo
    };
});
/*can-component@3.3.0#can-component*/
define('can-component@3.3.0#can-component', function (require, exports, module) {
    var ComponentControl = require('./control/control');
    var namespace = require('can-namespace');
    var Construct = require('can-construct');
    var stacheBindings = require('can-stache-bindings');
    var Scope = require('can-view-scope');
    var viewCallbacks = require('can-view-callbacks');
    var nodeLists = require('can-view-nodelist');
    var compute = require('can-compute');
    var domData = require('can-util/dom/data/data');
    var domMutate = require('can-util/dom/mutate/mutate');
    var getChildNodes = require('can-util/dom/child-nodes/child-nodes');
    var domDispatch = require('can-util/dom/dispatch/dispatch');
    var types = require('can-types');
    var string = require('can-util/js/string/string');
    var canReflect = require('can-reflect');
    var canEach = require('can-util/js/each/each');
    var assign = require('can-util/js/assign/assign');
    var isFunction = require('can-util/js/is-function/is-function');
    var canLog = require('can-util/js/log/log');
    var makeArray = require('can-util/js/make-array/make-array');
    var isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');
    require('can-util/dom/events/inserted/inserted');
    require('can-util/dom/events/removed/removed');
    require('can-view-model');
    function addContext(el, tagData, insertionElementTagData) {
        var vm;
        domData.set.call(el, 'preventDataBindings', true);
        var teardown = stacheBindings.behaviors.viewModel(el, insertionElementTagData, function (initialData) {
            return vm = compute(initialData);
        }, undefined, true);
        if (!teardown) {
            return tagData;
        } else {
            return assign(assign({}, tagData), {
                teardown: teardown,
                scope: tagData.scope.add(vm)
            });
        }
    }
    function makeInsertionTagCallback(tagName, componentTagData, shadowTagData, leakScope, getPrimaryTemplate) {
        var options = shadowTagData.options._context;
        return function hookupFunction(el, insertionElementTagData) {
            var template = getPrimaryTemplate(el) || insertionElementTagData.subtemplate, renderingLightContent = template !== insertionElementTagData.subtemplate;
            if (template) {
                delete options.tags[tagName];
                var tagData;
                if (renderingLightContent) {
                    if (leakScope.toLightContent) {
                        tagData = addContext(el, {
                            scope: insertionElementTagData.scope.cloneFromRef(),
                            options: insertionElementTagData.options
                        }, insertionElementTagData);
                    } else {
                        tagData = addContext(el, componentTagData, insertionElementTagData);
                    }
                } else {
                    tagData = addContext(el, insertionElementTagData, insertionElementTagData);
                }
                var nodeList = nodeLists.register([el], function () {
                    if (tagData.teardown) {
                        tagData.teardown();
                    }
                }, insertionElementTagData.parentNodeList || true, false);
                nodeList.expression = '<can-slot name=\'' + el.getAttribute('name') + '\'/>';
                var frag = template(tagData.scope, tagData.options, nodeList);
                var newNodes = makeArray(getChildNodes(frag));
                nodeLists.replace(nodeList, frag);
                nodeLists.update(nodeList, newNodes);
                options.tags[tagName] = hookupFunction;
            }
        };
    }
    var Component = Construct.extend({
        setup: function () {
            Construct.setup.apply(this, arguments);
            if (Component) {
                var self = this;
                if (!isEmptyObject(this.prototype.events)) {
                    this.Control = ComponentControl.extend(this.prototype.events);
                }
                var protoViewModel = this.prototype.viewModel || this.prototype.scope;
                if (protoViewModel && this.prototype.ViewModel) {
                    throw new Error('Cannot provide both a ViewModel and a viewModel property');
                }
                var vmName = string.capitalize(string.camelize(this.prototype.tag)) + 'VM';
                if (this.prototype.ViewModel) {
                    if (typeof this.prototype.ViewModel === 'function') {
                        this.ViewModel = this.prototype.ViewModel;
                    } else {
                        this.ViewModel = types.DefaultMap.extend(vmName, this.prototype.ViewModel);
                    }
                } else {
                    if (protoViewModel) {
                        if (typeof protoViewModel === 'function') {
                            if (canReflect.isObservableLike(protoViewModel.prototype) && canReflect.isMapLike(protoViewModel.prototype)) {
                                this.ViewModel = protoViewModel;
                            } else {
                                this.viewModelHandler = protoViewModel;
                            }
                        } else {
                            if (canReflect.isObservableLike(protoViewModel) && canReflect.isMapLike(protoViewModel)) {
                                this.viewModelInstance = protoViewModel;
                            } else {
                                this.ViewModel = types.DefaultMap.extend(vmName, protoViewModel);
                            }
                        }
                    } else {
                        this.ViewModel = types.DefaultMap.extend(vmName, {});
                    }
                }
                if (this.prototype.template) {
                    this.renderer = this.prototype.template;
                }
                if (this.prototype.view) {
                    this.renderer = this.prototype.view;
                }
                viewCallbacks.tag(this.prototype.tag, function (el, options) {
                    new self(el, options);
                });
            }
        }
    }, {
        setup: function (el, componentTagData) {
            var component = this;
            var teardownFunctions = [];
            var initialViewModelData = {};
            var callTeardownFunctions = function () {
                for (var i = 0, len = teardownFunctions.length; i < len; i++) {
                    teardownFunctions[i]();
                }
            };
            var setupBindings = !domData.get.call(el, 'preventDataBindings');
            var viewModel, frag;
            var teardownBindings;
            if (setupBindings) {
                var setupFn = componentTagData.setupBindings || function (el, callback, data) {
                    return stacheBindings.behaviors.viewModel(el, componentTagData, callback, data);
                };
                teardownBindings = setupFn(el, function (initialViewModelData) {
                    var ViewModel = component.constructor.ViewModel, viewModelHandler = component.constructor.viewModelHandler, viewModelInstance = component.constructor.viewModelInstance;
                    if (viewModelHandler) {
                        var scopeResult = viewModelHandler.call(component, initialViewModelData, componentTagData.scope, el);
                        if (canReflect.isObservableLike(scopeResult) && canReflect.isMapLike(scopeResult)) {
                            viewModelInstance = scopeResult;
                        } else if (canReflect.isObservableLike(scopeResult.prototype) && canReflect.isMapLike(scopeResult.prototype)) {
                            ViewModel = scopeResult;
                        } else {
                            ViewModel = types.DefaultMap.extend(scopeResult);
                        }
                    }
                    if (ViewModel) {
                        viewModelInstance = new component.constructor.ViewModel(initialViewModelData);
                    }
                    viewModel = viewModelInstance;
                    return viewModelInstance;
                }, initialViewModelData);
            }
            this.viewModel = viewModel;
            domData.set.call(el, 'viewModel', viewModel);
            domData.set.call(el, 'preventDataBindings', true);
            var options = {
                helpers: {},
                tags: {}
            };
            canEach(this.helpers || {}, function (val, prop) {
                if (isFunction(val)) {
                    options.helpers[prop] = val.bind(viewModel);
                }
            });
            var optionsScopeWithHelpers = componentTagData.options.add(options);
            if (this.constructor.Control) {
                this._control = new this.constructor.Control(el, {
                    scope: this.viewModel,
                    viewModel: this.viewModel,
                    destroy: callTeardownFunctions
                });
            }
            var leakScope = {
                toLightContent: this.leakScope === true,
                intoShadowContent: this.leakScope === true
            };
            var hasShadowTemplate = !!this.constructor.renderer;
            var betweenTagsRenderer;
            var betweenTagsTagData;
            if (hasShadowTemplate) {
                var shadowTagData;
                if (leakScope.intoShadowContent) {
                    shadowTagData = {
                        scope: componentTagData.scope.add(new Scope.Refs()).add(this.viewModel, { viewModel: true }),
                        options: optionsScopeWithHelpers
                    };
                } else {
                    shadowTagData = {
                        scope: Scope.refsScope().add(this.viewModel, { viewModel: true }),
                        options: optionsScopeWithHelpers
                    };
                }
                options.tags['can-slot'] = makeInsertionTagCallback('can-slot', componentTagData, shadowTagData, leakScope, function (el) {
                    return componentTagData.templates[el.getAttribute('name')];
                });
                options.tags.content = makeInsertionTagCallback('content', componentTagData, shadowTagData, leakScope, function () {
                    return componentTagData.subtemplate;
                });
                betweenTagsRenderer = this.constructor.renderer;
                betweenTagsTagData = shadowTagData;
            } else {
                var lightTemplateTagData = {
                    scope: componentTagData.scope.add(this.viewModel, { viewModel: true }),
                    options: optionsScopeWithHelpers
                };
                betweenTagsTagData = lightTemplateTagData;
                betweenTagsRenderer = componentTagData.subtemplate || el.ownerDocument.createDocumentFragment.bind(el.ownerDocument);
            }
            var nodeList = nodeLists.register([], function () {
                domDispatch.call(el, 'beforeremove', [], false);
                if (teardownBindings) {
                    teardownBindings();
                }
            }, componentTagData.parentNodeList || true, false);
            nodeList.expression = '<' + this.tag + '>';
            teardownFunctions.push(function () {
                nodeLists.unregister(nodeList);
            });
            frag = betweenTagsRenderer(betweenTagsTagData.scope, betweenTagsTagData.options, nodeList);
            domMutate.appendChild.call(el, frag);
            nodeLists.update(nodeList, getChildNodes(el));
        }
    });
    module.exports = namespace.Component = Component;
});
/*can-view-target@3.1.0#can-view-target*/
define('can-view-target@3.1.0#can-view-target', function (require, exports, module) {
    var childNodes = require('can-util/dom/child-nodes/child-nodes');
    var domAttr = require('can-util/dom/attr/attr');
    var each = require('can-util/js/each/each');
    var makeArray = require('can-util/js/make-array/make-array');
    var getDocument = require('can-util/dom/document/document');
    var domMutate = require('can-util/dom/mutate/mutate');
    var namespace = require('can-namespace');
    var MUTATION_OBSERVER = require('can-util/dom/mutation-observer/mutation-observer');
    var processNodes = function (nodes, paths, location, document) {
            var frag = document.createDocumentFragment();
            for (var i = 0, len = nodes.length; i < len; i++) {
                var node = nodes[i];
                frag.appendChild(processNode(node, paths, location.concat(i), document));
            }
            return frag;
        }, keepsTextNodes = typeof document !== 'undefined' && function () {
            var testFrag = document.createDocumentFragment();
            var div = document.createElement('div');
            div.appendChild(document.createTextNode(''));
            div.appendChild(document.createTextNode(''));
            testFrag.appendChild(div);
            var cloned = testFrag.cloneNode(true);
            return childNodes(cloned.firstChild).length === 2;
        }(), clonesWork = typeof document !== 'undefined' && function () {
            var el = document.createElement('a');
            el.innerHTML = '<xyz></xyz>';
            var clone = el.cloneNode(true);
            var works = clone.innerHTML === '<xyz></xyz>';
            var MO, observer;
            if (works) {
                el = document.createDocumentFragment();
                el.appendChild(document.createTextNode('foo-bar'));
                MO = MUTATION_OBSERVER();
                if (MO) {
                    observer = new MO(function () {
                    });
                    observer.observe(document.documentElement, {
                        childList: true,
                        subtree: true
                    });
                    clone = el.cloneNode(true);
                    observer.disconnect();
                } else {
                    clone = el.cloneNode(true);
                }
                return clone.childNodes.length === 1;
            }
            return works;
        }(), namespacesWork = typeof document !== 'undefined' && !!document.createElementNS;
    var cloneNode = clonesWork ? function (el) {
        return el.cloneNode(true);
    } : function (node) {
        var document = node.ownerDocument;
        var copy;
        if (node.nodeType === 1) {
            copy = document.createElement(node.nodeName);
        } else if (node.nodeType === 3) {
            copy = document.createTextNode(node.nodeValue);
        } else if (node.nodeType === 8) {
            copy = document.createComment(node.nodeValue);
        } else if (node.nodeType === 11) {
            copy = document.createDocumentFragment();
        }
        if (node.attributes) {
            var attributes = makeArray(node.attributes);
            each(attributes, function (node) {
                if (node && node.specified) {
                    domAttr.setAttribute(copy, node.nodeName || node.name, node.nodeValue || node.value);
                }
            });
        }
        if (node && node.firstChild) {
            var child = node.firstChild;
            while (child) {
                copy.appendChild(cloneNode(child));
                child = child.nextSibling;
            }
        }
        return copy;
    };
    function processNode(node, paths, location, document) {
        var callback, loc = location, nodeType = typeof node, el, p, i, len;
        var getCallback = function () {
            if (!callback) {
                callback = {
                    path: location,
                    callbacks: []
                };
                paths.push(callback);
                loc = [];
            }
            return callback;
        };
        if (nodeType === 'object') {
            if (node.tag) {
                if (namespacesWork && node.namespace) {
                    el = document.createElementNS(node.namespace, node.tag);
                } else {
                    el = document.createElement(node.tag);
                }
                if (node.attrs) {
                    for (var attrName in node.attrs) {
                        var value = node.attrs[attrName];
                        if (typeof value === 'function') {
                            getCallback().callbacks.push({ callback: value });
                        } else {
                            domAttr.setAttribute(el, attrName, value);
                        }
                    }
                }
                if (node.attributes) {
                    for (i = 0, len = node.attributes.length; i < len; i++) {
                        getCallback().callbacks.push({ callback: node.attributes[i] });
                    }
                }
                if (node.children && node.children.length) {
                    if (callback) {
                        p = callback.paths = [];
                    } else {
                        p = paths;
                    }
                    el.appendChild(processNodes(node.children, p, loc, document));
                }
            } else if (node.comment) {
                el = document.createComment(node.comment);
                if (node.callbacks) {
                    for (i = 0, len = node.attributes.length; i < len; i++) {
                        getCallback().callbacks.push({ callback: node.callbacks[i] });
                    }
                }
            }
        } else if (nodeType === 'string') {
            el = document.createTextNode(node);
        } else if (nodeType === 'function') {
            if (keepsTextNodes) {
                el = document.createTextNode('');
                getCallback().callbacks.push({ callback: node });
            } else {
                el = document.createComment('~');
                getCallback().callbacks.push({
                    callback: function () {
                        var el = document.createTextNode('');
                        domMutate.replaceChild.call(this.parentNode, el, this);
                        return node.apply(el, arguments);
                    }
                });
            }
        }
        return el;
    }
    function getCallbacks(el, pathData, elementCallbacks) {
        var path = pathData.path, callbacks = pathData.callbacks, paths = pathData.paths, child = el, pathLength = path ? path.length : 0, pathsLength = paths ? paths.length : 0;
        for (var i = 0; i < pathLength; i++) {
            child = child.childNodes.item(path[i]);
        }
        for (i = 0; i < pathsLength; i++) {
            getCallbacks(child, paths[i], elementCallbacks);
        }
        elementCallbacks.push({
            element: child,
            callbacks: callbacks
        });
    }
    function hydrateCallbacks(callbacks, args) {
        var len = callbacks.length, callbacksLength, callbackElement, callbackData;
        for (var i = 0; i < len; i++) {
            callbackData = callbacks[i];
            callbacksLength = callbackData.callbacks.length;
            callbackElement = callbackData.element;
            for (var c = 0; c < callbacksLength; c++) {
                callbackData.callbacks[c].callback.apply(callbackElement, args);
            }
        }
    }
    function makeTarget(nodes, doc) {
        var paths = [];
        var frag = processNodes(nodes, paths, [], doc || getDocument());
        return {
            paths: paths,
            clone: frag,
            hydrate: function () {
                var cloned = cloneNode(this.clone);
                var args = makeArray(arguments);
                var callbacks = [];
                for (var i = 0; i < paths.length; i++) {
                    getCallbacks(cloned, paths[i], callbacks);
                }
                hydrateCallbacks(callbacks, args);
                return cloned;
            }
        };
    }
    makeTarget.keepsTextNodes = keepsTextNodes;
    makeTarget.cloneNode = cloneNode;
    namespace.view = namespace.view || {};
    module.exports = namespace.view.target = makeTarget;
});
/*can-stache@3.2.0#src/mustache_core*/
define('can-stache@3.2.0#src/mustache_core', function (require, exports, module) {
    var live = require('can-view-live');
    var nodeLists = require('can-view-nodelist');
    var compute = require('can-compute');
    var Observation = require('can-observation');
    var utils = require('./utils');
    var expression = require('./expression');
    var frag = require('can-util/dom/frag/frag');
    var attr = require('can-util/dom/attr/attr');
    var canSymbol = require('can-symbol');
    var canReflect = require('can-reflect');
    var mustacheLineBreakRegExp = /(?:(?:^|(\r?)\n)(\s*)(\{\{([^\}]*)\}\}\}?)([^\S\n\r]*)($|\r?\n))|(\{\{([^\}]*)\}\}\}?)/g, k = function () {
        };
    var core = {
        expression: expression,
        makeEvaluator: function (scope, helperOptions, nodeList, mode, exprData, truthyRenderer, falseyRenderer, stringOnly) {
            if (mode === '^') {
                var temp = truthyRenderer;
                truthyRenderer = falseyRenderer;
                falseyRenderer = temp;
            }
            var value, helperOptionArg;
            if (exprData instanceof expression.Call) {
                helperOptionArg = {
                    fn: function () {
                    },
                    inverse: function () {
                    },
                    context: scope.peek('.'),
                    scope: scope,
                    nodeList: nodeList,
                    exprData: exprData,
                    helpersScope: helperOptions
                };
                utils.convertToScopes(helperOptionArg, scope, helperOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly);
                value = exprData.value(scope, helperOptions, helperOptionArg);
                if (exprData.isHelper) {
                    return value;
                }
            } else if (exprData instanceof expression.Bracket) {
                value = exprData.value(scope);
                if (exprData.isHelper) {
                    return value;
                }
            } else if (exprData instanceof expression.Lookup) {
                value = exprData.value(scope);
                if (exprData.isHelper) {
                    return value;
                }
            } else if (exprData instanceof expression.Helper && exprData.methodExpr instanceof expression.Bracket) {
                value = exprData.methodExpr.value(scope);
                if (exprData.isHelper) {
                    return value;
                }
            } else {
                var readOptions = {
                    isArgument: true,
                    args: [
                        scope.peek('.'),
                        scope
                    ],
                    asCompute: true
                };
                var helperAndValue = exprData.helperAndValue(scope, helperOptions, readOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly);
                var helper = helperAndValue.helper;
                value = helperAndValue.value;
                if (helper) {
                    return exprData.evaluator(helper, scope, helperOptions, readOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly);
                }
            }
            if (!mode) {
                return value;
            } else if (mode === '#' || mode === '^') {
                helperOptionArg = {
                    fn: function () {
                    },
                    inverse: function () {
                    }
                };
                utils.convertToScopes(helperOptionArg, scope, helperOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly);
                return function () {
                    var finalValue = canReflect.getValue(value);
                    if (typeof finalValue === 'function') {
                        return finalValue;
                    } else if (typeof finalValue !== 'string' && utils.isArrayLike(finalValue)) {
                        var isObserveList = canReflect.isObservableLike(finalValue) && canReflect.isListLike(finalValue);
                        if (isObserveList ? finalValue.attr('length') : finalValue.length) {
                            if (stringOnly) {
                                return utils.getItemsStringContent(finalValue, isObserveList, helperOptionArg, helperOptions);
                            } else {
                                return frag(utils.getItemsFragContent(finalValue, helperOptionArg, scope));
                            }
                        } else {
                            return helperOptionArg.inverse(scope, helperOptions);
                        }
                    } else {
                        return finalValue ? helperOptionArg.fn(finalValue || scope, helperOptions) : helperOptionArg.inverse(scope, helperOptions);
                    }
                };
            } else {
            }
        },
        makeLiveBindingPartialRenderer: function (expressionString, state) {
            expressionString = expressionString.trim();
            var exprData, partialName = expressionString.split(/\s+/).shift();
            if (partialName !== expressionString) {
                exprData = core.expression.parse(expressionString);
            }
            return function (scope, options, parentSectionNodeList) {
                var nodeList = [this];
                nodeList.expression = '>' + partialName;
                nodeLists.register(nodeList, null, parentSectionNodeList || true, state.directlyNested);
                var partialFrag = compute(function () {
                    var localPartialName = partialName;
                    if (exprData && exprData.argExprs.length === 1) {
                        var newContext = canReflect.getValue(exprData.argExprs[0].value(scope, options));
                        if (typeof newContext === 'undefined') {
                        } else {
                            scope = scope.add(newContext);
                        }
                    }
                    var partial = options.peek('partials.' + localPartialName), renderer;
                    if (partial) {
                        renderer = function () {
                            return partial.render ? partial.render(scope, options, nodeList) : partial(scope, options);
                        };
                    } else {
                        var scopePartialName = scope.read(localPartialName, { isArgument: true }).value;
                        if (scopePartialName === null || !scopePartialName && localPartialName[0] === '*') {
                            return frag('');
                        }
                        if (scopePartialName) {
                            localPartialName = scopePartialName;
                        }
                        renderer = function () {
                            if (typeof localPartialName === 'function') {
                                return localPartialName(scope, options, nodeList);
                            } else {
                                return core.getTemplateById(localPartialName)(scope, options, nodeList);
                            }
                        };
                    }
                    var res = Observation.ignore(renderer)();
                    return frag(res);
                });
                partialFrag.computeInstance.setPrimaryDepth(nodeList.nesting);
                live.html(this, partialFrag, this.parentNode, nodeList);
            };
        },
        makeStringBranchRenderer: function (mode, expressionString) {
            var exprData = core.expression.parse(expressionString), fullExpression = mode + expressionString;
            if (!(exprData instanceof expression.Helper) && !(exprData instanceof expression.Call)) {
                exprData = new expression.Helper(exprData, [], {});
            }
            var branchRenderer = function branchRenderer(scope, options, truthyRenderer, falseyRenderer) {
                var evaluator = scope.__cache[fullExpression];
                if (mode || !evaluator) {
                    evaluator = makeEvaluator(scope, options, null, mode, exprData, truthyRenderer, falseyRenderer, true);
                    if (!mode) {
                        scope.__cache[fullExpression] = evaluator;
                    }
                }
                var gotObservableValue = evaluator[canSymbol.for('can.onValue')], res;
                if (gotObservableValue) {
                    res = canReflect.getValue(evaluator);
                } else {
                    res = evaluator();
                }
                return res == null ? '' : '' + res;
            };
            branchRenderer.exprData = exprData;
            return branchRenderer;
        },
        makeLiveBindingBranchRenderer: function (mode, expressionString, state) {
            var exprData = core.expression.parse(expressionString);
            if (!(exprData instanceof expression.Helper) && !(exprData instanceof expression.Call) && !(exprData instanceof expression.Bracket) && !(exprData instanceof expression.Lookup)) {
                exprData = new expression.Helper(exprData, [], {});
            }
            var branchRenderer = function branchRenderer(scope, options, parentSectionNodeList, truthyRenderer, falseyRenderer) {
                var nodeList = [this];
                nodeList.expression = expressionString;
                nodeLists.register(nodeList, null, parentSectionNodeList || true, state.directlyNested);
                var evaluator = makeEvaluator(scope, options, nodeList, mode, exprData, truthyRenderer, falseyRenderer, state.tag);
                var gotObservableValue = evaluator[canSymbol.for('can.onValue')];
                var observable;
                if (gotObservableValue) {
                    observable = evaluator;
                } else {
                    observable = new Observation(evaluator, null, { isObservable: false });
                }
                if (observable instanceof Observation) {
                    observable.compute._primaryDepth = nodeList.nesting;
                } else if (observable.computeInstance) {
                    observable.computeInstance.setPrimaryDepth(nodeList.nesting);
                } else if (observable.observation) {
                    observable.observation.compute._primaryDepth = nodeList.nesting;
                }
                canReflect.onValue(observable, k);
                var value = canReflect.getValue(observable);
                if (typeof value === 'function') {
                    Observation.ignore(value)(this);
                } else if (canReflect.valueHasDependencies(observable)) {
                    if (state.attr) {
                        live.attr(this, state.attr, observable);
                    } else if (state.tag) {
                        live.attrs(this, observable);
                    } else if (state.text && typeof value !== 'object') {
                        live.text(this, observable, this.parentNode, nodeList);
                    } else {
                        live.html(this, observable, this.parentNode, nodeList);
                    }
                } else {
                    if (state.attr) {
                        attr.set(this, state.attr, value);
                    } else if (state.tag) {
                        live.attrs(this, value);
                    } else if (state.text && typeof value === 'string') {
                        this.nodeValue = value;
                    } else if (value != null) {
                        nodeLists.replace([this], frag(value, this.ownerDocument));
                    }
                }
                canReflect.offValue(observable, k);
            };
            branchRenderer.exprData = exprData;
            return branchRenderer;
        },
        splitModeFromExpression: function (expression, state) {
            expression = expression.trim();
            var mode = expression.charAt(0);
            if ('#/{&^>!'.indexOf(mode) >= 0) {
                expression = expression.substr(1).trim();
            } else {
                mode = null;
            }
            if (mode === '{' && state.node) {
                mode = null;
            }
            return {
                mode: mode,
                expression: expression
            };
        },
        cleanLineEndings: function (template) {
            return template.replace(mustacheLineBreakRegExp, function (whole, returnBefore, spaceBefore, special, expression, spaceAfter, returnAfter, spaceLessSpecial, spaceLessExpression, matchIndex) {
                spaceAfter = spaceAfter || '';
                returnBefore = returnBefore || '';
                spaceBefore = spaceBefore || '';
                var modeAndExpression = splitModeFromExpression(expression || spaceLessExpression, {});
                if (spaceLessSpecial || '>{'.indexOf(modeAndExpression.mode) >= 0) {
                    return whole;
                } else if ('^#!/'.indexOf(modeAndExpression.mode) >= 0) {
                    return special + (matchIndex !== 0 && returnAfter.length ? returnBefore + '\n' : '');
                } else {
                    return spaceBefore + special + spaceAfter + (spaceBefore.length || matchIndex !== 0 ? returnBefore + '\n' : '');
                }
            });
        },
        Options: utils.Options,
        getTemplateById: function () {
        }
    };
    var makeEvaluator = core.makeEvaluator, splitModeFromExpression = core.splitModeFromExpression;
    module.exports = core;
});
/*can-stache@3.2.0#src/html_section*/
define('can-stache@3.2.0#src/html_section', function (require, exports, module) {
    var target = require('can-view-target');
    var Scope = require('can-view-scope');
    var Observation = require('can-observation');
    var utils = require('./utils');
    var mustacheCore = require('./mustache_core');
    var getDocument = require('can-util/dom/document/document');
    var assign = require('can-util/js/assign/assign');
    var last = require('can-util/js/last/last');
    var decodeHTML = typeof document !== 'undefined' && function () {
        var el = getDocument().createElement('div');
        return function (html) {
            if (html.indexOf('&') === -1) {
                return html.replace(/\r\n/g, '\n');
            }
            el.innerHTML = html;
            return el.childNodes.length === 0 ? '' : el.childNodes.item(0).nodeValue;
        };
    }();
    var HTMLSectionBuilder = function () {
        this.stack = [new HTMLSection()];
    };
    assign(HTMLSectionBuilder.prototype, utils.mixins);
    assign(HTMLSectionBuilder.prototype, {
        startSubSection: function (process) {
            var newSection = new HTMLSection(process);
            this.stack.push(newSection);
            return newSection;
        },
        endSubSectionAndReturnRenderer: function () {
            if (this.last().isEmpty()) {
                this.stack.pop();
                return null;
            } else {
                var htmlSection = this.endSection();
                return htmlSection.compiled.hydrate.bind(htmlSection.compiled);
            }
        },
        startSection: function (process) {
            var newSection = new HTMLSection(process);
            this.last().add(newSection.targetCallback);
            this.stack.push(newSection);
        },
        endSection: function () {
            this.last().compile();
            return this.stack.pop();
        },
        inverse: function () {
            this.last().inverse();
        },
        compile: function () {
            var compiled = this.stack.pop().compile();
            return Observation.ignore(function (scope, options, nodeList) {
                if (!(scope instanceof Scope)) {
                    scope = Scope.refsScope().add(scope || {});
                }
                if (!(options instanceof mustacheCore.Options)) {
                    options = new mustacheCore.Options(options || {});
                }
                return compiled.hydrate(scope, options, nodeList);
            });
        },
        push: function (chars) {
            this.last().push(chars);
        },
        pop: function () {
            return this.last().pop();
        },
        removeCurrentNode: function () {
            this.last().removeCurrentNode();
        }
    });
    var HTMLSection = function (process) {
        this.data = 'targetData';
        this.targetData = [];
        this.targetStack = [];
        var self = this;
        this.targetCallback = function (scope, options, sectionNode) {
            process.call(this, scope, options, sectionNode, self.compiled.hydrate.bind(self.compiled), self.inverseCompiled && self.inverseCompiled.hydrate.bind(self.inverseCompiled));
        };
    };
    assign(HTMLSection.prototype, {
        inverse: function () {
            this.inverseData = [];
            this.data = 'inverseData';
        },
        push: function (data) {
            this.add(data);
            this.targetStack.push(data);
        },
        pop: function () {
            return this.targetStack.pop();
        },
        add: function (data) {
            if (typeof data === 'string') {
                data = decodeHTML(data);
            }
            if (this.targetStack.length) {
                last(this.targetStack).children.push(data);
            } else {
                this[this.data].push(data);
            }
        },
        compile: function () {
            this.compiled = target(this.targetData, getDocument());
            if (this.inverseData) {
                this.inverseCompiled = target(this.inverseData, getDocument());
                delete this.inverseData;
            }
            this.targetStack = this.targetData = null;
            return this.compiled;
        },
        removeCurrentNode: function () {
            var children = this.children();
            return children.pop();
        },
        children: function () {
            if (this.targetStack.length) {
                return last(this.targetStack).children;
            } else {
                return this[this.data];
            }
        },
        isEmpty: function () {
            return !this.targetData.length;
        }
    });
    HTMLSectionBuilder.HTMLSection = HTMLSection;
    module.exports = HTMLSectionBuilder;
});
/*can-stache@3.2.0#src/text_section*/
define('can-stache@3.2.0#src/text_section', function (require, exports, module) {
    var compute = require('can-compute');
    var live = require('can-view-live');
    var utils = require('./utils');
    var attr = require('can-util/dom/attr/attr');
    var assign = require('can-util/js/assign/assign');
    var canReflect = require('can-reflect');
    var Observation = require('can-observation');
    var noop = function () {
    };
    var TextSectionBuilder = function () {
        this.stack = [new TextSection()];
    };
    assign(TextSectionBuilder.prototype, utils.mixins);
    assign(TextSectionBuilder.prototype, {
        startSection: function (process) {
            var subSection = new TextSection();
            this.last().add({
                process: process,
                truthy: subSection
            });
            this.stack.push(subSection);
        },
        endSection: function () {
            this.stack.pop();
        },
        inverse: function () {
            this.stack.pop();
            var falseySection = new TextSection();
            this.last().last().falsey = falseySection;
            this.stack.push(falseySection);
        },
        compile: function (state) {
            var renderer = this.stack[0].compile();
            return function (scope, options) {
                var observation = new Observation(function () {
                    return renderer(scope, options);
                }, null, { isObservable: false });
                canReflect.onValue(observation, noop);
                var value = canReflect.getValue(observation);
                if (canReflect.valueHasDependencies(observation)) {
                    if (state.textContentOnly) {
                        live.text(this, observation);
                    } else if (state.attr) {
                        live.attr(this, state.attr, observation);
                    } else {
                        live.attrs(this, observation, scope, options);
                    }
                    canReflect.offValue(observation, noop);
                } else {
                    if (state.textContentOnly) {
                        this.nodeValue = value;
                    } else if (state.attr) {
                        attr.set(this, state.attr, value);
                    } else {
                        live.attrs(this, value);
                    }
                }
            };
        }
    });
    var passTruthyFalsey = function (process, truthy, falsey) {
        return function (scope, options) {
            return process.call(this, scope, options, truthy, falsey);
        };
    };
    var TextSection = function () {
        this.values = [];
    };
    assign(TextSection.prototype, {
        add: function (data) {
            this.values.push(data);
        },
        last: function () {
            return this.values[this.values.length - 1];
        },
        compile: function () {
            var values = this.values, len = values.length;
            for (var i = 0; i < len; i++) {
                var value = this.values[i];
                if (typeof value === 'object') {
                    values[i] = passTruthyFalsey(value.process, value.truthy && value.truthy.compile(), value.falsey && value.falsey.compile());
                }
            }
            return function (scope, options) {
                var txt = '', value;
                for (var i = 0; i < len; i++) {
                    value = values[i];
                    txt += typeof value === 'string' ? value : value.call(this, scope, options);
                }
                return txt;
            };
        }
    });
    module.exports = TextSectionBuilder;
});
/*can-stache@3.2.0#helpers/converter*/
define('can-stache@3.2.0#helpers/converter', function (require, exports, module) {
    var helpers = require('./core');
    var expression = require('../src/expression');
    var makeArray = require('can-util/js/make-array/make-array');
    helpers.registerConverter = function (name, getterSetter) {
        getterSetter = getterSetter || {};
        helpers.registerHelper(name, function (newVal, source) {
            var args = makeArray(arguments);
            if (newVal instanceof expression.SetIdentifier) {
                return typeof getterSetter.set === 'function' ? getterSetter.set.apply(this, [newVal.value].concat(args.slice(1))) : source(newVal.value);
            } else {
                return typeof getterSetter.get === 'function' ? getterSetter.get.apply(this, args) : args[0];
            }
        });
    };
    module.exports = helpers;
});
/*can-stache@3.2.0#src/intermediate_and_imports*/
define('can-stache@3.2.0#src/intermediate_and_imports', function (require, exports, module) {
    var mustacheCore = require('./mustache_core');
    var parser = require('can-view-parser');
    module.exports = function (source) {
        var template = mustacheCore.cleanLineEndings(source);
        var imports = [], dynamicImports = [], ases = {}, inImport = false, inFrom = false, inAs = false, isUnary = false, currentAs = '', currentFrom = '';
        var intermediate = parser(template, {
            start: function (tagName, unary) {
                isUnary = unary;
                if (tagName === 'can-import') {
                    inImport = true;
                } else if (inImport) {
                    inImport = false;
                }
            },
            attrStart: function (attrName) {
                if (attrName === 'from') {
                    inFrom = true;
                } else if (attrName === 'as' || attrName === 'export-as') {
                    inAs = true;
                }
            },
            attrEnd: function (attrName) {
                if (attrName === 'from') {
                    inFrom = false;
                } else if (attrName === 'as' || attrName === 'export-as') {
                    inAs = false;
                }
            },
            attrValue: function (value) {
                if (inFrom && inImport) {
                    imports.push(value);
                    if (!isUnary) {
                        dynamicImports.push(value);
                    }
                    currentFrom = value;
                } else if (inAs && inImport) {
                    currentAs = value;
                }
            },
            end: function (tagName) {
                if (tagName === 'can-import') {
                    if (currentAs) {
                        ases[currentAs] = currentFrom;
                        currentAs = '';
                    }
                }
            },
            close: function (tagName) {
                if (tagName === 'can-import') {
                    imports.pop();
                }
            }
        }, true);
        return {
            intermediate: intermediate,
            imports: imports,
            dynamicImports: dynamicImports,
            ases: ases,
            exports: ases
        };
    };
});
/*can-util@3.9.6#js/import/import*/
define('can-util@3.9.6#js/import/import', function (require, exports, module) {
    (function (global) {
        'use strict';
        var isFunction = require('../is-function/is-function');
        var global = require('../global/global')();
        module.exports = function (moduleName, parentName) {
            return new Promise(function (resolve, reject) {
                try {
                    if (typeof global.System === 'object' && isFunction(global.System['import'])) {
                        global.System['import'](moduleName, { name: parentName }).then(resolve, reject);
                    } else if (global.define && global.define.amd) {
                        global.require([moduleName], function (value) {
                            resolve(value);
                        });
                    } else if (global.require) {
                        resolve(global.require(moduleName));
                    } else {
                        resolve();
                    }
                } catch (err) {
                    reject(err);
                }
            });
        };
    }(function () {
        return this;
    }()));
});
/*can-stache@3.2.0#can-stache*/
define('can-stache@3.2.0#can-stache', function (require, exports, module) {
    var parser = require('can-view-parser');
    var viewCallbacks = require('can-view-callbacks');
    var HTMLSectionBuilder = require('./src/html_section');
    var TextSectionBuilder = require('./src/text_section');
    var mustacheCore = require('./src/mustache_core');
    var mustacheHelpers = require('./helpers/core');
    require('./helpers/converter');
    var getIntermediateAndImports = require('./src/intermediate_and_imports');
    var makeRendererConvertScopes = require('./src/utils').makeRendererConvertScopes;
    var dev = require('can-util/js/dev/dev');
    var namespace = require('can-namespace');
    var DOCUMENT = require('can-util/dom/document/document');
    var assign = require('can-util/js/assign/assign');
    var last = require('can-util/js/last/last');
    var importer = require('can-util/js/import/import');
    require('can-view-target');
    require('can-view-nodelist');
    viewCallbacks.tag('content', function (el, tagData) {
        return tagData.scope;
    });
    var svgNamespace = 'http://www.w3.org/2000/svg';
    var namespaces = {
            'svg': svgNamespace,
            'g': svgNamespace
        }, textContentOnlyTag = {
            style: true,
            script: true
        };
    function stache(template) {
        if (typeof template === 'string') {
            template = mustacheCore.cleanLineEndings(template);
        }
        var section = new HTMLSectionBuilder(), state = {
                node: null,
                attr: null,
                sectionElementStack: [],
                text: false,
                namespaceStack: [],
                textContentOnly: null
            }, makeRendererAndUpdateSection = function (section, mode, stache) {
                if (mode === '>') {
                    section.add(mustacheCore.makeLiveBindingPartialRenderer(stache, copyState()));
                } else if (mode === '/') {
                    section.endSection();
                    if (section instanceof HTMLSectionBuilder) {
                        state.sectionElementStack.pop();
                    }
                } else if (mode === 'else') {
                    section.inverse();
                } else {
                    var makeRenderer = section instanceof HTMLSectionBuilder ? mustacheCore.makeLiveBindingBranchRenderer : mustacheCore.makeStringBranchRenderer;
                    if (mode === '{' || mode === '&') {
                        section.add(makeRenderer(null, stache, copyState()));
                    } else if (mode === '#' || mode === '^') {
                        var renderer = makeRenderer(mode, stache, copyState());
                        section.startSection(renderer);
                        if (section instanceof HTMLSectionBuilder) {
                            state.sectionElementStack.push({ type: 'section' });
                        }
                    } else {
                        section.add(makeRenderer(null, stache, copyState({ text: true })));
                    }
                }
            }, copyState = function (overwrites) {
                var lastElement = state.sectionElementStack[state.sectionElementStack.length - 1];
                var cur = {
                    tag: state.node && state.node.tag,
                    attr: state.attr && state.attr.name,
                    directlyNested: state.sectionElementStack.length ? lastElement.type === 'section' || lastElement.type === 'custom' : true,
                    textContentOnly: !!state.textContentOnly
                };
                return overwrites ? assign(cur, overwrites) : cur;
            }, addAttributesCallback = function (node, callback) {
                if (!node.attributes) {
                    node.attributes = [];
                }
                node.attributes.unshift(callback);
            };
        parser(template, {
            start: function (tagName, unary) {
                var matchedNamespace = namespaces[tagName];
                if (matchedNamespace && !unary) {
                    state.namespaceStack.push(matchedNamespace);
                }
                state.node = {
                    tag: tagName,
                    children: [],
                    namespace: matchedNamespace || last(state.namespaceStack)
                };
            },
            end: function (tagName, unary) {
                var isCustomTag = viewCallbacks.tag(tagName);
                if (unary) {
                    section.add(state.node);
                    if (isCustomTag) {
                        addAttributesCallback(state.node, function (scope, options, parentNodeList) {
                            viewCallbacks.tagHandler(this, tagName, {
                                scope: scope,
                                options: options,
                                subtemplate: null,
                                templateType: 'stache',
                                parentNodeList: parentNodeList
                            });
                        });
                    }
                } else {
                    section.push(state.node);
                    state.sectionElementStack.push({
                        type: isCustomTag ? 'custom' : null,
                        tag: isCustomTag ? null : tagName,
                        templates: {}
                    });
                    if (isCustomTag) {
                        section.startSubSection();
                    } else if (textContentOnlyTag[tagName]) {
                        state.textContentOnly = new TextSectionBuilder();
                    }
                }
                state.node = null;
            },
            close: function (tagName) {
                var matchedNamespace = namespaces[tagName];
                if (matchedNamespace) {
                    state.namespaceStack.pop();
                }
                var isCustomTag = viewCallbacks.tag(tagName), renderer;
                if (isCustomTag) {
                    renderer = section.endSubSectionAndReturnRenderer();
                }
                if (textContentOnlyTag[tagName]) {
                    section.last().add(state.textContentOnly.compile(copyState()));
                    state.textContentOnly = null;
                }
                var oldNode = section.pop();
                if (isCustomTag) {
                    if (tagName === 'can-template') {
                        var parent = state.sectionElementStack[state.sectionElementStack.length - 2];
                        parent.templates[oldNode.attrs.name] = makeRendererConvertScopes(renderer);
                        section.removeCurrentNode();
                    } else {
                        var current = state.sectionElementStack[state.sectionElementStack.length - 1];
                        addAttributesCallback(oldNode, function (scope, options, parentNodeList) {
                            viewCallbacks.tagHandler(this, tagName, {
                                scope: scope,
                                options: options,
                                subtemplate: renderer,
                                templateType: 'stache',
                                parentNodeList: parentNodeList,
                                templates: current.templates
                            });
                        });
                    }
                }
                state.sectionElementStack.pop();
            },
            attrStart: function (attrName) {
                if (state.node.section) {
                    state.node.section.add(attrName + '="');
                } else {
                    state.attr = {
                        name: attrName,
                        value: ''
                    };
                }
            },
            attrEnd: function (attrName) {
                if (state.node.section) {
                    state.node.section.add('" ');
                } else {
                    if (!state.node.attrs) {
                        state.node.attrs = {};
                    }
                    state.node.attrs[state.attr.name] = state.attr.section ? state.attr.section.compile(copyState()) : state.attr.value;
                    var attrCallback = viewCallbacks.attr(attrName);
                    if (attrCallback) {
                        if (!state.node.attributes) {
                            state.node.attributes = [];
                        }
                        state.node.attributes.push(function (scope, options, nodeList) {
                            attrCallback(this, {
                                attributeName: attrName,
                                scope: scope,
                                options: options,
                                nodeList: nodeList
                            });
                        });
                    }
                    state.attr = null;
                }
            },
            attrValue: function (value) {
                var section = state.node.section || state.attr.section;
                if (section) {
                    section.add(value);
                } else {
                    state.attr.value += value;
                }
            },
            chars: function (text) {
                (state.textContentOnly || section).add(text);
            },
            special: function (text) {
                var firstAndText = mustacheCore.splitModeFromExpression(text, state), mode = firstAndText.mode, expression = firstAndText.expression;
                if (expression === 'else') {
                    var inverseSection;
                    if (state.attr && state.attr.section) {
                        inverseSection = state.attr.section;
                    } else if (state.node && state.node.section) {
                        inverseSection = state.node.section;
                    } else {
                        inverseSection = state.textContentOnly || section;
                    }
                    inverseSection.inverse();
                    return;
                }
                if (mode === '!') {
                    return;
                }
                if (state.node && state.node.section) {
                    makeRendererAndUpdateSection(state.node.section, mode, expression);
                    if (state.node.section.subSectionDepth() === 0) {
                        state.node.attributes.push(state.node.section.compile(copyState()));
                        delete state.node.section;
                    }
                } else if (state.attr) {
                    if (!state.attr.section) {
                        state.attr.section = new TextSectionBuilder();
                        if (state.attr.value) {
                            state.attr.section.add(state.attr.value);
                        }
                    }
                    makeRendererAndUpdateSection(state.attr.section, mode, expression);
                } else if (state.node) {
                    if (!state.node.attributes) {
                        state.node.attributes = [];
                    }
                    if (!mode) {
                        state.node.attributes.push(mustacheCore.makeLiveBindingBranchRenderer(null, expression, copyState()));
                    } else if (mode === '#' || mode === '^') {
                        if (!state.node.section) {
                            state.node.section = new TextSectionBuilder();
                        }
                        makeRendererAndUpdateSection(state.node.section, mode, expression);
                    } else {
                        throw new Error(mode + ' is currently not supported within a tag.');
                    }
                } else {
                    makeRendererAndUpdateSection(state.textContentOnly || section, mode, expression);
                }
            },
            comment: function (text) {
                section.add({ comment: text });
            },
            done: function () {
            }
        });
        return section.compile();
    }
    assign(stache, mustacheHelpers);
    stache.safeString = function (text) {
        return {
            toString: function () {
                return text;
            }
        };
    };
    stache.async = function (source) {
        var iAi = getIntermediateAndImports(source);
        var importPromises = iAi.imports.map(function (moduleName) {
            return importer(moduleName);
        });
        return Promise.all(importPromises).then(function () {
            return stache(iAi.intermediate);
        });
    };
    var templates = {};
    stache.from = mustacheCore.getTemplateById = function (id) {
        if (!templates[id]) {
            var el = DOCUMENT().getElementById(id);
            templates[id] = stache(el.innerHTML);
        }
        return templates[id];
    };
    stache.registerPartial = function (id, partial) {
        templates[id] = typeof partial === 'string' ? stache(partial) : partial;
    };
    module.exports = namespace.stache = stache;
});
/*steal-qunit@1.0.1#add-dom*/
define('steal-qunit@1.0.1#add-dom', function (require, exports, module) {
    'format cjs';
    if (!document.getElementById('qunit')) {
        var qunit = document.createElement('div');
        qunit.id = 'qunit';
        (document.body || document.documentElement).appendChild(qunit);
    }
});
/*qunitjs@1.23.1#qunit/qunit*/
define('qunitjs@1.23.1#qunit/qunit', [
    'module',
    '@loader',
    'require',
    'steal-qunit/add-dom'
], function (module, loader, require) {
    loader.get('@@global-helpers').prepareGlobal({
        require: require,
        name: module.id,
        deps: ['steal-qunit/add-dom'],
        exports: 'QUnit'
    });
    var define = loader.global.define;
    var require = loader.global.require;
    var source = '/*!\n * QUnit 1.23.1\n * https://qunitjs.com/\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2016-04-12T17:29Z\n */\n\n( function( global ) {\n\nvar QUnit = {};\n\nvar Date = global.Date;\nvar now = Date.now || function() {\n\treturn new Date().getTime();\n};\n\nvar setTimeout = global.setTimeout;\nvar clearTimeout = global.clearTimeout;\n\n// Store a local window from the global to allow direct references.\nvar window = global.window;\n\nvar defined = {\n\tdocument: window && window.document !== undefined,\n\tsetTimeout: setTimeout !== undefined,\n\tsessionStorage: ( function() {\n\t\tvar x = "qunit-test-string";\n\t\ttry {\n\t\t\tsessionStorage.setItem( x, x );\n\t\t\tsessionStorage.removeItem( x );\n\t\t\treturn true;\n\t\t} catch ( e ) {\n\t\t\treturn false;\n\t\t}\n\t}() )\n};\n\nvar fileName = ( sourceFromStacktrace( 0 ) || "" ).replace( /(:\\d+)+\\)?/, "" ).replace( /.+\\//, "" );\nvar globalStartCalled = false;\nvar runStarted = false;\n\nvar toString = Object.prototype.toString,\n\thasOwn = Object.prototype.hasOwnProperty;\n\n// Returns a new Array with the elements that are in a but not in b\nfunction diff( a, b ) {\n\tvar i, j,\n\t\tresult = a.slice();\n\n\tfor ( i = 0; i < result.length; i++ ) {\n\t\tfor ( j = 0; j < b.length; j++ ) {\n\t\t\tif ( result[ i ] === b[ j ] ) {\n\t\t\t\tresult.splice( i, 1 );\n\t\t\t\ti--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\n// From jquery.js\nfunction inArray( elem, array ) {\n\tif ( array.indexOf ) {\n\t\treturn array.indexOf( elem );\n\t}\n\n\tfor ( var i = 0, length = array.length; i < length; i++ ) {\n\t\tif ( array[ i ] === elem ) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n/**\n * Makes a clone of an object using only Array or Object as base,\n * and copies over the own enumerable properties.\n *\n * @param {Object} obj\n * @return {Object} New object with only the own properties (recursively).\n */\nfunction objectValues ( obj ) {\n\tvar key, val,\n\t\tvals = QUnit.is( "array", obj ) ? [] : {};\n\tfor ( key in obj ) {\n\t\tif ( hasOwn.call( obj, key ) ) {\n\t\t\tval = obj[ key ];\n\t\t\tvals[ key ] = val === Object( val ) ? objectValues( val ) : val;\n\t\t}\n\t}\n\treturn vals;\n}\n\nfunction extend( a, b, undefOnly ) {\n\tfor ( var prop in b ) {\n\t\tif ( hasOwn.call( b, prop ) ) {\n\n\t\t\t// Avoid "Member not found" error in IE8 caused by messing with window.constructor\n\t\t\t// This block runs on every environment, so `global` is being used instead of `window`\n\t\t\t// to avoid errors on node.\n\t\t\tif ( prop !== "constructor" || a !== global ) {\n\t\t\t\tif ( b[ prop ] === undefined ) {\n\t\t\t\t\tdelete a[ prop ];\n\t\t\t\t} else if ( !( undefOnly && typeof a[ prop ] !== "undefined" ) ) {\n\t\t\t\t\ta[ prop ] = b[ prop ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a;\n}\n\nfunction objectType( obj ) {\n\tif ( typeof obj === "undefined" ) {\n\t\treturn "undefined";\n\t}\n\n\t// Consider: typeof null === object\n\tif ( obj === null ) {\n\t\treturn "null";\n\t}\n\n\tvar match = toString.call( obj ).match( /^\\[object\\s(.*)\\]$/ ),\n\t\ttype = match && match[ 1 ];\n\n\tswitch ( type ) {\n\t\tcase "Number":\n\t\t\tif ( isNaN( obj ) ) {\n\t\t\t\treturn "nan";\n\t\t\t}\n\t\t\treturn "number";\n\t\tcase "String":\n\t\tcase "Boolean":\n\t\tcase "Array":\n\t\tcase "Set":\n\t\tcase "Map":\n\t\tcase "Date":\n\t\tcase "RegExp":\n\t\tcase "Function":\n\t\tcase "Symbol":\n\t\t\treturn type.toLowerCase();\n\t}\n\tif ( typeof obj === "object" ) {\n\t\treturn "object";\n\t}\n}\n\n// Safe object type checking\nfunction is( type, obj ) {\n\treturn QUnit.objectType( obj ) === type;\n}\n\n// Doesn\'t support IE6 to IE9, it will return undefined on these browsers\n// See also https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error/Stack\nfunction extractStacktrace( e, offset ) {\n\toffset = offset === undefined ? 4 : offset;\n\n\tvar stack, include, i;\n\n\tif ( e.stack ) {\n\t\tstack = e.stack.split( "\\n" );\n\t\tif ( /^error$/i.test( stack[ 0 ] ) ) {\n\t\t\tstack.shift();\n\t\t}\n\t\tif ( fileName ) {\n\t\t\tinclude = [];\n\t\t\tfor ( i = offset; i < stack.length; i++ ) {\n\t\t\t\tif ( stack[ i ].indexOf( fileName ) !== -1 ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tinclude.push( stack[ i ] );\n\t\t\t}\n\t\t\tif ( include.length ) {\n\t\t\t\treturn include.join( "\\n" );\n\t\t\t}\n\t\t}\n\t\treturn stack[ offset ];\n\n\t// Support: Safari <=6 only\n\t} else if ( e.sourceURL ) {\n\n\t\t// Exclude useless self-reference for generated Error objects\n\t\tif ( /qunit.js$/.test( e.sourceURL ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// For actual exceptions, this is useful\n\t\treturn e.sourceURL + ":" + e.line;\n\t}\n}\n\nfunction sourceFromStacktrace( offset ) {\n\tvar error = new Error();\n\n\t// Support: Safari <=7 only, IE <=10 - 11 only\n\t// Not all browsers generate the `stack` property for `new Error()`, see also #636\n\tif ( !error.stack ) {\n\t\ttry {\n\t\t\tthrow error;\n\t\t} catch ( err ) {\n\t\t\terror = err;\n\t\t}\n\t}\n\n\treturn extractStacktrace( error, offset );\n}\n\n/**\n * Config object: Maintain internal state\n * Later exposed as QUnit.config\n * `config` initialized at top of scope\n */\nvar config = {\n\n\t// The queue of tests to run\n\tqueue: [],\n\n\t// Block until document ready\n\tblocking: true,\n\n\t// By default, run previously failed tests first\n\t// very useful in combination with "Hide passed tests" checked\n\treorder: true,\n\n\t// By default, modify document.title when suite is done\n\taltertitle: true,\n\n\t// HTML Reporter: collapse every test except the first failing test\n\t// If false, all failing tests will be expanded\n\tcollapse: true,\n\n\t// By default, scroll to top of the page when suite is done\n\tscrolltop: true,\n\n\t// Depth up-to which object will be dumped\n\tmaxDepth: 5,\n\n\t// When enabled, all tests must call expect()\n\trequireExpects: false,\n\n\t// Placeholder for user-configurable form-exposed URL parameters\n\turlConfig: [],\n\n\t// Set of all modules.\n\tmodules: [],\n\n\t// Stack of nested modules\n\tmoduleStack: [],\n\n\t// The first unnamed module\n\tcurrentModule: {\n\t\tname: "",\n\t\ttests: []\n\t},\n\n\tcallbacks: {}\n};\n\n// Push a loose unnamed module to the modules collection\nconfig.modules.push( config.currentModule );\n\nvar loggingCallbacks = {};\n\n// Register logging callbacks\nfunction registerLoggingCallbacks( obj ) {\n\tvar i, l, key,\n\t\tcallbackNames = [ "begin", "done", "log", "testStart", "testDone",\n\t\t\t"moduleStart", "moduleDone" ];\n\n\tfunction registerLoggingCallback( key ) {\n\t\tvar loggingCallback = function( callback ) {\n\t\t\tif ( objectType( callback ) !== "function" ) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t"QUnit logging methods require a callback function as their first parameters."\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconfig.callbacks[ key ].push( callback );\n\t\t};\n\n\t\t// DEPRECATED: This will be removed on QUnit 2.0.0+\n\t\t// Stores the registered functions allowing restoring\n\t\t// at verifyLoggingCallbacks() if modified\n\t\tloggingCallbacks[ key ] = loggingCallback;\n\n\t\treturn loggingCallback;\n\t}\n\n\tfor ( i = 0, l = callbackNames.length; i < l; i++ ) {\n\t\tkey = callbackNames[ i ];\n\n\t\t// Initialize key collection of logging callback\n\t\tif ( objectType( config.callbacks[ key ] ) === "undefined" ) {\n\t\t\tconfig.callbacks[ key ] = [];\n\t\t}\n\n\t\tobj[ key ] = registerLoggingCallback( key );\n\t}\n}\n\nfunction runLoggingCallbacks( key, args ) {\n\tvar i, l, callbacks;\n\n\tcallbacks = config.callbacks[ key ];\n\tfor ( i = 0, l = callbacks.length; i < l; i++ ) {\n\t\tcallbacks[ i ]( args );\n\t}\n}\n\n// DEPRECATED: This will be removed on 2.0.0+\n// This function verifies if the loggingCallbacks were modified by the user\n// If so, it will restore it, assign the given callback and print a console warning\nfunction verifyLoggingCallbacks() {\n\tvar loggingCallback, userCallback;\n\n\tfor ( loggingCallback in loggingCallbacks ) {\n\t\tif ( QUnit[ loggingCallback ] !== loggingCallbacks[ loggingCallback ] ) {\n\n\t\t\tuserCallback = QUnit[ loggingCallback ];\n\n\t\t\t// Restore the callback function\n\t\t\tQUnit[ loggingCallback ] = loggingCallbacks[ loggingCallback ];\n\n\t\t\t// Assign the deprecated given callback\n\t\t\tQUnit[ loggingCallback ]( userCallback );\n\n\t\t\tif ( global.console && global.console.warn ) {\n\t\t\t\tglobal.console.warn(\n\t\t\t\t\t"QUnit." + loggingCallback + " was replaced with a new value.\\n" +\n\t\t\t\t\t"Please, check out the documentation on how to apply logging callbacks.\\n" +\n\t\t\t\t\t"Reference: https://api.qunitjs.com/category/callbacks/"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n}\n\n( function() {\n\tif ( !defined.document ) {\n\t\treturn;\n\t}\n\n\t// `onErrorFnPrev` initialized at top of scope\n\t// Preserve other handlers\n\tvar onErrorFnPrev = window.onerror;\n\n\t// Cover uncaught exceptions\n\t// Returning true will suppress the default browser handler,\n\t// returning false will let it run.\n\twindow.onerror = function( error, filePath, linerNr ) {\n\t\tvar ret = false;\n\t\tif ( onErrorFnPrev ) {\n\t\t\tret = onErrorFnPrev( error, filePath, linerNr );\n\t\t}\n\n\t\t// Treat return value as window.onerror itself does,\n\t\t// Only do our handling if not suppressed.\n\t\tif ( ret !== true ) {\n\t\t\tif ( QUnit.config.current ) {\n\t\t\t\tif ( QUnit.config.current.ignoreGlobalErrors ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tQUnit.pushFailure( error, filePath + ":" + linerNr );\n\t\t\t} else {\n\t\t\t\tQUnit.test( "global failure", extend( function() {\n\t\t\t\t\tQUnit.pushFailure( error, filePath + ":" + linerNr );\n\t\t\t\t}, { validTest: true } ) );\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\treturn ret;\n\t};\n}() );\n\n// Figure out if we\'re running the tests from a server or not\nQUnit.isLocal = !( defined.document && window.location.protocol !== "file:" );\n\n// Expose the current QUnit version\nQUnit.version = "1.23.1";\n\nextend( QUnit, {\n\n\t// Call on start of module test to prepend name to all tests\n\tmodule: function( name, testEnvironment, executeNow ) {\n\t\tvar module, moduleFns;\n\t\tvar currentModule = config.currentModule;\n\n\t\tif ( arguments.length === 2 ) {\n\t\t\tif ( objectType( testEnvironment ) === "function" ) {\n\t\t\t\texecuteNow = testEnvironment;\n\t\t\t\ttestEnvironment = undefined;\n\t\t\t}\n\t\t}\n\n\t\t// DEPRECATED: handles setup/teardown functions,\n\t\t// beforeEach and afterEach should be used instead\n\t\tif ( testEnvironment && testEnvironment.setup ) {\n\t\t\ttestEnvironment.beforeEach = testEnvironment.setup;\n\t\t\tdelete testEnvironment.setup;\n\t\t}\n\t\tif ( testEnvironment && testEnvironment.teardown ) {\n\t\t\ttestEnvironment.afterEach = testEnvironment.teardown;\n\t\t\tdelete testEnvironment.teardown;\n\t\t}\n\n\t\tmodule = createModule();\n\n\t\tmoduleFns = {\n\t\t\tbeforeEach: setHook( module, "beforeEach" ),\n\t\t\tafterEach: setHook( module, "afterEach" )\n\t\t};\n\n\t\tif ( objectType( executeNow ) === "function" ) {\n\t\t\tconfig.moduleStack.push( module );\n\t\t\tsetCurrentModule( module );\n\t\t\texecuteNow.call( module.testEnvironment, moduleFns );\n\t\t\tconfig.moduleStack.pop();\n\t\t\tmodule = module.parentModule || currentModule;\n\t\t}\n\n\t\tsetCurrentModule( module );\n\n\t\tfunction createModule() {\n\t\t\tvar parentModule = config.moduleStack.length ?\n\t\t\t\tconfig.moduleStack.slice( -1 )[ 0 ] : null;\n\t\t\tvar moduleName = parentModule !== null ?\n\t\t\t\t[ parentModule.name, name ].join( " > " ) : name;\n\t\t\tvar module = {\n\t\t\t\tname: moduleName,\n\t\t\t\tparentModule: parentModule,\n\t\t\t\ttests: [],\n\t\t\t\tmoduleId: generateHash( moduleName )\n\t\t\t};\n\n\t\t\tvar env = {};\n\t\t\tif ( parentModule ) {\n\t\t\t\textend( env, parentModule.testEnvironment );\n\t\t\t\tdelete env.beforeEach;\n\t\t\t\tdelete env.afterEach;\n\t\t\t}\n\t\t\textend( env, testEnvironment );\n\t\t\tmodule.testEnvironment = env;\n\n\t\t\tconfig.modules.push( module );\n\t\t\treturn module;\n\t\t}\n\n\t\tfunction setCurrentModule( module ) {\n\t\t\tconfig.currentModule = module;\n\t\t}\n\n\t},\n\n\t// DEPRECATED: QUnit.asyncTest() will be removed in QUnit 2.0.\n\tasyncTest: asyncTest,\n\n\ttest: test,\n\n\tskip: skip,\n\n\tonly: only,\n\n\t// DEPRECATED: The functionality of QUnit.start() will be altered in QUnit 2.0.\n\t// In QUnit 2.0, invoking it will ONLY affect the `QUnit.config.autostart` blocking behavior.\n\tstart: function( count ) {\n\t\tvar globalStartAlreadyCalled = globalStartCalled;\n\n\t\tif ( !config.current ) {\n\t\t\tglobalStartCalled = true;\n\n\t\t\tif ( runStarted ) {\n\t\t\t\tthrow new Error( "Called start() outside of a test context while already started" );\n\t\t\t} else if ( globalStartAlreadyCalled || count > 1 ) {\n\t\t\t\tthrow new Error( "Called start() outside of a test context too many times" );\n\t\t\t} else if ( config.autostart ) {\n\t\t\t\tthrow new Error( "Called start() outside of a test context when " +\n\t\t\t\t\t"QUnit.config.autostart was true" );\n\t\t\t} else if ( !config.pageLoaded ) {\n\n\t\t\t\t// The page isn\'t completely loaded yet, so bail out and let `QUnit.load` handle it\n\t\t\t\tconfig.autostart = true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\n\t\t\t// If a test is running, adjust its semaphore\n\t\t\tconfig.current.semaphore -= count || 1;\n\n\t\t\t// If semaphore is non-numeric, throw error\n\t\t\tif ( isNaN( config.current.semaphore ) ) {\n\t\t\t\tconfig.current.semaphore = 0;\n\n\t\t\t\tQUnit.pushFailure(\n\t\t\t\t\t"Called start() with a non-numeric decrement.",\n\t\t\t\t\tsourceFromStacktrace( 2 )\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Don\'t start until equal number of stop-calls\n\t\t\tif ( config.current.semaphore > 0 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Throw an Error if start is called more often than stop\n\t\t\tif ( config.current.semaphore < 0 ) {\n\t\t\t\tconfig.current.semaphore = 0;\n\n\t\t\t\tQUnit.pushFailure(\n\t\t\t\t\t"Called start() while already started (test\'s semaphore was 0 already)",\n\t\t\t\t\tsourceFromStacktrace( 2 )\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tresumeProcessing();\n\t},\n\n\t// DEPRECATED: QUnit.stop() will be removed in QUnit 2.0.\n\tstop: function( count ) {\n\n\t\t// If there isn\'t a test running, don\'t allow QUnit.stop() to be called\n\t\tif ( !config.current ) {\n\t\t\tthrow new Error( "Called stop() outside of a test context" );\n\t\t}\n\n\t\t// If a test is running, adjust its semaphore\n\t\tconfig.current.semaphore += count || 1;\n\n\t\tpauseProcessing();\n\t},\n\n\tconfig: config,\n\n\tis: is,\n\n\tobjectType: objectType,\n\n\textend: extend,\n\n\tload: function() {\n\t\tconfig.pageLoaded = true;\n\n\t\t// Initialize the configuration options\n\t\textend( config, {\n\t\t\tstats: { all: 0, bad: 0 },\n\t\t\tmoduleStats: { all: 0, bad: 0 },\n\t\t\tstarted: 0,\n\t\t\tupdateRate: 1000,\n\t\t\tautostart: true,\n\t\t\tfilter: ""\n\t\t}, true );\n\n\t\tconfig.blocking = false;\n\n\t\tif ( config.autostart ) {\n\t\t\tresumeProcessing();\n\t\t}\n\t},\n\n\tstack: function( offset ) {\n\t\toffset = ( offset || 0 ) + 2;\n\t\treturn sourceFromStacktrace( offset );\n\t}\n} );\n\nregisterLoggingCallbacks( QUnit );\n\nfunction begin() {\n\tvar i, l,\n\t\tmodulesLog = [];\n\n\t// If the test run hasn\'t officially begun yet\n\tif ( !config.started ) {\n\n\t\t// Record the time of the test run\'s beginning\n\t\tconfig.started = now();\n\n\t\tverifyLoggingCallbacks();\n\n\t\t// Delete the loose unnamed module if unused.\n\t\tif ( config.modules[ 0 ].name === "" && config.modules[ 0 ].tests.length === 0 ) {\n\t\t\tconfig.modules.shift();\n\t\t}\n\n\t\t// Avoid unnecessary information by not logging modules\' test environments\n\t\tfor ( i = 0, l = config.modules.length; i < l; i++ ) {\n\t\t\tmodulesLog.push( {\n\t\t\t\tname: config.modules[ i ].name,\n\t\t\t\ttests: config.modules[ i ].tests\n\t\t\t} );\n\t\t}\n\n\t\t// The test run is officially beginning now\n\t\trunLoggingCallbacks( "begin", {\n\t\t\ttotalTests: Test.count,\n\t\t\tmodules: modulesLog\n\t\t} );\n\t}\n\n\tconfig.blocking = false;\n\tprocess( true );\n}\n\nfunction process( last ) {\n\tfunction next() {\n\t\tprocess( last );\n\t}\n\tvar start = now();\n\tconfig.depth = ( config.depth || 0 ) + 1;\n\n\twhile ( config.queue.length && !config.blocking ) {\n\t\tif ( !defined.setTimeout || config.updateRate <= 0 ||\n\t\t\t\t( ( now() - start ) < config.updateRate ) ) {\n\t\t\tif ( config.current ) {\n\n\t\t\t\t// Reset async tracking for each phase of the Test lifecycle\n\t\t\t\tconfig.current.usedAsync = false;\n\t\t\t}\n\t\t\tconfig.queue.shift()();\n\t\t} else {\n\t\t\tsetTimeout( next, 13 );\n\t\t\tbreak;\n\t\t}\n\t}\n\tconfig.depth--;\n\tif ( last && !config.blocking && !config.queue.length && config.depth === 0 ) {\n\t\tdone();\n\t}\n}\n\nfunction pauseProcessing() {\n\tconfig.blocking = true;\n\n\tif ( config.testTimeout && defined.setTimeout ) {\n\t\tclearTimeout( config.timeout );\n\t\tconfig.timeout = setTimeout( function() {\n\t\t\tif ( config.current ) {\n\t\t\t\tconfig.current.semaphore = 0;\n\t\t\t\tQUnit.pushFailure( "Test timed out", sourceFromStacktrace( 2 ) );\n\t\t\t} else {\n\t\t\t\tthrow new Error( "Test timed out" );\n\t\t\t}\n\t\t\tresumeProcessing();\n\t\t}, config.testTimeout );\n\t}\n}\n\nfunction resumeProcessing() {\n\trunStarted = true;\n\n\t// A slight delay to allow this iteration of the event loop to finish (more assertions, etc.)\n\tif ( defined.setTimeout ) {\n\t\tsetTimeout( function() {\n\t\t\tif ( config.current && config.current.semaphore > 0 ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( config.timeout ) {\n\t\t\t\tclearTimeout( config.timeout );\n\t\t\t}\n\n\t\t\tbegin();\n\t\t}, 13 );\n\t} else {\n\t\tbegin();\n\t}\n}\n\nfunction done() {\n\tvar runtime, passed;\n\n\tconfig.autorun = true;\n\n\t// Log the last module results\n\tif ( config.previousModule ) {\n\t\trunLoggingCallbacks( "moduleDone", {\n\t\t\tname: config.previousModule.name,\n\t\t\ttests: config.previousModule.tests,\n\t\t\tfailed: config.moduleStats.bad,\n\t\t\tpassed: config.moduleStats.all - config.moduleStats.bad,\n\t\t\ttotal: config.moduleStats.all,\n\t\t\truntime: now() - config.moduleStats.started\n\t\t} );\n\t}\n\tdelete config.previousModule;\n\n\truntime = now() - config.started;\n\tpassed = config.stats.all - config.stats.bad;\n\n\trunLoggingCallbacks( "done", {\n\t\tfailed: config.stats.bad,\n\t\tpassed: passed,\n\t\ttotal: config.stats.all,\n\t\truntime: runtime\n\t} );\n}\n\nfunction setHook( module, hookName ) {\n\tif ( module.testEnvironment === undefined ) {\n\t\tmodule.testEnvironment = {};\n\t}\n\n\treturn function( callback ) {\n\t\tmodule.testEnvironment[ hookName ] = callback;\n\t};\n}\n\nvar focused = false;\nvar priorityCount = 0;\nvar unitSampler;\n\nfunction Test( settings ) {\n\tvar i, l;\n\n\t++Test.count;\n\n\textend( this, settings );\n\tthis.assertions = [];\n\tthis.semaphore = 0;\n\tthis.usedAsync = false;\n\tthis.module = config.currentModule;\n\tthis.stack = sourceFromStacktrace( 3 );\n\n\t// Register unique strings\n\tfor ( i = 0, l = this.module.tests; i < l.length; i++ ) {\n\t\tif ( this.module.tests[ i ].name === this.testName ) {\n\t\t\tthis.testName += " ";\n\t\t}\n\t}\n\n\tthis.testId = generateHash( this.module.name, this.testName );\n\n\tthis.module.tests.push( {\n\t\tname: this.testName,\n\t\ttestId: this.testId\n\t} );\n\n\tif ( settings.skip ) {\n\n\t\t// Skipped tests will fully ignore any sent callback\n\t\tthis.callback = function() {};\n\t\tthis.async = false;\n\t\tthis.expected = 0;\n\t} else {\n\t\tthis.assert = new Assert( this );\n\t}\n}\n\nTest.count = 0;\n\nTest.prototype = {\n\tbefore: function() {\n\t\tif (\n\n\t\t\t// Emit moduleStart when we\'re switching from one module to another\n\t\t\tthis.module !== config.previousModule ||\n\n\t\t\t\t// They could be equal (both undefined) but if the previousModule property doesn\'t\n\t\t\t\t// yet exist it means this is the first test in a suite that isn\'t wrapped in a\n\t\t\t\t// module, in which case we\'ll just emit a moduleStart event for \'undefined\'.\n\t\t\t\t// Without this, reporters can get testStart before moduleStart  which is a problem.\n\t\t\t\t!hasOwn.call( config, "previousModule" )\n\t\t) {\n\t\t\tif ( hasOwn.call( config, "previousModule" ) ) {\n\t\t\t\trunLoggingCallbacks( "moduleDone", {\n\t\t\t\t\tname: config.previousModule.name,\n\t\t\t\t\ttests: config.previousModule.tests,\n\t\t\t\t\tfailed: config.moduleStats.bad,\n\t\t\t\t\tpassed: config.moduleStats.all - config.moduleStats.bad,\n\t\t\t\t\ttotal: config.moduleStats.all,\n\t\t\t\t\truntime: now() - config.moduleStats.started\n\t\t\t\t} );\n\t\t\t}\n\t\t\tconfig.previousModule = this.module;\n\t\t\tconfig.moduleStats = { all: 0, bad: 0, started: now() };\n\t\t\trunLoggingCallbacks( "moduleStart", {\n\t\t\t\tname: this.module.name,\n\t\t\t\ttests: this.module.tests\n\t\t\t} );\n\t\t}\n\n\t\tconfig.current = this;\n\n\t\tif ( this.module.testEnvironment ) {\n\t\t\tdelete this.module.testEnvironment.beforeEach;\n\t\t\tdelete this.module.testEnvironment.afterEach;\n\t\t}\n\t\tthis.testEnvironment = extend( {}, this.module.testEnvironment );\n\n\t\tthis.started = now();\n\t\trunLoggingCallbacks( "testStart", {\n\t\t\tname: this.testName,\n\t\t\tmodule: this.module.name,\n\t\t\ttestId: this.testId\n\t\t} );\n\n\t\tif ( !config.pollution ) {\n\t\t\tsaveGlobal();\n\t\t}\n\t},\n\n\trun: function() {\n\t\tvar promise;\n\n\t\tconfig.current = this;\n\n\t\tif ( this.async ) {\n\t\t\tQUnit.stop();\n\t\t}\n\n\t\tthis.callbackStarted = now();\n\n\t\tif ( config.notrycatch ) {\n\t\t\trunTest( this );\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\trunTest( this );\n\t\t} catch ( e ) {\n\t\t\tthis.pushFailure( "Died on test #" + ( this.assertions.length + 1 ) + " " +\n\t\t\t\tthis.stack + ": " + ( e.message || e ), extractStacktrace( e, 0 ) );\n\n\t\t\t// Else next test will carry the responsibility\n\t\t\tsaveGlobal();\n\n\t\t\t// Restart the tests if they\'re blocking\n\t\t\tif ( config.blocking ) {\n\t\t\t\tQUnit.start();\n\t\t\t}\n\t\t}\n\n\t\tfunction runTest( test ) {\n\t\t\tpromise = test.callback.call( test.testEnvironment, test.assert );\n\t\t\ttest.resolvePromise( promise );\n\t\t}\n\t},\n\n\tafter: function() {\n\t\tcheckPollution();\n\t},\n\n\tqueueHook: function( hook, hookName ) {\n\t\tvar promise,\n\t\t\ttest = this;\n\t\treturn function runHook() {\n\t\t\tconfig.current = test;\n\t\t\tif ( config.notrycatch ) {\n\t\t\t\tcallHook();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tcallHook();\n\t\t\t} catch ( error ) {\n\t\t\t\ttest.pushFailure( hookName + " failed on " + test.testName + ": " +\n\t\t\t\t( error.message || error ), extractStacktrace( error, 0 ) );\n\t\t\t}\n\n\t\t\tfunction callHook() {\n\t\t\t\tpromise = hook.call( test.testEnvironment, test.assert );\n\t\t\t\ttest.resolvePromise( promise, hookName );\n\t\t\t}\n\t\t};\n\t},\n\n\t// Currently only used for module level hooks, can be used to add global level ones\n\thooks: function( handler ) {\n\t\tvar hooks = [];\n\n\t\tfunction processHooks( test, module ) {\n\t\t\tif ( module.parentModule ) {\n\t\t\t\tprocessHooks( test, module.parentModule );\n\t\t\t}\n\t\t\tif ( module.testEnvironment &&\n\t\t\t\tQUnit.objectType( module.testEnvironment[ handler ] ) === "function" ) {\n\t\t\t\thooks.push( test.queueHook( module.testEnvironment[ handler ], handler ) );\n\t\t\t}\n\t\t}\n\n\t\t// Hooks are ignored on skipped tests\n\t\tif ( !this.skip ) {\n\t\t\tprocessHooks( this, this.module );\n\t\t}\n\t\treturn hooks;\n\t},\n\n\tfinish: function() {\n\t\tconfig.current = this;\n\t\tif ( config.requireExpects && this.expected === null ) {\n\t\t\tthis.pushFailure( "Expected number of assertions to be defined, but expect() was " +\n\t\t\t\t"not called.", this.stack );\n\t\t} else if ( this.expected !== null && this.expected !== this.assertions.length ) {\n\t\t\tthis.pushFailure( "Expected " + this.expected + " assertions, but " +\n\t\t\t\tthis.assertions.length + " were run", this.stack );\n\t\t} else if ( this.expected === null && !this.assertions.length ) {\n\t\t\tthis.pushFailure( "Expected at least one assertion, but none were run - call " +\n\t\t\t\t"expect(0) to accept zero assertions.", this.stack );\n\t\t}\n\n\t\tvar i,\n\t\t\tbad = 0;\n\n\t\tthis.runtime = now() - this.started;\n\t\tconfig.stats.all += this.assertions.length;\n\t\tconfig.moduleStats.all += this.assertions.length;\n\n\t\tfor ( i = 0; i < this.assertions.length; i++ ) {\n\t\t\tif ( !this.assertions[ i ].result ) {\n\t\t\t\tbad++;\n\t\t\t\tconfig.stats.bad++;\n\t\t\t\tconfig.moduleStats.bad++;\n\t\t\t}\n\t\t}\n\n\t\trunLoggingCallbacks( "testDone", {\n\t\t\tname: this.testName,\n\t\t\tmodule: this.module.name,\n\t\t\tskipped: !!this.skip,\n\t\t\tfailed: bad,\n\t\t\tpassed: this.assertions.length - bad,\n\t\t\ttotal: this.assertions.length,\n\t\t\truntime: this.runtime,\n\n\t\t\t// HTML Reporter use\n\t\t\tassertions: this.assertions,\n\t\t\ttestId: this.testId,\n\n\t\t\t// Source of Test\n\t\t\tsource: this.stack,\n\n\t\t\t// DEPRECATED: this property will be removed in 2.0.0, use runtime instead\n\t\t\tduration: this.runtime\n\t\t} );\n\n\t\t// QUnit.reset() is deprecated and will be replaced for a new\n\t\t// fixture reset function on QUnit 2.0/2.1.\n\t\t// It\'s still called here for backwards compatibility handling\n\t\tQUnit.reset();\n\n\t\tconfig.current = undefined;\n\t},\n\n\tqueue: function() {\n\t\tvar priority,\n\t\t\ttest = this;\n\n\t\tif ( !this.valid() ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfunction run() {\n\n\t\t\t// Each of these can by async\n\t\t\tsynchronize( [\n\t\t\t\tfunction() {\n\t\t\t\t\ttest.before();\n\t\t\t\t},\n\n\t\t\t\ttest.hooks( "beforeEach" ),\n\t\t\t\tfunction() {\n\t\t\t\t\ttest.run();\n\t\t\t\t},\n\n\t\t\t\ttest.hooks( "afterEach" ).reverse(),\n\n\t\t\t\tfunction() {\n\t\t\t\t\ttest.after();\n\t\t\t\t},\n\t\t\t\tfunction() {\n\t\t\t\t\ttest.finish();\n\t\t\t\t}\n\t\t\t] );\n\t\t}\n\n\t\t// Prioritize previously failed tests, detected from sessionStorage\n\t\tpriority = QUnit.config.reorder && defined.sessionStorage &&\n\t\t\t\t+sessionStorage.getItem( "qunit-test-" + this.module.name + "-" + this.testName );\n\n\t\treturn synchronize( run, priority, config.seed );\n\t},\n\n\tpushResult: function( resultInfo ) {\n\n\t\t// Destructure of resultInfo = { result, actual, expected, message, negative }\n\t\tvar source,\n\t\t\tdetails = {\n\t\t\t\tmodule: this.module.name,\n\t\t\t\tname: this.testName,\n\t\t\t\tresult: resultInfo.result,\n\t\t\t\tmessage: resultInfo.message,\n\t\t\t\tactual: resultInfo.actual,\n\t\t\t\texpected: resultInfo.expected,\n\t\t\t\ttestId: this.testId,\n\t\t\t\tnegative: resultInfo.negative || false,\n\t\t\t\truntime: now() - this.started\n\t\t\t};\n\n\t\tif ( !resultInfo.result ) {\n\t\t\tsource = sourceFromStacktrace();\n\n\t\t\tif ( source ) {\n\t\t\t\tdetails.source = source;\n\t\t\t}\n\t\t}\n\n\t\trunLoggingCallbacks( "log", details );\n\n\t\tthis.assertions.push( {\n\t\t\tresult: !!resultInfo.result,\n\t\t\tmessage: resultInfo.message\n\t\t} );\n\t},\n\n\tpushFailure: function( message, source, actual ) {\n\t\tif ( !( this instanceof Test ) ) {\n\t\t\tthrow new Error( "pushFailure() assertion outside test context, was " +\n\t\t\t\tsourceFromStacktrace( 2 ) );\n\t\t}\n\n\t\tvar details = {\n\t\t\t\tmodule: this.module.name,\n\t\t\t\tname: this.testName,\n\t\t\t\tresult: false,\n\t\t\t\tmessage: message || "error",\n\t\t\t\tactual: actual || null,\n\t\t\t\ttestId: this.testId,\n\t\t\t\truntime: now() - this.started\n\t\t\t};\n\n\t\tif ( source ) {\n\t\t\tdetails.source = source;\n\t\t}\n\n\t\trunLoggingCallbacks( "log", details );\n\n\t\tthis.assertions.push( {\n\t\t\tresult: false,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tresolvePromise: function( promise, phase ) {\n\t\tvar then, message,\n\t\t\ttest = this;\n\t\tif ( promise != null ) {\n\t\t\tthen = promise.then;\n\t\t\tif ( QUnit.objectType( then ) === "function" ) {\n\t\t\t\tQUnit.stop();\n\t\t\t\tthen.call(\n\t\t\t\t\tpromise,\n\t\t\t\t\tfunction() { QUnit.start(); },\n\t\t\t\t\tfunction( error ) {\n\t\t\t\t\t\tmessage = "Promise rejected " +\n\t\t\t\t\t\t\t( !phase ? "during" : phase.replace( /Each$/, "" ) ) +\n\t\t\t\t\t\t\t" " + test.testName + ": " + ( error.message || error );\n\t\t\t\t\t\ttest.pushFailure( message, extractStacktrace( error, 0 ) );\n\n\t\t\t\t\t\t// Else next test will carry the responsibility\n\t\t\t\t\t\tsaveGlobal();\n\n\t\t\t\t\t\t// Unblock\n\t\t\t\t\t\tQUnit.start();\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t},\n\n\tvalid: function() {\n\t\tvar filter = config.filter,\n\t\t\tregexFilter = /^(!?)\\/([\\w\\W]*)\\/(i?$)/.exec( filter ),\n\t\t\tmodule = config.module && config.module.toLowerCase(),\n\t\t\tfullName = ( this.module.name + ": " + this.testName );\n\n\t\tfunction moduleChainNameMatch( testModule ) {\n\t\t\tvar testModuleName = testModule.name ? testModule.name.toLowerCase() : null;\n\t\t\tif ( testModuleName === module ) {\n\t\t\t\treturn true;\n\t\t\t} else if ( testModule.parentModule ) {\n\t\t\t\treturn moduleChainNameMatch( testModule.parentModule );\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfunction moduleChainIdMatch( testModule ) {\n\t\t\treturn inArray( testModule.moduleId, config.moduleId ) > -1 ||\n\t\t\t\ttestModule.parentModule && moduleChainIdMatch( testModule.parentModule );\n\t\t}\n\n\t\t// Internally-generated tests are always valid\n\t\tif ( this.callback && this.callback.validTest ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif ( config.moduleId && config.moduleId.length > 0 &&\n\t\t\t!moduleChainIdMatch( this.module ) ) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( config.testId && config.testId.length > 0 &&\n\t\t\tinArray( this.testId, config.testId ) < 0 ) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( module && !moduleChainNameMatch( this.module ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( !filter ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn regexFilter ?\n\t\t\tthis.regexFilter( !!regexFilter[ 1 ], regexFilter[ 2 ], regexFilter[ 3 ], fullName ) :\n\t\t\tthis.stringFilter( filter, fullName );\n\t},\n\n\tregexFilter: function( exclude, pattern, flags, fullName ) {\n\t\tvar regex = new RegExp( pattern, flags );\n\t\tvar match = regex.test( fullName );\n\n\t\treturn match !== exclude;\n\t},\n\n\tstringFilter: function( filter, fullName ) {\n\t\tfilter = filter.toLowerCase();\n\t\tfullName = fullName.toLowerCase();\n\n\t\tvar include = filter.charAt( 0 ) !== "!";\n\t\tif ( !include ) {\n\t\t\tfilter = filter.slice( 1 );\n\t\t}\n\n\t\t// If the filter matches, we need to honour include\n\t\tif ( fullName.indexOf( filter ) !== -1 ) {\n\t\t\treturn include;\n\t\t}\n\n\t\t// Otherwise, do the opposite\n\t\treturn !include;\n\t}\n};\n\n// Resets the test setup. Useful for tests that modify the DOM.\n/*\nDEPRECATED: Use multiple tests instead of resetting inside a test.\nUse testStart or testDone for custom cleanup.\nThis method will throw an error in 2.0, and will be removed in 2.1\n*/\nQUnit.reset = function() {\n\n\t// Return on non-browser environments\n\t// This is necessary to not break on node tests\n\tif ( !defined.document ) {\n\t\treturn;\n\t}\n\n\tvar fixture = defined.document && document.getElementById &&\n\t\t\tdocument.getElementById( "qunit-fixture" );\n\n\tif ( fixture ) {\n\t\tfixture.innerHTML = config.fixture;\n\t}\n};\n\nQUnit.pushFailure = function() {\n\tif ( !QUnit.config.current ) {\n\t\tthrow new Error( "pushFailure() assertion outside test context, in " +\n\t\t\tsourceFromStacktrace( 2 ) );\n\t}\n\n\t// Gets current test obj\n\tvar currentTest = QUnit.config.current;\n\n\treturn currentTest.pushFailure.apply( currentTest, arguments );\n};\n\n// Based on Java\'s String.hashCode, a simple but not\n// rigorously collision resistant hashing function\nfunction generateHash( module, testName ) {\n\tvar hex,\n\t\ti = 0,\n\t\thash = 0,\n\t\tstr = module + "\\x1C" + testName,\n\t\tlen = str.length;\n\n\tfor ( ; i < len; i++ ) {\n\t\thash  = ( ( hash << 5 ) - hash ) + str.charCodeAt( i );\n\t\thash |= 0;\n\t}\n\n\t// Convert the possibly negative integer hash code into an 8 character hex string, which isn\'t\n\t// strictly necessary but increases user understanding that the id is a SHA-like hash\n\thex = ( 0x100000000 + hash ).toString( 16 );\n\tif ( hex.length < 8 ) {\n\t\thex = "0000000" + hex;\n\t}\n\n\treturn hex.slice( -8 );\n}\n\nfunction synchronize( callback, priority, seed ) {\n\tvar last = !priority,\n\t\tindex;\n\n\tif ( QUnit.objectType( callback ) === "array" ) {\n\t\twhile ( callback.length ) {\n\t\t\tsynchronize( callback.shift() );\n\t\t}\n\t\treturn;\n\t}\n\n\tif ( priority ) {\n\t\tconfig.queue.splice( priorityCount++, 0, callback );\n\t} else if ( seed ) {\n\t\tif ( !unitSampler ) {\n\t\t\tunitSampler = unitSamplerGenerator( seed );\n\t\t}\n\n\t\t// Insert into a random position after all priority items\n\t\tindex = Math.floor( unitSampler() * ( config.queue.length - priorityCount + 1 ) );\n\t\tconfig.queue.splice( priorityCount + index, 0, callback );\n\t} else {\n\t\tconfig.queue.push( callback );\n\t}\n\n\tif ( config.autorun && !config.blocking ) {\n\t\tprocess( last );\n\t}\n}\n\nfunction unitSamplerGenerator( seed ) {\n\n\t// 32-bit xorshift, requires only a nonzero seed\n\t// http://excamera.com/sphinx/article-xorshift.html\n\tvar sample = parseInt( generateHash( seed ), 16 ) || -1;\n\treturn function() {\n\t\tsample ^= sample << 13;\n\t\tsample ^= sample >>> 17;\n\t\tsample ^= sample << 5;\n\n\t\t// ECMAScript has no unsigned number type\n\t\tif ( sample < 0 ) {\n\t\t\tsample += 0x100000000;\n\t\t}\n\n\t\treturn sample / 0x100000000;\n\t};\n}\n\nfunction saveGlobal() {\n\tconfig.pollution = [];\n\n\tif ( config.noglobals ) {\n\t\tfor ( var key in global ) {\n\t\t\tif ( hasOwn.call( global, key ) ) {\n\n\t\t\t\t// In Opera sometimes DOM element ids show up here, ignore them\n\t\t\t\tif ( /^qunit-test-output/.test( key ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconfig.pollution.push( key );\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction checkPollution() {\n\tvar newGlobals,\n\t\tdeletedGlobals,\n\t\told = config.pollution;\n\n\tsaveGlobal();\n\n\tnewGlobals = diff( config.pollution, old );\n\tif ( newGlobals.length > 0 ) {\n\t\tQUnit.pushFailure( "Introduced global variable(s): " + newGlobals.join( ", " ) );\n\t}\n\n\tdeletedGlobals = diff( old, config.pollution );\n\tif ( deletedGlobals.length > 0 ) {\n\t\tQUnit.pushFailure( "Deleted global variable(s): " + deletedGlobals.join( ", " ) );\n\t}\n}\n\n// Will be exposed as QUnit.asyncTest\nfunction asyncTest( testName, expected, callback ) {\n\tif ( arguments.length === 2 ) {\n\t\tcallback = expected;\n\t\texpected = null;\n\t}\n\n\tQUnit.test( testName, expected, callback, true );\n}\n\n// Will be exposed as QUnit.test\nfunction test( testName, expected, callback, async ) {\n\tif ( focused )  { return; }\n\n\tvar newTest;\n\n\tif ( arguments.length === 2 ) {\n\t\tcallback = expected;\n\t\texpected = null;\n\t}\n\n\tnewTest = new Test( {\n\t\ttestName: testName,\n\t\texpected: expected,\n\t\tasync: async,\n\t\tcallback: callback\n\t} );\n\n\tnewTest.queue();\n}\n\n// Will be exposed as QUnit.skip\nfunction skip( testName ) {\n\tif ( focused )  { return; }\n\n\tvar test = new Test( {\n\t\ttestName: testName,\n\t\tskip: true\n\t} );\n\n\ttest.queue();\n}\n\n// Will be exposed as QUnit.only\nfunction only( testName, expected, callback, async ) {\n\tvar newTest;\n\n\tif ( focused )  { return; }\n\n\tQUnit.config.queue.length = 0;\n\tfocused = true;\n\n\tif ( arguments.length === 2 ) {\n\t\tcallback = expected;\n\t\texpected = null;\n\t}\n\n\tnewTest = new Test( {\n\t\ttestName: testName,\n\t\texpected: expected,\n\t\tasync: async,\n\t\tcallback: callback\n\t} );\n\n\tnewTest.queue();\n}\n\nfunction Assert( testContext ) {\n\tthis.test = testContext;\n}\n\n// Assert helpers\nQUnit.assert = Assert.prototype = {\n\n\t// Specify the number of expected assertions to guarantee that failed test\n\t// (no assertions are run at all) don\'t slip through.\n\texpect: function( asserts ) {\n\t\tif ( arguments.length === 1 ) {\n\t\t\tthis.test.expected = asserts;\n\t\t} else {\n\t\t\treturn this.test.expected;\n\t\t}\n\t},\n\n\t// Increment this Test\'s semaphore counter, then return a function that\n\t// decrements that counter a maximum of once.\n\tasync: function( count ) {\n\t\tvar test = this.test,\n\t\t\tpopped = false,\n\t\t\tacceptCallCount = count;\n\n\t\tif ( typeof acceptCallCount === "undefined" ) {\n\t\t\tacceptCallCount = 1;\n\t\t}\n\n\t\ttest.semaphore += 1;\n\t\ttest.usedAsync = true;\n\t\tpauseProcessing();\n\n\t\treturn function done() {\n\n\t\t\tif ( popped ) {\n\t\t\t\ttest.pushFailure( "Too many calls to the `assert.async` callback",\n\t\t\t\t\tsourceFromStacktrace( 2 ) );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tacceptCallCount -= 1;\n\t\t\tif ( acceptCallCount > 0 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttest.semaphore -= 1;\n\t\t\tpopped = true;\n\t\t\tresumeProcessing();\n\t\t};\n\t},\n\n\t// Exports test.push() to the user API\n\t// Alias of pushResult.\n\tpush: function( result, actual, expected, message, negative ) {\n\t\tvar currentAssert = this instanceof Assert ? this : QUnit.config.current.assert;\n\t\treturn currentAssert.pushResult( {\n\t\t\tresult: result,\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message,\n\t\t\tnegative: negative\n\t\t} );\n\t},\n\n\tpushResult: function( resultInfo ) {\n\n\t\t// Destructure of resultInfo = { result, actual, expected, message, negative }\n\t\tvar assert = this,\n\t\t\tcurrentTest = ( assert instanceof Assert && assert.test ) || QUnit.config.current;\n\n\t\t// Backwards compatibility fix.\n\t\t// Allows the direct use of global exported assertions and QUnit.assert.*\n\t\t// Although, it\'s use is not recommended as it can leak assertions\n\t\t// to other tests from async tests, because we only get a reference to the current test,\n\t\t// not exactly the test where assertion were intended to be called.\n\t\tif ( !currentTest ) {\n\t\t\tthrow new Error( "assertion outside test context, in " + sourceFromStacktrace( 2 ) );\n\t\t}\n\n\t\tif ( currentTest.usedAsync === true && currentTest.semaphore === 0 ) {\n\t\t\tcurrentTest.pushFailure( "Assertion after the final `assert.async` was resolved",\n\t\t\t\tsourceFromStacktrace( 2 ) );\n\n\t\t\t// Allow this assertion to continue running anyway...\n\t\t}\n\n\t\tif ( !( assert instanceof Assert ) ) {\n\t\t\tassert = currentTest.assert;\n\t\t}\n\n\t\treturn assert.test.pushResult( resultInfo );\n\t},\n\n\tok: function( result, message ) {\n\t\tmessage = message || ( result ? "okay" : "failed, expected argument to be truthy, was: " +\n\t\t\tQUnit.dump.parse( result ) );\n\t\tthis.pushResult( {\n\t\t\tresult: !!result,\n\t\t\tactual: result,\n\t\t\texpected: true,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tnotOk: function( result, message ) {\n\t\tmessage = message || ( !result ? "okay" : "failed, expected argument to be falsy, was: " +\n\t\t\tQUnit.dump.parse( result ) );\n\t\tthis.pushResult( {\n\t\t\tresult: !result,\n\t\t\tactual: result,\n\t\t\texpected: false,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tequal: function( actual, expected, message ) {\n\t\t/*jshint eqeqeq:false */\n\t\tthis.pushResult( {\n\t\t\tresult: expected == actual,\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tnotEqual: function( actual, expected, message ) {\n\t\t/*jshint eqeqeq:false */\n\t\tthis.pushResult( {\n\t\t\tresult: expected != actual,\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message,\n\t\t\tnegative: true\n\t\t} );\n\t},\n\n\tpropEqual: function( actual, expected, message ) {\n\t\tactual = objectValues( actual );\n\t\texpected = objectValues( expected );\n\t\tthis.pushResult( {\n\t\t\tresult: QUnit.equiv( actual, expected ),\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tnotPropEqual: function( actual, expected, message ) {\n\t\tactual = objectValues( actual );\n\t\texpected = objectValues( expected );\n\t\tthis.pushResult( {\n\t\t\tresult: !QUnit.equiv( actual, expected ),\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message,\n\t\t\tnegative: true\n\t\t} );\n\t},\n\n\tdeepEqual: function( actual, expected, message ) {\n\t\tthis.pushResult( {\n\t\t\tresult: QUnit.equiv( actual, expected ),\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tnotDeepEqual: function( actual, expected, message ) {\n\t\tthis.pushResult( {\n\t\t\tresult: !QUnit.equiv( actual, expected ),\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message,\n\t\t\tnegative: true\n\t\t} );\n\t},\n\n\tstrictEqual: function( actual, expected, message ) {\n\t\tthis.pushResult( {\n\t\t\tresult: expected === actual,\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tnotStrictEqual: function( actual, expected, message ) {\n\t\tthis.pushResult( {\n\t\t\tresult: expected !== actual,\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message,\n\t\t\tnegative: true\n\t\t} );\n\t},\n\n\t"throws": function( block, expected, message ) {\n\t\tvar actual, expectedType,\n\t\t\texpectedOutput = expected,\n\t\t\tok = false,\n\t\t\tcurrentTest = ( this instanceof Assert && this.test ) || QUnit.config.current;\n\n\t\t// \'expected\' is optional unless doing string comparison\n\t\tif ( message == null && typeof expected === "string" ) {\n\t\t\tmessage = expected;\n\t\t\texpected = null;\n\t\t}\n\n\t\tcurrentTest.ignoreGlobalErrors = true;\n\t\ttry {\n\t\t\tblock.call( currentTest.testEnvironment );\n\t\t} catch ( e ) {\n\t\t\tactual = e;\n\t\t}\n\t\tcurrentTest.ignoreGlobalErrors = false;\n\n\t\tif ( actual ) {\n\t\t\texpectedType = QUnit.objectType( expected );\n\n\t\t\t// We don\'t want to validate thrown error\n\t\t\tif ( !expected ) {\n\t\t\t\tok = true;\n\t\t\t\texpectedOutput = null;\n\n\t\t\t// Expected is a regexp\n\t\t\t} else if ( expectedType === "regexp" ) {\n\t\t\t\tok = expected.test( errorString( actual ) );\n\n\t\t\t// Expected is a string\n\t\t\t} else if ( expectedType === "string" ) {\n\t\t\t\tok = expected === errorString( actual );\n\n\t\t\t// Expected is a constructor, maybe an Error constructor\n\t\t\t} else if ( expectedType === "function" && actual instanceof expected ) {\n\t\t\t\tok = true;\n\n\t\t\t// Expected is an Error object\n\t\t\t} else if ( expectedType === "object" ) {\n\t\t\t\tok = actual instanceof expected.constructor &&\n\t\t\t\t\tactual.name === expected.name &&\n\t\t\t\t\tactual.message === expected.message;\n\n\t\t\t// Expected is a validation function which returns true if validation passed\n\t\t\t} else if ( expectedType === "function" && expected.call( {}, actual ) === true ) {\n\t\t\t\texpectedOutput = null;\n\t\t\t\tok = true;\n\t\t\t}\n\t\t}\n\n\t\tcurrentTest.assert.pushResult( {\n\t\t\tresult: ok,\n\t\t\tactual: actual,\n\t\t\texpected: expectedOutput,\n\t\t\tmessage: message\n\t\t} );\n\t}\n};\n\n// Provide an alternative to assert.throws(), for environments that consider throws a reserved word\n// Known to us are: Closure Compiler, Narwhal\n( function() {\n\t/*jshint sub:true */\n\tAssert.prototype.raises = Assert.prototype [ "throws" ]; //jscs:ignore requireDotNotation\n}() );\n\nfunction errorString( error ) {\n\tvar name, message,\n\t\tresultErrorString = error.toString();\n\tif ( resultErrorString.substring( 0, 7 ) === "[object" ) {\n\t\tname = error.name ? error.name.toString() : "Error";\n\t\tmessage = error.message ? error.message.toString() : "";\n\t\tif ( name && message ) {\n\t\t\treturn name + ": " + message;\n\t\t} else if ( name ) {\n\t\t\treturn name;\n\t\t} else if ( message ) {\n\t\t\treturn message;\n\t\t} else {\n\t\t\treturn "Error";\n\t\t}\n\t} else {\n\t\treturn resultErrorString;\n\t}\n}\n\n// Test for equality any JavaScript type.\n// Author: Philippe Rathé <prathe@gmail.com>\nQUnit.equiv = ( function() {\n\n\t// Stack to decide between skip/abort functions\n\tvar callers = [];\n\n\t// Stack to avoiding loops from circular referencing\n\tvar parents = [];\n\tvar parentsB = [];\n\n\tvar getProto = Object.getPrototypeOf || function( obj ) {\n\n\t\t/*jshint proto: true */\n\t\treturn obj.__proto__;\n\t};\n\n\tfunction useStrictEquality( b, a ) {\n\n\t\t// To catch short annotation VS \'new\' annotation of a declaration. e.g.:\n\t\t// `var i = 1;`\n\t\t// `var j = new Number(1);`\n\t\tif ( typeof a === "object" ) {\n\t\t\ta = a.valueOf();\n\t\t}\n\t\tif ( typeof b === "object" ) {\n\t\t\tb = b.valueOf();\n\t\t}\n\n\t\treturn a === b;\n\t}\n\n\tfunction compareConstructors( a, b ) {\n\t\tvar protoA = getProto( a );\n\t\tvar protoB = getProto( b );\n\n\t\t// Comparing constructors is more strict than using `instanceof`\n\t\tif ( a.constructor === b.constructor ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Ref #851\n\t\t// If the obj prototype descends from a null constructor, treat it\n\t\t// as a null prototype.\n\t\tif ( protoA && protoA.constructor === null ) {\n\t\t\tprotoA = null;\n\t\t}\n\t\tif ( protoB && protoB.constructor === null ) {\n\t\t\tprotoB = null;\n\t\t}\n\n\t\t// Allow objects with no prototype to be equivalent to\n\t\t// objects with Object as their constructor.\n\t\tif ( ( protoA === null && protoB === Object.prototype ) ||\n\t\t\t\t( protoB === null && protoA === Object.prototype ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tfunction getRegExpFlags( regexp ) {\n\t\treturn "flags" in regexp ? regexp.flags : regexp.toString().match( /[gimuy]*$/ )[ 0 ];\n\t}\n\n\tvar callbacks = {\n\t\t"string": useStrictEquality,\n\t\t"boolean": useStrictEquality,\n\t\t"number": useStrictEquality,\n\t\t"null": useStrictEquality,\n\t\t"undefined": useStrictEquality,\n\t\t"symbol": useStrictEquality,\n\t\t"date": useStrictEquality,\n\n\t\t"nan": function() {\n\t\t\treturn true;\n\t\t},\n\n\t\t"regexp": function( b, a ) {\n\t\t\treturn a.source === b.source &&\n\n\t\t\t\t// Include flags in the comparison\n\t\t\t\tgetRegExpFlags( a ) === getRegExpFlags( b );\n\t\t},\n\n\t\t// - skip when the property is a method of an instance (OOP)\n\t\t// - abort otherwise,\n\t\t// initial === would have catch identical references anyway\n\t\t"function": function() {\n\t\t\tvar caller = callers[ callers.length - 1 ];\n\t\t\treturn caller !== Object && typeof caller !== "undefined";\n\t\t},\n\n\t\t"array": function( b, a ) {\n\t\t\tvar i, j, len, loop, aCircular, bCircular;\n\n\t\t\tlen = a.length;\n\t\t\tif ( len !== b.length ) {\n\n\t\t\t\t// Safe and faster\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Track reference to avoid circular references\n\t\t\tparents.push( a );\n\t\t\tparentsB.push( b );\n\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\tloop = false;\n\t\t\t\tfor ( j = 0; j < parents.length; j++ ) {\n\t\t\t\t\taCircular = parents[ j ] === a[ i ];\n\t\t\t\t\tbCircular = parentsB[ j ] === b[ i ];\n\t\t\t\t\tif ( aCircular || bCircular ) {\n\t\t\t\t\t\tif ( a[ i ] === b[ i ] || aCircular && bCircular ) {\n\t\t\t\t\t\t\tloop = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tparents.pop();\n\t\t\t\t\t\t\tparentsB.pop();\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( !loop && !innerEquiv( a[ i ], b[ i ] ) ) {\n\t\t\t\t\tparents.pop();\n\t\t\t\t\tparentsB.pop();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tparents.pop();\n\t\t\tparentsB.pop();\n\t\t\treturn true;\n\t\t},\n\n\t\t"set": function( b, a ) {\n\t\t\tvar innerEq,\n\t\t\t\touterEq = true;\n\n\t\t\tif ( a.size !== b.size ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\ta.forEach( function( aVal ) {\n\t\t\t\tinnerEq = false;\n\n\t\t\t\tb.forEach( function( bVal ) {\n\t\t\t\t\tif ( innerEquiv( bVal, aVal ) ) {\n\t\t\t\t\t\tinnerEq = true;\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\tif ( !innerEq ) {\n\t\t\t\t\touterEq = false;\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\treturn outerEq;\n\t\t},\n\n\t\t"map": function( b, a ) {\n\t\t\tvar innerEq,\n\t\t\t\touterEq = true;\n\n\t\t\tif ( a.size !== b.size ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\ta.forEach( function( aVal, aKey ) {\n\t\t\t\tinnerEq = false;\n\n\t\t\t\tb.forEach( function( bVal, bKey ) {\n\t\t\t\t\tif ( innerEquiv( [ bVal, bKey ], [ aVal, aKey ] ) ) {\n\t\t\t\t\t\tinnerEq = true;\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\tif ( !innerEq ) {\n\t\t\t\t\touterEq = false;\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\treturn outerEq;\n\t\t},\n\n\t\t"object": function( b, a ) {\n\t\t\tvar i, j, loop, aCircular, bCircular;\n\n\t\t\t// Default to true\n\t\t\tvar eq = true;\n\t\t\tvar aProperties = [];\n\t\t\tvar bProperties = [];\n\n\t\t\tif ( compareConstructors( a, b ) === false ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Stack constructor before traversing properties\n\t\t\tcallers.push( a.constructor );\n\n\t\t\t// Track reference to avoid circular references\n\t\t\tparents.push( a );\n\t\t\tparentsB.push( b );\n\n\t\t\t// Be strict: don\'t ensure hasOwnProperty and go deep\n\t\t\tfor ( i in a ) {\n\t\t\t\tloop = false;\n\t\t\t\tfor ( j = 0; j < parents.length; j++ ) {\n\t\t\t\t\taCircular = parents[ j ] === a[ i ];\n\t\t\t\t\tbCircular = parentsB[ j ] === b[ i ];\n\t\t\t\t\tif ( aCircular || bCircular ) {\n\t\t\t\t\t\tif ( a[ i ] === b[ i ] || aCircular && bCircular ) {\n\t\t\t\t\t\t\tloop = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\teq = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taProperties.push( i );\n\t\t\t\tif ( !loop && !innerEquiv( a[ i ], b[ i ] ) ) {\n\t\t\t\t\teq = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tparents.pop();\n\t\t\tparentsB.pop();\n\n\t\t\t// Unstack, we are done\n\t\t\tcallers.pop();\n\n\t\t\tfor ( i in b ) {\n\n\t\t\t\t// Collect b\'s properties\n\t\t\t\tbProperties.push( i );\n\t\t\t}\n\n\t\t\t// Ensures identical properties name\n\t\t\treturn eq && innerEquiv( aProperties.sort(), bProperties.sort() );\n\t\t}\n\t};\n\n\tfunction typeEquiv( a, b ) {\n\t\tvar type = QUnit.objectType( a );\n\t\treturn QUnit.objectType( b ) === type && callbacks[ type ]( b, a );\n\t}\n\n\t// The real equiv function\n\tfunction innerEquiv( a, b ) {\n\n\t\t// We\'re done when there\'s nothing more to compare\n\t\tif ( arguments.length < 2 ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Require type-specific equality\n\t\treturn ( a === b || typeEquiv( a, b ) ) &&\n\n\t\t\t// ...across all consecutive argument pairs\n\t\t\t( arguments.length === 2 || innerEquiv.apply( this, [].slice.call( arguments, 1 ) ) );\n\t}\n\n\treturn innerEquiv;\n}() );\n\n// Based on jsDump by Ariel Flesler\n// http://flesler.blogspot.com/2008/05/jsdump-pretty-dump-of-any-javascript.html\nQUnit.dump = ( function() {\n\tfunction quote( str ) {\n\t\treturn "\\"" + str.toString().replace( /\\\\/g, "\\\\\\\\" ).replace( /"/g, "\\\\\\"" ) + "\\"";\n\t}\n\tfunction literal( o ) {\n\t\treturn o + "";\n\t}\n\tfunction join( pre, arr, post ) {\n\t\tvar s = dump.separator(),\n\t\t\tbase = dump.indent(),\n\t\t\tinner = dump.indent( 1 );\n\t\tif ( arr.join ) {\n\t\t\tarr = arr.join( "," + s + inner );\n\t\t}\n\t\tif ( !arr ) {\n\t\t\treturn pre + post;\n\t\t}\n\t\treturn [ pre, inner + arr, base + post ].join( s );\n\t}\n\tfunction array( arr, stack ) {\n\t\tvar i = arr.length,\n\t\t\tret = new Array( i );\n\n\t\tif ( dump.maxDepth && dump.depth > dump.maxDepth ) {\n\t\t\treturn "[object Array]";\n\t\t}\n\n\t\tthis.up();\n\t\twhile ( i-- ) {\n\t\t\tret[ i ] = this.parse( arr[ i ], undefined, stack );\n\t\t}\n\t\tthis.down();\n\t\treturn join( "[", ret, "]" );\n\t}\n\n\tvar reName = /^function (\\w+)/,\n\t\tdump = {\n\n\t\t\t// The objType is used mostly internally, you can fix a (custom) type in advance\n\t\t\tparse: function( obj, objType, stack ) {\n\t\t\t\tstack = stack || [];\n\t\t\t\tvar res, parser, parserType,\n\t\t\t\t\tinStack = inArray( obj, stack );\n\n\t\t\t\tif ( inStack !== -1 ) {\n\t\t\t\t\treturn "recursion(" + ( inStack - stack.length ) + ")";\n\t\t\t\t}\n\n\t\t\t\tobjType = objType || this.typeOf( obj  );\n\t\t\t\tparser = this.parsers[ objType ];\n\t\t\t\tparserType = typeof parser;\n\n\t\t\t\tif ( parserType === "function" ) {\n\t\t\t\t\tstack.push( obj );\n\t\t\t\t\tres = parser.call( this, obj, stack );\n\t\t\t\t\tstack.pop();\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\treturn ( parserType === "string" ) ? parser : this.parsers.error;\n\t\t\t},\n\t\t\ttypeOf: function( obj ) {\n\t\t\t\tvar type;\n\t\t\t\tif ( obj === null ) {\n\t\t\t\t\ttype = "null";\n\t\t\t\t} else if ( typeof obj === "undefined" ) {\n\t\t\t\t\ttype = "undefined";\n\t\t\t\t} else if ( QUnit.is( "regexp", obj ) ) {\n\t\t\t\t\ttype = "regexp";\n\t\t\t\t} else if ( QUnit.is( "date", obj ) ) {\n\t\t\t\t\ttype = "date";\n\t\t\t\t} else if ( QUnit.is( "function", obj ) ) {\n\t\t\t\t\ttype = "function";\n\t\t\t\t} else if ( obj.setInterval !== undefined &&\n\t\t\t\t\t\tobj.document !== undefined &&\n\t\t\t\t\t\tobj.nodeType === undefined ) {\n\t\t\t\t\ttype = "window";\n\t\t\t\t} else if ( obj.nodeType === 9 ) {\n\t\t\t\t\ttype = "document";\n\t\t\t\t} else if ( obj.nodeType ) {\n\t\t\t\t\ttype = "node";\n\t\t\t\t} else if (\n\n\t\t\t\t\t// Native arrays\n\t\t\t\t\ttoString.call( obj ) === "[object Array]" ||\n\n\t\t\t\t\t// NodeList objects\n\t\t\t\t\t( typeof obj.length === "number" && obj.item !== undefined &&\n\t\t\t\t\t( obj.length ? obj.item( 0 ) === obj[ 0 ] : ( obj.item( 0 ) === null &&\n\t\t\t\t\tobj[ 0 ] === undefined ) ) )\n\t\t\t\t) {\n\t\t\t\t\ttype = "array";\n\t\t\t\t} else if ( obj.constructor === Error.prototype.constructor ) {\n\t\t\t\t\ttype = "error";\n\t\t\t\t} else {\n\t\t\t\t\ttype = typeof obj;\n\t\t\t\t}\n\t\t\t\treturn type;\n\t\t\t},\n\n\t\t\tseparator: function() {\n\t\t\t\treturn this.multiline ? this.HTML ? "<br />" : "\\n" : this.HTML ? "&#160;" : " ";\n\t\t\t},\n\n\t\t\t// Extra can be a number, shortcut for increasing-calling-decreasing\n\t\t\tindent: function( extra ) {\n\t\t\t\tif ( !this.multiline ) {\n\t\t\t\t\treturn "";\n\t\t\t\t}\n\t\t\t\tvar chr = this.indentChar;\n\t\t\t\tif ( this.HTML ) {\n\t\t\t\t\tchr = chr.replace( /\\t/g, "   " ).replace( / /g, "&#160;" );\n\t\t\t\t}\n\t\t\t\treturn new Array( this.depth + ( extra || 0 ) ).join( chr );\n\t\t\t},\n\t\t\tup: function( a ) {\n\t\t\t\tthis.depth += a || 1;\n\t\t\t},\n\t\t\tdown: function( a ) {\n\t\t\t\tthis.depth -= a || 1;\n\t\t\t},\n\t\t\tsetParser: function( name, parser ) {\n\t\t\t\tthis.parsers[ name ] = parser;\n\t\t\t},\n\n\t\t\t// The next 3 are exposed so you can use them\n\t\t\tquote: quote,\n\t\t\tliteral: literal,\n\t\t\tjoin: join,\n\t\t\tdepth: 1,\n\t\t\tmaxDepth: QUnit.config.maxDepth,\n\n\t\t\t// This is the list of parsers, to modify them, use dump.setParser\n\t\t\tparsers: {\n\t\t\t\twindow: "[Window]",\n\t\t\t\tdocument: "[Document]",\n\t\t\t\terror: function( error ) {\n\t\t\t\t\treturn "Error(\\"" + error.message + "\\")";\n\t\t\t\t},\n\t\t\t\tunknown: "[Unknown]",\n\t\t\t\t"null": "null",\n\t\t\t\t"undefined": "undefined",\n\t\t\t\t"function": function( fn ) {\n\t\t\t\t\tvar ret = "function",\n\n\t\t\t\t\t\t// Functions never have name in IE\n\t\t\t\t\t\tname = "name" in fn ? fn.name : ( reName.exec( fn ) || [] )[ 1 ];\n\n\t\t\t\t\tif ( name ) {\n\t\t\t\t\t\tret += " " + name;\n\t\t\t\t\t}\n\t\t\t\t\tret += "(";\n\n\t\t\t\t\tret = [ ret, dump.parse( fn, "functionArgs" ), "){" ].join( "" );\n\t\t\t\t\treturn join( ret, dump.parse( fn, "functionCode" ), "}" );\n\t\t\t\t},\n\t\t\t\tarray: array,\n\t\t\t\tnodelist: array,\n\t\t\t\t"arguments": array,\n\t\t\t\tobject: function( map, stack ) {\n\t\t\t\t\tvar keys, key, val, i, nonEnumerableProperties,\n\t\t\t\t\t\tret = [];\n\n\t\t\t\t\tif ( dump.maxDepth && dump.depth > dump.maxDepth ) {\n\t\t\t\t\t\treturn "[object Object]";\n\t\t\t\t\t}\n\n\t\t\t\t\tdump.up();\n\t\t\t\t\tkeys = [];\n\t\t\t\t\tfor ( key in map ) {\n\t\t\t\t\t\tkeys.push( key );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Some properties are not always enumerable on Error objects.\n\t\t\t\t\tnonEnumerableProperties = [ "message", "name" ];\n\t\t\t\t\tfor ( i in nonEnumerableProperties ) {\n\t\t\t\t\t\tkey = nonEnumerableProperties[ i ];\n\t\t\t\t\t\tif ( key in map && inArray( key, keys ) < 0 ) {\n\t\t\t\t\t\t\tkeys.push( key );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tkeys.sort();\n\t\t\t\t\tfor ( i = 0; i < keys.length; i++ ) {\n\t\t\t\t\t\tkey = keys[ i ];\n\t\t\t\t\t\tval = map[ key ];\n\t\t\t\t\t\tret.push( dump.parse( key, "key" ) + ": " +\n\t\t\t\t\t\t\tdump.parse( val, undefined, stack ) );\n\t\t\t\t\t}\n\t\t\t\t\tdump.down();\n\t\t\t\t\treturn join( "{", ret, "}" );\n\t\t\t\t},\n\t\t\t\tnode: function( node ) {\n\t\t\t\t\tvar len, i, val,\n\t\t\t\t\t\topen = dump.HTML ? "&lt;" : "<",\n\t\t\t\t\t\tclose = dump.HTML ? "&gt;" : ">",\n\t\t\t\t\t\ttag = node.nodeName.toLowerCase(),\n\t\t\t\t\t\tret = open + tag,\n\t\t\t\t\t\tattrs = node.attributes;\n\n\t\t\t\t\tif ( attrs ) {\n\t\t\t\t\t\tfor ( i = 0, len = attrs.length; i < len; i++ ) {\n\t\t\t\t\t\t\tval = attrs[ i ].nodeValue;\n\n\t\t\t\t\t\t\t// IE6 includes all attributes in .attributes, even ones not explicitly\n\t\t\t\t\t\t\t// set. Those have values like undefined, null, 0, false, "" or\n\t\t\t\t\t\t\t// "inherit".\n\t\t\t\t\t\t\tif ( val && val !== "inherit" ) {\n\t\t\t\t\t\t\t\tret += " " + attrs[ i ].nodeName + "=" +\n\t\t\t\t\t\t\t\t\tdump.parse( val, "attribute" );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tret += close;\n\n\t\t\t\t\t// Show content of TextNode or CDATASection\n\t\t\t\t\tif ( node.nodeType === 3 || node.nodeType === 4 ) {\n\t\t\t\t\t\tret += node.nodeValue;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn ret + open + "/" + tag + close;\n\t\t\t\t},\n\n\t\t\t\t// Function calls it internally, it\'s the arguments part of the function\n\t\t\t\tfunctionArgs: function( fn ) {\n\t\t\t\t\tvar args,\n\t\t\t\t\t\tl = fn.length;\n\n\t\t\t\t\tif ( !l ) {\n\t\t\t\t\t\treturn "";\n\t\t\t\t\t}\n\n\t\t\t\t\targs = new Array( l );\n\t\t\t\t\twhile ( l-- ) {\n\n\t\t\t\t\t\t// 97 is \'a\'\n\t\t\t\t\t\targs[ l ] = String.fromCharCode( 97 + l );\n\t\t\t\t\t}\n\t\t\t\t\treturn " " + args.join( ", " ) + " ";\n\t\t\t\t},\n\n\t\t\t\t// Object calls it internally, the key part of an item in a map\n\t\t\t\tkey: quote,\n\n\t\t\t\t// Function calls it internally, it\'s the content of the function\n\t\t\t\tfunctionCode: "[code]",\n\n\t\t\t\t// Node calls it internally, it\'s a html attribute value\n\t\t\t\tattribute: quote,\n\t\t\t\tstring: quote,\n\t\t\t\tdate: quote,\n\t\t\t\tregexp: literal,\n\t\t\t\tnumber: literal,\n\t\t\t\t"boolean": literal\n\t\t\t},\n\n\t\t\t// If true, entities are escaped ( <, >, \\t, space and \\n )\n\t\t\tHTML: false,\n\n\t\t\t// Indentation unit\n\t\t\tindentChar: "  ",\n\n\t\t\t// If true, items in a collection, are separated by a \\n, else just a space.\n\t\t\tmultiline: true\n\t\t};\n\n\treturn dump;\n}() );\n\n// Back compat\nQUnit.jsDump = QUnit.dump;\n\n// Deprecated\n// Extend assert methods to QUnit for Backwards compatibility\n( function() {\n\tvar i,\n\t\tassertions = Assert.prototype;\n\n\tfunction applyCurrent( current ) {\n\t\treturn function() {\n\t\t\tvar assert = new Assert( QUnit.config.current );\n\t\t\tcurrent.apply( assert, arguments );\n\t\t};\n\t}\n\n\tfor ( i in assertions ) {\n\t\tQUnit[ i ] = applyCurrent( assertions[ i ] );\n\t}\n}() );\n\n// For browser, export only select globals\nif ( defined.document ) {\n\n\t( function() {\n\t\tvar i, l,\n\t\t\tkeys = [\n\t\t\t\t"test",\n\t\t\t\t"module",\n\t\t\t\t"expect",\n\t\t\t\t"asyncTest",\n\t\t\t\t"start",\n\t\t\t\t"stop",\n\t\t\t\t"ok",\n\t\t\t\t"notOk",\n\t\t\t\t"equal",\n\t\t\t\t"notEqual",\n\t\t\t\t"propEqual",\n\t\t\t\t"notPropEqual",\n\t\t\t\t"deepEqual",\n\t\t\t\t"notDeepEqual",\n\t\t\t\t"strictEqual",\n\t\t\t\t"notStrictEqual",\n\t\t\t\t"throws",\n\t\t\t\t"raises"\n\t\t\t];\n\n\t\tfor ( i = 0, l = keys.length; i < l; i++ ) {\n\t\t\twindow[ keys[ i ] ] = QUnit[ keys[ i ] ];\n\t\t}\n\t}() );\n\n\twindow.QUnit = QUnit;\n}\n\n// For nodejs\nif ( typeof module !== "undefined" && module && module.exports ) {\n\tmodule.exports = QUnit;\n\n\t// For consistency with CommonJS environments\' exports\n\tmodule.exports.QUnit = QUnit;\n}\n\n// For CommonJS with exports, but without module.exports, like Rhino\nif ( typeof exports !== "undefined" && exports ) {\n\texports.QUnit = QUnit;\n}\n\nif ( typeof define === "function" && define.amd ) {\n\tdefine( function() {\n\t\treturn QUnit;\n\t} );\n\tQUnit.config.autostart = false;\n}\n\n// Get a reference to the global object, like window in browsers\n}( ( function() {\n\treturn this;\n}() ) ) );\n\n( function() {\n\n// Only interact with URLs via window.location\nvar location = typeof window !== "undefined" && window.location;\nif ( !location ) {\n\treturn;\n}\n\nvar urlParams = getUrlParams();\n\nQUnit.urlParams = urlParams;\n\n// Match module/test by inclusion in an array\nQUnit.config.moduleId = [].concat( urlParams.moduleId || [] );\nQUnit.config.testId = [].concat( urlParams.testId || [] );\n\n// Exact case-insensitive match of the module name\nQUnit.config.module = urlParams.module;\n\n// Regular expression or case-insenstive substring match against "moduleName: testName"\nQUnit.config.filter = urlParams.filter;\n\n// Test order randomization\nif ( urlParams.seed === true ) {\n\n\t// Generate a random seed if the option is specified without a value\n\tQUnit.config.seed = Math.random().toString( 36 ).slice( 2 );\n} else if ( urlParams.seed ) {\n\tQUnit.config.seed = urlParams.seed;\n}\n\n// Add URL-parameter-mapped config values with UI form rendering data\nQUnit.config.urlConfig.push(\n\t{\n\t\tid: "hidepassed",\n\t\tlabel: "Hide passed tests",\n\t\ttooltip: "Only show tests and assertions that fail. Stored as query-strings."\n\t},\n\t{\n\t\tid: "noglobals",\n\t\tlabel: "Check for Globals",\n\t\ttooltip: "Enabling this will test if any test introduces new properties on the " +\n\t\t\t"global object (`window` in Browsers). Stored as query-strings."\n\t},\n\t{\n\t\tid: "notrycatch",\n\t\tlabel: "No try-catch",\n\t\ttooltip: "Enabling this will run tests outside of a try-catch block. Makes debugging " +\n\t\t\t"exceptions in IE reasonable. Stored as query-strings."\n\t}\n);\n\nQUnit.begin( function() {\n\tvar i, option,\n\t\turlConfig = QUnit.config.urlConfig;\n\n\tfor ( i = 0; i < urlConfig.length; i++ ) {\n\n\t\t// Options can be either strings or objects with nonempty "id" properties\n\t\toption = QUnit.config.urlConfig[ i ];\n\t\tif ( typeof option !== "string" ) {\n\t\t\toption = option.id;\n\t\t}\n\n\t\tif ( QUnit.config[ option ] === undefined ) {\n\t\t\tQUnit.config[ option ] = urlParams[ option ];\n\t\t}\n\t}\n} );\n\nfunction getUrlParams() {\n\tvar i, param, name, value;\n\tvar urlParams = {};\n\tvar params = location.search.slice( 1 ).split( "&" );\n\tvar length = params.length;\n\n\tfor ( i = 0; i < length; i++ ) {\n\t\tif ( params[ i ] ) {\n\t\t\tparam = params[ i ].split( "=" );\n\t\t\tname = decodeURIComponent( param[ 0 ] );\n\n\t\t\t// Allow just a key to turn on a flag, e.g., test.html?noglobals\n\t\t\tvalue = param.length === 1 ||\n\t\t\t\tdecodeURIComponent( param.slice( 1 ).join( "=" ) ) ;\n\t\t\tif ( urlParams[ name ] ) {\n\t\t\t\turlParams[ name ] = [].concat( urlParams[ name ], value );\n\t\t\t} else {\n\t\t\t\turlParams[ name ] = value;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn urlParams;\n}\n\n// Don\'t load the HTML Reporter on non-browser environments\nif ( typeof window === "undefined" || !window.document ) {\n\treturn;\n}\n\n// Deprecated QUnit.init - Ref #530\n// Re-initialize the configuration options\nQUnit.init = function() {\n\tvar config = QUnit.config;\n\n\tconfig.stats = { all: 0, bad: 0 };\n\tconfig.moduleStats = { all: 0, bad: 0 };\n\tconfig.started = 0;\n\tconfig.updateRate = 1000;\n\tconfig.blocking = false;\n\tconfig.autostart = true;\n\tconfig.autorun = false;\n\tconfig.filter = "";\n\tconfig.queue = [];\n\n\tappendInterface();\n};\n\nvar config = QUnit.config,\n\tdocument = window.document,\n\tcollapseNext = false,\n\thasOwn = Object.prototype.hasOwnProperty,\n\tunfilteredUrl = setUrl( { filter: undefined, module: undefined,\n\t\tmoduleId: undefined, testId: undefined } ),\n\tdefined = {\n\t\tsessionStorage: ( function() {\n\t\t\tvar x = "qunit-test-string";\n\t\t\ttry {\n\t\t\t\tsessionStorage.setItem( x, x );\n\t\t\t\tsessionStorage.removeItem( x );\n\t\t\t\treturn true;\n\t\t\t} catch ( e ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}() )\n\t},\n\tmodulesList = [];\n\n/**\n* Escape text for attribute or text content.\n*/\nfunction escapeText( s ) {\n\tif ( !s ) {\n\t\treturn "";\n\t}\n\ts = s + "";\n\n\t// Both single quotes and double quotes (for attributes)\n\treturn s.replace( /[\'"<>&]/g, function( s ) {\n\t\tswitch ( s ) {\n\t\tcase "\'":\n\t\t\treturn "&#039;";\n\t\tcase "\\"":\n\t\t\treturn "&quot;";\n\t\tcase "<":\n\t\t\treturn "&lt;";\n\t\tcase ">":\n\t\t\treturn "&gt;";\n\t\tcase "&":\n\t\t\treturn "&amp;";\n\t\t}\n\t} );\n}\n\n/**\n * @param {HTMLElement} elem\n * @param {string} type\n * @param {Function} fn\n */\nfunction addEvent( elem, type, fn ) {\n\tif ( elem.addEventListener ) {\n\n\t\t// Standards-based browsers\n\t\telem.addEventListener( type, fn, false );\n\t} else if ( elem.attachEvent ) {\n\n\t\t// Support: IE <9\n\t\telem.attachEvent( "on" + type, function() {\n\t\t\tvar event = window.event;\n\t\t\tif ( !event.target ) {\n\t\t\t\tevent.target = event.srcElement || document;\n\t\t\t}\n\n\t\t\tfn.call( elem, event );\n\t\t} );\n\t}\n}\n\n/**\n * @param {Array|NodeList} elems\n * @param {string} type\n * @param {Function} fn\n */\nfunction addEvents( elems, type, fn ) {\n\tvar i = elems.length;\n\twhile ( i-- ) {\n\t\taddEvent( elems[ i ], type, fn );\n\t}\n}\n\nfunction hasClass( elem, name ) {\n\treturn ( " " + elem.className + " " ).indexOf( " " + name + " " ) >= 0;\n}\n\nfunction addClass( elem, name ) {\n\tif ( !hasClass( elem, name ) ) {\n\t\telem.className += ( elem.className ? " " : "" ) + name;\n\t}\n}\n\nfunction toggleClass( elem, name, force ) {\n\tif ( force || typeof force === "undefined" && !hasClass( elem, name ) ) {\n\t\taddClass( elem, name );\n\t} else {\n\t\tremoveClass( elem, name );\n\t}\n}\n\nfunction removeClass( elem, name ) {\n\tvar set = " " + elem.className + " ";\n\n\t// Class name may appear multiple times\n\twhile ( set.indexOf( " " + name + " " ) >= 0 ) {\n\t\tset = set.replace( " " + name + " ", " " );\n\t}\n\n\t// Trim for prettiness\n\telem.className = typeof set.trim === "function" ? set.trim() : set.replace( /^\\s+|\\s+$/g, "" );\n}\n\nfunction id( name ) {\n\treturn document.getElementById && document.getElementById( name );\n}\n\nfunction getUrlConfigHtml() {\n\tvar i, j, val,\n\t\tescaped, escapedTooltip,\n\t\tselection = false,\n\t\turlConfig = config.urlConfig,\n\t\turlConfigHtml = "";\n\n\tfor ( i = 0; i < urlConfig.length; i++ ) {\n\n\t\t// Options can be either strings or objects with nonempty "id" properties\n\t\tval = config.urlConfig[ i ];\n\t\tif ( typeof val === "string" ) {\n\t\t\tval = {\n\t\t\t\tid: val,\n\t\t\t\tlabel: val\n\t\t\t};\n\t\t}\n\n\t\tescaped = escapeText( val.id );\n\t\tescapedTooltip = escapeText( val.tooltip );\n\n\t\tif ( !val.value || typeof val.value === "string" ) {\n\t\t\turlConfigHtml += "<input id=\'qunit-urlconfig-" + escaped +\n\t\t\t\t"\' name=\'" + escaped + "\' type=\'checkbox\'" +\n\t\t\t\t( val.value ? " value=\'" + escapeText( val.value ) + "\'" : "" ) +\n\t\t\t\t( config[ val.id ] ? " checked=\'checked\'" : "" ) +\n\t\t\t\t" title=\'" + escapedTooltip + "\' /><label for=\'qunit-urlconfig-" + escaped +\n\t\t\t\t"\' title=\'" + escapedTooltip + "\'>" + val.label + "</label>";\n\t\t} else {\n\t\t\turlConfigHtml += "<label for=\'qunit-urlconfig-" + escaped +\n\t\t\t\t"\' title=\'" + escapedTooltip + "\'>" + val.label +\n\t\t\t\t": </label><select id=\'qunit-urlconfig-" + escaped +\n\t\t\t\t"\' name=\'" + escaped + "\' title=\'" + escapedTooltip + "\'><option></option>";\n\n\t\t\tif ( QUnit.is( "array", val.value ) ) {\n\t\t\t\tfor ( j = 0; j < val.value.length; j++ ) {\n\t\t\t\t\tescaped = escapeText( val.value[ j ] );\n\t\t\t\t\turlConfigHtml += "<option value=\'" + escaped + "\'" +\n\t\t\t\t\t\t( config[ val.id ] === val.value[ j ] ?\n\t\t\t\t\t\t\t( selection = true ) && " selected=\'selected\'" : "" ) +\n\t\t\t\t\t\t">" + escaped + "</option>";\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( j in val.value ) {\n\t\t\t\t\tif ( hasOwn.call( val.value, j ) ) {\n\t\t\t\t\t\turlConfigHtml += "<option value=\'" + escapeText( j ) + "\'" +\n\t\t\t\t\t\t\t( config[ val.id ] === j ?\n\t\t\t\t\t\t\t\t( selection = true ) && " selected=\'selected\'" : "" ) +\n\t\t\t\t\t\t\t">" + escapeText( val.value[ j ] ) + "</option>";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( config[ val.id ] && !selection ) {\n\t\t\t\tescaped = escapeText( config[ val.id ] );\n\t\t\t\turlConfigHtml += "<option value=\'" + escaped +\n\t\t\t\t\t"\' selected=\'selected\' disabled=\'disabled\'>" + escaped + "</option>";\n\t\t\t}\n\t\t\turlConfigHtml += "</select>";\n\t\t}\n\t}\n\n\treturn urlConfigHtml;\n}\n\n// Handle "click" events on toolbar checkboxes and "change" for select menus.\n// Updates the URL with the new state of `config.urlConfig` values.\nfunction toolbarChanged() {\n\tvar updatedUrl, value, tests,\n\t\tfield = this,\n\t\tparams = {};\n\n\t// Detect if field is a select menu or a checkbox\n\tif ( "selectedIndex" in field ) {\n\t\tvalue = field.options[ field.selectedIndex ].value || undefined;\n\t} else {\n\t\tvalue = field.checked ? ( field.defaultValue || true ) : undefined;\n\t}\n\n\tparams[ field.name ] = value;\n\tupdatedUrl = setUrl( params );\n\n\t// Check if we can apply the change without a page refresh\n\tif ( "hidepassed" === field.name && "replaceState" in window.history ) {\n\t\tQUnit.urlParams[ field.name ] = value;\n\t\tconfig[ field.name ] = value || false;\n\t\ttests = id( "qunit-tests" );\n\t\tif ( tests ) {\n\t\t\ttoggleClass( tests, "hidepass", value || false );\n\t\t}\n\t\twindow.history.replaceState( null, "", updatedUrl );\n\t} else {\n\t\twindow.location = updatedUrl;\n\t}\n}\n\nfunction setUrl( params ) {\n\tvar key, arrValue, i,\n\t\tquerystring = "?",\n\t\tlocation = window.location;\n\n\tparams = QUnit.extend( QUnit.extend( {}, QUnit.urlParams ), params );\n\n\tfor ( key in params ) {\n\n\t\t// Skip inherited or undefined properties\n\t\tif ( hasOwn.call( params, key ) && params[ key ] !== undefined ) {\n\n\t\t\t// Output a parameter for each value of this key (but usually just one)\n\t\t\tarrValue = [].concat( params[ key ] );\n\t\t\tfor ( i = 0; i < arrValue.length; i++ ) {\n\t\t\t\tquerystring += encodeURIComponent( key );\n\t\t\t\tif ( arrValue[ i ] !== true ) {\n\t\t\t\t\tquerystring += "=" + encodeURIComponent( arrValue[ i ] );\n\t\t\t\t}\n\t\t\t\tquerystring += "&";\n\t\t\t}\n\t\t}\n\t}\n\treturn location.protocol + "//" + location.host +\n\t\tlocation.pathname + querystring.slice( 0, -1 );\n}\n\nfunction applyUrlParams() {\n\tvar selectedModule,\n\t\tmodulesList = id( "qunit-modulefilter" ),\n\t\tfilter = id( "qunit-filter-input" ).value;\n\n\tselectedModule = modulesList ?\n\t\tdecodeURIComponent( modulesList.options[ modulesList.selectedIndex ].value ) :\n\t\tundefined;\n\n\twindow.location = setUrl( {\n\t\tmodule: ( selectedModule === "" ) ? undefined : selectedModule,\n\t\tfilter: ( filter === "" ) ? undefined : filter,\n\n\t\t// Remove moduleId and testId filters\n\t\tmoduleId: undefined,\n\t\ttestId: undefined\n\t} );\n}\n\nfunction toolbarUrlConfigContainer() {\n\tvar urlConfigContainer = document.createElement( "span" );\n\n\turlConfigContainer.innerHTML = getUrlConfigHtml();\n\taddClass( urlConfigContainer, "qunit-url-config" );\n\n\t// For oldIE support:\n\t// * Add handlers to the individual elements instead of the container\n\t// * Use "click" instead of "change" for checkboxes\n\taddEvents( urlConfigContainer.getElementsByTagName( "input" ), "click", toolbarChanged );\n\taddEvents( urlConfigContainer.getElementsByTagName( "select" ), "change", toolbarChanged );\n\n\treturn urlConfigContainer;\n}\n\nfunction toolbarLooseFilter() {\n\tvar filter = document.createElement( "form" ),\n\t\tlabel = document.createElement( "label" ),\n\t\tinput = document.createElement( "input" ),\n\t\tbutton = document.createElement( "button" );\n\n\taddClass( filter, "qunit-filter" );\n\n\tlabel.innerHTML = "Filter: ";\n\n\tinput.type = "text";\n\tinput.value = config.filter || "";\n\tinput.name = "filter";\n\tinput.id = "qunit-filter-input";\n\n\tbutton.innerHTML = "Go";\n\n\tlabel.appendChild( input );\n\n\tfilter.appendChild( label );\n\tfilter.appendChild( button );\n\taddEvent( filter, "submit", function( ev ) {\n\t\tapplyUrlParams();\n\n\t\tif ( ev && ev.preventDefault ) {\n\t\t\tev.preventDefault();\n\t\t}\n\n\t\treturn false;\n\t} );\n\n\treturn filter;\n}\n\nfunction toolbarModuleFilterHtml() {\n\tvar i,\n\t\tmoduleFilterHtml = "";\n\n\tif ( !modulesList.length ) {\n\t\treturn false;\n\t}\n\n\tmoduleFilterHtml += "<label for=\'qunit-modulefilter\'>Module: </label>" +\n\t\t"<select id=\'qunit-modulefilter\' name=\'modulefilter\'><option value=\'\' " +\n\t\t( QUnit.urlParams.module === undefined ? "selected=\'selected\'" : "" ) +\n\t\t">< All Modules ></option>";\n\n\tfor ( i = 0; i < modulesList.length; i++ ) {\n\t\tmoduleFilterHtml += "<option value=\'" +\n\t\t\tescapeText( encodeURIComponent( modulesList[ i ] ) ) + "\' " +\n\t\t\t( QUnit.urlParams.module === modulesList[ i ] ? "selected=\'selected\'" : "" ) +\n\t\t\t">" + escapeText( modulesList[ i ] ) + "</option>";\n\t}\n\tmoduleFilterHtml += "</select>";\n\n\treturn moduleFilterHtml;\n}\n\nfunction toolbarModuleFilter() {\n\tvar toolbar = id( "qunit-testrunner-toolbar" ),\n\t\tmoduleFilter = document.createElement( "span" ),\n\t\tmoduleFilterHtml = toolbarModuleFilterHtml();\n\n\tif ( !toolbar || !moduleFilterHtml ) {\n\t\treturn false;\n\t}\n\n\tmoduleFilter.setAttribute( "id", "qunit-modulefilter-container" );\n\tmoduleFilter.innerHTML = moduleFilterHtml;\n\n\taddEvent( moduleFilter.lastChild, "change", applyUrlParams );\n\n\ttoolbar.appendChild( moduleFilter );\n}\n\nfunction appendToolbar() {\n\tvar toolbar = id( "qunit-testrunner-toolbar" );\n\n\tif ( toolbar ) {\n\t\ttoolbar.appendChild( toolbarUrlConfigContainer() );\n\t\ttoolbar.appendChild( toolbarLooseFilter() );\n\t\ttoolbarModuleFilter();\n\t}\n}\n\nfunction appendHeader() {\n\tvar header = id( "qunit-header" );\n\n\tif ( header ) {\n\t\theader.innerHTML = "<a href=\'" + escapeText( unfilteredUrl ) + "\'>" + header.innerHTML +\n\t\t\t"</a> ";\n\t}\n}\n\nfunction appendBanner() {\n\tvar banner = id( "qunit-banner" );\n\n\tif ( banner ) {\n\t\tbanner.className = "";\n\t}\n}\n\nfunction appendTestResults() {\n\tvar tests = id( "qunit-tests" ),\n\t\tresult = id( "qunit-testresult" );\n\n\tif ( result ) {\n\t\tresult.parentNode.removeChild( result );\n\t}\n\n\tif ( tests ) {\n\t\ttests.innerHTML = "";\n\t\tresult = document.createElement( "p" );\n\t\tresult.id = "qunit-testresult";\n\t\tresult.className = "result";\n\t\ttests.parentNode.insertBefore( result, tests );\n\t\tresult.innerHTML = "Running...<br />&#160;";\n\t}\n}\n\nfunction storeFixture() {\n\tvar fixture = id( "qunit-fixture" );\n\tif ( fixture ) {\n\t\tconfig.fixture = fixture.innerHTML;\n\t}\n}\n\nfunction appendFilteredTest() {\n\tvar testId = QUnit.config.testId;\n\tif ( !testId || testId.length <= 0 ) {\n\t\treturn "";\n\t}\n\treturn "<div id=\'qunit-filteredTest\'>Rerunning selected tests: " +\n\t\tescapeText( testId.join( ", " ) ) +\n\t\t" <a id=\'qunit-clearFilter\' href=\'" +\n\t\tescapeText( unfilteredUrl ) +\n\t\t"\'>Run all tests</a></div>";\n}\n\nfunction appendUserAgent() {\n\tvar userAgent = id( "qunit-userAgent" );\n\n\tif ( userAgent ) {\n\t\tuserAgent.innerHTML = "";\n\t\tuserAgent.appendChild(\n\t\t\tdocument.createTextNode(\n\t\t\t\t"QUnit " + QUnit.version + "; " + navigator.userAgent\n\t\t\t)\n\t\t);\n\t}\n}\n\nfunction appendInterface() {\n\tvar qunit = id( "qunit" );\n\n\tif ( qunit ) {\n\t\tqunit.innerHTML =\n\t\t\t"<h1 id=\'qunit-header\'>" + escapeText( document.title ) + "</h1>" +\n\t\t\t"<h2 id=\'qunit-banner\'></h2>" +\n\t\t\t"<div id=\'qunit-testrunner-toolbar\'></div>" +\n\t\t\tappendFilteredTest() +\n\t\t\t"<h2 id=\'qunit-userAgent\'></h2>" +\n\t\t\t"<ol id=\'qunit-tests\'></ol>";\n\t}\n\n\tappendHeader();\n\tappendBanner();\n\tappendTestResults();\n\tappendUserAgent();\n\tappendToolbar();\n}\n\nfunction appendTestsList( modules ) {\n\tvar i, l, x, z, test, moduleObj;\n\n\tfor ( i = 0, l = modules.length; i < l; i++ ) {\n\t\tmoduleObj = modules[ i ];\n\n\t\tfor ( x = 0, z = moduleObj.tests.length; x < z; x++ ) {\n\t\t\ttest = moduleObj.tests[ x ];\n\n\t\t\tappendTest( test.name, test.testId, moduleObj.name );\n\t\t}\n\t}\n}\n\nfunction appendTest( name, testId, moduleName ) {\n\tvar title, rerunTrigger, testBlock, assertList,\n\t\ttests = id( "qunit-tests" );\n\n\tif ( !tests ) {\n\t\treturn;\n\t}\n\n\ttitle = document.createElement( "strong" );\n\ttitle.innerHTML = getNameHtml( name, moduleName );\n\n\trerunTrigger = document.createElement( "a" );\n\trerunTrigger.innerHTML = "Rerun";\n\trerunTrigger.href = setUrl( { testId: testId } );\n\n\ttestBlock = document.createElement( "li" );\n\ttestBlock.appendChild( title );\n\ttestBlock.appendChild( rerunTrigger );\n\ttestBlock.id = "qunit-test-output-" + testId;\n\n\tassertList = document.createElement( "ol" );\n\tassertList.className = "qunit-assert-list";\n\n\ttestBlock.appendChild( assertList );\n\n\ttests.appendChild( testBlock );\n}\n\n// HTML Reporter initialization and load\nQUnit.begin( function( details ) {\n\tvar i, moduleObj, tests;\n\n\t// Sort modules by name for the picker\n\tfor ( i = 0; i < details.modules.length; i++ ) {\n\t\tmoduleObj = details.modules[ i ];\n\t\tif ( moduleObj.name ) {\n\t\t\tmodulesList.push( moduleObj.name );\n\t\t}\n\t}\n\tmodulesList.sort( function( a, b ) {\n\t\treturn a.localeCompare( b );\n\t} );\n\n\t// Capture fixture HTML from the page\n\tstoreFixture();\n\n\t// Initialize QUnit elements\n\tappendInterface();\n\tappendTestsList( details.modules );\n\ttests = id( "qunit-tests" );\n\tif ( tests && config.hidepassed ) {\n\t\taddClass( tests, "hidepass" );\n\t}\n} );\n\nQUnit.done( function( details ) {\n\tvar i, key,\n\t\tbanner = id( "qunit-banner" ),\n\t\ttests = id( "qunit-tests" ),\n\t\thtml = [\n\t\t\t"Tests completed in ",\n\t\t\tdetails.runtime,\n\t\t\t" milliseconds.<br />",\n\t\t\t"<span class=\'passed\'>",\n\t\t\tdetails.passed,\n\t\t\t"</span> assertions of <span class=\'total\'>",\n\t\t\tdetails.total,\n\t\t\t"</span> passed, <span class=\'failed\'>",\n\t\t\tdetails.failed,\n\t\t\t"</span> failed."\n\t\t].join( "" );\n\n\tif ( banner ) {\n\t\tbanner.className = details.failed ? "qunit-fail" : "qunit-pass";\n\t}\n\n\tif ( tests ) {\n\t\tid( "qunit-testresult" ).innerHTML = html;\n\t}\n\n\tif ( config.altertitle && document.title ) {\n\n\t\t// Show \u2716 for good, \u2714 for bad suite result in title\n\t\t// use escape sequences in case file gets loaded with non-utf-8-charset\n\t\tdocument.title = [\n\t\t\t( details.failed ? "\\u2716" : "\\u2714" ),\n\t\t\tdocument.title.replace( /^[\\u2714\\u2716] /i, "" )\n\t\t].join( " " );\n\t}\n\n\t// Clear own sessionStorage items if all tests passed\n\tif ( config.reorder && defined.sessionStorage && details.failed === 0 ) {\n\t\tfor ( i = 0; i < sessionStorage.length; i++ ) {\n\t\t\tkey = sessionStorage.key( i++ );\n\t\t\tif ( key.indexOf( "qunit-test-" ) === 0 ) {\n\t\t\t\tsessionStorage.removeItem( key );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Scroll back to top to show results\n\tif ( config.scrolltop && window.scrollTo ) {\n\t\twindow.scrollTo( 0, 0 );\n\t}\n} );\n\nfunction getNameHtml( name, module ) {\n\tvar nameHtml = "";\n\n\tif ( module ) {\n\t\tnameHtml = "<span class=\'module-name\'>" + escapeText( module ) + "</span>: ";\n\t}\n\n\tnameHtml += "<span class=\'test-name\'>" + escapeText( name ) + "</span>";\n\n\treturn nameHtml;\n}\n\nQUnit.testStart( function( details ) {\n\tvar running, testBlock, bad;\n\n\ttestBlock = id( "qunit-test-output-" + details.testId );\n\tif ( testBlock ) {\n\t\ttestBlock.className = "running";\n\t} else {\n\n\t\t// Report later registered tests\n\t\tappendTest( details.name, details.testId, details.module );\n\t}\n\n\trunning = id( "qunit-testresult" );\n\tif ( running ) {\n\t\tbad = QUnit.config.reorder && defined.sessionStorage &&\n\t\t\t+sessionStorage.getItem( "qunit-test-" + details.module + "-" + details.name );\n\n\t\trunning.innerHTML = ( bad ?\n\t\t\t"Rerunning previously failed test: <br />" :\n\t\t\t"Running: <br />" ) +\n\t\t\tgetNameHtml( details.name, details.module );\n\t}\n\n} );\n\nfunction stripHtml( string ) {\n\n\t// Strip tags, html entity and whitespaces\n\treturn string.replace( /<\\/?[^>]+(>|$)/g, "" ).replace( /\\&quot;/g, "" ).replace( /\\s+/g, "" );\n}\n\nQUnit.log( function( details ) {\n\tvar assertList, assertLi,\n\t\tmessage, expected, actual, diff,\n\t\tshowDiff = false,\n\t\ttestItem = id( "qunit-test-output-" + details.testId );\n\n\tif ( !testItem ) {\n\t\treturn;\n\t}\n\n\tmessage = escapeText( details.message ) || ( details.result ? "okay" : "failed" );\n\tmessage = "<span class=\'test-message\'>" + message + "</span>";\n\tmessage += "<span class=\'runtime\'>@ " + details.runtime + " ms</span>";\n\n\t// The pushFailure doesn\'t provide details.expected\n\t// when it calls, it\'s implicit to also not show expected and diff stuff\n\t// Also, we need to check details.expected existence, as it can exist and be undefined\n\tif ( !details.result && hasOwn.call( details, "expected" ) ) {\n\t\tif ( details.negative ) {\n\t\t\texpected = "NOT " + QUnit.dump.parse( details.expected );\n\t\t} else {\n\t\t\texpected = QUnit.dump.parse( details.expected );\n\t\t}\n\n\t\tactual = QUnit.dump.parse( details.actual );\n\t\tmessage += "<table><tr class=\'test-expected\'><th>Expected: </th><td><pre>" +\n\t\t\tescapeText( expected ) +\n\t\t\t"</pre></td></tr>";\n\n\t\tif ( actual !== expected ) {\n\n\t\t\tmessage += "<tr class=\'test-actual\'><th>Result: </th><td><pre>" +\n\t\t\t\tescapeText( actual ) + "</pre></td></tr>";\n\n\t\t\t// Don\'t show diff if actual or expected are booleans\n\t\t\tif ( !( /^(true|false)$/.test( actual ) ) &&\n\t\t\t\t\t!( /^(true|false)$/.test( expected ) ) ) {\n\t\t\t\tdiff = QUnit.diff( expected, actual );\n\t\t\t\tshowDiff = stripHtml( diff ).length !==\n\t\t\t\t\tstripHtml( expected ).length +\n\t\t\t\t\tstripHtml( actual ).length;\n\t\t\t}\n\n\t\t\t// Don\'t show diff if expected and actual are totally different\n\t\t\tif ( showDiff ) {\n\t\t\t\tmessage += "<tr class=\'test-diff\'><th>Diff: </th><td><pre>" +\n\t\t\t\t\tdiff + "</pre></td></tr>";\n\t\t\t}\n\t\t} else if ( expected.indexOf( "[object Array]" ) !== -1 ||\n\t\t\t\texpected.indexOf( "[object Object]" ) !== -1 ) {\n\t\t\tmessage += "<tr class=\'test-message\'><th>Message: </th><td>" +\n\t\t\t\t"Diff suppressed as the depth of object is more than current max depth (" +\n\t\t\t\tQUnit.config.maxDepth + ").<p>Hint: Use <code>QUnit.dump.maxDepth</code> to " +\n\t\t\t\t" run with a higher max depth or <a href=\'" +\n\t\t\t\tescapeText( setUrl( { maxDepth: -1 } ) ) + "\'>" +\n\t\t\t\t"Rerun</a> without max depth.</p></td></tr>";\n\t\t} else {\n\t\t\tmessage += "<tr class=\'test-message\'><th>Message: </th><td>" +\n\t\t\t\t"Diff suppressed as the expected and actual results have an equivalent" +\n\t\t\t\t" serialization</td></tr>";\n\t\t}\n\n\t\tif ( details.source ) {\n\t\t\tmessage += "<tr class=\'test-source\'><th>Source: </th><td><pre>" +\n\t\t\t\tescapeText( details.source ) + "</pre></td></tr>";\n\t\t}\n\n\t\tmessage += "</table>";\n\n\t// This occurs when pushFailure is set and we have an extracted stack trace\n\t} else if ( !details.result && details.source ) {\n\t\tmessage += "<table>" +\n\t\t\t"<tr class=\'test-source\'><th>Source: </th><td><pre>" +\n\t\t\tescapeText( details.source ) + "</pre></td></tr>" +\n\t\t\t"</table>";\n\t}\n\n\tassertList = testItem.getElementsByTagName( "ol" )[ 0 ];\n\n\tassertLi = document.createElement( "li" );\n\tassertLi.className = details.result ? "pass" : "fail";\n\tassertLi.innerHTML = message;\n\tassertList.appendChild( assertLi );\n} );\n\nQUnit.testDone( function( details ) {\n\tvar testTitle, time, testItem, assertList,\n\t\tgood, bad, testCounts, skipped, sourceName,\n\t\ttests = id( "qunit-tests" );\n\n\tif ( !tests ) {\n\t\treturn;\n\t}\n\n\ttestItem = id( "qunit-test-output-" + details.testId );\n\n\tassertList = testItem.getElementsByTagName( "ol" )[ 0 ];\n\n\tgood = details.passed;\n\tbad = details.failed;\n\n\t// Store result when possible\n\tif ( config.reorder && defined.sessionStorage ) {\n\t\tif ( bad ) {\n\t\t\tsessionStorage.setItem( "qunit-test-" + details.module + "-" + details.name, bad );\n\t\t} else {\n\t\t\tsessionStorage.removeItem( "qunit-test-" + details.module + "-" + details.name );\n\t\t}\n\t}\n\n\tif ( bad === 0 ) {\n\n\t\t// Collapse the passing tests\n\t\taddClass( assertList, "qunit-collapsed" );\n\t} else if ( bad && config.collapse && !collapseNext ) {\n\n\t\t// Skip collapsing the first failing test\n\t\tcollapseNext = true;\n\t} else {\n\n\t\t// Collapse remaining tests\n\t\taddClass( assertList, "qunit-collapsed" );\n\t}\n\n\t// The testItem.firstChild is the test name\n\ttestTitle = testItem.firstChild;\n\n\ttestCounts = bad ?\n\t\t"<b class=\'failed\'>" + bad + "</b>, " + "<b class=\'passed\'>" + good + "</b>, " :\n\t\t"";\n\n\ttestTitle.innerHTML += " <b class=\'counts\'>(" + testCounts +\n\t\tdetails.assertions.length + ")</b>";\n\n\tif ( details.skipped ) {\n\t\ttestItem.className = "skipped";\n\t\tskipped = document.createElement( "em" );\n\t\tskipped.className = "qunit-skipped-label";\n\t\tskipped.innerHTML = "skipped";\n\t\ttestItem.insertBefore( skipped, testTitle );\n\t} else {\n\t\taddEvent( testTitle, "click", function() {\n\t\t\ttoggleClass( assertList, "qunit-collapsed" );\n\t\t} );\n\n\t\ttestItem.className = bad ? "fail" : "pass";\n\n\t\ttime = document.createElement( "span" );\n\t\ttime.className = "runtime";\n\t\ttime.innerHTML = details.runtime + " ms";\n\t\ttestItem.insertBefore( time, assertList );\n\t}\n\n\t// Show the source of the test when showing assertions\n\tif ( details.source ) {\n\t\tsourceName = document.createElement( "p" );\n\t\tsourceName.innerHTML = "<strong>Source: </strong>" + details.source;\n\t\taddClass( sourceName, "qunit-source" );\n\t\tif ( bad === 0 ) {\n\t\t\taddClass( sourceName, "qunit-collapsed" );\n\t\t}\n\t\taddEvent( testTitle, "click", function() {\n\t\t\ttoggleClass( sourceName, "qunit-collapsed" );\n\t\t} );\n\t\ttestItem.appendChild( sourceName );\n\t}\n} );\n\n// Avoid readyState issue with phantomjs\n// Ref: #818\nvar notPhantom = ( function( p ) {\n\treturn !( p && p.version && p.version.major > 0 );\n} )( window.phantom );\n\nif ( notPhantom && document.readyState === "complete" ) {\n\tQUnit.load();\n} else {\n\taddEvent( window, "load", QUnit.load );\n}\n\n/*\n * This file is a modified version of google-diff-match-patch\'s JavaScript implementation\n * (https://code.google.com/p/google-diff-match-patch/source/browse/trunk/javascript/diff_match_patch_uncompressed.js),\n * modifications are licensed as more fully set forth in LICENSE.txt.\n *\n * The original source of google-diff-match-patch is attributable and licensed as follows:\n *\n * Copyright 2006 Google Inc.\n * https://code.google.com/p/google-diff-match-patch/\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * More Info:\n *  https://code.google.com/p/google-diff-match-patch/\n *\n * Usage: QUnit.diff(expected, actual)\n *\n */\nQUnit.diff = ( function() {\n\tfunction DiffMatchPatch() {\n\t}\n\n\t//  DIFF FUNCTIONS\n\n\t/**\n\t * The data structure representing a diff is an array of tuples:\n\t * [[DIFF_DELETE, \'Hello\'], [DIFF_INSERT, \'Goodbye\'], [DIFF_EQUAL, \' world.\']]\n\t * which means: delete \'Hello\', add \'Goodbye\' and keep \' world.\'\n\t */\n\tvar DIFF_DELETE = -1,\n\t\tDIFF_INSERT = 1,\n\t\tDIFF_EQUAL = 0;\n\n\t/**\n\t * Find the differences between two texts.  Simplifies the problem by stripping\n\t * any common prefix or suffix off the texts before diffing.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {boolean=} optChecklines Optional speedup flag. If present and false,\n\t *     then don\'t run a line-level diff first to identify the changed areas.\n\t *     Defaults to true, which does a faster, slightly less optimal diff.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t */\n\tDiffMatchPatch.prototype.DiffMain = function( text1, text2, optChecklines ) {\n\t\tvar deadline, checklines, commonlength,\n\t\t\tcommonprefix, commonsuffix, diffs;\n\n\t\t// The diff must be complete in up to 1 second.\n\t\tdeadline = ( new Date() ).getTime() + 1000;\n\n\t\t// Check for null inputs.\n\t\tif ( text1 === null || text2 === null ) {\n\t\t\tthrow new Error( "Null input. (DiffMain)" );\n\t\t}\n\n\t\t// Check for equality (speedup).\n\t\tif ( text1 === text2 ) {\n\t\t\tif ( text1 ) {\n\t\t\t\treturn [\n\t\t\t\t\t[ DIFF_EQUAL, text1 ]\n\t\t\t\t];\n\t\t\t}\n\t\t\treturn [];\n\t\t}\n\n\t\tif ( typeof optChecklines === "undefined" ) {\n\t\t\toptChecklines = true;\n\t\t}\n\n\t\tchecklines = optChecklines;\n\n\t\t// Trim off common prefix (speedup).\n\t\tcommonlength = this.diffCommonPrefix( text1, text2 );\n\t\tcommonprefix = text1.substring( 0, commonlength );\n\t\ttext1 = text1.substring( commonlength );\n\t\ttext2 = text2.substring( commonlength );\n\n\t\t// Trim off common suffix (speedup).\n\t\tcommonlength = this.diffCommonSuffix( text1, text2 );\n\t\tcommonsuffix = text1.substring( text1.length - commonlength );\n\t\ttext1 = text1.substring( 0, text1.length - commonlength );\n\t\ttext2 = text2.substring( 0, text2.length - commonlength );\n\n\t\t// Compute the diff on the middle block.\n\t\tdiffs = this.diffCompute( text1, text2, checklines, deadline );\n\n\t\t// Restore the prefix and suffix.\n\t\tif ( commonprefix ) {\n\t\t\tdiffs.unshift( [ DIFF_EQUAL, commonprefix ] );\n\t\t}\n\t\tif ( commonsuffix ) {\n\t\t\tdiffs.push( [ DIFF_EQUAL, commonsuffix ] );\n\t\t}\n\t\tthis.diffCleanupMerge( diffs );\n\t\treturn diffs;\n\t};\n\n\t/**\n\t * Reduce the number of edits by eliminating operationally trivial equalities.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t */\n\tDiffMatchPatch.prototype.diffCleanupEfficiency = function( diffs ) {\n\t\tvar changes, equalities, equalitiesLength, lastequality,\n\t\t\tpointer, preIns, preDel, postIns, postDel;\n\t\tchanges = false;\n\t\tequalities = []; // Stack of indices where equalities are found.\n\t\tequalitiesLength = 0; // Keeping our own length var is faster in JS.\n\t\t/** @type {?string} */\n\t\tlastequality = null;\n\n\t\t// Always equal to diffs[equalities[equalitiesLength - 1]][1]\n\t\tpointer = 0; // Index of current position.\n\n\t\t// Is there an insertion operation before the last equality.\n\t\tpreIns = false;\n\n\t\t// Is there a deletion operation before the last equality.\n\t\tpreDel = false;\n\n\t\t// Is there an insertion operation after the last equality.\n\t\tpostIns = false;\n\n\t\t// Is there a deletion operation after the last equality.\n\t\tpostDel = false;\n\t\twhile ( pointer < diffs.length ) {\n\n\t\t\t// Equality found.\n\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_EQUAL ) {\n\t\t\t\tif ( diffs[ pointer ][ 1 ].length < 4 && ( postIns || postDel ) ) {\n\n\t\t\t\t\t// Candidate found.\n\t\t\t\t\tequalities[ equalitiesLength++ ] = pointer;\n\t\t\t\t\tpreIns = postIns;\n\t\t\t\t\tpreDel = postDel;\n\t\t\t\t\tlastequality = diffs[ pointer ][ 1 ];\n\t\t\t\t} else {\n\n\t\t\t\t\t// Not a candidate, and can never become one.\n\t\t\t\t\tequalitiesLength = 0;\n\t\t\t\t\tlastequality = null;\n\t\t\t\t}\n\t\t\t\tpostIns = postDel = false;\n\n\t\t\t// An insertion or deletion.\n\t\t\t} else {\n\n\t\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_DELETE ) {\n\t\t\t\t\tpostDel = true;\n\t\t\t\t} else {\n\t\t\t\t\tpostIns = true;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Five types to be split:\n\t\t\t\t * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n\t\t\t\t * <ins>A</ins>X<ins>C</ins><del>D</del>\n\t\t\t\t * <ins>A</ins><del>B</del>X<ins>C</ins>\n\t\t\t\t * <ins>A</del>X<ins>C</ins><del>D</del>\n\t\t\t\t * <ins>A</ins><del>B</del>X<del>C</del>\n\t\t\t\t */\n\t\t\t\tif ( lastequality && ( ( preIns && preDel && postIns && postDel ) ||\n\t\t\t\t\t\t( ( lastequality.length < 2 ) &&\n\t\t\t\t\t\t( preIns + preDel + postIns + postDel ) === 3 ) ) ) {\n\n\t\t\t\t\t// Duplicate record.\n\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\tequalities[ equalitiesLength - 1 ],\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t[ DIFF_DELETE, lastequality ]\n\t\t\t\t\t);\n\n\t\t\t\t\t// Change second copy to insert.\n\t\t\t\t\tdiffs[ equalities[ equalitiesLength - 1 ] + 1 ][ 0 ] = DIFF_INSERT;\n\t\t\t\t\tequalitiesLength--; // Throw away the equality we just deleted;\n\t\t\t\t\tlastequality = null;\n\t\t\t\t\tif ( preIns && preDel ) {\n\n\t\t\t\t\t\t// No changes made which could affect previous entry, keep going.\n\t\t\t\t\t\tpostIns = postDel = true;\n\t\t\t\t\t\tequalitiesLength = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tequalitiesLength--; // Throw away the previous equality.\n\t\t\t\t\t\tpointer = equalitiesLength > 0 ? equalities[ equalitiesLength - 1 ] : -1;\n\t\t\t\t\t\tpostIns = postDel = false;\n\t\t\t\t\t}\n\t\t\t\t\tchanges = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\n\t\tif ( changes ) {\n\t\t\tthis.diffCleanupMerge( diffs );\n\t\t}\n\t};\n\n\t/**\n\t * Convert a diff array into a pretty HTML report.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t * @param {integer} string to be beautified.\n\t * @return {string} HTML representation.\n\t */\n\tDiffMatchPatch.prototype.diffPrettyHtml = function( diffs ) {\n\t\tvar op, data, x,\n\t\t\thtml = [];\n\t\tfor ( x = 0; x < diffs.length; x++ ) {\n\t\t\top = diffs[ x ][ 0 ]; // Operation (insert, delete, equal)\n\t\t\tdata = diffs[ x ][ 1 ]; // Text of change.\n\t\t\tswitch ( op ) {\n\t\t\tcase DIFF_INSERT:\n\t\t\t\thtml[ x ] = "<ins>" + escapeText( data ) + "</ins>";\n\t\t\t\tbreak;\n\t\t\tcase DIFF_DELETE:\n\t\t\t\thtml[ x ] = "<del>" + escapeText( data ) + "</del>";\n\t\t\t\tbreak;\n\t\t\tcase DIFF_EQUAL:\n\t\t\t\thtml[ x ] = "<span>" + escapeText( data ) + "</span>";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn html.join( "" );\n\t};\n\n\t/**\n\t * Determine the common prefix of two strings.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {number} The number of characters common to the start of each\n\t *     string.\n\t */\n\tDiffMatchPatch.prototype.diffCommonPrefix = function( text1, text2 ) {\n\t\tvar pointermid, pointermax, pointermin, pointerstart;\n\n\t\t// Quick check for common null cases.\n\t\tif ( !text1 || !text2 || text1.charAt( 0 ) !== text2.charAt( 0 ) ) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Binary search.\n\t\t// Performance analysis: https://neil.fraser.name/news/2007/10/09/\n\t\tpointermin = 0;\n\t\tpointermax = Math.min( text1.length, text2.length );\n\t\tpointermid = pointermax;\n\t\tpointerstart = 0;\n\t\twhile ( pointermin < pointermid ) {\n\t\t\tif ( text1.substring( pointerstart, pointermid ) ===\n\t\t\t\t\ttext2.substring( pointerstart, pointermid ) ) {\n\t\t\t\tpointermin = pointermid;\n\t\t\t\tpointerstart = pointermin;\n\t\t\t} else {\n\t\t\t\tpointermax = pointermid;\n\t\t\t}\n\t\t\tpointermid = Math.floor( ( pointermax - pointermin ) / 2 + pointermin );\n\t\t}\n\t\treturn pointermid;\n\t};\n\n\t/**\n\t * Determine the common suffix of two strings.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {number} The number of characters common to the end of each string.\n\t */\n\tDiffMatchPatch.prototype.diffCommonSuffix = function( text1, text2 ) {\n\t\tvar pointermid, pointermax, pointermin, pointerend;\n\n\t\t// Quick check for common null cases.\n\t\tif ( !text1 ||\n\t\t\t\t!text2 ||\n\t\t\t\ttext1.charAt( text1.length - 1 ) !== text2.charAt( text2.length - 1 ) ) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Binary search.\n\t\t// Performance analysis: https://neil.fraser.name/news/2007/10/09/\n\t\tpointermin = 0;\n\t\tpointermax = Math.min( text1.length, text2.length );\n\t\tpointermid = pointermax;\n\t\tpointerend = 0;\n\t\twhile ( pointermin < pointermid ) {\n\t\t\tif ( text1.substring( text1.length - pointermid, text1.length - pointerend ) ===\n\t\t\t\t\ttext2.substring( text2.length - pointermid, text2.length - pointerend ) ) {\n\t\t\t\tpointermin = pointermid;\n\t\t\t\tpointerend = pointermin;\n\t\t\t} else {\n\t\t\t\tpointermax = pointermid;\n\t\t\t}\n\t\t\tpointermid = Math.floor( ( pointermax - pointermin ) / 2 + pointermin );\n\t\t}\n\t\treturn pointermid;\n\t};\n\n\t/**\n\t * Find the differences between two texts.  Assumes that the texts do not\n\t * have any common prefix or suffix.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {boolean} checklines Speedup flag.  If false, then don\'t run a\n\t *     line-level diff first to identify the changed areas.\n\t *     If true, then run a faster, slightly less optimal diff.\n\t * @param {number} deadline Time when the diff should be complete by.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffCompute = function( text1, text2, checklines, deadline ) {\n\t\tvar diffs, longtext, shorttext, i, hm,\n\t\t\ttext1A, text2A, text1B, text2B,\n\t\t\tmidCommon, diffsA, diffsB;\n\n\t\tif ( !text1 ) {\n\n\t\t\t// Just add some text (speedup).\n\t\t\treturn [\n\t\t\t\t[ DIFF_INSERT, text2 ]\n\t\t\t];\n\t\t}\n\n\t\tif ( !text2 ) {\n\n\t\t\t// Just delete some text (speedup).\n\t\t\treturn [\n\t\t\t\t[ DIFF_DELETE, text1 ]\n\t\t\t];\n\t\t}\n\n\t\tlongtext = text1.length > text2.length ? text1 : text2;\n\t\tshorttext = text1.length > text2.length ? text2 : text1;\n\t\ti = longtext.indexOf( shorttext );\n\t\tif ( i !== -1 ) {\n\n\t\t\t// Shorter text is inside the longer text (speedup).\n\t\t\tdiffs = [\n\t\t\t\t[ DIFF_INSERT, longtext.substring( 0, i ) ],\n\t\t\t\t[ DIFF_EQUAL, shorttext ],\n\t\t\t\t[ DIFF_INSERT, longtext.substring( i + shorttext.length ) ]\n\t\t\t];\n\n\t\t\t// Swap insertions for deletions if diff is reversed.\n\t\t\tif ( text1.length > text2.length ) {\n\t\t\t\tdiffs[ 0 ][ 0 ] = diffs[ 2 ][ 0 ] = DIFF_DELETE;\n\t\t\t}\n\t\t\treturn diffs;\n\t\t}\n\n\t\tif ( shorttext.length === 1 ) {\n\n\t\t\t// Single character string.\n\t\t\t// After the previous speedup, the character can\'t be an equality.\n\t\t\treturn [\n\t\t\t\t[ DIFF_DELETE, text1 ],\n\t\t\t\t[ DIFF_INSERT, text2 ]\n\t\t\t];\n\t\t}\n\n\t\t// Check to see if the problem can be split in two.\n\t\thm = this.diffHalfMatch( text1, text2 );\n\t\tif ( hm ) {\n\n\t\t\t// A half-match was found, sort out the return data.\n\t\t\ttext1A = hm[ 0 ];\n\t\t\ttext1B = hm[ 1 ];\n\t\t\ttext2A = hm[ 2 ];\n\t\t\ttext2B = hm[ 3 ];\n\t\t\tmidCommon = hm[ 4 ];\n\n\t\t\t// Send both pairs off for separate processing.\n\t\t\tdiffsA = this.DiffMain( text1A, text2A, checklines, deadline );\n\t\t\tdiffsB = this.DiffMain( text1B, text2B, checklines, deadline );\n\n\t\t\t// Merge the results.\n\t\t\treturn diffsA.concat( [\n\t\t\t\t[ DIFF_EQUAL, midCommon ]\n\t\t\t], diffsB );\n\t\t}\n\n\t\tif ( checklines && text1.length > 100 && text2.length > 100 ) {\n\t\t\treturn this.diffLineMode( text1, text2, deadline );\n\t\t}\n\n\t\treturn this.diffBisect( text1, text2, deadline );\n\t};\n\n\t/**\n\t * Do the two texts share a substring which is at least half the length of the\n\t * longer text?\n\t * This speedup can produce non-minimal diffs.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {Array.<string>} Five element Array, containing the prefix of\n\t *     text1, the suffix of text1, the prefix of text2, the suffix of\n\t *     text2 and the common middle.  Or null if there was no match.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffHalfMatch = function( text1, text2 ) {\n\t\tvar longtext, shorttext, dmp,\n\t\t\ttext1A, text2B, text2A, text1B, midCommon,\n\t\t\thm1, hm2, hm;\n\n\t\tlongtext = text1.length > text2.length ? text1 : text2;\n\t\tshorttext = text1.length > text2.length ? text2 : text1;\n\t\tif ( longtext.length < 4 || shorttext.length * 2 < longtext.length ) {\n\t\t\treturn null; // Pointless.\n\t\t}\n\t\tdmp = this; // \'this\' becomes \'window\' in a closure.\n\n\t\t/**\n\t\t * Does a substring of shorttext exist within longtext such that the substring\n\t\t * is at least half the length of longtext?\n\t\t * Closure, but does not reference any external variables.\n\t\t * @param {string} longtext Longer string.\n\t\t * @param {string} shorttext Shorter string.\n\t\t * @param {number} i Start index of quarter length substring within longtext.\n\t\t * @return {Array.<string>} Five element Array, containing the prefix of\n\t\t *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n\t\t *     of shorttext and the common middle.  Or null if there was no match.\n\t\t * @private\n\t\t */\n\t\tfunction diffHalfMatchI( longtext, shorttext, i ) {\n\t\t\tvar seed, j, bestCommon, prefixLength, suffixLength,\n\t\t\t\tbestLongtextA, bestLongtextB, bestShorttextA, bestShorttextB;\n\n\t\t\t// Start with a 1/4 length substring at position i as a seed.\n\t\t\tseed = longtext.substring( i, i + Math.floor( longtext.length / 4 ) );\n\t\t\tj = -1;\n\t\t\tbestCommon = "";\n\t\t\twhile ( ( j = shorttext.indexOf( seed, j + 1 ) ) !== -1 ) {\n\t\t\t\tprefixLength = dmp.diffCommonPrefix( longtext.substring( i ),\n\t\t\t\t\tshorttext.substring( j ) );\n\t\t\t\tsuffixLength = dmp.diffCommonSuffix( longtext.substring( 0, i ),\n\t\t\t\t\tshorttext.substring( 0, j ) );\n\t\t\t\tif ( bestCommon.length < suffixLength + prefixLength ) {\n\t\t\t\t\tbestCommon = shorttext.substring( j - suffixLength, j ) +\n\t\t\t\t\t\tshorttext.substring( j, j + prefixLength );\n\t\t\t\t\tbestLongtextA = longtext.substring( 0, i - suffixLength );\n\t\t\t\t\tbestLongtextB = longtext.substring( i + prefixLength );\n\t\t\t\t\tbestShorttextA = shorttext.substring( 0, j - suffixLength );\n\t\t\t\t\tbestShorttextB = shorttext.substring( j + prefixLength );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( bestCommon.length * 2 >= longtext.length ) {\n\t\t\t\treturn [ bestLongtextA, bestLongtextB,\n\t\t\t\t\tbestShorttextA, bestShorttextB, bestCommon\n\t\t\t\t];\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\t// First check if the second quarter is the seed for a half-match.\n\t\thm1 = diffHalfMatchI( longtext, shorttext,\n\t\t\tMath.ceil( longtext.length / 4 ) );\n\n\t\t// Check again based on the third quarter.\n\t\thm2 = diffHalfMatchI( longtext, shorttext,\n\t\t\tMath.ceil( longtext.length / 2 ) );\n\t\tif ( !hm1 && !hm2 ) {\n\t\t\treturn null;\n\t\t} else if ( !hm2 ) {\n\t\t\thm = hm1;\n\t\t} else if ( !hm1 ) {\n\t\t\thm = hm2;\n\t\t} else {\n\n\t\t\t// Both matched.  Select the longest.\n\t\t\thm = hm1[ 4 ].length > hm2[ 4 ].length ? hm1 : hm2;\n\t\t}\n\n\t\t// A half-match was found, sort out the return data.\n\t\ttext1A, text1B, text2A, text2B;\n\t\tif ( text1.length > text2.length ) {\n\t\t\ttext1A = hm[ 0 ];\n\t\t\ttext1B = hm[ 1 ];\n\t\t\ttext2A = hm[ 2 ];\n\t\t\ttext2B = hm[ 3 ];\n\t\t} else {\n\t\t\ttext2A = hm[ 0 ];\n\t\t\ttext2B = hm[ 1 ];\n\t\t\ttext1A = hm[ 2 ];\n\t\t\ttext1B = hm[ 3 ];\n\t\t}\n\t\tmidCommon = hm[ 4 ];\n\t\treturn [ text1A, text1B, text2A, text2B, midCommon ];\n\t};\n\n\t/**\n\t * Do a quick line-level diff on both strings, then rediff the parts for\n\t * greater accuracy.\n\t * This speedup can produce non-minimal diffs.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {number} deadline Time when the diff should be complete by.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffLineMode = function( text1, text2, deadline ) {\n\t\tvar a, diffs, linearray, pointer, countInsert,\n\t\t\tcountDelete, textInsert, textDelete, j;\n\n\t\t// Scan the text on a line-by-line basis first.\n\t\ta = this.diffLinesToChars( text1, text2 );\n\t\ttext1 = a.chars1;\n\t\ttext2 = a.chars2;\n\t\tlinearray = a.lineArray;\n\n\t\tdiffs = this.DiffMain( text1, text2, false, deadline );\n\n\t\t// Convert the diff back to original text.\n\t\tthis.diffCharsToLines( diffs, linearray );\n\n\t\t// Eliminate freak matches (e.g. blank lines)\n\t\tthis.diffCleanupSemantic( diffs );\n\n\t\t// Rediff any replacement blocks, this time character-by-character.\n\t\t// Add a dummy entry at the end.\n\t\tdiffs.push( [ DIFF_EQUAL, "" ] );\n\t\tpointer = 0;\n\t\tcountDelete = 0;\n\t\tcountInsert = 0;\n\t\ttextDelete = "";\n\t\ttextInsert = "";\n\t\twhile ( pointer < diffs.length ) {\n\t\t\tswitch ( diffs[ pointer ][ 0 ] ) {\n\t\t\tcase DIFF_INSERT:\n\t\t\t\tcountInsert++;\n\t\t\t\ttextInsert += diffs[ pointer ][ 1 ];\n\t\t\t\tbreak;\n\t\t\tcase DIFF_DELETE:\n\t\t\t\tcountDelete++;\n\t\t\t\ttextDelete += diffs[ pointer ][ 1 ];\n\t\t\t\tbreak;\n\t\t\tcase DIFF_EQUAL:\n\n\t\t\t\t// Upon reaching an equality, check for prior redundancies.\n\t\t\t\tif ( countDelete >= 1 && countInsert >= 1 ) {\n\n\t\t\t\t\t// Delete the offending records and add the merged ones.\n\t\t\t\t\tdiffs.splice( pointer - countDelete - countInsert,\n\t\t\t\t\t\tcountDelete + countInsert );\n\t\t\t\t\tpointer = pointer - countDelete - countInsert;\n\t\t\t\t\ta = this.DiffMain( textDelete, textInsert, false, deadline );\n\t\t\t\t\tfor ( j = a.length - 1; j >= 0; j-- ) {\n\t\t\t\t\t\tdiffs.splice( pointer, 0, a[ j ] );\n\t\t\t\t\t}\n\t\t\t\t\tpointer = pointer + a.length;\n\t\t\t\t}\n\t\t\t\tcountInsert = 0;\n\t\t\t\tcountDelete = 0;\n\t\t\t\ttextDelete = "";\n\t\t\t\ttextInsert = "";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\t\tdiffs.pop(); // Remove the dummy entry at the end.\n\n\t\treturn diffs;\n\t};\n\n\t/**\n\t * Find the \'middle snake\' of a diff, split the problem in two\n\t * and return the recursively constructed diff.\n\t * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {number} deadline Time at which to bail if not yet complete.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffBisect = function( text1, text2, deadline ) {\n\t\tvar text1Length, text2Length, maxD, vOffset, vLength,\n\t\t\tv1, v2, x, delta, front, k1start, k1end, k2start,\n\t\t\tk2end, k2Offset, k1Offset, x1, x2, y1, y2, d, k1, k2;\n\n\t\t// Cache the text lengths to prevent multiple calls.\n\t\ttext1Length = text1.length;\n\t\ttext2Length = text2.length;\n\t\tmaxD = Math.ceil( ( text1Length + text2Length ) / 2 );\n\t\tvOffset = maxD;\n\t\tvLength = 2 * maxD;\n\t\tv1 = new Array( vLength );\n\t\tv2 = new Array( vLength );\n\n\t\t// Setting all elements to -1 is faster in Chrome & Firefox than mixing\n\t\t// integers and undefined.\n\t\tfor ( x = 0; x < vLength; x++ ) {\n\t\t\tv1[ x ] = -1;\n\t\t\tv2[ x ] = -1;\n\t\t}\n\t\tv1[ vOffset + 1 ] = 0;\n\t\tv2[ vOffset + 1 ] = 0;\n\t\tdelta = text1Length - text2Length;\n\n\t\t// If the total number of characters is odd, then the front path will collide\n\t\t// with the reverse path.\n\t\tfront = ( delta % 2 !== 0 );\n\n\t\t// Offsets for start and end of k loop.\n\t\t// Prevents mapping of space beyond the grid.\n\t\tk1start = 0;\n\t\tk1end = 0;\n\t\tk2start = 0;\n\t\tk2end = 0;\n\t\tfor ( d = 0; d < maxD; d++ ) {\n\n\t\t\t// Bail out if deadline is reached.\n\t\t\tif ( ( new Date() ).getTime() > deadline ) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Walk the front path one step.\n\t\t\tfor ( k1 = -d + k1start; k1 <= d - k1end; k1 += 2 ) {\n\t\t\t\tk1Offset = vOffset + k1;\n\t\t\t\tif ( k1 === -d || ( k1 !== d && v1[ k1Offset - 1 ] < v1[ k1Offset + 1 ] ) ) {\n\t\t\t\t\tx1 = v1[ k1Offset + 1 ];\n\t\t\t\t} else {\n\t\t\t\t\tx1 = v1[ k1Offset - 1 ] + 1;\n\t\t\t\t}\n\t\t\t\ty1 = x1 - k1;\n\t\t\t\twhile ( x1 < text1Length && y1 < text2Length &&\n\t\t\t\t\ttext1.charAt( x1 ) === text2.charAt( y1 ) ) {\n\t\t\t\t\tx1++;\n\t\t\t\t\ty1++;\n\t\t\t\t}\n\t\t\t\tv1[ k1Offset ] = x1;\n\t\t\t\tif ( x1 > text1Length ) {\n\n\t\t\t\t\t// Ran off the right of the graph.\n\t\t\t\t\tk1end += 2;\n\t\t\t\t} else if ( y1 > text2Length ) {\n\n\t\t\t\t\t// Ran off the bottom of the graph.\n\t\t\t\t\tk1start += 2;\n\t\t\t\t} else if ( front ) {\n\t\t\t\t\tk2Offset = vOffset + delta - k1;\n\t\t\t\t\tif ( k2Offset >= 0 && k2Offset < vLength && v2[ k2Offset ] !== -1 ) {\n\n\t\t\t\t\t\t// Mirror x2 onto top-left coordinate system.\n\t\t\t\t\t\tx2 = text1Length - v2[ k2Offset ];\n\t\t\t\t\t\tif ( x1 >= x2 ) {\n\n\t\t\t\t\t\t\t// Overlap detected.\n\t\t\t\t\t\t\treturn this.diffBisectSplit( text1, text2, x1, y1, deadline );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Walk the reverse path one step.\n\t\t\tfor ( k2 = -d + k2start; k2 <= d - k2end; k2 += 2 ) {\n\t\t\t\tk2Offset = vOffset + k2;\n\t\t\t\tif ( k2 === -d || ( k2 !== d && v2[ k2Offset - 1 ] < v2[ k2Offset + 1 ] ) ) {\n\t\t\t\t\tx2 = v2[ k2Offset + 1 ];\n\t\t\t\t} else {\n\t\t\t\t\tx2 = v2[ k2Offset - 1 ] + 1;\n\t\t\t\t}\n\t\t\t\ty2 = x2 - k2;\n\t\t\t\twhile ( x2 < text1Length && y2 < text2Length &&\n\t\t\t\t\ttext1.charAt( text1Length - x2 - 1 ) ===\n\t\t\t\t\ttext2.charAt( text2Length - y2 - 1 ) ) {\n\t\t\t\t\tx2++;\n\t\t\t\t\ty2++;\n\t\t\t\t}\n\t\t\t\tv2[ k2Offset ] = x2;\n\t\t\t\tif ( x2 > text1Length ) {\n\n\t\t\t\t\t// Ran off the left of the graph.\n\t\t\t\t\tk2end += 2;\n\t\t\t\t} else if ( y2 > text2Length ) {\n\n\t\t\t\t\t// Ran off the top of the graph.\n\t\t\t\t\tk2start += 2;\n\t\t\t\t} else if ( !front ) {\n\t\t\t\t\tk1Offset = vOffset + delta - k2;\n\t\t\t\t\tif ( k1Offset >= 0 && k1Offset < vLength && v1[ k1Offset ] !== -1 ) {\n\t\t\t\t\t\tx1 = v1[ k1Offset ];\n\t\t\t\t\t\ty1 = vOffset + x1 - k1Offset;\n\n\t\t\t\t\t\t// Mirror x2 onto top-left coordinate system.\n\t\t\t\t\t\tx2 = text1Length - x2;\n\t\t\t\t\t\tif ( x1 >= x2 ) {\n\n\t\t\t\t\t\t\t// Overlap detected.\n\t\t\t\t\t\t\treturn this.diffBisectSplit( text1, text2, x1, y1, deadline );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Diff took too long and hit the deadline or\n\t\t// number of diffs equals number of characters, no commonality at all.\n\t\treturn [\n\t\t\t[ DIFF_DELETE, text1 ],\n\t\t\t[ DIFF_INSERT, text2 ]\n\t\t];\n\t};\n\n\t/**\n\t * Given the location of the \'middle snake\', split the diff in two parts\n\t * and recurse.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {number} x Index of split point in text1.\n\t * @param {number} y Index of split point in text2.\n\t * @param {number} deadline Time at which to bail if not yet complete.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffBisectSplit = function( text1, text2, x, y, deadline ) {\n\t\tvar text1a, text1b, text2a, text2b, diffs, diffsb;\n\t\ttext1a = text1.substring( 0, x );\n\t\ttext2a = text2.substring( 0, y );\n\t\ttext1b = text1.substring( x );\n\t\ttext2b = text2.substring( y );\n\n\t\t// Compute both diffs serially.\n\t\tdiffs = this.DiffMain( text1a, text2a, false, deadline );\n\t\tdiffsb = this.DiffMain( text1b, text2b, false, deadline );\n\n\t\treturn diffs.concat( diffsb );\n\t};\n\n\t/**\n\t * Reduce the number of edits by eliminating semantically trivial equalities.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t */\n\tDiffMatchPatch.prototype.diffCleanupSemantic = function( diffs ) {\n\t\tvar changes, equalities, equalitiesLength, lastequality,\n\t\t\tpointer, lengthInsertions2, lengthDeletions2, lengthInsertions1,\n\t\t\tlengthDeletions1, deletion, insertion, overlapLength1, overlapLength2;\n\t\tchanges = false;\n\t\tequalities = []; // Stack of indices where equalities are found.\n\t\tequalitiesLength = 0; // Keeping our own length var is faster in JS.\n\t\t/** @type {?string} */\n\t\tlastequality = null;\n\n\t\t// Always equal to diffs[equalities[equalitiesLength - 1]][1]\n\t\tpointer = 0; // Index of current position.\n\n\t\t// Number of characters that changed prior to the equality.\n\t\tlengthInsertions1 = 0;\n\t\tlengthDeletions1 = 0;\n\n\t\t// Number of characters that changed after the equality.\n\t\tlengthInsertions2 = 0;\n\t\tlengthDeletions2 = 0;\n\t\twhile ( pointer < diffs.length ) {\n\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_EQUAL ) { // Equality found.\n\t\t\t\tequalities[ equalitiesLength++ ] = pointer;\n\t\t\t\tlengthInsertions1 = lengthInsertions2;\n\t\t\t\tlengthDeletions1 = lengthDeletions2;\n\t\t\t\tlengthInsertions2 = 0;\n\t\t\t\tlengthDeletions2 = 0;\n\t\t\t\tlastequality = diffs[ pointer ][ 1 ];\n\t\t\t} else { // An insertion or deletion.\n\t\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_INSERT ) {\n\t\t\t\t\tlengthInsertions2 += diffs[ pointer ][ 1 ].length;\n\t\t\t\t} else {\n\t\t\t\t\tlengthDeletions2 += diffs[ pointer ][ 1 ].length;\n\t\t\t\t}\n\n\t\t\t\t// Eliminate an equality that is smaller or equal to the edits on both\n\t\t\t\t// sides of it.\n\t\t\t\tif ( lastequality && ( lastequality.length <=\n\t\t\t\t\t\tMath.max( lengthInsertions1, lengthDeletions1 ) ) &&\n\t\t\t\t\t\t( lastequality.length <= Math.max( lengthInsertions2,\n\t\t\t\t\t\t\tlengthDeletions2 ) ) ) {\n\n\t\t\t\t\t// Duplicate record.\n\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\tequalities[ equalitiesLength - 1 ],\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t[ DIFF_DELETE, lastequality ]\n\t\t\t\t\t);\n\n\t\t\t\t\t// Change second copy to insert.\n\t\t\t\t\tdiffs[ equalities[ equalitiesLength - 1 ] + 1 ][ 0 ] = DIFF_INSERT;\n\n\t\t\t\t\t// Throw away the equality we just deleted.\n\t\t\t\t\tequalitiesLength--;\n\n\t\t\t\t\t// Throw away the previous equality (it needs to be reevaluated).\n\t\t\t\t\tequalitiesLength--;\n\t\t\t\t\tpointer = equalitiesLength > 0 ? equalities[ equalitiesLength - 1 ] : -1;\n\n\t\t\t\t\t// Reset the counters.\n\t\t\t\t\tlengthInsertions1 = 0;\n\t\t\t\t\tlengthDeletions1 = 0;\n\t\t\t\t\tlengthInsertions2 = 0;\n\t\t\t\t\tlengthDeletions2 = 0;\n\t\t\t\t\tlastequality = null;\n\t\t\t\t\tchanges = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\n\t\t// Normalize the diff.\n\t\tif ( changes ) {\n\t\t\tthis.diffCleanupMerge( diffs );\n\t\t}\n\n\t\t// Find any overlaps between deletions and insertions.\n\t\t// e.g: <del>abcxxx</del><ins>xxxdef</ins>\n\t\t//   -> <del>abc</del>xxx<ins>def</ins>\n\t\t// e.g: <del>xxxabc</del><ins>defxxx</ins>\n\t\t//   -> <ins>def</ins>xxx<del>abc</del>\n\t\t// Only extract an overlap if it is as big as the edit ahead or behind it.\n\t\tpointer = 1;\n\t\twhile ( pointer < diffs.length ) {\n\t\t\tif ( diffs[ pointer - 1 ][ 0 ] === DIFF_DELETE &&\n\t\t\t\t\tdiffs[ pointer ][ 0 ] === DIFF_INSERT ) {\n\t\t\t\tdeletion = diffs[ pointer - 1 ][ 1 ];\n\t\t\t\tinsertion = diffs[ pointer ][ 1 ];\n\t\t\t\toverlapLength1 = this.diffCommonOverlap( deletion, insertion );\n\t\t\t\toverlapLength2 = this.diffCommonOverlap( insertion, deletion );\n\t\t\t\tif ( overlapLength1 >= overlapLength2 ) {\n\t\t\t\t\tif ( overlapLength1 >= deletion.length / 2 ||\n\t\t\t\t\t\t\toverlapLength1 >= insertion.length / 2 ) {\n\n\t\t\t\t\t\t// Overlap found.  Insert an equality and trim the surrounding edits.\n\t\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\t\tpointer,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t[ DIFF_EQUAL, insertion.substring( 0, overlapLength1 ) ]\n\t\t\t\t\t\t);\n\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] =\n\t\t\t\t\t\t\tdeletion.substring( 0, deletion.length - overlapLength1 );\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] = insertion.substring( overlapLength1 );\n\t\t\t\t\t\tpointer++;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif ( overlapLength2 >= deletion.length / 2 ||\n\t\t\t\t\t\t\toverlapLength2 >= insertion.length / 2 ) {\n\n\t\t\t\t\t\t// Reverse overlap found.\n\t\t\t\t\t\t// Insert an equality and swap and trim the surrounding edits.\n\t\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\t\tpointer,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t[ DIFF_EQUAL, deletion.substring( 0, overlapLength2 ) ]\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tdiffs[ pointer - 1 ][ 0 ] = DIFF_INSERT;\n\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] =\n\t\t\t\t\t\t\tinsertion.substring( 0, insertion.length - overlapLength2 );\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 0 ] = DIFF_DELETE;\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] =\n\t\t\t\t\t\t\tdeletion.substring( overlapLength2 );\n\t\t\t\t\t\tpointer++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpointer++;\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\t};\n\n\t/**\n\t * Determine if the suffix of one string is the prefix of another.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {number} The number of characters common to the end of the first\n\t *     string and the start of the second string.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffCommonOverlap = function( text1, text2 ) {\n\t\tvar text1Length, text2Length, textLength,\n\t\t\tbest, length, pattern, found;\n\n\t\t// Cache the text lengths to prevent multiple calls.\n\t\ttext1Length = text1.length;\n\t\ttext2Length = text2.length;\n\n\t\t// Eliminate the null case.\n\t\tif ( text1Length === 0 || text2Length === 0 ) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Truncate the longer string.\n\t\tif ( text1Length > text2Length ) {\n\t\t\ttext1 = text1.substring( text1Length - text2Length );\n\t\t} else if ( text1Length < text2Length ) {\n\t\t\ttext2 = text2.substring( 0, text1Length );\n\t\t}\n\t\ttextLength = Math.min( text1Length, text2Length );\n\n\t\t// Quick check for the worst case.\n\t\tif ( text1 === text2 ) {\n\t\t\treturn textLength;\n\t\t}\n\n\t\t// Start by looking for a single character match\n\t\t// and increase length until no match is found.\n\t\t// Performance analysis: https://neil.fraser.name/news/2010/11/04/\n\t\tbest = 0;\n\t\tlength = 1;\n\t\twhile ( true ) {\n\t\t\tpattern = text1.substring( textLength - length );\n\t\t\tfound = text2.indexOf( pattern );\n\t\t\tif ( found === -1 ) {\n\t\t\t\treturn best;\n\t\t\t}\n\t\t\tlength += found;\n\t\t\tif ( found === 0 || text1.substring( textLength - length ) ===\n\t\t\t\t\ttext2.substring( 0, length ) ) {\n\t\t\t\tbest = length;\n\t\t\t\tlength++;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Split two texts into an array of strings.  Reduce the texts to a string of\n\t * hashes where each Unicode character represents one line.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}\n\t *     An object containing the encoded text1, the encoded text2 and\n\t *     the array of unique strings.\n\t *     The zeroth element of the array of unique strings is intentionally blank.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffLinesToChars = function( text1, text2 ) {\n\t\tvar lineArray, lineHash, chars1, chars2;\n\t\tlineArray = []; // E.g. lineArray[4] === \'Hello\\n\'\n\t\tlineHash = {};  // E.g. lineHash[\'Hello\\n\'] === 4\n\n\t\t// \'\\x00\' is a valid character, but various debuggers don\'t like it.\n\t\t// So we\'ll insert a junk entry to avoid generating a null character.\n\t\tlineArray[ 0 ] = "";\n\n\t\t/**\n\t\t * Split a text into an array of strings.  Reduce the texts to a string of\n\t\t * hashes where each Unicode character represents one line.\n\t\t * Modifies linearray and linehash through being a closure.\n\t\t * @param {string} text String to encode.\n\t\t * @return {string} Encoded string.\n\t\t * @private\n\t\t */\n\t\tfunction diffLinesToCharsMunge( text ) {\n\t\t\tvar chars, lineStart, lineEnd, lineArrayLength, line;\n\t\t\tchars = "";\n\n\t\t\t// Walk the text, pulling out a substring for each line.\n\t\t\t// text.split(\'\\n\') would would temporarily double our memory footprint.\n\t\t\t// Modifying text would create many large strings to garbage collect.\n\t\t\tlineStart = 0;\n\t\t\tlineEnd = -1;\n\n\t\t\t// Keeping our own length variable is faster than looking it up.\n\t\t\tlineArrayLength = lineArray.length;\n\t\t\twhile ( lineEnd < text.length - 1 ) {\n\t\t\t\tlineEnd = text.indexOf( "\\n", lineStart );\n\t\t\t\tif ( lineEnd === -1 ) {\n\t\t\t\t\tlineEnd = text.length - 1;\n\t\t\t\t}\n\t\t\t\tline = text.substring( lineStart, lineEnd + 1 );\n\t\t\t\tlineStart = lineEnd + 1;\n\n\t\t\t\tif ( lineHash.hasOwnProperty ? lineHash.hasOwnProperty( line ) :\n\t\t\t\t\t\t\t( lineHash[ line ] !== undefined ) ) {\n\t\t\t\t\tchars += String.fromCharCode( lineHash[ line ] );\n\t\t\t\t} else {\n\t\t\t\t\tchars += String.fromCharCode( lineArrayLength );\n\t\t\t\t\tlineHash[ line ] = lineArrayLength;\n\t\t\t\t\tlineArray[ lineArrayLength++ ] = line;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn chars;\n\t\t}\n\n\t\tchars1 = diffLinesToCharsMunge( text1 );\n\t\tchars2 = diffLinesToCharsMunge( text2 );\n\t\treturn {\n\t\t\tchars1: chars1,\n\t\t\tchars2: chars2,\n\t\t\tlineArray: lineArray\n\t\t};\n\t};\n\n\t/**\n\t * Rehydrate the text in a diff from a string of line hashes to real lines of\n\t * text.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t * @param {!Array.<string>} lineArray Array of unique strings.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffCharsToLines = function( diffs, lineArray ) {\n\t\tvar x, chars, text, y;\n\t\tfor ( x = 0; x < diffs.length; x++ ) {\n\t\t\tchars = diffs[ x ][ 1 ];\n\t\t\ttext = [];\n\t\t\tfor ( y = 0; y < chars.length; y++ ) {\n\t\t\t\ttext[ y ] = lineArray[ chars.charCodeAt( y ) ];\n\t\t\t}\n\t\t\tdiffs[ x ][ 1 ] = text.join( "" );\n\t\t}\n\t};\n\n\t/**\n\t * Reorder and merge like edit sections.  Merge equalities.\n\t * Any edit section can move as long as it doesn\'t cross an equality.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t */\n\tDiffMatchPatch.prototype.diffCleanupMerge = function( diffs ) {\n\t\tvar pointer, countDelete, countInsert, textInsert, textDelete,\n\t\t\tcommonlength, changes, diffPointer, position;\n\t\tdiffs.push( [ DIFF_EQUAL, "" ] ); // Add a dummy entry at the end.\n\t\tpointer = 0;\n\t\tcountDelete = 0;\n\t\tcountInsert = 0;\n\t\ttextDelete = "";\n\t\ttextInsert = "";\n\t\tcommonlength;\n\t\twhile ( pointer < diffs.length ) {\n\t\t\tswitch ( diffs[ pointer ][ 0 ] ) {\n\t\t\tcase DIFF_INSERT:\n\t\t\t\tcountInsert++;\n\t\t\t\ttextInsert += diffs[ pointer ][ 1 ];\n\t\t\t\tpointer++;\n\t\t\t\tbreak;\n\t\t\tcase DIFF_DELETE:\n\t\t\t\tcountDelete++;\n\t\t\t\ttextDelete += diffs[ pointer ][ 1 ];\n\t\t\t\tpointer++;\n\t\t\t\tbreak;\n\t\t\tcase DIFF_EQUAL:\n\n\t\t\t\t// Upon reaching an equality, check for prior redundancies.\n\t\t\t\tif ( countDelete + countInsert > 1 ) {\n\t\t\t\t\tif ( countDelete !== 0 && countInsert !== 0 ) {\n\n\t\t\t\t\t\t// Factor out any common prefixes.\n\t\t\t\t\t\tcommonlength = this.diffCommonPrefix( textInsert, textDelete );\n\t\t\t\t\t\tif ( commonlength !== 0 ) {\n\t\t\t\t\t\t\tif ( ( pointer - countDelete - countInsert ) > 0 &&\n\t\t\t\t\t\t\t\t\tdiffs[ pointer - countDelete - countInsert - 1 ][ 0 ] ===\n\t\t\t\t\t\t\t\t\tDIFF_EQUAL ) {\n\t\t\t\t\t\t\t\tdiffs[ pointer - countDelete - countInsert - 1 ][ 1 ] +=\n\t\t\t\t\t\t\t\t\ttextInsert.substring( 0, commonlength );\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdiffs.splice( 0, 0, [ DIFF_EQUAL,\n\t\t\t\t\t\t\t\t\ttextInsert.substring( 0, commonlength )\n\t\t\t\t\t\t\t\t] );\n\t\t\t\t\t\t\t\tpointer++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttextInsert = textInsert.substring( commonlength );\n\t\t\t\t\t\t\ttextDelete = textDelete.substring( commonlength );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Factor out any common suffixies.\n\t\t\t\t\t\tcommonlength = this.diffCommonSuffix( textInsert, textDelete );\n\t\t\t\t\t\tif ( commonlength !== 0 ) {\n\t\t\t\t\t\t\tdiffs[ pointer ][ 1 ] = textInsert.substring( textInsert.length -\n\t\t\t\t\t\t\t\t\tcommonlength ) + diffs[ pointer ][ 1 ];\n\t\t\t\t\t\t\ttextInsert = textInsert.substring( 0, textInsert.length -\n\t\t\t\t\t\t\t\tcommonlength );\n\t\t\t\t\t\t\ttextDelete = textDelete.substring( 0, textDelete.length -\n\t\t\t\t\t\t\t\tcommonlength );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Delete the offending records and add the merged ones.\n\t\t\t\t\tif ( countDelete === 0 ) {\n\t\t\t\t\t\tdiffs.splice( pointer - countInsert,\n\t\t\t\t\t\t\tcountDelete + countInsert, [ DIFF_INSERT, textInsert ] );\n\t\t\t\t\t} else if ( countInsert === 0 ) {\n\t\t\t\t\t\tdiffs.splice( pointer - countDelete,\n\t\t\t\t\t\t\tcountDelete + countInsert, [ DIFF_DELETE, textDelete ] );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\t\tpointer - countDelete - countInsert,\n\t\t\t\t\t\t\tcountDelete + countInsert,\n\t\t\t\t\t\t\t[ DIFF_DELETE, textDelete ], [ DIFF_INSERT, textInsert ]\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tpointer = pointer - countDelete - countInsert +\n\t\t\t\t\t\t( countDelete ? 1 : 0 ) + ( countInsert ? 1 : 0 ) + 1;\n\t\t\t\t} else if ( pointer !== 0 && diffs[ pointer - 1 ][ 0 ] === DIFF_EQUAL ) {\n\n\t\t\t\t\t// Merge this equality with the previous one.\n\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] += diffs[ pointer ][ 1 ];\n\t\t\t\t\tdiffs.splice( pointer, 1 );\n\t\t\t\t} else {\n\t\t\t\t\tpointer++;\n\t\t\t\t}\n\t\t\t\tcountInsert = 0;\n\t\t\t\tcountDelete = 0;\n\t\t\t\ttextDelete = "";\n\t\t\t\ttextInsert = "";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif ( diffs[ diffs.length - 1 ][ 1 ] === "" ) {\n\t\t\tdiffs.pop(); // Remove the dummy entry at the end.\n\t\t}\n\n\t\t// Second pass: look for single edits surrounded on both sides by equalities\n\t\t// which can be shifted sideways to eliminate an equality.\n\t\t// e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n\t\tchanges = false;\n\t\tpointer = 1;\n\n\t\t// Intentionally ignore the first and last element (don\'t need checking).\n\t\twhile ( pointer < diffs.length - 1 ) {\n\t\t\tif ( diffs[ pointer - 1 ][ 0 ] === DIFF_EQUAL &&\n\t\t\t\t\tdiffs[ pointer + 1 ][ 0 ] === DIFF_EQUAL ) {\n\n\t\t\t\tdiffPointer = diffs[ pointer ][ 1 ];\n\t\t\t\tposition = diffPointer.substring(\n\t\t\t\t\tdiffPointer.length - diffs[ pointer - 1 ][ 1 ].length\n\t\t\t\t);\n\n\t\t\t\t// This is a single edit surrounded by equalities.\n\t\t\t\tif ( position === diffs[ pointer - 1 ][ 1 ] ) {\n\n\t\t\t\t\t// Shift the edit over the previous equality.\n\t\t\t\t\tdiffs[ pointer ][ 1 ] = diffs[ pointer - 1 ][ 1 ] +\n\t\t\t\t\t\tdiffs[ pointer ][ 1 ].substring( 0, diffs[ pointer ][ 1 ].length -\n\t\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ].length );\n\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] =\n\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] + diffs[ pointer + 1 ][ 1 ];\n\t\t\t\t\tdiffs.splice( pointer - 1, 1 );\n\t\t\t\t\tchanges = true;\n\t\t\t\t} else if ( diffPointer.substring( 0, diffs[ pointer + 1 ][ 1 ].length ) ===\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] ) {\n\n\t\t\t\t\t// Shift the edit over the next equality.\n\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] += diffs[ pointer + 1 ][ 1 ];\n\t\t\t\t\tdiffs[ pointer ][ 1 ] =\n\t\t\t\t\t\tdiffs[ pointer ][ 1 ].substring( diffs[ pointer + 1 ][ 1 ].length ) +\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ];\n\t\t\t\t\tdiffs.splice( pointer + 1, 1 );\n\t\t\t\t\tchanges = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\n\t\t// If shifts were made, the diff needs reordering and another shift sweep.\n\t\tif ( changes ) {\n\t\t\tthis.diffCleanupMerge( diffs );\n\t\t}\n\t};\n\n\treturn function( o, n ) {\n\t\tvar diff, output, text;\n\t\tdiff = new DiffMatchPatch();\n\t\toutput = diff.DiffMain( o, n );\n\t\tdiff.diffCleanupEfficiency( output );\n\t\ttext = diff.diffPrettyHtml( output );\n\n\t\treturn text;\n\t};\n}() );\n\n}() );\n';
    loader.global.define = undefined;
    loader.global.module = undefined;
    loader.global.exports = undefined;
    loader.__exec({
        'source': source,
        'address': module.uri
    });
    loader.global.require = require;
    loader.global.define = define;
    return loader.get('@@global-helpers').retrieveGlobal(module.id, 'QUnit');
});
/*steal-css@1.2.5#css*/
define('steal-css@1.2.5#css', function (require, exports, module) {
    (function (global) {
        var loader = require('@loader');
        var steal = require('@steal');
        var isNode = typeof process === 'object' && {}.toString.call(process) === '[object process]';
        var importRegEx = /@import [^uU]['"]?([^'"\)]*)['"]?/g;
        var resourceRegEx = /url\(['"]?([^'"\)]*)['"]?\)/g;
        var waitSeconds = loader.cssOptions && loader.cssOptions.timeout ? parseInt(loader.cssOptions.timeout, 10) : 60;
        var onloadCss = function (link, cb) {
            var styleSheets = getDocument().styleSheets, i = styleSheets.length;
            while (i--) {
                if (styleSheets[i].href === link.href) {
                    return cb();
                }
            }
            setTimeout(function () {
                onloadCss(link, cb);
            });
        };
        function isIE9() {
            var doc = getDocument();
            return doc && !!Function('/*@cc_on return (/^9/.test(@_jscript_version) && /MSIE 9.0(?!.*IEMobile)/i.test(navigator.userAgent)); @*/')();
        }
        function getDocument() {
            if (typeof doneSsr !== 'undefined' && doneSsr.globalDocument) {
                return doneSsr.globalDocument;
            }
            if (typeof document !== 'undefined') {
                return document;
            }
            throw new Error('Unable to load CSS in an environment without a document.');
        }
        function getHead() {
            var doc = getDocument();
            var head = doc.head || doc.getElementsByTagName('head')[0];
            if (!head) {
                var docEl = doc.documentElement || doc;
                head = doc.createElement('head');
                docEl.insertBefore(head, docEl.firstChild);
            }
            return head;
        }
        function CSSModule(load, loader) {
            if (typeof load === 'object') {
                this.load = load;
                this.loader = loader;
                this.address = this.load.address;
                this.source = this.load.source;
            } else {
                this.address = load;
                this.source = loader;
            }
        }
        CSSModule.cssCount = 0;
        CSSModule.ie9MaxStyleSheets = 31;
        CSSModule.currentStyleSheet = null;
        CSSModule.prototype = {
            injectLink: function () {
                if (this._loaded) {
                    return this._loaded;
                }
                if (this.linkExists()) {
                    this._loaded = Promise.resolve('');
                    return this._loaded;
                }
                var doc = getDocument();
                var link = this.link = doc.createElement('link');
                link.type = 'text/css';
                link.rel = 'stylesheet';
                link.href = this.address;
                this._loaded = new Promise(function (resolve, reject) {
                    var timeout = setTimeout(function () {
                        reject('Unable to load CSS');
                    }, waitSeconds * 1000);
                    var loadCB = function (event) {
                        clearTimeout(timeout);
                        link.removeEventListener('load', loadCB);
                        link.removeEventListener('error', loadCB);
                        if (event && event.type === 'error') {
                            reject('Unable to load CSS');
                        } else {
                            resolve('');
                        }
                    };
                    if ('isApplicationInstalled' in navigator || !link.addEventListener) {
                        onloadCss(link, loadCB);
                    } else if (navigator.noUI) {
                        loadCB();
                    } else {
                        link.addEventListener('load', loadCB);
                        link.addEventListener('error', loadCB);
                    }
                    getHead().appendChild(link);
                });
                return this._loaded;
            },
            injectStyle: function () {
                var doc = getDocument();
                var head = getHead();
                var style = this.style = doc.createElement('style');
                style.type = 'text/css';
                if (style.sheet) {
                    style.sheet.cssText = this.source;
                } else if (style.styleSheet) {
                    style.styleSheet.cssText = this.source;
                } else {
                    style.appendChild(doc.createTextNode(this.source));
                }
                head.appendChild(style);
            },
            ie9StyleSheetLimitHack: function () {
                var doc = getDocument();
                if (!CSSModule.cssCount) {
                    CSSModule.currentStyleSheet = doc.createStyleSheet();
                }
                CSSModule.cssCount += 1;
                CSSModule.currentStyleSheet.cssText += this.source;
                if (CSSModule.cssCount === CSSModule.ie9MaxStyleSheets) {
                    CSSModule.cssCount = 0;
                }
            },
            updateURLs: function () {
                var rawSource = this.source, address = this.address;
                this.source = rawSource.replace(importRegEx, function (whole, part) {
                    if (isNode) {
                        return '@import url(' + part + ')';
                    } else {
                        return '@import url(' + steal.joinURIs(address, part) + ')';
                    }
                });
                if (!loader.isEnv('build')) {
                    this.source = this.source + '/*# sourceURL=' + address + ' */';
                    this.source = this.source.replace(resourceRegEx, function (whole, part) {
                        return 'url(' + steal.joinURIs(address, part) + ')';
                    });
                }
                return this.source;
            },
            getExistingNode: function () {
                var doc = getDocument();
                var selector = '[href=\'' + this.address + '\']';
                return doc.querySelector && doc.querySelector(selector);
            },
            linkExists: function () {
                var styleSheets = getDocument().styleSheets;
                for (var i = 0; i < styleSheets.length; ++i) {
                    if (this.address === styleSheets[i].href) {
                        return true;
                    }
                }
                return false;
            },
            setupLiveReload: function (loader, name) {
                var head = getHead();
                var css = this;
                if (loader.liveReloadInstalled) {
                    var cssReload = loader['import']('live-reload', { name: module.id });
                    Promise.resolve(cssReload).then(function (reload) {
                        loader['import'](name).then(function () {
                            reload.once('!dispose/' + name, function () {
                                css.style.__isDirty = true;
                                reload.once('!cycleComplete', function () {
                                    head.removeChild(css.style);
                                });
                            });
                        });
                    });
                }
            }
        };
        if (loader.isEnv('production')) {
            exports.fetch = function (load) {
                var css = new CSSModule(load.address);
                return css.injectLink();
            };
        } else {
            exports.instantiate = function (load) {
                var loader = this;
                var css = new CSSModule(load.address, load.source);
                load.source = css.updateURLs();
                load.metadata.deps = [];
                load.metadata.format = 'css';
                load.metadata.execute = function () {
                    if (getDocument()) {
                        if (isIE9()) {
                            css.ie9StyleSheetLimitHack();
                        } else {
                            css.injectStyle();
                        }
                        css.setupLiveReload(loader, load.name);
                    }
                    return loader.newModule({ source: css.source });
                };
            };
        }
        exports.CSSModule = CSSModule;
        exports.getDocument = getDocument;
        exports.getHead = getHead;
        exports.locateScheme = true;
        exports.buildType = 'css';
        exports.includeInBuild = true;
    }(function () {
        return this;
    }()));
});
/*steal-qunit@1.0.1#steal-qunit*/
'format amd';
define('steal-qunit@1.0.1#steal-qunit', [
    '@loader',
    'qunitjs/qunit/qunit',
    'qunitjs/qunit/qunit.css'
], function (loader, QUnit) {
    if (loader.has('live-reload')) {
        setupLiveReload();
    }
    setupSauceLabsReporting();
    function setupLiveReload() {
        QUnit.done(updateResults);
        function findModule(name) {
            var mods = QUnit.config.modules;
            return mods.filter(function (mod) {
                return mod.name === name;
            }).pop();
        }
        function findTestResult(mod, id) {
            var tests = mod.tests || [];
            return tests.filter(function (test) {
                return test.testId === id;
            })[0];
        }
        function updateResults() {
            var tests = document.getElementById('qunit-tests').children;
            var node, id, test, moduleName, mod;
            passed = true, removedNodes = [];
            for (var i = 0, len = tests.length; i < len; i++) {
                node = tests.item(i);
                id = node.id.split('-').pop();
                moduleName = node.querySelector('.module-name').textContent;
                mod = findModule(moduleName);
                test = findTestResult(mod, id);
                if (test) {
                    removeAllButLast(node, 'runtime');
                    if (node.className !== 'pass') {
                        passed = false;
                        break;
                    }
                } else {
                    removedNodes.push(node);
                }
            }
            removedNodes.forEach(function (node) {
                node.parentNode.removeChild(node);
            });
            document.getElementById('qunit-banner').className = passed ? 'qunit-pass' : 'qunit-fail';
        }
        function removeAllButLast(parent, className) {
            var node, nodes = [];
            var children = parent.children;
            for (var i = 0, len = children.length; i < len; i++) {
                node = children.item(i);
                if (node.className === className)
                    nodes.push(node);
            }
            while (nodes.length > 1) {
                node = nodes.shift();
                parent.removeChild(node);
            }
        }
    }
    function setupSauceLabsReporting() {
        var log = [];
        QUnit.done(function (test_results) {
            var tests = [];
            for (var i = 0, len = log.length; i < len; i++) {
                var details = log[i];
                tests.push({
                    name: details.name,
                    result: details.result,
                    expected: details.expected,
                    actual: details.actual,
                    source: details.source
                });
            }
            test_results.tests = tests;
            window.global_test_results = test_results;
        });
        QUnit.testStart(function (testDetails) {
            QUnit.log(function (details) {
                if (!details.result) {
                    details.name = testDetails.name;
                    log.push(details);
                }
            });
        });
    }
    QUnit.config.autorun = false;
    steal.done().then(function () {
        if (window.Testee && window.Testee.init) {
            Testee.init();
        }
        QUnit.load();
    });
    return QUnit;
});
/*can-util@3.9.6#js/defaults/defaults*/
define('can-util@3.9.6#js/defaults/defaults', function (require, exports, module) {
    'use strict';
    module.exports = function (target) {
        var length = arguments.length;
        for (var i = 1; i < length; i++) {
            for (var prop in arguments[i]) {
                if (target[prop] === undefined) {
                    target[prop] = arguments[i][prop];
                }
            }
        }
        return target;
    };
});
/*can-util@3.9.6#js/string-to-any/string-to-any*/
define('can-util@3.9.6#js/string-to-any/string-to-any', function (require, exports, module) {
    'use strict';
    module.exports = function (str) {
        switch (str) {
        case 'NaN':
        case 'Infinity':
            return +str;
        case 'null':
            return null;
        case 'undefined':
            return undefined;
        case 'true':
        case 'false':
            return str === 'true';
        default:
            var val = +str;
            if (!isNaN(val)) {
                return val;
            } else {
                return str;
            }
        }
    };
});
/*can-define@1.3.2#can-define*/
define('can-define@1.3.2#can-define', function (require, exports, module) {
    'use strict';
    'format cjs';
    var eventLifecycle = require('can-event/lifecycle/lifecycle');
    var canBatch = require('can-event/batch/batch');
    var canEvent = require('can-event');
    var compute = require('can-compute');
    var Observation = require('can-observation');
    var isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');
    var assign = require('can-util/js/assign/assign');
    var dev = require('can-util/js/dev/dev');
    var CID = require('can-cid');
    var isPlainObject = require('can-util/js/is-plain-object/is-plain-object');
    var isArray = require('can-util/js/is-array/is-array');
    var types = require('can-types');
    var each = require('can-util/js/each/each');
    var defaults = require('can-util/js/defaults/defaults');
    var stringToAny = require('can-util/js/string-to-any/string-to-any');
    var ns = require('can-namespace');
    var canSymbol = require('can-symbol');
    var canReflect = require('can-reflect');
    var singleReference = require('can-util/js/single-reference/single-reference');
    var eventsProto, define, make, makeDefinition, replaceWith, getDefinitionsAndMethods, isDefineType, getDefinitionOrMethod;
    var defineConfigurableAndNotEnumerable = function (obj, prop, value) {
        Object.defineProperty(obj, prop, {
            configurable: true,
            enumerable: false,
            writable: true,
            value: value
        });
    };
    var eachPropertyDescriptor = function (map, cb) {
        for (var prop in map) {
            if (map.hasOwnProperty(prop)) {
                cb(prop, Object.getOwnPropertyDescriptor(map, prop));
            }
        }
    };
    function trapSets(observableValue) {
        return {
            observable: observableValue,
            lastSetValue: undefined,
            setValue: function (value) {
                this.lastSetValue = value;
                if (this.observable) {
                    if (canSymbol.for('can.setValue') in this.observable) {
                        canReflect.setValue(this.observable, value);
                    } else {
                        this.observable.update();
                    }
                }
            }
        };
    }
    module.exports = define = ns.define = function (objPrototype, defines, baseDefine) {
        var prop, dataInitializers = Object.create(baseDefine ? baseDefine.dataInitializers : null), computedInitializers = Object.create(baseDefine ? baseDefine.computedInitializers : null);
        var result = getDefinitionsAndMethods(defines, baseDefine);
        result.dataInitializers = dataInitializers;
        result.computedInitializers = computedInitializers;
        each(result.definitions, function (definition, property) {
            define.property(objPrototype, property, definition, dataInitializers, computedInitializers);
        });
        if (objPrototype.hasOwnProperty('_data')) {
            for (prop in dataInitializers) {
                replaceWith(objPrototype._data, prop, dataInitializers[prop].bind(objPrototype), true);
            }
        } else {
            replaceWith(objPrototype, '_data', function () {
                var map = this;
                var data = {};
                for (var prop in dataInitializers) {
                    replaceWith(data, prop, dataInitializers[prop].bind(map), true);
                }
                return data;
            });
        }
        if (objPrototype.hasOwnProperty('_computed')) {
            for (prop in computedInitializers) {
                replaceWith(objPrototype._computed, prop, computedInitializers[prop].bind(objPrototype));
            }
        } else {
            replaceWith(objPrototype, '_computed', function () {
                var map = this;
                var data = Object.create(null);
                for (var prop in computedInitializers) {
                    replaceWith(data, prop, computedInitializers[prop].bind(map));
                }
                return data;
            });
        }
        for (prop in eventsProto) {
            Object.defineProperty(objPrototype, prop, {
                enumerable: false,
                value: eventsProto[prop],
                configurable: true,
                writable: true
            });
        }
        Object.defineProperty(objPrototype, '_define', {
            enumerable: false,
            value: result,
            configurable: true,
            writable: true
        });
        var iteratorSymbol = canSymbol.iterator || canSymbol.for('iterator');
        if (!objPrototype[iteratorSymbol]) {
            defineConfigurableAndNotEnumerable(objPrototype, iteratorSymbol, function () {
                return new define.Iterator(this);
            });
        }
        return result;
    };
    define.extensions = function () {
    };
    var onlyType = function (obj) {
        for (var prop in obj) {
            if (prop !== 'type') {
                return false;
            }
        }
        return true;
    };
    define.property = function (objPrototype, prop, definition, dataInitializers, computedInitializers) {
        var propertyDefinition = define.extensions.apply(this, arguments);
        if (propertyDefinition) {
            definition = propertyDefinition;
        }
        var type = definition.type;
        if (type && onlyType(definition) && type === define.types['*']) {
            Object.defineProperty(objPrototype, prop, {
                get: make.get.data(prop),
                set: make.set.events(prop, make.get.data(prop), make.set.data(prop), make.eventType.data(prop)),
                enumerable: true,
                configurable: true
            });
            return;
        }
        definition.type = type;
        var dataProperty = definition.get ? 'computed' : 'data', reader = make.read[dataProperty](prop), getter = make.get[dataProperty](prop), setter = make.set[dataProperty](prop), getInitialValue;
        var typeConvert = function (val) {
            return val;
        };
        if (definition.Type) {
            typeConvert = make.set.Type(prop, definition.Type, typeConvert);
        }
        if (type) {
            typeConvert = make.set.type(prop, type, typeConvert);
        }
        var eventsSetter = make.set.events(prop, reader, setter, make.eventType[dataProperty](prop));
        if (definition.value !== undefined || definition.Value !== undefined) {
            getInitialValue = Observation.ignore(make.get.defaultValue(prop, definition, typeConvert, eventsSetter));
        }
        if (definition.get) {
            computedInitializers[prop] = make.compute(prop, definition.get, getInitialValue);
        } else if (getInitialValue) {
            dataInitializers[prop] = getInitialValue;
        }
        if (definition.get && definition.set) {
            setter = make.set.setter(prop, definition.set, make.read.lastSet(prop), setter, true);
        } else if (definition.set) {
            setter = make.set.setter(prop, definition.set, reader, eventsSetter, false);
        } else if (!definition.get) {
            setter = eventsSetter;
        }
        if (type) {
            setter = make.set.type(prop, type, setter);
        }
        if (definition.Type) {
            setter = make.set.Type(prop, definition.Type, setter);
        }
        Object.defineProperty(objPrototype, prop, {
            get: getter,
            set: setter,
            enumerable: 'serialize' in definition ? !!definition.serialize : !definition.get,
            configurable: true
        });
    };
    define.Constructor = function (defines) {
        var constructor = function (props) {
            define.setup.call(this, props);
        };
        define(constructor.prototype, defines);
        return constructor;
    };
    make = {
        compute: function (prop, get, defaultValueFn) {
            return function () {
                var map = this, defaultValue = defaultValueFn && defaultValueFn.call(this), computeFn, valueTrap, computeObj;
                var boundGet = function () {
                    return get.call(map, computeObj.valueTrap.lastSetValue);
                };
                if (get.length < 2) {
                    if (defaultValue && defaultValue.isComputed) {
                        computeFn = defaultValue;
                        valueTrap = trapSets(computeFn);
                    } else {
                        computeFn = new Observation(boundGet, map);
                        valueTrap = trapSets(computeFn);
                        valueTrap.lastSetValue = defaultValue;
                    }
                } else {
                    if (defaultValue) {
                        computeFn = defaultValue.isComputed ? defaultValue : compute.async(defaultValue, get, map);
                    } else {
                        computeFn = compute.async(defaultValue, get, map);
                    }
                    valueTrap = trapSets(computeFn);
                }
                computeObj = {
                    oldValue: undefined,
                    compute: computeFn,
                    count: 0,
                    handler: function (newVal) {
                        var oldValue = computeObj.oldValue;
                        computeObj.oldValue = newVal;
                        canEvent.dispatch.call(map, {
                            type: prop,
                            target: map,
                            batchNum: canBatch.batchNum
                        }, [
                            newVal,
                            oldValue
                        ]);
                    },
                    valueTrap: valueTrap
                };
                return computeObj;
            };
        },
        set: {
            data: function (prop) {
                return function (newVal) {
                    this._data[prop] = newVal;
                };
            },
            computed: function (prop) {
                return function (val) {
                    this._computed[prop].valueTrap.setValue(val);
                };
            },
            events: function (prop, getCurrent, setData, eventType) {
                return function (newVal) {
                    if (this.__inSetup) {
                        setData.call(this, newVal);
                    } else {
                        var current = getCurrent.call(this);
                        if (newVal !== current) {
                            setData.call(this, newVal);
                            canEvent.dispatch.call(this, {
                                type: prop,
                                target: this
                            }, [
                                newVal,
                                current
                            ]);
                        }
                    }
                };
            },
            setter: function (prop, setter, getCurrent, setEvents, hasGetter) {
                return function (value) {
                    var self = this;
                    canBatch.start();
                    var setterCalled = false, current = getCurrent.call(this), setValue = setter.call(this, value, function (value) {
                            setEvents.call(self, value);
                            setterCalled = true;
                        }, current);
                    if (setterCalled) {
                        canBatch.stop();
                    } else {
                        if (hasGetter) {
                            if (setValue !== undefined) {
                                if (current !== setValue) {
                                    setEvents.call(this, setValue);
                                }
                                canBatch.stop();
                            } else if (setter.length === 0) {
                                setEvents.call(this, value);
                                canBatch.stop();
                                return;
                            } else if (setter.length === 1) {
                                canBatch.stop();
                            } else {
                                canBatch.stop();
                                return;
                            }
                        } else {
                            if (setValue !== undefined) {
                                setEvents.call(this, setValue);
                                canBatch.stop();
                            } else if (setter.length === 0) {
                                setEvents.call(this, value);
                                canBatch.stop();
                                return;
                            } else if (setter.length === 1) {
                                setEvents.call(this, undefined);
                                canBatch.stop();
                            } else {
                                canBatch.stop();
                                return;
                            }
                        }
                    }
                };
            },
            type: function (prop, type, set) {
                if (typeof type === 'object') {
                    return make.set.Type(prop, type, set);
                } else {
                    return function (newValue) {
                        return set.call(this, type.call(this, newValue, prop));
                    };
                }
            },
            Type: function (prop, Type, set) {
                if (isArray(Type) && types.DefineList) {
                    Type = types.DefineList.extend({ '#': Type[0] });
                } else if (typeof Type === 'object') {
                    if (types.DefineMap) {
                        Type = types.DefineMap.extend(Type);
                    } else {
                        Type = define.constructor(Type);
                    }
                }
                return function (newValue) {
                    if (newValue instanceof Type || newValue == null) {
                        return set.call(this, newValue);
                    } else {
                        return set.call(this, new Type(newValue));
                    }
                };
            }
        },
        eventType: {
            data: function (prop) {
                return function (newVal, oldVal) {
                    return oldVal !== undefined || this._data.hasOwnProperty(prop) ? 'set' : 'add';
                };
            },
            computed: function () {
                return function () {
                    return 'set';
                };
            }
        },
        read: {
            data: function (prop) {
                return function () {
                    return this._data[prop];
                };
            },
            computed: function (prop) {
                return function () {
                    return canReflect.getValue(this._computed[prop].compute);
                };
            },
            lastSet: function (prop) {
                return function () {
                    var lastSetValue = this._computed[prop].valueTrap.lastSetValue;
                    return lastSetValue;
                };
            }
        },
        get: {
            defaultValue: function (prop, definition, typeConvert, callSetter) {
                return function () {
                    var value = definition.value;
                    if (value !== undefined) {
                        if (typeof value === 'function') {
                            value = value.call(this);
                        }
                        value = typeConvert(value);
                    } else {
                        var Value = definition.Value;
                        if (Value) {
                            value = typeConvert(new Value());
                        }
                    }
                    if (definition.set) {
                        var VALUE;
                        var sync = true;
                        var setter = make.set.setter(prop, definition.set, function () {
                        }, function (value) {
                            if (sync) {
                                VALUE = value;
                            } else {
                                callSetter.call(this, value);
                            }
                        }, definition.get);
                        setter.call(this, value);
                        sync = false;
                        return VALUE;
                    }
                    return value;
                };
            },
            data: function (prop) {
                return function () {
                    if (!this.__inSetup) {
                        Observation.add(this, prop);
                    }
                    return this._data[prop];
                };
            },
            computed: function (prop) {
                return function () {
                    return canReflect.getValue(this._computed[prop].compute);
                };
            }
        }
    };
    define.behaviors = [
        'get',
        'set',
        'value',
        'Value',
        'type',
        'Type',
        'serialize'
    ];
    var addDefinition = function (definition, behavior, value) {
        if (behavior === 'type') {
            var behaviorDef = value;
            if (typeof behaviorDef === 'string') {
                behaviorDef = define.types[behaviorDef];
                if (typeof behaviorDef === 'object') {
                    assign(definition, behaviorDef);
                    behaviorDef = behaviorDef[behavior];
                }
            }
            definition[behavior] = behaviorDef;
        } else {
            definition[behavior] = value;
        }
    };
    makeDefinition = function (prop, def, defaultDefinition) {
        var definition = {};
        each(def, function (value, behavior) {
            addDefinition(definition, behavior, value);
        });
        each(defaultDefinition, function (value, prop) {
            if (definition[prop] === undefined) {
                if (prop !== 'type' && prop !== 'Type') {
                    definition[prop] = value;
                }
            }
        });
        if (!definition.type && !definition.Type) {
            defaults(definition, defaultDefinition);
        }
        if (isEmptyObject(definition)) {
            definition.type = define.types['*'];
        }
        return definition;
    };
    getDefinitionOrMethod = function (prop, value, defaultDefinition) {
        var definition;
        if (typeof value === 'string') {
            definition = { type: value };
        } else if (typeof value === 'function') {
            if (canReflect.isConstructorLike(value)) {
                definition = { Type: value };
            } else if (isDefineType(value)) {
                definition = { type: value };
            }
        } else if (isArray(value)) {
            definition = { Type: value };
        } else if (isPlainObject(value)) {
            definition = value;
        }
        if (definition) {
            return makeDefinition(prop, definition, defaultDefinition);
        } else {
            return value;
        }
    };
    getDefinitionsAndMethods = function (defines, baseDefines) {
        var definitions = Object.create(baseDefines ? baseDefines.definitions : null);
        var methods = {};
        var defaults = defines['*'], defaultDefinition;
        if (defaults) {
            delete defines['*'];
            defaultDefinition = getDefinitionOrMethod('*', defaults, {});
        } else {
            defaultDefinition = Object.create(null);
        }
        eachPropertyDescriptor(defines, function (prop, propertyDescriptor) {
            var value;
            if (propertyDescriptor.get || propertyDescriptor.set) {
                value = {
                    get: propertyDescriptor.get,
                    set: propertyDescriptor.set
                };
            } else {
                value = propertyDescriptor.value;
            }
            if (prop === 'constructor') {
                methods[prop] = value;
                return;
            } else {
                var result = getDefinitionOrMethod(prop, value, defaultDefinition);
                if (result && typeof result === 'object') {
                    definitions[prop] = result;
                } else {
                    methods[prop] = result;
                }
            }
        });
        if (defaults) {
            defines['*'] = defaults;
        }
        return {
            definitions: definitions,
            methods: methods,
            defaultDefinition: defaultDefinition
        };
    };
    replaceWith = function (obj, prop, cb, writable) {
        Object.defineProperty(obj, prop, {
            configurable: true,
            get: function () {
                Object.defineProperty(this, prop, {
                    value: undefined,
                    writable: true
                });
                var value = cb.call(this, obj, prop);
                Object.defineProperty(this, prop, {
                    value: value,
                    writable: !!writable
                });
                return value;
            },
            set: function (value) {
                Object.defineProperty(this, prop, {
                    value: value,
                    writable: !!writable
                });
                return value;
            }
        });
    };
    eventsProto = assign({}, canEvent);
    assign(eventsProto, {
        _eventSetup: function () {
        },
        _eventTeardown: function () {
        },
        addEventListener: function (eventName, handler) {
            var computedBinding = this._computed && this._computed[eventName];
            if (computedBinding && computedBinding.compute) {
                if (!computedBinding.count) {
                    computedBinding.count = 1;
                    canReflect.onValue(computedBinding.compute, computedBinding.handler);
                    computedBinding.oldValue = canReflect.getValue(computedBinding.compute);
                } else {
                    computedBinding.count++;
                }
            }
            return eventLifecycle.addAndSetup.apply(this, arguments);
        },
        removeEventListener: function (eventName, handler) {
            var computedBinding = this._computed && this._computed[eventName];
            if (computedBinding) {
                if (computedBinding.count === 1) {
                    computedBinding.count = 0;
                    canReflect.offValue(computedBinding.compute, computedBinding.handler);
                } else {
                    computedBinding.count--;
                }
            }
            return eventLifecycle.removeAndTeardown.apply(this, arguments);
        }
    });
    eventsProto.on = eventsProto.bind = eventsProto.addEventListener;
    eventsProto.off = eventsProto.unbind = eventsProto.removeEventListener;
    canReflect.set(eventsProto, canSymbol.for('can.onKeyValue'), function (key, handler) {
        var translationHandler = function (ev, newValue, oldValue) {
            handler(newValue, oldValue);
        };
        singleReference.set(handler, this, translationHandler, key);
        this.addEventListener(key, translationHandler);
    });
    canReflect.set(eventsProto, canSymbol.for('can.offKeyValue'), function (key, handler) {
        this.removeEventListener(key, singleReference.getAndDelete(handler, this, key));
    });
    delete eventsProto.one;
    define.setup = function (props, sealed) {
        CID(this);
        Object.defineProperty(this, '_cid', {
            value: this._cid,
            enumerable: false,
            writable: false
        });
        Object.defineProperty(this, 'constructor', {
            value: this.constructor,
            enumerable: false,
            writable: false
        });
        Object.defineProperty(this, '__bindEvents', {
            value: Object.create(null),
            enumerable: false,
            writable: false
        });
        var definitions = this._define.definitions;
        var instanceDefinitions = Object.create(null);
        var map = this;
        canReflect.eachKey(props, function (value, prop) {
            if (definitions[prop] !== undefined) {
                map[prop] = value;
            } else {
                var def = define.makeSimpleGetterSetter(prop);
                instanceDefinitions[prop] = {};
                Object.defineProperty(map, prop, def);
                map[prop] = define.types.observable(value);
            }
        });
        if (!isEmptyObject(instanceDefinitions)) {
            defineConfigurableAndNotEnumerable(this, '_instanceDefinitions', instanceDefinitions);
        }
    };
    define.replaceWith = replaceWith;
    define.eventsProto = eventsProto;
    define.defineConfigurableAndNotEnumerable = defineConfigurableAndNotEnumerable;
    define.make = make;
    define.getDefinitionOrMethod = getDefinitionOrMethod;
    var simpleGetterSetters = {};
    define.makeSimpleGetterSetter = function (prop) {
        if (!simpleGetterSetters[prop]) {
            var setter = make.set.events(prop, make.get.data(prop), make.set.data(prop), make.eventType.data(prop));
            simpleGetterSetters[prop] = {
                get: make.get.data(prop),
                set: function (newVal) {
                    return setter.call(this, define.types.observable(newVal));
                },
                enumerable: true
            };
        }
        return simpleGetterSetters[prop];
    };
    define.Iterator = function (obj) {
        this.obj = obj;
        this.definitions = Object.keys(obj._define.definitions);
        this.instanceDefinitions = obj._instanceDefinitions ? Object.keys(obj._instanceDefinitions) : Object.keys(obj);
        this.hasGet = typeof obj.get === 'function';
    };
    define.Iterator.prototype.next = function () {
        var key;
        if (this.definitions.length) {
            key = this.definitions.shift();
            var def = this.obj._define.definitions[key];
            if (def.get) {
                return this.next();
            }
        } else if (this.instanceDefinitions.length) {
            key = this.instanceDefinitions.shift();
        } else {
            return {
                value: undefined,
                done: true
            };
        }
        return {
            value: [
                key,
                this.hasGet ? this.obj.get(key) : this.obj[key]
            ],
            done: false
        };
    };
    isDefineType = function (func) {
        return func && func.canDefineType === true;
    };
    define.types = {
        'date': function (str) {
            var type = typeof str;
            if (type === 'string') {
                str = Date.parse(str);
                return isNaN(str) ? null : new Date(str);
            } else if (type === 'number') {
                return new Date(str);
            } else {
                return str;
            }
        },
        'number': function (val) {
            if (val == null) {
                return val;
            }
            return +val;
        },
        'boolean': function (val) {
            if (val == null) {
                return val;
            }
            if (val === 'false' || val === '0' || !val) {
                return false;
            }
            return true;
        },
        'observable': function (newVal) {
            if (isArray(newVal) && types.DefineList) {
                newVal = new types.DefineList(newVal);
            } else if (isPlainObject(newVal) && types.DefineMap) {
                newVal = new types.DefineMap(newVal);
            }
            return newVal;
        },
        'stringOrObservable': function (newVal) {
            if (isArray(newVal)) {
                return new types.DefaultList(newVal);
            } else if (isPlainObject(newVal)) {
                return new types.DefaultMap(newVal);
            } else {
                return define.types.string(newVal);
            }
        },
        'htmlbool': function (val) {
            if (val === '') {
                return true;
            }
            return !!stringToAny(val);
        },
        '*': function (val) {
            return val;
        },
        'any': function (val) {
            return val;
        },
        'string': function (val) {
            if (val == null) {
                return val;
            }
            return '' + val;
        },
        'compute': {
            set: function (newValue, setVal, setErr, oldValue) {
                if (newValue && newValue.isComputed) {
                    return newValue;
                }
                if (oldValue && oldValue.isComputed) {
                    oldValue(newValue);
                    return oldValue;
                }
                return newValue;
            },
            get: function (value) {
                return value && value.isComputed ? value() : value;
            }
        }
    };
});
/*can-define@1.3.2#define-helpers/define-helpers*/
define('can-define@1.3.2#define-helpers/define-helpers', function (require, exports, module) {
    var define = require('can-define');
    var canBatch = require('can-event/batch/batch');
    var canEvent = require('can-event');
    var canReflect = require('can-reflect');
    var defineHelpers = {
        defineExpando: function (map, prop, value) {
            var constructorDefines = map._define.definitions;
            if (constructorDefines && constructorDefines[prop]) {
                return;
            }
            var instanceDefines = map._instanceDefinitions;
            if (!instanceDefines) {
                Object.defineProperty(map, '_instanceDefinitions', {
                    configurable: true,
                    enumerable: false,
                    value: {}
                });
                instanceDefines = map._instanceDefinitions;
            }
            if (!instanceDefines[prop]) {
                var defaultDefinition = map._define.defaultDefinition || { type: define.types.observable };
                define.property(map, prop, defaultDefinition, {}, {});
                map._data[prop] = defaultDefinition.type ? defaultDefinition.type(value) : define.types.observable(value);
                instanceDefines[prop] = defaultDefinition;
                canBatch.start();
                canEvent.dispatch.call(map, {
                    type: '__keys',
                    target: map
                });
                if (map._data[prop] !== undefined) {
                    canEvent.dispatch.call(map, {
                        type: prop,
                        target: map
                    }, [
                        map._data[prop],
                        undefined
                    ]);
                }
                canBatch.stop();
                return true;
            }
        },
        reflectSerialize: function (unwrapped) {
            var constructorDefinitions = this._define.definitions;
            var defaultDefinition = this._define.defaultDefinition;
            this.each(function (val, name) {
                var propDef = constructorDefinitions[name];
                if (propDef && typeof propDef.serialize === 'function') {
                    val = propDef.serialize.call(this, val, name);
                } else if (defaultDefinition && typeof defaultDefinition.serialize === 'function') {
                    val = defaultDefinition.serialize.call(this, val, name);
                } else {
                    val = canReflect.serialize(val);
                }
                if (val !== undefined) {
                    unwrapped[name] = val;
                }
            }, this);
            return unwrapped;
        },
        reflectUnwrap: function (unwrapped) {
            this.forEach(function (value, key) {
                if (value !== undefined) {
                    unwrapped[key] = canReflect.unwrap(value);
                }
            });
            return unwrapped;
        }
    };
    module.exports = defineHelpers;
});
/*can-define@1.3.2#map/map*/
define('can-define@1.3.2#map/map', function (require, exports, module) {
    var Construct = require('can-construct');
    var define = require('can-define');
    var defineHelpers = require('../define-helpers/define-helpers');
    var Observation = require('can-observation');
    var types = require('can-types');
    var canBatch = require('can-event/batch/batch');
    var ns = require('can-namespace');
    var canLog = require('can-util/js/log/log');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var CIDSet = require('can-util/js/cid-set/cid-set');
    var CIDMap = require('can-util/js/cid-map/cid-map');
    var keysForDefinition = function (definitions) {
        var keys = [];
        for (var prop in definitions) {
            var definition = definitions[prop];
            if (typeof definition !== 'object' || ('serialize' in definition ? !!definition.serialize : !definition.get)) {
                keys.push(prop);
            }
        }
        return keys;
    };
    function assignDeep(source) {
        canBatch.start();
        canReflect.assignDeepMap(this, source || {});
        canBatch.stop();
    }
    function updateDeep(source) {
        canBatch.start();
        canReflect.updateDeepMap(this, source || {});
        canBatch.stop();
    }
    function setKeyValue(key, value) {
        var defined = defineHelpers.defineExpando(this, key, value);
        if (!defined) {
            this[key] = value;
        }
    }
    function getKeyValue(key) {
        var value = this[key];
        if (value !== undefined || key in this || Object.isSealed(this)) {
            return value;
        } else {
            Observation.add(this, key);
            return this[key];
        }
    }
    var DefineMap = Construct.extend('DefineMap', {
        setup: function (base) {
            var key, prototype = this.prototype;
            if (DefineMap) {
                define(prototype, prototype, base.prototype._define);
                for (key in DefineMap.prototype) {
                    define.defineConfigurableAndNotEnumerable(prototype, key, prototype[key]);
                }
                this.prototype.setup = function (props) {
                    define.setup.call(this, props || {}, this.constructor.seal);
                };
            } else {
                for (key in prototype) {
                    define.defineConfigurableAndNotEnumerable(prototype, key, prototype[key]);
                }
            }
            define.defineConfigurableAndNotEnumerable(prototype, 'constructor', this);
        }
    }, {
        setup: function (props, sealed) {
            if (!this._define) {
                Object.defineProperty(this, '_define', {
                    enumerable: false,
                    value: { definitions: {} }
                });
                Object.defineProperty(this, '_data', {
                    enumerable: false,
                    value: {}
                });
            }
            define.setup.call(this, props || {}, sealed === true);
        },
        get: function (prop) {
            if (prop) {
                return getKeyValue.call(this, prop);
            } else {
                return canReflect.unwrap(this, CIDMap);
            }
        },
        set: function (prop, value) {
            if (typeof prop === 'object') {
                if (value === true) {
                    updateDeep.call(this, prop);
                } else {
                    assignDeep.call(this, prop);
                }
            } else {
                setKeyValue.call(this, prop, value);
            }
            return this;
        },
        serialize: function () {
            return canReflect.serialize(this, CIDMap);
        },
        forEach: function () {
            var forEach = function (list, cb, thisarg) {
                    return canReflect.eachKey(list, cb, thisarg);
                }, noObserve = Observation.ignore(forEach);
            return function (cb, thisarg, observe) {
                return observe === false ? noObserve(this, cb, thisarg) : forEach(this, cb, thisarg);
            };
        }(),
        '*': { type: define.types.observable }
    });
    canReflect.assignSymbols(DefineMap.prototype, {
        'can.isMapLike': true,
        'can.isListLike': false,
        'can.isValueLike': false,
        'can.getKeyValue': getKeyValue,
        'can.setKeyValue': setKeyValue,
        'can.deleteKeyValue': function (prop) {
            this.set(prop, undefined);
            return this;
        },
        'can.getOwnEnumerableKeys': function () {
            Observation.add(this, '__keys');
            return keysForDefinition(this._define.definitions).concat(keysForDefinition(this._instanceDefinitions));
        },
        'can.assignDeep': assignDeep,
        'can.updateDeep': updateDeep,
        'can.unwrap': defineHelpers.reflectUnwrap,
        'can.serialize': defineHelpers.reflectSerialize,
        'can.keyHasDependencies': function (key) {
            return !!(this._computed && this._computed[key] && this._computed[key].compute);
        },
        'can.getKeyDependencies': function (key) {
            var ret;
            if (this._computed && this._computed[key] && this._computed[key].compute) {
                ret = {};
                ret.valueDependencies = new CIDSet();
                ret.valueDependencies.add(this._computed[key].compute);
            }
            return ret;
        }
    });
    canReflect.setKeyValue(DefineMap.prototype, canSymbol.iterator, function () {
        return new define.Iterator(this);
    });
    for (var prop in define.eventsProto) {
        DefineMap[prop] = define.eventsProto[prop];
        Object.defineProperty(DefineMap.prototype, prop, {
            enumerable: false,
            value: define.eventsProto[prop],
            writable: true
        });
    }
    var eventsProtoSymbols = 'getOwnPropertySymbols' in Object ? Object.getOwnPropertySymbols(define.eventsProto) : [
        canSymbol.for('can.onKeyValue'),
        canSymbol.for('can.offKeyValue')
    ];
    eventsProtoSymbols.forEach(function (sym) {
        Object.defineProperty(DefineMap.prototype, sym, {
            enumerable: false,
            value: define.eventsProto[sym],
            writable: true
        });
    });
    types.DefineMap = DefineMap;
    types.DefaultMap = DefineMap;
    Object.defineProperty(DefineMap.prototype, 'toObject', {
        enumerable: false,
        writable: true,
        value: function () {
            canLog.warn('Use DefineMap::get instead of DefineMap::toObject');
            return this.get();
        }
    });
    Object.defineProperty(DefineMap.prototype, 'each', {
        enumerable: false,
        writable: true,
        value: DefineMap.prototype.forEach
    });
    module.exports = ns.DefineMap = DefineMap;
});
/*can-component@3.3.0#test/component-define-test*/
define('can-component@3.3.0#test/component-define-test', function (require, exports, module) {
    var Component = require('can-component');
    var stache = require('can-stache');
    var QUnit = require('steal-qunit');
    var define = require('can-define');
    var DefineMap = require('can-define/map/map');
    var viewModel = require('can-view-model');
    var types = require('can-types');
    QUnit.module('can-component with can-define');
    QUnit.test('Works with can-define', function () {
        var VM = define.Constructor({
            firstName: { type: 'string' },
            lastName: { type: 'string' },
            fullName: {
                get: function () {
                    return [
                        this.firstName,
                        this.lastName
                    ].join(' ');
                }
            }
        });
        Component.extend({
            tag: 'can-define-component',
            ViewModel: VM,
            view: stache('Name: {{fullName}}')
        });
        var frag = stache('<can-define-component {first-name}="firstName" {last-name}="lastName" />')({
            firstName: 'Chris',
            lastName: 'Gomez'
        });
        var vm = viewModel(frag.firstChild);
        QUnit.ok(vm instanceof VM, 'Constructor was called');
        QUnit.equal(vm.firstName, 'Chris', 'ViewModel was set from scope');
        QUnit.equal(vm.lastName, 'Gomez', 'ViewModel was set from scope');
        QUnit.equal(frag.firstChild.innerHTML, 'Name: Chris Gomez', 'Rendered fullName');
        vm.firstName = 'Justin';
        vm.lastName = 'Meyer';
        QUnit.equal(frag.firstChild.innerHTML, 'Name: Justin Meyer', 'Rendered fullName after change');
    });
    QUnit.test('scope method works', function () {
        Component.extend({
            tag: 'my-element',
            viewModel: function (properties, scope, element) {
                QUnit.deepEqual(properties, {
                    first: 'Justin',
                    last: 'Meyer'
                });
                return new types.DefaultMap(properties);
            }
        });
        stache('<my-element {first}=\'firstName\' last=\'Meyer\'/>')({
            firstName: 'Justin',
            middleName: 'Barry'
        });
    });
    QUnit.test('33 - works when instantiated with an object for ViewModel', function () {
        Component.extend({
            tag: 'test-element',
            view: stache('{{someMethod}}'),
            ViewModel: {
                someMethod: function () {
                    ok(true, 'Function got called');
                    return true;
                }
            }
        });
        var renderer = stache('<test-element>');
        renderer();
    });
});
/*can-map@3.3.1#bubble*/
define('can-map@3.3.1#bubble', function (require, exports, module) {
    var canEvent = require('can-event');
    var makeArray = require('can-util/js/make-array/make-array');
    var canReflect = require('can-reflect');
    var isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');
    var bubble = {
        bind: function (parent, eventName) {
            if (!parent.__inSetup) {
                var bubbleEvents = bubble.events(parent, eventName), len = bubbleEvents.length, bubbleEvent;
                if (!parent._bubbleBindings) {
                    parent._bubbleBindings = {};
                }
                for (var i = 0; i < len; i++) {
                    bubbleEvent = bubbleEvents[i];
                    if (!parent._bubbleBindings[bubbleEvent]) {
                        parent._bubbleBindings[bubbleEvent] = 1;
                        bubble.childrenOf(parent, bubbleEvent);
                    } else {
                        parent._bubbleBindings[bubbleEvent]++;
                    }
                }
            }
        },
        unbind: function (parent, eventName) {
            var bubbleEvents = bubble.events(parent, eventName), len = bubbleEvents.length, bubbleEvent;
            for (var i = 0; i < len; i++) {
                bubbleEvent = bubbleEvents[i];
                if (parent._bubbleBindings) {
                    parent._bubbleBindings[bubbleEvent]--;
                }
                if (parent._bubbleBindings && !parent._bubbleBindings[bubbleEvent]) {
                    delete parent._bubbleBindings[bubbleEvent];
                    bubble.teardownChildrenFrom(parent, bubbleEvent);
                    if (isEmptyObject(parent._bubbleBindings)) {
                        delete parent._bubbleBindings;
                    }
                }
            }
        },
        add: function (parent, child, prop) {
            if (canReflect.isObservableLike(child) && canReflect.isMapLike(child) && parent._bubbleBindings) {
                for (var eventName in parent._bubbleBindings) {
                    if (parent._bubbleBindings[eventName]) {
                        bubble.teardownFromParent(parent, child, eventName);
                        bubble.toParent(child, parent, prop, eventName);
                    }
                }
            }
        },
        addMany: function (parent, children) {
            for (var i = 0, len = children.length; i < len; i++) {
                bubble.add(parent, children[i], i);
            }
        },
        remove: function (parent, child) {
            if (canReflect.isObservableLike(child) && canReflect.isMapLike(child) && parent._bubbleBindings) {
                for (var eventName in parent._bubbleBindings) {
                    if (parent._bubbleBindings[eventName]) {
                        bubble.teardownFromParent(parent, child, eventName);
                    }
                }
            }
        },
        removeMany: function (parent, children) {
            for (var i = 0, len = children.length; i < len; i++) {
                bubble.remove(parent, children[i]);
            }
        },
        set: function (parent, prop, value, current) {
            if (canReflect.isObservableLike(value) && canReflect.isMapLike(value)) {
                bubble.add(parent, value, prop);
            }
            if (canReflect.isObservableLike(current) && canReflect.isMapLike(current)) {
                bubble.remove(parent, current);
            }
            return value;
        },
        events: function (map, boundEventName) {
            return map.constructor._bubbleRule(boundEventName, map);
        },
        toParent: function (child, parent, prop, eventName) {
            canEvent.listenTo.call(parent, child, eventName, function () {
                var args = makeArray(arguments), ev = args.shift();
                args[0] = (canReflect.isObservableLike(parent) && canReflect.isListLike(parent) ? parent.indexOf(child) : prop) + (args[0] ? '.' + args[0] : '');
                ev.triggeredNS = ev.triggeredNS || {};
                if (ev.triggeredNS[parent._cid]) {
                    return;
                }
                ev.triggeredNS[parent._cid] = true;
                canEvent.dispatch.call(parent, ev, args);
                if (eventName === 'change') {
                    canEvent.dispatch.call(parent, args[0], [
                        args[2],
                        args[3]
                    ]);
                }
            });
        },
        childrenOf: function (parent, eventName) {
            parent._each(function (child, prop) {
                if (child && child.bind) {
                    bubble.toParent(child, parent, prop, eventName);
                }
            });
        },
        teardownFromParent: function (parent, child, eventName) {
            if (child && child.unbind) {
                canEvent.stopListening.call(parent, child, eventName);
            }
        },
        teardownChildrenFrom: function (parent, eventName) {
            parent._each(function (child) {
                bubble.teardownFromParent(parent, child, eventName);
            });
        },
        isBubbling: function (parent, eventName) {
            return parent._bubbleBindings && parent._bubbleBindings[eventName];
        }
    };
    module.exports = bubble;
});
/*can-util@3.9.6#js/is-promise/is-promise*/
define('can-util@3.9.6#js/is-promise/is-promise', function (require, exports, module) {
    'use strict';
    var canReflect = require('can-reflect');
    module.exports = function (obj) {
        return canReflect.isPromise(obj);
    };
});
/*can-map@3.3.1#map-helpers*/
define('can-map@3.3.1#map-helpers', function (require, exports, module) {
    var isPlainObject = require('can-util/js/is-plain-object/is-plain-object');
    var isPromise = require('can-util/js/is-promise/is-promise');
    var CID = require('can-cid');
    var assign = require('can-util/js/assign/assign');
    var canReflect = require('can-reflect');
    var madeMap = null;
    var teardownMap = function () {
        for (var cid in madeMap) {
            if (madeMap[cid].added) {
                delete madeMap[cid].obj._cid;
            }
        }
        madeMap = null;
    };
    var mapHelpers = {
        attrParts: function (attr, keepKey) {
            if (keepKey) {
                return [attr];
            }
            return typeof attr === 'object' ? attr : ('' + attr).split('.');
        },
        canMakeObserve: function (obj) {
            return obj && !isPromise(obj) && (Array.isArray(obj) || isPlainObject(obj));
        },
        reflectSerialize: function (unwrapped) {
            this.each(function (val, name) {
                if (this.___serialize) {
                    val = this.___serialize(name, val);
                } else {
                    val = canReflect.serialize(val);
                }
                if (val !== undefined) {
                    unwrapped[name] = val;
                }
            }, this);
            return unwrapped;
        },
        reflectUnwrap: function (unwrapped) {
            this.each(function (value, key) {
                if (value !== undefined) {
                    unwrapped[key] = canReflect.unwrap(value);
                }
            });
            return unwrapped;
        },
        removeSpecialKeys: function (map) {
            if (map) {
                [
                    '_data',
                    'constructor',
                    '_cid',
                    '__bindEvents'
                ].forEach(function (key) {
                    delete map[key];
                });
            }
            return map;
        },
        define: null,
        addComputedAttr: function (map, attrName, compute) {
            map._computedAttrs[attrName] = {
                compute: compute,
                count: 0,
                handler: function (newVal, oldVal) {
                    map._triggerChange(attrName, 'set', newVal, oldVal);
                }
            };
        },
        addToMap: function addToMap(obj, instance) {
            var teardown;
            if (!madeMap) {
                teardown = teardownMap;
                madeMap = {};
            }
            var hasCid = obj._cid;
            var cid = CID(obj);
            if (!madeMap[cid]) {
                madeMap[cid] = {
                    obj: obj,
                    instance: instance,
                    added: !hasCid
                };
            }
            return teardown;
        },
        getMapFromObject: function (obj) {
            return madeMap && madeMap[obj._cid] && madeMap[obj._cid].instance;
        },
        twoLevelDeepExtend: function (destination, source) {
            for (var prop in source) {
                destination[prop] = destination[prop] || {};
                assign(destination[prop], source[prop]);
            }
        }
    };
    module.exports = exports = mapHelpers;
});
/*can-map@3.3.1#can-map*/
define('can-map@3.3.1#can-map', function (require, exports, module) {
    var bubble = require('./bubble');
    var mapHelpers = require('./map-helpers');
    var canEvent = require('can-event');
    var canBatch = require('can-event/batch/batch');
    var eventLifecycle = require('can-event/lifecycle/lifecycle');
    var Construct = require('can-construct');
    var Observation = require('can-observation');
    var ObserveReader = require('can-stache-key');
    var canCompute = require('can-compute');
    var singleReference = require('can-util/js/single-reference/single-reference');
    var namespace = require('can-namespace');
    var dev = require('can-util/js/dev/dev');
    var CID = require('can-cid');
    var deepAssign = require('can-util/js/deep-assign/deep-assign');
    var isFunction = require('can-util/js/is-function/is-function');
    var assign = require('can-util/js/assign/assign');
    var types = require('can-types');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var CIDSet = require('can-util/js/cid-set/cid-set');
    var CIDMap = require('can-util/js/cid-map/cid-map');
    var unobservable = { 'constructor': true };
    var hasOwnProperty = {}.hasOwnProperty;
    var Map = Construct.extend({
        setup: function (baseMap) {
            Construct.setup.apply(this, arguments);
            this._computedPropertyNames = [];
            if (Map) {
                if (!this.defaults) {
                    this.defaults = {};
                }
                for (var prop in this.prototype) {
                    if (prop !== 'define' && prop !== 'constructor' && (typeof this.prototype[prop] !== 'function' || this.prototype[prop].prototype instanceof Construct)) {
                        this.defaults[prop] = this.prototype[prop];
                    } else if (this.prototype[prop].isComputed) {
                        this._computedPropertyNames.push(prop);
                    }
                }
                if (mapHelpers.define) {
                    mapHelpers.define(this, baseMap.prototype.define);
                }
            }
        },
        shortName: 'Map',
        _bubbleRule: function (eventName) {
            return eventName === 'change' || eventName.indexOf('.') >= 0 ? ['change'] : [];
        },
        addEventListener: eventLifecycle.addAndSetup,
        removeEventListener: eventLifecycle.removeAndTeardown,
        keys: function (map) {
            Observation.add(map, '__keys');
            return canReflect.getOwnEnumerableKeys(map._data);
        }
    }, {
        setup: function (obj) {
            if (canReflect.isObservableLike(obj) && typeof obj.serialize === 'function') {
                obj = obj.serialize();
            }
            this._data = Object.create(null);
            CID(this, '.map');
            this._setupComputedProperties();
            var teardownMapping = obj && mapHelpers.addToMap(obj, this);
            var defaultValues = this._setupDefaults(obj);
            var data = assign(deepAssign(true, {}, defaultValues), obj);
            this.attr(data);
            if (teardownMapping) {
                teardownMapping();
            }
        },
        _setupComputedProperties: function () {
            this._computedAttrs = Object.create(null);
            var computes = this.constructor._computedPropertyNames;
            for (var i = 0, len = computes.length; i < len; i++) {
                var attrName = computes[i];
                mapHelpers.addComputedAttr(this, attrName, this[attrName].clone(this));
            }
        },
        _setupDefaults: function () {
            return this.constructor.defaults || {};
        },
        attr: function (attr, val) {
            var type = typeof attr;
            if (attr === undefined) {
                return this._getAttrs();
            } else if (type !== 'string' && type !== 'number') {
                return this._setAttrs(attr, val);
            } else if (arguments.length === 1) {
                return this._get(attr + '');
            } else {
                this._set(attr + '', val);
                return this;
            }
        },
        _get: function (attr) {
            var dotIndex = attr.indexOf('.');
            if (dotIndex >= 0) {
                var value = this.___get(attr);
                if (value !== undefined) {
                    Observation.add(this, attr);
                    return value;
                }
                var first = attr.substr(0, dotIndex), second = attr.substr(dotIndex + 1);
                var current = this.__get(first);
                return current && canReflect.getKeyValue(current, second);
            } else {
                return this.__get(attr);
            }
        },
        __get: function (attr) {
            if (!unobservable[attr] && !this._computedAttrs[attr]) {
                Observation.add(this, attr);
            }
            return this.___get(attr);
        },
        ___get: function (attr) {
            if (attr !== undefined) {
                var computedAttr = this._computedAttrs[attr];
                if (computedAttr && computedAttr.compute) {
                    return computedAttr.compute();
                } else {
                    return hasOwnProperty.call(this._data, attr) ? this._data[attr] : undefined;
                }
            } else {
                return this._data;
            }
        },
        _set: function (attr, value, keepKey) {
            var dotIndex = attr.indexOf('.'), current;
            if (dotIndex >= 0 && !keepKey) {
                var first = attr.substr(0, dotIndex), second = attr.substr(dotIndex + 1);
                current = this.__inSetup ? undefined : this.___get(first);
                if (canReflect.isMapLike(current)) {
                    canReflect.setKeyValue(current, second, value);
                } else {
                    current = this.__inSetup ? undefined : this.___get(attr);
                    if (this.__convert) {
                        value = this.__convert(attr, value);
                    }
                    this.__set(attr, this.__type(value, attr), current);
                }
            } else {
                current = this.__inSetup ? undefined : this.___get(attr);
                if (this.__convert) {
                    value = this.__convert(attr, value);
                }
                this.__set(attr, this.__type(value, attr), current);
            }
        },
        __type: function (value, prop) {
            if (typeof value === 'object' && !canReflect.isObservableLike(value) && mapHelpers.canMakeObserve(value) && !canReflect.isListLike(value)) {
                var cached = mapHelpers.getMapFromObject(value);
                if (cached) {
                    return cached;
                }
                var MapConstructor = this.constructor.Map || Map;
                return new MapConstructor(value);
            }
            return value;
        },
        __set: function (prop, value, current) {
            if (value !== current) {
                var computedAttr = this._computedAttrs[prop];
                var changeType = computedAttr || current !== undefined || hasOwnProperty.call(this.___get(), prop) ? 'set' : 'add';
                this.___set(prop, typeof value === 'object' ? bubble.set(this, prop, value, current) : value);
                if (!computedAttr || !computedAttr.count) {
                    this._triggerChange(prop, changeType, value, current);
                }
                if (typeof current === 'object') {
                    bubble.teardownFromParent(this, current);
                }
            }
        },
        ___set: function (prop, val) {
            var computedAttr = this._computedAttrs[prop];
            if (computedAttr) {
                computedAttr.compute(val);
            } else {
                this._data[prop] = val;
            }
            if (typeof this.constructor.prototype[prop] !== 'function' && !computedAttr) {
                this[prop] = val;
            }
        },
        removeAttr: function (attr) {
            return this._remove(attr);
        },
        _remove: function (attr) {
            var parts = mapHelpers.attrParts(attr), prop = parts.shift(), current = this.___get(prop);
            if (parts.length && current) {
                return canReflect.deleteKeyValue(current, parts.join('.'));
            } else {
                if (typeof attr === 'string' && !!~attr.indexOf('.')) {
                    prop = attr;
                }
                this.__remove(prop, current);
                return current;
            }
        },
        __remove: function (prop, current) {
            if (prop in this._data) {
                this.___remove(prop);
                this._triggerChange(prop, 'remove', undefined, current);
            }
        },
        ___remove: function (prop) {
            delete this._data[prop];
            if (!(prop in this.constructor.prototype)) {
                delete this[prop];
            }
        },
        ___serialize: function (name, val) {
            return canReflect.serialize(val, CIDMap);
        },
        _getAttrs: function () {
            return canReflect.unwrap(this, CIDMap);
        },
        _setAttrs: function (props, remove) {
            if (remove === true) {
                this[canSymbol.for('can.updateDeep')](props);
            } else {
                this[canSymbol.for('can.assignDeep')](props);
            }
            return this;
        },
        serialize: function () {
            return canReflect.serialize(this, CIDMap);
        },
        _triggerChange: function (attr, how, newVal, oldVal, batchNum) {
            if (bubble.isBubbling(this, 'change')) {
                canEvent.dispatch.call(this, {
                    type: 'change',
                    target: this,
                    batchNum: batchNum
                }, [
                    attr,
                    how,
                    newVal,
                    oldVal
                ]);
            }
            canEvent.dispatch.call(this, {
                type: attr,
                target: this,
                batchNum: batchNum
            }, [
                newVal,
                oldVal
            ]);
            if (how === 'remove' || how === 'add') {
                canEvent.dispatch.call(this, {
                    type: '__keys',
                    target: this,
                    batchNum: batchNum
                });
            }
        },
        _eventSetup: function () {
        },
        _eventTeardown: function () {
        },
        one: canEvent.one,
        addEventListener: function (eventName, handler) {
            var computedBinding = this._computedAttrs && this._computedAttrs[eventName];
            if (computedBinding && computedBinding.compute) {
                if (!computedBinding.count) {
                    computedBinding.count = 1;
                    computedBinding.compute.addEventListener('change', function (ev, newVal, oldVal) {
                        computedBinding.handler(newVal, oldVal);
                    });
                } else {
                    computedBinding.count++;
                }
            }
            bubble.bind(this, eventName);
            return eventLifecycle.addAndSetup.apply(this, arguments);
        },
        removeEventListener: function (eventName, handler) {
            var computedBinding = this._computedAttrs && this._computedAttrs[eventName];
            if (computedBinding) {
                if (computedBinding.count === 1) {
                    computedBinding.count = 0;
                    canReflect.offValue(computedBinding.compute, computedBinding.handler);
                } else {
                    computedBinding.count--;
                }
            }
            bubble.unbind(this, eventName);
            return eventLifecycle.removeAndTeardown.apply(this, arguments);
        },
        compute: function (prop) {
            if (isFunction(this.constructor.prototype[prop])) {
                return canCompute(this[prop], this);
            } else {
                var reads = ObserveReader.reads(prop);
                var last = reads.length - 1;
                return canCompute(function (newVal) {
                    if (arguments.length) {
                        ObserveReader.write(this, reads[last].key, newVal, {});
                    } else {
                        return ObserveReader.get(this, prop);
                    }
                }, this);
            }
        },
        each: function (callback, context) {
            var key, item;
            var keys = Map.keys(this);
            for (var i = 0, len = keys.length; i < len; i++) {
                key = keys[i];
                item = this.attr(key);
                if (callback.call(context || item, item, key, this) === false) {
                    break;
                }
            }
            return this;
        },
        _each: function (callback) {
            var data = this.___get();
            for (var prop in data) {
                if (hasOwnProperty.call(data, prop)) {
                    callback(data[prop], prop);
                }
            }
        },
        dispatch: canEvent.dispatch
    });
    Map.prototype.on = Map.prototype.bind = Map.prototype.addEventListener;
    Map.prototype.off = Map.prototype.unbind = Map.prototype.removeEventListener;
    Map.on = Map.bind = Map.addEventListener;
    Map.off = Map.unbind = Map.removeEventListener;
    canReflect.assignSymbols(Map.prototype, {
        'can.isMapLike': true,
        'can.isListLike': false,
        'can.isValueLike': false,
        'can.getKeyValue': Map.prototype._get,
        'can.setKeyValue': Map.prototype._set,
        'can.deleteKeyValue': Map.prototype._remove,
        'can.getOwnEnumerableKeys': function () {
            Observation.add(this, '__keys');
            return Object.keys(this._data);
        },
        'can.assignDeep': function (source) {
            canBatch.start();
            canReflect.assignDeepMap(this, mapHelpers.removeSpecialKeys(canReflect.assignMap({}, source)));
            canBatch.stop();
        },
        'can.updateDeep': function (source) {
            canBatch.start();
            canReflect.updateDeepMap(this, mapHelpers.removeSpecialKeys(canReflect.assignMap({}, source)));
            canBatch.stop();
        },
        'can.unwrap': mapHelpers.reflectUnwrap,
        'can.serialize': mapHelpers.reflectSerialize,
        'can.onKeyValue': function (key, handler) {
            var translationHandler = function (ev, newValue, oldValue) {
                handler.call(this, newValue, oldValue);
            };
            singleReference.set(handler, this, translationHandler, key);
            this.addEventListener(key, translationHandler);
        },
        'can.offKeyValue': function (key, handler) {
            this.removeEventListener(key, singleReference.getAndDelete(handler, this, key));
        },
        'can.keyHasDependencies': function (key) {
            return !!(this._computedAttrs && this._computedAttrs[key] && this._computedAttrs[key].compute);
        },
        'can.getKeyDependencies': function (key) {
            var ret;
            if (this._computedAttrs && this._computedAttrs[key] && this._computedAttrs[key].compute) {
                ret = {};
                ret.valueDependencies = new CIDSet();
                ret.valueDependencies.add(this._computedAttrs[key].compute);
            }
            return ret;
        }
    });
    if (!types.DefaultMap) {
        types.DefaultMap = Map;
    }
    module.exports = namespace.Map = Map;
});
/*can-list@3.2.0#can-list*/
define('can-list@3.2.0#can-list', function (require, exports, module) {
    require('can-event');
    var namespace = require('can-namespace');
    var Map = require('can-map');
    var bubble = require('can-map/bubble');
    var mapHelpers = require('can-map/map-helpers');
    var canBatch = require('can-event/batch/batch');
    var canEvent = require('can-event');
    var Observation = require('can-observation');
    var CID = require('can-cid');
    var isPromise = require('can-util/js/is-promise/is-promise');
    var makeArray = require('can-util/js/make-array/make-array');
    var assign = require('can-util/js/assign/assign');
    var types = require('can-types');
    var each = require('can-util/js/each/each');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var CIDMap = require('can-util/js/cid-map/cid-map');
    var splice = [].splice, spliceRemovesProps = function () {
            var obj = {
                0: 'a',
                length: 1
            };
            splice.call(obj, 0, 1);
            return !obj[0];
        }();
    var serializeNonTypes = function (MapType, arg, args) {
        if (arg && arg.serialize && !(arg instanceof MapType)) {
            args.push(new MapType(arg.serialize()));
        } else {
            args.push(arg);
        }
    };
    var List = Map.extend({ Map: Map }, {
            setup: function (instances, options) {
                this.length = 0;
                CID(this, '.map');
                this._setupComputedProperties();
                instances = instances || [];
                var teardownMapping;
                if (isPromise(instances)) {
                    this.replace(instances);
                } else {
                    teardownMapping = instances.length && mapHelpers.addToMap(instances, this);
                    this.push.apply(this, makeArray(instances || []));
                }
                if (teardownMapping) {
                    teardownMapping();
                }
                assign(this, options);
            },
            _triggerChange: function (attr, how, newVal, oldVal) {
                Map.prototype._triggerChange.apply(this, arguments);
                var index = +attr;
                if (!~('' + attr).indexOf('.') && !isNaN(index)) {
                    if (how === 'add') {
                        canEvent.dispatch.call(this, how, [
                            newVal,
                            index
                        ]);
                        canEvent.dispatch.call(this, 'length', [this.length]);
                    } else if (how === 'remove') {
                        canEvent.dispatch.call(this, how, [
                            oldVal,
                            index
                        ]);
                        canEvent.dispatch.call(this, 'length', [this.length]);
                    } else {
                        canEvent.dispatch.call(this, how, [
                            newVal,
                            index
                        ]);
                    }
                }
            },
            ___get: function (attr) {
                if (attr) {
                    var computedAttr = this._computedAttrs[attr];
                    if (computedAttr && computedAttr.compute) {
                        return canReflect.getValue(computedAttr.compute);
                    }
                    if (this[attr] && this[attr].isComputed && typeof this.constructor.prototype[attr] === 'function') {
                        return canReflect.getValue(this[attr]);
                    } else {
                        return this[attr];
                    }
                } else {
                    return this;
                }
            },
            __set: function (prop, value, current) {
                prop = isNaN(+prop) || prop % 1 ? prop : +prop;
                if (typeof prop === 'number') {
                    if (prop > this.length - 1) {
                        var newArr = new Array(prop + 1 - this.length);
                        newArr[newArr.length - 1] = value;
                        this.push.apply(this, newArr);
                        return newArr;
                    } else {
                        this.splice(prop, 1, value);
                        return this;
                    }
                }
                return Map.prototype.__set.call(this, '' + prop, value, current);
            },
            ___set: function (attr, val) {
                this[attr] = val;
                if (+attr >= this.length) {
                    this.length = +attr + 1;
                }
            },
            __remove: function (prop, current) {
                if (isNaN(+prop)) {
                    delete this[prop];
                    this._triggerChange(prop, 'remove', undefined, current);
                } else {
                    this.splice(prop, 1);
                }
            },
            _each: function (callback) {
                var data = this.___get();
                for (var i = 0; i < data.length; i++) {
                    callback(data[i], i);
                }
            },
            serialize: function () {
                return canReflect.serialize(this, CIDMap);
            },
            splice: function (index, howMany) {
                var args = makeArray(arguments), added = [], i, len, listIndex, allSame = args.length > 2;
                index = index || 0;
                for (i = 0, len = args.length - 2; i < len; i++) {
                    listIndex = i + 2;
                    args[listIndex] = this.__type(args[listIndex], listIndex);
                    added.push(args[listIndex]);
                    if (this[i + index] !== args[listIndex]) {
                        allSame = false;
                    }
                }
                if (allSame && this.length <= added.length) {
                    return added;
                }
                if (howMany === undefined) {
                    howMany = args[1] = this.length - index;
                }
                var removed = splice.apply(this, args);
                if (!spliceRemovesProps) {
                    for (i = this.length; i < removed.length + this.length; i++) {
                        delete this[i];
                    }
                }
                canBatch.start();
                if (howMany > 0) {
                    bubble.removeMany(this, removed);
                    this._triggerChange('' + index, 'remove', undefined, removed);
                }
                if (args.length > 2) {
                    bubble.addMany(this, added);
                    this._triggerChange('' + index, 'add', added, removed);
                }
                canBatch.stop();
                return removed;
            }
        }), getArgs = function (args) {
            return args[0] && Array.isArray(args[0]) ? args[0] : makeArray(args);
        };
    each({
        push: 'length',
        unshift: 0
    }, function (where, name) {
        var orig = [][name];
        List.prototype[name] = function () {
            var args = [], len = where ? this.length : 0, i = arguments.length, res, val;
            while (i--) {
                val = arguments[i];
                args[i] = bubble.set(this, i, this.__type(val, i));
            }
            res = orig.apply(this, args);
            if (!this.comparator || args.length) {
                this._triggerChange('' + len, 'add', args, undefined);
            }
            return res;
        };
    });
    each({
        pop: 'length',
        shift: 0
    }, function (where, name) {
        List.prototype[name] = function () {
            if (!this.length) {
                return undefined;
            }
            var args = getArgs(arguments), len = where && this.length ? this.length - 1 : 0;
            var res = [][name].apply(this, args);
            this._triggerChange('' + len, 'remove', undefined, [res]);
            if (res && res.removeEventListener) {
                bubble.remove(this, res);
            }
            return res;
        };
    });
    assign(List.prototype, {
        indexOf: function (item, fromIndex) {
            Observation.add(this, 'length');
            for (var i = fromIndex || 0, len = this.length; i < len; i++) {
                if (this.attr(i) === item) {
                    return i;
                }
            }
            return -1;
        },
        join: function () {
            Observation.add(this, 'length');
            return [].join.apply(this, arguments);
        },
        reverse: function () {
            var list = [].reverse.call(makeArray(this));
            return this.replace(list);
        },
        slice: function () {
            Observation.add(this, 'length');
            var temp = Array.prototype.slice.apply(this, arguments);
            return new this.constructor(temp);
        },
        concat: function () {
            var args = [], MapType = this.constructor.Map;
            each(arguments, function (arg) {
                if (canReflect.isObservableLike(arg) && canReflect.isListLike(arg) || Array.isArray(arg)) {
                    var arr = canReflect.isObservableLike(arg) && canReflect.isListLike(arg) ? makeArray(arg) : arg;
                    each(arr, function (innerArg) {
                        serializeNonTypes(MapType, innerArg, args);
                    });
                } else {
                    serializeNonTypes(MapType, arg, args);
                }
            });
            return new this.constructor(Array.prototype.concat.apply(makeArray(this), args));
        },
        forEach: function (cb, thisarg) {
            var item;
            for (var i = 0, len = this.attr('length'); i < len; i++) {
                item = this.attr(i);
                if (item !== undefined && cb.call(thisarg || item, item, i, this) === false) {
                    break;
                }
            }
            return this;
        },
        replace: function (newList) {
            if (isPromise(newList)) {
                if (this._promise) {
                    this._promise.__isCurrentPromise = false;
                }
                var promise = this._promise = newList;
                promise.__isCurrentPromise = true;
                var self = this;
                newList.then(function (newList) {
                    if (promise.__isCurrentPromise) {
                        self.replace(newList);
                    }
                });
            } else {
                this.splice.apply(this, [
                    0,
                    this.length
                ].concat(makeArray(newList || [])));
            }
            return this;
        },
        filter: function (callback, thisArg) {
            var filteredList = new this.constructor(), self = this, filtered;
            this.each(function (item, index, list) {
                filtered = callback.call(thisArg || self, item, index, self);
                if (filtered) {
                    filteredList.push(item);
                }
            });
            return filteredList;
        },
        map: function (callback, thisArg) {
            var filteredList = new List(), self = this;
            this.each(function (item, index, list) {
                var mapped = callback.call(thisArg || self, item, index, self);
                filteredList.push(mapped);
            });
            return filteredList;
        }
    });
    var oldType = Map.prototype.__type;
    Map.prototype.__type = function (value, prop) {
        if (typeof value === 'object' && Array.isArray(value)) {
            var cached = mapHelpers.getMapFromObject(value);
            if (cached) {
                return cached;
            }
            return new List(value);
        }
        return oldType.apply(this, arguments);
    };
    var oldSetup = Map.setup;
    Map.setup = function () {
        oldSetup.apply(this, arguments);
        if (!(this.prototype instanceof List)) {
            this.List = Map.List.extend({ Map: this }, {});
        }
    };
    if (!types.DefaultList) {
        types.DefaultList = List;
    }
    canReflect.assignSymbols(List.prototype, {
        'can.isMoreListLikeThanMapLike': true,
        'can.isListLike': true,
        'can.getKeyValue': List.prototype._get,
        'can.setKeyValue': List.prototype._set,
        'can.deleteKeyValue': List.prototype._remove,
        'can.getOwnEnumerableKeys': function () {
            return Object.keys(this._data || {}).concat(this.map(function (val, index) {
                return index;
            }));
        },
        'can.assignDeep': function (source) {
            canBatch.start();
            canReflect.assignDeepList(this, source);
            canBatch.stop();
        },
        'can.updateDeep': function (source) {
            canBatch.start();
            canReflect.updateDeepList(this, source);
            canBatch.stop();
        },
        'can.unwrap': mapHelpers.reflectUnwrap,
        'can.serialize': mapHelpers.reflectSerialize,
        'can.onKeysAdded': function (handler) {
            this[canSymbol.for('can.onKeyValue')]('add', handler);
        },
        'can.onKeysRemoved': function (handler) {
            this[canSymbol.for('can.onKeyValue')]('remove', handler);
        },
        'can.splice': function (index, deleteCount, insert) {
            this.splice.apply(this, [
                index,
                deleteCount
            ].concat(insert));
        }
    });
    List.prototype.each = List.prototype.forEach;
    Map.List = List;
    module.exports = namespace.List = List;
});
/*can-simple-dom@1.0.10#simple-dom/document/node*/
define('can-simple-dom@1.0.10#simple-dom/document/node', ['exports'], function (exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    function Node(nodeType, nodeName, nodeValue, ownerDocument) {
        this.nodeType = nodeType;
        this.nodeName = nodeName;
        this.nodeValue = nodeValue;
        this.ownerDocument = ownerDocument;
        this.childNodes = new ChildNodes(this);
        this.parentNode = null;
        this.previousSibling = null;
        this.nextSibling = null;
        this.firstChild = null;
        this.lastChild = null;
    }
    Node.prototype._cloneNode = function () {
        return new Node(this.nodeType, this.nodeName, this.nodeValue, this.ownerDocument);
    };
    Node.prototype.cloneNode = function (deep) {
        var node = this._cloneNode();
        if (deep) {
            var child = this.firstChild, nextChild = child;
            while (nextChild) {
                nextChild = child.nextSibling;
                nodeAppendChild.call(node, child.cloneNode(true));
                child = nextChild;
            }
        }
        return node;
    };
    var nodeAppendChild = Node.prototype.appendChild = function (node) {
        if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
            insertFragment(node, this, this.lastChild, null);
            return node;
        }
        if (node.parentNode) {
            nodeRemoveChild.call(node.parentNode, node);
        }
        node.parentNode = this;
        var refNode = this.lastChild;
        if (refNode === null) {
            this.firstChild = node;
            this.lastChild = node;
        } else {
            node.previousSibling = refNode;
            refNode.nextSibling = node;
            this.lastChild = node;
        }
        return node;
    };
    function insertFragment(fragment, newParent, before, after) {
        if (!fragment.firstChild) {
            return;
        }
        var firstChild = fragment.firstChild;
        var lastChild = firstChild;
        var node = firstChild;
        firstChild.previousSibling = before;
        if (before) {
            before.nextSibling = firstChild;
        } else {
            newParent.firstChild = firstChild;
        }
        while (node) {
            node.parentNode = newParent;
            lastChild = node;
            node = node.nextSibling;
        }
        lastChild.nextSibling = after;
        if (after) {
            after.previousSibling = lastChild;
        } else {
            newParent.lastChild = lastChild;
        }
        fragment.firstChild = null;
        fragment.lastChild = null;
    }
    var nodeInsertBefore = Node.prototype.insertBefore = function (node, refNode) {
        if (refNode == null) {
            return nodeAppendChild.call(this, node);
        }
        if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
            insertFragment(node, this, refNode ? refNode.previousSibling : null, refNode);
            return node;
        }
        if (node.parentNode) {
            nodeRemoveChild.call(node.parentNode, node);
        }
        node.parentNode = this;
        var previousSibling = refNode.previousSibling;
        if (previousSibling) {
            previousSibling.nextSibling = node;
            node.previousSibling = previousSibling;
        }
        refNode.previousSibling = node;
        node.nextSibling = refNode;
        if (this.firstChild === refNode) {
            this.firstChild = node;
        }
        return node;
    };
    var nodeRemoveChild = Node.prototype.removeChild = function (refNode) {
        if (this.firstChild === refNode) {
            this.firstChild = refNode.nextSibling;
        }
        if (this.lastChild === refNode) {
            this.lastChild = refNode.previousSibling;
        }
        if (refNode.previousSibling) {
            refNode.previousSibling.nextSibling = refNode.nextSibling;
        }
        if (refNode.nextSibling) {
            refNode.nextSibling.previousSibling = refNode.previousSibling;
        }
        refNode.parentNode = null;
        refNode.nextSibling = null;
        refNode.previousSibling = null;
        return refNode;
    };
    Node.prototype.replaceChild = function (newChild, oldChild) {
        nodeInsertBefore.call(this, newChild, oldChild);
        nodeRemoveChild.call(this, oldChild);
        return oldChild;
    };
    Node.prototype.addEventListener = function () {
    };
    Node.prototype.removeEventListener = function () {
    };
    Node.ELEMENT_NODE = 1;
    Node.ATTRIBUTE_NODE = 2;
    Node.TEXT_NODE = 3;
    Node.CDATA_SECTION_NODE = 4;
    Node.ENTITY_REFERENCE_NODE = 5;
    Node.ENTITY_NODE = 6;
    Node.PROCESSING_INSTRUCTION_NODE = 7;
    Node.COMMENT_NODE = 8;
    Node.DOCUMENT_NODE = 9;
    Node.DOCUMENT_TYPE_NODE = 10;
    Node.DOCUMENT_FRAGMENT_NODE = 11;
    Node.NOTATION_NODE = 12;
    function ChildNodes(node) {
        this.node = node;
    }
    ChildNodes.prototype.item = function (index) {
        var child = this.node.firstChild;
        for (var i = 0; child && index !== i; i++) {
            child = child.nextSibling;
        }
        return child;
    };
    exports.default = Node;
});
/*can-simple-dom@1.0.10#simple-dom/document/style*/
define('can-simple-dom@1.0.10#simple-dom/document/style', ['exports'], function (exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    function CSSStyleDeclaration(node) {
        this.__node = node;
    }
    Object.defineProperty(CSSStyleDeclaration.prototype, 'cssText', {
        enumerable: true,
        configurable: true,
        get: function get() {
            return this.__node.getAttribute('style') || '';
        },
        set: function set(val) {
            this.__node._setAttribute('style', val);
        }
    });
    exports.default = CSSStyleDeclaration;
});
/*can-simple-dom@1.0.10#simple-dom/document/element*/
define('can-simple-dom@1.0.10#simple-dom/document/element', [
    'exports',
    './node',
    './style'
], function (exports, _node, _style) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    var _node2 = _interopRequireDefault(_node);
    var _style2 = _interopRequireDefault(_style);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    var attrSpecial = {
        'class': function _class(element, value) {
            element._className = value;
        }
    };
    function Element(tagName, ownerDocument) {
        tagName = tagName.toUpperCase();
        this.nodeConstructor(1, tagName, null, ownerDocument);
        this.style = new _style2.default(this);
        this.attributes = [];
        this.tagName = tagName;
    }
    Element.prototype = Object.create(_node2.default.prototype);
    Element.prototype.constructor = Element;
    Element.prototype.nodeConstructor = _node2.default;
    Element.prototype._cloneNode = function () {
        var node = this.ownerDocument.createElement(this.tagName);
        node.attributes = this.attributes.map(function (attr) {
            return {
                name: attr.name,
                value: attr.value,
                specified: attr.specified
            };
        });
        return node;
    };
    Element.prototype.getAttribute = function (_name) {
        var attributes = this.attributes;
        var name = _name.toLowerCase();
        var attr;
        for (var i = 0, l = attributes.length; i < l; i++) {
            attr = attributes[i];
            if (attr.name === name) {
                return attr.value;
            }
        }
        return null;
    };
    Element.prototype.setAttribute = function () {
        return this._setAttribute.apply(this, arguments);
    };
    Element.prototype._setAttribute = function (_name, value) {
        var attributes = this.attributes;
        var name = _name.toLowerCase();
        var attr;
        for (var i = 0, l = attributes.length; i < l; i++) {
            attr = attributes[i];
            if (attr.name === name) {
                attr.value = value;
                return;
            }
        }
        attributes.push({
            name: name,
            value: value,
            specified: true
        });
        attributes[name] = value;
        var special = attrSpecial[name];
        if (special) {
            special(this, value);
        }
    };
    Element.prototype.hasAttribute = function (_name) {
        var attributes = this.attributes;
        var name = _name.toLowerCase();
        var attr;
        for (var i = 0, len = attributes.length; i < len; i++) {
            attr = attributes[i];
            if (attr.name === name) {
                return true;
            }
        }
        return false;
    };
    Element.prototype.removeAttribute = function (name) {
        var attributes = this.attributes;
        for (var i = 0, l = attributes.length; i < l; i++) {
            var attr = attributes[i];
            if (attr.name === name) {
                attributes.splice(i, 1);
                delete attributes[name];
                return;
            }
        }
    };
    Element.prototype.getElementsByTagName = function (name) {
        name = name.toUpperCase();
        var elements = [];
        var cur = this.firstChild;
        while (cur) {
            if (cur.nodeType === _node2.default.ELEMENT_NODE) {
                if (cur.nodeName === name || name === '*') {
                    elements.push(cur);
                }
                elements.push.apply(elements, cur.getElementsByTagName(name));
            }
            cur = cur.nextSibling;
        }
        return elements;
    };
    Element.prototype.contains = function (child) {
        child = child.parentNode;
        while (child) {
            if (child === this) {
                return true;
            }
            child = child.parentNode;
        }
        return false;
    };
    Element.prototype.getElementById = function (id) {
        var cur = this.firstChild, child;
        while (cur) {
            if (cur.attributes && cur.attributes.length) {
                var attr;
                for (var i = 0, len = cur.attributes.length; i < len; i++) {
                    attr = cur.attributes[i];
                    if (attr.name === 'id' && attr.value === id) {
                        return cur;
                    }
                }
            }
            if (cur.getElementById) {
                child = cur.getElementById(id);
                if (child) {
                    return child;
                }
            }
            cur = cur.nextSibling;
        }
    };
    function Style(node) {
        this.__node = node;
    }
    if (Object.defineProperty) {
        Object.defineProperty(Element.prototype, 'className', {
            configurable: true,
            enumerable: true,
            get: function get() {
                return this._className || '';
            },
            set: function set(val) {
                this._setAttribute('class', val);
                this._className = val;
            }
        });
        Object.defineProperty(Element.prototype, 'innerHTML', {
            configurable: true,
            enumerable: true,
            get: function get() {
                var html = '';
                var cur = this.firstChild;
                while (cur) {
                    html += this.ownerDocument.__serializer.serialize(cur);
                    cur = cur.nextSibling;
                }
                return html;
            },
            set: function set(html) {
                this.lastChild = this.firstChild = null;
                var fragment;
                if (this.nodeName === 'SCRIPT' || this.nodeName === 'STYLE') {
                    fragment = this.ownerDocument.createTextNode(html);
                } else {
                    fragment = this.ownerDocument.__parser.parse(html);
                }
                this.appendChild(fragment);
            }
        });
        Object.defineProperty(Element.prototype, 'outerHTML', {
            get: function get() {
                return this.ownerDocument.__serializer.serialize(this);
            },
            set: function set(html) {
                this.parentNode.replaceChild(this.ownerDocument.__parser.parse(html), this);
            }
        });
    }
    exports.default = Element;
});
/*can-simple-dom@1.0.10#simple-dom/document/text*/
define('can-simple-dom@1.0.10#simple-dom/document/text', [
    'exports',
    './node'
], function (exports, _node) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    var _node2 = _interopRequireDefault(_node);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    function Text(text, ownerDocument) {
        this.nodeConstructor(3, '#text', text, ownerDocument);
    }
    Text.prototype._cloneNode = function () {
        return this.ownerDocument.createTextNode(this.nodeValue);
    };
    Text.prototype = Object.create(_node2.default.prototype);
    Text.prototype.constructor = Text;
    Text.prototype.nodeConstructor = _node2.default;
    exports.default = Text;
});
/*can-simple-dom@1.0.10#simple-dom/document/comment*/
define('can-simple-dom@1.0.10#simple-dom/document/comment', [
    'exports',
    './node'
], function (exports, _node) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    var _node2 = _interopRequireDefault(_node);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    function Comment(text, ownerDocument) {
        this.nodeConstructor(8, '#comment', text, ownerDocument);
    }
    Comment.prototype._cloneNode = function () {
        return this.ownerDocument.createComment(this.nodeValue);
    };
    Comment.prototype = Object.create(_node2.default.prototype);
    Comment.prototype.constructor = Comment;
    Comment.prototype.nodeConstructor = _node2.default;
    exports.default = Comment;
});
/*can-simple-dom@1.0.10#simple-dom/document/document-fragment*/
define('can-simple-dom@1.0.10#simple-dom/document/document-fragment', [
    'exports',
    './node'
], function (exports, _node) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    var _node2 = _interopRequireDefault(_node);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    function DocumentFragment(ownerDocument) {
        this.nodeConstructor(11, '#document-fragment', null, ownerDocument);
    }
    DocumentFragment.prototype._cloneNode = function () {
        return this.ownerDocument.createDocumentFragment();
    };
    DocumentFragment.prototype = Object.create(_node2.default.prototype);
    DocumentFragment.prototype.constructor = DocumentFragment;
    DocumentFragment.prototype.nodeConstructor = _node2.default;
    exports.default = DocumentFragment;
});
/*micro-location@0.1.5#lib/micro-location*/
function Location() {
    this.init.apply(this, arguments);
}
Location.prototype = {
    init: function (protocol, host, hostname, port, pathname, search, hash) {
        this.protocol = protocol;
        this.host = host;
        this.hostname = hostname;
        this.port = port || '';
        this.pathname = pathname || '';
        this.search = search || '';
        this.hash = hash || '';
        if (protocol) {
            with (this)
                this.href = protocol + '//' + host + pathname + search + hash;
        } else if (host) {
            with (this)
                this.href = '//' + host + pathname + search + hash;
        } else {
            with (this)
                this.href = pathname + search + hash;
        }
    },
    params: function (name) {
        if (!this._params) {
            var params = {};
            var pairs = this.search.substring(1).split(/[;&]/);
            for (var i = 0, len = pairs.length; i < len; i++) {
                if (!pairs[i])
                    continue;
                var pair = pairs[i].split(/=/);
                var key = decodeURIComponent(pair[0].replace(/\+/g, '%20'));
                var val = decodeURIComponent(pair[1].replace(/\+/g, '%20'));
                if (!params[key])
                    params[key] = [];
                params[key].push(val);
            }
            this._params = params;
        }
        switch (typeof name) {
        case 'undefined':
            return this._params;
        case 'object':
            return this.build(name);
        }
        return this._params[name] ? this._params[name][0] : null;
    },
    build: function (params) {
        if (!params)
            params = this._params;
        var ret = new Location();
        var _search = this.search;
        if (params) {
            var search = [];
            for (var key in params)
                if (params.hasOwnProperty(key)) {
                    var val = params[key];
                    switch (typeof val) {
                    case 'object':
                        for (var i = 0, len = val.length; i < len; i++) {
                            search.push(encodeURIComponent(key) + '=' + encodeURIComponent(val[i]));
                        }
                        break;
                    default:
                        search.push(encodeURIComponent(key) + '=' + encodeURIComponent(val));
                    }
                }
            _search = '?' + search.join('&');
        }
        with (this)
            ret.init.apply(ret, [
                protocol,
                host,
                hostname,
                port,
                pathname,
                _search,
                hash
            ]);
        return ret;
    }
};
Location.regexp = new RegExp('^(?:(https?:)//(([^:/]+)(:[^/]+)?))?([^#?]*)(\\?[^#]*)?(#.*)?$');
Location.parse = function (string) {
    var matched = String(string).match(this.regexp);
    var ret = new Location();
    ret.init.apply(ret, matched.slice(1));
    return ret;
};
(function (root, factory) {
    if (typeof module === 'object' && module.exports) {
        module.exports = { Location: factory() };
    } else if (typeof define === 'function' && define.amd) {
        define('micro-location@0.1.5#lib/micro-location', [], function () {
            return { Location: factory() };
        });
    } else {
        root.Location = factory();
    }
}(this, function () {
    return Location;
}));
/*can-simple-dom@1.0.10#simple-dom/extend*/
define('can-simple-dom@1.0.10#simple-dom/extend', ['exports'], function (exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.default = function (a, b) {
        for (var p in b) {
            a[p] = b[p];
        }
        return a;
    };
    ;
});
/*can-simple-dom@1.0.10#simple-dom/document/anchor-element*/
define('can-simple-dom@1.0.10#simple-dom/document/anchor-element', [
    'exports',
    './element',
    'micro-location',
    '../extend'
], function (exports, _element, _microLocation, _extend) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    var _element2 = _interopRequireDefault(_element);
    var _microLocation2 = _interopRequireDefault(_microLocation);
    var _extend2 = _interopRequireDefault(_extend);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    var Location = _microLocation2.default.Location || _microLocation2.default;
    function AnchorElement(tagName, ownerDocument) {
        this.elementConstructor(tagName, ownerDocument);
        (0, _extend2.default)(this, Location.parse(''));
    }
    AnchorElement.prototype = Object.create(_element2.default.prototype);
    AnchorElement.prototype.constructor = AnchorElement;
    AnchorElement.prototype.elementConstructor = _element2.default;
    AnchorElement.prototype.setAttribute = function (_name, value) {
        _element2.default.prototype.setAttribute.apply(this, arguments);
        if (_name.toLowerCase() === 'href') {
            (0, _extend2.default)(this, Location.parse(value));
        }
    };
    exports.default = AnchorElement;
});
/*can-simple-dom@1.0.10#simple-dom/document/utils*/
define('can-simple-dom@1.0.10#simple-dom/document/utils', ['exports'], function (exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.propToAttr = propToAttr;
    function propToAttr(Element, name) {
        Object.defineProperty(Element.prototype, name, {
            configurable: true,
            enumerable: true,
            get: function get() {
                return this.getAttribute(name);
            },
            set: function set(val) {
                this.setAttribute(name, val);
            }
        });
    }
    ;
});
/*can-simple-dom@1.0.10#simple-dom/document/input-element*/
define('can-simple-dom@1.0.10#simple-dom/document/input-element', [
    'exports',
    './element',
    './utils.js'
], function (exports, _element, _utils) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    var _element2 = _interopRequireDefault(_element);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    function InputElement(tagName, ownerDocument) {
        this.elementConstructor(tagName, ownerDocument);
    }
    InputElement.prototype = Object.create(_element2.default.prototype);
    InputElement.prototype.constructor = InputElement;
    InputElement.prototype.elementConstructor = _element2.default;
    (0, _utils.propToAttr)(InputElement, 'type');
    (0, _utils.propToAttr)(InputElement, 'value');
    Object.defineProperty(InputElement.prototype, 'checked', {
        configurable: true,
        enumerable: true,
        get: function get() {
            return this.hasAttribute('checked');
        },
        set: function set(value) {
            if (value) {
                this.setAttribute('checked', '');
            } else {
                this.removeAttribute('checked');
            }
        }
    });
    exports.default = InputElement;
});
/*can-simple-dom@1.0.10#simple-dom/document/option-element*/
define('can-simple-dom@1.0.10#simple-dom/document/option-element', [
    'exports',
    './element',
    './utils'
], function (exports, _element, _utils) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    var _element2 = _interopRequireDefault(_element);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    function OptionElement(tagName, ownerDocument) {
        this.elementConstructor(tagName, ownerDocument);
    }
    OptionElement.prototype = Object.create(_element2.default.prototype);
    OptionElement.prototype.constructor = OptionElement;
    OptionElement.prototype.elementConstructor = _element2.default;
    (0, _utils.propToAttr)(OptionElement, 'value');
    Object.defineProperty(OptionElement.prototype, 'selected', {
        enumerable: true,
        configurable: true,
        get: function get() {
            var val = this.value || '';
            var parent = this.parentNode;
            return parent && parent.value == val;
        },
        set: function set(val) {
            if (val) {
                var parent = this.parentNode;
                if (parent) {
                    parent.value = this.value;
                }
            }
        }
    });
    exports.default = OptionElement;
});
/*can-simple-dom@1.0.10#simple-dom/document/select-element*/
define('can-simple-dom@1.0.10#simple-dom/document/select-element', [
    'exports',
    './element',
    './utils'
], function (exports, _element, _utils) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    var _element2 = _interopRequireDefault(_element);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    function SelectElement(tagName, ownerDocument) {
        this.elementConstructor(tagName, ownerDocument);
        this.selectedIndex = 0;
    }
    SelectElement.prototype = Object.create(_element2.default.prototype);
    SelectElement.prototype.constructor = SelectElement;
    SelectElement.prototype.elementConstructor = _element2.default;
    (0, _utils.propToAttr)(SelectElement, 'value');
    exports.default = SelectElement;
});
/*can-simple-dom@1.0.10#simple-dom/document*/
define('can-simple-dom@1.0.10#simple-dom/document', [
    'exports',
    './document/node',
    './document/element',
    './document/text',
    './document/comment',
    './document/document-fragment',
    './document/anchor-element',
    './document/input-element',
    './document/option-element',
    './document/select-element'
], function (exports, _node, _element, _text, _comment, _documentFragment, _anchorElement, _inputElement, _optionElement, _selectElement) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    var _node2 = _interopRequireDefault(_node);
    var _element2 = _interopRequireDefault(_element);
    var _text2 = _interopRequireDefault(_text);
    var _comment2 = _interopRequireDefault(_comment);
    var _documentFragment2 = _interopRequireDefault(_documentFragment);
    var _anchorElement2 = _interopRequireDefault(_anchorElement);
    var _inputElement2 = _interopRequireDefault(_inputElement);
    var _optionElement2 = _interopRequireDefault(_optionElement);
    var _selectElement2 = _interopRequireDefault(_selectElement);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    var noop = Function.prototype;
    function Document() {
        this.nodeConstructor(9, '#document', null, this);
        var documentElement = new _element2.default('html', this);
        var body = new _element2.default('body', this);
        documentElement.appendChild(body);
        this.appendChild(documentElement);
        var self = this;
        this.implementation = {
            createHTMLDocument: function createHTMLDocument(content) {
                var document = new Document();
                var frag = self.__parser.parse(content);
                var body = _element2.default.prototype.getElementsByTagName.call(frag, 'body')[0];
                var head = _element2.default.prototype.getElementsByTagName.call(frag, 'head')[0];
                if (!body && !head) {
                    document.body.appendChild(frag);
                } else {
                    if (body) {
                        document.documentElement.replaceChild(body, document.body);
                    }
                    if (head) {
                        document.documentElement.replaceChild(head, document.head);
                    }
                    document.documentElement.appendChild(frag);
                }
                document.__addSerializerAndParser(self.__serializer, self.__parser);
                return document;
            }
        };
    }
    Document.prototype = Object.create(_node2.default.prototype);
    Document.prototype.constructor = Document;
    Document.prototype.nodeConstructor = _node2.default;
    var specialElements = {
        'a': _anchorElement2.default,
        'input': _inputElement2.default,
        'option': _optionElement2.default,
        'select': _selectElement2.default
    };
    Document.prototype.createElement = function (tagName) {
        var Special = specialElements[tagName.toLowerCase()];
        if (Special) {
            return new Special(tagName, this);
        }
        return new _element2.default(tagName, this);
    };
    Document.prototype.createTextNode = function (text) {
        return new _text2.default(text, this);
    };
    Document.prototype.createComment = function (text) {
        return new _comment2.default(text, this);
    };
    Document.prototype.createDocumentFragment = function () {
        return new _documentFragment2.default(this);
    };
    Document.prototype.getElementsByTagName = function (name) {
        name = name.toUpperCase();
        var elements = [];
        var cur = this.firstChild;
        while (cur) {
            if (cur.nodeType === _node2.default.ELEMENT_NODE) {
                if (cur.nodeName === name || name === '*') {
                    elements.push(cur);
                }
                elements.push.apply(elements, cur.getElementsByTagName(name));
            }
            cur = cur.nextSibling;
        }
        return elements;
    };
    Document.prototype.getElementById = function (id) {
        return _element2.default.prototype.getElementById.apply(this.documentElement, arguments);
    };
    Document.prototype.__addSerializerAndParser = function (serializer, parser) {
        this.__parser = parser;
        this.__serializer = serializer;
    };
    if (Object.defineProperty) {
        var firstOfKind = function firstOfKind(root, nodeName) {
            if (root == null)
                return null;
            var node = root.firstChild;
            while (node) {
                if (node.nodeName === nodeName) {
                    return node;
                }
                node = node.nextSibling;
            }
            return null;
        };
        Object.defineProperty(Document.prototype, 'currentScript', {
            get: function get() {
                var scripts = this.getElementsByTagName('script');
                var first = scripts[scripts.length - 1];
                if (!first) {
                    first = this.createElement('script');
                }
                return first;
            }
        });
        Object.defineProperty(Document.prototype, 'documentElement', {
            get: function get() {
                return this.firstChild;
            },
            set: noop
        });
        [
            'head',
            'body'
        ].forEach(function (localName) {
            var nodeName = localName.toUpperCase();
            Object.defineProperty(Document.prototype, localName, {
                get: function get() {
                    return firstOfKind(this.documentElement, nodeName);
                },
                set: noop
            });
        });
    }
    exports.default = Document;
});
/*can-simple-dom@1.0.10#simple-dom/event*/
define('can-simple-dom@1.0.10#simple-dom/event', [
    'exports',
    './document/node',
    './document'
], function (exports, _node, _document) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    var _node2 = _interopRequireDefault(_node);
    var _document2 = _interopRequireDefault(_document);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    var Event = function Event() {
    };
    Event.prototype.initEvent = function (type, bubbles, cancelable) {
        this.type = type;
        this.bubbles = !!bubbles;
        this.cancelable = !!cancelable;
    };
    Event.prototype.stopPropagation = function () {
        this.isPropagationStopped = true;
    };
    Event.prototype.preventDefault = function () {
        this.isDefaultPrevented = true;
    };
    _document2.default.prototype.createEvent = function (type) {
        return new Event();
    };
    _node2.default.prototype.addEventListener = function (event, handler, capture) {
        if (!this.__handlers) {
            Object.defineProperty(this, '__handlers', {
                value: {},
                enumerable: false
            });
        }
        var phase = capture ? 'capture' : 'bubble';
        var handlersByType = this.__handlers[event + ' ' + phase];
        if (!handlersByType) {
            handlersByType = this.__handlers[event + ' ' + phase] = [];
        }
        handlersByType.push(handler);
    };
    _node2.default.prototype.removeEventListener = function (event, handler, capture) {
        if (this.__handlers) {
            var phase = capture ? 'capture' : 'bubble';
            var handlersByType = this.__handlers[event + ' ' + phase];
            if (handlersByType) {
                var index = 0;
                while (index < handlersByType.length) {
                    if (handlersByType[index] === handler) {
                        handlersByType.splice(index, 1);
                    } else {
                        index++;
                    }
                }
            }
        }
    };
    _node2.default.prototype.dispatchEvent = function (event) {
        event.target = this;
        var cur = this;
        var dispatchHandlers = [];
        do {
            var handlers = cur.__handlers && cur.__handlers[event.type + ' bubble'];
            if (handlers) {
                dispatchHandlers.push({
                    node: cur,
                    handlers: handlers
                });
            }
            cur = cur.parentNode;
        } while (event.bubbles && cur);
        for (var i = 0; i < dispatchHandlers.length; i++) {
            var dispatches = dispatchHandlers[i];
            event.currentTarget = dispatches.node;
            for (var h = 0; h < dispatches.handlers.length; h++) {
                var handler = dispatches.handlers[h];
                var res = handler.call(this, event);
                if (res) {
                    event.stopPropagation();
                    event.preventDefault();
                }
                if (event.isImmediatePropagationStopped) {
                    return !event.isDefaultPrevented;
                }
            }
            if (event.isPropagationStopped) {
                return !event.isDefaultPrevented;
            }
        }
        return !event.isDefaultPrevented;
    };
    exports.default = Event;
});
/*he@1.1.1#he*/
;
(function (root) {
    var freeExports = typeof exports == 'object' && exports;
    var freeModule = typeof module == 'object' && module && module.exports == freeExports && module;
    var freeGlobal = typeof global == 'object' && global;
    if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
        root = freeGlobal;
    }
    var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    var regexAsciiWhitelist = /[\x01-\x7F]/g;
    var regexBmpWhitelist = /[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g;
    var regexEncodeNonAscii = /<\u20D2|=\u20E5|>\u20D2|\u205F\u200A|\u219D\u0338|\u2202\u0338|\u2220\u20D2|\u2229\uFE00|\u222A\uFE00|\u223C\u20D2|\u223D\u0331|\u223E\u0333|\u2242\u0338|\u224B\u0338|\u224D\u20D2|\u224E\u0338|\u224F\u0338|\u2250\u0338|\u2261\u20E5|\u2264\u20D2|\u2265\u20D2|\u2266\u0338|\u2267\u0338|\u2268\uFE00|\u2269\uFE00|\u226A\u0338|\u226A\u20D2|\u226B\u0338|\u226B\u20D2|\u227F\u0338|\u2282\u20D2|\u2283\u20D2|\u228A\uFE00|\u228B\uFE00|\u228F\u0338|\u2290\u0338|\u2293\uFE00|\u2294\uFE00|\u22B4\u20D2|\u22B5\u20D2|\u22D8\u0338|\u22D9\u0338|\u22DA\uFE00|\u22DB\uFE00|\u22F5\u0338|\u22F9\u0338|\u2933\u0338|\u29CF\u0338|\u29D0\u0338|\u2A6D\u0338|\u2A70\u0338|\u2A7D\u0338|\u2A7E\u0338|\u2AA1\u0338|\u2AA2\u0338|\u2AAC\uFE00|\u2AAD\uFE00|\u2AAF\u0338|\u2AB0\u0338|\u2AC5\u0338|\u2AC6\u0338|\u2ACB\uFE00|\u2ACC\uFE00|\u2AFD\u20E5|[\xA0-\u0113\u0116-\u0122\u0124-\u012B\u012E-\u014D\u0150-\u017E\u0192\u01B5\u01F5\u0237\u02C6\u02C7\u02D8-\u02DD\u0311\u0391-\u03A1\u03A3-\u03A9\u03B1-\u03C9\u03D1\u03D2\u03D5\u03D6\u03DC\u03DD\u03F0\u03F1\u03F5\u03F6\u0401-\u040C\u040E-\u044F\u0451-\u045C\u045E\u045F\u2002-\u2005\u2007-\u2010\u2013-\u2016\u2018-\u201A\u201C-\u201E\u2020-\u2022\u2025\u2026\u2030-\u2035\u2039\u203A\u203E\u2041\u2043\u2044\u204F\u2057\u205F-\u2063\u20AC\u20DB\u20DC\u2102\u2105\u210A-\u2113\u2115-\u211E\u2122\u2124\u2127-\u2129\u212C\u212D\u212F-\u2131\u2133-\u2138\u2145-\u2148\u2153-\u215E\u2190-\u219B\u219D-\u21A7\u21A9-\u21AE\u21B0-\u21B3\u21B5-\u21B7\u21BA-\u21DB\u21DD\u21E4\u21E5\u21F5\u21FD-\u2205\u2207-\u2209\u220B\u220C\u220F-\u2214\u2216-\u2218\u221A\u221D-\u2238\u223A-\u2257\u2259\u225A\u225C\u225F-\u2262\u2264-\u228B\u228D-\u229B\u229D-\u22A5\u22A7-\u22B0\u22B2-\u22BB\u22BD-\u22DB\u22DE-\u22E3\u22E6-\u22F7\u22F9-\u22FE\u2305\u2306\u2308-\u2310\u2312\u2313\u2315\u2316\u231C-\u231F\u2322\u2323\u232D\u232E\u2336\u233D\u233F\u237C\u23B0\u23B1\u23B4-\u23B6\u23DC-\u23DF\u23E2\u23E7\u2423\u24C8\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2550-\u256C\u2580\u2584\u2588\u2591-\u2593\u25A1\u25AA\u25AB\u25AD\u25AE\u25B1\u25B3-\u25B5\u25B8\u25B9\u25BD-\u25BF\u25C2\u25C3\u25CA\u25CB\u25EC\u25EF\u25F8-\u25FC\u2605\u2606\u260E\u2640\u2642\u2660\u2663\u2665\u2666\u266A\u266D-\u266F\u2713\u2717\u2720\u2736\u2758\u2772\u2773\u27C8\u27C9\u27E6-\u27ED\u27F5-\u27FA\u27FC\u27FF\u2902-\u2905\u290C-\u2913\u2916\u2919-\u2920\u2923-\u292A\u2933\u2935-\u2939\u293C\u293D\u2945\u2948-\u294B\u294E-\u2976\u2978\u2979\u297B-\u297F\u2985\u2986\u298B-\u2996\u299A\u299C\u299D\u29A4-\u29B7\u29B9\u29BB\u29BC\u29BE-\u29C5\u29C9\u29CD-\u29D0\u29DC-\u29DE\u29E3-\u29E5\u29EB\u29F4\u29F6\u2A00-\u2A02\u2A04\u2A06\u2A0C\u2A0D\u2A10-\u2A17\u2A22-\u2A27\u2A29\u2A2A\u2A2D-\u2A31\u2A33-\u2A3C\u2A3F\u2A40\u2A42-\u2A4D\u2A50\u2A53-\u2A58\u2A5A-\u2A5D\u2A5F\u2A66\u2A6A\u2A6D-\u2A75\u2A77-\u2A9A\u2A9D-\u2AA2\u2AA4-\u2AB0\u2AB3-\u2AC8\u2ACB\u2ACC\u2ACF-\u2ADB\u2AE4\u2AE6-\u2AE9\u2AEB-\u2AF3\u2AFD\uFB00-\uFB04]|\uD835[\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDD6B]/g;
    var encodeMap = {
        '\xAD': 'shy',
        '‌': 'zwnj',
        '‍': 'zwj',
        '\u200E': 'lrm',
        '\u2063': 'ic',
        '\u2062': 'it',
        '\u2061': 'af',
        '\u200F': 'rlm',
        '\u200B': 'ZeroWidthSpace',
        '\u2060': 'NoBreak',
        '̑': 'DownBreve',
        '⃛': 'tdot',
        '⃜': 'DotDot',
        '\t': 'Tab',
        '\n': 'NewLine',
        '\u2008': 'puncsp',
        '\u205F': 'MediumSpace',
        '\u2009': 'thinsp',
        '\u200A': 'hairsp',
        '\u2004': 'emsp13',
        '\u2002': 'ensp',
        '\u2005': 'emsp14',
        '\u2003': 'emsp',
        '\u2007': 'numsp',
        '\xA0': 'nbsp',
        '\u205F\u200A': 'ThickSpace',
        '\u203E': 'oline',
        '_': 'lowbar',
        '\u2010': 'dash',
        '\u2013': 'ndash',
        '\u2014': 'mdash',
        '\u2015': 'horbar',
        ',': 'comma',
        ';': 'semi',
        '\u204F': 'bsemi',
        ':': 'colon',
        '\u2A74': 'Colone',
        '!': 'excl',
        '\xA1': 'iexcl',
        '?': 'quest',
        '\xBF': 'iquest',
        '.': 'period',
        '\u2025': 'nldr',
        '\u2026': 'mldr',
        '\xB7': 'middot',
        '\'': 'apos',
        '\u2018': 'lsquo',
        '\u2019': 'rsquo',
        '\u201A': 'sbquo',
        '\u2039': 'lsaquo',
        '\u203A': 'rsaquo',
        '"': 'quot',
        '\u201C': 'ldquo',
        '\u201D': 'rdquo',
        '\u201E': 'bdquo',
        '\xAB': 'laquo',
        '\xBB': 'raquo',
        '(': 'lpar',
        ')': 'rpar',
        '[': 'lsqb',
        ']': 'rsqb',
        '{': 'lcub',
        '}': 'rcub',
        '\u2308': 'lceil',
        '\u2309': 'rceil',
        '\u230A': 'lfloor',
        '\u230B': 'rfloor',
        '\u2985': 'lopar',
        '\u2986': 'ropar',
        '\u298B': 'lbrke',
        '\u298C': 'rbrke',
        '\u298D': 'lbrkslu',
        '\u298E': 'rbrksld',
        '\u298F': 'lbrksld',
        '\u2990': 'rbrkslu',
        '\u2991': 'langd',
        '\u2992': 'rangd',
        '\u2993': 'lparlt',
        '\u2994': 'rpargt',
        '\u2995': 'gtlPar',
        '\u2996': 'ltrPar',
        '\u27E6': 'lobrk',
        '\u27E7': 'robrk',
        '\u27E8': 'lang',
        '\u27E9': 'rang',
        '\u27EA': 'Lang',
        '\u27EB': 'Rang',
        '\u27EC': 'loang',
        '\u27ED': 'roang',
        '\u2772': 'lbbrk',
        '\u2773': 'rbbrk',
        '\u2016': 'Vert',
        '\xA7': 'sect',
        '\xB6': 'para',
        '@': 'commat',
        '*': 'ast',
        '/': 'sol',
        'undefined': null,
        '&': 'amp',
        '#': 'num',
        '%': 'percnt',
        '\u2030': 'permil',
        '\u2031': 'pertenk',
        '\u2020': 'dagger',
        '\u2021': 'Dagger',
        '\u2022': 'bull',
        '\u2043': 'hybull',
        '\u2032': 'prime',
        '\u2033': 'Prime',
        '\u2034': 'tprime',
        '\u2057': 'qprime',
        '\u2035': 'bprime',
        '\u2041': 'caret',
        '`': 'grave',
        '\xB4': 'acute',
        '\u02DC': 'tilde',
        '^': 'Hat',
        '\xAF': 'macr',
        '\u02D8': 'breve',
        '\u02D9': 'dot',
        '\xA8': 'die',
        '\u02DA': 'ring',
        '\u02DD': 'dblac',
        '\xB8': 'cedil',
        '\u02DB': 'ogon',
        'ˆ': 'circ',
        'ˇ': 'caron',
        '\xB0': 'deg',
        '\xA9': 'copy',
        '\xAE': 'reg',
        '\u2117': 'copysr',
        '\u2118': 'wp',
        '\u211E': 'rx',
        '\u2127': 'mho',
        '\u2129': 'iiota',
        '\u2190': 'larr',
        '\u219A': 'nlarr',
        '\u2192': 'rarr',
        '\u219B': 'nrarr',
        '\u2191': 'uarr',
        '\u2193': 'darr',
        '\u2194': 'harr',
        '\u21AE': 'nharr',
        '\u2195': 'varr',
        '\u2196': 'nwarr',
        '\u2197': 'nearr',
        '\u2198': 'searr',
        '\u2199': 'swarr',
        '\u219D': 'rarrw',
        '\u219D̸': 'nrarrw',
        '\u219E': 'Larr',
        '\u219F': 'Uarr',
        '\u21A0': 'Rarr',
        '\u21A1': 'Darr',
        '\u21A2': 'larrtl',
        '\u21A3': 'rarrtl',
        '\u21A4': 'mapstoleft',
        '\u21A5': 'mapstoup',
        '\u21A6': 'map',
        '\u21A7': 'mapstodown',
        '\u21A9': 'larrhk',
        '\u21AA': 'rarrhk',
        '\u21AB': 'larrlp',
        '\u21AC': 'rarrlp',
        '\u21AD': 'harrw',
        '\u21B0': 'lsh',
        '\u21B1': 'rsh',
        '\u21B2': 'ldsh',
        '\u21B3': 'rdsh',
        '\u21B5': 'crarr',
        '\u21B6': 'cularr',
        '\u21B7': 'curarr',
        '\u21BA': 'olarr',
        '\u21BB': 'orarr',
        '\u21BC': 'lharu',
        '\u21BD': 'lhard',
        '\u21BE': 'uharr',
        '\u21BF': 'uharl',
        '\u21C0': 'rharu',
        '\u21C1': 'rhard',
        '\u21C2': 'dharr',
        '\u21C3': 'dharl',
        '\u21C4': 'rlarr',
        '\u21C5': 'udarr',
        '\u21C6': 'lrarr',
        '\u21C7': 'llarr',
        '\u21C8': 'uuarr',
        '\u21C9': 'rrarr',
        '\u21CA': 'ddarr',
        '\u21CB': 'lrhar',
        '\u21CC': 'rlhar',
        '\u21D0': 'lArr',
        '\u21CD': 'nlArr',
        '\u21D1': 'uArr',
        '\u21D2': 'rArr',
        '\u21CF': 'nrArr',
        '\u21D3': 'dArr',
        '\u21D4': 'iff',
        '\u21CE': 'nhArr',
        '\u21D5': 'vArr',
        '\u21D6': 'nwArr',
        '\u21D7': 'neArr',
        '\u21D8': 'seArr',
        '\u21D9': 'swArr',
        '\u21DA': 'lAarr',
        '\u21DB': 'rAarr',
        '\u21DD': 'zigrarr',
        '\u21E4': 'larrb',
        '\u21E5': 'rarrb',
        '\u21F5': 'duarr',
        '\u21FD': 'loarr',
        '\u21FE': 'roarr',
        '\u21FF': 'hoarr',
        '\u2200': 'forall',
        '\u2201': 'comp',
        '\u2202': 'part',
        '\u2202̸': 'npart',
        '\u2203': 'exist',
        '\u2204': 'nexist',
        '\u2205': 'empty',
        '\u2207': 'Del',
        '\u2208': 'in',
        '\u2209': 'notin',
        '\u220B': 'ni',
        '\u220C': 'notni',
        '\u03F6': 'bepsi',
        '\u220F': 'prod',
        '\u2210': 'coprod',
        '\u2211': 'sum',
        '+': 'plus',
        '\xB1': 'pm',
        '\xF7': 'div',
        '\xD7': 'times',
        '<': 'lt',
        '\u226E': 'nlt',
        '<⃒': 'nvlt',
        '=': 'equals',
        '\u2260': 'ne',
        '=⃥': 'bne',
        '\u2A75': 'Equal',
        '>': 'gt',
        '\u226F': 'ngt',
        '>⃒': 'nvgt',
        '\xAC': 'not',
        '|': 'vert',
        '\xA6': 'brvbar',
        '\u2212': 'minus',
        '\u2213': 'mp',
        '\u2214': 'plusdo',
        '\u2044': 'frasl',
        '\u2216': 'setmn',
        '\u2217': 'lowast',
        '\u2218': 'compfn',
        '\u221A': 'Sqrt',
        '\u221D': 'prop',
        '\u221E': 'infin',
        '\u221F': 'angrt',
        '\u2220': 'ang',
        '\u2220⃒': 'nang',
        '\u2221': 'angmsd',
        '\u2222': 'angsph',
        '\u2223': 'mid',
        '\u2224': 'nmid',
        '\u2225': 'par',
        '\u2226': 'npar',
        '\u2227': 'and',
        '\u2228': 'or',
        '\u2229': 'cap',
        '\u2229︀': 'caps',
        '\u222A': 'cup',
        '\u222A︀': 'cups',
        '\u222B': 'int',
        '\u222C': 'Int',
        '\u222D': 'tint',
        '\u2A0C': 'qint',
        '\u222E': 'oint',
        '\u222F': 'Conint',
        '\u2230': 'Cconint',
        '\u2231': 'cwint',
        '\u2232': 'cwconint',
        '\u2233': 'awconint',
        '\u2234': 'there4',
        '\u2235': 'becaus',
        '\u2236': 'ratio',
        '\u2237': 'Colon',
        '\u2238': 'minusd',
        '\u223A': 'mDDot',
        '\u223B': 'homtht',
        '\u223C': 'sim',
        '\u2241': 'nsim',
        '\u223C⃒': 'nvsim',
        '\u223D': 'bsim',
        '\u223Ḏ': 'race',
        '\u223E': 'ac',
        '\u223E̳': 'acE',
        '\u223F': 'acd',
        '\u2240': 'wr',
        '\u2242': 'esim',
        '\u2242̸': 'nesim',
        '\u2243': 'sime',
        '\u2244': 'nsime',
        '\u2245': 'cong',
        '\u2247': 'ncong',
        '\u2246': 'simne',
        '\u2248': 'ap',
        '\u2249': 'nap',
        '\u224A': 'ape',
        '\u224B': 'apid',
        '\u224B̸': 'napid',
        '\u224C': 'bcong',
        '\u224D': 'CupCap',
        '\u226D': 'NotCupCap',
        '\u224D⃒': 'nvap',
        '\u224E': 'bump',
        '\u224E̸': 'nbump',
        '\u224F': 'bumpe',
        '\u224F̸': 'nbumpe',
        '\u2250': 'doteq',
        '\u2250̸': 'nedot',
        '\u2251': 'eDot',
        '\u2252': 'efDot',
        '\u2253': 'erDot',
        '\u2254': 'colone',
        '\u2255': 'ecolon',
        '\u2256': 'ecir',
        '\u2257': 'cire',
        '\u2259': 'wedgeq',
        '\u225A': 'veeeq',
        '\u225C': 'trie',
        '\u225F': 'equest',
        '\u2261': 'equiv',
        '\u2262': 'nequiv',
        '\u2261⃥': 'bnequiv',
        '\u2264': 'le',
        '\u2270': 'nle',
        '\u2264⃒': 'nvle',
        '\u2265': 'ge',
        '\u2271': 'nge',
        '\u2265⃒': 'nvge',
        '\u2266': 'lE',
        '\u2266̸': 'nlE',
        '\u2267': 'gE',
        '\u2267̸': 'ngE',
        '\u2268︀': 'lvnE',
        '\u2268': 'lnE',
        '\u2269': 'gnE',
        '\u2269︀': 'gvnE',
        '\u226A': 'll',
        '\u226A̸': 'nLtv',
        '\u226A⃒': 'nLt',
        '\u226B': 'gg',
        '\u226B̸': 'nGtv',
        '\u226B⃒': 'nGt',
        '\u226C': 'twixt',
        '\u2272': 'lsim',
        '\u2274': 'nlsim',
        '\u2273': 'gsim',
        '\u2275': 'ngsim',
        '\u2276': 'lg',
        '\u2278': 'ntlg',
        '\u2277': 'gl',
        '\u2279': 'ntgl',
        '\u227A': 'pr',
        '\u2280': 'npr',
        '\u227B': 'sc',
        '\u2281': 'nsc',
        '\u227C': 'prcue',
        '\u22E0': 'nprcue',
        '\u227D': 'sccue',
        '\u22E1': 'nsccue',
        '\u227E': 'prsim',
        '\u227F': 'scsim',
        '\u227F̸': 'NotSucceedsTilde',
        '\u2282': 'sub',
        '\u2284': 'nsub',
        '\u2282⃒': 'vnsub',
        '\u2283': 'sup',
        '\u2285': 'nsup',
        '\u2283⃒': 'vnsup',
        '\u2286': 'sube',
        '\u2288': 'nsube',
        '\u2287': 'supe',
        '\u2289': 'nsupe',
        '\u228A︀': 'vsubne',
        '\u228A': 'subne',
        '\u228B︀': 'vsupne',
        '\u228B': 'supne',
        '\u228D': 'cupdot',
        '\u228E': 'uplus',
        '\u228F': 'sqsub',
        '\u228F̸': 'NotSquareSubset',
        '\u2290': 'sqsup',
        '\u2290̸': 'NotSquareSuperset',
        '\u2291': 'sqsube',
        '\u22E2': 'nsqsube',
        '\u2292': 'sqsupe',
        '\u22E3': 'nsqsupe',
        '\u2293': 'sqcap',
        '\u2293︀': 'sqcaps',
        '\u2294': 'sqcup',
        '\u2294︀': 'sqcups',
        '\u2295': 'oplus',
        '\u2296': 'ominus',
        '\u2297': 'otimes',
        '\u2298': 'osol',
        '\u2299': 'odot',
        '\u229A': 'ocir',
        '\u229B': 'oast',
        '\u229D': 'odash',
        '\u229E': 'plusb',
        '\u229F': 'minusb',
        '\u22A0': 'timesb',
        '\u22A1': 'sdotb',
        '\u22A2': 'vdash',
        '\u22AC': 'nvdash',
        '\u22A3': 'dashv',
        '\u22A4': 'top',
        '\u22A5': 'bot',
        '\u22A7': 'models',
        '\u22A8': 'vDash',
        '\u22AD': 'nvDash',
        '\u22A9': 'Vdash',
        '\u22AE': 'nVdash',
        '\u22AA': 'Vvdash',
        '\u22AB': 'VDash',
        '\u22AF': 'nVDash',
        '\u22B0': 'prurel',
        '\u22B2': 'vltri',
        '\u22EA': 'nltri',
        '\u22B3': 'vrtri',
        '\u22EB': 'nrtri',
        '\u22B4': 'ltrie',
        '\u22EC': 'nltrie',
        '\u22B4⃒': 'nvltrie',
        '\u22B5': 'rtrie',
        '\u22ED': 'nrtrie',
        '\u22B5⃒': 'nvrtrie',
        '\u22B6': 'origof',
        '\u22B7': 'imof',
        '\u22B8': 'mumap',
        '\u22B9': 'hercon',
        '\u22BA': 'intcal',
        '\u22BB': 'veebar',
        '\u22BD': 'barvee',
        '\u22BE': 'angrtvb',
        '\u22BF': 'lrtri',
        '\u22C0': 'Wedge',
        '\u22C1': 'Vee',
        '\u22C2': 'xcap',
        '\u22C3': 'xcup',
        '\u22C4': 'diam',
        '\u22C5': 'sdot',
        '\u22C6': 'Star',
        '\u22C7': 'divonx',
        '\u22C8': 'bowtie',
        '\u22C9': 'ltimes',
        '\u22CA': 'rtimes',
        '\u22CB': 'lthree',
        '\u22CC': 'rthree',
        '\u22CD': 'bsime',
        '\u22CE': 'cuvee',
        '\u22CF': 'cuwed',
        '\u22D0': 'Sub',
        '\u22D1': 'Sup',
        '\u22D2': 'Cap',
        '\u22D3': 'Cup',
        '\u22D4': 'fork',
        '\u22D5': 'epar',
        '\u22D6': 'ltdot',
        '\u22D7': 'gtdot',
        '\u22D8': 'Ll',
        '\u22D8̸': 'nLl',
        '\u22D9': 'Gg',
        '\u22D9̸': 'nGg',
        '\u22DA︀': 'lesg',
        '\u22DA': 'leg',
        '\u22DB': 'gel',
        '\u22DB︀': 'gesl',
        '\u22DE': 'cuepr',
        '\u22DF': 'cuesc',
        '\u22E6': 'lnsim',
        '\u22E7': 'gnsim',
        '\u22E8': 'prnsim',
        '\u22E9': 'scnsim',
        '\u22EE': 'vellip',
        '\u22EF': 'ctdot',
        '\u22F0': 'utdot',
        '\u22F1': 'dtdot',
        '\u22F2': 'disin',
        '\u22F3': 'isinsv',
        '\u22F4': 'isins',
        '\u22F5': 'isindot',
        '\u22F5̸': 'notindot',
        '\u22F6': 'notinvc',
        '\u22F7': 'notinvb',
        '\u22F9': 'isinE',
        '\u22F9̸': 'notinE',
        '\u22FA': 'nisd',
        '\u22FB': 'xnis',
        '\u22FC': 'nis',
        '\u22FD': 'notnivc',
        '\u22FE': 'notnivb',
        '\u2305': 'barwed',
        '\u2306': 'Barwed',
        '\u230C': 'drcrop',
        '\u230D': 'dlcrop',
        '\u230E': 'urcrop',
        '\u230F': 'ulcrop',
        '\u2310': 'bnot',
        '\u2312': 'profline',
        '\u2313': 'profsurf',
        '\u2315': 'telrec',
        '\u2316': 'target',
        '\u231C': 'ulcorn',
        '\u231D': 'urcorn',
        '\u231E': 'dlcorn',
        '\u231F': 'drcorn',
        '\u2322': 'frown',
        '\u2323': 'smile',
        '\u232D': 'cylcty',
        '\u232E': 'profalar',
        '\u2336': 'topbot',
        '\u233D': 'ovbar',
        '\u233F': 'solbar',
        '\u237C': 'angzarr',
        '\u23B0': 'lmoust',
        '\u23B1': 'rmoust',
        '\u23B4': 'tbrk',
        '\u23B5': 'bbrk',
        '\u23B6': 'bbrktbrk',
        '\u23DC': 'OverParenthesis',
        '\u23DD': 'UnderParenthesis',
        '\u23DE': 'OverBrace',
        '\u23DF': 'UnderBrace',
        '\u23E2': 'trpezium',
        '\u23E7': 'elinters',
        '\u2423': 'blank',
        '\u2500': 'boxh',
        '\u2502': 'boxv',
        '\u250C': 'boxdr',
        '\u2510': 'boxdl',
        '\u2514': 'boxur',
        '\u2518': 'boxul',
        '\u251C': 'boxvr',
        '\u2524': 'boxvl',
        '\u252C': 'boxhd',
        '\u2534': 'boxhu',
        '\u253C': 'boxvh',
        '\u2550': 'boxH',
        '\u2551': 'boxV',
        '\u2552': 'boxdR',
        '\u2553': 'boxDr',
        '\u2554': 'boxDR',
        '\u2555': 'boxdL',
        '\u2556': 'boxDl',
        '\u2557': 'boxDL',
        '\u2558': 'boxuR',
        '\u2559': 'boxUr',
        '\u255A': 'boxUR',
        '\u255B': 'boxuL',
        '\u255C': 'boxUl',
        '\u255D': 'boxUL',
        '\u255E': 'boxvR',
        '\u255F': 'boxVr',
        '\u2560': 'boxVR',
        '\u2561': 'boxvL',
        '\u2562': 'boxVl',
        '\u2563': 'boxVL',
        '\u2564': 'boxHd',
        '\u2565': 'boxhD',
        '\u2566': 'boxHD',
        '\u2567': 'boxHu',
        '\u2568': 'boxhU',
        '\u2569': 'boxHU',
        '\u256A': 'boxvH',
        '\u256B': 'boxVh',
        '\u256C': 'boxVH',
        '\u2580': 'uhblk',
        '\u2584': 'lhblk',
        '\u2588': 'block',
        '\u2591': 'blk14',
        '\u2592': 'blk12',
        '\u2593': 'blk34',
        '\u25A1': 'squ',
        '\u25AA': 'squf',
        '\u25AB': 'EmptyVerySmallSquare',
        '\u25AD': 'rect',
        '\u25AE': 'marker',
        '\u25B1': 'fltns',
        '\u25B3': 'xutri',
        '\u25B4': 'utrif',
        '\u25B5': 'utri',
        '\u25B8': 'rtrif',
        '\u25B9': 'rtri',
        '\u25BD': 'xdtri',
        '\u25BE': 'dtrif',
        '\u25BF': 'dtri',
        '\u25C2': 'ltrif',
        '\u25C3': 'ltri',
        '\u25CA': 'loz',
        '\u25CB': 'cir',
        '\u25EC': 'tridot',
        '\u25EF': 'xcirc',
        '\u25F8': 'ultri',
        '\u25F9': 'urtri',
        '\u25FA': 'lltri',
        '\u25FB': 'EmptySmallSquare',
        '\u25FC': 'FilledSmallSquare',
        '\u2605': 'starf',
        '\u2606': 'star',
        '\u260E': 'phone',
        '\u2640': 'female',
        '\u2642': 'male',
        '\u2660': 'spades',
        '\u2663': 'clubs',
        '\u2665': 'hearts',
        '\u2666': 'diams',
        '\u266A': 'sung',
        '\u2713': 'check',
        '\u2717': 'cross',
        '\u2720': 'malt',
        '\u2736': 'sext',
        '\u2758': 'VerticalSeparator',
        '\u27C8': 'bsolhsub',
        '\u27C9': 'suphsol',
        '\u27F5': 'xlarr',
        '\u27F6': 'xrarr',
        '\u27F7': 'xharr',
        '\u27F8': 'xlArr',
        '\u27F9': 'xrArr',
        '\u27FA': 'xhArr',
        '\u27FC': 'xmap',
        '\u27FF': 'dzigrarr',
        '\u2902': 'nvlArr',
        '\u2903': 'nvrArr',
        '\u2904': 'nvHarr',
        '\u2905': 'Map',
        '\u290C': 'lbarr',
        '\u290D': 'rbarr',
        '\u290E': 'lBarr',
        '\u290F': 'rBarr',
        '\u2910': 'RBarr',
        '\u2911': 'DDotrahd',
        '\u2912': 'UpArrowBar',
        '\u2913': 'DownArrowBar',
        '\u2916': 'Rarrtl',
        '\u2919': 'latail',
        '\u291A': 'ratail',
        '\u291B': 'lAtail',
        '\u291C': 'rAtail',
        '\u291D': 'larrfs',
        '\u291E': 'rarrfs',
        '\u291F': 'larrbfs',
        '\u2920': 'rarrbfs',
        '\u2923': 'nwarhk',
        '\u2924': 'nearhk',
        '\u2925': 'searhk',
        '\u2926': 'swarhk',
        '\u2927': 'nwnear',
        '\u2928': 'toea',
        '\u2929': 'tosa',
        '\u292A': 'swnwar',
        '\u2933': 'rarrc',
        '\u2933̸': 'nrarrc',
        '\u2935': 'cudarrr',
        '\u2936': 'ldca',
        '\u2937': 'rdca',
        '\u2938': 'cudarrl',
        '\u2939': 'larrpl',
        '\u293C': 'curarrm',
        '\u293D': 'cularrp',
        '\u2945': 'rarrpl',
        '\u2948': 'harrcir',
        '\u2949': 'Uarrocir',
        '\u294A': 'lurdshar',
        '\u294B': 'ldrushar',
        '\u294E': 'LeftRightVector',
        '\u294F': 'RightUpDownVector',
        '\u2950': 'DownLeftRightVector',
        '\u2951': 'LeftUpDownVector',
        '\u2952': 'LeftVectorBar',
        '\u2953': 'RightVectorBar',
        '\u2954': 'RightUpVectorBar',
        '\u2955': 'RightDownVectorBar',
        '\u2956': 'DownLeftVectorBar',
        '\u2957': 'DownRightVectorBar',
        '\u2958': 'LeftUpVectorBar',
        '\u2959': 'LeftDownVectorBar',
        '\u295A': 'LeftTeeVector',
        '\u295B': 'RightTeeVector',
        '\u295C': 'RightUpTeeVector',
        '\u295D': 'RightDownTeeVector',
        '\u295E': 'DownLeftTeeVector',
        '\u295F': 'DownRightTeeVector',
        '\u2960': 'LeftUpTeeVector',
        '\u2961': 'LeftDownTeeVector',
        '\u2962': 'lHar',
        '\u2963': 'uHar',
        '\u2964': 'rHar',
        '\u2965': 'dHar',
        '\u2966': 'luruhar',
        '\u2967': 'ldrdhar',
        '\u2968': 'ruluhar',
        '\u2969': 'rdldhar',
        '\u296A': 'lharul',
        '\u296B': 'llhard',
        '\u296C': 'rharul',
        '\u296D': 'lrhard',
        '\u296E': 'udhar',
        '\u296F': 'duhar',
        '\u2970': 'RoundImplies',
        '\u2971': 'erarr',
        '\u2972': 'simrarr',
        '\u2973': 'larrsim',
        '\u2974': 'rarrsim',
        '\u2975': 'rarrap',
        '\u2976': 'ltlarr',
        '\u2978': 'gtrarr',
        '\u2979': 'subrarr',
        '\u297B': 'suplarr',
        '\u297C': 'lfisht',
        '\u297D': 'rfisht',
        '\u297E': 'ufisht',
        '\u297F': 'dfisht',
        '\u299A': 'vzigzag',
        '\u299C': 'vangrt',
        '\u299D': 'angrtvbd',
        '\u29A4': 'ange',
        '\u29A5': 'range',
        '\u29A6': 'dwangle',
        '\u29A7': 'uwangle',
        '\u29A8': 'angmsdaa',
        '\u29A9': 'angmsdab',
        '\u29AA': 'angmsdac',
        '\u29AB': 'angmsdad',
        '\u29AC': 'angmsdae',
        '\u29AD': 'angmsdaf',
        '\u29AE': 'angmsdag',
        '\u29AF': 'angmsdah',
        '\u29B0': 'bemptyv',
        '\u29B1': 'demptyv',
        '\u29B2': 'cemptyv',
        '\u29B3': 'raemptyv',
        '\u29B4': 'laemptyv',
        '\u29B5': 'ohbar',
        '\u29B6': 'omid',
        '\u29B7': 'opar',
        '\u29B9': 'operp',
        '\u29BB': 'olcross',
        '\u29BC': 'odsold',
        '\u29BE': 'olcir',
        '\u29BF': 'ofcir',
        '\u29C0': 'olt',
        '\u29C1': 'ogt',
        '\u29C2': 'cirscir',
        '\u29C3': 'cirE',
        '\u29C4': 'solb',
        '\u29C5': 'bsolb',
        '\u29C9': 'boxbox',
        '\u29CD': 'trisb',
        '\u29CE': 'rtriltri',
        '\u29CF': 'LeftTriangleBar',
        '\u29CF̸': 'NotLeftTriangleBar',
        '\u29D0': 'RightTriangleBar',
        '\u29D0̸': 'NotRightTriangleBar',
        '\u29DC': 'iinfin',
        '\u29DD': 'infintie',
        '\u29DE': 'nvinfin',
        '\u29E3': 'eparsl',
        '\u29E4': 'smeparsl',
        '\u29E5': 'eqvparsl',
        '\u29EB': 'lozf',
        '\u29F4': 'RuleDelayed',
        '\u29F6': 'dsol',
        '\u2A00': 'xodot',
        '\u2A01': 'xoplus',
        '\u2A02': 'xotime',
        '\u2A04': 'xuplus',
        '\u2A06': 'xsqcup',
        '\u2A0D': 'fpartint',
        '\u2A10': 'cirfnint',
        '\u2A11': 'awint',
        '\u2A12': 'rppolint',
        '\u2A13': 'scpolint',
        '\u2A14': 'npolint',
        '\u2A15': 'pointint',
        '\u2A16': 'quatint',
        '\u2A17': 'intlarhk',
        '\u2A22': 'pluscir',
        '\u2A23': 'plusacir',
        '\u2A24': 'simplus',
        '\u2A25': 'plusdu',
        '\u2A26': 'plussim',
        '\u2A27': 'plustwo',
        '\u2A29': 'mcomma',
        '\u2A2A': 'minusdu',
        '\u2A2D': 'loplus',
        '\u2A2E': 'roplus',
        '\u2A2F': 'Cross',
        '\u2A30': 'timesd',
        '\u2A31': 'timesbar',
        '\u2A33': 'smashp',
        '\u2A34': 'lotimes',
        '\u2A35': 'rotimes',
        '\u2A36': 'otimesas',
        '\u2A37': 'Otimes',
        '\u2A38': 'odiv',
        '\u2A39': 'triplus',
        '\u2A3A': 'triminus',
        '\u2A3B': 'tritime',
        '\u2A3C': 'iprod',
        '\u2A3F': 'amalg',
        '\u2A40': 'capdot',
        '\u2A42': 'ncup',
        '\u2A43': 'ncap',
        '\u2A44': 'capand',
        '\u2A45': 'cupor',
        '\u2A46': 'cupcap',
        '\u2A47': 'capcup',
        '\u2A48': 'cupbrcap',
        '\u2A49': 'capbrcup',
        '\u2A4A': 'cupcup',
        '\u2A4B': 'capcap',
        '\u2A4C': 'ccups',
        '\u2A4D': 'ccaps',
        '\u2A50': 'ccupssm',
        '\u2A53': 'And',
        '\u2A54': 'Or',
        '\u2A55': 'andand',
        '\u2A56': 'oror',
        '\u2A57': 'orslope',
        '\u2A58': 'andslope',
        '\u2A5A': 'andv',
        '\u2A5B': 'orv',
        '\u2A5C': 'andd',
        '\u2A5D': 'ord',
        '\u2A5F': 'wedbar',
        '\u2A66': 'sdote',
        '\u2A6A': 'simdot',
        '\u2A6D': 'congdot',
        '\u2A6D̸': 'ncongdot',
        '\u2A6E': 'easter',
        '\u2A6F': 'apacir',
        '\u2A70': 'apE',
        '\u2A70̸': 'napE',
        '\u2A71': 'eplus',
        '\u2A72': 'pluse',
        '\u2A73': 'Esim',
        '\u2A77': 'eDDot',
        '\u2A78': 'equivDD',
        '\u2A79': 'ltcir',
        '\u2A7A': 'gtcir',
        '\u2A7B': 'ltquest',
        '\u2A7C': 'gtquest',
        '\u2A7D': 'les',
        '\u2A7D̸': 'nles',
        '\u2A7E': 'ges',
        '\u2A7E̸': 'nges',
        '\u2A7F': 'lesdot',
        '\u2A80': 'gesdot',
        '\u2A81': 'lesdoto',
        '\u2A82': 'gesdoto',
        '\u2A83': 'lesdotor',
        '\u2A84': 'gesdotol',
        '\u2A85': 'lap',
        '\u2A86': 'gap',
        '\u2A87': 'lne',
        '\u2A88': 'gne',
        '\u2A89': 'lnap',
        '\u2A8A': 'gnap',
        '\u2A8B': 'lEg',
        '\u2A8C': 'gEl',
        '\u2A8D': 'lsime',
        '\u2A8E': 'gsime',
        '\u2A8F': 'lsimg',
        '\u2A90': 'gsiml',
        '\u2A91': 'lgE',
        '\u2A92': 'glE',
        '\u2A93': 'lesges',
        '\u2A94': 'gesles',
        '\u2A95': 'els',
        '\u2A96': 'egs',
        '\u2A97': 'elsdot',
        '\u2A98': 'egsdot',
        '\u2A99': 'el',
        '\u2A9A': 'eg',
        '\u2A9D': 'siml',
        '\u2A9E': 'simg',
        '\u2A9F': 'simlE',
        '\u2AA0': 'simgE',
        '\u2AA1': 'LessLess',
        '\u2AA1̸': 'NotNestedLessLess',
        '\u2AA2': 'GreaterGreater',
        '\u2AA2̸': 'NotNestedGreaterGreater',
        '\u2AA4': 'glj',
        '\u2AA5': 'gla',
        '\u2AA6': 'ltcc',
        '\u2AA7': 'gtcc',
        '\u2AA8': 'lescc',
        '\u2AA9': 'gescc',
        '\u2AAA': 'smt',
        '\u2AAB': 'lat',
        '\u2AAC': 'smte',
        '\u2AAC︀': 'smtes',
        '\u2AAD': 'late',
        '\u2AAD︀': 'lates',
        '\u2AAE': 'bumpE',
        '\u2AAF': 'pre',
        '\u2AAF̸': 'npre',
        '\u2AB0': 'sce',
        '\u2AB0̸': 'nsce',
        '\u2AB3': 'prE',
        '\u2AB4': 'scE',
        '\u2AB5': 'prnE',
        '\u2AB6': 'scnE',
        '\u2AB7': 'prap',
        '\u2AB8': 'scap',
        '\u2AB9': 'prnap',
        '\u2ABA': 'scnap',
        '\u2ABB': 'Pr',
        '\u2ABC': 'Sc',
        '\u2ABD': 'subdot',
        '\u2ABE': 'supdot',
        '\u2ABF': 'subplus',
        '\u2AC0': 'supplus',
        '\u2AC1': 'submult',
        '\u2AC2': 'supmult',
        '\u2AC3': 'subedot',
        '\u2AC4': 'supedot',
        '\u2AC5': 'subE',
        '\u2AC5̸': 'nsubE',
        '\u2AC6': 'supE',
        '\u2AC6̸': 'nsupE',
        '\u2AC7': 'subsim',
        '\u2AC8': 'supsim',
        '\u2ACB︀': 'vsubnE',
        '\u2ACB': 'subnE',
        '\u2ACC︀': 'vsupnE',
        '\u2ACC': 'supnE',
        '\u2ACF': 'csub',
        '\u2AD0': 'csup',
        '\u2AD1': 'csube',
        '\u2AD2': 'csupe',
        '\u2AD3': 'subsup',
        '\u2AD4': 'supsub',
        '\u2AD5': 'subsub',
        '\u2AD6': 'supsup',
        '\u2AD7': 'suphsub',
        '\u2AD8': 'supdsub',
        '\u2AD9': 'forkv',
        '\u2ADA': 'topfork',
        '\u2ADB': 'mlcp',
        '\u2AE4': 'Dashv',
        '\u2AE6': 'Vdashl',
        '\u2AE7': 'Barv',
        '\u2AE8': 'vBar',
        '\u2AE9': 'vBarv',
        '\u2AEB': 'Vbar',
        '\u2AEC': 'Not',
        '\u2AED': 'bNot',
        '\u2AEE': 'rnmid',
        '\u2AEF': 'cirmid',
        '\u2AF0': 'midcir',
        '\u2AF1': 'topcir',
        '\u2AF2': 'nhpar',
        '\u2AF3': 'parsim',
        '\u2AFD': 'parsl',
        '\u2AFD⃥': 'nparsl',
        '\u266D': 'flat',
        '\u266E': 'natur',
        '\u266F': 'sharp',
        '\xA4': 'curren',
        '\xA2': 'cent',
        '$': 'dollar',
        '\xA3': 'pound',
        '\xA5': 'yen',
        '\u20AC': 'euro',
        '\xB9': 'sup1',
        '\xBD': 'half',
        '\u2153': 'frac13',
        '\xBC': 'frac14',
        '\u2155': 'frac15',
        '\u2159': 'frac16',
        '\u215B': 'frac18',
        '\xB2': 'sup2',
        '\u2154': 'frac23',
        '\u2156': 'frac25',
        '\xB3': 'sup3',
        '\xBE': 'frac34',
        '\u2157': 'frac35',
        '\u215C': 'frac38',
        '\u2158': 'frac45',
        '\u215A': 'frac56',
        '\u215D': 'frac58',
        '\u215E': 'frac78',
        '\uD835\uDCB6': 'ascr',
        '\uD835\uDD52': 'aopf',
        '\uD835\uDD1E': 'afr',
        '\uD835\uDD38': 'Aopf',
        '\uD835\uDD04': 'Afr',
        '\uD835\uDC9C': 'Ascr',
        'ª': 'ordf',
        'á': 'aacute',
        'Á': 'Aacute',
        'à': 'agrave',
        'À': 'Agrave',
        'ă': 'abreve',
        'Ă': 'Abreve',
        'â': 'acirc',
        'Â': 'Acirc',
        'å': 'aring',
        'Å': 'angst',
        'ä': 'auml',
        'Ä': 'Auml',
        'ã': 'atilde',
        'Ã': 'Atilde',
        'ą': 'aogon',
        'Ą': 'Aogon',
        'ā': 'amacr',
        'Ā': 'Amacr',
        'æ': 'aelig',
        'Æ': 'AElig',
        '\uD835\uDCB7': 'bscr',
        '\uD835\uDD53': 'bopf',
        '\uD835\uDD1F': 'bfr',
        '\uD835\uDD39': 'Bopf',
        'ℬ': 'Bscr',
        '\uD835\uDD05': 'Bfr',
        '\uD835\uDD20': 'cfr',
        '\uD835\uDCB8': 'cscr',
        '\uD835\uDD54': 'copf',
        'ℭ': 'Cfr',
        '\uD835\uDC9E': 'Cscr',
        'ℂ': 'Copf',
        'ć': 'cacute',
        'Ć': 'Cacute',
        'ĉ': 'ccirc',
        'Ĉ': 'Ccirc',
        'č': 'ccaron',
        'Č': 'Ccaron',
        'ċ': 'cdot',
        'Ċ': 'Cdot',
        'ç': 'ccedil',
        'Ç': 'Ccedil',
        '\u2105': 'incare',
        '\uD835\uDD21': 'dfr',
        'ⅆ': 'dd',
        '\uD835\uDD55': 'dopf',
        '\uD835\uDCB9': 'dscr',
        '\uD835\uDC9F': 'Dscr',
        '\uD835\uDD07': 'Dfr',
        'ⅅ': 'DD',
        '\uD835\uDD3B': 'Dopf',
        'ď': 'dcaron',
        'Ď': 'Dcaron',
        'đ': 'dstrok',
        'Đ': 'Dstrok',
        'ð': 'eth',
        'Ð': 'ETH',
        'ⅇ': 'ee',
        'ℯ': 'escr',
        '\uD835\uDD22': 'efr',
        '\uD835\uDD56': 'eopf',
        'ℰ': 'Escr',
        '\uD835\uDD08': 'Efr',
        '\uD835\uDD3C': 'Eopf',
        'é': 'eacute',
        'É': 'Eacute',
        'è': 'egrave',
        'È': 'Egrave',
        'ê': 'ecirc',
        'Ê': 'Ecirc',
        'ě': 'ecaron',
        'Ě': 'Ecaron',
        'ë': 'euml',
        'Ë': 'Euml',
        'ė': 'edot',
        'Ė': 'Edot',
        'ę': 'eogon',
        'Ę': 'Eogon',
        'ē': 'emacr',
        'Ē': 'Emacr',
        '\uD835\uDD23': 'ffr',
        '\uD835\uDD57': 'fopf',
        '\uD835\uDCBB': 'fscr',
        '\uD835\uDD09': 'Ffr',
        '\uD835\uDD3D': 'Fopf',
        'ℱ': 'Fscr',
        'ﬀ': 'fflig',
        'ﬃ': 'ffilig',
        'ﬄ': 'ffllig',
        'ﬁ': 'filig',
        'fj': 'fjlig',
        'ﬂ': 'fllig',
        'ƒ': 'fnof',
        'ℊ': 'gscr',
        '\uD835\uDD58': 'gopf',
        '\uD835\uDD24': 'gfr',
        '\uD835\uDCA2': 'Gscr',
        '\uD835\uDD3E': 'Gopf',
        '\uD835\uDD0A': 'Gfr',
        'ǵ': 'gacute',
        'ğ': 'gbreve',
        'Ğ': 'Gbreve',
        'ĝ': 'gcirc',
        'Ĝ': 'Gcirc',
        'ġ': 'gdot',
        'Ġ': 'Gdot',
        'Ģ': 'Gcedil',
        '\uD835\uDD25': 'hfr',
        'ℎ': 'planckh',
        '\uD835\uDCBD': 'hscr',
        '\uD835\uDD59': 'hopf',
        'ℋ': 'Hscr',
        'ℌ': 'Hfr',
        'ℍ': 'Hopf',
        'ĥ': 'hcirc',
        'Ĥ': 'Hcirc',
        'ℏ': 'hbar',
        'ħ': 'hstrok',
        'Ħ': 'Hstrok',
        '\uD835\uDD5A': 'iopf',
        '\uD835\uDD26': 'ifr',
        '\uD835\uDCBE': 'iscr',
        'ⅈ': 'ii',
        '\uD835\uDD40': 'Iopf',
        'ℐ': 'Iscr',
        'ℑ': 'Im',
        'í': 'iacute',
        'Í': 'Iacute',
        'ì': 'igrave',
        'Ì': 'Igrave',
        'î': 'icirc',
        'Î': 'Icirc',
        'ï': 'iuml',
        'Ï': 'Iuml',
        'ĩ': 'itilde',
        'Ĩ': 'Itilde',
        'İ': 'Idot',
        'į': 'iogon',
        'Į': 'Iogon',
        'ī': 'imacr',
        'Ī': 'Imacr',
        'ĳ': 'ijlig',
        'Ĳ': 'IJlig',
        'ı': 'imath',
        '\uD835\uDCBF': 'jscr',
        '\uD835\uDD5B': 'jopf',
        '\uD835\uDD27': 'jfr',
        '\uD835\uDCA5': 'Jscr',
        '\uD835\uDD0D': 'Jfr',
        '\uD835\uDD41': 'Jopf',
        'ĵ': 'jcirc',
        'Ĵ': 'Jcirc',
        'ȷ': 'jmath',
        '\uD835\uDD5C': 'kopf',
        '\uD835\uDCC0': 'kscr',
        '\uD835\uDD28': 'kfr',
        '\uD835\uDCA6': 'Kscr',
        '\uD835\uDD42': 'Kopf',
        '\uD835\uDD0E': 'Kfr',
        'ķ': 'kcedil',
        'Ķ': 'Kcedil',
        '\uD835\uDD29': 'lfr',
        '\uD835\uDCC1': 'lscr',
        'ℓ': 'ell',
        '\uD835\uDD5D': 'lopf',
        'ℒ': 'Lscr',
        '\uD835\uDD0F': 'Lfr',
        '\uD835\uDD43': 'Lopf',
        'ĺ': 'lacute',
        'Ĺ': 'Lacute',
        'ľ': 'lcaron',
        'Ľ': 'Lcaron',
        'ļ': 'lcedil',
        'Ļ': 'Lcedil',
        'ł': 'lstrok',
        'Ł': 'Lstrok',
        'ŀ': 'lmidot',
        'Ŀ': 'Lmidot',
        '\uD835\uDD2A': 'mfr',
        '\uD835\uDD5E': 'mopf',
        '\uD835\uDCC2': 'mscr',
        '\uD835\uDD10': 'Mfr',
        '\uD835\uDD44': 'Mopf',
        'ℳ': 'Mscr',
        '\uD835\uDD2B': 'nfr',
        '\uD835\uDD5F': 'nopf',
        '\uD835\uDCC3': 'nscr',
        'ℕ': 'Nopf',
        '\uD835\uDCA9': 'Nscr',
        '\uD835\uDD11': 'Nfr',
        'ń': 'nacute',
        'Ń': 'Nacute',
        'ň': 'ncaron',
        'Ň': 'Ncaron',
        'ñ': 'ntilde',
        'Ñ': 'Ntilde',
        'ņ': 'ncedil',
        'Ņ': 'Ncedil',
        '\u2116': 'numero',
        'ŋ': 'eng',
        'Ŋ': 'ENG',
        '\uD835\uDD60': 'oopf',
        '\uD835\uDD2C': 'ofr',
        'ℴ': 'oscr',
        '\uD835\uDCAA': 'Oscr',
        '\uD835\uDD12': 'Ofr',
        '\uD835\uDD46': 'Oopf',
        'º': 'ordm',
        'ó': 'oacute',
        'Ó': 'Oacute',
        'ò': 'ograve',
        'Ò': 'Ograve',
        'ô': 'ocirc',
        'Ô': 'Ocirc',
        'ö': 'ouml',
        'Ö': 'Ouml',
        'ő': 'odblac',
        'Ő': 'Odblac',
        'õ': 'otilde',
        'Õ': 'Otilde',
        'ø': 'oslash',
        'Ø': 'Oslash',
        'ō': 'omacr',
        'Ō': 'Omacr',
        'œ': 'oelig',
        'Œ': 'OElig',
        '\uD835\uDD2D': 'pfr',
        '\uD835\uDCC5': 'pscr',
        '\uD835\uDD61': 'popf',
        'ℙ': 'Popf',
        '\uD835\uDD13': 'Pfr',
        '\uD835\uDCAB': 'Pscr',
        '\uD835\uDD62': 'qopf',
        '\uD835\uDD2E': 'qfr',
        '\uD835\uDCC6': 'qscr',
        '\uD835\uDCAC': 'Qscr',
        '\uD835\uDD14': 'Qfr',
        'ℚ': 'Qopf',
        'ĸ': 'kgreen',
        '\uD835\uDD2F': 'rfr',
        '\uD835\uDD63': 'ropf',
        '\uD835\uDCC7': 'rscr',
        'ℛ': 'Rscr',
        'ℜ': 'Re',
        'ℝ': 'Ropf',
        'ŕ': 'racute',
        'Ŕ': 'Racute',
        'ř': 'rcaron',
        'Ř': 'Rcaron',
        'ŗ': 'rcedil',
        'Ŗ': 'Rcedil',
        '\uD835\uDD64': 'sopf',
        '\uD835\uDCC8': 'sscr',
        '\uD835\uDD30': 'sfr',
        '\uD835\uDD4A': 'Sopf',
        '\uD835\uDD16': 'Sfr',
        '\uD835\uDCAE': 'Sscr',
        '\u24C8': 'oS',
        'ś': 'sacute',
        'Ś': 'Sacute',
        'ŝ': 'scirc',
        'Ŝ': 'Scirc',
        'š': 'scaron',
        'Š': 'Scaron',
        'ş': 'scedil',
        'Ş': 'Scedil',
        'ß': 'szlig',
        '\uD835\uDD31': 'tfr',
        '\uD835\uDCC9': 'tscr',
        '\uD835\uDD65': 'topf',
        '\uD835\uDCAF': 'Tscr',
        '\uD835\uDD17': 'Tfr',
        '\uD835\uDD4B': 'Topf',
        'ť': 'tcaron',
        'Ť': 'Tcaron',
        'ţ': 'tcedil',
        'Ţ': 'Tcedil',
        '\u2122': 'trade',
        'ŧ': 'tstrok',
        'Ŧ': 'Tstrok',
        '\uD835\uDCCA': 'uscr',
        '\uD835\uDD66': 'uopf',
        '\uD835\uDD32': 'ufr',
        '\uD835\uDD4C': 'Uopf',
        '\uD835\uDD18': 'Ufr',
        '\uD835\uDCB0': 'Uscr',
        'ú': 'uacute',
        'Ú': 'Uacute',
        'ù': 'ugrave',
        'Ù': 'Ugrave',
        'ŭ': 'ubreve',
        'Ŭ': 'Ubreve',
        'û': 'ucirc',
        'Û': 'Ucirc',
        'ů': 'uring',
        'Ů': 'Uring',
        'ü': 'uuml',
        'Ü': 'Uuml',
        'ű': 'udblac',
        'Ű': 'Udblac',
        'ũ': 'utilde',
        'Ũ': 'Utilde',
        'ų': 'uogon',
        'Ų': 'Uogon',
        'ū': 'umacr',
        'Ū': 'Umacr',
        '\uD835\uDD33': 'vfr',
        '\uD835\uDD67': 'vopf',
        '\uD835\uDCCB': 'vscr',
        '\uD835\uDD19': 'Vfr',
        '\uD835\uDD4D': 'Vopf',
        '\uD835\uDCB1': 'Vscr',
        '\uD835\uDD68': 'wopf',
        '\uD835\uDCCC': 'wscr',
        '\uD835\uDD34': 'wfr',
        '\uD835\uDCB2': 'Wscr',
        '\uD835\uDD4E': 'Wopf',
        '\uD835\uDD1A': 'Wfr',
        'ŵ': 'wcirc',
        'Ŵ': 'Wcirc',
        '\uD835\uDD35': 'xfr',
        '\uD835\uDCCD': 'xscr',
        '\uD835\uDD69': 'xopf',
        '\uD835\uDD4F': 'Xopf',
        '\uD835\uDD1B': 'Xfr',
        '\uD835\uDCB3': 'Xscr',
        '\uD835\uDD36': 'yfr',
        '\uD835\uDCCE': 'yscr',
        '\uD835\uDD6A': 'yopf',
        '\uD835\uDCB4': 'Yscr',
        '\uD835\uDD1C': 'Yfr',
        '\uD835\uDD50': 'Yopf',
        'ý': 'yacute',
        'Ý': 'Yacute',
        'ŷ': 'ycirc',
        'Ŷ': 'Ycirc',
        'ÿ': 'yuml',
        'Ÿ': 'Yuml',
        '\uD835\uDCCF': 'zscr',
        '\uD835\uDD37': 'zfr',
        '\uD835\uDD6B': 'zopf',
        'ℨ': 'Zfr',
        'ℤ': 'Zopf',
        '\uD835\uDCB5': 'Zscr',
        'ź': 'zacute',
        'Ź': 'Zacute',
        'ž': 'zcaron',
        'Ž': 'Zcaron',
        'ż': 'zdot',
        'Ż': 'Zdot',
        'Ƶ': 'imped',
        'þ': 'thorn',
        'Þ': 'THORN',
        'ŉ': 'napos',
        'α': 'alpha',
        'Α': 'Alpha',
        'β': 'beta',
        'Β': 'Beta',
        'γ': 'gamma',
        'Γ': 'Gamma',
        'δ': 'delta',
        'Δ': 'Delta',
        'ε': 'epsi',
        'ϵ': 'epsiv',
        'Ε': 'Epsilon',
        'ϝ': 'gammad',
        'Ϝ': 'Gammad',
        'ζ': 'zeta',
        'Ζ': 'Zeta',
        'η': 'eta',
        'Η': 'Eta',
        'θ': 'theta',
        'ϑ': 'thetav',
        'Θ': 'Theta',
        'ι': 'iota',
        'Ι': 'Iota',
        'κ': 'kappa',
        'ϰ': 'kappav',
        'Κ': 'Kappa',
        'λ': 'lambda',
        'Λ': 'Lambda',
        'μ': 'mu',
        'µ': 'micro',
        'Μ': 'Mu',
        'ν': 'nu',
        'Ν': 'Nu',
        'ξ': 'xi',
        'Ξ': 'Xi',
        'ο': 'omicron',
        'Ο': 'Omicron',
        'π': 'pi',
        'ϖ': 'piv',
        'Π': 'Pi',
        'ρ': 'rho',
        'ϱ': 'rhov',
        'Ρ': 'Rho',
        'σ': 'sigma',
        'Σ': 'Sigma',
        'ς': 'sigmaf',
        'τ': 'tau',
        'Τ': 'Tau',
        'υ': 'upsi',
        'Υ': 'Upsilon',
        'ϒ': 'Upsi',
        'φ': 'phi',
        'ϕ': 'phiv',
        'Φ': 'Phi',
        'χ': 'chi',
        'Χ': 'Chi',
        'ψ': 'psi',
        'Ψ': 'Psi',
        'ω': 'omega',
        'Ω': 'ohm',
        'а': 'acy',
        'А': 'Acy',
        'б': 'bcy',
        'Б': 'Bcy',
        'в': 'vcy',
        'В': 'Vcy',
        'г': 'gcy',
        'Г': 'Gcy',
        'ѓ': 'gjcy',
        'Ѓ': 'GJcy',
        'д': 'dcy',
        'Д': 'Dcy',
        'ђ': 'djcy',
        'Ђ': 'DJcy',
        'е': 'iecy',
        'Е': 'IEcy',
        'ё': 'iocy',
        'Ё': 'IOcy',
        'є': 'jukcy',
        'Є': 'Jukcy',
        'ж': 'zhcy',
        'Ж': 'ZHcy',
        'з': 'zcy',
        'З': 'Zcy',
        'ѕ': 'dscy',
        'Ѕ': 'DScy',
        'и': 'icy',
        'И': 'Icy',
        'і': 'iukcy',
        'І': 'Iukcy',
        'ї': 'yicy',
        'Ї': 'YIcy',
        'й': 'jcy',
        'Й': 'Jcy',
        'ј': 'jsercy',
        'Ј': 'Jsercy',
        'к': 'kcy',
        'К': 'Kcy',
        'ќ': 'kjcy',
        'Ќ': 'KJcy',
        'л': 'lcy',
        'Л': 'Lcy',
        'љ': 'ljcy',
        'Љ': 'LJcy',
        'м': 'mcy',
        'М': 'Mcy',
        'н': 'ncy',
        'Н': 'Ncy',
        'њ': 'njcy',
        'Њ': 'NJcy',
        'о': 'ocy',
        'О': 'Ocy',
        'п': 'pcy',
        'П': 'Pcy',
        'р': 'rcy',
        'Р': 'Rcy',
        'с': 'scy',
        'С': 'Scy',
        'т': 'tcy',
        'Т': 'Tcy',
        'ћ': 'tshcy',
        'Ћ': 'TSHcy',
        'у': 'ucy',
        'У': 'Ucy',
        'ў': 'ubrcy',
        'Ў': 'Ubrcy',
        'ф': 'fcy',
        'Ф': 'Fcy',
        'х': 'khcy',
        'Х': 'KHcy',
        'ц': 'tscy',
        'Ц': 'TScy',
        'ч': 'chcy',
        'Ч': 'CHcy',
        'џ': 'dzcy',
        'Џ': 'DZcy',
        'ш': 'shcy',
        'Ш': 'SHcy',
        'щ': 'shchcy',
        'Щ': 'SHCHcy',
        'ъ': 'hardcy',
        'Ъ': 'HARDcy',
        'ы': 'ycy',
        'Ы': 'Ycy',
        'ь': 'softcy',
        'Ь': 'SOFTcy',
        'э': 'ecy',
        'Э': 'Ecy',
        'ю': 'yucy',
        'Ю': 'YUcy',
        'я': 'yacy',
        'Я': 'YAcy',
        'ℵ': 'aleph',
        'ℶ': 'beth',
        'ℷ': 'gimel',
        'ℸ': 'daleth'
    };
    var regexEscape = /["&'<>`]/g;
    var escapeMap = {
        '"': '&quot;',
        '&': '&amp;',
        '\'': '&#x27;',
        '<': '&lt;',
        '>': '&gt;',
        '`': '&#x60;'
    };
    var regexInvalidEntity = /&#(?:[xX][^a-fA-F0-9]|[^0-9xX])/;
    var regexInvalidRawCodePoint = /[\0-\x08\x0B\x0E-\x1F\x7F-\x9F\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
    var regexDecode = /&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)([=a-zA-Z0-9])?/g;
    var decodeMap = {
        'aacute': 'á',
        'Aacute': 'Á',
        'abreve': 'ă',
        'Abreve': 'Ă',
        'ac': '\u223E',
        'acd': '\u223F',
        'acE': '\u223E̳',
        'acirc': 'â',
        'Acirc': 'Â',
        'acute': '\xB4',
        'acy': 'а',
        'Acy': 'А',
        'aelig': 'æ',
        'AElig': 'Æ',
        'af': '\u2061',
        'afr': '\uD835\uDD1E',
        'Afr': '\uD835\uDD04',
        'agrave': 'à',
        'Agrave': 'À',
        'alefsym': 'ℵ',
        'aleph': 'ℵ',
        'alpha': 'α',
        'Alpha': 'Α',
        'amacr': 'ā',
        'Amacr': 'Ā',
        'amalg': '\u2A3F',
        'amp': '&',
        'AMP': '&',
        'and': '\u2227',
        'And': '\u2A53',
        'andand': '\u2A55',
        'andd': '\u2A5C',
        'andslope': '\u2A58',
        'andv': '\u2A5A',
        'ang': '\u2220',
        'ange': '\u29A4',
        'angle': '\u2220',
        'angmsd': '\u2221',
        'angmsdaa': '\u29A8',
        'angmsdab': '\u29A9',
        'angmsdac': '\u29AA',
        'angmsdad': '\u29AB',
        'angmsdae': '\u29AC',
        'angmsdaf': '\u29AD',
        'angmsdag': '\u29AE',
        'angmsdah': '\u29AF',
        'angrt': '\u221F',
        'angrtvb': '\u22BE',
        'angrtvbd': '\u299D',
        'angsph': '\u2222',
        'angst': 'Å',
        'angzarr': '\u237C',
        'aogon': 'ą',
        'Aogon': 'Ą',
        'aopf': '\uD835\uDD52',
        'Aopf': '\uD835\uDD38',
        'ap': '\u2248',
        'apacir': '\u2A6F',
        'ape': '\u224A',
        'apE': '\u2A70',
        'apid': '\u224B',
        'apos': '\'',
        'ApplyFunction': '\u2061',
        'approx': '\u2248',
        'approxeq': '\u224A',
        'aring': 'å',
        'Aring': 'Å',
        'ascr': '\uD835\uDCB6',
        'Ascr': '\uD835\uDC9C',
        'Assign': '\u2254',
        'ast': '*',
        'asymp': '\u2248',
        'asympeq': '\u224D',
        'atilde': 'ã',
        'Atilde': 'Ã',
        'auml': 'ä',
        'Auml': 'Ä',
        'awconint': '\u2233',
        'awint': '\u2A11',
        'backcong': '\u224C',
        'backepsilon': '\u03F6',
        'backprime': '\u2035',
        'backsim': '\u223D',
        'backsimeq': '\u22CD',
        'Backslash': '\u2216',
        'Barv': '\u2AE7',
        'barvee': '\u22BD',
        'barwed': '\u2305',
        'Barwed': '\u2306',
        'barwedge': '\u2305',
        'bbrk': '\u23B5',
        'bbrktbrk': '\u23B6',
        'bcong': '\u224C',
        'bcy': 'б',
        'Bcy': 'Б',
        'bdquo': '\u201E',
        'becaus': '\u2235',
        'because': '\u2235',
        'Because': '\u2235',
        'bemptyv': '\u29B0',
        'bepsi': '\u03F6',
        'bernou': 'ℬ',
        'Bernoullis': 'ℬ',
        'beta': 'β',
        'Beta': 'Β',
        'beth': 'ℶ',
        'between': '\u226C',
        'bfr': '\uD835\uDD1F',
        'Bfr': '\uD835\uDD05',
        'bigcap': '\u22C2',
        'bigcirc': '\u25EF',
        'bigcup': '\u22C3',
        'bigodot': '\u2A00',
        'bigoplus': '\u2A01',
        'bigotimes': '\u2A02',
        'bigsqcup': '\u2A06',
        'bigstar': '\u2605',
        'bigtriangledown': '\u25BD',
        'bigtriangleup': '\u25B3',
        'biguplus': '\u2A04',
        'bigvee': '\u22C1',
        'bigwedge': '\u22C0',
        'bkarow': '\u290D',
        'blacklozenge': '\u29EB',
        'blacksquare': '\u25AA',
        'blacktriangle': '\u25B4',
        'blacktriangledown': '\u25BE',
        'blacktriangleleft': '\u25C2',
        'blacktriangleright': '\u25B8',
        'blank': '\u2423',
        'blk12': '\u2592',
        'blk14': '\u2591',
        'blk34': '\u2593',
        'block': '\u2588',
        'bne': '=⃥',
        'bnequiv': '\u2261⃥',
        'bnot': '\u2310',
        'bNot': '\u2AED',
        'bopf': '\uD835\uDD53',
        'Bopf': '\uD835\uDD39',
        'bot': '\u22A5',
        'bottom': '\u22A5',
        'bowtie': '\u22C8',
        'boxbox': '\u29C9',
        'boxdl': '\u2510',
        'boxdL': '\u2555',
        'boxDl': '\u2556',
        'boxDL': '\u2557',
        'boxdr': '\u250C',
        'boxdR': '\u2552',
        'boxDr': '\u2553',
        'boxDR': '\u2554',
        'boxh': '\u2500',
        'boxH': '\u2550',
        'boxhd': '\u252C',
        'boxhD': '\u2565',
        'boxHd': '\u2564',
        'boxHD': '\u2566',
        'boxhu': '\u2534',
        'boxhU': '\u2568',
        'boxHu': '\u2567',
        'boxHU': '\u2569',
        'boxminus': '\u229F',
        'boxplus': '\u229E',
        'boxtimes': '\u22A0',
        'boxul': '\u2518',
        'boxuL': '\u255B',
        'boxUl': '\u255C',
        'boxUL': '\u255D',
        'boxur': '\u2514',
        'boxuR': '\u2558',
        'boxUr': '\u2559',
        'boxUR': '\u255A',
        'boxv': '\u2502',
        'boxV': '\u2551',
        'boxvh': '\u253C',
        'boxvH': '\u256A',
        'boxVh': '\u256B',
        'boxVH': '\u256C',
        'boxvl': '\u2524',
        'boxvL': '\u2561',
        'boxVl': '\u2562',
        'boxVL': '\u2563',
        'boxvr': '\u251C',
        'boxvR': '\u255E',
        'boxVr': '\u255F',
        'boxVR': '\u2560',
        'bprime': '\u2035',
        'breve': '\u02D8',
        'Breve': '\u02D8',
        'brvbar': '\xA6',
        'bscr': '\uD835\uDCB7',
        'Bscr': 'ℬ',
        'bsemi': '\u204F',
        'bsim': '\u223D',
        'bsime': '\u22CD',
        'bsol': '\\',
        'bsolb': '\u29C5',
        'bsolhsub': '\u27C8',
        'bull': '\u2022',
        'bullet': '\u2022',
        'bump': '\u224E',
        'bumpe': '\u224F',
        'bumpE': '\u2AAE',
        'bumpeq': '\u224F',
        'Bumpeq': '\u224E',
        'cacute': 'ć',
        'Cacute': 'Ć',
        'cap': '\u2229',
        'Cap': '\u22D2',
        'capand': '\u2A44',
        'capbrcup': '\u2A49',
        'capcap': '\u2A4B',
        'capcup': '\u2A47',
        'capdot': '\u2A40',
        'CapitalDifferentialD': 'ⅅ',
        'caps': '\u2229︀',
        'caret': '\u2041',
        'caron': 'ˇ',
        'Cayleys': 'ℭ',
        'ccaps': '\u2A4D',
        'ccaron': 'č',
        'Ccaron': 'Č',
        'ccedil': 'ç',
        'Ccedil': 'Ç',
        'ccirc': 'ĉ',
        'Ccirc': 'Ĉ',
        'Cconint': '\u2230',
        'ccups': '\u2A4C',
        'ccupssm': '\u2A50',
        'cdot': 'ċ',
        'Cdot': 'Ċ',
        'cedil': '\xB8',
        'Cedilla': '\xB8',
        'cemptyv': '\u29B2',
        'cent': '\xA2',
        'centerdot': '\xB7',
        'CenterDot': '\xB7',
        'cfr': '\uD835\uDD20',
        'Cfr': 'ℭ',
        'chcy': 'ч',
        'CHcy': 'Ч',
        'check': '\u2713',
        'checkmark': '\u2713',
        'chi': 'χ',
        'Chi': 'Χ',
        'cir': '\u25CB',
        'circ': 'ˆ',
        'circeq': '\u2257',
        'circlearrowleft': '\u21BA',
        'circlearrowright': '\u21BB',
        'circledast': '\u229B',
        'circledcirc': '\u229A',
        'circleddash': '\u229D',
        'CircleDot': '\u2299',
        'circledR': '\xAE',
        'circledS': '\u24C8',
        'CircleMinus': '\u2296',
        'CirclePlus': '\u2295',
        'CircleTimes': '\u2297',
        'cire': '\u2257',
        'cirE': '\u29C3',
        'cirfnint': '\u2A10',
        'cirmid': '\u2AEF',
        'cirscir': '\u29C2',
        'ClockwiseContourIntegral': '\u2232',
        'CloseCurlyDoubleQuote': '\u201D',
        'CloseCurlyQuote': '\u2019',
        'clubs': '\u2663',
        'clubsuit': '\u2663',
        'colon': ':',
        'Colon': '\u2237',
        'colone': '\u2254',
        'Colone': '\u2A74',
        'coloneq': '\u2254',
        'comma': ',',
        'commat': '@',
        'comp': '\u2201',
        'compfn': '\u2218',
        'complement': '\u2201',
        'complexes': 'ℂ',
        'cong': '\u2245',
        'congdot': '\u2A6D',
        'Congruent': '\u2261',
        'conint': '\u222E',
        'Conint': '\u222F',
        'ContourIntegral': '\u222E',
        'copf': '\uD835\uDD54',
        'Copf': 'ℂ',
        'coprod': '\u2210',
        'Coproduct': '\u2210',
        'copy': '\xA9',
        'COPY': '\xA9',
        'copysr': '\u2117',
        'CounterClockwiseContourIntegral': '\u2233',
        'crarr': '\u21B5',
        'cross': '\u2717',
        'Cross': '\u2A2F',
        'cscr': '\uD835\uDCB8',
        'Cscr': '\uD835\uDC9E',
        'csub': '\u2ACF',
        'csube': '\u2AD1',
        'csup': '\u2AD0',
        'csupe': '\u2AD2',
        'ctdot': '\u22EF',
        'cudarrl': '\u2938',
        'cudarrr': '\u2935',
        'cuepr': '\u22DE',
        'cuesc': '\u22DF',
        'cularr': '\u21B6',
        'cularrp': '\u293D',
        'cup': '\u222A',
        'Cup': '\u22D3',
        'cupbrcap': '\u2A48',
        'cupcap': '\u2A46',
        'CupCap': '\u224D',
        'cupcup': '\u2A4A',
        'cupdot': '\u228D',
        'cupor': '\u2A45',
        'cups': '\u222A︀',
        'curarr': '\u21B7',
        'curarrm': '\u293C',
        'curlyeqprec': '\u22DE',
        'curlyeqsucc': '\u22DF',
        'curlyvee': '\u22CE',
        'curlywedge': '\u22CF',
        'curren': '\xA4',
        'curvearrowleft': '\u21B6',
        'curvearrowright': '\u21B7',
        'cuvee': '\u22CE',
        'cuwed': '\u22CF',
        'cwconint': '\u2232',
        'cwint': '\u2231',
        'cylcty': '\u232D',
        'dagger': '\u2020',
        'Dagger': '\u2021',
        'daleth': 'ℸ',
        'darr': '\u2193',
        'dArr': '\u21D3',
        'Darr': '\u21A1',
        'dash': '\u2010',
        'dashv': '\u22A3',
        'Dashv': '\u2AE4',
        'dbkarow': '\u290F',
        'dblac': '\u02DD',
        'dcaron': 'ď',
        'Dcaron': 'Ď',
        'dcy': 'д',
        'Dcy': 'Д',
        'dd': 'ⅆ',
        'DD': 'ⅅ',
        'ddagger': '\u2021',
        'ddarr': '\u21CA',
        'DDotrahd': '\u2911',
        'ddotseq': '\u2A77',
        'deg': '\xB0',
        'Del': '\u2207',
        'delta': 'δ',
        'Delta': 'Δ',
        'demptyv': '\u29B1',
        'dfisht': '\u297F',
        'dfr': '\uD835\uDD21',
        'Dfr': '\uD835\uDD07',
        'dHar': '\u2965',
        'dharl': '\u21C3',
        'dharr': '\u21C2',
        'DiacriticalAcute': '\xB4',
        'DiacriticalDot': '\u02D9',
        'DiacriticalDoubleAcute': '\u02DD',
        'DiacriticalGrave': '`',
        'DiacriticalTilde': '\u02DC',
        'diam': '\u22C4',
        'diamond': '\u22C4',
        'Diamond': '\u22C4',
        'diamondsuit': '\u2666',
        'diams': '\u2666',
        'die': '\xA8',
        'DifferentialD': 'ⅆ',
        'digamma': 'ϝ',
        'disin': '\u22F2',
        'div': '\xF7',
        'divide': '\xF7',
        'divideontimes': '\u22C7',
        'divonx': '\u22C7',
        'djcy': 'ђ',
        'DJcy': 'Ђ',
        'dlcorn': '\u231E',
        'dlcrop': '\u230D',
        'dollar': '$',
        'dopf': '\uD835\uDD55',
        'Dopf': '\uD835\uDD3B',
        'dot': '\u02D9',
        'Dot': '\xA8',
        'DotDot': '⃜',
        'doteq': '\u2250',
        'doteqdot': '\u2251',
        'DotEqual': '\u2250',
        'dotminus': '\u2238',
        'dotplus': '\u2214',
        'dotsquare': '\u22A1',
        'doublebarwedge': '\u2306',
        'DoubleContourIntegral': '\u222F',
        'DoubleDot': '\xA8',
        'DoubleDownArrow': '\u21D3',
        'DoubleLeftArrow': '\u21D0',
        'DoubleLeftRightArrow': '\u21D4',
        'DoubleLeftTee': '\u2AE4',
        'DoubleLongLeftArrow': '\u27F8',
        'DoubleLongLeftRightArrow': '\u27FA',
        'DoubleLongRightArrow': '\u27F9',
        'DoubleRightArrow': '\u21D2',
        'DoubleRightTee': '\u22A8',
        'DoubleUpArrow': '\u21D1',
        'DoubleUpDownArrow': '\u21D5',
        'DoubleVerticalBar': '\u2225',
        'downarrow': '\u2193',
        'Downarrow': '\u21D3',
        'DownArrow': '\u2193',
        'DownArrowBar': '\u2913',
        'DownArrowUpArrow': '\u21F5',
        'DownBreve': '̑',
        'downdownarrows': '\u21CA',
        'downharpoonleft': '\u21C3',
        'downharpoonright': '\u21C2',
        'DownLeftRightVector': '\u2950',
        'DownLeftTeeVector': '\u295E',
        'DownLeftVector': '\u21BD',
        'DownLeftVectorBar': '\u2956',
        'DownRightTeeVector': '\u295F',
        'DownRightVector': '\u21C1',
        'DownRightVectorBar': '\u2957',
        'DownTee': '\u22A4',
        'DownTeeArrow': '\u21A7',
        'drbkarow': '\u2910',
        'drcorn': '\u231F',
        'drcrop': '\u230C',
        'dscr': '\uD835\uDCB9',
        'Dscr': '\uD835\uDC9F',
        'dscy': 'ѕ',
        'DScy': 'Ѕ',
        'dsol': '\u29F6',
        'dstrok': 'đ',
        'Dstrok': 'Đ',
        'dtdot': '\u22F1',
        'dtri': '\u25BF',
        'dtrif': '\u25BE',
        'duarr': '\u21F5',
        'duhar': '\u296F',
        'dwangle': '\u29A6',
        'dzcy': 'џ',
        'DZcy': 'Џ',
        'dzigrarr': '\u27FF',
        'eacute': 'é',
        'Eacute': 'É',
        'easter': '\u2A6E',
        'ecaron': 'ě',
        'Ecaron': 'Ě',
        'ecir': '\u2256',
        'ecirc': 'ê',
        'Ecirc': 'Ê',
        'ecolon': '\u2255',
        'ecy': 'э',
        'Ecy': 'Э',
        'eDDot': '\u2A77',
        'edot': 'ė',
        'eDot': '\u2251',
        'Edot': 'Ė',
        'ee': 'ⅇ',
        'efDot': '\u2252',
        'efr': '\uD835\uDD22',
        'Efr': '\uD835\uDD08',
        'eg': '\u2A9A',
        'egrave': 'è',
        'Egrave': 'È',
        'egs': '\u2A96',
        'egsdot': '\u2A98',
        'el': '\u2A99',
        'Element': '\u2208',
        'elinters': '\u23E7',
        'ell': 'ℓ',
        'els': '\u2A95',
        'elsdot': '\u2A97',
        'emacr': 'ē',
        'Emacr': 'Ē',
        'empty': '\u2205',
        'emptyset': '\u2205',
        'EmptySmallSquare': '\u25FB',
        'emptyv': '\u2205',
        'EmptyVerySmallSquare': '\u25AB',
        'emsp': '\u2003',
        'emsp13': '\u2004',
        'emsp14': '\u2005',
        'eng': 'ŋ',
        'ENG': 'Ŋ',
        'ensp': '\u2002',
        'eogon': 'ę',
        'Eogon': 'Ę',
        'eopf': '\uD835\uDD56',
        'Eopf': '\uD835\uDD3C',
        'epar': '\u22D5',
        'eparsl': '\u29E3',
        'eplus': '\u2A71',
        'epsi': 'ε',
        'epsilon': 'ε',
        'Epsilon': 'Ε',
        'epsiv': 'ϵ',
        'eqcirc': '\u2256',
        'eqcolon': '\u2255',
        'eqsim': '\u2242',
        'eqslantgtr': '\u2A96',
        'eqslantless': '\u2A95',
        'Equal': '\u2A75',
        'equals': '=',
        'EqualTilde': '\u2242',
        'equest': '\u225F',
        'Equilibrium': '\u21CC',
        'equiv': '\u2261',
        'equivDD': '\u2A78',
        'eqvparsl': '\u29E5',
        'erarr': '\u2971',
        'erDot': '\u2253',
        'escr': 'ℯ',
        'Escr': 'ℰ',
        'esdot': '\u2250',
        'esim': '\u2242',
        'Esim': '\u2A73',
        'eta': 'η',
        'Eta': 'Η',
        'eth': 'ð',
        'ETH': 'Ð',
        'euml': 'ë',
        'Euml': 'Ë',
        'euro': '\u20AC',
        'excl': '!',
        'exist': '\u2203',
        'Exists': '\u2203',
        'expectation': 'ℰ',
        'exponentiale': 'ⅇ',
        'ExponentialE': 'ⅇ',
        'fallingdotseq': '\u2252',
        'fcy': 'ф',
        'Fcy': 'Ф',
        'female': '\u2640',
        'ffilig': 'ﬃ',
        'fflig': 'ﬀ',
        'ffllig': 'ﬄ',
        'ffr': '\uD835\uDD23',
        'Ffr': '\uD835\uDD09',
        'filig': 'ﬁ',
        'FilledSmallSquare': '\u25FC',
        'FilledVerySmallSquare': '\u25AA',
        'fjlig': 'fj',
        'flat': '\u266D',
        'fllig': 'ﬂ',
        'fltns': '\u25B1',
        'fnof': 'ƒ',
        'fopf': '\uD835\uDD57',
        'Fopf': '\uD835\uDD3D',
        'forall': '\u2200',
        'ForAll': '\u2200',
        'fork': '\u22D4',
        'forkv': '\u2AD9',
        'Fouriertrf': 'ℱ',
        'fpartint': '\u2A0D',
        'frac12': '\xBD',
        'frac13': '\u2153',
        'frac14': '\xBC',
        'frac15': '\u2155',
        'frac16': '\u2159',
        'frac18': '\u215B',
        'frac23': '\u2154',
        'frac25': '\u2156',
        'frac34': '\xBE',
        'frac35': '\u2157',
        'frac38': '\u215C',
        'frac45': '\u2158',
        'frac56': '\u215A',
        'frac58': '\u215D',
        'frac78': '\u215E',
        'frasl': '\u2044',
        'frown': '\u2322',
        'fscr': '\uD835\uDCBB',
        'Fscr': 'ℱ',
        'gacute': 'ǵ',
        'gamma': 'γ',
        'Gamma': 'Γ',
        'gammad': 'ϝ',
        'Gammad': 'Ϝ',
        'gap': '\u2A86',
        'gbreve': 'ğ',
        'Gbreve': 'Ğ',
        'Gcedil': 'Ģ',
        'gcirc': 'ĝ',
        'Gcirc': 'Ĝ',
        'gcy': 'г',
        'Gcy': 'Г',
        'gdot': 'ġ',
        'Gdot': 'Ġ',
        'ge': '\u2265',
        'gE': '\u2267',
        'gel': '\u22DB',
        'gEl': '\u2A8C',
        'geq': '\u2265',
        'geqq': '\u2267',
        'geqslant': '\u2A7E',
        'ges': '\u2A7E',
        'gescc': '\u2AA9',
        'gesdot': '\u2A80',
        'gesdoto': '\u2A82',
        'gesdotol': '\u2A84',
        'gesl': '\u22DB︀',
        'gesles': '\u2A94',
        'gfr': '\uD835\uDD24',
        'Gfr': '\uD835\uDD0A',
        'gg': '\u226B',
        'Gg': '\u22D9',
        'ggg': '\u22D9',
        'gimel': 'ℷ',
        'gjcy': 'ѓ',
        'GJcy': 'Ѓ',
        'gl': '\u2277',
        'gla': '\u2AA5',
        'glE': '\u2A92',
        'glj': '\u2AA4',
        'gnap': '\u2A8A',
        'gnapprox': '\u2A8A',
        'gne': '\u2A88',
        'gnE': '\u2269',
        'gneq': '\u2A88',
        'gneqq': '\u2269',
        'gnsim': '\u22E7',
        'gopf': '\uD835\uDD58',
        'Gopf': '\uD835\uDD3E',
        'grave': '`',
        'GreaterEqual': '\u2265',
        'GreaterEqualLess': '\u22DB',
        'GreaterFullEqual': '\u2267',
        'GreaterGreater': '\u2AA2',
        'GreaterLess': '\u2277',
        'GreaterSlantEqual': '\u2A7E',
        'GreaterTilde': '\u2273',
        'gscr': 'ℊ',
        'Gscr': '\uD835\uDCA2',
        'gsim': '\u2273',
        'gsime': '\u2A8E',
        'gsiml': '\u2A90',
        'gt': '>',
        'Gt': '\u226B',
        'GT': '>',
        'gtcc': '\u2AA7',
        'gtcir': '\u2A7A',
        'gtdot': '\u22D7',
        'gtlPar': '\u2995',
        'gtquest': '\u2A7C',
        'gtrapprox': '\u2A86',
        'gtrarr': '\u2978',
        'gtrdot': '\u22D7',
        'gtreqless': '\u22DB',
        'gtreqqless': '\u2A8C',
        'gtrless': '\u2277',
        'gtrsim': '\u2273',
        'gvertneqq': '\u2269︀',
        'gvnE': '\u2269︀',
        'Hacek': 'ˇ',
        'hairsp': '\u200A',
        'half': '\xBD',
        'hamilt': 'ℋ',
        'hardcy': 'ъ',
        'HARDcy': 'Ъ',
        'harr': '\u2194',
        'hArr': '\u21D4',
        'harrcir': '\u2948',
        'harrw': '\u21AD',
        'Hat': '^',
        'hbar': 'ℏ',
        'hcirc': 'ĥ',
        'Hcirc': 'Ĥ',
        'hearts': '\u2665',
        'heartsuit': '\u2665',
        'hellip': '\u2026',
        'hercon': '\u22B9',
        'hfr': '\uD835\uDD25',
        'Hfr': 'ℌ',
        'HilbertSpace': 'ℋ',
        'hksearow': '\u2925',
        'hkswarow': '\u2926',
        'hoarr': '\u21FF',
        'homtht': '\u223B',
        'hookleftarrow': '\u21A9',
        'hookrightarrow': '\u21AA',
        'hopf': '\uD835\uDD59',
        'Hopf': 'ℍ',
        'horbar': '\u2015',
        'HorizontalLine': '\u2500',
        'hscr': '\uD835\uDCBD',
        'Hscr': 'ℋ',
        'hslash': 'ℏ',
        'hstrok': 'ħ',
        'Hstrok': 'Ħ',
        'HumpDownHump': '\u224E',
        'HumpEqual': '\u224F',
        'hybull': '\u2043',
        'hyphen': '\u2010',
        'iacute': 'í',
        'Iacute': 'Í',
        'ic': '\u2063',
        'icirc': 'î',
        'Icirc': 'Î',
        'icy': 'и',
        'Icy': 'И',
        'Idot': 'İ',
        'iecy': 'е',
        'IEcy': 'Е',
        'iexcl': '\xA1',
        'iff': '\u21D4',
        'ifr': '\uD835\uDD26',
        'Ifr': 'ℑ',
        'igrave': 'ì',
        'Igrave': 'Ì',
        'ii': 'ⅈ',
        'iiiint': '\u2A0C',
        'iiint': '\u222D',
        'iinfin': '\u29DC',
        'iiota': '\u2129',
        'ijlig': 'ĳ',
        'IJlig': 'Ĳ',
        'Im': 'ℑ',
        'imacr': 'ī',
        'Imacr': 'Ī',
        'image': 'ℑ',
        'ImaginaryI': 'ⅈ',
        'imagline': 'ℐ',
        'imagpart': 'ℑ',
        'imath': 'ı',
        'imof': '\u22B7',
        'imped': 'Ƶ',
        'Implies': '\u21D2',
        'in': '\u2208',
        'incare': '\u2105',
        'infin': '\u221E',
        'infintie': '\u29DD',
        'inodot': 'ı',
        'int': '\u222B',
        'Int': '\u222C',
        'intcal': '\u22BA',
        'integers': 'ℤ',
        'Integral': '\u222B',
        'intercal': '\u22BA',
        'Intersection': '\u22C2',
        'intlarhk': '\u2A17',
        'intprod': '\u2A3C',
        'InvisibleComma': '\u2063',
        'InvisibleTimes': '\u2062',
        'iocy': 'ё',
        'IOcy': 'Ё',
        'iogon': 'į',
        'Iogon': 'Į',
        'iopf': '\uD835\uDD5A',
        'Iopf': '\uD835\uDD40',
        'iota': 'ι',
        'Iota': 'Ι',
        'iprod': '\u2A3C',
        'iquest': '\xBF',
        'iscr': '\uD835\uDCBE',
        'Iscr': 'ℐ',
        'isin': '\u2208',
        'isindot': '\u22F5',
        'isinE': '\u22F9',
        'isins': '\u22F4',
        'isinsv': '\u22F3',
        'isinv': '\u2208',
        'it': '\u2062',
        'itilde': 'ĩ',
        'Itilde': 'Ĩ',
        'iukcy': 'і',
        'Iukcy': 'І',
        'iuml': 'ï',
        'Iuml': 'Ï',
        'jcirc': 'ĵ',
        'Jcirc': 'Ĵ',
        'jcy': 'й',
        'Jcy': 'Й',
        'jfr': '\uD835\uDD27',
        'Jfr': '\uD835\uDD0D',
        'jmath': 'ȷ',
        'jopf': '\uD835\uDD5B',
        'Jopf': '\uD835\uDD41',
        'jscr': '\uD835\uDCBF',
        'Jscr': '\uD835\uDCA5',
        'jsercy': 'ј',
        'Jsercy': 'Ј',
        'jukcy': 'є',
        'Jukcy': 'Є',
        'kappa': 'κ',
        'Kappa': 'Κ',
        'kappav': 'ϰ',
        'kcedil': 'ķ',
        'Kcedil': 'Ķ',
        'kcy': 'к',
        'Kcy': 'К',
        'kfr': '\uD835\uDD28',
        'Kfr': '\uD835\uDD0E',
        'kgreen': 'ĸ',
        'khcy': 'х',
        'KHcy': 'Х',
        'kjcy': 'ќ',
        'KJcy': 'Ќ',
        'kopf': '\uD835\uDD5C',
        'Kopf': '\uD835\uDD42',
        'kscr': '\uD835\uDCC0',
        'Kscr': '\uD835\uDCA6',
        'lAarr': '\u21DA',
        'lacute': 'ĺ',
        'Lacute': 'Ĺ',
        'laemptyv': '\u29B4',
        'lagran': 'ℒ',
        'lambda': 'λ',
        'Lambda': 'Λ',
        'lang': '\u27E8',
        'Lang': '\u27EA',
        'langd': '\u2991',
        'langle': '\u27E8',
        'lap': '\u2A85',
        'Laplacetrf': 'ℒ',
        'laquo': '\xAB',
        'larr': '\u2190',
        'lArr': '\u21D0',
        'Larr': '\u219E',
        'larrb': '\u21E4',
        'larrbfs': '\u291F',
        'larrfs': '\u291D',
        'larrhk': '\u21A9',
        'larrlp': '\u21AB',
        'larrpl': '\u2939',
        'larrsim': '\u2973',
        'larrtl': '\u21A2',
        'lat': '\u2AAB',
        'latail': '\u2919',
        'lAtail': '\u291B',
        'late': '\u2AAD',
        'lates': '\u2AAD︀',
        'lbarr': '\u290C',
        'lBarr': '\u290E',
        'lbbrk': '\u2772',
        'lbrace': '{',
        'lbrack': '[',
        'lbrke': '\u298B',
        'lbrksld': '\u298F',
        'lbrkslu': '\u298D',
        'lcaron': 'ľ',
        'Lcaron': 'Ľ',
        'lcedil': 'ļ',
        'Lcedil': 'Ļ',
        'lceil': '\u2308',
        'lcub': '{',
        'lcy': 'л',
        'Lcy': 'Л',
        'ldca': '\u2936',
        'ldquo': '\u201C',
        'ldquor': '\u201E',
        'ldrdhar': '\u2967',
        'ldrushar': '\u294B',
        'ldsh': '\u21B2',
        'le': '\u2264',
        'lE': '\u2266',
        'LeftAngleBracket': '\u27E8',
        'leftarrow': '\u2190',
        'Leftarrow': '\u21D0',
        'LeftArrow': '\u2190',
        'LeftArrowBar': '\u21E4',
        'LeftArrowRightArrow': '\u21C6',
        'leftarrowtail': '\u21A2',
        'LeftCeiling': '\u2308',
        'LeftDoubleBracket': '\u27E6',
        'LeftDownTeeVector': '\u2961',
        'LeftDownVector': '\u21C3',
        'LeftDownVectorBar': '\u2959',
        'LeftFloor': '\u230A',
        'leftharpoondown': '\u21BD',
        'leftharpoonup': '\u21BC',
        'leftleftarrows': '\u21C7',
        'leftrightarrow': '\u2194',
        'Leftrightarrow': '\u21D4',
        'LeftRightArrow': '\u2194',
        'leftrightarrows': '\u21C6',
        'leftrightharpoons': '\u21CB',
        'leftrightsquigarrow': '\u21AD',
        'LeftRightVector': '\u294E',
        'LeftTee': '\u22A3',
        'LeftTeeArrow': '\u21A4',
        'LeftTeeVector': '\u295A',
        'leftthreetimes': '\u22CB',
        'LeftTriangle': '\u22B2',
        'LeftTriangleBar': '\u29CF',
        'LeftTriangleEqual': '\u22B4',
        'LeftUpDownVector': '\u2951',
        'LeftUpTeeVector': '\u2960',
        'LeftUpVector': '\u21BF',
        'LeftUpVectorBar': '\u2958',
        'LeftVector': '\u21BC',
        'LeftVectorBar': '\u2952',
        'leg': '\u22DA',
        'lEg': '\u2A8B',
        'leq': '\u2264',
        'leqq': '\u2266',
        'leqslant': '\u2A7D',
        'les': '\u2A7D',
        'lescc': '\u2AA8',
        'lesdot': '\u2A7F',
        'lesdoto': '\u2A81',
        'lesdotor': '\u2A83',
        'lesg': '\u22DA︀',
        'lesges': '\u2A93',
        'lessapprox': '\u2A85',
        'lessdot': '\u22D6',
        'lesseqgtr': '\u22DA',
        'lesseqqgtr': '\u2A8B',
        'LessEqualGreater': '\u22DA',
        'LessFullEqual': '\u2266',
        'LessGreater': '\u2276',
        'lessgtr': '\u2276',
        'LessLess': '\u2AA1',
        'lesssim': '\u2272',
        'LessSlantEqual': '\u2A7D',
        'LessTilde': '\u2272',
        'lfisht': '\u297C',
        'lfloor': '\u230A',
        'lfr': '\uD835\uDD29',
        'Lfr': '\uD835\uDD0F',
        'lg': '\u2276',
        'lgE': '\u2A91',
        'lHar': '\u2962',
        'lhard': '\u21BD',
        'lharu': '\u21BC',
        'lharul': '\u296A',
        'lhblk': '\u2584',
        'ljcy': 'љ',
        'LJcy': 'Љ',
        'll': '\u226A',
        'Ll': '\u22D8',
        'llarr': '\u21C7',
        'llcorner': '\u231E',
        'Lleftarrow': '\u21DA',
        'llhard': '\u296B',
        'lltri': '\u25FA',
        'lmidot': 'ŀ',
        'Lmidot': 'Ŀ',
        'lmoust': '\u23B0',
        'lmoustache': '\u23B0',
        'lnap': '\u2A89',
        'lnapprox': '\u2A89',
        'lne': '\u2A87',
        'lnE': '\u2268',
        'lneq': '\u2A87',
        'lneqq': '\u2268',
        'lnsim': '\u22E6',
        'loang': '\u27EC',
        'loarr': '\u21FD',
        'lobrk': '\u27E6',
        'longleftarrow': '\u27F5',
        'Longleftarrow': '\u27F8',
        'LongLeftArrow': '\u27F5',
        'longleftrightarrow': '\u27F7',
        'Longleftrightarrow': '\u27FA',
        'LongLeftRightArrow': '\u27F7',
        'longmapsto': '\u27FC',
        'longrightarrow': '\u27F6',
        'Longrightarrow': '\u27F9',
        'LongRightArrow': '\u27F6',
        'looparrowleft': '\u21AB',
        'looparrowright': '\u21AC',
        'lopar': '\u2985',
        'lopf': '\uD835\uDD5D',
        'Lopf': '\uD835\uDD43',
        'loplus': '\u2A2D',
        'lotimes': '\u2A34',
        'lowast': '\u2217',
        'lowbar': '_',
        'LowerLeftArrow': '\u2199',
        'LowerRightArrow': '\u2198',
        'loz': '\u25CA',
        'lozenge': '\u25CA',
        'lozf': '\u29EB',
        'lpar': '(',
        'lparlt': '\u2993',
        'lrarr': '\u21C6',
        'lrcorner': '\u231F',
        'lrhar': '\u21CB',
        'lrhard': '\u296D',
        'lrm': '\u200E',
        'lrtri': '\u22BF',
        'lsaquo': '\u2039',
        'lscr': '\uD835\uDCC1',
        'Lscr': 'ℒ',
        'lsh': '\u21B0',
        'Lsh': '\u21B0',
        'lsim': '\u2272',
        'lsime': '\u2A8D',
        'lsimg': '\u2A8F',
        'lsqb': '[',
        'lsquo': '\u2018',
        'lsquor': '\u201A',
        'lstrok': 'ł',
        'Lstrok': 'Ł',
        'lt': '<',
        'Lt': '\u226A',
        'LT': '<',
        'ltcc': '\u2AA6',
        'ltcir': '\u2A79',
        'ltdot': '\u22D6',
        'lthree': '\u22CB',
        'ltimes': '\u22C9',
        'ltlarr': '\u2976',
        'ltquest': '\u2A7B',
        'ltri': '\u25C3',
        'ltrie': '\u22B4',
        'ltrif': '\u25C2',
        'ltrPar': '\u2996',
        'lurdshar': '\u294A',
        'luruhar': '\u2966',
        'lvertneqq': '\u2268︀',
        'lvnE': '\u2268︀',
        'macr': '\xAF',
        'male': '\u2642',
        'malt': '\u2720',
        'maltese': '\u2720',
        'map': '\u21A6',
        'Map': '\u2905',
        'mapsto': '\u21A6',
        'mapstodown': '\u21A7',
        'mapstoleft': '\u21A4',
        'mapstoup': '\u21A5',
        'marker': '\u25AE',
        'mcomma': '\u2A29',
        'mcy': 'м',
        'Mcy': 'М',
        'mdash': '\u2014',
        'mDDot': '\u223A',
        'measuredangle': '\u2221',
        'MediumSpace': '\u205F',
        'Mellintrf': 'ℳ',
        'mfr': '\uD835\uDD2A',
        'Mfr': '\uD835\uDD10',
        'mho': '\u2127',
        'micro': 'µ',
        'mid': '\u2223',
        'midast': '*',
        'midcir': '\u2AF0',
        'middot': '\xB7',
        'minus': '\u2212',
        'minusb': '\u229F',
        'minusd': '\u2238',
        'minusdu': '\u2A2A',
        'MinusPlus': '\u2213',
        'mlcp': '\u2ADB',
        'mldr': '\u2026',
        'mnplus': '\u2213',
        'models': '\u22A7',
        'mopf': '\uD835\uDD5E',
        'Mopf': '\uD835\uDD44',
        'mp': '\u2213',
        'mscr': '\uD835\uDCC2',
        'Mscr': 'ℳ',
        'mstpos': '\u223E',
        'mu': 'μ',
        'Mu': 'Μ',
        'multimap': '\u22B8',
        'mumap': '\u22B8',
        'nabla': '\u2207',
        'nacute': 'ń',
        'Nacute': 'Ń',
        'nang': '\u2220⃒',
        'nap': '\u2249',
        'napE': '\u2A70̸',
        'napid': '\u224B̸',
        'napos': 'ŉ',
        'napprox': '\u2249',
        'natur': '\u266E',
        'natural': '\u266E',
        'naturals': 'ℕ',
        'nbsp': '\xA0',
        'nbump': '\u224E̸',
        'nbumpe': '\u224F̸',
        'ncap': '\u2A43',
        'ncaron': 'ň',
        'Ncaron': 'Ň',
        'ncedil': 'ņ',
        'Ncedil': 'Ņ',
        'ncong': '\u2247',
        'ncongdot': '\u2A6D̸',
        'ncup': '\u2A42',
        'ncy': 'н',
        'Ncy': 'Н',
        'ndash': '\u2013',
        'ne': '\u2260',
        'nearhk': '\u2924',
        'nearr': '\u2197',
        'neArr': '\u21D7',
        'nearrow': '\u2197',
        'nedot': '\u2250̸',
        'NegativeMediumSpace': '\u200B',
        'NegativeThickSpace': '\u200B',
        'NegativeThinSpace': '\u200B',
        'NegativeVeryThinSpace': '\u200B',
        'nequiv': '\u2262',
        'nesear': '\u2928',
        'nesim': '\u2242̸',
        'NestedGreaterGreater': '\u226B',
        'NestedLessLess': '\u226A',
        'NewLine': '\n',
        'nexist': '\u2204',
        'nexists': '\u2204',
        'nfr': '\uD835\uDD2B',
        'Nfr': '\uD835\uDD11',
        'nge': '\u2271',
        'ngE': '\u2267̸',
        'ngeq': '\u2271',
        'ngeqq': '\u2267̸',
        'ngeqslant': '\u2A7E̸',
        'nges': '\u2A7E̸',
        'nGg': '\u22D9̸',
        'ngsim': '\u2275',
        'ngt': '\u226F',
        'nGt': '\u226B⃒',
        'ngtr': '\u226F',
        'nGtv': '\u226B̸',
        'nharr': '\u21AE',
        'nhArr': '\u21CE',
        'nhpar': '\u2AF2',
        'ni': '\u220B',
        'nis': '\u22FC',
        'nisd': '\u22FA',
        'niv': '\u220B',
        'njcy': 'њ',
        'NJcy': 'Њ',
        'nlarr': '\u219A',
        'nlArr': '\u21CD',
        'nldr': '\u2025',
        'nle': '\u2270',
        'nlE': '\u2266̸',
        'nleftarrow': '\u219A',
        'nLeftarrow': '\u21CD',
        'nleftrightarrow': '\u21AE',
        'nLeftrightarrow': '\u21CE',
        'nleq': '\u2270',
        'nleqq': '\u2266̸',
        'nleqslant': '\u2A7D̸',
        'nles': '\u2A7D̸',
        'nless': '\u226E',
        'nLl': '\u22D8̸',
        'nlsim': '\u2274',
        'nlt': '\u226E',
        'nLt': '\u226A⃒',
        'nltri': '\u22EA',
        'nltrie': '\u22EC',
        'nLtv': '\u226A̸',
        'nmid': '\u2224',
        'NoBreak': '\u2060',
        'NonBreakingSpace': '\xA0',
        'nopf': '\uD835\uDD5F',
        'Nopf': 'ℕ',
        'not': '\xAC',
        'Not': '\u2AEC',
        'NotCongruent': '\u2262',
        'NotCupCap': '\u226D',
        'NotDoubleVerticalBar': '\u2226',
        'NotElement': '\u2209',
        'NotEqual': '\u2260',
        'NotEqualTilde': '\u2242̸',
        'NotExists': '\u2204',
        'NotGreater': '\u226F',
        'NotGreaterEqual': '\u2271',
        'NotGreaterFullEqual': '\u2267̸',
        'NotGreaterGreater': '\u226B̸',
        'NotGreaterLess': '\u2279',
        'NotGreaterSlantEqual': '\u2A7E̸',
        'NotGreaterTilde': '\u2275',
        'NotHumpDownHump': '\u224E̸',
        'NotHumpEqual': '\u224F̸',
        'notin': '\u2209',
        'notindot': '\u22F5̸',
        'notinE': '\u22F9̸',
        'notinva': '\u2209',
        'notinvb': '\u22F7',
        'notinvc': '\u22F6',
        'NotLeftTriangle': '\u22EA',
        'NotLeftTriangleBar': '\u29CF̸',
        'NotLeftTriangleEqual': '\u22EC',
        'NotLess': '\u226E',
        'NotLessEqual': '\u2270',
        'NotLessGreater': '\u2278',
        'NotLessLess': '\u226A̸',
        'NotLessSlantEqual': '\u2A7D̸',
        'NotLessTilde': '\u2274',
        'NotNestedGreaterGreater': '\u2AA2̸',
        'NotNestedLessLess': '\u2AA1̸',
        'notni': '\u220C',
        'notniva': '\u220C',
        'notnivb': '\u22FE',
        'notnivc': '\u22FD',
        'NotPrecedes': '\u2280',
        'NotPrecedesEqual': '\u2AAF̸',
        'NotPrecedesSlantEqual': '\u22E0',
        'NotReverseElement': '\u220C',
        'NotRightTriangle': '\u22EB',
        'NotRightTriangleBar': '\u29D0̸',
        'NotRightTriangleEqual': '\u22ED',
        'NotSquareSubset': '\u228F̸',
        'NotSquareSubsetEqual': '\u22E2',
        'NotSquareSuperset': '\u2290̸',
        'NotSquareSupersetEqual': '\u22E3',
        'NotSubset': '\u2282⃒',
        'NotSubsetEqual': '\u2288',
        'NotSucceeds': '\u2281',
        'NotSucceedsEqual': '\u2AB0̸',
        'NotSucceedsSlantEqual': '\u22E1',
        'NotSucceedsTilde': '\u227F̸',
        'NotSuperset': '\u2283⃒',
        'NotSupersetEqual': '\u2289',
        'NotTilde': '\u2241',
        'NotTildeEqual': '\u2244',
        'NotTildeFullEqual': '\u2247',
        'NotTildeTilde': '\u2249',
        'NotVerticalBar': '\u2224',
        'npar': '\u2226',
        'nparallel': '\u2226',
        'nparsl': '\u2AFD⃥',
        'npart': '\u2202̸',
        'npolint': '\u2A14',
        'npr': '\u2280',
        'nprcue': '\u22E0',
        'npre': '\u2AAF̸',
        'nprec': '\u2280',
        'npreceq': '\u2AAF̸',
        'nrarr': '\u219B',
        'nrArr': '\u21CF',
        'nrarrc': '\u2933̸',
        'nrarrw': '\u219D̸',
        'nrightarrow': '\u219B',
        'nRightarrow': '\u21CF',
        'nrtri': '\u22EB',
        'nrtrie': '\u22ED',
        'nsc': '\u2281',
        'nsccue': '\u22E1',
        'nsce': '\u2AB0̸',
        'nscr': '\uD835\uDCC3',
        'Nscr': '\uD835\uDCA9',
        'nshortmid': '\u2224',
        'nshortparallel': '\u2226',
        'nsim': '\u2241',
        'nsime': '\u2244',
        'nsimeq': '\u2244',
        'nsmid': '\u2224',
        'nspar': '\u2226',
        'nsqsube': '\u22E2',
        'nsqsupe': '\u22E3',
        'nsub': '\u2284',
        'nsube': '\u2288',
        'nsubE': '\u2AC5̸',
        'nsubset': '\u2282⃒',
        'nsubseteq': '\u2288',
        'nsubseteqq': '\u2AC5̸',
        'nsucc': '\u2281',
        'nsucceq': '\u2AB0̸',
        'nsup': '\u2285',
        'nsupe': '\u2289',
        'nsupE': '\u2AC6̸',
        'nsupset': '\u2283⃒',
        'nsupseteq': '\u2289',
        'nsupseteqq': '\u2AC6̸',
        'ntgl': '\u2279',
        'ntilde': 'ñ',
        'Ntilde': 'Ñ',
        'ntlg': '\u2278',
        'ntriangleleft': '\u22EA',
        'ntrianglelefteq': '\u22EC',
        'ntriangleright': '\u22EB',
        'ntrianglerighteq': '\u22ED',
        'nu': 'ν',
        'Nu': 'Ν',
        'num': '#',
        'numero': '\u2116',
        'numsp': '\u2007',
        'nvap': '\u224D⃒',
        'nvdash': '\u22AC',
        'nvDash': '\u22AD',
        'nVdash': '\u22AE',
        'nVDash': '\u22AF',
        'nvge': '\u2265⃒',
        'nvgt': '>⃒',
        'nvHarr': '\u2904',
        'nvinfin': '\u29DE',
        'nvlArr': '\u2902',
        'nvle': '\u2264⃒',
        'nvlt': '<⃒',
        'nvltrie': '\u22B4⃒',
        'nvrArr': '\u2903',
        'nvrtrie': '\u22B5⃒',
        'nvsim': '\u223C⃒',
        'nwarhk': '\u2923',
        'nwarr': '\u2196',
        'nwArr': '\u21D6',
        'nwarrow': '\u2196',
        'nwnear': '\u2927',
        'oacute': 'ó',
        'Oacute': 'Ó',
        'oast': '\u229B',
        'ocir': '\u229A',
        'ocirc': 'ô',
        'Ocirc': 'Ô',
        'ocy': 'о',
        'Ocy': 'О',
        'odash': '\u229D',
        'odblac': 'ő',
        'Odblac': 'Ő',
        'odiv': '\u2A38',
        'odot': '\u2299',
        'odsold': '\u29BC',
        'oelig': 'œ',
        'OElig': 'Œ',
        'ofcir': '\u29BF',
        'ofr': '\uD835\uDD2C',
        'Ofr': '\uD835\uDD12',
        'ogon': '\u02DB',
        'ograve': 'ò',
        'Ograve': 'Ò',
        'ogt': '\u29C1',
        'ohbar': '\u29B5',
        'ohm': 'Ω',
        'oint': '\u222E',
        'olarr': '\u21BA',
        'olcir': '\u29BE',
        'olcross': '\u29BB',
        'oline': '\u203E',
        'olt': '\u29C0',
        'omacr': 'ō',
        'Omacr': 'Ō',
        'omega': 'ω',
        'Omega': 'Ω',
        'omicron': 'ο',
        'Omicron': 'Ο',
        'omid': '\u29B6',
        'ominus': '\u2296',
        'oopf': '\uD835\uDD60',
        'Oopf': '\uD835\uDD46',
        'opar': '\u29B7',
        'OpenCurlyDoubleQuote': '\u201C',
        'OpenCurlyQuote': '\u2018',
        'operp': '\u29B9',
        'oplus': '\u2295',
        'or': '\u2228',
        'Or': '\u2A54',
        'orarr': '\u21BB',
        'ord': '\u2A5D',
        'order': 'ℴ',
        'orderof': 'ℴ',
        'ordf': 'ª',
        'ordm': 'º',
        'origof': '\u22B6',
        'oror': '\u2A56',
        'orslope': '\u2A57',
        'orv': '\u2A5B',
        'oS': '\u24C8',
        'oscr': 'ℴ',
        'Oscr': '\uD835\uDCAA',
        'oslash': 'ø',
        'Oslash': 'Ø',
        'osol': '\u2298',
        'otilde': 'õ',
        'Otilde': 'Õ',
        'otimes': '\u2297',
        'Otimes': '\u2A37',
        'otimesas': '\u2A36',
        'ouml': 'ö',
        'Ouml': 'Ö',
        'ovbar': '\u233D',
        'OverBar': '\u203E',
        'OverBrace': '\u23DE',
        'OverBracket': '\u23B4',
        'OverParenthesis': '\u23DC',
        'par': '\u2225',
        'para': '\xB6',
        'parallel': '\u2225',
        'parsim': '\u2AF3',
        'parsl': '\u2AFD',
        'part': '\u2202',
        'PartialD': '\u2202',
        'pcy': 'п',
        'Pcy': 'П',
        'percnt': '%',
        'period': '.',
        'permil': '\u2030',
        'perp': '\u22A5',
        'pertenk': '\u2031',
        'pfr': '\uD835\uDD2D',
        'Pfr': '\uD835\uDD13',
        'phi': 'φ',
        'Phi': 'Φ',
        'phiv': 'ϕ',
        'phmmat': 'ℳ',
        'phone': '\u260E',
        'pi': 'π',
        'Pi': 'Π',
        'pitchfork': '\u22D4',
        'piv': 'ϖ',
        'planck': 'ℏ',
        'planckh': 'ℎ',
        'plankv': 'ℏ',
        'plus': '+',
        'plusacir': '\u2A23',
        'plusb': '\u229E',
        'pluscir': '\u2A22',
        'plusdo': '\u2214',
        'plusdu': '\u2A25',
        'pluse': '\u2A72',
        'PlusMinus': '\xB1',
        'plusmn': '\xB1',
        'plussim': '\u2A26',
        'plustwo': '\u2A27',
        'pm': '\xB1',
        'Poincareplane': 'ℌ',
        'pointint': '\u2A15',
        'popf': '\uD835\uDD61',
        'Popf': 'ℙ',
        'pound': '\xA3',
        'pr': '\u227A',
        'Pr': '\u2ABB',
        'prap': '\u2AB7',
        'prcue': '\u227C',
        'pre': '\u2AAF',
        'prE': '\u2AB3',
        'prec': '\u227A',
        'precapprox': '\u2AB7',
        'preccurlyeq': '\u227C',
        'Precedes': '\u227A',
        'PrecedesEqual': '\u2AAF',
        'PrecedesSlantEqual': '\u227C',
        'PrecedesTilde': '\u227E',
        'preceq': '\u2AAF',
        'precnapprox': '\u2AB9',
        'precneqq': '\u2AB5',
        'precnsim': '\u22E8',
        'precsim': '\u227E',
        'prime': '\u2032',
        'Prime': '\u2033',
        'primes': 'ℙ',
        'prnap': '\u2AB9',
        'prnE': '\u2AB5',
        'prnsim': '\u22E8',
        'prod': '\u220F',
        'Product': '\u220F',
        'profalar': '\u232E',
        'profline': '\u2312',
        'profsurf': '\u2313',
        'prop': '\u221D',
        'Proportion': '\u2237',
        'Proportional': '\u221D',
        'propto': '\u221D',
        'prsim': '\u227E',
        'prurel': '\u22B0',
        'pscr': '\uD835\uDCC5',
        'Pscr': '\uD835\uDCAB',
        'psi': 'ψ',
        'Psi': 'Ψ',
        'puncsp': '\u2008',
        'qfr': '\uD835\uDD2E',
        'Qfr': '\uD835\uDD14',
        'qint': '\u2A0C',
        'qopf': '\uD835\uDD62',
        'Qopf': 'ℚ',
        'qprime': '\u2057',
        'qscr': '\uD835\uDCC6',
        'Qscr': '\uD835\uDCAC',
        'quaternions': 'ℍ',
        'quatint': '\u2A16',
        'quest': '?',
        'questeq': '\u225F',
        'quot': '"',
        'QUOT': '"',
        'rAarr': '\u21DB',
        'race': '\u223Ḏ',
        'racute': 'ŕ',
        'Racute': 'Ŕ',
        'radic': '\u221A',
        'raemptyv': '\u29B3',
        'rang': '\u27E9',
        'Rang': '\u27EB',
        'rangd': '\u2992',
        'range': '\u29A5',
        'rangle': '\u27E9',
        'raquo': '\xBB',
        'rarr': '\u2192',
        'rArr': '\u21D2',
        'Rarr': '\u21A0',
        'rarrap': '\u2975',
        'rarrb': '\u21E5',
        'rarrbfs': '\u2920',
        'rarrc': '\u2933',
        'rarrfs': '\u291E',
        'rarrhk': '\u21AA',
        'rarrlp': '\u21AC',
        'rarrpl': '\u2945',
        'rarrsim': '\u2974',
        'rarrtl': '\u21A3',
        'Rarrtl': '\u2916',
        'rarrw': '\u219D',
        'ratail': '\u291A',
        'rAtail': '\u291C',
        'ratio': '\u2236',
        'rationals': 'ℚ',
        'rbarr': '\u290D',
        'rBarr': '\u290F',
        'RBarr': '\u2910',
        'rbbrk': '\u2773',
        'rbrace': '}',
        'rbrack': ']',
        'rbrke': '\u298C',
        'rbrksld': '\u298E',
        'rbrkslu': '\u2990',
        'rcaron': 'ř',
        'Rcaron': 'Ř',
        'rcedil': 'ŗ',
        'Rcedil': 'Ŗ',
        'rceil': '\u2309',
        'rcub': '}',
        'rcy': 'р',
        'Rcy': 'Р',
        'rdca': '\u2937',
        'rdldhar': '\u2969',
        'rdquo': '\u201D',
        'rdquor': '\u201D',
        'rdsh': '\u21B3',
        'Re': 'ℜ',
        'real': 'ℜ',
        'realine': 'ℛ',
        'realpart': 'ℜ',
        'reals': 'ℝ',
        'rect': '\u25AD',
        'reg': '\xAE',
        'REG': '\xAE',
        'ReverseElement': '\u220B',
        'ReverseEquilibrium': '\u21CB',
        'ReverseUpEquilibrium': '\u296F',
        'rfisht': '\u297D',
        'rfloor': '\u230B',
        'rfr': '\uD835\uDD2F',
        'Rfr': 'ℜ',
        'rHar': '\u2964',
        'rhard': '\u21C1',
        'rharu': '\u21C0',
        'rharul': '\u296C',
        'rho': 'ρ',
        'Rho': 'Ρ',
        'rhov': 'ϱ',
        'RightAngleBracket': '\u27E9',
        'rightarrow': '\u2192',
        'Rightarrow': '\u21D2',
        'RightArrow': '\u2192',
        'RightArrowBar': '\u21E5',
        'RightArrowLeftArrow': '\u21C4',
        'rightarrowtail': '\u21A3',
        'RightCeiling': '\u2309',
        'RightDoubleBracket': '\u27E7',
        'RightDownTeeVector': '\u295D',
        'RightDownVector': '\u21C2',
        'RightDownVectorBar': '\u2955',
        'RightFloor': '\u230B',
        'rightharpoondown': '\u21C1',
        'rightharpoonup': '\u21C0',
        'rightleftarrows': '\u21C4',
        'rightleftharpoons': '\u21CC',
        'rightrightarrows': '\u21C9',
        'rightsquigarrow': '\u219D',
        'RightTee': '\u22A2',
        'RightTeeArrow': '\u21A6',
        'RightTeeVector': '\u295B',
        'rightthreetimes': '\u22CC',
        'RightTriangle': '\u22B3',
        'RightTriangleBar': '\u29D0',
        'RightTriangleEqual': '\u22B5',
        'RightUpDownVector': '\u294F',
        'RightUpTeeVector': '\u295C',
        'RightUpVector': '\u21BE',
        'RightUpVectorBar': '\u2954',
        'RightVector': '\u21C0',
        'RightVectorBar': '\u2953',
        'ring': '\u02DA',
        'risingdotseq': '\u2253',
        'rlarr': '\u21C4',
        'rlhar': '\u21CC',
        'rlm': '\u200F',
        'rmoust': '\u23B1',
        'rmoustache': '\u23B1',
        'rnmid': '\u2AEE',
        'roang': '\u27ED',
        'roarr': '\u21FE',
        'robrk': '\u27E7',
        'ropar': '\u2986',
        'ropf': '\uD835\uDD63',
        'Ropf': 'ℝ',
        'roplus': '\u2A2E',
        'rotimes': '\u2A35',
        'RoundImplies': '\u2970',
        'rpar': ')',
        'rpargt': '\u2994',
        'rppolint': '\u2A12',
        'rrarr': '\u21C9',
        'Rrightarrow': '\u21DB',
        'rsaquo': '\u203A',
        'rscr': '\uD835\uDCC7',
        'Rscr': 'ℛ',
        'rsh': '\u21B1',
        'Rsh': '\u21B1',
        'rsqb': ']',
        'rsquo': '\u2019',
        'rsquor': '\u2019',
        'rthree': '\u22CC',
        'rtimes': '\u22CA',
        'rtri': '\u25B9',
        'rtrie': '\u22B5',
        'rtrif': '\u25B8',
        'rtriltri': '\u29CE',
        'RuleDelayed': '\u29F4',
        'ruluhar': '\u2968',
        'rx': '\u211E',
        'sacute': 'ś',
        'Sacute': 'Ś',
        'sbquo': '\u201A',
        'sc': '\u227B',
        'Sc': '\u2ABC',
        'scap': '\u2AB8',
        'scaron': 'š',
        'Scaron': 'Š',
        'sccue': '\u227D',
        'sce': '\u2AB0',
        'scE': '\u2AB4',
        'scedil': 'ş',
        'Scedil': 'Ş',
        'scirc': 'ŝ',
        'Scirc': 'Ŝ',
        'scnap': '\u2ABA',
        'scnE': '\u2AB6',
        'scnsim': '\u22E9',
        'scpolint': '\u2A13',
        'scsim': '\u227F',
        'scy': 'с',
        'Scy': 'С',
        'sdot': '\u22C5',
        'sdotb': '\u22A1',
        'sdote': '\u2A66',
        'searhk': '\u2925',
        'searr': '\u2198',
        'seArr': '\u21D8',
        'searrow': '\u2198',
        'sect': '\xA7',
        'semi': ';',
        'seswar': '\u2929',
        'setminus': '\u2216',
        'setmn': '\u2216',
        'sext': '\u2736',
        'sfr': '\uD835\uDD30',
        'Sfr': '\uD835\uDD16',
        'sfrown': '\u2322',
        'sharp': '\u266F',
        'shchcy': 'щ',
        'SHCHcy': 'Щ',
        'shcy': 'ш',
        'SHcy': 'Ш',
        'ShortDownArrow': '\u2193',
        'ShortLeftArrow': '\u2190',
        'shortmid': '\u2223',
        'shortparallel': '\u2225',
        'ShortRightArrow': '\u2192',
        'ShortUpArrow': '\u2191',
        'shy': '\xAD',
        'sigma': 'σ',
        'Sigma': 'Σ',
        'sigmaf': 'ς',
        'sigmav': 'ς',
        'sim': '\u223C',
        'simdot': '\u2A6A',
        'sime': '\u2243',
        'simeq': '\u2243',
        'simg': '\u2A9E',
        'simgE': '\u2AA0',
        'siml': '\u2A9D',
        'simlE': '\u2A9F',
        'simne': '\u2246',
        'simplus': '\u2A24',
        'simrarr': '\u2972',
        'slarr': '\u2190',
        'SmallCircle': '\u2218',
        'smallsetminus': '\u2216',
        'smashp': '\u2A33',
        'smeparsl': '\u29E4',
        'smid': '\u2223',
        'smile': '\u2323',
        'smt': '\u2AAA',
        'smte': '\u2AAC',
        'smtes': '\u2AAC︀',
        'softcy': 'ь',
        'SOFTcy': 'Ь',
        'sol': '/',
        'solb': '\u29C4',
        'solbar': '\u233F',
        'sopf': '\uD835\uDD64',
        'Sopf': '\uD835\uDD4A',
        'spades': '\u2660',
        'spadesuit': '\u2660',
        'spar': '\u2225',
        'sqcap': '\u2293',
        'sqcaps': '\u2293︀',
        'sqcup': '\u2294',
        'sqcups': '\u2294︀',
        'Sqrt': '\u221A',
        'sqsub': '\u228F',
        'sqsube': '\u2291',
        'sqsubset': '\u228F',
        'sqsubseteq': '\u2291',
        'sqsup': '\u2290',
        'sqsupe': '\u2292',
        'sqsupset': '\u2290',
        'sqsupseteq': '\u2292',
        'squ': '\u25A1',
        'square': '\u25A1',
        'Square': '\u25A1',
        'SquareIntersection': '\u2293',
        'SquareSubset': '\u228F',
        'SquareSubsetEqual': '\u2291',
        'SquareSuperset': '\u2290',
        'SquareSupersetEqual': '\u2292',
        'SquareUnion': '\u2294',
        'squarf': '\u25AA',
        'squf': '\u25AA',
        'srarr': '\u2192',
        'sscr': '\uD835\uDCC8',
        'Sscr': '\uD835\uDCAE',
        'ssetmn': '\u2216',
        'ssmile': '\u2323',
        'sstarf': '\u22C6',
        'star': '\u2606',
        'Star': '\u22C6',
        'starf': '\u2605',
        'straightepsilon': 'ϵ',
        'straightphi': 'ϕ',
        'strns': '\xAF',
        'sub': '\u2282',
        'Sub': '\u22D0',
        'subdot': '\u2ABD',
        'sube': '\u2286',
        'subE': '\u2AC5',
        'subedot': '\u2AC3',
        'submult': '\u2AC1',
        'subne': '\u228A',
        'subnE': '\u2ACB',
        'subplus': '\u2ABF',
        'subrarr': '\u2979',
        'subset': '\u2282',
        'Subset': '\u22D0',
        'subseteq': '\u2286',
        'subseteqq': '\u2AC5',
        'SubsetEqual': '\u2286',
        'subsetneq': '\u228A',
        'subsetneqq': '\u2ACB',
        'subsim': '\u2AC7',
        'subsub': '\u2AD5',
        'subsup': '\u2AD3',
        'succ': '\u227B',
        'succapprox': '\u2AB8',
        'succcurlyeq': '\u227D',
        'Succeeds': '\u227B',
        'SucceedsEqual': '\u2AB0',
        'SucceedsSlantEqual': '\u227D',
        'SucceedsTilde': '\u227F',
        'succeq': '\u2AB0',
        'succnapprox': '\u2ABA',
        'succneqq': '\u2AB6',
        'succnsim': '\u22E9',
        'succsim': '\u227F',
        'SuchThat': '\u220B',
        'sum': '\u2211',
        'Sum': '\u2211',
        'sung': '\u266A',
        'sup': '\u2283',
        'Sup': '\u22D1',
        'sup1': '\xB9',
        'sup2': '\xB2',
        'sup3': '\xB3',
        'supdot': '\u2ABE',
        'supdsub': '\u2AD8',
        'supe': '\u2287',
        'supE': '\u2AC6',
        'supedot': '\u2AC4',
        'Superset': '\u2283',
        'SupersetEqual': '\u2287',
        'suphsol': '\u27C9',
        'suphsub': '\u2AD7',
        'suplarr': '\u297B',
        'supmult': '\u2AC2',
        'supne': '\u228B',
        'supnE': '\u2ACC',
        'supplus': '\u2AC0',
        'supset': '\u2283',
        'Supset': '\u22D1',
        'supseteq': '\u2287',
        'supseteqq': '\u2AC6',
        'supsetneq': '\u228B',
        'supsetneqq': '\u2ACC',
        'supsim': '\u2AC8',
        'supsub': '\u2AD4',
        'supsup': '\u2AD6',
        'swarhk': '\u2926',
        'swarr': '\u2199',
        'swArr': '\u21D9',
        'swarrow': '\u2199',
        'swnwar': '\u292A',
        'szlig': 'ß',
        'Tab': '\t',
        'target': '\u2316',
        'tau': 'τ',
        'Tau': 'Τ',
        'tbrk': '\u23B4',
        'tcaron': 'ť',
        'Tcaron': 'Ť',
        'tcedil': 'ţ',
        'Tcedil': 'Ţ',
        'tcy': 'т',
        'Tcy': 'Т',
        'tdot': '⃛',
        'telrec': '\u2315',
        'tfr': '\uD835\uDD31',
        'Tfr': '\uD835\uDD17',
        'there4': '\u2234',
        'therefore': '\u2234',
        'Therefore': '\u2234',
        'theta': 'θ',
        'Theta': 'Θ',
        'thetasym': 'ϑ',
        'thetav': 'ϑ',
        'thickapprox': '\u2248',
        'thicksim': '\u223C',
        'ThickSpace': '\u205F\u200A',
        'thinsp': '\u2009',
        'ThinSpace': '\u2009',
        'thkap': '\u2248',
        'thksim': '\u223C',
        'thorn': 'þ',
        'THORN': 'Þ',
        'tilde': '\u02DC',
        'Tilde': '\u223C',
        'TildeEqual': '\u2243',
        'TildeFullEqual': '\u2245',
        'TildeTilde': '\u2248',
        'times': '\xD7',
        'timesb': '\u22A0',
        'timesbar': '\u2A31',
        'timesd': '\u2A30',
        'tint': '\u222D',
        'toea': '\u2928',
        'top': '\u22A4',
        'topbot': '\u2336',
        'topcir': '\u2AF1',
        'topf': '\uD835\uDD65',
        'Topf': '\uD835\uDD4B',
        'topfork': '\u2ADA',
        'tosa': '\u2929',
        'tprime': '\u2034',
        'trade': '\u2122',
        'TRADE': '\u2122',
        'triangle': '\u25B5',
        'triangledown': '\u25BF',
        'triangleleft': '\u25C3',
        'trianglelefteq': '\u22B4',
        'triangleq': '\u225C',
        'triangleright': '\u25B9',
        'trianglerighteq': '\u22B5',
        'tridot': '\u25EC',
        'trie': '\u225C',
        'triminus': '\u2A3A',
        'TripleDot': '⃛',
        'triplus': '\u2A39',
        'trisb': '\u29CD',
        'tritime': '\u2A3B',
        'trpezium': '\u23E2',
        'tscr': '\uD835\uDCC9',
        'Tscr': '\uD835\uDCAF',
        'tscy': 'ц',
        'TScy': 'Ц',
        'tshcy': 'ћ',
        'TSHcy': 'Ћ',
        'tstrok': 'ŧ',
        'Tstrok': 'Ŧ',
        'twixt': '\u226C',
        'twoheadleftarrow': '\u219E',
        'twoheadrightarrow': '\u21A0',
        'uacute': 'ú',
        'Uacute': 'Ú',
        'uarr': '\u2191',
        'uArr': '\u21D1',
        'Uarr': '\u219F',
        'Uarrocir': '\u2949',
        'ubrcy': 'ў',
        'Ubrcy': 'Ў',
        'ubreve': 'ŭ',
        'Ubreve': 'Ŭ',
        'ucirc': 'û',
        'Ucirc': 'Û',
        'ucy': 'у',
        'Ucy': 'У',
        'udarr': '\u21C5',
        'udblac': 'ű',
        'Udblac': 'Ű',
        'udhar': '\u296E',
        'ufisht': '\u297E',
        'ufr': '\uD835\uDD32',
        'Ufr': '\uD835\uDD18',
        'ugrave': 'ù',
        'Ugrave': 'Ù',
        'uHar': '\u2963',
        'uharl': '\u21BF',
        'uharr': '\u21BE',
        'uhblk': '\u2580',
        'ulcorn': '\u231C',
        'ulcorner': '\u231C',
        'ulcrop': '\u230F',
        'ultri': '\u25F8',
        'umacr': 'ū',
        'Umacr': 'Ū',
        'uml': '\xA8',
        'UnderBar': '_',
        'UnderBrace': '\u23DF',
        'UnderBracket': '\u23B5',
        'UnderParenthesis': '\u23DD',
        'Union': '\u22C3',
        'UnionPlus': '\u228E',
        'uogon': 'ų',
        'Uogon': 'Ų',
        'uopf': '\uD835\uDD66',
        'Uopf': '\uD835\uDD4C',
        'uparrow': '\u2191',
        'Uparrow': '\u21D1',
        'UpArrow': '\u2191',
        'UpArrowBar': '\u2912',
        'UpArrowDownArrow': '\u21C5',
        'updownarrow': '\u2195',
        'Updownarrow': '\u21D5',
        'UpDownArrow': '\u2195',
        'UpEquilibrium': '\u296E',
        'upharpoonleft': '\u21BF',
        'upharpoonright': '\u21BE',
        'uplus': '\u228E',
        'UpperLeftArrow': '\u2196',
        'UpperRightArrow': '\u2197',
        'upsi': 'υ',
        'Upsi': 'ϒ',
        'upsih': 'ϒ',
        'upsilon': 'υ',
        'Upsilon': 'Υ',
        'UpTee': '\u22A5',
        'UpTeeArrow': '\u21A5',
        'upuparrows': '\u21C8',
        'urcorn': '\u231D',
        'urcorner': '\u231D',
        'urcrop': '\u230E',
        'uring': 'ů',
        'Uring': 'Ů',
        'urtri': '\u25F9',
        'uscr': '\uD835\uDCCA',
        'Uscr': '\uD835\uDCB0',
        'utdot': '\u22F0',
        'utilde': 'ũ',
        'Utilde': 'Ũ',
        'utri': '\u25B5',
        'utrif': '\u25B4',
        'uuarr': '\u21C8',
        'uuml': 'ü',
        'Uuml': 'Ü',
        'uwangle': '\u29A7',
        'vangrt': '\u299C',
        'varepsilon': 'ϵ',
        'varkappa': 'ϰ',
        'varnothing': '\u2205',
        'varphi': 'ϕ',
        'varpi': 'ϖ',
        'varpropto': '\u221D',
        'varr': '\u2195',
        'vArr': '\u21D5',
        'varrho': 'ϱ',
        'varsigma': 'ς',
        'varsubsetneq': '\u228A︀',
        'varsubsetneqq': '\u2ACB︀',
        'varsupsetneq': '\u228B︀',
        'varsupsetneqq': '\u2ACC︀',
        'vartheta': 'ϑ',
        'vartriangleleft': '\u22B2',
        'vartriangleright': '\u22B3',
        'vBar': '\u2AE8',
        'Vbar': '\u2AEB',
        'vBarv': '\u2AE9',
        'vcy': 'в',
        'Vcy': 'В',
        'vdash': '\u22A2',
        'vDash': '\u22A8',
        'Vdash': '\u22A9',
        'VDash': '\u22AB',
        'Vdashl': '\u2AE6',
        'vee': '\u2228',
        'Vee': '\u22C1',
        'veebar': '\u22BB',
        'veeeq': '\u225A',
        'vellip': '\u22EE',
        'verbar': '|',
        'Verbar': '\u2016',
        'vert': '|',
        'Vert': '\u2016',
        'VerticalBar': '\u2223',
        'VerticalLine': '|',
        'VerticalSeparator': '\u2758',
        'VerticalTilde': '\u2240',
        'VeryThinSpace': '\u200A',
        'vfr': '\uD835\uDD33',
        'Vfr': '\uD835\uDD19',
        'vltri': '\u22B2',
        'vnsub': '\u2282⃒',
        'vnsup': '\u2283⃒',
        'vopf': '\uD835\uDD67',
        'Vopf': '\uD835\uDD4D',
        'vprop': '\u221D',
        'vrtri': '\u22B3',
        'vscr': '\uD835\uDCCB',
        'Vscr': '\uD835\uDCB1',
        'vsubne': '\u228A︀',
        'vsubnE': '\u2ACB︀',
        'vsupne': '\u228B︀',
        'vsupnE': '\u2ACC︀',
        'Vvdash': '\u22AA',
        'vzigzag': '\u299A',
        'wcirc': 'ŵ',
        'Wcirc': 'Ŵ',
        'wedbar': '\u2A5F',
        'wedge': '\u2227',
        'Wedge': '\u22C0',
        'wedgeq': '\u2259',
        'weierp': '\u2118',
        'wfr': '\uD835\uDD34',
        'Wfr': '\uD835\uDD1A',
        'wopf': '\uD835\uDD68',
        'Wopf': '\uD835\uDD4E',
        'wp': '\u2118',
        'wr': '\u2240',
        'wreath': '\u2240',
        'wscr': '\uD835\uDCCC',
        'Wscr': '\uD835\uDCB2',
        'xcap': '\u22C2',
        'xcirc': '\u25EF',
        'xcup': '\u22C3',
        'xdtri': '\u25BD',
        'xfr': '\uD835\uDD35',
        'Xfr': '\uD835\uDD1B',
        'xharr': '\u27F7',
        'xhArr': '\u27FA',
        'xi': 'ξ',
        'Xi': 'Ξ',
        'xlarr': '\u27F5',
        'xlArr': '\u27F8',
        'xmap': '\u27FC',
        'xnis': '\u22FB',
        'xodot': '\u2A00',
        'xopf': '\uD835\uDD69',
        'Xopf': '\uD835\uDD4F',
        'xoplus': '\u2A01',
        'xotime': '\u2A02',
        'xrarr': '\u27F6',
        'xrArr': '\u27F9',
        'xscr': '\uD835\uDCCD',
        'Xscr': '\uD835\uDCB3',
        'xsqcup': '\u2A06',
        'xuplus': '\u2A04',
        'xutri': '\u25B3',
        'xvee': '\u22C1',
        'xwedge': '\u22C0',
        'yacute': 'ý',
        'Yacute': 'Ý',
        'yacy': 'я',
        'YAcy': 'Я',
        'ycirc': 'ŷ',
        'Ycirc': 'Ŷ',
        'ycy': 'ы',
        'Ycy': 'Ы',
        'yen': '\xA5',
        'yfr': '\uD835\uDD36',
        'Yfr': '\uD835\uDD1C',
        'yicy': 'ї',
        'YIcy': 'Ї',
        'yopf': '\uD835\uDD6A',
        'Yopf': '\uD835\uDD50',
        'yscr': '\uD835\uDCCE',
        'Yscr': '\uD835\uDCB4',
        'yucy': 'ю',
        'YUcy': 'Ю',
        'yuml': 'ÿ',
        'Yuml': 'Ÿ',
        'zacute': 'ź',
        'Zacute': 'Ź',
        'zcaron': 'ž',
        'Zcaron': 'Ž',
        'zcy': 'з',
        'Zcy': 'З',
        'zdot': 'ż',
        'Zdot': 'Ż',
        'zeetrf': 'ℨ',
        'ZeroWidthSpace': '\u200B',
        'zeta': 'ζ',
        'Zeta': 'Ζ',
        'zfr': '\uD835\uDD37',
        'Zfr': 'ℨ',
        'zhcy': 'ж',
        'ZHcy': 'Ж',
        'zigrarr': '\u21DD',
        'zopf': '\uD835\uDD6B',
        'Zopf': 'ℤ',
        'zscr': '\uD835\uDCCF',
        'Zscr': '\uD835\uDCB5',
        'zwj': '‍',
        'zwnj': '‌'
    };
    var decodeMapLegacy = {
        'aacute': 'á',
        'Aacute': 'Á',
        'acirc': 'â',
        'Acirc': 'Â',
        'acute': '\xB4',
        'aelig': 'æ',
        'AElig': 'Æ',
        'agrave': 'à',
        'Agrave': 'À',
        'amp': '&',
        'AMP': '&',
        'aring': 'å',
        'Aring': 'Å',
        'atilde': 'ã',
        'Atilde': 'Ã',
        'auml': 'ä',
        'Auml': 'Ä',
        'brvbar': '\xA6',
        'ccedil': 'ç',
        'Ccedil': 'Ç',
        'cedil': '\xB8',
        'cent': '\xA2',
        'copy': '\xA9',
        'COPY': '\xA9',
        'curren': '\xA4',
        'deg': '\xB0',
        'divide': '\xF7',
        'eacute': 'é',
        'Eacute': 'É',
        'ecirc': 'ê',
        'Ecirc': 'Ê',
        'egrave': 'è',
        'Egrave': 'È',
        'eth': 'ð',
        'ETH': 'Ð',
        'euml': 'ë',
        'Euml': 'Ë',
        'frac12': '\xBD',
        'frac14': '\xBC',
        'frac34': '\xBE',
        'gt': '>',
        'GT': '>',
        'iacute': 'í',
        'Iacute': 'Í',
        'icirc': 'î',
        'Icirc': 'Î',
        'iexcl': '\xA1',
        'igrave': 'ì',
        'Igrave': 'Ì',
        'iquest': '\xBF',
        'iuml': 'ï',
        'Iuml': 'Ï',
        'laquo': '\xAB',
        'lt': '<',
        'LT': '<',
        'macr': '\xAF',
        'micro': 'µ',
        'middot': '\xB7',
        'nbsp': '\xA0',
        'not': '\xAC',
        'ntilde': 'ñ',
        'Ntilde': 'Ñ',
        'oacute': 'ó',
        'Oacute': 'Ó',
        'ocirc': 'ô',
        'Ocirc': 'Ô',
        'ograve': 'ò',
        'Ograve': 'Ò',
        'ordf': 'ª',
        'ordm': 'º',
        'oslash': 'ø',
        'Oslash': 'Ø',
        'otilde': 'õ',
        'Otilde': 'Õ',
        'ouml': 'ö',
        'Ouml': 'Ö',
        'para': '\xB6',
        'plusmn': '\xB1',
        'pound': '\xA3',
        'quot': '"',
        'QUOT': '"',
        'raquo': '\xBB',
        'reg': '\xAE',
        'REG': '\xAE',
        'sect': '\xA7',
        'shy': '\xAD',
        'sup1': '\xB9',
        'sup2': '\xB2',
        'sup3': '\xB3',
        'szlig': 'ß',
        'thorn': 'þ',
        'THORN': 'Þ',
        'times': '\xD7',
        'uacute': 'ú',
        'Uacute': 'Ú',
        'ucirc': 'û',
        'Ucirc': 'Û',
        'ugrave': 'ù',
        'Ugrave': 'Ù',
        'uml': '\xA8',
        'uuml': 'ü',
        'Uuml': 'Ü',
        'yacute': 'ý',
        'Yacute': 'Ý',
        'yen': '\xA5',
        'yuml': 'ÿ'
    };
    var decodeMapNumeric = {
        '0': '\uFFFD',
        '128': '\u20AC',
        '130': '\u201A',
        '131': 'ƒ',
        '132': '\u201E',
        '133': '\u2026',
        '134': '\u2020',
        '135': '\u2021',
        '136': 'ˆ',
        '137': '\u2030',
        '138': 'Š',
        '139': '\u2039',
        '140': 'Œ',
        '142': 'Ž',
        '145': '\u2018',
        '146': '\u2019',
        '147': '\u201C',
        '148': '\u201D',
        '149': '\u2022',
        '150': '\u2013',
        '151': '\u2014',
        '152': '\u02DC',
        '153': '\u2122',
        '154': 'š',
        '155': '\u203A',
        '156': 'œ',
        '158': 'ž',
        '159': 'Ÿ'
    };
    var invalidReferenceCodePoints = [
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        11,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        27,
        28,
        29,
        30,
        31,
        127,
        128,
        129,
        130,
        131,
        132,
        133,
        134,
        135,
        136,
        137,
        138,
        139,
        140,
        141,
        142,
        143,
        144,
        145,
        146,
        147,
        148,
        149,
        150,
        151,
        152,
        153,
        154,
        155,
        156,
        157,
        158,
        159,
        64976,
        64977,
        64978,
        64979,
        64980,
        64981,
        64982,
        64983,
        64984,
        64985,
        64986,
        64987,
        64988,
        64989,
        64990,
        64991,
        64992,
        64993,
        64994,
        64995,
        64996,
        64997,
        64998,
        64999,
        65000,
        65001,
        65002,
        65003,
        65004,
        65005,
        65006,
        65007,
        65534,
        65535,
        131070,
        131071,
        196606,
        196607,
        262142,
        262143,
        327678,
        327679,
        393214,
        393215,
        458750,
        458751,
        524286,
        524287,
        589822,
        589823,
        655358,
        655359,
        720894,
        720895,
        786430,
        786431,
        851966,
        851967,
        917502,
        917503,
        983038,
        983039,
        1048574,
        1048575,
        1114110,
        1114111
    ];
    var stringFromCharCode = String.fromCharCode;
    var object = {};
    var hasOwnProperty = object.hasOwnProperty;
    var has = function (object, propertyName) {
        return hasOwnProperty.call(object, propertyName);
    };
    var contains = function (array, value) {
        var index = -1;
        var length = array.length;
        while (++index < length) {
            if (array[index] == value) {
                return true;
            }
        }
        return false;
    };
    var merge = function (options, defaults) {
        if (!options) {
            return defaults;
        }
        var result = {};
        var key;
        for (key in defaults) {
            result[key] = has(options, key) ? options[key] : defaults[key];
        }
        return result;
    };
    var codePointToSymbol = function (codePoint, strict) {
        var output = '';
        if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
            if (strict) {
                parseError('character reference outside the permissible Unicode range');
            }
            return '\uFFFD';
        }
        if (has(decodeMapNumeric, codePoint)) {
            if (strict) {
                parseError('disallowed character reference');
            }
            return decodeMapNumeric[codePoint];
        }
        if (strict && contains(invalidReferenceCodePoints, codePoint)) {
            parseError('disallowed character reference');
        }
        if (codePoint > 65535) {
            codePoint -= 65536;
            output += stringFromCharCode(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
        }
        output += stringFromCharCode(codePoint);
        return output;
    };
    var hexEscape = function (codePoint) {
        return '&#x' + codePoint.toString(16).toUpperCase() + ';';
    };
    var decEscape = function (codePoint) {
        return '&#' + codePoint + ';';
    };
    var parseError = function (message) {
        throw Error('Parse error: ' + message);
    };
    var encode = function (string, options) {
        options = merge(options, encode.options);
        var strict = options.strict;
        if (strict && regexInvalidRawCodePoint.test(string)) {
            parseError('forbidden code point');
        }
        var encodeEverything = options.encodeEverything;
        var useNamedReferences = options.useNamedReferences;
        var allowUnsafeSymbols = options.allowUnsafeSymbols;
        var escapeCodePoint = options.decimal ? decEscape : hexEscape;
        var escapeBmpSymbol = function (symbol) {
            return escapeCodePoint(symbol.charCodeAt(0));
        };
        if (encodeEverything) {
            string = string.replace(regexAsciiWhitelist, function (symbol) {
                if (useNamedReferences && has(encodeMap, symbol)) {
                    return '&' + encodeMap[symbol] + ';';
                }
                return escapeBmpSymbol(symbol);
            });
            if (useNamedReferences) {
                string = string.replace(/&gt;\u20D2/g, '&nvgt;').replace(/&lt;\u20D2/g, '&nvlt;').replace(/&#x66;&#x6A;/g, '&fjlig;');
            }
            if (useNamedReferences) {
                string = string.replace(regexEncodeNonAscii, function (string) {
                    return '&' + encodeMap[string] + ';';
                });
            }
        } else if (useNamedReferences) {
            if (!allowUnsafeSymbols) {
                string = string.replace(regexEscape, function (string) {
                    return '&' + encodeMap[string] + ';';
                });
            }
            string = string.replace(/&gt;\u20D2/g, '&nvgt;').replace(/&lt;\u20D2/g, '&nvlt;');
            string = string.replace(regexEncodeNonAscii, function (string) {
                return '&' + encodeMap[string] + ';';
            });
        } else if (!allowUnsafeSymbols) {
            string = string.replace(regexEscape, escapeBmpSymbol);
        }
        return string.replace(regexAstralSymbols, function ($0) {
            var high = $0.charCodeAt(0);
            var low = $0.charCodeAt(1);
            var codePoint = (high - 55296) * 1024 + low - 56320 + 65536;
            return escapeCodePoint(codePoint);
        }).replace(regexBmpWhitelist, escapeBmpSymbol);
    };
    encode.options = {
        'allowUnsafeSymbols': false,
        'encodeEverything': false,
        'strict': false,
        'useNamedReferences': false,
        'decimal': false
    };
    var decode = function (html, options) {
        options = merge(options, decode.options);
        var strict = options.strict;
        if (strict && regexInvalidEntity.test(html)) {
            parseError('malformed character reference');
        }
        return html.replace(regexDecode, function ($0, $1, $2, $3, $4, $5, $6, $7) {
            var codePoint;
            var semicolon;
            var decDigits;
            var hexDigits;
            var reference;
            var next;
            if ($1) {
                decDigits = $1;
                semicolon = $2;
                if (strict && !semicolon) {
                    parseError('character reference was not terminated by a semicolon');
                }
                codePoint = parseInt(decDigits, 10);
                return codePointToSymbol(codePoint, strict);
            }
            if ($3) {
                hexDigits = $3;
                semicolon = $4;
                if (strict && !semicolon) {
                    parseError('character reference was not terminated by a semicolon');
                }
                codePoint = parseInt(hexDigits, 16);
                return codePointToSymbol(codePoint, strict);
            }
            if ($5) {
                reference = $5;
                if (has(decodeMap, reference)) {
                    return decodeMap[reference];
                } else {
                    if (strict) {
                        parseError('named character reference was not terminated by a semicolon');
                    }
                    return $0;
                }
            }
            reference = $6;
            next = $7;
            if (next && options.isAttributeValue) {
                if (strict && next == '=') {
                    parseError('`&` did not start a character reference');
                }
                return $0;
            } else {
                if (strict) {
                    parseError('named character reference was not terminated by a semicolon');
                }
                return decodeMapLegacy[reference] + (next || '');
            }
        });
    };
    decode.options = {
        'isAttributeValue': false,
        'strict': false
    };
    var escape = function (string) {
        return string.replace(regexEscape, function ($0) {
            return escapeMap[$0];
        });
    };
    var he = {
        'version': '1.1.1',
        'encode': encode,
        'decode': decode,
        'escape': escape,
        'unescape': decode
    };
    if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
        define('he@1.1.1#he', function () {
            return he;
        });
    } else if (freeExports && !freeExports.nodeType) {
        if (freeModule) {
            freeModule.exports = he;
        } else {
            for (var key in he) {
                has(he, key) && (freeExports[key] = he[key]);
            }
        }
    } else {
        root.he = he;
    }
}(this));
/*can-simple-dom@1.0.10#simple-dom/html-parser*/
define('can-simple-dom@1.0.10#simple-dom/html-parser', [
    'exports',
    'he'
], function (exports, _he) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    var _he2 = _interopRequireDefault(_he);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    function HTMLParser(tokenize, document, voidMap) {
        this.tokenize = tokenize;
        this.document = document;
        this.voidMap = voidMap;
        this.parentStack = [];
    }
    HTMLParser.prototype.isVoid = function (element) {
        return this.voidMap[element.nodeName] === true;
    };
    HTMLParser.prototype.pushElement = function (token) {
        var el = this.document.createElement(token.tagName);
        for (var i = 0; i < token.attributes.length; i++) {
            var attr = token.attributes[i];
            if (attr[0] !== 'href' && attr[0] !== 'src') {
                attr[1] = _he2.default.encode(attr[1]);
            }
            el.setAttribute(attr[0], attr[1]);
        }
        if (this.isVoid(el) || token.selfClosing) {
            return this.appendChild(el);
        }
        this.parentStack.push(el);
    };
    HTMLParser.prototype.popElement = function (token) {
        var el = this.parentStack.pop();
        if (el.nodeName !== token.tagName.toUpperCase()) {
            throw new Error('unbalanced tag');
        }
        this.appendChild(el);
    };
    HTMLParser.prototype.appendText = function (token) {
        var text = this.document.createTextNode(token.chars);
        this.appendChild(text);
    };
    HTMLParser.prototype.appendComment = function (token) {
        var comment = this.document.createComment(token.chars);
        this.appendChild(comment);
    };
    HTMLParser.prototype.appendChild = function (node) {
        var parentNode = this.parentStack[this.parentStack.length - 1];
        parentNode.appendChild(node);
    };
    HTMLParser.prototype.parse = function (html) {
        var fragment = this.document.createDocumentFragment();
        this.parentStack.push(fragment);
        var tokens = this.tokenize(html);
        for (var i = 0, l = tokens.length; i < l; i++) {
            var token = tokens[i];
            switch (token.type) {
            case 'StartTag':
                this.pushElement(token);
                break;
            case 'EndTag':
                this.popElement(token);
                break;
            case 'Chars':
                this.appendText(token);
                break;
            case 'Comment':
                this.appendComment(token);
                break;
            }
        }
        return this.parentStack.pop();
    };
    exports.default = HTMLParser;
});
/*can-simple-dom@1.0.10#simple-dom/html-serializer*/
define('can-simple-dom@1.0.10#simple-dom/html-serializer', ['exports'], function (exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    var REG_ESCAPE_ALL = /[<>&]/g;
    var REG_ESCAPE_PRESERVE_ENTITIES = /[<>]|&(?:#?[a-zA-Z0-9]+;)?/g;
    function HTMLSerializer(voidMap) {
        this.voidMap = voidMap;
    }
    HTMLSerializer.prototype.openTag = function (element) {
        return '<' + element.nodeName.toLowerCase() + this.attributes(element.attributes) + '>';
    };
    HTMLSerializer.prototype.closeTag = function (element) {
        return '</' + element.nodeName.toLowerCase() + '>';
    };
    HTMLSerializer.prototype.isVoid = function (element) {
        return this.voidMap[element.nodeName] === true;
    };
    HTMLSerializer.prototype.attributes = function (namedNodeMap) {
        var buffer = '';
        for (var i = 0, l = namedNodeMap.length; i < l; i++) {
            buffer += this.attr(namedNodeMap[i]);
        }
        return buffer;
    };
    HTMLSerializer.prototype.escapeAttrValue = function (attrValue) {
        return attrValue.replace(/"|&(?:#?[a-zA-Z0-9]+;)?/g, function (match) {
            switch (match) {
            case '&':
                return '&amp;';
            case '"':
                return '&quot;';
            default:
                return match;
            }
        });
    };
    HTMLSerializer.prototype.attr = function (attr) {
        if (!attr.specified) {
            return '';
        }
        if (attr.value) {
            if (attr.name === 'href' || attr.name === 'src') {
                return ' ' + attr.name + '="' + attr.value + '"';
            }
            return ' ' + attr.name + '="' + this.escapeAttrValue(attr.value) + '"';
        }
        return ' ' + attr.name;
    };
    HTMLSerializer.prototype.escapeText = function (textNodeValue, escapeAll) {
        return textNodeValue.replace(escapeAll ? REG_ESCAPE_ALL : REG_ESCAPE_PRESERVE_ENTITIES, function (match) {
            switch (match) {
            case '&':
                return '&amp;';
            case '<':
                return '&lt;';
            case '>':
                return '&gt;';
            default:
                return match;
            }
        });
    };
    var metadataContentTags = {
        style: true,
        script: true,
        template: true
    };
    function isMetadataTag(elem) {
        return !!elem && metadataContentTags[elem.nodeName.toLowerCase()];
    }
    HTMLSerializer.prototype.text = function (text) {
        if (isMetadataTag(text.parentNode)) {
            return text.nodeValue;
        }
        return this.escapeText(text.nodeValue);
    };
    HTMLSerializer.prototype.comment = function (comment) {
        return '<!--' + comment.nodeValue + '-->';
    };
    HTMLSerializer.prototype.serialize = function (node) {
        var buffer = '';
        var next;
        switch (node.nodeType) {
        case 1:
            buffer += this.openTag(node);
            break;
        case 3:
            buffer += this.text(node);
            break;
        case 8:
            buffer += this.comment(node);
            break;
        default:
            break;
        }
        next = node.firstChild;
        if (next) {
            while (next) {
                buffer += this.serialize(next);
                next = next.nextSibling;
            }
        } else if (node.nodeType === 1 && node.textContent) {
            buffer += this.escapeText(node.textContent, true);
        }
        if (node.nodeType === 1 && !this.isVoid(node)) {
            buffer += this.closeTag(node);
        }
        return buffer;
    };
    exports.default = HTMLSerializer;
});
/*can-simple-dom@1.0.10#simple-dom/void-map*/
define('can-simple-dom@1.0.10#simple-dom/void-map', ['exports'], function (exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.default = {
        AREA: true,
        BASE: true,
        BR: true,
        COL: true,
        COMMAND: true,
        EMBED: true,
        HR: true,
        IMG: true,
        INPUT: true,
        KEYGEN: true,
        LINK: true,
        META: true,
        PARAM: true,
        SOURCE: true,
        TRACK: true,
        WBR: true
    };
});
/*can-simple-dom@1.0.10#simple-dom/dom*/
define('can-simple-dom@1.0.10#simple-dom/dom', [
    'exports',
    './document/node',
    './document/element',
    './document',
    './event',
    './html-parser',
    './html-serializer',
    './void-map'
], function (exports, _node, _element, _document, _event, _htmlParser, _htmlSerializer, _voidMap) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.createDocument = exports.voidMap = exports.HTMLSerializer = exports.HTMLParser = exports.Event = exports.Document = exports.Element = exports.Node = undefined;
    var _node2 = _interopRequireDefault(_node);
    var _element2 = _interopRequireDefault(_element);
    var _document2 = _interopRequireDefault(_document);
    var _event2 = _interopRequireDefault(_event);
    var _htmlParser2 = _interopRequireDefault(_htmlParser);
    var _htmlSerializer2 = _interopRequireDefault(_htmlSerializer);
    var _voidMap2 = _interopRequireDefault(_voidMap);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    function createDocument(serializer, parser) {
        var doc = new _document2.default();
        doc.__serializer = serializer;
        doc.__parser = parser;
        return doc;
    }
    exports.Node = _node2.default;
    exports.Element = _element2.default;
    exports.Document = _document2.default;
    exports.Event = _event2.default;
    exports.HTMLParser = _htmlParser2.default;
    exports.HTMLSerializer = _htmlSerializer2.default;
    exports.voidMap = _voidMap2.default;
    exports.createDocument = createDocument;
});
/*can-simple-dom@1.0.10#simple-dom*/
define('can-simple-dom@1.0.10#simple-dom', [
    'exports',
    './simple-dom/dom'
], function (exports, _dom) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    Object.keys(_dom).forEach(function (key) {
        if (key === 'default' || key === '__esModule')
            return;
        Object.defineProperty(exports, key, {
            enumerable: true,
            get: function () {
                return _dom[key];
            }
        });
    });
    var SimpleDOM = _interopRequireWildcard(_dom);
    function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
            return obj;
        } else {
            var newObj = {};
            if (obj != null) {
                for (var key in obj) {
                    if (Object.prototype.hasOwnProperty.call(obj, key))
                        newObj[key] = obj[key];
                }
            }
            newObj.default = obj;
            return newObj;
        }
    }
    if (typeof window !== 'undefined') {
        window.SimpleDOM = SimpleDOM;
    }
});
/*can-vdom@3.1.0#make-parser/make-parser*/
define('can-vdom@3.1.0#make-parser/make-parser', function (require, exports, module) {
    var canParser = require('can-view-parser');
    var simpleDOM = require('can-simple-dom');
    module.exports = function (document) {
        return new simpleDOM.HTMLParser(function (string) {
            var tokens = [];
            var currentTag, currentAttr;
            canParser(string, {
                start: function (tagName, unary) {
                    currentTag = {
                        type: 'StartTag',
                        attributes: [],
                        tagName: tagName
                    };
                },
                end: function (tagName, unary) {
                    tokens.push(currentTag);
                    currentTag = undefined;
                },
                close: function (tagName) {
                    tokens.push({
                        type: 'EndTag',
                        tagName: tagName
                    });
                },
                attrStart: function (attrName) {
                    currentAttr = [
                        attrName,
                        ''
                    ];
                    currentTag.attributes.push(currentAttr);
                },
                attrEnd: function (attrName) {
                },
                attrValue: function (value) {
                    currentAttr[1] += value;
                },
                chars: function (value) {
                    tokens.push({
                        type: 'Chars',
                        chars: value
                    });
                },
                comment: function (value) {
                    tokens.push({
                        type: 'Comment',
                        chars: value
                    });
                },
                special: function (value) {
                },
                done: function () {
                }
            });
            return tokens;
        }, document, simpleDOM.voidMap);
    };
});
/*can-vdom@3.1.0#make-document/make-document*/
define('can-vdom@3.1.0#make-document/make-document', function (require, exports, module) {
    var simpleDOM = require('can-simple-dom');
    var makeParser = require('../make-parser/make-parser');
    function CanSimpleDocument() {
        simpleDOM.Document.apply(this, arguments);
        var serializer = new simpleDOM.HTMLSerializer(simpleDOM.voidMap);
        var parser = makeParser(this);
        this.__addSerializerAndParser(serializer, parser);
    }
    CanSimpleDocument.prototype = new simpleDOM.Document();
    CanSimpleDocument.prototype.constructor = CanSimpleDocument;
    module.exports = function () {
        return new CanSimpleDocument();
    };
});
/*can-component@3.3.0#test/component-map-test*/
define('can-component@3.3.0#test/component-map-test', function (require, exports, module) {
    (function (global) {
        require('./component-define-test');
        var Component = require('can-component');
        var stache = require('can-stache');
        var QUnit = require('steal-qunit');
        var Construct = require('can-construct');
        var canCompute = require('can-compute');
        var CanMap = require('can-map');
        var CanList = require('can-list');
        var canEvent = require('can-event');
        var canViewModel = require('can-view-model');
        var canBatch = require('can-event/batch/batch');
        var attr = require('can-util/dom/attr/attr');
        var className = require('can-util/dom/class-name/class-name');
        var domMutate = require('can-util/dom/mutate/mutate');
        var domData = require('can-util/dom/data/data');
        var types = require('can-types');
        var isPromise = require('can-util/js/is-promise/is-promise');
        var makeDocument = require('can-vdom/make-document/make-document');
        var MUTATION_OBSERVER = require('can-util/dom/mutation-observer/mutation-observer');
        var DOCUMENT = require('can-util/dom/document/document');
        var getFragment = require('can-util/dom/fragment/fragment');
        var Scope = require('can-view-scope');
        var viewCallbacks = require('can-view-callbacks');
        var canLog = require('can-util/js/log/log');
        var DOC = DOCUMENT();
        var MUT_OBS = MUTATION_OBSERVER();
        makeTest('can-component - map - dom', document, MUT_OBS);
        makeTest('can-component - map - vdom', makeDocument(), null);
        var innerHTML = function (node) {
            if (node && 'innerHTML' in node) {
                return node.innerHTML;
            }
        };
        var runTasks = function (tasks) {
            var nextTask = function () {
                var next = tasks.shift();
                next();
                if (tasks.length) {
                    setTimeout(nextTask, 100);
                } else {
                    start();
                }
            };
            setTimeout(nextTask, 100);
        };
        function makeTest(name, doc, mutObs) {
            var oldDoc, oldDefaultMap;
            QUnit.module(name, {
                setup: function () {
                    DOCUMENT(doc);
                    MUTATION_OBSERVER(mutObs);
                    oldDefaultMap = types.DefaultMap;
                    types.DefaultMap = CanMap;
                    if (doc) {
                        this.fixture = doc.createElement('div');
                        doc.body.appendChild(this.fixture);
                    } else {
                        this.fixture = doc.getElementById('qunit-fixture');
                    }
                },
                teardown: function () {
                    doc.body.removeChild(this.fixture);
                    stop();
                    setTimeout(function () {
                        types.DefaultMap = oldDefaultMap;
                        start();
                        DOCUMENT(DOC);
                        MUTATION_OBSERVER(MUT_OBS);
                    }, 100);
                }
            });
            var Paginate = CanMap.extend({
                count: Infinity,
                offset: 0,
                limit: 100,
                setCount: function (newCount, success, error) {
                    return newCount < 0 ? 0 : newCount;
                },
                setOffset: function (newOffset) {
                    return newOffset < 0 ? 0 : Math.min(newOffset, !isNaN(this.count - 1) ? this.count - 1 : Infinity);
                },
                next: function () {
                    this.attr('offset', this.offset + this.limit);
                },
                prev: function () {
                    this.attr('offset', this.offset - this.limit);
                },
                canNext: function () {
                    return this.attr('offset') < this.attr('count') - this.attr('limit');
                },
                canPrev: function () {
                    return this.attr('offset') > 0;
                },
                page: function (newVal) {
                    if (newVal === undefined) {
                        return Math.floor(this.attr('offset') / this.attr('limit')) + 1;
                    } else {
                        this.attr('offset', (parseInt(newVal) - 1) * this.attr('limit'));
                    }
                },
                pageCount: function () {
                    return this.attr('count') ? Math.ceil(this.attr('count') / this.attr('limit')) : null;
                }
            });
            test('lexical scoping', function () {
                Component.extend({
                    tag: 'hello-world',
                    view: stache('{{greeting}} <content>World</content>{{exclamation}}'),
                    viewModel: { greeting: 'Hello' }
                });
                var renderer = stache('<hello-world>{{greeting}}</hello-world>');
                var frag = renderer({
                    greeting: 'World',
                    exclamation: '!'
                });
                var hello = frag.firstChild;
                equal(innerHTML(hello).trim(), 'Hello World');
                Component.extend({
                    tag: 'hello-world-no-template',
                    leakScope: false,
                    viewModel: { greeting: 'Hello' }
                });
                renderer = stache('<hello-world-no-template>{{greeting}}</hello-world-no-template>');
                frag = renderer({
                    greeting: 'World',
                    exclamation: '!'
                });
                hello = frag.firstChild;
                equal(innerHTML(hello).trim(), 'Hello', 'If no view is provided to Component, treat <content> bindings as dynamic.');
            });
            test('dynamic scoping', function () {
                Component.extend({
                    tag: 'hello-world',
                    leakScope: true,
                    view: stache('{{greeting}} <content>World</content>{{exclamation}}'),
                    viewModel: { greeting: 'Hello' }
                });
                var renderer = stache('<hello-world>{{greeting}}</hello-world>');
                var frag = renderer({
                    greeting: 'World',
                    exclamation: '!'
                });
                var hello = frag.firstChild;
                equal(innerHTML(hello).trim(), 'Hello Hello!');
            });
            test('treecombo', function () {
                var TreeComboViewModel = CanMap.extend({
                    items: [],
                    breadcrumb: [],
                    selected: [],
                    selectableItems: function () {
                        var breadcrumb = this.attr('breadcrumb');
                        if (breadcrumb.attr('length')) {
                            return breadcrumb.attr('' + (breadcrumb.length - 1) + '.children');
                        } else {
                            return this.attr('items');
                        }
                    },
                    showChildren: function (item, el, ev) {
                        ev.stopPropagation();
                        this.attr('breadcrumb').push(item);
                    },
                    emptyBreadcrumb: function () {
                        this.attr('breadcrumb').attr([], true);
                    },
                    updateBreadcrumb: function (item) {
                        var breadcrumb = this.attr('breadcrumb'), index = breadcrumb.indexOf(item);
                        breadcrumb.splice(index + 1, breadcrumb.length - index - 1);
                    },
                    toggle: function (item) {
                        var selected = this.attr('selected'), index = selected.indexOf(item);
                        if (index === -1) {
                            selected.push(item);
                        } else {
                            selected.splice(index, 1);
                        }
                    },
                    isSelected: function (item) {
                        return this.attr('selected').indexOf(item) > -1;
                    }
                });
                Component.extend({
                    tag: 'treecombo',
                    view: stache('<ul class=\'breadcrumb\'>' + '<li can-click=\'emptyBreadcrumb\'>{{title}}</li>' + '{{#each breadcrumb}}' + '<li can-click=\'updateBreadcrumb\'>{{title}}</li>' + '{{/each}}' + '</ul>' + '<ul class=\'options\'>' + '<content>' + '{{#selectableItems}}' + '<li {{#isSelected(.)}}class=\'active\'{{/isSelected}} can-click=\'toggle\'>' + '<input type=\'checkbox\' {{#isSelected(.)}}checked{{/isSelected}}/>' + '{{title}}' + '{{#if children.length}}' + '<button class=\'showChildren\' can-click=\'showChildren\'>+</button>' + '{{/if}}' + '</li>' + '{{/selectableItems}}' + '</content>' + '</ul>'),
                    ViewModel: TreeComboViewModel
                });
                var renderer = stache('<treecombo {(items)}=\'locations\' title=\'Locations\'></treecombo>');
                var base = new CanMap({});
                var frag = renderer(base);
                var root = doc.createElement('div');
                root.appendChild(frag);
                var items = [
                    {
                        id: 1,
                        title: 'Midwest',
                        children: [
                            {
                                id: 5,
                                title: 'Illinois',
                                children: [
                                    {
                                        id: 23423,
                                        title: 'Chicago'
                                    },
                                    {
                                        id: 4563,
                                        title: 'Springfield'
                                    },
                                    {
                                        id: 4564,
                                        title: 'Naperville'
                                    }
                                ]
                            },
                            {
                                id: 6,
                                title: 'Wisconsin',
                                children: [
                                    {
                                        id: 232423,
                                        title: 'Milwaulkee'
                                    },
                                    {
                                        id: 45463,
                                        title: 'Green Bay'
                                    },
                                    {
                                        id: 45464,
                                        title: 'Madison'
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        id: 2,
                        title: 'East Coast',
                        children: [
                            {
                                id: 25,
                                title: 'New York',
                                children: [
                                    {
                                        id: 3413,
                                        title: 'New York'
                                    },
                                    {
                                        id: 4613,
                                        title: 'Rochester'
                                    },
                                    {
                                        id: 4516,
                                        title: 'Syracuse'
                                    }
                                ]
                            },
                            {
                                id: 6,
                                title: 'Pennsylvania',
                                children: [
                                    {
                                        id: 2362423,
                                        title: 'Philadelphia'
                                    },
                                    {
                                        id: 454663,
                                        title: 'Harrisburg'
                                    },
                                    {
                                        id: 454664,
                                        title: 'Scranton'
                                    }
                                ]
                            }
                        ]
                    }
                ];
                stop();
                setTimeout(function () {
                    base.attr('locations', items);
                    var itemsList = base.attr('locations');
                    var treecombo = root.firstChild, breadcrumb = treecombo.firstChild, breadcrumbLIs = function () {
                            return breadcrumb.getElementsByTagName('li');
                        }, options = treecombo.lastChild, optionsLis = function () {
                            return options.getElementsByTagName('li');
                        };
                    equal(breadcrumbLIs().length, 1, 'Only the default title is shown');
                    equal(innerHTML(breadcrumbLIs()[0]), 'Locations', 'The correct title from the attribute is shown');
                    equal(itemsList.length, optionsLis().length, 'first level items are displayed');
                    canEvent.trigger.call(optionsLis()[0], 'click');
                    equal(optionsLis()[0].className, 'active', 'toggling something not selected adds active');
                    ok(optionsLis()[0].getElementsByTagName('input')[0].checked, 'toggling something not selected checks checkbox');
                    equal(canViewModel(treecombo, 'selected').length, 1, 'there is one selected item');
                    equal(canViewModel(treecombo, 'selected.0'), itemsList.attr('0'), 'the midwest is in selected');
                    canViewModel(treecombo, 'selected').pop();
                    equal(optionsLis()[0].className, '', 'toggling something not selected adds active');
                    canEvent.trigger.call(optionsLis()[0].getElementsByTagName('button')[0], 'click');
                    equal(breadcrumbLIs().length, 2, 'Only the default title is shown');
                    equal(innerHTML(breadcrumbLIs()[1]), 'Midwest', 'The breadcrumb has an item in it');
                    ok(/Illinois/.test(innerHTML(optionsLis()[0])), 'A child of the top breadcrumb is displayed');
                    canEvent.trigger.call(optionsLis()[0].getElementsByTagName('button')[0], 'click');
                    ok(/Chicago/.test(innerHTML(optionsLis()[0])), 'A child of the top breadcrumb is displayed');
                    ok(!optionsLis()[0].getElementsByTagName('button').length, 'no show children button');
                    canEvent.trigger.call(breadcrumbLIs()[1], 'click');
                    equal(innerHTML(breadcrumbLIs()[1]), 'Midwest', 'The breadcrumb has an item in it');
                    ok(/Illinois/.test(innerHTML(optionsLis()[0])), 'A child of the top breadcrumb is displayed');
                    canEvent.trigger.call(breadcrumbLIs()[0], 'click');
                    equal(breadcrumbLIs().length, 1, 'Only the default title is shown');
                    equal(innerHTML(breadcrumbLIs()[0]), 'Locations', 'The correct title from the attribute is shown');
                    start();
                }, 100);
            });
            test('deferred grid', function () {
                var GridViewModel = CanMap.extend({
                    items: [],
                    waiting: true
                });
                Component.extend({
                    tag: 'grid',
                    ViewModel: GridViewModel,
                    view: stache('<table><tbody><content></content></tbody></table>'),
                    leakScope: true,
                    events: {
                        init: function () {
                            this.update();
                        },
                        '{viewModel} deferreddata': 'update',
                        update: function () {
                            var deferred = this.viewModel.attr('deferreddata'), viewModel = this.viewModel;
                            if (isPromise(deferred)) {
                                this.viewModel.attr('waiting', true);
                                deferred.then(function (items) {
                                    viewModel.attr('items').attr(items, true);
                                });
                            } else {
                                viewModel.attr('items').attr(deferred, true);
                            }
                        },
                        '{items} change': function () {
                            this.viewModel.attr('waiting', false);
                        }
                    }
                });
                var SimulatedScope = CanMap.extend({
                    set: 0,
                    deferredData: function () {
                        var deferred = {};
                        var promise = new Promise(function (resolve, reject) {
                            deferred.resolve = resolve;
                            deferred.reject = reject;
                        });
                        var set = this.attr('set');
                        if (set === 0) {
                            setTimeout(function () {
                                deferred.resolve([{
                                        first: 'Justin',
                                        last: 'Meyer'
                                    }]);
                            }, 100);
                        } else if (set === 1) {
                            setTimeout(function () {
                                deferred.resolve([{
                                        first: 'Brian',
                                        last: 'Moschel'
                                    }]);
                            }, 100);
                        }
                        return promise;
                    }
                });
                var viewModel = new SimulatedScope();
                var renderer = stache('<grid {(deferreddata)}=\'viewModel.deferredData\'>' + '{{#each items}}' + '<tr>' + '<td width=\'40%\'>{{first}}</td>' + '<td width=\'70%\'>{{last}}</td>' + '</tr>' + '{{/each}}' + '</grid>');
                domMutate.appendChild.call(this.fixture, renderer({ viewModel: viewModel }));
                var gridScope = canViewModel(this.fixture.firstChild);
                equal(gridScope.attr('waiting'), true, 'The grid is initially waiting on the deferreddata to resolve');
                stop();
                var self = this;
                var waitingHandler = function () {
                    gridScope.unbind('waiting', waitingHandler);
                    setTimeout(function () {
                        var tds = self.fixture.getElementsByTagName('td');
                        equal(tds.length, 2, 'there are 2 tds');
                        gridScope.bind('waiting', function (ev, newVal) {
                            if (newVal === false) {
                                setTimeout(function () {
                                    equal(innerHTML(tds[0]), 'Brian', 'td changed to brian');
                                    start();
                                }, 100);
                            }
                        });
                        viewModel.attr('set', 1);
                    }, 100);
                };
                gridScope.bind('waiting', waitingHandler);
            });
            test('nextprev', function () {
                Component.extend({
                    tag: 'next-prev',
                    view: stache('<a href="javascript://"' + 'class="prev {{#paginate.canPrev}}enabled{{/paginate.canPrev}}" ($click)="paginate.prev()">Prev</a>' + '<a href="javascript://"' + 'class="next {{#paginate.canNext}}enabled{{/paginate.canNext}}" ($click)="paginate.next()">Next</a>')
                });
                var paginator = new Paginate({
                    limit: 20,
                    offset: 0,
                    count: 100
                });
                var renderer = stache('<next-prev {(paginate)}=\'paginator\'></next-prev>');
                var frag = renderer({ paginator: paginator });
                var nextPrev = frag.firstChild;
                var prev = nextPrev.firstChild, next = nextPrev.lastChild;
                ok(!/enabled/.test(prev.className), 'prev is not enabled');
                ok(/enabled/.test(next.className), 'next is  enabled');
                canEvent.trigger.call(next, 'click');
                ok(/enabled/.test(prev.className), 'prev is enabled');
            });
            test('page-count', function () {
                Component.extend({
                    tag: 'page-count',
                    view: stache('Page <span>{{page}}</span>.')
                });
                var paginator = new Paginate({
                    limit: 20,
                    offset: 0,
                    count: 100
                });
                var renderer = stache('<page-count {(page)}=\'paginator.page\'></page-count>');
                var frag = renderer(new CanMap({ paginator: paginator }));
                var span = frag.firstChild.getElementsByTagName('span')[0];
                equal(span.firstChild.nodeValue, '1');
                paginator.next();
                equal(span.firstChild.nodeValue, '2');
                paginator.next();
                equal(span.firstChild.nodeValue, '3');
            });
            test('hello-world and whitespace around custom elements', function () {
                Component.extend({
                    tag: 'hello-world',
                    view: stache('{{#if visible}}{{message}}{{else}}Click me{{/if}}'),
                    viewModel: {
                        visible: false,
                        message: 'Hello There!'
                    },
                    events: {
                        click: function () {
                            this.viewModel.attr('visible', true);
                        }
                    }
                });
                var renderer = stache('  <hello-world></hello-world>  ');
                var frag = renderer({});
                var helloWorld = frag.childNodes.item(1);
                canEvent.trigger.call(helloWorld, 'click');
                equal(innerHTML(helloWorld), 'Hello There!');
            });
            test('self closing content tags', function () {
                Component.extend({
                    'tag': 'my-greeting',
                    view: stache('<h1><content/></h1>'),
                    viewModel: { title: 'Component' }
                });
                var renderer = stache('<my-greeting><span>{{site}} - {{title}}</span></my-greeting>');
                var frag = renderer({ site: 'CanJS' });
                equal(frag.firstChild.getElementsByTagName('span').length, 1, 'there is an h1');
            });
            test('canViewModel utility', function () {
                Component({
                    tag: 'my-taggy-tag',
                    view: stache('<h1>hello</h1>'),
                    viewModel: { foo: 'bar' }
                });
                var frag = stache('<my-taggy-tag id=\'x\'></my-taggy-tag>')();
                var el = frag.firstChild;
                equal(canViewModel(el), domData.get.call(el, 'viewModel'), 'one argument grabs the viewModel object');
                equal(canViewModel(el, 'foo'), 'bar', 'two arguments fetches a value');
                canViewModel(el, 'foo', 'baz');
                equal(canViewModel(el, 'foo'), 'baz', 'Three arguments sets the value');
            });
            test('canViewModel creates one if it doesn\'t exist', function () {
                var frag = stache('<div id=\'me\'></div>')();
                var el = frag.firstChild;
                var viewModel = canViewModel(el);
                ok(!!viewModel, 'viewModel created where it didn\'t exist.');
                equal(viewModel, domData.get.call(el, 'viewModel'), 'viewModel is in the data.');
            });
            test('setting passed variables - two way binding', function () {
                Component.extend({
                    tag: 'my-toggler',
                    view: stache('{{#if visible}}<content/>{{/if}}'),
                    leakScope: true,
                    viewModel: {
                        visible: true,
                        show: function () {
                            this.attr('visible', true);
                        },
                        hide: function () {
                            this.attr('visible', false);
                        }
                    }
                });
                Component.extend({
                    tag: 'my-app',
                    viewModel: {
                        visible: true,
                        show: function () {
                            this.attr('visible', true);
                        }
                    }
                });
                var renderer = stache('<my-app>' + '{{^visible}}<button can-click="show">show</button>{{/visible}}' + '<my-toggler {(visible)}="visible">' + 'content' + '<button can-click="hide">hide</button>' + '</my-toggler>' + '</my-app>');
                var frag = renderer({});
                var myApp = frag.firstChild, buttons = myApp.getElementsByTagName('button');
                equal(buttons.length, 1, 'there is one button');
                equal(innerHTML(buttons[0]), 'hide', 'the button\'s text is hide');
                canEvent.trigger.call(buttons[0], 'click');
                buttons = myApp.getElementsByTagName('button');
                equal(buttons.length, 1, 'there is one button');
                equal(innerHTML(buttons[0]), 'show', 'the button\'s text is show');
                canEvent.trigger.call(buttons[0], 'click');
                buttons = myApp.getElementsByTagName('button');
                equal(buttons.length, 1, 'there is one button');
                equal(innerHTML(buttons[0]), 'hide', 'the button\'s text is hide');
            });
            test('helpers reference the correct instance (#515)', function () {
                expect(2);
                Component({
                    tag: 'my-text',
                    view: stache('<p>{{valueHelper}}</p>'),
                    helpers: {
                        valueHelper: function () {
                            return this.attr('value');
                        }
                    }
                });
                var renderer = stache('<my-text value="value1"></my-text><my-text value="value2"></my-text>');
                var frag = renderer({});
                equal(frag.firstChild.firstChild.firstChild.nodeValue, 'value1');
                equal(frag.lastChild.firstChild.firstChild.nodeValue, 'value2');
            });
            test('access hypenated attributes via camelCase or hypenated', function () {
                Component({
                    tag: 'hyphen',
                    view: stache('<p>{{valueHelper}}</p>'),
                    helpers: {
                        valueHelper: function () {
                            return this.attr('camelCase');
                        }
                    }
                });
                var renderer = stache('<hyphen camel-case="value1"></hyphen>');
                var frag = renderer({});
                equal(frag.firstChild.firstChild.firstChild.nodeValue, 'value1');
            });
            test('a map as viewModel', function () {
                var me = new CanMap({ name: 'Justin' });
                Component.extend({
                    tag: 'my-viewmodel',
                    view: stache('{{name}}}'),
                    viewModel: me
                });
                var renderer = stache('<my-viewmodel></my-viewmodel>');
                equal(renderer().firstChild.firstChild.nodeValue, 'Justin');
            });
            test('a CanMap constructor as viewModel', function () {
                var MyMap = CanMap.extend({ name: 'Matthew' });
                Component.extend({
                    tag: 'can-map-viewmodel',
                    view: stache('{{name}}'),
                    viewModel: MyMap
                });
                var renderer = stache('<can-map-viewmodel></can-map-viewmodel>');
                equal(renderer().firstChild.firstChild.nodeValue, 'Matthew');
            });
            test('a CanMap constructor as scope', function () {
                var MyMap = CanMap.extend({ name: 'Matthew' });
                Component.extend({
                    tag: 'can-map-viewmodel',
                    view: stache('{{name}}'),
                    scope: MyMap
                });
                var renderer = stache('<can-map-viewmodel></can-map-viewmodel>');
                equal(renderer().firstChild.firstChild.nodeValue, 'Matthew');
            });
            test('an object is turned into a CanMap as viewModel', function () {
                Component.extend({
                    tag: 'can-map-viewmodel',
                    view: stache('{{name}}'),
                    viewModel: { name: 'Matthew' }
                });
                var renderer = stache('<can-map-viewmodel></can-map-viewmodel>');
                var fragOne = renderer();
                var vmOne = canViewModel(fragOne.firstChild);
                var fragTwo = renderer();
                var vmTwo = canViewModel(fragTwo.firstChild);
                vmOne.attr('name', 'Wilbur');
                equal(fragOne.firstChild.firstChild.nodeValue, 'Wilbur', 'The first map changed values');
                equal(fragTwo.firstChild.firstChild.nodeValue, 'Matthew', 'The second map did not change');
            });
            test('Providing viewModel and ViewModel throws', function () {
                try {
                    Component.extend({
                        tag: 'viewmodel-test',
                        view: stache('<div></div>'),
                        viewModel: {},
                        ViewModel: CanMap.extend({})
                    });
                    ok(false, 'Should have thrown because we provided both');
                } catch (er) {
                    ok(true, 'It threw because we provided both viewModel and ViewModel');
                }
            });
            test('content in a list', function () {
                var renderer = stache('<my-list>{{name}}</my-list>');
                Component.extend({
                    tag: 'my-list',
                    view: stache('{{#each items}}<li><content/></li>{{/each}}'),
                    leakScope: true,
                    viewModel: {
                        items: new CanList([
                            { name: 'one' },
                            { name: 'two' }
                        ])
                    }
                });
                var lis = renderer().firstChild.getElementsByTagName('li');
                equal(innerHTML(lis[0]), 'one', 'first li has correct content');
                equal(innerHTML(lis[1]), 'two', 'second li has correct content');
            });
            test('don\'t update computes unnecessarily', function () {
                var sourceAge = 30, timesComputeIsCalled = 0;
                var age = canCompute(function (newVal) {
                    timesComputeIsCalled++;
                    if (timesComputeIsCalled === 1) {
                        ok(true, 'reading initial value to set as years');
                    } else if (timesComputeIsCalled === 2) {
                        equal(newVal, 31, 'updating value to 31');
                    } else if (timesComputeIsCalled === 3) {
                        ok(true, 'called back another time after set to get the value');
                    } else {
                        ok(false, 'You\'ve called the callback ' + timesComputeIsCalled + ' times');
                    }
                    if (arguments.length) {
                        sourceAge = newVal;
                    } else {
                        return sourceAge;
                    }
                });
                Component.extend({ tag: 'age-er' });
                var renderer = stache('<age-er {(years)}=\'age\'></age-er>');
                renderer({ age: age });
                age(31);
            });
            test('component does not respect canCompute passed via attributes (#540)', function () {
                var data = { compute: canCompute(30) };
                Component.extend({
                    tag: 'my-component',
                    view: stache('<span>{{blocks}}</span>')
                });
                var renderer = stache('<my-component {(blocks)}=\'compute\'></my-component>');
                var frag = renderer(data);
                equal(innerHTML(frag.firstChild.firstChild), '30');
            });
            test('defined view models (#563)', function () {
                var HelloWorldModel = CanMap.extend({
                    visible: true,
                    toggle: function () {
                        this.attr('visible', !this.attr('visible'));
                    }
                });
                Component.extend({
                    tag: 'my-helloworld',
                    view: stache('<h1>{{#if visible}}visible{{else}}invisible{{/if}}</h1>'),
                    ViewModel: HelloWorldModel
                });
                var renderer = stache('<my-helloworld></my-helloworld>');
                var frag = renderer({});
                equal(innerHTML(frag.firstChild.firstChild), 'visible');
            });
            test('viewModel not rebound correctly (#550)', function () {
                var nameChanges = 0;
                Component.extend({
                    tag: 'viewmodel-rebinder',
                    events: {
                        '{name} change': function () {
                            nameChanges++;
                        }
                    }
                });
                var renderer = stache('<viewmodel-rebinder></viewmodel-rebinder>');
                var frag = renderer();
                var viewModel = canViewModel(frag.firstChild);
                var n1 = canCompute(), n2 = canCompute();
                viewModel.attr('name', n1);
                n1('updated');
                viewModel.attr('name', n2);
                n2('updated');
                equal(nameChanges, 2);
            });
            test('content extension stack overflow error', function () {
                Component({
                    tag: 'outer-tag',
                    view: stache('<inner-tag>inner-tag CONTENT <content/></inner-tag>')
                });
                Component({
                    tag: 'inner-tag',
                    view: stache('inner-tag TEMPLATE <content/>')
                });
                var renderer = stache('<outer-tag>outer-tag CONTENT</outer-tag>');
                var frag = renderer();
                equal(innerHTML(frag.firstChild.firstChild), 'inner-tag TEMPLATE inner-tag CONTENT outer-tag CONTENT');
            });
            test('inserted event fires twice if component inside live binding block', function () {
                var inited = 0, inserted = 0;
                Component.extend({
                    tag: 'child-tag',
                    ViewModel: CanMap.extend({
                        init: function () {
                            inited++;
                        }
                    }),
                    events: {
                        ' inserted': function () {
                            inserted++;
                        }
                    }
                });
                Component.extend({
                    tag: 'parent-tag',
                    view: stache('{{#shown}}<child-tag></child-tag>{{/shown}}'),
                    viewModel: { shown: false },
                    events: {
                        ' inserted': function () {
                            this.viewModel.attr('shown', true);
                        }
                    }
                });
                var frag = stache('<parent-tag id=\'pt\'></parent-tag>')({});
                domMutate.appendChild.call(this.fixture, frag);
                stop();
                function checkCount() {
                    if (inserted >= 1) {
                        equal(inited, 1, 'inited');
                        equal(inserted, 1, 'inserted');
                        start();
                    } else {
                        setTimeout(checkCount, 30);
                    }
                }
                checkCount();
            });
            test('@ keeps properties live now', function () {
                Component.extend({
                    tag: 'attr-fun',
                    view: stache('<h1>{{fullName}}</h1>'),
                    ViewModel: CanMap.extend({
                        fullName: function () {
                            return this.attr('firstName') + ' ' + this.attr('lastName');
                        }
                    })
                });
                var frag = stache('<attr-fun first-name=\'Justin\' last-name=\'Meyer\'></attr-fun>')();
                var attrFun = frag.firstChild;
                this.fixture.appendChild(attrFun);
                equal(innerHTML(attrFun.firstChild), 'Justin Meyer');
                attr.set(attrFun, 'first-name', 'Brian');
                stop();
                setTimeout(function () {
                    equal(attrFun.firstChild.firstChild.nodeValue, 'Brian Meyer');
                    start();
                }, 100);
            });
            test('id and class should work now (#694)', function () {
                Component.extend({
                    tag: 'stay-classy',
                    ViewModel: CanMap.extend({
                        notid: 'foo',
                        notclass: 5,
                        notdataviewid: {}
                    })
                });
                var data = {
                    idData: 'id-success',
                    classData: 'class-success'
                };
                var frag = stache('<stay-classy {(id)}=\'idData\'' + ' {(class)}=\'classData\'></stay-classy>')(data);
                var stayClassy = frag.firstChild;
                domMutate.appendChild.call(this.fixture, frag);
                var viewModel = canViewModel(stayClassy);
                equal(viewModel.attr('id'), 'id-success');
                equal(viewModel.attr('class'), 'class-success');
            });
            test('Component can-click method should be not called while component\'s init', function () {
                var called = false;
                Component.extend({ tag: 'child-tag' });
                Component.extend({
                    tag: 'parent-tag',
                    view: stache('<child-tag can-click="method"></child-tag>'),
                    viewModel: {
                        method: function () {
                            called = true;
                        }
                    }
                });
                stache('<parent-tag></parent-tag>')();
                equal(called, false);
            });
            test('Same component tag nested', function () {
                Component({
                    'tag': 'my-tag',
                    view: stache('<p><content/></p>')
                });
                var renderer = stache('<div><my-tag>Outter<my-tag>Inner</my-tag></my-tag></div>');
                var renderer2 = stache('<div><my-tag>3<my-tag>2<my-tag>1<my-tag>0</my-tag></my-tag></my-tag></my-tag></div>');
                var renderer3 = stache('<div><my-tag>First</my-tag><my-tag>Second</my-tag></div>');
                equal(renderer({}).firstChild.getElementsByTagName('p').length, 2, 'proper number of p tags');
                equal(renderer2({}).firstChild.getElementsByTagName('p').length, 4, 'proper number of p tags');
                equal(renderer3({}).firstChild.getElementsByTagName('p').length, 2, 'proper number of p tags');
            });
            test('Component events bind to window', function () {
                window.tempMap = new CanMap();
                Component.extend({
                    tag: 'window-events',
                    events: {
                        '{tempMap} prop': function () {
                            ok(true, 'called templated event');
                        }
                    }
                });
                var renderer = stache('<window-events></window-events>');
                renderer();
                window.tempMap.attr('prop', 'value');
                window.tempMap = undefined;
                try {
                    delete window.tempMap;
                } catch (e) {
                }
            });
            test('Construct are passed normally', function () {
                var Constructed = Construct.extend({ foo: 'bar' }, {});
                Component.extend({
                    tag: 'con-struct',
                    view: stache('{{con.foo}}')
                });
                var stached = stache('<con-struct {(con)}=\'Constructed\'></con-struct>');
                var res = stached({ Constructed: Constructed });
                equal(innerHTML(res.firstChild), 'bar');
            });
            test('passing id works now', function () {
                Component.extend({
                    tag: 'my-thing',
                    view: stache('hello')
                });
                var renderer = stache('<my-thing {(id)}=\'productId\'></my-tagged>');
                var frag = renderer(new CanMap({ productId: 123 }));
                equal(canViewModel(frag.firstChild).attr('id'), 123);
            });
            test('stache conditionally nested components calls inserted once (#967)', function () {
                expect(1);
                Component.extend({
                    tag: 'can-parent-stache',
                    viewModel: { shown: true },
                    view: stache('{{#if shown}}<can-child></can-child>{{/if}}')
                });
                Component.extend({
                    tag: 'can-child',
                    events: {
                        inserted: function () {
                            ok(true, 'called inserted once');
                        }
                    }
                });
                var renderer = stache('<can-parent-stache></can-parent-stache>');
                domMutate.appendChild.call(this.fixture, renderer());
                stop();
                setTimeout(start, 100);
            });
            test('hyphen-less tag names', function () {
                Component.extend({
                    tag: 'foobar',
                    view: stache('<div>{{name}}</div>'),
                    viewModel: { name: 'Brian' }
                });
                var renderer = stache('<span></span><foobar></foobar>');
                var frag = renderer();
                equal(frag.lastChild.firstChild.firstChild.nodeValue, 'Brian');
            });
            test('nested component within an #if is not live bound(#1025)', function () {
                Component.extend({
                    tag: 'parent-component',
                    view: stache('{{#if shown}}<child-component></child-component>{{/if}}'),
                    viewModel: { shown: false }
                });
                Component.extend({
                    tag: 'child-component',
                    view: stache('Hello world.')
                });
                var renderer = stache('<parent-component></parent-component>');
                var frag = renderer({});
                equal(innerHTML(frag.firstChild), '', 'child component is not inserted');
                canViewModel(frag.firstChild).attr('shown', true);
                equal(innerHTML(frag.firstChild.firstChild), 'Hello world.', 'child component is inserted');
                canViewModel(frag.firstChild).attr('shown', false);
                equal(innerHTML(frag.firstChild), '', 'child component is removed');
            });
            test('component does not update viewModel on id, class, and data-view-id attribute changes (#1079)', function () {
                Component.extend({ tag: 'x-app' });
                var frag = stache('<x-app></x-app>')({});
                var el = frag.firstChild;
                var viewModel = canViewModel(el);
                domMutate.appendChild.call(this.fixture, frag);
                className.add.call(el, 'foo');
                stop();
                setTimeout(function () {
                    equal(viewModel.attr('class'), undefined, 'the viewModel is not updated when the class attribute changes');
                    start();
                }, 100);
            });
            test('viewModel objects with Constructor functions as properties do not get converted (#1261)', 1, function () {
                stop();
                var Test = CanMap.extend({ test: 'Yeah' });
                Component.extend({
                    tag: 'my-app',
                    viewModel: { MyConstruct: Test },
                    events: {
                        '{MyConstruct} something': function () {
                            ok(true, 'Event got triggered');
                            start();
                        }
                    }
                });
                var frag = stache('<my-app></my-app>')();
                domMutate.appendChild.call(this.fixture, frag);
                canEvent.trigger.call(Test, 'something');
            });
            test('removing bound viewModel properties on destroy #1415', function () {
                var state = new CanMap({
                    product: {
                        id: 1,
                        name: 'Tom'
                    }
                });
                Component.extend({
                    tag: 'destroyable-component',
                    events: {
                        destroy: function () {
                            this.viewModel.attr('product', null);
                        }
                    }
                });
                var frag = stache('<destroyable-component {(product)}="product"></destroyable-component>')(state);
                domMutate.appendChild.call(this.fixture, frag);
                domMutate.removeChild.call(this.fixture, this.fixture.firstChild);
                stop();
                setTimeout(function () {
                    ok(state.attr('product') == null, 'product was removed');
                    start();
                }, 100);
            });
            test('changing viewModel property rebinds {viewModel.<...>} events (#1529)', 2, function () {
                Component.extend({
                    tag: 'rebind-viewmodel',
                    events: {
                        init: function () {
                            this.viewModel.attr('item', {});
                        },
                        '{scope.item} change': function () {
                            ok(true, 'Change event on scope');
                        },
                        '{viewModel.item} change': function () {
                            ok(true, 'Change event on viewModel');
                        }
                    }
                });
                var frag = stache('<rebind-viewmodel></rebind-viewmodel>')();
                var rebind = frag.firstChild;
                domMutate.appendChild.call(this.fixture, rebind);
                canViewModel(rebind).attr('item.name', 'CDN');
            });
            test('Component two way binding loop (#1579)', function () {
                var changeCount = 0;
                Component.extend({
                    tag: 'product-swatch-color',
                    viewModel: { tag: 'product-swatch-color' }
                });
                Component.extend({
                    tag: 'product-swatch',
                    view: stache('<product-swatch-color {(variations)}="variations"></product-swatch-color>'),
                    ViewModel: CanMap.extend({
                        tag: 'product-swatch',
                        define: {
                            variations: {
                                set: function (variations) {
                                    if (changeCount > 500) {
                                        return;
                                    }
                                    changeCount++;
                                    return new CanList(variations.attr());
                                }
                            }
                        }
                    })
                });
                var frag = stache('<product-swatch></product-swatch>')(), productSwatch = frag.firstChild;
                canBatch.start();
                canViewModel(productSwatch).attr('variations', new CanList());
                canBatch.stop();
                ok(changeCount < 500, 'more than 500 events');
            });
            test('references scopes are available to bindings nested in components (#2029)', function () {
                var renderer = stache('<export-er {^value}="*reference" />' + '<wrap-er><simple-example {key}="*reference"/></wrap-er>');
                Component.extend({ tag: 'wrap-er' });
                Component.extend({
                    tag: 'export-er',
                    events: {
                        'init': function () {
                            var self = this.viewModel;
                            stop();
                            setTimeout(function () {
                                self.attr('value', 100);
                                var wrapper = frag.lastChild, simpleExample = wrapper.firstChild, textNode = simpleExample.firstChild;
                                equal(textNode.nodeValue, '100', 'updated value with reference');
                                start();
                            }, 100);
                        }
                    }
                });
                Component.extend({
                    tag: 'simple-example',
                    view: stache('{{key}}'),
                    viewModel: {}
                });
                var frag = renderer({});
            });
            test('two-way binding syntax PRIOR to v2.3 shall NOT let a child property initialize an undefined parent property (#2020)', function () {
                var renderer = stache('<pa-rent/>');
                Component.extend({
                    tag: 'pa-rent',
                    view: stache('<chi-ld child-prop="{parentProp}" />')
                });
                Component.extend({
                    tag: 'chi-ld',
                    viewModel: { childProp: 'bar' }
                });
                var frag = renderer({});
                var parentVM = canViewModel(frag.firstChild);
                var childVM = canViewModel(frag.firstChild.firstChild);
                equal(parentVM.attr('parentProp'), undefined, 'parentProp is undefined');
                equal(childVM.attr('childProp'), 'bar', 'childProp is bar');
                parentVM.attr('parentProp', 'foo');
                equal(parentVM.attr('parentProp'), 'foo', 'parentProp is foo');
                equal(childVM.attr('childProp'), 'foo', 'childProp is foo');
                childVM.attr('childProp', 'baz');
                equal(parentVM.attr('parentProp'), 'baz', 'parentProp is baz');
                equal(childVM.attr('childProp'), 'baz', 'childProp is baz');
            });
            test('two-way binding syntax INTRODUCED in v2.3 ALLOWS a child property to initialize an undefined parent property', function () {
                var renderer = stache('<pa-rent/>');
                Component.extend({
                    tag: 'pa-rent',
                    view: stache('<chi-ld {(child-prop)}="parentProp" />')
                });
                Component.extend({
                    tag: 'chi-ld',
                    viewModel: { childProp: 'bar' }
                });
                var frag = renderer({});
                var parentVM = canViewModel(frag.firstChild);
                var childVM = canViewModel(frag.firstChild.firstChild);
                equal(parentVM.attr('parentProp'), 'bar', 'parentProp is bar');
                equal(childVM.attr('childProp'), 'bar', 'childProp is bar');
                parentVM.attr('parentProp', 'foo');
                equal(parentVM.attr('parentProp'), 'foo', 'parentProp is foo');
                equal(childVM.attr('childProp'), 'foo', 'childProp is foo');
                childVM.attr('childProp', 'baz');
                equal(parentVM.attr('parentProp'), 'baz', 'parentProp is baz');
                equal(childVM.attr('childProp'), 'baz', 'childProp is baz');
            });
            test('conditional attributes (#2077)', function () {
                Component.extend({ tag: 'some-comp' });
                var renderer = stache('<some-comp ' + '{{#if preview}}{next}=\'nextPage\'{{/if}} ' + '{swap}=\'{{swapName}}\' ' + '{{#preview}}checked{{/preview}} ' + '></some-comp>');
                var map = new CanMap({
                    preview: true,
                    nextPage: 2,
                    swapName: 'preview'
                });
                var frag = renderer(map);
                var vm = canViewModel(frag.firstChild);
                var threads = [
                    function () {
                        equal(vm.attr('next'), 2, 'has binidng');
                        equal(vm.attr('swap'), true, 'swap - has binding');
                        equal(vm.attr('checked'), '', 'attr - has binding');
                        map.attr('preview', false);
                    },
                    function () {
                        equal(vm.attr('swap'), false, 'swap - updated binidng');
                        ok(vm.attr('checked') === null, 'attr - value set to null');
                        map.attr('nextPage', 3);
                        equal(vm.attr('next'), 2, 'not updating after binding is torn down');
                        map.attr('preview', true);
                    },
                    function () {
                        equal(vm.attr('next'), 3, 're-initialized with binding');
                        equal(vm.attr('swap'), true, 'swap - updated binidng');
                        equal(vm.attr('checked'), '', 'attr - has binding set again');
                        map.attr('swapName', 'nextPage');
                    },
                    function () {
                        equal(vm.attr('swap'), 3, 'swap - updated binding key');
                        map.attr('nextPage', 4);
                        equal(vm.attr('swap'), 4, 'swap - updated binding');
                    }
                ];
                stop();
                var index = 0;
                var next = function () {
                    if (index < threads.length) {
                        threads[index]();
                        index++;
                        setTimeout(next, 150);
                    } else {
                        start();
                    }
                };
                setTimeout(next, 100);
            });
            test('<content> (#2151)', function () {
                var mapInstance = new CanMap({
                    items: [
                        {
                            id: 1,
                            context: 'Item 1',
                            render: false
                        },
                        {
                            id: 2,
                            context: 'Item 2',
                            render: false
                        }
                    ]
                });
                Component.extend({
                    tag: 'list-items',
                    view: stache('<ul>' + '{{#items}}' + '{{#if render}}' + '<li><content /></li>' + '{{/if}}' + '{{/items}}' + '</ul>'),
                    viewModel: mapInstance,
                    leakScope: true
                });
                Component.extend({
                    tag: 'list-item',
                    view: stache('{{item.context}}')
                });
                var renderer = stache('<list-items><list-item item=\'{.}\'/></list-items>');
                var frag = renderer();
                canBatch.start();
                canViewModel(frag.firstChild).attr('items').each(function (item, index) {
                    item.attr('render', true);
                });
                canBatch.stop();
                var lis = frag.firstChild.getElementsByTagName('li');
                ok(innerHTML(lis[0]).indexOf('Item 1') >= 0, 'Item 1 written out');
                ok(innerHTML(lis[1]).indexOf('Item 2') >= 0, 'Item 2 written out');
            });
            test('one-way - child to parent - parent that does not leak scope, but has no view', function () {
                Component.extend({
                    tag: 'outer-noleak',
                    viewModel: { isOuter: true },
                    leakScope: false
                });
                Component.extend({
                    tag: 'my-child',
                    viewModel: { isChild: true },
                    leakScope: false
                });
                var renderer = stache('<outer-noleak><my-child {^.}=\'myChild\'/></outer-noleak>');
                var frag = renderer();
                var vm = canViewModel(frag.firstChild);
                ok(vm.attr('myChild') instanceof CanMap, 'got instance');
            });
            test('two-way - reference - with <content> tag', function () {
                Component.extend({
                    tag: 'other-export',
                    viewModel: { name: 'OTHER-EXPORT' }
                });
                Component.extend({
                    tag: 'ref-export',
                    view: stache('<other-export {(name)}="*otherExport"/><content>{{*otherExport}}</content>')
                });
                var t1 = stache('<ref-export></ref-export>');
                var f1 = t1();
                equal(canViewModel(f1.firstChild.firstChild).attr('name'), 'OTHER-EXPORT', 'viewModel set correctly');
                equal(f1.firstChild.lastChild.nodeValue, 'OTHER-EXPORT', 'content');
            });
            test('custom renderer can provide setupBindings', function () {
                DOCUMENT(document);
                var rendererFactory = function (tmpl) {
                    var frag = getFragment(tmpl);
                    return function (scope, options) {
                        scope = scope || new Scope();
                        options = options || new Scope.Options({});
                        if (frag.firstChild.nodeName === 'CUSTOM-RENDERER') {
                            viewCallbacks.tagHandler(frag.firstChild, 'custom-renderer', {
                                scope: scope,
                                options: options,
                                templateType: 'my-renderer',
                                setupBindings: function (el, callback, data) {
                                    callback({ foo: 'qux' });
                                }
                            });
                        } else {
                            var tn = frag.firstChild.firstChild;
                            tn.nodeValue = scope.read('foo').value;
                        }
                        return frag;
                    };
                };
                Component.extend({
                    tag: 'custom-renderer',
                    view: rendererFactory('<div>{{foo}}</div>'),
                    ViewModel: CanMap.extend({})
                });
                var renderer = rendererFactory('<custom-renderer foo=\'bar\'></custom-renderer>');
                var frag = renderer();
                var tn = frag.firstChild.firstChild.firstChild;
                equal(tn.nodeValue, 'qux', 'was bound!');
            });
            if (System.env !== 'canjs-test') {
                test('basic tabs', function () {
                    var TabsViewModel = CanMap.extend({
                        init: function () {
                            this.attr('panels', []);
                        },
                        addPanel: function (panel) {
                            if (this.attr('panels').length === 0) {
                                this.makeActive(panel);
                            }
                            this.attr('panels').push(panel);
                        },
                        removePanel: function (panel) {
                            var panels = this.attr('panels');
                            canBatch.start();
                            var index = panels.indexOf(panel);
                            canLog.log(index);
                            panels.splice(index, 1);
                            if (panel === this.attr('active')) {
                                if (panels.length) {
                                    this.makeActive(panels[0]);
                                } else {
                                    this.removeAttr('active');
                                }
                            }
                            canBatch.stop();
                        },
                        makeActive: function (panel) {
                            this.attr('active', panel);
                            this.attr('panels').each(function (panel) {
                                panel.attr('active', false);
                            });
                            panel.attr('active', true);
                        },
                        isActive: function (panel) {
                            return this.attr('active') === panel;
                        }
                    });
                    Component.extend({
                        tag: 'tabs',
                        ViewModel: TabsViewModel,
                        view: stache('<ul>' + '{{#panels}}' + '<li {{#isActive(.)}}class=\'active\'{{/isActive}} can-click=\'makeActive\'>{{title}}</li>' + '{{/panels}}' + '</ul>' + '<content></content>')
                    });
                    Component.extend({
                        view: stache('{{#if active}}<content></content>{{/if}}'),
                        tag: 'panel',
                        ViewModel: CanMap.extend({ active: false }),
                        events: {
                            ' inserted': function () {
                                canViewModel(this.element.parentNode).addPanel(this.viewModel);
                            },
                            ' beforeremove': function () {
                                canLog.log('I AM BEING REMOVED');
                                canViewModel(this.element.parentNode).removePanel(this.viewModel);
                            }
                        }
                    });
                    var renderer = stache('<tabs>{{#each foodTypes}}<panel title=\'{{title}}\'>{{content}}</panel>{{/each}}</tabs>');
                    var foodTypes = new CanList([
                        {
                            title: 'Fruits',
                            content: 'oranges, apples'
                        },
                        {
                            title: 'Breads',
                            content: 'pasta, cereal'
                        },
                        {
                            title: 'Sweets',
                            content: 'ice cream, candy'
                        }
                    ]);
                    var frag = renderer({ foodTypes: foodTypes });
                    domMutate.appendChild.call(this.fixture, frag);
                    var testArea = this.fixture;
                    stop();
                    runTasks([
                        function () {
                            var lis = testArea.getElementsByTagName('li');
                            equal(lis.length, 3, 'three lis added');
                            foodTypes.each(function (type, i) {
                                equal(innerHTML(lis[i]), type.attr('title'), 'li ' + i + ' has the right content');
                            });
                            foodTypes.push({
                                title: 'Vegies',
                                content: 'carrots, kale'
                            });
                        },
                        function () {
                            var lis = testArea.getElementsByTagName('li');
                            equal(lis.length, 4, 'li added');
                            foodTypes.each(function (type, i) {
                                equal(innerHTML(lis[i]), type.attr('title'), 'li ' + i + ' has the right content');
                            });
                            equal(testArea.getElementsByTagName('panel').length, 4, 'panel added');
                            canLog.log('SHIFTY');
                            foodTypes.shift();
                        },
                        function () {
                            var lis = testArea.getElementsByTagName('li');
                            equal(lis.length, 3, 'removed li after shifting a foodType');
                            foodTypes.each(function (type, i) {
                                equal(innerHTML(lis[i]), type.attr('title'), 'li ' + i + ' has the right content');
                            });
                            var panels = testArea.getElementsByTagName('panel');
                            equal(lis[0].className, 'active', 'the first element is active');
                            equal(innerHTML(panels[0]), 'pasta, cereal', 'the first content is shown');
                            equal(innerHTML(panels[1]), '', 'the second content is removed');
                            canEvent.trigger.call(lis[1], 'click');
                            lis = testArea.getElementsByTagName('li');
                            equal(lis[1].className, 'active', 'the second element is active');
                            equal(lis[0].className, '', 'the first element is not active');
                            equal(innerHTML(panels[0]), '', 'the second content is removed');
                            equal(innerHTML(panels[1]), 'ice cream, candy', 'the second content is shown');
                        }
                    ]);
                });
                test('DOM trees not releasing when referencing CanMap inside CanMap in view (#1593)', function () {
                    var baseTemplate = stache('{{#if show}}<my-outside></my-outside>{{/if}}'), show = canCompute(true), state = new CanMap({ inner: 1 });
                    var removeCount = 0;
                    Component.extend({
                        tag: 'my-inside',
                        events: {
                            removed: function () {
                                removeCount++;
                            }
                        },
                        leakScope: true
                    });
                    Component.extend({
                        tag: 'my-outside',
                        view: stache('{{#if state.inner}}<my-inside></my-inside>{{/if}}'),
                        leakScope: true
                    });
                    domMutate.appendChild.call(this.fixture, baseTemplate({
                        show: show,
                        state: state
                    }));
                    runTasks([
                        function () {
                            show(false);
                        },
                        function () {
                            state.removeAttr('inner');
                        },
                        function () {
                            equal(removeCount, 1, 'internal removed once');
                            show(true);
                        },
                        function () {
                            state.attr('inner', 2);
                        },
                        function () {
                            state.removeAttr('inner');
                        },
                        function () {
                            equal(removeCount, 2, 'internal removed twice');
                        }
                    ]);
                    stop();
                });
            }
        }
    }(function () {
        return this;
    }()));
});
/*can-component@3.3.0#test/component-slot-test*/
define('can-component@3.3.0#test/component-slot-test', function (require, exports, module) {
    var Component = require('can-component');
    var stache = require('can-stache');
    var QUnit = require('steal-qunit');
    var DefineMap = require('can-define/map/map');
    var viewModel = require('can-view-model');
    QUnit.module('can-components - can-slots');
    test('<can-slot> Works', function () {
        var ViewModel = DefineMap.extend({
            subject: { value: 'Hello World' },
            body: { value: 'Later Gator' }
        });
        Component.extend({
            tag: 'my-email',
            view: stache('<can-slot name="subject" />' + '<can-slot name="body" />'),
            ViewModel: ViewModel,
            leakScope: true
        });
        var renderer = stache('<my-email>' + '<can-template name="subject">' + '{{subject}}' + '</can-template>' + '<can-template name="body">' + '{{body}}' + '</can-template>' + '</my-email>');
        var testView = renderer();
        equal(testView.firstChild.childNodes[0].nodeValue, 'Hello World');
        equal(testView.firstChild.childNodes[1].nodeValue, 'Later Gator');
    });
    test('<can-slot> leakScope false acts as expected', function () {
        var ViewModel = DefineMap.extend({
            subject: { value: 'Hello World' },
            body: { value: 'Later Gator' }
        });
        Component.extend({
            tag: 'my-email',
            view: stache('<can-slot name="subject" />' + '<can-slot name="body" />'),
            ViewModel: ViewModel
        });
        var renderer = stache('<my-email>' + '<can-template name="subject">' + '{{subject}}' + '</can-template>' + '<can-template name="body">' + '{{body}}' + '</can-template>' + '</my-email>');
        var testView = renderer({
            subject: 'foo',
            body: 'bar'
        });
        equal(testView.firstChild.childNodes[0].nodeValue, 'foo');
        equal(testView.firstChild.childNodes[1].nodeValue, 'bar');
    });
    test('<can-slot> Re-use templates', function () {
        var ViewModel = DefineMap.extend({
            subject: { value: 'Hello World' },
            body: { value: 'Later Gator' }
        });
        Component.extend({
            tag: 'my-email',
            view: stache('<can-slot name="subject" />' + '<can-slot name="subject" />'),
            ViewModel: ViewModel,
            leakScope: true
        });
        var renderer = stache('<my-email>' + '<can-template name="subject">' + '{{subject}}' + '</can-template>' + '</my-email>');
        var testView = renderer();
        equal(testView.firstChild.childNodes[0].nodeValue, 'Hello World');
        equal(testView.firstChild.childNodes[1].nodeValue, 'Hello World');
    });
    test('<can-slot> Works with default content', function () {
        var ViewModel = DefineMap.extend({});
        Component.extend({
            tag: 'my-email',
            view: stache('<can-slot name="subject">' + 'Default Content' + '</can-slot>'),
            ViewModel: ViewModel
        });
        var renderer = stache('<my-email>' + '<can-template name="subject" />' + '</my-email>');
        var testView = renderer();
        equal(testView.firstChild.innerHTML, 'Default Content');
    });
    test('<can-slot> Context one-way binding works', function () {
        var ViewModel = DefineMap.extend('MyEmailVM', { subject: { value: 'Hello World' } });
        Component.extend({
            tag: 'my-email',
            view: stache('<can-slot name="foo" {this}="subject" />'),
            ViewModel: ViewModel
        });
        var renderer = stache('<my-email>' + '<can-template name="foo"><span>{{this}}</span></can-template>' + '</my-email>');
        var frag = renderer();
        var vm = viewModel(frag.firstChild);
        equal(frag.firstChild.firstChild.innerHTML, 'Hello World');
        vm.subject = 'Later Gator';
        equal(frag.firstChild.firstChild.innerHTML, 'Later Gator');
    });
    test('<can-slot> Context two-way binding works', function () {
        var ViewModel = DefineMap.extend('MyEmailVM', {}, { subject: { value: 'Hello World' } });
        Component.extend({
            tag: 'my-email',
            view: stache('<can-slot name="foo" {(this)}="subject" />'),
            ViewModel: ViewModel
        });
        Component.extend({
            tag: 'my-subject',
            view: stache('{{subject}}')
        });
        var vm = 'Hello World';
        var renderer = stache('<my-email>' + '<can-template name="foo"><my-subject {(subject)}="this" /></can-template>' + '</my-email>');
        var frag = renderer();
        vm = viewModel(frag.firstChild);
        var childVM = viewModel(frag.firstChild.firstChild);
        equal(frag.firstChild.firstChild.innerHTML, 'Hello World');
        vm.subject = 'Later Gator';
        equal(frag.firstChild.firstChild.innerHTML, 'Later Gator');
        childVM.subject = 'After a while crocodile';
        equal(vm.subject, 'After a while crocodile');
    });
    test('<can-slot> Context child-to-parent binding works', function () {
        var ViewModel = DefineMap.extend({ subject: { value: 'Hello World' } });
        Component.extend({
            tag: 'my-email',
            view: stache('<can-slot name="foo" {^this}="subject" />'),
            ViewModel: ViewModel
        });
        Component.extend({
            tag: 'my-subject',
            view: stache('{{subject}}'),
            ViewModel: DefineMap.extend({ subject: { value: 'Yo' } })
        });
        var renderer = stache('<my-email>' + '<can-template name="foo"><my-subject {^subject}="this" /></can-template>' + '</my-email>');
        var frag = renderer();
        var vm = viewModel(frag.firstChild);
        var childVM = viewModel(frag.firstChild.firstChild);
        equal(frag.firstChild.firstChild.innerHTML, 'Yo');
        childVM.subject = 'bar';
        equal(frag.firstChild.firstChild.innerHTML, 'bar');
        equal(vm.subject, 'bar');
    });
    test('<can-slot> Works alongside <content>', function () {
        var ViewModel = DefineMap.extend({
            subject: { value: 'Hello World' },
            body: { value: 'Later Gator' }
        });
        Component.extend({
            tag: 'my-email',
            view: stache('<can-slot name="subject" />' + '<content />'),
            ViewModel: ViewModel,
            leakScope: true
        });
        var renderer = stache('<my-email>' + '<can-template name="subject">' + '<p>{{subject}}</p>' + '</can-template>' + '<span>Some content</span>' + '</my-email>');
        var testView = renderer();
        equal(testView.firstChild.childNodes[0].firstChild.nodeValue, 'Hello World');
        equal(testView.firstChild.childNodes[1].firstChild.nodeValue, 'Some content');
    });
    test('<can-slot> Works alongside <content> with default content', function () {
        var ViewModel = DefineMap.extend({
            subject: { value: 'Hello World' },
            body: { value: 'Later Gator' }
        });
        Component.extend({
            tag: 'my-email',
            view: stache('<can-slot name="subject" />' + '<content>Default content</content>'),
            ViewModel: ViewModel,
            leakScope: true
        });
        var renderer = stache('<my-email>' + '<can-template name="subject">' + '<p>{{subject}}</p>' + '</can-template>' + '</my-email>');
        var testView = renderer();
        equal(testView.firstChild.childNodes[0].firstChild.nodeValue, 'Hello World');
        equal(testView.firstChild.childNodes[1].nodeValue, 'Default content');
    });
    test('<can-slot> Can be used conditionally and will remove bindings', function () {
        var ViewModel = DefineMap.extend('MyEmailVM', {
            subject: { value: 'Hello World' },
            showSubject: { value: true }
        });
        Component.extend({
            tag: 'my-email',
            view: stache('{{#if showSubject}}<can-slot name="subject" {this}="subject" />{{/if}}'),
            ViewModel: ViewModel
        });
        var renderer = stache('<my-email>' + '<can-template name="subject">' + '<p>{{this}}</p>' + '</can-template>' + '</my-email>');
        var testView = renderer();
        equal(testView.firstChild.firstChild.firstChild.nodeValue, 'Hello World');
        var vm = viewModel(testView.firstChild);
        vm.showSubject = false;
        QUnit.stop();
        QUnit.equal(testView.firstChild.children.length, 0);
        setTimeout(function () {
            QUnit.equal(vm.__bindEvents.subject.length, 0);
            QUnit.start();
        }, 50);
    });
});
/*can-component@3.3.0#test/component-test*/
define('can-component@3.3.0#test/component-test', function (require, exports, module) {
    require('./component-define-test');
    require('./component-map-test');
    require('./component-slot-test');
});
/*can@3.9.0-pre.0#component/component_test*/
define('can@3.9.0-pre.0#component/component_test', function (require, exports, module) {
    require('can-component/test/component-test');
});
/*can-event@3.5.0#async/async*/
define('can-event@3.5.0#async/async', function (require, exports, module) {
    (function (global) {
        var canEvent = require('can-event');
        var canBatch = require('can-event/batch/batch');
        var setImmediate = require('can-util/js/set-immediate/set-immediate');
        var GLOBAL = require('can-util/js/global/global')();
        var assign = require('can-util/js/assign/assign');
        var timeout;
        var clearImmediate = GLOBAL.clearImmediate || GLOBAL.clearTimeout;
        var syncBatchDispatch = canBatch.dispatch;
        var syncBatchQueue = canBatch.queue;
        var syncBatchFlush = canBatch.flush;
        var asyncMethods = {
            dispatch: function (ev) {
                var batchNum = typeof ev === 'object' && ev.batchNum;
                if (!canBatch.collecting() && (!batchNum || canBatch.batchNum !== batchNum)) {
                    canBatch.start();
                    timeout = setImmediate(canBatch.stop);
                }
                return syncBatchDispatch.apply(this, arguments);
            },
            queue: function () {
                if (!canBatch.collecting()) {
                    canBatch.start();
                    timeout = setImmediate(canBatch.stop);
                }
                return syncBatchQueue.apply(this, arguments);
            },
            flush: function () {
                if (isAsync && canBatch.collecting()) {
                    clearImmediate(timeout);
                    canBatch.stop();
                }
                canBatch.flush();
            }
        };
        var syncMethods = assign({ flush: syncBatchFlush }, canEvent);
        var isAsync = false;
        var eventAsync = {
            async: function () {
                assign(canEvent, asyncMethods);
                isAsync = true;
            },
            sync: function () {
                if (canBatch.collecting()) {
                    clearImmediate(timeout);
                    canBatch.stop();
                }
                assign(canEvent, syncMethods);
                isAsync = false;
            }
        };
        assign(eventAsync, asyncMethods);
        module.exports = eventAsync;
    }(function () {
        return this;
    }()));
});
/*can-compute@3.3.1#can-compute-async-test*/
define('can-compute@3.3.1#can-compute-async-test', function (require, exports, module) {
    var compute = require('can-compute');
    var QUnit = require('steal-qunit');
    require('can-event/batch/batch');
    var canAsync = require('can-event/async/async');
    QUnit.module('can-compute async', {
        setup: function () {
            canAsync.async();
        },
        teardown: function () {
            canAsync.sync();
        }
    });
    QUnit.asyncTest('async basics', 2, function () {
        var canAsync = require('can-event/async/async');
        canAsync.async();
        var first = compute('Justin');
        var last = compute('Meyer');
        var fullName = compute(function () {
            return first() + ' ' + last();
        });
        fullName.on('change', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'Payal Shah', 'newVal');
            QUnit.equal(oldVal, 'Justin Meyer', 'oldVal');
            QUnit.start();
        });
        first('Payal');
        last('Shah');
    });
    QUnit.asyncTest('async can immediately read', 4, function () {
        var canAsync = require('can-event/async/async');
        canAsync.async();
        var compute = require('can-compute');
        var first = compute('Justin');
        var last = compute('Meyer');
        var fullName = compute(function () {
            return first() + ' ' + last();
        });
        var firedEvents = false;
        fullName.on('change', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'Payal Shah', 'change newVal');
            QUnit.equal(oldVal, 'Justin Meyer', 'change oldVal');
            firedEvents = true;
            QUnit.start();
        });
        first('Payal');
        last('Shah');
        QUnit.equal(fullName(), 'Payal Shah');
        QUnit.ok(firedEvents, 'fired events');
    });
    test('setting compute.async with a observable dependency gets a new value and can re-compute', 4, function () {
        var c = compute(1);
        var add;
        var async = compute.async(1, function (curVal) {
            add = curVal;
            return c() + add;
        });
        equal(async(), 2, 'can read unbound');
        async.bind('change', function (ev, newVal, oldVal) {
            equal(newVal, 3, 'change new val');
            equal(oldVal, 2, 'change old val');
        });
        async(2);
        equal(async(), 3, 'can read unbound');
    });
    test('compute.async getter has correct when length === 1', function () {
        var m = {};
        var getterCompute = compute.async(false, function (singleArg) {
            equal(this, m, 'getter has the right context');
        }, m);
        getterCompute.bind('change', function () {
        });
    });
});
/*can-compute@3.3.1#proto-compute_test*/
define('can-compute@3.3.1#proto-compute_test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var Compute = require('can-compute/proto-compute');
    var canBatch = require('can-event/batch/');
    var canSymbol = require('can-symbol');
    var canReflect = require('can-reflect');
    QUnit.module('can/Compute');
    test('single value compute', function () {
        expect(2);
        var num = new Compute(1);
        num.bind('change', function (ev, newVal, oldVal) {
            equal(newVal, 2, 'newVal');
            equal(oldVal, 1, 'oldVal');
        });
        num.set(2);
    });
    test('inner computes values are not bound to', function () {
        var num = new Compute(1), numBind = num.addEventListener, numUnbind = num.removeEventListener;
        var bindCount = 0;
        num.addEventListener = function () {
            bindCount++;
            return numBind.apply(this, arguments);
        };
        num.removeEventListener = function () {
            bindCount--;
            return numUnbind.apply(this, arguments);
        };
        var outer = new Compute(function () {
            var inner = new Compute(function () {
                return num.get() + 1;
            });
            return 2 * inner.get();
        });
        var handler = function () {
        };
        outer.bind('change', handler);
        stop();
        setTimeout(function () {
            equal(bindCount, 1, 'compute only bound to once');
            start();
        }, 50);
    });
    test('compute.truthy', function () {
        var result = 0;
        var num = new Compute(3);
        var truthy = Compute.truthy(num);
        var tester = new Compute(function () {
            if (truthy.get()) {
                return ++result;
            } else {
                return ++result;
            }
        });
        tester.bind('change', function (ev, newVal, oldVal) {
            if (num.get() === 0) {
                equal(newVal, 2, '2 is the new val');
            } else if (num.get() === -1) {
                equal(newVal, 3, '3 is the new val');
            } else {
                ok(false, 'change should not be called');
            }
        });
        equal(tester.get(), 1, 'on bind, we call tester once');
        num.set(2);
        num.set(1);
        num.set(0);
        num.set(-1);
    });
    test('a binding compute does not double read', function () {
        var sourceAge = 30, timesComputeIsCalled = 0;
        var age = new Compute(function (newVal) {
            timesComputeIsCalled++;
            if (timesComputeIsCalled === 1) {
                ok(true, 'reading age to get value');
            } else if (timesComputeIsCalled === 2) {
                equal(newVal, 31, 'the second time should be an update');
            } else if (timesComputeIsCalled === 3) {
                ok(true, 'called after set to get the value');
            } else {
                ok(false, 'You\'ve called the callback ' + timesComputeIsCalled + ' times');
            }
            if (arguments.length) {
                sourceAge = newVal;
            } else {
                return sourceAge;
            }
        });
        var info = new Compute(function () {
            return 'I am ' + age.get();
        });
        var k = function () {
        };
        info.bind('change', k);
        equal(info.get(), 'I am 30');
        age.set(31);
        equal(info.get(), 'I am 31');
    });
    test('cloning a setter compute (#547)', function () {
        var name = new Compute('', function (newVal) {
            return this.txt + newVal;
        });
        var cloned = name.clone({ txt: '.' });
        cloned.set('-');
        equal(cloned.get(), '.-');
    });
    test('compute updated method uses get and old value (#732)', function () {
        expect(9);
        var input = { value: 1 };
        var value = new Compute('', {
            get: function () {
                return input.value;
            },
            set: function (newVal) {
                input.value = newVal;
            },
            on: function (update) {
                input.onchange = update;
            },
            off: function () {
                delete input.onchange;
            }
        });
        equal(value.get(), 1, 'original value');
        ok(!input.onchange, 'nothing bound');
        value.set(2);
        equal(value.get(), 2, 'updated value');
        equal(input.value, 2, 'updated input.value');
        value.bind('change', function (ev, newVal, oldVal) {
            equal(newVal, 3, 'newVal');
            equal(oldVal, 2, 'oldVal');
            value.unbind('change', this.Constructor);
        });
        ok(input.onchange, 'binding to onchange');
        input.value = 3;
        input.onchange({});
        ok(!input.onchange, 'removed binding');
        equal(value.get(), 3);
    });
    test('a compute updated by source changes within a batch is part of that batch', function () {
        var computeA = new Compute('a');
        var computeB = new Compute('b');
        var combined1 = new Compute(function () {
            return computeA.get() + ' ' + computeB.get();
        });
        var combined2 = new Compute(function () {
            return computeA.get() + ' ' + computeB.get();
        });
        var combo = new Compute(function () {
            return combined1.get() + ' ' + combined2.get();
        });
        var callbacks = 0;
        combo.bind('change', function () {
            if (callbacks === 0) {
                ok(true, 'called change once');
            } else {
                ok(false, 'called change multiple times');
            }
            callbacks++;
        });
        canBatch.start();
        computeA.set('A');
        computeB.set('B');
        canBatch.stop();
    });
    test('Compute.async can be like a normal getter', function () {
        var first = new Compute('Justin'), last = new Compute('Meyer'), fullName = Compute.async('', function () {
                return first.get() + ' ' + last.get();
            });
        equal(fullName.get(), 'Justin Meyer');
    });
    test('Compute.async operate on single value', function () {
        var a = new Compute(1);
        var b = new Compute(2);
        var obj = Compute.async({}, function (curVal) {
            if (a.get()) {
                curVal.a = a.get();
            } else {
                delete curVal.a;
            }
            if (b.get()) {
                curVal.b = b.get();
            } else {
                delete curVal.b;
            }
            return curVal;
        });
        obj.bind('change', function () {
        });
        deepEqual(obj.get(), {
            a: 1,
            b: 2
        }, 'object has all properties');
        a.set(0);
        deepEqual(obj.get(), { b: 2 }, 'removed a');
        b.set(0);
        deepEqual(obj.get(), {}, 'removed b');
    });
    test('Compute.async async changing value', function () {
        var a = new Compute(1);
        var b = new Compute(2);
        var async = Compute.async(undefined, function (curVal, setVal) {
            if (a.get()) {
                setTimeout(function () {
                    setVal('a');
                }, 10);
            } else if (b.get()) {
                setTimeout(function () {
                    setVal('b');
                }, 10);
            } else {
                return null;
            }
        });
        var changeArgs = [
                {
                    newVal: 'a',
                    oldVal: undefined,
                    run: function () {
                        a.set(0);
                    }
                },
                {
                    newVal: 'b',
                    oldVal: 'a',
                    run: function () {
                        b.set(0);
                    }
                },
                {
                    newVal: null,
                    oldVal: 'b',
                    run: function () {
                        start();
                    }
                }
            ], changeNum = 0;
        stop();
        async.bind('change', function (ev, newVal, oldVal) {
            var data = changeArgs[changeNum++];
            equal(newVal, data.newVal, 'newVal is correct');
            equal(oldVal, data.oldVal, 'oldVal is correct');
            setTimeout(data.run, 10);
        });
    });
    test('Compute.async read without binding', function () {
        var source = new Compute(1);
        var async = Compute.async([], function (curVal, setVal) {
            curVal.push(source.get());
            return curVal;
        });
        ok(async.get(), 'calling async worked');
    });
    test('Compute.async set uses last set or initial value', function () {
        var add = new Compute(1);
        var fnCount = 0;
        var async = Compute.async(10, function (curVal) {
            switch (fnCount++) {
            case 0:
                equal(curVal, 10);
                break;
            case 1:
                equal(curVal, 20);
                break;
            case 2:
                equal(curVal, 30, 'on bind');
                break;
            case 3:
                equal(curVal, 30, 'on bind');
                break;
            }
            return curVal + add.get();
        });
        equal(async.get(), 11, 'initial value');
        async.set(20);
        async.bind('change', function () {
        });
        async.set(20);
        async.set(30);
    });
    test('Change propagation in a batch with late bindings (#2412)', function () {
        var rootA = new Compute('a');
        var rootB = new Compute('b');
        var childA = new Compute(function () {
            return 'childA' + rootA.get();
        });
        var grandChild = new Compute(function () {
            var b = rootB.get();
            if (b === 'b') {
                return 'grandChild->b';
            }
            var a = childA.get();
            return 'grandChild->' + a;
        });
        childA.bind('change', function (ev, newVal, oldVal) {
        });
        grandChild.bind('change', function (ev, newVal, oldVal) {
            equal(newVal, 'grandChild->childAA');
        });
        canBatch.start();
        rootA.set('A');
        rootB.set('B');
        canBatch.stop();
    });
    if (Compute.prototype.trace) {
        test('trace', function () {
            var rootA = new Compute('a');
            var rootB = new Compute('b');
            var childA = new Compute(function () {
                return 'childA' + rootA.get();
            });
            var fn = function () {
                var b = rootB.get();
                if (b === 'b') {
                    return 'grandChild->b';
                }
                var a = childA.get();
                return 'grandChild->' + a;
            };
            var grandChild = new Compute(fn);
            childA.bind('change', function (ev, newVal, oldVal) {
            });
            grandChild.bind('change', function (ev, newVal, oldVal) {
                equal(newVal, 'grandChild->childAA');
            });
            var out = grandChild.trace();
            equal(out.definition, fn, 'got the right function');
            equal(out.computeValue, 'grandChild->b');
            grandChild.log();
            canBatch.start();
            rootA.set('A');
            rootB.set('B');
            canBatch.stop();
            grandChild.log();
        });
    }
    test('works with can-reflect', 5, function () {
        var c = new Compute(0);
        QUnit.equal(canReflect.getValue(c), 0, 'unbound value');
        QUnit.ok(canReflect.isValueLike(c), 'isValueLike is true');
        QUnit.ok(!canReflect.valueHasDependencies(c), 'valueHasDependencies -- false');
        var d = new Compute(function () {
            return c.get();
        });
        d.on('change', function () {
        });
        QUnit.ok(canReflect.valueHasDependencies(d), 'valueHasDependencies -- true');
        c.set(1);
        QUnit.equal(canReflect.getValue(d), 1, 'bound value');
        c.set(2);
    });
    QUnit.test('can-reflect setValue', function () {
        var a = new Compute('a');
        canReflect.setValue(a, 'A');
        QUnit.equal(a.get(), 'A', 'compute');
    });
    QUnit.test('registered symbols', function () {
        var a = new Compute('a');
        ok(a[canSymbol.for('can.isValueLike')], 'can.isValueLike');
        equal(a[canSymbol.for('can.getValue')](), 'a', 'can.getValue');
        a[canSymbol.for('can.setValue')]('b');
        equal(a.get(), 'b', 'can.setValue');
        function handler(val) {
            equal(val, 'c', 'can.onValue');
        }
        a[canSymbol.for('can.onValue')](handler);
        a.set('c');
        a[canSymbol.for('can.offValue')](handler);
        a.set('d');
    });
});
/*can-compute@3.3.1#can-compute_test*/
define('can-compute@3.3.1#can-compute_test', function (require, exports, module) {
    require('./can-compute-async-test');
    require('./proto-compute_test');
    var compute = require('can-compute');
    var QUnit = require('steal-qunit');
    var canBatch = require('can-event/batch/');
    var Observation = require('can-observation');
    var domDispatch = require('can-util/dom/dispatch/dispatch');
    var canSymbol = require('can-symbol');
    var canReflect = require('can-reflect');
    QUnit.module('can/compute');
    test('single value compute', function () {
        var num = compute(1);
        num.on('change', function (ev, newVal, oldVal) {
            equal(newVal, 2, 'newVal');
            equal(oldVal, 1, 'oldVal');
        });
        num(2);
    });
    test('inner computes values are not bound to', function () {
        var num = compute(1);
        var outer = compute(function () {
            var inner = compute(function () {
                return num() + 1;
            });
            return 2 * inner();
        });
        var handler = function () {
        };
        outer.on('change', handler);
        stop();
        setTimeout(function () {
            equal(num.computeInstance.__bindEvents._lifecycleBindings, 1, 'inner compute only bound once');
            equal(outer.computeInstance.__bindEvents._lifecycleBindings, 1, 'outer compute only bound once');
            start();
        }, 50);
    });
    test('compute.truthy', function () {
        var result = 0;
        var numValue;
        var num = compute(numValue = 3);
        var truthy = compute.truthy(num);
        var tester = compute(function () {
            if (truthy()) {
                return ++result;
            } else {
                return ++result;
            }
        });
        tester.addEventListener('change', function (ev, newVal, oldVal) {
            if (num() === 0) {
                equal(newVal, 2, '2 is the new val');
            } else if (num() === -1) {
                equal(newVal, 3, '3 is the new val');
            } else {
                ok(false, 'change should not be called');
            }
        });
        equal(tester(), 1, 'on bind, we call tester once');
        num(numValue = 2);
        num(numValue = 1);
        num(numValue = 0);
        num(numValue = -1);
    });
    test('a binding compute does not double read', function () {
        var sourceAge = 30, timesComputeIsCalled = 0;
        var age = compute(function (newVal) {
            timesComputeIsCalled++;
            if (timesComputeIsCalled === 1) {
                ok(true, 'reading age to get value');
            } else if (timesComputeIsCalled === 2) {
                equal(newVal, 31, 'the second time should be an update');
            } else if (timesComputeIsCalled === 3) {
                ok(true, 'called after set to get the value');
            } else {
                ok(false, 'You\'ve called the callback ' + timesComputeIsCalled + ' times');
            }
            if (arguments.length) {
                sourceAge = newVal;
            } else {
                return sourceAge;
            }
        });
        var info = compute(function () {
            return 'I am ' + age();
        });
        var k = function () {
        };
        info.bind('change', k);
        equal(info(), 'I am 30');
        age(31);
        equal(info(), 'I am 31');
    });
    test('cloning a setter compute (#547)', function () {
        var name = compute('', function (newVal) {
            return this.txt + newVal;
        });
        var cloned = name.clone({ txt: '.' });
        cloned('-');
        equal(cloned(), '.-');
    });
    test('compute updated method uses get and old value (#732)', function () {
        expect(9);
        var input = { value: 1 };
        var value = compute('', {
            get: function () {
                return input.value;
            },
            set: function (newVal) {
                input.value = newVal;
            },
            on: function (update) {
                input.onchange = update;
            },
            off: function () {
                delete input.onchange;
            }
        });
        equal(value(), 1, 'original value');
        ok(!input.onchange, 'nothing bound');
        value(2);
        equal(value(), 2, 'updated value');
        equal(input.value, 2, 'updated input.value');
        value.bind('change', function (ev, newVal, oldVal) {
            equal(newVal, 3, 'newVal');
            equal(oldVal, 2, 'oldVal');
            value.unbind('change', this.Constructor);
        });
        ok(input.onchange, 'binding to onchange');
        input.value = 3;
        input.onchange({});
        ok(!input.onchange, 'removed binding');
        equal(value(), 3);
    });
    test('a compute updated by source changes within a batch is part of that batch', function () {
        var computeA = compute('a');
        var computeB = compute('b');
        var combined1 = compute(function () {
            return computeA() + ' ' + computeB();
        });
        var combined2 = compute(function () {
            return computeA() + ' ' + computeB();
        });
        var combo = compute(function () {
            return combined1() + ' ' + combined2();
        });
        var callbacks = 0;
        combo.bind('change', function () {
            if (callbacks === 0) {
                ok(true, 'called change once');
            } else {
                ok(false, 'called change multiple times');
            }
            callbacks++;
        });
        canBatch.start();
        computeA('A');
        computeB('B');
        canBatch.stop();
    });
    test('compute.async can be like a normal getter', function () {
        var first = compute('Justin'), last = compute('Meyer'), fullName = compute.async('', function () {
                return first() + ' ' + last();
            });
        equal(fullName(), 'Justin Meyer');
    });
    test('compute.async operate on single value', function () {
        var a = compute(1);
        var b = compute(2);
        var obj = compute.async({}, function (curVal) {
            if (a()) {
                curVal.a = a();
            } else {
                delete curVal.a;
            }
            if (b()) {
                curVal.b = b();
            } else {
                delete curVal.b;
            }
            return curVal;
        });
        obj.bind('change', function () {
        });
        deepEqual(obj(), {
            a: 1,
            b: 2
        }, 'object has all properties');
        a(0);
        deepEqual(obj(), { b: 2 }, 'removed a');
        b(0);
        deepEqual(obj(), {}, 'removed b');
    });
    test('compute.async async changing value', function () {
        var a = compute(1);
        var b = compute(2);
        var async = compute.async(undefined, function (curVal, setVal) {
            if (a()) {
                setTimeout(function () {
                    setVal('a');
                }, 10);
            } else if (b()) {
                setTimeout(function () {
                    setVal('b');
                }, 10);
            } else {
                return null;
            }
        });
        var changeArgs = [
                {
                    newVal: 'a',
                    oldVal: undefined,
                    run: function () {
                        a(0);
                    }
                },
                {
                    newVal: 'b',
                    oldVal: 'a',
                    run: function () {
                        b(0);
                    }
                },
                {
                    newVal: null,
                    oldVal: 'b',
                    run: function () {
                        start();
                    }
                }
            ], changeNum = 0;
        stop();
        async.bind('change', function (ev, newVal, oldVal) {
            var data = changeArgs[changeNum++];
            equal(newVal, data.newVal, 'newVal is correct');
            equal(oldVal, data.oldVal, 'oldVal is correct');
            setTimeout(data.run, 10);
        });
    });
    test('compute.async read without binding', function () {
        var source = compute(1);
        var async = compute.async([], function (curVal, setVal) {
            curVal.push(source());
            return curVal;
        });
        ok(async(), 'calling async worked');
    });
    test('bug with nested computes and batch ordering (#1519)', function () {
        var root = compute('a');
        var isA = compute(function () {
            return root() === 'a';
        });
        var isB = compute(function () {
            return root() === 'b';
        });
        var combined = compute(function () {
            var valA = isA(), valB = isB();
            return valA || valB;
        });
        equal(combined(), true);
        combined.bind('change', function () {
        });
        canBatch.start();
        root('b');
        canBatch.stop();
        equal(combined(), true);
    });
    test('compute change handler context is set to the function not compute', function () {
        var comp = compute(null);
        comp.bind('change', function () {
            equal(typeof this, 'function');
        });
        comp('test');
    });
    test('Calling .unbind() on un-bound compute does not throw an error', function () {
        var count = compute(0);
        count.unbind('change');
        ok(true, 'No error was thrown');
    });
    test('dependent computes update in the right order (2093)', function () {
        var root = compute('a'), childB = compute(function () {
                return root();
            }), combine = compute(function () {
                return root() + childB();
            });
        combine.bind('change', function (ev, newVal) {
            equal(newVal, 'bb', 'concat changed');
        });
        root('b');
    });
    test('dependent computes update in the right order with a batch (#2093)', function () {
        var root = compute('a'), child = compute(function () {
                return root();
            }), child2 = compute(function () {
                return root();
            }), grandChild = compute(function () {
                return child();
            }), combine = compute(function () {
                return child2() + grandChild();
            });
        combine.bind('change', function (ev, newVal) {
            equal(newVal, 'bb', 'concat changed');
        });
        canBatch.start();
        root('b');
        canBatch.stop();
    });
    test('bug with nested computes and batch ordering (#1519)', function () {
        var root = compute('a');
        var isA = compute(function () {
            return root() === 'a';
        });
        var isB = compute(function () {
            return root() === 'b';
        });
        var combined = compute(function () {
            var valA = isA(), valB = isB();
            return valA || valB;
        });
        equal(combined(), true);
        combined.bind('change', function () {
        });
        canBatch.start();
        root('b');
        canBatch.stop();
        equal(combined(), true);
    });
    test('binding, unbinding, and rebinding works after a timeout (#2095)', function () {
        var root = compute(1), derived = compute(function () {
                return root();
            });
        var change = function () {
        };
        derived.bind('change', change);
        derived.unbind('change', change);
        stop();
        setTimeout(function () {
            derived.bind('change', function (ev, newVal, oldVal) {
                equal(newVal, 2, 'updated');
                start();
            });
            root(2);
        }, 10);
    });
    test('Observation.isRecording observes doesn\'t understand Observation.ignore (#2099)', function () {
        expect(0);
        var c = compute(1);
        c.computeInstance.bind = function () {
            ok(false);
        };
        var outer = compute(function () {
            Observation.ignore(function () {
                c();
            })();
        });
        outer.bind('change', function () {
        });
    });
    test('handles missing update order items (#2121)', function () {
        var root1 = compute('root1'), child1 = compute(function () {
                return root1();
            }), root2 = compute('root2'), child2 = compute(function () {
                return root2();
            }), gc2 = compute(function () {
                return child2();
            }), res = compute(function () {
                return child1() + gc2();
            });
        res.bind('change', function (ev, newVal) {
            equal(newVal, 'ROOT1root2');
        });
        canBatch.start();
        root1('ROOT1');
        canBatch.stop();
    });
    test('compute should not fire event when NaN is set multiple times #2128', function () {
        var c = compute(NaN);
        compute.bind('change', function () {
            ok(false, 'change event should not be fired');
        });
        ok(isNaN(c()));
        c(NaN);
    });
    test('canBatch.afterPreviousEvents firing too late (#2198)', function () {
        var compute1 = compute('a'), compute2 = compute('b');
        var derived = compute(function () {
            return compute1().toUpperCase();
        });
        derived.bind('change', function () {
            var afterPrevious = false;
            compute2.bind('change', function () {
                ok(afterPrevious, 'after previous should have fired so we would respond to this event');
            });
            canBatch.start();
            canBatch.stop();
            canBatch.afterPreviousEvents(function () {
                afterPrevious = true;
            });
            compute2('c');
        });
        canBatch.start();
        compute1('x');
        canBatch.stop();
    });
    test('Async getter causes infinite loop (#28)', function () {
        var changeCount = 0;
        var idCompute = compute(1);
        stop();
        var comp = compute.async(undefined, function (last, resolve) {
            var id = idCompute();
            setTimeout(function () {
                resolve(changeCount + '|' + id);
            }, 1);
            resolve(changeCount + '|' + id);
        }, null);
        comp.bind('change', function (ev, newVal) {
            changeCount++;
            comp();
        });
        setTimeout(function () {
            idCompute(2);
        }, 50);
        var checkChangeCount = function () {
            if (changeCount === 4) {
                equal(changeCount, 4);
                start();
            } else {
                setTimeout(checkChangeCount, 10);
            }
        };
        checkChangeCount();
    });
    test('Listening to input change', function () {
        var input = document.createElement('input');
        var comp = compute(input, 'value', 'input');
        comp.on('change', function () {
            ok(true, 'it changed');
        });
        input.value = 'foo';
        domDispatch.call(input, 'input');
    });
    test('Setting an input to change', function () {
        var input = document.createElement('input');
        var comp = compute(input, 'value', 'input');
        comp('foo');
        ok(input.value === 'foo');
    });
    test('compute.truthy with functions (canjs/can-stache#172)', function () {
        var func = compute(function () {
            return function () {
                ok(false, 'should not be run');
            };
        });
        var truthy = compute.truthy(func);
        equal(truthy(), true);
    });
    test('works with can-reflect', 5, function () {
        var c = compute(0);
        QUnit.equal(canReflect.getValue(c), 0, 'unbound value');
        var handler = function (newValue) {
            QUnit.equal(newValue, 1, 'observed new value');
            canReflect.offValue(c, handler);
        };
        QUnit.ok(canReflect.isValueLike(c), 'isValueLike is true');
        canReflect.onValue(c, handler);
        QUnit.equal(canReflect.valueHasDependencies(c), undefined, 'valueHasDependencies');
        c(1);
        QUnit.equal(canReflect.getValue(c), 1, 'bound value');
        c(2);
    });
    QUnit.test('can-reflect valueHasDependencies', function () {
        var a = compute('a');
        var b = compute('b');
        var c = compute(function () {
            return a() + b();
        });
        c.on('change', function () {
        });
        QUnit.ok(canReflect.valueHasDependencies(c), 'valueHasDependencies');
    });
    QUnit.test('registered symbols', function () {
        var a = compute('a');
        ok(a[canSymbol.for('can.isValueLike')], 'can.isValueLike');
        equal(a[canSymbol.for('can.getValue')](), 'a', 'can.getValue');
        a[canSymbol.for('can.setValue')]('b');
        equal(a(), 'b', 'can.setValue');
        function handler(val) {
            equal(val, 'c', 'can.onValue');
        }
        a[canSymbol.for('can.onValue')](handler);
        a('c');
        a[canSymbol.for('can.offValue')](handler);
        a('d');
    });
    QUnit.test('can-reflect setValue', function () {
        var a = compute('a');
        canReflect.setValue(a, 'A');
        QUnit.equal(a(), 'A', 'compute');
    });
});
/*can@3.9.0-pre.0#compute/compute_test*/
define('can@3.9.0-pre.0#compute/compute_test', function (require, exports, module) {
    require('can-compute/can-compute_test');
});
/*can-construct@3.2.0#can-construct_test*/
define('can-construct@3.2.0#can-construct_test', function (require, exports, module) {
    (function (global) {
        QUnit = require('steal-qunit');
        var Construct = require('can-construct');
        var dev = require('can-util/js/dev/');
        var makeArray = require('can-util/js/make-array/');
        QUnit.module('can-construct', {
            setup: function () {
                var Animal = this.Animal = Construct.extend({
                    count: 0,
                    test: function () {
                        return this.match ? true : false;
                    }
                }, {
                    init: function () {
                        this.constructor.count++;
                        this.eyes = false;
                    }
                });
                var Dog = this.Dog = this.Animal.extend({ match: /abc/ }, {
                    init: function () {
                        Animal.prototype.init.apply(this, arguments);
                    },
                    talk: function () {
                        return 'Woof';
                    }
                });
                this.Ajax = this.Dog.extend({ count: 0 }, {
                    init: function (hairs) {
                        Dog.prototype.init.apply(this, arguments);
                        this.hairs = hairs;
                        this.setEyes();
                    },
                    setEyes: function () {
                        this.eyes = true;
                    }
                });
            }
        });
        test('inherit', function () {
            var Base = Construct({});
            ok(new Base() instanceof Construct);
            var Inherit = Base({});
            ok(new Inherit() instanceof Base);
        });
        test('Creating', function () {
            new this.Dog();
            var a1 = new this.Animal();
            new this.Animal();
            var ajax = new this.Ajax(1000);
            equal(2, this.Animal.count, 'right number of animals');
            equal(1, this.Dog.count, 'right number of animals');
            ok(this.Dog.match, 'right number of animals');
            ok(!this.Animal.match, 'right number of animals');
            ok(this.Dog.test(), 'right number of animals');
            ok(!this.Animal.test(), 'right number of animals');
            equal(1, this.Ajax.count, 'right number of animals');
            equal(2, this.Animal.count, 'right number of animals');
            equal(true, ajax.eyes, 'right number of animals');
            equal(1000, ajax.hairs, 'right number of animals');
            ok(a1 instanceof this.Animal);
            ok(a1 instanceof Construct);
        });
        test('new instance', function () {
            var d = this.Ajax.newInstance(6);
            equal(6, d.hairs);
        });
        test('namespaces', function () {
            var fb = Construct.extend('Bar');
            ok(!window.Bar, 'not added to global namespace');
            equal(fb.shortName, 'Bar', 'short name is right');
        });
        test('setups', function () {
            var order = 0, staticSetup, staticSetupArgs, staticInit, staticInitArgs, protoSetup, protoInitArgs, protoInit, staticProps = {
                    setup: function () {
                        staticSetup = ++order;
                        staticSetupArgs = arguments;
                        return ['something'];
                    },
                    init: function () {
                        staticInit = ++order;
                        staticInitArgs = arguments;
                    }
                }, protoProps = {
                    setup: function (name) {
                        protoSetup = ++order;
                        return ['Ford: ' + name];
                    },
                    init: function () {
                        protoInit = ++order;
                        protoInitArgs = arguments;
                    }
                };
            var Car = Construct.extend('Car', staticProps, protoProps);
            new Car('geo');
            equal(staticSetup, 1);
            equal(staticInit, 2);
            equal(protoSetup, 3);
            equal(protoInit, 4);
            deepEqual(makeArray(staticInitArgs), ['something']);
            deepEqual(makeArray(protoInitArgs), ['Ford: geo']);
            deepEqual(makeArray(staticSetupArgs), [
                Construct,
                'Car',
                staticProps,
                protoProps
            ], 'static construct');
            Car.extend('Truck');
            equal(staticSetup, 5, 'Static setup is called if overwriting');
        });
        test('Creating without extend', function () {
            var Bar = Construct('Bar', {
                ok: function () {
                    ok(true, 'ok called');
                }
            });
            new Bar().ok();
            var Foo = Bar('Foo', {
                dude: function () {
                    ok(true, 'dude called');
                }
            });
            new Foo().dude(true);
        });
        test('setup called with original arguments', function () {
            var o2 = {};
            var o1 = {
                setup: function (base, arg1, arg2) {
                    equal(o1, arg1, 'first argument is correct');
                    equal(o2, arg2, 'second argument is correct');
                }
            };
            Construct.extend(o1, o2);
        });
        test('legacy namespace strings (A.B.C) accepted', function () {
            var Type = Construct.extend('Foo.Bar.Baz');
            var expectedValue = ~steal.config('env').indexOf('production') ? '' : 'Foo_Bar_Baz';
            ok(new Type() instanceof Construct, 'No unexpected behavior in the prototype chain');
            if (Function.prototype.name) {
                equal(Type.name, expectedValue, 'Name becomes underscored');
            }
        });
        test('reserved words accepted', function () {
            var Type = Construct.extend('const');
            var expectedValue = ~steal.config('env').indexOf('production') ? '' : 'Const';
            ok(new Type() instanceof Construct, 'No unexpected behavior in the prototype chain');
            if (Function.prototype.name) {
                equal(Type.name, expectedValue, 'Name becomes capitalized');
            }
        });
        test('basic injection attacks thwarted', function () {
            var rootToken = typeof window === 'undefined' ? 'global' : 'window';
            var rootObject = typeof window === 'undefined' ? global : window;
            var expando = 'foo' + Math.random().toString(10).slice(2);
            var MalignantType;
            try {
                MalignantType = Construct.extend('(){};' + rootToken + '.' + expando + '=\'bar\';var f=function');
            } catch (e) {
            } finally {
                equal(rootObject[expando], undefined, 'Injected code doesn\'t run');
            }
            delete rootObject[expando];
            try {
                MalignantType = Construct.extend('(){},' + rootToken + '.' + expando + '=\'baz\',function');
            } catch (e) {
            } finally {
                equal(rootObject[expando], undefined, 'Injected code doesn\'t run');
            }
        });
        QUnit.test('setters not invoked on extension (#28)', function () {
            var extending = true;
            var Base = Construct.extend('Base', {
                set something(value) {
                    QUnit.ok(!extending, 'called when not extending');
                },
                get something() {
                }
            });
            Base.extend('Extended', { something: 'value' });
            extending = false;
            new Base().something = 'foo';
        });
        QUnit.test('return alternative value simple', function () {
            var Alternative = function () {
            };
            var Base = Construct.extend({
                setup: function () {
                    return new Construct.ReturnValue(new Alternative());
                }
            });
            QUnit.ok(new Base() instanceof Alternative, 'Should create an instance of Alternative');
        });
        QUnit.test('return alternative value on setup (full case)', function () {
            var Student = function (name, school) {
                this.name = name;
                this.school = school;
                this.isStudent = true;
            };
            var Person = Construct.extend({
                setup: function (opts) {
                    if (opts.age >= 16) {
                        return new Construct.ReturnValue(new Student(opts.name, opts.school));
                    }
                    opts.isStudent = false;
                    return [opts];
                },
                init: function (params) {
                    this.age = params.age;
                    this.name = params.name;
                    this.isStudent = params.isStudent;
                }
            });
            QUnit.equal(new Person({ age: 12 }).isStudent, false, 'Age 12 cannot be a student');
            QUnit.equal(new Person({ age: 30 }).isStudent, true, 'Age 20 can be a student');
            QUnit.ok(new Person({ age: 30 }) instanceof Student, 'Should return an instance of Student');
        });
    }(function () {
        return this;
    }()));
});
/*can@3.9.0-pre.0#construct/construct_test*/
define('can@3.9.0-pre.0#construct/construct_test', function (require, exports, module) {
    require('can-construct/can-construct_test');
});
/*can-util@3.9.6#js/omit/omit*/
define('can-util@3.9.6#js/omit/omit', function (require, exports, module) {
    'use strict';
    module.exports = function (source, propsToOmit) {
        var result = {};
        for (var prop in source) {
            if (propsToOmit.indexOf(prop) < 0) {
                result[prop] = source[prop];
            }
        }
        return result;
    };
});
/*can-param@1.0.1#can-param*/
define('can-param@1.0.1#can-param', function (require, exports, module) {
    var namespace = require('can-namespace');
    function buildParam(prefix, obj, add) {
        if (Array.isArray(obj)) {
            for (var i = 0, l = obj.length; i < l; ++i) {
                add(prefix + '[]', obj[i]);
            }
        } else if (obj && typeof obj === 'object') {
            for (var name in obj) {
                buildParam(prefix + '[' + name + ']', obj[name], add);
            }
        } else {
            add(prefix, obj);
        }
    }
    module.exports = namespace.param = function param(object) {
        var pairs = [], add = function (key, value) {
                pairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
            };
        for (var name in object) {
            buildParam(name, object[name], add);
        }
        return pairs.join('&').replace(/%20/g, '+');
    };
});
/*can-util@3.9.6#dom/ajax/ajax*/
define('can-util@3.9.6#dom/ajax/ajax', function (require, exports, module) {
    (function (global) {
        'use strict';
        var Global = require('../../js/global/global');
        var assign = require('../../js/assign/assign');
        var namespace = require('can-namespace');
        var parseURI = require('../../js/parse-uri/parse-uri');
        var param = require('can-param');
        var xhrs = [
                function () {
                    return new XMLHttpRequest();
                },
                function () {
                    return new ActiveXObject('Microsoft.XMLHTTP');
                },
                function () {
                    return new ActiveXObject('MSXML2.XMLHTTP.3.0');
                },
                function () {
                    return new ActiveXObject('MSXML2.XMLHTTP');
                }
            ], _xhrf = null;
        var originUrl = parseURI(Global().location.href);
        var makeXhr = function () {
            if (_xhrf != null) {
                return _xhrf();
            }
            for (var i = 0, l = xhrs.length; i < l; i++) {
                try {
                    var f = xhrs[i], req = f();
                    if (req != null) {
                        _xhrf = f;
                        return req;
                    }
                } catch (e) {
                    continue;
                }
            }
            return function () {
            };
        };
        var contentTypes = {
            json: 'application/json',
            form: 'application/x-www-form-urlencoded'
        };
        var _xhrResp = function (xhr, options) {
            switch (options.dataType || xhr.getResponseHeader('Content-Type').split(';')[0]) {
            case 'text/xml':
            case 'xml':
                return xhr.responseXML;
            case 'text/json':
            case 'application/json':
            case 'text/javascript':
            case 'application/javascript':
            case 'application/x-javascript':
            case 'json':
                return JSON.parse(xhr.responseText);
            default:
                return xhr.responseText;
            }
        };
        module.exports = namespace.ajax = function (o) {
            var xhr = makeXhr(), timer, n = 0;
            var deferred = {};
            var promise = new Promise(function (resolve, reject) {
                deferred.resolve = resolve;
                deferred.reject = reject;
            });
            var requestUrl;
            promise.abort = function () {
                xhr.abort();
            };
            o = assign({
                userAgent: 'XMLHttpRequest',
                lang: 'en',
                type: 'GET',
                data: null,
                dataType: 'json'
            }, o);
            if (!o.contentType) {
                o.contentType = o.type.toUpperCase() === 'GET' ? contentTypes.form : contentTypes.json;
            }
            if (o.crossDomain == null) {
                try {
                    requestUrl = parseURI(o.url);
                    o.crossDomain = !!(requestUrl.protocol && requestUrl.protocol !== originUrl.protocol || requestUrl.host && requestUrl.host !== originUrl.host);
                } catch (e) {
                    o.crossDomain = true;
                }
            }
            if (o.timeout) {
                timer = setTimeout(function () {
                    xhr.abort();
                    if (o.timeoutFn) {
                        o.timeoutFn(o.url);
                    }
                }, o.timeout);
            }
            xhr.onreadystatechange = function () {
                try {
                    if (xhr.readyState === 4) {
                        if (timer) {
                            clearTimeout(timer);
                        }
                        if (xhr.status < 300) {
                            if (o.success) {
                                o.success(_xhrResp(xhr, o));
                            }
                        } else if (o.error) {
                            o.error(xhr, xhr.status, xhr.statusText);
                        }
                        if (o.complete) {
                            o.complete(xhr, xhr.statusText);
                        }
                        if (xhr.status >= 200 && xhr.status < 300) {
                            deferred.resolve(_xhrResp(xhr, o));
                        } else {
                            deferred.reject(xhr);
                        }
                    } else if (o.progress) {
                        o.progress(++n);
                    }
                } catch (e) {
                    deferred.reject(e);
                }
            };
            var url = o.url, data = null, type = o.type.toUpperCase();
            var isJsonContentType = o.contentType === contentTypes.json;
            var isPost = type === 'POST' || type === 'PUT';
            if (!isPost && o.data) {
                url += '?' + (isJsonContentType ? JSON.stringify(o.data) : param(o.data));
            }
            xhr.open(type, url);
            var isSimpleCors = o.crossDomain && [
                'GET',
                'POST',
                'HEAD'
            ].indexOf(type) !== -1;
            if (isPost) {
                data = isJsonContentType && !isSimpleCors ? typeof o.data === 'object' ? JSON.stringify(o.data) : o.data : param(o.data);
                var setContentType = isJsonContentType && !isSimpleCors ? 'application/json' : 'application/x-www-form-urlencoded';
                xhr.setRequestHeader('Content-Type', setContentType);
            } else {
                xhr.setRequestHeader('Content-Type', o.contentType);
            }
            if (!isSimpleCors) {
                xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
            }
            xhr.send(data);
            return promise;
        };
    }(function () {
        return this;
    }()));
});
/*can-util@3.9.6#dom/dom*/
define('can-util@3.9.6#dom/dom', function (require, exports, module) {
    (function (global) {
        'use strict';
        module.exports = {
            ajax: require('./ajax/ajax'),
            attr: require('./attr/attr'),
            childNodes: require('./child-nodes/child-nodes'),
            className: require('./class-name/class-name'),
            contains: require('./contains/contains'),
            data: require('./data/data'),
            dispatch: require('./dispatch/dispatch'),
            document: require('./document/document'),
            events: require('./events/events'),
            frag: require('./frag/frag'),
            fragment: require('./fragment/fragment'),
            isOfGlobalDocument: require('./is-of-global-document/is-of-global-document'),
            matches: require('./matches/matches'),
            mutate: require('./mutate/mutate'),
            mutationObserver: require('./mutation-observer/mutation-observer')
        };
    }(function () {
        return this;
    }()));
});
/*can-util@3.9.6#js/is-node/is-node*/
define('can-util@3.9.6#js/is-node/is-node', function (require, exports, module) {
    (function (global) {
        'use strict';
        module.exports = function () {
            return typeof process === 'object' && {}.toString.call(process) === '[object process]';
        };
    }(function () {
        return this;
    }()));
});
/*can-util@3.9.6#js/is-string/is-string*/
define('can-util@3.9.6#js/is-string/is-string', function (require, exports, module) {
    'use strict';
    module.exports = function isString(obj) {
        return typeof obj === 'string';
    };
});
/*can-util@3.9.6#js/is-web-worker/is-web-worker*/
define('can-util@3.9.6#js/is-web-worker/is-web-worker', function (require, exports, module) {
    (function (global) {
        'use strict';
        module.exports = function () {
            return typeof WorkerGlobalScope !== 'undefined' && this instanceof WorkerGlobalScope;
        };
    }(function () {
        return this;
    }()));
});
/*can-util@3.9.6#js/js*/
define('can-util@3.9.6#js/js', function (require, exports, module) {
    (function (global) {
        'use strict';
        module.exports = {
            assign: require('./assign/assign'),
            cid: require('can-cid'),
            deepAssign: require('./deep-assign/deep-assign'),
            dev: require('./dev/dev'),
            diff: require('./diff/diff'),
            each: require('./each/each'),
            global: require('./global/global'),
            'import': require('./import/import'),
            isArray: require('./is-array/is-array'),
            isArrayLike: require('./is-array-like/is-array-like'),
            isBrowserWindow: require('./is-browser-window/is-browser-window'),
            isEmptyObject: require('./is-empty-object/is-empty-object'),
            isFunction: require('./is-function/is-function'),
            isNode: require('./is-node/is-node'),
            isPlainObject: require('./is-plain-object/is-plain-object'),
            isPromise: require('./is-promise/is-promise'),
            isString: require('./is-string/is-string'),
            isWebWorker: require('./is-web-worker/is-web-worker'),
            joinURIs: require('./join-uris/join-uris'),
            last: require('./last/last'),
            makeArray: require('./make-array/make-array'),
            omit: require('./omit/omit'),
            setImmediate: require('./set-immediate/set-immediate'),
            string: require('./string/string'),
            types: require('can-types')
        };
    }(function () {
        return this;
    }()));
});
/*can-util@3.9.6#can-util*/
define('can-util@3.9.6#can-util', function (require, exports, module) {
    var deepAssign = require('./js/deep-assign/deep-assign');
    var omit = require('./js/omit/omit');
    var namespace = require('can-namespace');
    module.exports = deepAssign(namespace, require('./dom/dom'), omit(require('./js/js'), [
        'cid',
        'types'
    ]));
});
/*can-construct-super@3.1.0#can-construct-super*/
define('can-construct-super@3.1.0#can-construct-super', function (require, exports, module) {
    (function (global) {
        var can = require('can-util');
        var Construct = require('can-construct');
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var isFunction = can.isFunction, fnTest = /xyz/.test(function () {
                return this.xyz;
            }) ? /\b_super\b/ : /.*/, getset = [
                'get',
                'set'
            ], getSuper = function (base, name, fn) {
                return function () {
                    var hasExistingValue = false;
                    var existingValue;
                    var prototype = getPrototypeOf(this);
                    var existingPrototypeValue = prototype._super;
                    if (hasOwnProperty.call(this, '_super')) {
                        hasExistingValue = true;
                        existingValue = this._super;
                        delete this._super;
                    }
                    prototype._super = base[name];
                    var ret = fn.apply(this, arguments);
                    prototype._super = existingPrototypeValue;
                    if (hasExistingValue) {
                        this._super = existingValue;
                    }
                    return ret;
                };
            };
        Construct._defineProperty = function (addTo, base, name, descriptor) {
            var _super = Object.getOwnPropertyDescriptor(base, name);
            if (_super) {
                can.each(getset, function (method) {
                    if (isFunction(_super[method]) && isFunction(descriptor[method])) {
                        descriptor[method] = getSuper(_super, method, descriptor[method]);
                    } else if (!isFunction(descriptor[method])) {
                        descriptor[method] = _super[method];
                    }
                });
            }
            Object.defineProperty(addTo, name, descriptor);
        };
        var getPrototypeOf = Object.getPrototypeOf || function (obj) {
            return obj.__proto__;
        };
        var getPropertyDescriptor = Object.getPropertyDescriptor || function (subject, name) {
            if (name in subject) {
                var pd = Object.getOwnPropertyDescriptor(subject, name);
                var proto = getPrototypeOf(subject);
                while (pd === undefined && proto !== null) {
                    pd = Object.getOwnPropertyDescriptor(proto, name);
                    proto = getPrototypeOf(proto);
                }
                return pd;
            }
        };
        Construct._overwrite = function (addTo, base, name, val) {
            var baseDescriptor = getPropertyDescriptor(base, name);
            var baseValue = baseDescriptor && baseDescriptor.value;
            Object.defineProperty(addTo, name, {
                value: isFunction(val) && isFunction(baseValue) && fnTest.test(val) ? getSuper(base, name, val) : val,
                configurable: true,
                enumerable: true,
                writable: true
            });
        };
        module.exports = Construct;
    }(function () {
        return this;
    }()));
});
/*can-construct-super@3.1.0#test/can-construct-super_test*/
define('can-construct-super@3.1.0#test/can-construct-super_test', function (require, exports, module) {
    (function (global) {
        var Construct = require('can-construct-super');
        var QUnit = require('steal-qunit');
        QUnit.module('can-construct-super');
        test('prototype super', function () {
            var A = Construct.extend({
                init: function (arg) {
                    this.arg = arg + 1;
                },
                add: function (num) {
                    return this.arg + num;
                }
            });
            var B = A({
                init: function (arg) {
                    this._super(arg + 2);
                },
                add: function (arg) {
                    return this._super(arg + 1);
                }
            });
            var b = new B(1);
            equal(b.arg, 4);
            equal(b.add(2), 7);
        });
        test('static super', function () {
            var First = Construct.extend({
                raise: function (num) {
                    return num;
                }
            }, {});
            var Second = First.extend({
                raise: function (num) {
                    return this._super(num) * num;
                }
            }, {});
            equal(Second.raise(2), 4);
        });
        test('findAll super', function () {
            var Parent = Construct.extend({
                findAll: function () {
                    equal(this.shortName, 'child');
                    return Promise.resolve();
                },
                shortName: 'parent'
            }, {});
            var Child = Parent.extend({
                findAll: function () {
                    return this._super();
                },
                shortName: 'child'
            }, {});
            stop();
            expect(1);
            Child.findAll({});
            start();
        });
        if (Object.getOwnPropertyDescriptor) {
            test('_super supports getters and setters', function () {
                var Person = Construct.extend({
                    get age() {
                        return 42;
                    },
                    set name(value) {
                        this._name = value;
                    },
                    get name() {
                        return this._name;
                    }
                });
                var OtherPerson = Person.extend({
                    get age() {
                        return this._super() + 8;
                    },
                    set name(value) {
                        this._super(value + '_super');
                    }
                });
                var test = new OtherPerson();
                test.base = 2;
                equal(test.age, 50, 'Getter and _super works');
                test.name = 'David';
                equal(test.name, 'David_super', 'Setter ran');
            });
        }
        QUnit.test('setters not invoked on extension (#9)', function () {
            var extending = true;
            var Base = Construct.extend('Base', {
                set something(value) {
                    QUnit.ok(!extending, 'set not called when not extending');
                },
                get something() {
                    QUnit.ok(!extending, 'get not called when not extending');
                }
            });
            Base.extend('Extended', { something: 'value' });
            extending = false;
            new Base().something = 'foo';
        });
        QUnit.test('_super isn\'t always available (#11)', function () {
            var Parent = Construct.extend({});
            var Child = Parent.extend({
                init: function () {
                    this._super();
                    ok(true);
                }
            });
            new Child();
        });
        QUnit.test('_super should work for sealed instances', function () {
            var A = Construct.extend({
                init: function (arg) {
                    this.arg = arg + 1;
                },
                add: function (num) {
                    return this.arg + num;
                }
            });
            var B = A({
                init: function (arg) {
                    this._super(arg + 2);
                },
                add: function (arg) {
                    console.log(this);
                    return this._super(arg + 1);
                }
            });
            var b = new B(1);
            Object.seal(b);
            equal(b.arg, 4, 'should instantiate properly');
            equal(b.add(2), 7, 'should call methods properly');
        });
    }(function () {
        return this;
    }()));
});
/*can-define@1.3.2#list/list*/
define('can-define@1.3.2#list/list', function (require, exports, module) {
    var Construct = require('can-construct');
    var define = require('can-define');
    var make = define.make;
    var canEvent = require('can-event');
    var canBatch = require('can-event/batch/batch');
    var Observation = require('can-observation');
    var canLog = require('can-util/js/log/log');
    var defineHelpers = require('../define-helpers/define-helpers');
    var assign = require('can-util/js/assign/assign');
    var diff = require('can-util/js/diff/diff');
    var each = require('can-util/js/each/each');
    var makeArray = require('can-util/js/make-array/make-array');
    var types = require('can-types');
    var ns = require('can-namespace');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var CIDSet = require('can-util/js/cid-set/cid-set');
    var CIDMap = require('can-util/js/cid-map/cid-map');
    var splice = [].splice;
    var runningNative = false;
    var identity = function (x) {
        return x;
    };
    var makeFilterCallback = function (props) {
        return function (item) {
            for (var prop in props) {
                if (item[prop] !== props[prop]) {
                    return false;
                }
            }
            return true;
        };
    };
    var DefineList = Construct.extend('DefineList', {
        setup: function (base) {
            if (DefineList) {
                var prototype = this.prototype;
                var result = define(prototype, prototype, base.prototype._define);
                var itemsDefinition = result.definitions['#'] || result.defaultDefinition;
                if (itemsDefinition) {
                    if (itemsDefinition.Type) {
                        this.prototype.__type = make.set.Type('*', itemsDefinition.Type, identity);
                    } else if (itemsDefinition.type) {
                        this.prototype.__type = make.set.type('*', itemsDefinition.type, identity);
                    }
                }
            }
        }
    }, {
        setup: function (items) {
            if (!this._define) {
                Object.defineProperty(this, '_define', {
                    enumerable: false,
                    value: { definitions: {} }
                });
                Object.defineProperty(this, '_data', {
                    enumerable: false,
                    value: {}
                });
            }
            define.setup.call(this, {}, false);
            this._length = 0;
            if (items) {
                this.splice.apply(this, [
                    0,
                    0
                ].concat(canReflect.toArray(items)));
            }
        },
        __type: define.types.observable,
        _triggerChange: function (attr, how, newVal, oldVal) {
            var index = +attr;
            if (!~('' + attr).indexOf('.') && !isNaN(index)) {
                var itemsDefinition = this._define.definitions['#'];
                if (how === 'add') {
                    if (itemsDefinition && typeof itemsDefinition.added === 'function') {
                        Observation.ignore(itemsDefinition.added).call(this, newVal, index);
                    }
                    canEvent.dispatch.call(this, how, [
                        newVal,
                        index
                    ]);
                } else if (how === 'remove') {
                    if (itemsDefinition && typeof itemsDefinition.removed === 'function') {
                        Observation.ignore(itemsDefinition.removed).call(this, oldVal, index);
                    }
                    canEvent.dispatch.call(this, how, [
                        oldVal,
                        index
                    ]);
                } else {
                    canEvent.dispatch.call(this, how, [
                        newVal,
                        index
                    ]);
                }
            } else {
                canEvent.dispatch.call(this, {
                    type: '' + attr,
                    target: this
                }, [
                    newVal,
                    oldVal
                ]);
            }
        },
        get: function (index) {
            if (arguments.length) {
                Observation.add(this, '' + index);
                return this[index];
            } else {
                return canReflect.unwrap(this, CIDMap);
            }
        },
        set: function (prop, value) {
            if (typeof prop !== 'object') {
                prop = isNaN(+prop) || prop % 1 ? prop : +prop;
                if (typeof prop === 'number') {
                    if (typeof prop === 'number' && prop > this._length - 1) {
                        var newArr = new Array(prop + 1 - this._length);
                        newArr[newArr.length - 1] = value;
                        this.push.apply(this, newArr);
                        return newArr;
                    }
                    this.splice(prop, 1, value);
                } else {
                    var defined = defineHelpers.defineExpando(this, prop, value);
                    if (!defined) {
                        this[prop] = value;
                    }
                }
            } else {
                if (canReflect.isListLike(prop)) {
                    if (value) {
                        this.replace(prop);
                    } else {
                        canReflect.assignList(this, prop);
                    }
                } else {
                    canReflect.assignMap(this, prop);
                }
            }
            return this;
        },
        _items: function () {
            var arr = [];
            this._each(function (item) {
                arr.push(item);
            });
            return arr;
        },
        _each: function (callback) {
            for (var i = 0, len = this._length; i < len; i++) {
                callback(this[i], i);
            }
        },
        splice: function (index, howMany) {
            var args = makeArray(arguments), added = [], i, len, listIndex, allSame = args.length > 2;
            index = index || 0;
            for (i = 0, len = args.length - 2; i < len; i++) {
                listIndex = i + 2;
                args[listIndex] = this.__type(args[listIndex], listIndex);
                added.push(args[listIndex]);
                if (this[i + index] !== args[listIndex]) {
                    allSame = false;
                }
            }
            if (allSame && this._length <= added.length) {
                return added;
            }
            if (howMany === undefined) {
                howMany = args[1] = this._length - index;
            }
            runningNative = true;
            var removed = splice.apply(this, args);
            runningNative = false;
            canBatch.start();
            if (howMany > 0) {
                this._triggerChange('' + index, 'remove', undefined, removed);
            }
            if (args.length > 2) {
                this._triggerChange('' + index, 'add', added, removed);
            }
            canEvent.dispatch.call(this, 'length', [this._length]);
            canBatch.stop();
            return removed;
        },
        serialize: function () {
            return canReflect.serialize(this, CIDMap);
        }
    });
    var getArgs = function (args) {
        return args[0] && Array.isArray(args[0]) ? args[0] : makeArray(args);
    };
    each({
        push: 'length',
        unshift: 0
    }, function (where, name) {
        var orig = [][name];
        DefineList.prototype[name] = function () {
            var args = [], len = where ? this._length : 0, i = arguments.length, res, val;
            while (i--) {
                val = arguments[i];
                args[i] = this.__type(val, i);
            }
            runningNative = true;
            res = orig.apply(this, args);
            runningNative = false;
            if (!this.comparator || args.length) {
                canBatch.start();
                this._triggerChange('' + len, 'add', args, undefined);
                canEvent.dispatch.call(this, 'length', [this._length]);
                canBatch.stop();
            }
            return res;
        };
    });
    each({
        pop: 'length',
        shift: 0
    }, function (where, name) {
        var orig = [][name];
        DefineList.prototype[name] = function () {
            if (!this._length) {
                return undefined;
            }
            var args = getArgs(arguments), len = where && this._length ? this._length - 1 : 0, res;
            runningNative = true;
            res = orig.apply(this, args);
            runningNative = false;
            canBatch.start();
            this._triggerChange('' + len, 'remove', undefined, [res]);
            canEvent.dispatch.call(this, 'length', [this._length]);
            canBatch.stop();
            return res;
        };
    });
    each({
        'map': 3,
        'filter': 3,
        'reduce': 4,
        'reduceRight': 4,
        'every': 3,
        'some': 3
    }, function a(fnLength, fnName) {
        DefineList.prototype[fnName] = function () {
            var self = this;
            var args = [].slice.call(arguments, 0);
            var callback = args[0];
            var thisArg = args[fnLength - 1] || self;
            if (typeof callback === 'object') {
                callback = makeFilterCallback(callback);
            }
            args[0] = function () {
                var cbArgs = [].slice.call(arguments, 0);
                cbArgs[fnLength - 3] = self.get(cbArgs[fnLength - 2]);
                return callback.apply(thisArg, cbArgs);
            };
            var ret = Array.prototype[fnName].apply(this, args);
            if (fnName === 'map') {
                return new DefineList(ret);
            } else if (fnName === 'filter') {
                return new self.constructor(ret);
            } else {
                return ret;
            }
        };
    });
    assign(DefineList.prototype, {
        indexOf: function (item, fromIndex) {
            for (var i = fromIndex || 0, len = this.length; i < len; i++) {
                if (this.get(i) === item) {
                    return i;
                }
            }
            return -1;
        },
        lastIndexOf: function (item, fromIndex) {
            fromIndex = typeof fromIndex === 'undefined' ? this.length - 1 : fromIndex;
            for (var i = fromIndex; i >= 0; i--) {
                if (this.get(i) === item) {
                    return i;
                }
            }
            return -1;
        },
        join: function () {
            Observation.add(this, 'length');
            return [].join.apply(this, arguments);
        },
        reverse: function () {
            var list = [].reverse.call(this._items());
            return this.replace(list);
        },
        slice: function () {
            Observation.add(this, 'length');
            var temp = Array.prototype.slice.apply(this, arguments);
            return new this.constructor(temp);
        },
        concat: function () {
            var args = [];
            each(arguments, function (arg) {
                if (canReflect.isListLike(arg)) {
                    var arr = Array.isArray(arg) ? arg : makeArray(arg);
                    arr.forEach(function (innerArg) {
                        args.push(this.__type(innerArg));
                    }, this);
                } else {
                    args.push(this.__type(arg));
                }
            }, this);
            return new this.constructor(Array.prototype.concat.apply(makeArray(this), args));
        },
        forEach: function (cb, thisarg) {
            var item;
            for (var i = 0, len = this.length; i < len; i++) {
                item = this.get(i);
                if (cb.call(thisarg || item, item, i, this) === false) {
                    break;
                }
            }
            return this;
        },
        replace: function (newList) {
            var patches = diff(this, newList);
            canBatch.start();
            for (var i = 0, len = patches.length; i < len; i++) {
                this.splice.apply(this, [
                    patches[i].index,
                    patches[i].deleteCount
                ].concat(patches[i].insert));
            }
            canBatch.stop();
            return this;
        },
        sort: function (compareFunction) {
            var removed = Array.prototype.slice.call(this);
            Array.prototype.sort.call(this, compareFunction);
            var added = Array.prototype.slice.call(this);
            canBatch.start();
            canEvent.dispatch.call(this, 'remove', [
                removed,
                0
            ]);
            canEvent.dispatch.call(this, 'add', [
                added,
                0
            ]);
            canEvent.dispatch.call(this, 'length', [
                this._length,
                this._length
            ]);
            canBatch.stop();
            return this;
        }
    });
    for (var prop in define.eventsProto) {
        DefineList[prop] = define.eventsProto[prop];
        Object.defineProperty(DefineList.prototype, prop, {
            enumerable: false,
            value: define.eventsProto[prop],
            writable: true
        });
    }
    var eventsProtoSymbols = 'getOwnPropertySymbols' in Object ? Object.getOwnPropertySymbols(define.eventsProto) : [
        canSymbol.for('can.onKeyValue'),
        canSymbol.for('can.offKeyValue')
    ];
    eventsProtoSymbols.forEach(function (sym) {
        Object.defineProperty(DefineList.prototype, sym, {
            enumerable: false,
            value: define.eventsProto[sym],
            writable: true
        });
    });
    Object.defineProperty(DefineList.prototype, 'length', {
        get: function () {
            if (!this.__inSetup) {
                Observation.add(this, 'length');
            }
            return this._length;
        },
        set: function (newVal) {
            if (runningNative) {
                this._length = newVal;
                return;
            }
            if (newVal === this._length) {
                return;
            }
            if (newVal > this._length - 1) {
                var newArr = new Array(newVal - this._length);
                this.push.apply(this, newArr);
            } else {
                this.splice(newVal);
            }
        },
        enumerable: true
    });
    Object.defineProperty(DefineList.prototype, 'each', {
        enumerable: false,
        writable: true,
        value: DefineList.prototype.forEach
    });
    DefineList.prototype.attr = function (prop, value) {
        canLog.warn('DefineMap::attr shouldn\'t be called');
        if (arguments.length === 0) {
            return this.get();
        } else if (prop && typeof prop === 'object') {
            return this.set.apply(this, arguments);
        } else if (arguments.length === 1) {
            return this.get(prop);
        } else {
            return this.set(prop, value);
        }
    };
    DefineList.prototype.item = function (index, value) {
        if (arguments.length === 1) {
            return this.get(index);
        } else {
            return this.set(index, value);
        }
    };
    DefineList.prototype.items = function () {
        canLog.warn('DefineList::get should should be used instead of DefineList::items');
        return this.get();
    };
    canReflect.assignSymbols(DefineList.prototype, {
        'can.isMoreListLikeThanMapLike': true,
        'can.isMapLike': true,
        'can.isListLike': true,
        'can.isValueLike': false,
        'can.getKeyValue': DefineList.prototype.get,
        'can.setKeyValue': DefineList.prototype.set,
        'can.deleteKeyValue': function (prop) {
            if (typeof prop === 'number') {
                this.splice(prop, 1);
            } else {
                this.set(prop, undefined);
            }
            return this;
        },
        'can.assignDeep': function (source) {
            canBatch.start();
            canReflect.assignList(this, source);
            canBatch.stop();
        },
        'can.updateDeep': function (source) {
            canBatch.start();
            this.replace(source);
            canBatch.stop();
        },
        'can.keyHasDependencies': function (key) {
            return !!(this._computed && this._computed[key] && this._computed[key].compute);
        },
        'can.getKeyDependencies': function (key) {
            var ret;
            if (this._computed && this._computed[key] && this._computed[key].compute) {
                ret = {};
                ret.valueDependencies = new CIDSet();
                ret.valueDependencies.add(this._computed[key].compute);
            }
            return ret;
        },
        'can.onKeysAdded': function (handler) {
            this[canSymbol.for('can.onKeyValue')]('add', handler);
        },
        'can.onKeysRemoved': function (handler) {
            this[canSymbol.for('can.onKeyValue')]('remove', handler);
        },
        'can.splice': function (index, deleteCount, insert) {
            this.splice.apply(this, [
                index,
                deleteCount
            ].concat(insert));
        }
    });
    canReflect.setKeyValue(DefineList.prototype, canSymbol.iterator, function () {
        var index = -1;
        return {
            next: function () {
                index++;
                return {
                    value: this[index],
                    done: index >= this.length
                };
            }.bind(this)
        };
    });
    types.DefineList = DefineList;
    types.DefaultList = DefineList;
    module.exports = ns.DefineList = DefineList;
});
/*can-define@1.3.2#list/list-test*/
define('can-define@1.3.2#list/list-test', function (require, exports, module) {
    'use strict';
    var QUnit = require('steal-qunit');
    var DefineList = require('can-define/list/list');
    var DefineMap = require('can-define/map/map');
    var Observation = require('can-observation');
    var define = require('can-define');
    var compute = require('can-compute');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var assign = require('can-util/js/assign/assign');
    var CID = require('can-cid');
    QUnit.module('can-define/list/list');
    QUnit.test('List is an event emitter', function (assert) {
        var Base = DefineList.extend({});
        assert.ok(Base.on, 'Base has event methods.');
        var List = Base.extend({});
        assert.ok(List.on, 'List has event methods.');
    });
    QUnit.test('creating an instance', function () {
        var list = new DefineList([
            'a',
            'b',
            'c'
        ]);
        list.on('add', function (ev, newVals, index) {
            QUnit.deepEqual(newVals, ['d']);
            QUnit.equal(index, 3);
        });
        list.push('d');
    });
    test('list attr changes length', function () {
        var l = new DefineList([
            0,
            1,
            2
        ]);
        l.set(3, 3);
        equal(l.length, 4);
    });
    test('remove on pop', function () {
        var l = new DefineList([
            0,
            1,
            2
        ]);
        l.pop();
        equal(l.length, 2);
        deepEqual(l.get(), [
            0,
            1
        ]);
    });
    test('list splice', function () {
        var l = new DefineList([
            0,
            1,
            2,
            3
        ]);
        l.on('add', function (ev, newVals, index) {
            deepEqual(newVals, [
                'a',
                'b'
            ], 'got the right newVals');
            equal(index, 1, 'adding items');
        });
        l.on('remove', function (ev, oldVals, index) {
            deepEqual(oldVals, [
                1,
                2
            ], 'got the right oldVals');
            equal(index, 1, 'no new Vals');
        });
        l.splice(1, 2, 'a', 'b');
        deepEqual(l.get(), [
            0,
            'a',
            'b',
            3
        ], 'serialized');
    });
    test('Array accessor methods', 11, function () {
        var l = new DefineList([
                'a',
                'b',
                'c'
            ]), sliced = l.slice(2), joined = l.join(' | '), concatenated = l.concat([
                2,
                1
            ], new DefineList([0]));
        ok(sliced instanceof DefineList, 'Slice is an Observable list');
        equal(sliced.length, 1, 'Sliced off two elements');
        equal(sliced[0], 'c', 'Single element as expected');
        equal(joined, 'a | b | c', 'Joined list properly');
        ok(concatenated instanceof DefineList, 'Concatenated is an Observable list');
        deepEqual(concatenated.serialize(), [
            'a',
            'b',
            'c',
            2,
            1,
            0
        ], 'DefineList concatenated properly');
        l.forEach(function (letter, index) {
            ok(true, 'Iteration');
            if (index === 0) {
                equal(letter, 'a', 'First letter right');
            }
            if (index === 2) {
                equal(letter, 'c', 'Last letter right');
            }
        });
    });
    test('Concatenated list items Equal original', function () {
        var l = new DefineList([
                { firstProp: 'Some data' },
                { secondProp: 'Next data' }
            ]), concatenated = l.concat([
                { hello: 'World' },
                { foo: 'Bar' }
            ]);
        ok(l[0] === concatenated[0], 'They are Equal');
        ok(l[1] === concatenated[1], 'They are Equal');
    });
    test('Lists with maps concatenate properly', function () {
        var Person = DefineMap.extend();
        var People = DefineList.extend({ '#': Person });
        var Genius = Person.extend();
        var Animal = DefineMap.extend();
        var me = new Person({ name: 'John' });
        var animal = new Animal({ name: 'Tak' });
        var genius = new Genius({ name: 'Einstein' });
        var hero = { name: 'Ghandi' };
        var people = new People([]);
        var specialPeople = new People([
            genius,
            hero
        ]);
        people = people.concat([
            me,
            animal,
            specialPeople
        ], specialPeople, [
            1,
            2
        ], 3);
        ok(people.length === 8, 'List length is right');
        ok(people[0] === me, 'Map in list === vars created before concat');
        ok(people[1] instanceof Person, 'Animal got serialized to Person');
    });
    test('splice removes items in IE (#562)', function () {
        var l = new DefineList(['a']);
        l.splice(0, 1);
        ok(!l.get(0), 'all props are removed');
    });
    test('reverse triggers add/remove events (#851)', function () {
        expect(4);
        var l = new DefineList([
            1,
            2,
            3
        ]);
        l.on('add', function () {
            ok(true, 'add called');
        });
        l.on('remove', function () {
            ok(true, 'remove called');
        });
        l.on('length', function () {
            ok(true, 'length should be called');
        });
        l.reverse();
        deepEqual(l.get(), [
            3,
            2,
            1
        ], 'reversed');
    });
    test('filter', function () {
        var l = new DefineList([
            {
                id: 1,
                name: 'John'
            },
            {
                id: 2,
                name: 'Mary'
            }
        ]);
        var filtered = l.filter(function (item) {
            return item.name === 'Mary';
        });
        notEqual(filtered._cid, l._cid, 'not same object');
        equal(filtered.length, 1, 'one item');
        equal(filtered[0].name, 'Mary', 'filter works');
    });
    test('No Add Events if DefineList Splice adds the same items that it is removing. (#1277, #1399)', function () {
        var list = new DefineList([
            'a',
            'b'
        ]);
        list.bind('add', function () {
            ok(false, 'Add callback should not be called.');
        });
        list.bind('remove', function () {
            ok(false, 'Remove callback should not be called.');
        });
        var result = list.splice(0, 2, 'a', 'b');
        deepEqual(result, [
            'a',
            'b'
        ]);
    });
    test('add event always returns an array as the value (#998)', function () {
        var list = new DefineList([]), msg;
        list.bind('add', function (ev, newElements, index) {
            deepEqual(newElements, [4], msg);
        });
        msg = 'works on push';
        list.push(4);
        list.pop();
        msg = 'works on attr()';
        list.set(0, 4);
        list.pop();
        msg = 'works on replace()';
        list.replace([4]);
    });
    test('Setting with .set() out of bounds of length triggers add event with leading undefineds', function () {
        var list = new DefineList([1]);
        list.bind('add', function (ev, newElements, index) {
            deepEqual(newElements, [
                undefined,
                undefined,
                4
            ], 'Leading undefineds are included');
            equal(index, 1, 'Index takes into account the leading undefineds from a .set()');
        });
        list.set(3, 4);
    });
    test('No events should fire if removals happened on empty arrays', function () {
        var list = new DefineList([]), msg;
        list.bind('remove', function (ev, removed, index) {
            ok(false, msg);
        });
        msg = 'works on pop';
        list.pop();
        msg = 'works on shift';
        list.shift();
        ok(true, 'No events were fired.');
    });
    test('setting an index out of bounds does not create an array', function () {
        expect(1);
        var l = new DefineList();
        l.set('1', 'foo');
        equal(l.get('1'), 'foo');
    });
    test('splice with similar but less items works (#1606)', function () {
        var list = new DefineList([
            'aa',
            'bb',
            'cc'
        ]);
        list.splice(0, list.length, 'aa', 'cc', 'dd');
        deepEqual(list.get(), [
            'aa',
            'cc',
            'dd'
        ]);
        list.splice(0, list.length, 'aa', 'cc');
        deepEqual(list.get(), [
            'aa',
            'cc'
        ]);
    });
    test('filter returns same list type (#1744)', function () {
        var ParentList = DefineList.extend();
        var ChildList = ParentList.extend();
        var children = new ChildList([
            1,
            2,
            3
        ]);
        ok(children.filter(function () {
        }) instanceof ChildList);
    });
    test('reverse returns the same list instance (#1744)', function () {
        var ParentList = DefineList.extend();
        var ChildList = ParentList.extend();
        var children = new ChildList([
            1,
            2,
            3
        ]);
        ok(children.reverse() === children);
    });
    test('slice and join are observable by a compute (#1884)', function () {
        expect(2);
        var list = new DefineList([
            1,
            2,
            3
        ]);
        var sliced = new Observation(function () {
            return list.slice(0, 1);
        }, null, {
            updater: function (newVal) {
                deepEqual(newVal.get(), [2], 'got a new DefineList');
            }
        });
        sliced.start();
        var joined = new Observation(function () {
            return list.join(',');
        }, null, {
            updater: function (newVal) {
                equal(newVal, '2,3', 'joined is observable');
            }
        });
        joined.start();
        list.shift();
    });
    test('list.replace', function () {
        var firstArray = [
            {
                id: 1,
                name: 'Marshall'
            },
            {
                id: 2,
                name: 'Austin'
            },
            {
                id: 3,
                name: 'Hyrum'
            }
        ];
        var myList = new DefineList(firstArray);
        var newArray = [
            {
                id: 4,
                name: 'Aubree'
            },
            {
                id: 5,
                name: 'Leah'
            },
            {
                id: 6,
                name: 'Lily'
            }
        ];
        myList.replace(newArray);
        equal(myList.length, 3);
        equal(myList[0].name, 'Aubree');
        equal(myList[1].name, 'Leah');
        equal(myList[2].name, 'Lily', 'Can replace a List with an Array.');
        myList.replace(firstArray);
        equal(myList.length, 3);
        equal(myList[0].name, 'Marshall');
        equal(myList[1].name, 'Austin');
        equal(myList[2].name, 'Hyrum', 'Can replace a List with another List.');
    });
    test('list.map', function () {
        var myArray = [
            {
                id: 1,
                name: 'Marshall'
            },
            {
                id: 2,
                name: 'Austin'
            },
            {
                id: 3,
                name: 'Hyrum'
            }
        ];
        var myList = new DefineList(myArray);
        var newList = myList.map(function (person) {
            person.lastName = 'Thompson';
            return person;
        });
        equal(newList.length, 3);
        equal(newList[0].name, 'Marshall');
        equal(newList[0].lastName, 'Thompson');
        equal(newList[1].name, 'Austin');
        equal(newList[1].lastName, 'Thompson');
        equal(newList[2].name, 'Hyrum');
        equal(newList[2].lastName, 'Thompson');
        var ExtendedList = DefineList.extend({
            testMe: function () {
                return 'It Worked!';
            }
        });
        var myExtendedList = new ExtendedList(myArray);
        var newExtendedList = myExtendedList.map(function (person) {
            person.lastName = 'Thompson';
            return person;
        });
        try {
            newExtendedList.testMe();
        } catch (err) {
            QUnit.ok(err.message.match(/testMe/), 'Does not return the same type of list.');
        }
    });
    test('list.sort a simple list', function () {
        var myList = new DefineList([
            'Marshall',
            'Austin',
            'Hyrum'
        ]);
        myList.sort();
        equal(myList.length, 3);
        equal(myList[0], 'Austin');
        equal(myList[1], 'Hyrum');
        equal(myList[2], 'Marshall', 'Basic list was properly sorted.');
    });
    test('list.sort a list of objects', function () {
        var objList = new DefineList([
            {
                id: 1,
                name: 'Marshall'
            },
            {
                id: 2,
                name: 'Austin'
            },
            {
                id: 3,
                name: 'Hyrum'
            }
        ]);
        objList.sort(function (a, b) {
            if (a.name < b.name) {
                return -1;
            } else if (a.name > b.name) {
                return 1;
            } else {
                return 0;
            }
        });
        equal(objList.length, 3);
        equal(objList[0].name, 'Austin');
        equal(objList[1].name, 'Hyrum');
        equal(objList[2].name, 'Marshall', 'List of objects was properly sorted.');
    });
    test('list.sort a list of objects without losing reference (#137)', function () {
        var unSorted = new DefineList([
            { id: 3 },
            { id: 2 },
            { id: 1 }
        ]);
        var sorted = unSorted.slice(0).sort(function (a, b) {
            return a.id > b.id ? 1 : a.id < b.id ? -1 : 0;
        });
        equal(unSorted[0], sorted[2], 'items should be equal');
    });
    test('list defines', 6, function () {
        var Todo = function (props) {
            assign(this, props);
            CID(this);
        };
        define(Todo.prototype, {
            completed: 'boolean',
            destroyed: { value: false }
        });
        Todo.prototype.destroy = function () {
            this.destroyed = true;
        };
        var TodoList = DefineList.extend({
            '*': Todo,
            remaining: {
                get: function () {
                    return this.filter({ completed: false });
                }
            },
            completed: {
                get: function () {
                    return this.filter({ completed: true });
                }
            },
            destroyCompleted: function () {
                this.completed.forEach(function (todo) {
                    todo.destroy();
                });
            },
            setCompletedTo: function (value) {
                this.forEach(function (todo) {
                    todo.completed = value;
                });
            }
        });
        var todos = new TodoList([
            { completed: true },
            { completed: false }
        ]);
        ok(todos.item(0) instanceof Todo, 'correct instance');
        equal(todos.completed.length, 1, 'only one todo');
        todos.on('completed', function (ev, newVal, oldVal) {
            ok(newVal instanceof TodoList, 'right type');
            equal(newVal.length, 2, 'all items');
            ok(oldVal instanceof TodoList, 'right type');
            equal(oldVal.length, 1, 'all items');
        });
        todos.setCompletedTo(true);
    });
    QUnit.test('extending the base supports overwriting _eventSetup', function () {
        var L = DefineList.extend({});
        Object.getOwnPropertyDescriptor(DefineMap.prototype, '_eventSetup');
        L.prototype.arbitraryProp = true;
        ok(true, 'set arbitraryProp');
        L.prototype._eventSetup = function () {
        };
        ok(true, 'worked');
    });
    QUnit.test('setting expandos on a DefineList', function () {
        var DL = DefineList.extend({ count: 'number' });
        var dl = new DL();
        dl.set({
            count: 5,
            skip: 2
        });
        QUnit.equal(dl.get('count'), 5, 'read with .get defined');
        QUnit.equal(dl.count, 5, 'read with . defined');
        QUnit.equal(dl.get('skip'), 2, 'read with .get expando');
        QUnit.equal(dl.skip, 2, 'read with . expando');
        QUnit.equal(dl.get('limit'), undefined, 'read with .get undefined');
    });
    QUnit.test('passing a DefineList to DefineList (#33)', function () {
        var m = new DefineList([
            {},
            {}
        ]);
        var m2 = new DefineList(m);
        QUnit.deepEqual(m.get(), m2.get());
        QUnit.ok(m[0] === m2[0], 'index the same');
        QUnit.ok(m[1] === m2[1], 'index the same');
    });
    QUnit.test('reading and setting expandos', function () {
        var list = new DefineList();
        var countObservation = new Observation(function () {
            return list.get('count');
        }, null, function (newValue) {
            QUnit.equal(newValue, 1000, 'got new value');
        });
        countObservation.start();
        list.set('count', 1000);
        QUnit.equal(countObservation.value, 1000);
        var list2 = new DefineList();
        list2.on('count', function (ev, newVal) {
            QUnit.equal(newVal, 5);
        });
        list2.set('count', 5);
    });
    QUnit.test('extending DefineList constructor functions (#61)', function () {
        var AList = DefineList.extend('AList', {
            aProp: {},
            aMethod: function () {
            }
        });
        var BList = AList.extend('BList', {
            bProp: {},
            bMethod: function () {
            }
        });
        var CList = BList.extend('CList', {
            cProp: {},
            cMethod: function () {
            }
        });
        var list = new CList([
            {},
            {}
        ]);
        list.on('aProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'PROP');
            QUnit.equal(oldVal, undefined);
        });
        list.on('bProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'FOO');
            QUnit.equal(oldVal, undefined);
        });
        list.on('cProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'BAR');
            QUnit.equal(oldVal, undefined);
        });
        list.aProp = 'PROP';
        list.bProp = 'FOO';
        list.cProp = 'BAR';
        QUnit.ok(list.aMethod);
        QUnit.ok(list.bMethod);
        QUnit.ok(list.cMethod);
    });
    QUnit.test('extending DefineList constructor functions more than once (#61)', function () {
        var AList = DefineList.extend('AList', {
            aProp: {},
            aMethod: function () {
            }
        });
        var BList = AList.extend('BList', {
            bProp: {},
            bMethod: function () {
            }
        });
        var CList = AList.extend('CList', {
            cProp: {},
            cMethod: function () {
            }
        });
        var list1 = new BList([
            {},
            {}
        ]);
        var list2 = new CList([
            {},
            {},
            {}
        ]);
        list1.on('aProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'PROP', 'aProp newVal on list1');
            QUnit.equal(oldVal, undefined);
        });
        list1.on('bProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'FOO', 'bProp newVal on list1');
            QUnit.equal(oldVal, undefined);
        });
        list2.on('aProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'PROP', 'aProp newVal on list2');
            QUnit.equal(oldVal, undefined);
        });
        list2.on('cProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'BAR', 'cProp newVal on list2');
            QUnit.equal(oldVal, undefined);
        });
        list1.aProp = 'PROP';
        list1.bProp = 'FOO';
        list2.aProp = 'PROP';
        list2.cProp = 'BAR';
        QUnit.ok(list1.aMethod, 'list1 aMethod');
        QUnit.ok(list1.bMethod);
        QUnit.ok(list2.aMethod);
        QUnit.ok(list2.cMethod, 'list2 cMethod');
    });
    QUnit.test('extending DefineList constructor functions - value (#61)', function () {
        var AList = DefineList.extend('AList', { aProp: { value: 1 } });
        var BList = AList.extend('BList', {});
        var CList = BList.extend('CList', {});
        var c = new CList([]);
        QUnit.equal(c.aProp, 1, 'got initial value');
    });
    QUnit.test('\'*\' inheritance works (#61)', function () {
        var Account = DefineMap.extend({
            name: 'string',
            amount: 'number',
            slug: {
                serialize: true,
                get: function () {
                    return this.name.toLowerCase().replace(/ /g, '-').replace(/[^\w-]+/g, '');
                }
            }
        });
        var BaseList = DefineList.extend({ '*': Account });
        var ExtendedList = BaseList.extend({});
        var xl = new ExtendedList([{}]);
        QUnit.ok(xl[0] instanceof Account);
    });
    QUnit.test('shorthand getter setter (#56)', function () {
        var People = DefineList.extend({
            first: '*',
            last: '*',
            get fullName() {
                return this.first + ' ' + this.last;
            },
            set fullName(newVal) {
                var parts = newVal.split(' ');
                this.first = parts[0];
                this.last = parts[1];
            }
        });
        var p = new People([]);
        p.fullName = 'Mohamed Cherif';
        p.on('fullName', function (ev, newVal, oldVal) {
            QUnit.equal(oldVal, 'Mohamed Cherif');
            QUnit.equal(newVal, 'Justin Meyer');
        });
        equal(p.fullName, 'Mohamed Cherif', 'fullName initialized right');
        p.fullName = 'Justin Meyer';
    });
    QUnit.test('added and removed are called after items are added/removed (#14)', function () {
        var Person = DefineMap.extend({
            id: 'number',
            name: 'string'
        });
        var addedFuncCalled, removedFuncCalled, theList;
        var People = DefineList.extend({
            '#': {
                added: function (items, index) {
                    addedFuncCalled = true;
                    ok(items, 'items added got passed to added');
                    ok(typeof index === 'number', 'index of items was passed to added and is a number');
                    ok(items[0].name === 'John', 'Name was correct');
                    theList = this;
                },
                removed: function (items, index) {
                    removedFuncCalled = true;
                    ok(items, 'items added got passed to removed');
                    ok(typeof index === 'number', 'index of items was passed to removed and is a number');
                    theList = this;
                },
                Type: Person
            },
            outsideProp: {
                type: 'boolean',
                value: true
            }
        });
        var people = new People([]);
        var me = new Person();
        me.name = 'John';
        me.id = '1234';
        ok(!addedFuncCalled, 'added function has not been called yet');
        people.push(me);
        ok(addedFuncCalled, 'added function was called');
        ok(theList.outsideProp === true && theList instanceof People, 'the list was passed correctly as this to added');
        theList = null;
        ok(!removedFuncCalled, 'removed function has not been called yet');
        people.splice(people.indexOf(me), 1);
        ok(removedFuncCalled, 'removed function was called');
        ok(theList.outsideProp === true && theList instanceof People, 'the list was passed correctly as this to removed');
    });
    QUnit.test('* vs # (#78)', function () {
        var MyList = DefineList.extend({
            '*': 'number',
            '#': {
                added: function () {
                    ok(true, 'called on init');
                },
                removed: function () {
                },
                type: 'string'
            }
        });
        var list = new MyList([
            1,
            2,
            3
        ]);
        QUnit.ok(list[0] === '1', 'converted to string');
        list.set('prop', '4');
        QUnit.ok(list.prop === 4, 'type converted');
    });
    QUnit.test('Array shorthand uses #', function () {
        var MyMap = DefineMap.extend({ 'numbers': ['number'] });
        var map = new MyMap({
            numbers: [
                '1',
                '2'
            ]
        });
        QUnit.ok(map.numbers[0] === 1, 'converted to number');
        map.numbers.set('prop', '4');
        QUnit.ok(map.numbers.prop === '4', 'type left alone');
    });
    QUnit.test('replace-with-self lists are diffed properly (can-view-live#10)', function () {
        var a = new DefineMap({ name: 'A' });
        var b = new DefineMap({ name: 'B' });
        var c = new DefineMap({ name: 'C' });
        var d = new DefineMap({ name: 'D' });
        expect(4);
        var list1 = new DefineList([
            a,
            b
        ]);
        list1.on('add', function (ev, newVals, where) {
            throw new Error('list1 should not add.');
        });
        list1.on('remove', function (ev, oldVals, where) {
            throw new Error('list1 should not remove.');
        });
        list1.replace([
            a,
            b
        ]);
        var list2 = new DefineList([
            a,
            b,
            c
        ]);
        list2.on('add', function (ev, newVals, where) {
            equal(newVals.length, 1, 'list2 added length');
            equal(where, 2, 'list2 added location');
        });
        list2.on('remove', function (ev, oldVals, where) {
            equal(oldVals.length, 1, 'list2 removed length');
            equal(where, 2, 'list2 removed location');
        });
        list2.replace([
            a,
            b,
            d
        ]);
    });
    QUnit.test('set >= length - triggers length event (#152)', function () {
        var l = new DefineList([
            1,
            2,
            3
        ]);
        var batchNum = null;
        l.on('add', function (e) {
            ok(true, 'add called');
            if (batchNum === null) {
                batchNum = e.batchNum;
            } else {
                equal(batchNum, e.batchNum, 'batch numbers match');
            }
        });
        l.on('remove', function (e) {
            ok(false, 'remove called');
            if (batchNum === null) {
                batchNum = e.batchNum;
            } else {
                equal(batchNum, e.batchNum, 'batch numbers match');
            }
        });
        l.on('length', function (e) {
            ok(true, 'length called');
            if (batchNum === null) {
                batchNum = e.batchNum;
            } else {
                equal(batchNum, e.batchNum, 'batch numbers match');
            }
        });
        expect(4);
        l.set(3, 5);
        deepEqual(l.get(), [
            1,
            2,
            3,
            5
        ], 'updated list');
    });
    QUnit.test('set < length - triggers length event (#150)', function () {
        var l = new DefineList([
            1,
            2,
            3
        ]);
        var batchNum = null;
        l.on('add', function (e) {
            ok(true, 'add called');
            if (batchNum === null) {
                batchNum = e.batchNum;
            } else {
                equal(batchNum, e.batchNum, 'batch numbers match');
            }
        });
        l.on('remove', function (e) {
            ok(true, 'remove called');
            if (batchNum === null) {
                batchNum = e.batchNum;
            } else {
                equal(batchNum, e.batchNum, 'batch numbers match');
            }
        });
        l.on('length', function (e) {
            ok(true, 'length called');
            if (batchNum === null) {
                batchNum = e.batchNum;
            } else {
                equal(batchNum, e.batchNum, 'batch numbers match');
            }
        });
        expect(6);
        l.set(2, 4);
        deepEqual(l.get(), [
            1,
            2,
            4
        ], 'updated list');
    });
    QUnit.test('set/splice are observable', function () {
        var list = new DefineList([
            1,
            2,
            3,
            4,
            5
        ]);
        var count = new Observation(function () {
            var count = 0;
            for (var i = 0; i < list.length; i++) {
                count += list[i] % 2 ? 1 : 0;
            }
            return count;
        }, null, {
            updater: function () {
                ok(true);
            }
        });
        count.start();
        expect(3);
        list.set(3, 5);
        list.set(2, 4);
        list.splice(1, 1, 1);
    });
    QUnit.test('setting length > current (#147)', function () {
        var list = new DefineList([
            1,
            2
        ]);
        list.length = 5;
        equal(list.length, 5);
        equal(list.hasOwnProperty(0), true);
        equal(list.hasOwnProperty(1), true);
        equal(list.hasOwnProperty(2), true);
        equal(list.hasOwnProperty(3), true);
        equal(list.hasOwnProperty(4), true);
        equal(list.hasOwnProperty(5), false);
    });
    QUnit.test('setting length < current (#147)', function () {
        var list = new DefineList([
            1,
            2,
            3,
            4,
            5
        ]);
        list.length = 3;
        equal(list.length, 3);
        equal(list.hasOwnProperty(0), true);
        equal(list.hasOwnProperty(1), true);
        equal(list.hasOwnProperty(2), true);
        equal(list.hasOwnProperty(3), false);
        equal(list.hasOwnProperty(4), false);
        equal(list.hasOwnProperty(5), false);
    });
    test('every', function () {
        var l = new DefineList([
            {
                id: 1,
                name: 'Bob'
            },
            {
                id: 2,
                name: 'Bob'
            }
        ]);
        var allBobs = l.every(function (item) {
            return item.name === 'Bob';
        });
        ok(allBobs, 'Every works in true case');
        var idOne = l.every(function (item) {
            return item.id === 1;
        });
        ok(!idOne, 'Every works in false case');
        allBobs = l.every({ name: 'Bob' });
        ok(allBobs, 'Every works in true case');
        idOne = l.every({
            name: 'Bob',
            id: 1
        });
        ok(!idOne, 'Every works in false case');
    });
    test('some', function () {
        var l = new DefineList([
            {
                id: 1,
                name: 'Alice'
            },
            {
                id: 2,
                name: 'Bob'
            }
        ]);
        var allBobs = l.some(function (item) {
            return item.name === 'Bob';
        });
        ok(allBobs, 'Some works in true case');
        var idOne = l.some(function (item) {
            return item.name === 'Charlie';
        });
        ok(!idOne, 'Some works in false case');
        allBobs = l.some({ name: 'Bob' });
        ok(allBobs, 'Some works in true case');
        idOne = l.some({
            name: 'Bob',
            id: 1
        });
        ok(!idOne, 'Some works in false case');
    });
    test('lastIndexOf', function () {
        var l = new DefineList([
            {
                id: 1,
                name: 'Alice'
            },
            {
                id: 2,
                name: 'Bob'
            }
        ]);
        var bobIdx = l.lastIndexOf(l[1]);
        equal(bobIdx, 1, 'lastIndexOf found object');
        var charlieIdx = l.lastIndexOf({
            id: 3,
            name: 'Charlie'
        });
        equal(charlieIdx, -1, 'lastIndexOf not found object');
        l.push(l[1]);
        bobIdx = l.lastIndexOf(l[1]);
        equal(bobIdx, 2, 'lastIndexOf found last index of duped object');
    });
    test('reduce', function () {
        var l = new DefineList([
            {
                id: 1,
                name: 'Alice',
                score: 10
            },
            {
                id: 2,
                name: 'Bob',
                score: 20
            }
        ]);
        var totalScores = l.reduce(function (total, player) {
            return total + player.score;
        }, 0);
        equal(totalScores, 30, 'Reduce works over list');
    });
    test('reduceRight', function () {
        var l = new DefineList([
            {
                id: 1,
                name: 'Alice'
            },
            {
                id: 2,
                name: 'Bob'
            }
        ]);
        var concatenatedNames = l.reduceRight(function (string, person) {
            return string + person.name;
        }, '');
        equal(concatenatedNames, 'BobAlice', 'ReduceRight works over list');
    });
    test('compute(defineMap, \'property.names\') works (#20)', function () {
        var map = new DefineMap();
        var c = compute(map, 'foo.bar');
        c.on('change', function (ev, newVal) {
            QUnit.equal(newVal, 2);
        });
        map.set('foo', new DefineMap());
        map.foo.set('bar', 2);
    });
    test('compute(DefineList, 0) works (#17)', function (assert) {
        assert.expect(1);
        var list = new DefineList([
            1,
            2,
            3
        ]);
        var c = compute(list, 0);
        c.on('change', function (ev, newVal) {
            assert.equal(newVal, 5);
        });
        list.set(0, 5);
    });
    test('works with can-reflect', function () {
        var a = new DefineMap({ foo: 4 });
        var b = new DefineList([
            'foo',
            'bar'
        ]);
        var c;
        QUnit.equal(canReflect.getKeyValue(b, '0'), 'foo', 'unbound value');
        QUnit.ok(!canReflect.isValueLike(b), 'isValueLike is false');
        QUnit.ok(canReflect.isObservableLike(b), 'isObservableLike is true');
        QUnit.ok(canReflect.isMapLike(b), 'isMapLike is true');
        QUnit.ok(canReflect.isListLike(b), 'isListLike is false');
        QUnit.ok(!canReflect.keyHasDependencies(b, 'length'), 'keyHasDependencies -- false');
        define(c = Object.create(b), {
            length: {
                get: function () {
                    return a.foo;
                }
            }
        });
        QUnit.ok(canReflect.getKeyDependencies(c, 'length'), 'dependencies exist');
        QUnit.ok(canReflect.getKeyDependencies(c, 'length').valueDependencies.has(c._computed.length.compute), 'dependencies returned');
    });
    QUnit.test('can-reflect setKeyValue', function () {
        var a = new DefineList([
            'a',
            'b'
        ]);
        canReflect.setKeyValue(a, 1, 'c');
        QUnit.equal(a[1], 'c', 'setKeyValue');
    });
    QUnit.test('can-reflect deleteKeyValue', function () {
        var a = new DefineList([
            'a',
            'b'
        ]);
        a.set('foo', 'bar');
        canReflect.deleteKeyValue(a, 0);
        QUnit.equal(a[1], undefined, 'last value is now undefined');
        QUnit.equal(a[0], 'b', 'last value is shifted down');
        canReflect.deleteKeyValue(a, 'foo');
        QUnit.equal(a.foo, undefined, 'value not included in serial');
        QUnit.ok(!('foo' in a.get()), 'value not included in serial');
    });
    QUnit.test('can-reflect getKeyDependencies', function () {
        var a = new DefineMap({ foo: 4 });
        var b = new DefineList([
            'foo',
            'bar'
        ]);
        var c;
        ok(!canReflect.getKeyDependencies(b, 'length'), 'No dependencies before binding');
        define(c = Object.create(b), {
            length: {
                get: function () {
                    return a.foo;
                }
            }
        });
        ok(canReflect.getKeyDependencies(c, 'length'), 'dependencies exist');
        ok(canReflect.getKeyDependencies(c, 'length').valueDependencies.has(c._computed.length.compute), 'dependencies returned');
    });
    QUnit.test('registered symbols', function () {
        var a = new DefineMap({ 'a': 'a' });
        ok(a[canSymbol.for('can.isMapLike')], 'can.isMapLike');
        equal(a[canSymbol.for('can.getKeyValue')]('a'), 'a', 'can.getKeyValue');
        a[canSymbol.for('can.setKeyValue')]('a', 'b');
        equal(a.a, 'b', 'can.setKeyValue');
        function handler(val) {
            equal(val, 'c', 'can.onKeyValue');
        }
        a[canSymbol.for('can.onKeyValue')]('a', handler);
        a.a = 'c';
        a[canSymbol.for('can.offKeyValue')]('a', handler);
        a.a = 'd';
    });
});
/*can-define@1.3.2#map/map-test*/
define('can-define@1.3.2#map/map-test', function (require, exports, module) {
    'use strict';
    var QUnit = require('steal-qunit');
    var DefineMap = require('can-define/map/map');
    var define = require('can-define');
    var Observation = require('can-observation');
    var each = require('can-util/js/each/each');
    var compute = require('can-compute');
    var assign = require('can-util/js/assign/assign');
    var canReflect = require('can-reflect');
    var isPlainObject = require('can-util/js/is-plain-object/is-plain-object');
    var sealWorks = function () {
        try {
            var o = {};
            Object.seal(o);
            o.prop = true;
            return false;
        } catch (e) {
            return true;
        }
    }();
    QUnit.module('can-define/map/map');
    QUnit.test('Map is an event emitter', function (assert) {
        var Base = DefineMap.extend({});
        assert.ok(Base.on, 'Base has event methods.');
        var Map = Base.extend({});
        assert.ok(Map.on, 'Map has event methods.');
    });
    QUnit.test('creating an instance', function () {
        var map = new DefineMap({ prop: 'foo' });
        map.on('prop', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'BAR');
            QUnit.equal(oldVal, 'foo');
        });
        map.prop = 'BAR';
    });
    QUnit.test('creating an instance with nested prop', function () {
        var map = new DefineMap({ name: { first: 'Justin' } });
        map.name.on('first', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'David');
            QUnit.equal(oldVal, 'Justin');
        });
        map.name.first = 'David';
    });
    QUnit.test('extending', function () {
        var MyMap = DefineMap.extend({ prop: {} });
        var map = new MyMap();
        map.on('prop', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'BAR');
            QUnit.equal(oldVal, undefined);
        });
        map.prop = 'BAR';
    });
    QUnit.test('loop only through defined serializable props', function () {
        var MyMap = DefineMap.extend({
            propA: {},
            propB: { serialize: false },
            propC: {
                get: function () {
                    return this.propA;
                }
            }
        });
        var inst = new MyMap({
            propA: 1,
            propB: 2
        });
        QUnit.deepEqual(Object.keys(inst.get()), ['propA']);
    });
    QUnit.test('get and set can setup expandos', function () {
        var map = new DefineMap();
        var oi = new Observation(function () {
            return map.get('foo');
        }, null, {
            updater: function (newVal) {
                QUnit.equal(newVal, 'bar', 'updated to bar');
            }
        });
        oi.start();
        map.set('foo', 'bar');
    });
    QUnit.test('default settings', function () {
        var MyMap = DefineMap.extend({
            '*': 'string',
            foo: {}
        });
        var m = new MyMap();
        m.set('foo', 123);
        QUnit.ok(m.get('foo') === '123');
    });
    QUnit.test('default settings on unsealed', function () {
        var MyMap = DefineMap.extend({ seal: false }, { '*': 'string' });
        var m = new MyMap();
        m.set('foo', 123);
        QUnit.ok(m.get('foo') === '123');
    });
    if (!System.isEnv('production')) {
        QUnit.test('extends sealed objects (#48)', function () {
            var Map1 = DefineMap.extend({ seal: true }, {
                name: {
                    get: function (curVal) {
                        return 'computed ' + curVal;
                    }
                }
            });
            var Map2 = Map1.extend({ seal: false }, {});
            var Map3 = Map2.extend({ seal: true }, {});
            var map1 = new Map1({ name: 'Justin' });
            try {
                map1.foo = 'bar';
                if (map1.foo) {
                    QUnit.ok(false, 'map1 not sealed');
                } else {
                    QUnit.ok(true, 'map1 sealed - silent failure');
                }
            } catch (ex) {
                QUnit.ok(true, 'map1 sealed');
            }
            QUnit.equal(map1.name, 'computed Justin', 'map1.name property is computed');
            var map2 = new Map2({ name: 'Brian' });
            try {
                map2.foo = 'bar';
                if (map2.foo) {
                    QUnit.ok(true, 'map2 not sealed');
                } else {
                    QUnit.ok(false, 'map2 sealed');
                }
            } catch (ex) {
                QUnit.ok(false, 'map2 sealed');
            }
            QUnit.equal(map2.name, 'computed Brian', 'map2.name property is computed');
            var map3 = new Map3({ name: 'Curtis' });
            try {
                map3.foo = 'bar';
                if (map3.foo) {
                    QUnit.ok(false, 'map3 not sealed');
                } else {
                    QUnit.ok(true, 'map3 sealed');
                }
            } catch (ex) {
                QUnit.ok(true, 'map3 sealed');
            }
            QUnit.equal(map3.name, 'computed Curtis', 'map3.name property is computed');
        });
    }
    QUnit.test('get with dynamically added properties', function () {
        var map = new DefineMap();
        map.set('a', 1);
        map.set('b', 2);
        QUnit.deepEqual(map.get(), {
            a: 1,
            b: 2
        });
    });
    QUnit.test('set multiple props', function () {
        var map = new DefineMap();
        map.set({
            a: 0,
            b: 2
        });
        QUnit.deepEqual(map.get(), {
            a: 0,
            b: 2
        }, 'added props');
        map.set({ a: 2 }, true);
        QUnit.deepEqual(map.get(), { a: 2 }, 'removed b');
        map.set({ foo: { bar: 'VALUE' } });
        QUnit.deepEqual(map.get(), {
            foo: { bar: 'VALUE' },
            a: 2
        }, 'works nested');
    });
    QUnit.test('serialize responds to added props', function () {
        var map = new DefineMap();
        var oi = new Observation(function () {
            return map.serialize();
        }, null, {
            updater: function (newVal) {
                QUnit.deepEqual(newVal, {
                    a: 1,
                    b: 2
                }, 'updated right');
            }
        });
        oi.start();
        map.set({
            a: 1,
            b: 2
        });
    });
    QUnit.test('initialize an undefined property', function () {
        var MyMap = DefineMap.extend({ seal: false }, {});
        var instance = new MyMap({ foo: 'bar' });
        equal(instance.foo, 'bar');
    });
    QUnit.test('set an already initialized null property', function () {
        var map = new DefineMap({ foo: null });
        map.set({ foo: null });
        equal(map.foo, null);
    });
    QUnit.test('creating a new key doesn\'t cause two changes', 1, function () {
        var map = new DefineMap();
        var oi = new Observation(function () {
            return map.serialize();
        }, null, {
            updater: function (newVal) {
                QUnit.deepEqual(newVal, { a: 1 }, 'updated right');
            }
        });
        oi.start();
        map.set('a', 1);
    });
    QUnit.test('setting nested object', function () {
        var m = new DefineMap({});
        m.set({ foo: {} });
        m.set({ foo: {} });
        QUnit.deepEqual(m.get(), { foo: {} });
    });
    QUnit.test('passing a DefineMap to DefineMap (#33)', function () {
        var MyMap = DefineMap.extend({ foo: 'observable' });
        var m = new MyMap({
            foo: {},
            bar: {}
        });
        var m2 = new MyMap(m);
        QUnit.deepEqual(m.get(), m2.get());
        QUnit.ok(m.foo === m2.foo, 'defined props the same');
        QUnit.ok(m.bar === m2.bar, 'expando props the same');
    });
    QUnit.test('serialize: function works (#38)', function () {
        var Something = DefineMap.extend({});
        var MyMap = DefineMap.extend({
            somethingRef: {
                type: function (val) {
                    return new Something({ id: val });
                },
                serialize: function (val) {
                    return val.id;
                }
            },
            somethingElseRef: {
                type: function (val) {
                    return new Something({ id: val });
                },
                serialize: false
            }
        });
        var myMap = new MyMap({
            somethingRef: 2,
            somethingElseRef: 3
        });
        QUnit.ok(myMap.somethingRef instanceof Something);
        QUnit.deepEqual(myMap.serialize(), { somethingRef: 2 }, 'serialize: function and serialize: false works');
        var MyMap2 = DefineMap.extend({
            '*': {
                serialize: function (value) {
                    return '' + value;
                }
            }
        });
        var myMap2 = new MyMap2({
            foo: 1,
            bar: 2
        });
        QUnit.deepEqual(myMap2.serialize(), {
            foo: '1',
            bar: '2'
        }, 'serialize: function on default works');
    });
    QUnit.test('get will not create properties', function () {
        var method = function () {
        };
        var MyMap = DefineMap.extend({ method: method });
        var m = new MyMap();
        m.get('foo');
        QUnit.equal(m.get('method'), method);
    });
    QUnit.test('Properties are enumerable', function () {
        QUnit.expect(4);
        var VM = DefineMap.extend({ foo: 'string' });
        var vm = new VM({
            foo: 'bar',
            baz: 'qux'
        });
        var i = 0;
        each(vm, function (value, key) {
            if (i === 0) {
                QUnit.equal(key, 'foo');
                QUnit.equal(value, 'bar');
            } else {
                QUnit.equal(key, 'baz');
                QUnit.equal(value, 'qux');
            }
            i++;
        });
    });
    QUnit.test('Getters are not enumerable', function () {
        QUnit.expect(2);
        var MyMap = DefineMap.extend({
            foo: 'string',
            baz: {
                get: function () {
                    return this.foo;
                }
            }
        });
        var map = new MyMap({ foo: 'bar' });
        each(map, function (value, key) {
            QUnit.equal(key, 'foo');
            QUnit.equal(value, 'bar');
        });
    });
    QUnit.test('extending DefineMap constructor functions (#18)', function () {
        var AType = DefineMap.extend('AType', {
            aProp: {},
            aMethod: function () {
            }
        });
        var BType = AType.extend('BType', {
            bProp: {},
            bMethod: function () {
            }
        });
        var CType = BType.extend('CType', {
            cProp: {},
            cMethod: function () {
            }
        });
        var map = new CType();
        map.on('aProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'PROP');
            QUnit.equal(oldVal, undefined);
        });
        map.on('bProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'FOO');
            QUnit.equal(oldVal, undefined);
        });
        map.on('cProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'BAR');
            QUnit.equal(oldVal, undefined);
        });
        map.aProp = 'PROP';
        map.bProp = 'FOO';
        map.cProp = 'BAR';
        QUnit.ok(map.aMethod);
        QUnit.ok(map.bMethod);
        QUnit.ok(map.cMethod);
    });
    QUnit.test('extending DefineMap constructor functions more than once (#18)', function () {
        var AType = DefineMap.extend('AType', {
            aProp: {},
            aMethod: function () {
            }
        });
        var BType = AType.extend('BType', {
            bProp: {},
            bMethod: function () {
            }
        });
        var CType = AType.extend('CType', {
            cProp: {},
            cMethod: function () {
            }
        });
        var map1 = new BType();
        var map2 = new CType();
        map1.on('aProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'PROP', 'aProp newVal on map1');
            QUnit.equal(oldVal, undefined);
        });
        map1.on('bProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'FOO', 'bProp newVal on map1');
            QUnit.equal(oldVal, undefined);
        });
        map2.on('aProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'PROP', 'aProp newVal on map2');
            QUnit.equal(oldVal, undefined);
        });
        map2.on('cProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'BAR', 'cProp newVal on map2');
            QUnit.equal(oldVal, undefined);
        });
        map1.aProp = 'PROP';
        map1.bProp = 'FOO';
        map2.aProp = 'PROP';
        map2.cProp = 'BAR';
        QUnit.ok(map1.aMethod, 'map1 aMethod');
        QUnit.ok(map1.bMethod);
        QUnit.ok(map2.aMethod);
        QUnit.ok(map2.cMethod, 'map2 cMethod');
    });
    QUnit.test('extending DefineMap constructor functions - value (#18)', function () {
        var AType = DefineMap.extend('AType', { aProp: { value: 1 } });
        var BType = AType.extend('BType', {});
        var CType = BType.extend('CType', {});
        var c = new CType();
        QUnit.equal(c.aProp, 1, 'got initial value');
    });
    QUnit.test('copying DefineMap excludes constructor', function () {
        var AType = DefineMap.extend('AType', { aProp: { value: 1 } });
        var a = new AType();
        var b = assign({}, a);
        QUnit.notEqual(a.constructor, b.constructor, 'Constructor prop not copied');
        QUnit.equal(a.aProp, b.aProp, 'Other values are unaffected');
    });
    QUnit.test('cloning from non-defined map excludes special keys on setup', function () {
        var MyType = DefineMap.extend({});
        var a = new MyType({ 'foo': 'bar' });
        var b = new DefineMap(a);
        QUnit.notEqual(a.constructor, b.constructor, 'Constructor prop not copied');
        QUnit.notEqual(a._data, b._data, '_data prop not copied');
        QUnit.notEqual(a.__bindEvents, b.__bindEvents, '_bindEvents prop not copied');
        QUnit.notEqual(a._cid, b._cid, '_cid prop not copied');
        QUnit.equal(a.foo, b.foo, 'Other props copied');
    });
    QUnit.test('copying from .set() excludes special keys', function () {
        var MyType = DefineMap.extend({});
        var a = new MyType({
            'foo': 'bar',
            'existing': 'newVal'
        });
        var b = new DefineMap({ 'existing': 'oldVal' });
        b.set(a);
        QUnit.notEqual(a.constructor, b.constructor, 'Constructor prop not copied');
        QUnit.notEqual(a._data, b._data, '_data prop not copied');
        QUnit.notEqual(a.__bindEvents, b.__bindEvents, '_bindEvents prop not copied');
        QUnit.notEqual(a._cid, b._cid, '_cid prop not copied');
        QUnit.equal(a.foo, b.foo, 'NEw props copied');
    });
    QUnit.test('copying with assign() excludes special keys', function () {
        var a = {
            _data: {},
            constructor: function () {
            },
            __bindEvents: {},
            _cid: 'object0',
            'foo': 'bar',
            'existing': 'newVal'
        };
        var b = new DefineMap({ 'existing': 'oldVal' });
        assign(b, a);
        QUnit.notEqual(a.constructor, b.constructor, 'Constructor prop not copied');
        QUnit.notEqual(a._data, b._data, '_data prop not copied');
        QUnit.notEqual(a.__bindEvents, b.__bindEvents, '_bindEvents prop not copied');
        QUnit.notEqual(a._cid, b._cid, '_cid prop not copied');
        QUnit.equal(a.foo, b.foo, 'New props copied');
        QUnit.equal(a.existing, b.existing, 'Existing props copied');
    });
    QUnit.test('shorthand getter setter (#56)', function () {
        var Person = DefineMap.extend({
            first: '*',
            last: '*',
            get fullName() {
                return this.first + ' ' + this.last;
            },
            set fullName(newVal) {
                var parts = newVal.split(' ');
                this.first = parts[0];
                this.last = parts[1];
            }
        });
        var p = new Person({
            first: 'Mohamed',
            last: 'Cherif'
        });
        p.on('fullName', function (ev, newVal, oldVal) {
            QUnit.equal(oldVal, 'Mohamed Cherif');
            QUnit.equal(newVal, 'Justin Meyer');
        });
        equal(p.fullName, 'Mohamed Cherif', 'fullName initialized right');
        p.fullName = 'Justin Meyer';
    });
    QUnit.test('compute props can be set to null or undefined (#2372)', function () {
        var VM = DefineMap.extend({ computeProp: { type: 'compute' } });
        var vmNull = new VM({ computeProp: null });
        QUnit.equal(vmNull.get('computeProp'), null, 'computeProp is null, no error thrown');
        var vmUndef = new VM({ computeProp: undefined });
        QUnit.equal(vmUndef.get('computeProp'), undefined, 'computeProp is undefined, no error thrown');
    });
    QUnit.test('Inheriting DefineMap .set doesn\'t work if prop is on base map (#74)', function () {
        var Base = DefineMap.extend({ baseProp: 'string' });
        var Inheriting = Base.extend();
        var inherting = new Inheriting();
        inherting.set('baseProp', 'value');
        QUnit.equal(inherting.baseProp, 'value', 'set prop');
    });
    if (sealWorks && System.env.indexOf('production') < 0) {
        QUnit.test('setting not defined property', function () {
            var MyMap = DefineMap.extend({ prop: {} });
            var mymap = new MyMap();
            try {
                mymap.notdefined = 'value';
                ok(false, 'no error');
            } catch (e) {
                ok(true, 'error thrown');
            }
        });
    }
    QUnit.test('.extend errors when re-defining a property (#117)', function () {
        var A = DefineMap.extend('A', {
            foo: {
                type: 'string',
                value: 'blah'
            }
        });
        A.extend('B', {
            foo: {
                type: 'string',
                value: 'flub'
            }
        });
        var C = DefineMap.extend('C', {
            foo: {
                get: function () {
                    return 'blah';
                }
            }
        });
        C.extend('D', {
            foo: {
                get: function () {
                    return 'flub';
                }
            }
        });
        QUnit.ok(true, 'extended without errors');
    });
    QUnit.test('.value functions should not be observable', function () {
        var outer = new DefineMap({ bam: 'baz' });
        var ItemsVM = DefineMap.extend({
            item: {
                value: function () {
                    (function () {
                    }(this.zed, outer.bam));
                    return new DefineMap({ foo: 'bar' });
                }
            },
            zed: 'string'
        });
        var items = new ItemsVM();
        var count = 0;
        var itemsList = compute(function () {
            count++;
            return items.item;
        });
        itemsList.on('change', function () {
        });
        items.item.foo = 'changed';
        items.zed = 'changed';
        equal(count, 1);
    });
    QUnit.test('.value values are overwritten by props in DefineMap construction', function () {
        var Foo = DefineMap.extend({ bar: { value: 'baz' } });
        var foo = new Foo({ bar: 'quux' });
        equal(foo.bar, 'quux', 'Value set properly');
    });
    QUnit.test('can-reflect reflections work with DefineMap', function () {
        var b = new DefineMap({ 'foo': 'bar' });
        var c = new (DefineMap.extend({
            'baz': {
                get: function () {
                    return b.foo;
                }
            }
        }))({
            'foo': 'bar',
            thud: 'baz'
        });
        QUnit.equal(canReflect.getKeyValue(b, 'foo'), 'bar', 'unbound value');
        var handler = function (newValue) {
            QUnit.equal(newValue, 'quux', 'observed new value');
            canReflect.offKeyValue(c, 'baz', handler);
        };
        QUnit.ok(!canReflect.isValueLike(c), 'isValueLike is false');
        QUnit.ok(canReflect.isObservableLike(c), 'isObservableLike is true');
        QUnit.ok(canReflect.isMapLike(c), 'isMapLike is true');
        QUnit.ok(!canReflect.isListLike(c), 'isListLike is false');
        QUnit.ok(!canReflect.keyHasDependencies(b, 'foo'), 'keyHasDependencies -- false');
        canReflect.onKeyValue(c, 'baz', handler);
        canReflect.onKeyValue(c, 'thud', handler);
        QUnit.ok(canReflect.keyHasDependencies(c, 'baz'), 'keyHasDependencies -- true');
        b.foo = 'quux';
        c.thud = 'quux';
        QUnit.equal(canReflect.getKeyValue(c, 'baz'), 'quux', 'bound value');
        b.foo = 'thud';
        c.baz = 'jeek';
    });
    QUnit.test('can-reflect setKeyValue', function () {
        var a = new DefineMap({ 'a': 'b' });
        canReflect.setKeyValue(a, 'a', 'c');
        QUnit.equal(a.a, 'c', 'setKeyValue');
    });
    QUnit.test('can-reflect deleteKeyValue', function () {
        var a = new DefineMap({ 'a': 'b' });
        canReflect.deleteKeyValue(a, 'a');
        QUnit.equal(a.a, undefined, 'value is now undefined');
        QUnit.ok(!('a' in a.get()), 'value not included in serial');
    });
    QUnit.test('can-reflect getKeyDependencies', function () {
        var a = new DefineMap({ 'a': 'a' });
        var b = new (DefineMap.extend({
            'a': {
                get: function () {
                    return a.a;
                }
            }
        }))();
        ok(canReflect.getKeyDependencies(b, 'a'), 'dependencies exist');
        ok(!canReflect.getKeyDependencies(b, 'b'), 'no dependencies exist for unknown value');
        ok(canReflect.getKeyDependencies(b, 'a').valueDependencies.has(b._computed.a.compute), 'dependencies returned');
    });
    QUnit.test('can-reflect assign', function () {
        var aData = { 'a': 'b' };
        var bData = { 'b': 'c' };
        var a = new DefineMap(aData);
        var b = new DefineMap(bData);
        canReflect.assign(a, b);
        QUnit.deepEqual(a.get(), assign(aData, bData), 'when called with an object, should merge into existing object');
    });
    QUnit.test('Does not attempt to redefine _data if already defined', function () {
        var Bar = DefineMap.extend({ seal: false }, { baz: { value: 'thud' } });
        var baz = new Bar();
        define(baz, {
            quux: { value: 'jeek' },
            plonk: {
                get: function () {
                    return 'waldo';
                }
            }
        }, baz._define);
        QUnit.equal(baz.quux, 'jeek', 'New definitions successful');
        QUnit.equal(baz.plonk, 'waldo', 'New computed definitions successful');
        QUnit.equal(baz.baz, 'thud', 'Old definitions still available');
    });
    if (!System.isEnv('production')) {
        QUnit.test('redefines still not allowed on sealed objects', function () {
            QUnit.expect(6);
            var Bar = DefineMap.extend({ seal: true }, { baz: { value: 'thud' } });
            var baz = new Bar();
            try {
                define(baz, { quux: { value: 'jeek' } }, baz._define);
            } catch (e) {
                QUnit.ok(/is not extensible/i.test(e.message), 'Sealed object throws on data property defines');
                QUnit.ok(!Object.getOwnPropertyDescriptor(baz, 'quux'), 'nothing set on object');
                QUnit.ok(!Object.getOwnPropertyDescriptor(baz._data, 'quux'), 'nothing set on _data');
            }
            try {
                define(baz, {
                    plonk: {
                        get: function () {
                            return 'waldo';
                        }
                    }
                }, baz._define);
            } catch (e) {
                QUnit.ok(/is not extensible/i.test(e.message), 'Sealed object throws on computed property defines');
                QUnit.ok(!Object.getOwnPropertyDescriptor(baz, 'plonk'), 'nothing set on object');
                QUnit.ok(!Object.getOwnPropertyDescriptor(baz._computed, 'plonk'), 'nothing set on _computed');
            }
        });
    }
    QUnit.test('Call .get() when a nested object has its own get method', function () {
        var Bar = DefineMap.extend({ request: '*' });
        var request = {
            prop: 22,
            get: function () {
                if (arguments.length === 0) {
                    throw new Error('This function can\'t be called with 0 arguments');
                }
            }
        };
        var obj = new Bar({ request: request });
        var data = obj.get();
        QUnit.equal(data.request.prop, 22, 'obj did get()');
    });
    QUnit.test('DefineMap short-hand Type (#221)', function () {
        var Child = DefineMap.extend('child', { other: DefineMap });
        var c = new Child();
        c.other = { prop: 'hello' };
        QUnit.ok(c.other instanceof DefineMap, 'is a DefineMap');
    });
    QUnit.test('non-Object constructor', function () {
        var Constructor = DefineMap.extend();
        QUnit.ok(!isPlainObject(new DefineMap()), 'instance of DefineMap is not a plain object');
        QUnit.ok(!isPlainObject(new Constructor()), 'instance of extended DefineMap is not a plain object');
    });
});
/*can-define@1.3.2#define-test*/
define('can-define@1.3.2#define-test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var compute = require('can-compute');
    var define = require('can-define');
    var CanList = require('can-define/list/list');
    var canBatch = require('can-event/batch/batch');
    var isArray = require('can-util/js/is-array/is-array');
    var each = require('can-util/js/each/each');
    var canSymbol = require('can-symbol');
    QUnit.module('can-define');
    QUnit.test('basics on a prototype', 5, function () {
        var Person = function (first, last) {
            this.first = first;
            this.last = last;
        };
        define(Person.prototype, {
            first: '*',
            last: '*',
            fullName: {
                get: function () {
                    return this.first + ' ' + this.last;
                }
            }
        });
        var p = new Person('Mohamed', 'Cherif');
        p.bind('fullName', function (ev, newVal, oldVal) {
            QUnit.equal(oldVal, 'Mohamed Cherif');
            QUnit.equal(newVal, 'Justin Meyer');
        });
        equal(p.fullName, 'Mohamed Cherif', 'fullName initialized right');
        p.bind('first', function (el, newVal, oldVal) {
            QUnit.equal(newVal, 'Justin', 'first new value');
            QUnit.equal(oldVal, 'Mohamed', 'first old value');
        });
        canBatch.start();
        p.first = 'Justin';
        p.last = 'Meyer';
        canBatch.stop();
    });
    QUnit.test('basics set', 2, function () {
        var Defined = function (prop) {
            this.prop = prop;
        };
        define(Defined.prototype, {
            prop: {
                set: function (newVal) {
                    return 'foo' + newVal;
                }
            }
        });
        var def = new Defined();
        def.prop = 'bar';
        QUnit.equal(def.prop, 'foobar', 'setter works');
        var DefinedCB = function (prop) {
            this.prop = prop;
        };
        define(DefinedCB.prototype, {
            prop: {
                set: function (newVal, setter) {
                    setter('foo' + newVal);
                }
            }
        });
        var defCallback = new DefinedCB();
        defCallback.prop = 'bar';
        QUnit.equal(defCallback.prop, 'foobar', 'setter callback works');
    });
    QUnit.test('basic type', function () {
        QUnit.expect(6);
        var Typer = function (arrayWithAddedItem, listWithAddedItem) {
            this.arrayWithAddedItem = arrayWithAddedItem;
            this.listWithAddedItem = listWithAddedItem;
        };
        define(Typer.prototype, {
            arrayWithAddedItem: {
                type: function (value) {
                    if (value && value.push) {
                        value.push('item');
                    }
                    return value;
                }
            },
            listWithAddedItem: {
                type: function (value) {
                    if (value && value.push) {
                        value.push('item');
                    }
                    return value;
                },
                Type: CanList
            }
        });
        var t = new Typer();
        deepEqual(Object.keys(t), [], 'no keys');
        var array = [];
        t.arrayWithAddedItem = array;
        deepEqual(array, ['item'], 'updated array');
        QUnit.equal(t.arrayWithAddedItem, array, 'leave value as array');
        t.listWithAddedItem = [];
        QUnit.ok(t.listWithAddedItem instanceof CanList, 'convert to CanList');
        QUnit.equal(t.listWithAddedItem[0], 'item', 'has item in it');
        compute(function () {
            return t.listWithAddedItem.attr('length');
        }).addEventListener('change', function (ev, newVal) {
            QUnit.equal(newVal, 2, 'got a length change');
        });
        t.listWithAddedItem.push('another item');
    });
    QUnit.test('basic Type', function () {
        var Foo = function (name) {
            this.name = name;
        };
        Foo.prototype.getName = function () {
            return this.name;
        };
        var Typer = function (foo) {
            this.foo = foo;
        };
        define(Typer.prototype, { foo: { Type: Foo } });
        var t = new Typer('Justin');
        QUnit.equal(t.foo.getName(), 'Justin', 'correctly created an instance');
        var brian = new Foo('brian');
        t.foo = brian;
        QUnit.equal(t.foo, brian, 'same instances');
    });
    QUnit.test('type converters', function () {
        var Typer = function (date, string, number, bool, htmlbool, leaveAlone) {
            this.date = date;
            this.string = string;
            this.number = number;
            this.bool = bool;
            this.htmlbool = htmlbool;
            this.leaveAlone = leaveAlone;
        };
        define(Typer.prototype, {
            date: { type: 'date' },
            string: { type: 'string' },
            number: { type: 'number' },
            bool: { type: 'boolean' },
            htmlbool: { type: 'htmlbool' },
            leaveAlone: { type: '*' }
        });
        var obj = {};
        var t = new Typer(1395896701516, 5, '5', 'false', '', obj);
        QUnit.ok(t.date instanceof Date, 'converted to date');
        QUnit.equal(t.string, '5', 'converted to string');
        QUnit.equal(t.number, 5, 'converted to number');
        QUnit.equal(t.bool, false, 'converted to boolean');
        QUnit.equal(t.htmlbool, true, 'converted to htmlbool');
        QUnit.equal(t.leaveAlone, obj, 'left as object');
        t.number = '15';
        QUnit.ok(t.number === 15, 'converted to number');
    });
    QUnit.test('basics value', function () {
        var Typer = function (prop) {
            if (prop !== undefined) {
                this.prop = prop;
            }
        };
        define(Typer.prototype, { prop: { value: 'foo' } });
        var t = new Typer();
        QUnit.equal(t.prop, 'foo', 'value is used as default value');
        var Typer2 = function (prop) {
            if (prop !== undefined) {
                this.prop = prop;
            }
        };
        define(Typer2.prototype, {
            prop: {
                value: function () {
                    return [];
                },
                type: '*'
            }
        });
        var t1 = new Typer2(), t2 = new Typer2();
        QUnit.ok(t1.prop !== t2.prop, 'different array instances');
        QUnit.ok(isArray(t1.prop), 'its an array');
    });
    test('basics Value', function () {
        var Typer = function (prop) {
        };
        define(Typer.prototype, {
            prop: {
                Value: Array,
                type: '*'
            }
        });
        var t1 = new Typer(), t2 = new Typer();
        QUnit.ok(t1.prop !== t2.prop, 'different array instances');
        QUnit.ok(isArray(t1.prop), 'its an array');
    });
    test('setter with no arguments and returns undefined does the default behavior, the setter is for side effects only', function () {
        var Typer = function (prop) {
        };
        define(Typer.prototype, {
            prop: {
                set: function () {
                    this.foo = 'bar';
                }
            },
            foo: '*'
        });
        var t = new Typer();
        t.prop = false;
        deepEqual({
            foo: t.foo,
            prop: t.prop
        }, {
            foo: 'bar',
            prop: false
        }, 'got the right props');
    });
    test('type happens before the set', 2, function () {
        var Typer = function () {
        };
        define(Typer.prototype, {
            prop: {
                type: 'number',
                set: function (newValue) {
                    equal(typeof newValue, 'number', 'got a number');
                    return newValue + 1;
                }
            }
        });
        var map = new Typer();
        map.prop = '5';
        equal(map.prop, 6, 'number');
    });
    test('getter and setter work', function () {
        expect(5);
        var Paginate = define.Constructor({
            limit: '*',
            offset: '*',
            page: {
                set: function (newVal) {
                    this.offset = (parseInt(newVal) - 1) * this.limit;
                },
                get: function () {
                    return Math.floor(this.offset / this.limit) + 1;
                }
            }
        });
        var p = new Paginate({
            limit: 10,
            offset: 20
        });
        equal(p.page, 3, 'page get right');
        p.bind('page', function (ev, newValue, oldValue) {
            equal(newValue, 2, 'got new value event');
            equal(oldValue, 3, 'got old value event');
        });
        p.page = 2;
        equal(p.page, 2, 'page set right');
        equal(p.offset, 10, 'page offset set');
    });
    test('getter with initial value', function () {
        var comp = compute(1);
        var Grabber = define.Constructor({
            vals: {
                type: '*',
                Value: Array,
                get: function (current, setVal) {
                    if (setVal) {
                        current.push(comp());
                    }
                    return current;
                }
            }
        });
        var g = new Grabber();
        equal(g.vals.length, 0, 'zero items in array');
    });
    test('Value generator can read other properties', function () {
        var Map = define.Constructor({
            letters: { value: 'ABC' },
            numbers: {
                value: [
                    1,
                    2,
                    3
                ]
            },
            definedLetters: { value: 'DEF' },
            definedNumbers: {
                value: [
                    4,
                    5,
                    6
                ]
            },
            generatedLetters: {
                value: function () {
                    return 'GHI';
                }
            },
            generatedNumbers: {
                value: function () {
                    return new CanList([
                        7,
                        8,
                        9
                    ]);
                }
            },
            firstLetter: {
                value: function () {
                    return this.letters.substr(0, 1);
                }
            },
            firstNumber: {
                value: function () {
                    return this.numbers[0];
                }
            },
            middleLetter: {
                value: function () {
                    return this.definedLetters.substr(1, 1);
                }
            },
            middleNumber: {
                value: function () {
                    return this.definedNumbers[1];
                }
            },
            lastLetter: {
                value: function () {
                    return this.generatedLetters.substr(2, 1);
                }
            },
            lastNumber: {
                value: function () {
                    return this.generatedNumbers[2];
                }
            }
        });
        var map = new Map();
        var prefix = 'Was able to read dependent value from ';
        equal(map.firstLetter, 'A', prefix + 'traditional can.Map style property definition');
        equal(map.firstNumber, 1, prefix + 'traditional can.Map style property definition');
        equal(map.middleLetter, 'E', prefix + 'define plugin style default property definition');
        equal(map.middleNumber, 5, prefix + 'define plugin style default property definition');
        equal(map.lastLetter, 'I', prefix + 'define plugin style generated default property definition');
        equal(map.lastNumber, 9, prefix + 'define plugin style generated default property definition');
    });
    test('default behaviors with "*" work for attributes', function () {
        expect(6);
        var DefaultMap = define.Constructor({
            '*': {
                type: 'number',
                set: function (newVal) {
                    ok(true, 'set called');
                    return newVal;
                }
            },
            someNumber: { value: '5' },
            number: {}
        });
        var map = new DefaultMap();
        equal(map.someNumber, '5', 'default values are not type converted anymore');
        map.someNumber = '5';
        equal(map.someNumber, 5, 'on a set, they should be type converted');
        map.number = '10';
        equal(map.number, 10, 'value of number should be converted to a number');
    });
    test('nested define', function () {
        var nailedIt = 'Nailed it';
        var Example = define.Constructor({ name: { value: nailedIt } });
        var NestedMap = define.Constructor({
            isEnabled: { value: true },
            test: { Value: Example },
            examples: {
                type: {
                    one: { Value: Example },
                    two: {
                        type: { deep: { Value: Example } },
                        Value: Object
                    }
                },
                Value: Object
            }
        });
        var nested = new NestedMap();
        equal(nested.test.name, nailedIt);
        equal(nested.examples.one.name, nailedIt);
        equal(nested.examples.two.deep.name, nailedIt);
        ok(nested.test instanceof Example);
        ok(nested.examples.one instanceof Example);
        ok(nested.examples.two.deep instanceof Example);
    });
    test('Can make an attr alias a compute (#1470)', 9, function () {
        var computeValue = compute(1);
        var GetMap = define.Constructor({
            value: {
                set: function (newValue, setVal, oldValue) {
                    if (newValue.isComputed) {
                        return newValue;
                    }
                    if (oldValue && oldValue.isComputed) {
                        oldValue(newValue);
                        return oldValue;
                    }
                    return newValue;
                },
                get: function (value) {
                    return value && value.isComputed ? value() : value;
                }
            }
        });
        var getMap = new GetMap();
        getMap.value = computeValue;
        equal(getMap.value, 1, 'initial value read from compute');
        var bindCallbacks = 0;
        getMap.bind('value', function (ev, newVal, oldVal) {
            switch (bindCallbacks) {
            case 0:
                equal(newVal, 2, '0 - bind called with new val');
                equal(oldVal, 1, '0 - bind called with old val');
                break;
            case 1:
                equal(newVal, 3, '1 - bind called with new val');
                equal(oldVal, 2, '1 - bind called with old val');
                break;
            case 2:
                equal(newVal, 4, '2 - bind called with new val');
                equal(oldVal, 3, '2 - bind called with old val');
                break;
            }
            bindCallbacks++;
        });
        computeValue(2);
        getMap.value = 3;
        equal(getMap.value, 3, 'read value is 3');
        equal(computeValue(), 3, 'the compute value is 3');
        var newComputeValue = compute(4);
        getMap.value = newComputeValue;
    });
    test('value and get (#1521)', function () {
        var MyMap = define.Constructor({
            data: {
                value: function () {
                    return new CanList(['test']);
                }
            },
            size: {
                value: 1,
                get: function (val) {
                    var list = this.data;
                    var length = list.attr('length');
                    return val + length;
                }
            }
        });
        var map = new MyMap({});
        equal(map.size, 2);
    });
    test('One event on getters (#1585)', function () {
        var Person = define.Constructor({
            name: '*',
            id: 'number'
        });
        var AppState = define.Constructor({
            person: {
                get: function (lastSetValue, resolve) {
                    if (lastSetValue) {
                        return lastSetValue;
                    } else if (this.personId) {
                        resolve(new Person({
                            name: 'Jose',
                            id: 5
                        }));
                    } else {
                        return null;
                    }
                },
                Type: Person
            },
            personId: '*'
        });
        var appState = new AppState();
        var personEvents = 0;
        appState.bind('person', function (ev, person) {
            personEvents++;
        });
        equal(appState.person, null, 'no personId and no lastSetValue');
        appState.personId = 5;
        equal(appState.person.name, 'Jose', 'a personId, providing Jose');
        ok(appState.person instanceof Person, 'got a person instance');
        appState.person = { name: 'Julia' };
        ok(appState.person instanceof Person, 'got a person instance');
        equal(personEvents, 2);
    });
    test('Can read a defined property with a set/get method (#1648)', function () {
        var Map = define.Constructor({
            foo: {
                value: '',
                set: function (setVal) {
                    return setVal;
                },
                get: function (lastSetVal) {
                    return lastSetVal;
                }
            }
        });
        var map = new Map();
        equal(map.foo, '', 'Calling .foo returned the correct value');
        map.foo = 'baz';
        equal(map.foo, 'baz', 'Calling .foo returned the correct value');
    });
    test('Can bind to a defined property with a set/get method (#1648)', 3, function () {
        var Map = define.Constructor({
            foo: {
                value: '',
                set: function (setVal) {
                    return setVal;
                },
                get: function (lastSetVal) {
                    return lastSetVal;
                }
            }
        });
        var map = new Map();
        map.bind('foo', function () {
            ok(true, 'Bound function is called');
        });
        equal(map.foo, '', 'Calling .attr(\'foo\') returned the correct value');
        map.foo = 'baz';
        equal(map.foo, 'baz', 'Calling .attr(\'foo\') returned the correct value');
    });
    test('type converters handle null and undefined in expected ways (1693)', function () {
        var Typer = define.Constructor({
            date: { type: 'date' },
            string: { type: 'string' },
            number: { type: 'number' },
            'boolean': { type: 'boolean' },
            htmlbool: { type: 'htmlbool' },
            leaveAlone: { type: '*' }
        });
        var t = new Typer({
            date: undefined,
            string: undefined,
            number: undefined,
            'boolean': undefined,
            htmlbool: undefined,
            leaveAlone: undefined
        });
        equal(t.date, undefined, 'converted to date');
        equal(t.string, undefined, 'converted to string');
        equal(t.number, undefined, 'converted to number');
        equal(t.boolean, undefined, 'converted to boolean');
        equal(t.htmlbool, false, 'converted to htmlbool');
        equal(t.leaveAlone, undefined, 'left as object');
        t = new Typer({
            date: null,
            string: null,
            number: null,
            'boolean': null,
            htmlbool: null,
            leaveAlone: null
        });
        equal(t.date, null, 'converted to date');
        equal(t.string, null, 'converted to string');
        equal(t.number, null, 'converted to number');
        equal(t.boolean, null, 'converted to boolean');
        equal(t.htmlbool, false, 'converted to htmlbool');
        equal(t.leaveAlone, null, 'left as object');
    });
    test('Initial value does not call getter', function () {
        expect(0);
        var Map = define.Constructor({
            count: {
                get: function (lastVal) {
                    ok(false, 'Should not be called');
                    return lastVal;
                }
            }
        });
        new Map({ count: 100 });
    });
    test('getters produce change events', function () {
        var Map = define.Constructor({
            count: {
                get: function (lastVal) {
                    return lastVal;
                }
            }
        });
        var map = new Map();
        map.bind('count', function () {
            ok(true, 'change called');
        });
        map.count = 22;
    });
    test('Asynchronous virtual properties cause extra recomputes (#1915)', function () {
        stop();
        var ran = false;
        var VM = define.Constructor({
            foo: {
                get: function (lastVal, setVal) {
                    setTimeout(function () {
                        if (setVal) {
                            setVal(5);
                        }
                    }, 10);
                }
            },
            bar: {
                get: function () {
                    var foo = this.foo;
                    if (foo) {
                        if (ran) {
                            ok(false, 'Getter ran twice');
                        }
                        ran = true;
                        return foo * 2;
                    }
                }
            }
        });
        var vm = new VM();
        vm.bind('bar', function () {
        });
        setTimeout(function () {
            equal(vm.bar, 10);
            start();
        }, 200);
    });
    QUnit.test('Default values cannot be set (#8)', function () {
        var Person = function () {
        };
        define(Person.prototype, {
            first: {
                type: 'string',
                value: 'Chris'
            },
            last: {
                type: 'string',
                value: 'Gomez'
            },
            fullName: {
                get: function () {
                    return this.first + ' ' + this.last;
                }
            }
        });
        var p = new Person();
        QUnit.equal(p.fullName, 'Chris Gomez', 'Fullname is correct');
        p.first = 'Sara';
        QUnit.equal(p.fullName, 'Sara Gomez', 'Fullname is correct after update');
    });
    QUnit.test('default type is setable', function () {
        var Person = function () {
        };
        define(Person.prototype, {
            '*': 'string',
            first: { value: 1 },
            last: { value: 2 }
        });
        var p = new Person();
        QUnit.ok(p.first === '1', typeof p.first);
        QUnit.ok(p.last === '2', typeof p.last);
    });
    QUnit.test('expandos are added in define.setup (#25)', function () {
        var MyMap = define.Constructor({});
        var map = new MyMap({ prop: 4 });
        map.on('prop', function () {
            QUnit.ok(true, 'prop event called');
        });
        map.prop = 5;
    });
    if (compute.prototype.trace) {
        QUnit.test('logs work with maps', function () {
            var MyMap = define.Constructor({
                first: 'string',
                last: 'string'
            });
            var m = new MyMap({
                first: 'J',
                last: 'M'
            });
            var fullName = compute(function () {
                return m.first + m.last;
            });
            fullName.on('change', function () {
            });
            var t = fullName.computeInstance.trace();
            QUnit.equal(t.dependencies[0].obj, m);
            QUnit.equal(t.dependencies[1].obj, m);
        });
    }
    QUnit.test('Set property with type compute', function () {
        var MyMap = define.Constructor({ computeProp: { type: 'compute' } });
        var m = new MyMap();
        m.computeProp = compute(0);
        equal(m.computeProp, 0, 'Property has correct value');
        m.computeProp = compute(1);
        equal(m.computeProp, 1, 'Property has correct value');
    });
    QUnit.test('Compute type property can have a default value', function () {
        var MyMap = define.Constructor({
            computeProp: {
                type: 'compute',
                value: function () {
                    return 0;
                }
            }
        });
        var m = new MyMap();
        equal(m.computeProp, 0, 'Property has correct value');
        m.computeProp = 1;
        equal(m.computeProp, 1, 'Property has correct value');
    });
    QUnit.test('Compute type property with compute default value triggers change events when updated', function () {
        var expected = 0;
        var c = compute(0);
        var MyMap = define.Constructor({
            computeProp: {
                type: 'compute',
                value: function () {
                    return c;
                }
            }
        });
        var m = new MyMap();
        c.bind('change', function (ev, newVal) {
            equal(newVal, expected, 'Compute fired change event');
        });
        m.on('computeProp', function (ev, newVal) {
            equal(newVal, expected, 'Map fired change event');
        });
        expected = 1;
        m.computeProp = expected;
        expected = 2;
        c(expected);
    });
    QUnit.test('Compute type property can have a default value that is a compute', function () {
        var c = compute(0);
        var MyMap = define.Constructor({
            computeProp: {
                type: 'compute',
                value: function () {
                    return c;
                }
            }
        });
        var m = new MyMap();
        equal(m.computeProp, 0, 'Property has correct value');
        c(1);
        equal(m.computeProp, 1, 'Property has correct value');
    });
    QUnit.test('Extensions can modify definitions', function () {
        var oldExtensions = define.extensions;
        define.behaviors.push('extended');
        define.extensions = function (objPrototype, prop, definition) {
            if (definition.extended) {
                return { value: 'extended' };
            }
        };
        var MyMap = define.Constructor({
            foo: {
                value: 'defined',
                extended: true
            },
            bar: { value: 'defined' }
        });
        var map = new MyMap();
        QUnit.equal(map.foo, 'extended', 'Value was set via extension');
        QUnit.equal(map.bar, 'defined', 'Value was set via definition');
        define.extensions = oldExtensions;
    });
    QUnit.test('Properties are enumerable', function () {
        QUnit.expect(4);
        function VM(foo) {
            this.foo = foo;
        }
        define(VM.prototype, { foo: 'string' });
        var vm = new VM('bar');
        vm.baz = 'qux';
        var i = 0;
        each(vm, function (value, key) {
            if (i === 0) {
                QUnit.equal(key, 'foo');
                QUnit.equal(value, 'bar');
            } else {
                QUnit.equal(key, 'baz');
                QUnit.equal(value, 'qux');
            }
            i++;
        });
    });
    QUnit.test('Doesn\'t override canSymbol.iterator if already on the prototype', function () {
        function MyMap() {
        }
        MyMap.prototype[canSymbol.iterator || canSymbol.for('iterator')] = function () {
            var i = 0;
            return {
                next: function () {
                    if (i === 0) {
                        i++;
                        return {
                            value: [
                                'it',
                                'worked'
                            ],
                            done: false
                        };
                    }
                    return {
                        value: undefined,
                        done: true
                    };
                }
            };
        };
        define(MyMap.prototype, { foo: 'string' });
        var map = new MyMap();
        map.foo = 'bar';
        each(map, function (value, key) {
            QUnit.equal(value, 'worked');
            QUnit.equal(key, 'it');
        });
    });
    QUnit.test('nullish values are not converted for type or Type', function (assert) {
        var Foo = function () {
        };
        var MyMap = define.Constructor({
            map: { Type: Foo },
            notype: {}
        });
        var vm = new MyMap({
            map: {},
            notype: {}
        });
        assert.ok(vm.map instanceof Foo, 'map is another type');
        assert.ok(vm.notype instanceof Object, 'notype is an Object');
        vm.map = null;
        vm.notype = null;
        assert.equal(vm.map, null, 'map is null');
        assert.equal(vm.map, null, 'notype is null');
    });
    QUnit.test('shorthand getter (#56)', function () {
        var Person = function (first, last) {
            this.first = first;
            this.last = last;
        };
        define(Person.prototype, {
            first: '*',
            last: '*',
            get fullName() {
                return this.first + ' ' + this.last;
            }
        });
        var p = new Person('Mohamed', 'Cherif');
        p.on('fullName', function (ev, newVal, oldVal) {
            QUnit.equal(oldVal, 'Mohamed Cherif');
            QUnit.equal(newVal, 'Justin Meyer');
        });
        equal(p.fullName, 'Mohamed Cherif', 'fullName initialized right');
        canBatch.start();
        p.first = 'Justin';
        p.last = 'Meyer';
        canBatch.stop();
    });
    QUnit.test('shorthand getter setter (#56)', function () {
        var Person = function (first, last) {
            this.first = first;
            this.last = last;
        };
        define(Person.prototype, {
            first: '*',
            last: '*',
            get fullName() {
                return this.first + ' ' + this.last;
            },
            set fullName(newVal) {
                var parts = newVal.split(' ');
                this.first = parts[0];
                this.last = parts[1];
            }
        });
        var p = new Person('Mohamed', 'Cherif');
        p.on('fullName', function (ev, newVal, oldVal) {
            QUnit.equal(oldVal, 'Mohamed Cherif');
            QUnit.equal(newVal, 'Justin Meyer');
        });
        equal(p.fullName, 'Mohamed Cherif', 'fullName initialized right');
        p.fullName = 'Justin Meyer';
    });
    QUnit.test('set and value work together (#87)', function () {
        var Type = define.Constructor({
            prop: {
                value: 2,
                set: function (num) {
                    return num * num;
                }
            }
        });
        var instance = new Type();
        QUnit.equal(instance.prop, 4, 'used setter');
    });
    QUnit.test('async setter is provided', 5, function () {
        var RESOLVE;
        var Type = define.Constructor({
            prop: {
                value: 2,
                set: function (num, resolve) {
                    resolve(num * num);
                }
            },
            prop2: {
                value: 3,
                set: function (num, resolve) {
                    RESOLVE = resolve;
                }
            }
        });
        var instance = new Type();
        QUnit.equal(instance.prop, 4, 'used async setter');
        QUnit.equal(instance.prop2, undefined, 'used async setter');
        instance.on('prop2', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 9, 'updated');
            QUnit.equal(oldVal, undefined, 'updated');
        });
        RESOLVE(9);
        QUnit.equal(instance.prop2, 9, 'used async setter updates after');
    });
    QUnit.test('setter with default value causes an infinite loop (#142)', function () {
        var A = define.Constructor({
            val: {
                value: 'hello',
                set: function (val) {
                    if (this.val) {
                    }
                    return val;
                }
            }
        });
        var a = new A();
        QUnit.equal(a.val, 'hello', 'creating an instance should not cause an inifinte loop');
    });
    QUnit.test('defined properties are configurable', function () {
        var A = define.Constructor({
            val: {
                get: function () {
                    return 'foo';
                }
            }
        });
        var dataInitializers = A.prototype._define.dataInitializers, computedInitializers = A.prototype._define.computedInitializers;
        var newDefinition = {
            get: function () {
                return 'bar';
            }
        };
        define.property(A.prototype, 'val', newDefinition, dataInitializers, computedInitializers);
        var a = new A();
        QUnit.equal(a.val, 'bar', 'It was redefined');
    });
});
/*can-define@1.3.2#test/test*/
define('can-define@1.3.2#test/test', function (require, exports, module) {
    require('../list/list-test');
    require('../map/map-test');
    require('../define-test');
    var DefineMap = require('can-define/map/map');
    var DefineList = require('can-define/list/list');
    var isArray = require('can-util/js/is-array/is-array');
    var isPlainObject = require('can-util/js/is-plain-object/is-plain-object');
    var types = require('can-types');
    var QUnit = require('steal-qunit');
    QUnit.module('can-define: map and list combined');
    QUnit.test('basics', function () {
        var items = new DefineMap({
            people: [
                { name: 'Justin' },
                { name: 'Brian' }
            ],
            count: 1000
        });
        QUnit.ok(items.people instanceof types.DefineList, 'people is list');
        QUnit.ok(items.people.item(0) instanceof types.DefineMap, '1st object is Map');
        QUnit.ok(items.people.item(1) instanceof types.DefineMap, '2nd object is Map');
        QUnit.equal(items.people.item(1).name, 'Brian', '2nd object\'s name is right');
        QUnit.equal(items.count, 1000, 'count is number');
    });
    QUnit.test('serialize works', function () {
        var Person = DefineMap.extend({
            first: 'string',
            last: 'string'
        });
        var People = DefineList.extend({ '*': Person });
        var people = new People([{
                first: 'j',
                last: 'm'
            }]);
        QUnit.deepEqual(people.serialize(), [{
                first: 'j',
                last: 'm'
            }]);
    });
    QUnit.test('Extended Map with empty def converts to default Observables', function () {
        var School = DefineMap.extend({
            students: {},
            teacher: {}
        });
        var school = new School();
        school.students = [{ name: 'J' }];
        school.teacher = { name: 'M' };
        ok(school.students instanceof types.DefineList, 'converted to DefineList');
        ok(school.teacher instanceof types.DefineMap, 'converted to DefineMap');
    });
    QUnit.test('default \'observable\' type prevents Type from working (#29)', function () {
        var M = DefineMap.extend('M', { id: 'number' });
        var L = DefineList.extend('L', { '*': M });
        var MyMap = DefineMap.extend({ l: L });
        var m = new MyMap({ l: [{ id: 5 }] });
        QUnit.ok(m.l[0] instanceof M, 'is instance');
        QUnit.equal(m.l[0].id, 5, 'correct props');
    });
    QUnit.test('inline DefineList Type', function () {
        var M = DefineMap.extend('M', { id: 'number' });
        var MyMap = DefineMap.extend({ l: { Type: [M] } });
        var m = new MyMap({ l: [{ id: 5 }] });
        QUnit.ok(m.l[0] instanceof M, 'is instance');
        QUnit.equal(m.l[0].id, 5, 'correct props');
    });
    QUnit.test('recursively `get`s (#31)', function () {
        var M = DefineMap.extend('M', { id: 'number' });
        var MyMap = DefineMap.extend({ l: { Type: [M] } });
        var m = new MyMap({ l: [{ id: 5 }] });
        var res = m.get();
        QUnit.ok(isArray(res.l), 'is a plain array');
        QUnit.ok(isPlainObject(res.l[0]), 'plain object');
    });
    QUnit.test('DefineList trigger deprecation warning when set with Map.set (#93)', 0, function () {
        var map = new DefineMap({ things: [{ foo: 'bar' }] });
        map.things.attr = function () {
            ok(false, 'attr should not be called');
        };
        map.set({ things: [{ baz: 'luhrmann' }] });
    });
});
/*can-set@1.3.0#src/helpers*/
define('can-set@1.3.0#src/helpers', function (require, exports, module) {
    var assign = require('can-util/js/assign/assign');
    var each = require('can-util/js/each/each');
    var last = require('can-util/js/last/last');
    var IgnoreType = function () {
    };
    var helpers;
    module.exports = helpers = {
        eachInUnique: function (a, acb, b, bcb, defaultReturn) {
            var bCopy = assign({}, b), res;
            for (var prop in a) {
                res = acb(a[prop], b[prop], a, b, prop);
                if (res !== undefined) {
                    return res;
                }
                delete bCopy[prop];
            }
            for (prop in bCopy) {
                res = bcb(undefined, b[prop], a, b, prop);
                if (res !== undefined) {
                    return res;
                }
            }
            return defaultReturn;
        },
        doubleLoop: function (arr, callbacks) {
            if (typeof callbacks === 'function') {
                callbacks = { iterate: callbacks };
            }
            var i = 0;
            while (i < arr.length) {
                if (callbacks.start) {
                    callbacks.start(arr[i]);
                }
                var j = i + 1;
                while (j < arr.length) {
                    if (callbacks.iterate(arr[j], j, arr[i], i) === false) {
                        arr.splice(j, 1);
                    } else {
                        j++;
                    }
                }
                if (callbacks.end) {
                    callbacks.end(arr[i]);
                }
                i++;
            }
        },
        identityMap: function (arr) {
            var map = {};
            each(arr, function (value) {
                map[value] = 1;
            });
            return map;
        },
        arrayUnionIntersectionDifference: function (arr1, arr2) {
            var map = {};
            var intersection = [];
            var union = [];
            var difference = arr1.slice(0);
            each(arr1, function (value) {
                map[value] = true;
                union.push(value);
            });
            each(arr2, function (value) {
                if (map[value]) {
                    intersection.push(value);
                    var index = helpers.indexOf.call(difference, value);
                    if (index !== -1) {
                        difference.splice(index, 1);
                    }
                } else {
                    union.push(value);
                }
            });
            return {
                intersection: intersection,
                union: union,
                difference: difference
            };
        },
        arraySame: function (arr1, arr2) {
            if (arr1.length !== arr2.length) {
                return false;
            }
            var map = helpers.identityMap(arr1);
            for (var i = 0; i < arr2.length; i++) {
                var val = map[arr2[i]];
                if (!val) {
                    return false;
                } else if (val > 1) {
                    return false;
                } else {
                    map[arr2[i]]++;
                }
            }
            return true;
        },
        indexOf: Array.prototype.indexOf || function (item) {
            for (var i = 0, thisLen = this.length; i < thisLen; i++) {
                if (this[i] === item) {
                    return i;
                }
            }
            return -1;
        },
        map: Array.prototype.map || function (cb) {
            var out = [];
            for (var i = 0, len = this.length; i < len; i++) {
                out.push(cb(this[i], i, this));
            }
            return out;
        },
        filter: Array.prototype.filter || function (cb) {
            var out = [];
            for (var i = 0, len = this.length; i < len; i++) {
                if (cb(this[i], i, this)) {
                    out.push(this[i]);
                }
            }
            return out;
        },
        ignoreType: new IgnoreType(),
        firstProp: function (set) {
            for (var prop in set) {
                return prop;
            }
        },
        index: function (compare, items, props) {
            if (!items || !items.length) {
                return undefined;
            }
            if (compare(props, items[0]) === -1) {
                return 0;
            } else if (compare(props, last(items)) === 1) {
                return items.length;
            }
            var low = 0, high = items.length;
            while (low < high) {
                var mid = low + high >>> 1, item = items[mid], computed = compare(props, item);
                if (computed === -1) {
                    high = mid;
                } else {
                    low = mid + 1;
                }
            }
            return high;
        },
        defaultSort: function (sortPropValue, item1, item2) {
            var parts = sortPropValue.split(' ');
            var sortProp = parts[0];
            var item1Value = item1[sortProp];
            var item2Value = item2[sortProp];
            var temp;
            var desc = parts[1] || '';
            desc = desc.toLowerCase() === 'desc';
            if (desc) {
                temp = item1Value;
                item1Value = item2Value;
                item2Value = temp;
            }
            if (item1Value < item2Value) {
                return -1;
            }
            if (item1Value > item2Value) {
                return 1;
            }
            return 0;
        }
    };
});
/*can-set@1.3.0#src/clause*/
define('can-set@1.3.0#src/clause', function (require, exports, module) {
    var assign = require('can-util/js/assign/assign');
    var each = require('can-util/js/each/each');
    var clause = {};
    module.exports = clause;
    clause.TYPES = [
        'where',
        'order',
        'paginate',
        'id'
    ];
    each(clause.TYPES, function (type) {
        var className = type.charAt(0).toUpperCase() + type.substr(1);
        clause[className] = function (compare) {
            assign(this, compare);
        };
        clause[className].type = type;
    });
});
/*can-set@1.3.0#src/compare*/
define('can-set@1.3.0#src/compare', function (require, exports, module) {
    var h = require('./helpers');
    var assign = require('can-util/js/assign/assign');
    var each = require('can-util/js/each/each');
    var makeArray = require('can-util/js/make-array/make-array');
    var compareHelpers;
    var loop = function (a, b, aParent, bParent, prop, compares, options) {
        var checks = options.checks;
        for (var i = 0; i < checks.length; i++) {
            var res = checks[i](a, b, aParent, bParent, prop, compares || {}, options);
            if (res !== undefined) {
                return res;
            }
        }
        return options['default'];
    };
    var addIntersectedPropertyToResult = function (a, b, aParent, bParent, prop, compares, options) {
        var subsetCheck;
        if (!(prop in aParent)) {
            subsetCheck = 'subsetB';
        } else if (prop in bParent) {
            return false;
        }
        if (!(prop in bParent)) {
            subsetCheck = 'subsetA';
        }
        if (subsetCheck === 'subsetB') {
            options.result[prop] = b;
        } else {
            options.result[prop] = a;
        }
        return undefined;
    };
    var addToResult = function (fn, name) {
        return function (a, b, aParent, bParent, prop, compares, options) {
            var res = fn.apply(this, arguments);
            if (res === true) {
                if (prop !== undefined && !(prop in options.result)) {
                    options.result[prop] = a;
                }
                return true;
            } else {
                return res;
            }
        };
    };
    module.exports = compareHelpers = {
        equal: function (a, b, aParent, bParent, prop, compares, options) {
            options.checks = [
                compareHelpers.equalComparesType,
                compareHelpers.equalBasicTypes,
                compareHelpers.equalArrayLike,
                compareHelpers.equalObject
            ];
            options['default'] = false;
            return loop(a, b, aParent, bParent, prop, compares, options);
        },
        equalComparesType: function (a, b, aParent, bParent, prop, compares, options) {
            if (typeof compares === 'function') {
                var compareResult = compares(a, b, aParent, bParent, prop, options);
                if (typeof compareResult === 'boolean') {
                    return compareResult;
                } else if (compareResult && typeof compareResult === 'object') {
                    if ('intersection' in compareResult && !('difference' in compareResult)) {
                        var reverseResult = compares(b, a, bParent, aParent, prop, options);
                        return 'intersection' in reverseResult && !('difference' in reverseResult);
                    }
                    return false;
                }
                return compareResult;
            }
        },
        equalBasicTypes: function (a, b, aParent, bParent, prop, compares, options) {
            if (a === null || b === null) {
                return a === b;
            }
            if (a instanceof Date && b instanceof Date) {
                return a.getTime() === b.getTime();
            }
            if (options.deep === -1) {
                return typeof a === 'object' || a === b;
            }
            if (typeof a !== typeof b || Array.isArray(a) !== Array.isArray(b)) {
                return false;
            }
            if (a === b) {
                return true;
            }
        },
        equalArrayLike: function (a, b, aParent, bParent, prop, compares, options) {
            if (Array.isArray(a) && Array.isArray(b)) {
                if (a.length !== b.length) {
                    return false;
                }
                for (var i = 0; i < a.length; i++) {
                    var compare = compares[i] === undefined ? compares['*'] : compares[i];
                    if (!loop(a[i], b[i], a, b, i, compare, options)) {
                        return false;
                    }
                }
                return true;
            }
        },
        equalObject: function (a, b, aParent, bParent, parentProp, compares, options) {
            var aType = typeof a;
            if (aType === 'object' || aType === 'function') {
                var bCopy = assign({}, b);
                if (options.deep === false) {
                    options.deep = -1;
                }
                for (var prop in a) {
                    var compare = compares[prop] === undefined ? compares['*'] : compares[prop];
                    if (!loop(a[prop], b[prop], a, b, prop, compare, options)) {
                        return false;
                    }
                    delete bCopy[prop];
                }
                for (prop in bCopy) {
                    if (compares[prop] === undefined || !loop(undefined, b[prop], a, b, prop, compares[prop], options)) {
                        return false;
                    }
                }
                return true;
            }
        },
        subset: function (a, b, aParent, bParent, prop, compares, options) {
            options.checks = [
                compareHelpers.subsetComparesType,
                compareHelpers.equalBasicTypes,
                compareHelpers.equalArrayLike,
                compareHelpers.subsetObject
            ];
            options.getSubsets = [];
            options['default'] = false;
            return loop(a, b, aParent, bParent, prop, compares, options);
        },
        subsetObject: function (a, b, aParent, bParent, parentProp, compares, options) {
            var aType = typeof a;
            if (aType === 'object' || aType === 'function') {
                return h.eachInUnique(a, function (a, b, aParent, bParent, prop) {
                    var compare = compares[prop] === undefined ? compares['*'] : compares[prop];
                    if (!loop(a, b, aParent, bParent, prop, compare, options) && prop in bParent) {
                        return false;
                    }
                }, b, function (a, b, aParent, bParent, prop) {
                    var compare = compares[prop] === undefined ? compares['*'] : compares[prop];
                    if (!loop(a, b, aParent, bParent, prop, compare, options)) {
                        return false;
                    }
                }, true);
            }
        },
        subsetComparesType: function (a, b, aParent, bParent, prop, compares, options) {
            if (typeof compares === 'function') {
                var compareResult = compares(a, b, aParent, bParent, prop, options);
                if (typeof compareResult === 'boolean') {
                    return compareResult;
                } else if (compareResult && typeof compareResult === 'object') {
                    if (compareResult.getSubset) {
                        if (h.indexOf.call(options.getSubsets, compareResult.getSubset) === -1) {
                            options.getSubsets.push(compareResult.getSubset);
                        }
                    }
                    if (compareResult.intersection === h.ignoreType || compareResult.difference === h.ignoreType) {
                        return true;
                    }
                    if ('intersection' in compareResult && !('difference' in compareResult)) {
                        var reverseResult = compares(b, a, bParent, aParent, prop, options);
                        return 'intersection' in reverseResult;
                    }
                    return false;
                }
                return compareResult;
            }
        },
        properSupersetObject: function (a, b, aParent, bParent, parentProp, compares, options) {
            var bType = typeof b;
            var hasAdditionalProp = false;
            if (bType === 'object' || bType === 'function') {
                var aCopy = assign({}, a);
                if (options.deep === false) {
                    options.deep = -1;
                }
                for (var prop in b) {
                    var compare = compares[prop] === undefined ? compares['*'] : compares[prop];
                    var compareResult = loop(a[prop], b[prop], a, b, prop, compare, options);
                    if (compareResult === h.ignoreType) {
                    } else if (!(prop in a) || options.performedDifference) {
                        hasAdditionalProp = true;
                    } else if (!compareResult) {
                        return false;
                    }
                    delete aCopy[prop];
                }
                for (prop in aCopy) {
                    if (compares[prop] === undefined || !loop(a[prop], undefined, a, b, prop, compares[prop], options)) {
                        return false;
                    }
                }
                return hasAdditionalProp;
            }
        },
        properSubsetComparesType: function (a, b, aParent, bParent, prop, compares, options) {
            if (typeof compares === 'function') {
                var compareResult = compares(a, b, aParent, bParent, prop, options);
                if (typeof compareResult === 'boolean') {
                    return compareResult;
                } else if (compareResult && typeof compareResult === 'object') {
                    if ('intersection' in compareResult && !('difference' in compareResult)) {
                        var reverseResult = compares(b, a, bParent, aParent, prop, options);
                        return 'intersection' in reverseResult && 'difference' in reverseResult;
                    }
                    return false;
                }
                return compareResult;
            }
        },
        difference: function (a, b, aParent, bParent, prop, compares, options) {
            options.result = {};
            options.performedDifference = 0;
            options.checks = [
                compareHelpers.differenceComparesType,
                addToResult(compareHelpers.equalBasicTypes, 'equalBasicTypes'),
                addToResult(compareHelpers.equalArrayLike, 'equalArrayLike'),
                addToResult(compareHelpers.properSupersetObject, 'properSubsetObject')
            ];
            options['default'] = true;
            var res = loop(a, b, aParent, bParent, prop, compares, options);
            if (res === true && options.performedDifference) {
                return options.result;
            }
            return res;
        },
        differenceComparesType: function (a, b, aParent, bParent, prop, compares, options) {
            if (typeof compares === 'function') {
                var compareResult = compares(a, b, aParent, bParent, prop, options);
                if (typeof compareResult === 'boolean') {
                    if (compareResult === true) {
                        options.result[prop] = a;
                        return true;
                    } else {
                        return compareResult;
                    }
                } else if (compareResult && typeof compareResult === 'object') {
                    if ('difference' in compareResult) {
                        if (compareResult.difference === h.ignoreType) {
                            return h.ignoreType;
                        } else if (compareResult.difference != null) {
                            options.result[prop] = compareResult.difference;
                            options.performedDifference++;
                            return true;
                        } else {
                            return true;
                        }
                    } else {
                        if (compareHelpers.equalComparesType.apply(this, arguments)) {
                            options.performedDifference++;
                            options.result[prop] = compareResult.union;
                        } else {
                            return false;
                        }
                    }
                }
            }
        },
        union: function (a, b, aParent, bParent, prop, compares, options) {
            options.result = {};
            options.performedUnion = 0;
            options.checks = [
                compareHelpers.unionComparesType,
                addToResult(compareHelpers.equalBasicTypes, 'equalBasicTypes'),
                addToResult(compareHelpers.unionArrayLike, 'unionArrayLike'),
                addToResult(compareHelpers.unionObject, 'unionObject')
            ];
            options.getUnions = [];
            options['default'] = false;
            var res = loop(a, b, aParent, bParent, prop, compares, options);
            if (res === true) {
                return options.result;
            }
            return false;
        },
        unionComparesType: function (a, b, aParent, bParent, prop, compares, options) {
            if (typeof compares === 'function') {
                var compareResult = compares(a, b, aParent, bParent, prop, options);
                if (typeof compareResult === 'boolean') {
                    if (compareResult === true) {
                        options.result[prop] = a;
                        return true;
                    } else {
                        return compareResult;
                    }
                } else if (compareResult && typeof compareResult === 'object') {
                    if (compareResult.getUnion) {
                        if (h.indexOf.call(options.getUnions, compareResult.getUnion) === -1) {
                            options.getUnions.push(compareResult.getUnion);
                        }
                    }
                    if ('union' in compareResult) {
                        if (compareResult.union === h.ignoreType) {
                            return compareResult.union;
                        }
                        if (compareResult.union !== undefined) {
                            options.result[prop] = compareResult.union;
                        }
                        options.performedUnion++;
                        return true;
                    }
                }
            }
        },
        unionObject: function (a, b, aParent, bParent, prop, compares, options) {
            var subsetCompare = function (a, b, aParent, bParent, prop) {
                var compare = compares[prop] === undefined ? compares['*'] : compares[prop];
                if (!loop(a, b, aParent, bParent, prop, compare, options)) {
                    var subsetCheck;
                    if (!(prop in aParent)) {
                        subsetCheck = 'subsetB';
                    }
                    if (!(prop in bParent)) {
                        subsetCheck = 'subsetA';
                    }
                    if (subsetCheck) {
                        if (!options.subset) {
                            options.subset = subsetCheck;
                        }
                        return options.subset === subsetCheck ? undefined : false;
                    }
                    return false;
                }
            };
            var aType = typeof a;
            if (aType === 'object' || aType === 'function') {
                return h.eachInUnique(a, subsetCompare, b, subsetCompare, true);
            }
        },
        unionArrayLike: function (a, b, aParent, bParent, prop, compares, options) {
            if (Array.isArray(a) && Array.isArray(b)) {
                var combined = makeArray(a).concat(makeArray(b));
                h.doubleLoop(combined, function (item, j, cur, i) {
                    var res = !compareHelpers.equal(cur, item, aParent, bParent, undefined, compares['*'], { 'default': false });
                    return res;
                });
                options.result[prop] = combined;
                return true;
            }
        },
        count: function (a, b, aParent, bParent, prop, compares, options) {
            options.checks = [
                compareHelpers.countComparesType,
                compareHelpers.equalBasicTypes,
                compareHelpers.equalArrayLike,
                compareHelpers.loopObject
            ];
            options['default'] = false;
            loop(a, b, aParent, bParent, prop, compares, options);
            if (typeof options.count === 'number') {
                return options.count;
            }
            return Infinity;
        },
        countComparesType: function (a, b, aParent, bParent, prop, compares, options) {
            if (typeof compares === 'function') {
                var compareResult = compares(a, b, aParent, bParent, prop, options);
                if (typeof compareResult === 'boolean') {
                    return true;
                } else if (compareResult && typeof compareResult === 'object') {
                    if (typeof compareResult.count === 'number') {
                        if (!('count' in options) || compareResult.count === options.count) {
                            options.count = compareResult.count;
                        } else {
                            options.count = Infinity;
                        }
                    }
                    return true;
                }
            }
        },
        loopObject: function (a, b, aParent, bParent, prop, compares, options) {
            var aType = typeof a;
            if (aType === 'object' || aType === 'function') {
                each(a, function (aValue, prop) {
                    var compare = compares[prop] === undefined ? compares['*'] : compares[prop];
                    loop(aValue, b[prop], a, b, prop, compare, options);
                });
                return true;
            }
        },
        intersection: function (a, b, aParent, bParent, prop, compares, options) {
            options.result = {};
            options.performedIntersection = 0;
            options.checks = [
                compareHelpers.intersectionComparesType,
                addToResult(compareHelpers.equalBasicTypes, 'equalBasicTypes'),
                addToResult(compareHelpers.intersectionArrayLike, 'intersectionArrayLike'),
                compareHelpers.intersectionObject
            ];
            options['default'] = false;
            var res = loop(a, b, aParent, bParent, prop, compares, options);
            if (res === true) {
                return options.result;
            }
            return false;
        },
        intersectionComparesType: function (a, b, aParent, bParent, prop, compares, options) {
            if (typeof compares === 'function') {
                var compareResult = compares(a, b, aParent, bParent, prop, options);
                if (typeof compareResult === 'boolean') {
                    if (compareResult === true) {
                        options.result[prop] = a;
                        return true;
                    } else {
                        return compareResult;
                    }
                } else if (compareResult && typeof compareResult === 'object') {
                    if ('intersection' in compareResult) {
                        if (compareResult.intersection !== undefined) {
                            options.result[prop] = compareResult.intersection;
                        }
                        options.performedIntersection++;
                        return true;
                    }
                }
            }
        },
        intersectionObject: function (a, b, aParent, bParent, prop, compares, options) {
            var subsetCompare = function (a, b, aParent, bParent, prop) {
                var compare = compares[prop] === undefined ? compares['*'] : compares[prop];
                if (!loop(a, b, aParent, bParent, prop, compare, options)) {
                    return addIntersectedPropertyToResult(a, b, aParent, bParent, prop, compares, options);
                }
            };
            var aType = typeof a;
            if (aType === 'object' || aType === 'function') {
                return h.eachInUnique(a, subsetCompare, b, subsetCompare, true);
            }
        },
        intersectionArrayLike: function (a, b, aParent, bParent, prop, compares, options) {
            if (Array.isArray(a) && Array.isArray(b)) {
                var intersection = [];
                each(makeArray(a), function (cur) {
                    for (var i = 0; i < b.length; i++) {
                        if (compareHelpers.equal(cur, b[i], aParent, bParent, undefined, compares['*'], { 'default': false })) {
                            intersection.push(cur);
                            break;
                        }
                    }
                });
                options.result[prop] = intersection;
                return true;
            }
        }
    };
});
/*can-set@1.3.0#src/get*/
define('can-set@1.3.0#src/get', function (require, exports, module) {
    var compare = require('./compare');
    var h = require('./helpers');
    var each = require('can-util/js/each/each');
    var filterData = function (data, clause, props) {
        return h.filter.call(data, function (item) {
            var isSubset = compare.subset(item, clause, undefined, undefined, undefined, props, {});
            return isSubset;
        });
    };
    module.exports = {
        subsetData: function (a, b, bData, algebra) {
            var aClauseProps = algebra.getClauseProperties(a);
            var bClauseProps = algebra.getClauseProperties(b);
            var options = {};
            var aData = filterData(bData, aClauseProps.where, algebra.clauses.where);
            if (aData.length && (aClauseProps.enabled.order || bClauseProps.enabled.order)) {
                options = {};
                var propName = h.firstProp(aClauseProps.order), compareOrder = algebra.clauses.order[propName];
                aData = aData.sort(function (aItem, bItem) {
                    return compareOrder(a[propName], aItem, bItem);
                });
            }
            if (aData.length && (aClauseProps.enabled.paginate || bClauseProps.enabled.paginate)) {
                options = {};
                compare.subset(aClauseProps.paginate, bClauseProps.paginate, undefined, undefined, undefined, algebra.clauses.paginate, options);
                each(options.getSubsets, function (filter) {
                    aData = filter(a, b, aData, algebra, options);
                });
            }
            return aData;
        }
    };
});
/*can-set@1.3.0#src/set-core*/
define('can-set@1.3.0#src/set-core', function (require, exports, module) {
    var h = require('./helpers');
    var clause = require('./clause');
    var compare = require('./compare');
    var get = require('./get');
    var assign = require('can-util/js/assign/assign');
    var each = require('can-util/js/each/each');
    var makeArray = require('can-util/js/make-array/make-array');
    var isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');
    function Translate(clause, options) {
        if (typeof options === 'string') {
            var path = options;
            options = {
                fromSet: function (set, setRemainder) {
                    return set[path] || {};
                },
                toSet: function (set, wheres) {
                    set[path] = wheres;
                    return set;
                }
            };
        }
        this.clause = clause;
        assign(this, options);
    }
    var Algebra = function () {
        var clauses = this.clauses = {
            where: {},
            order: {},
            paginate: {},
            id: {}
        };
        this.translators = {
            where: new Translate('where', {
                fromSet: function (set, setRemainder) {
                    return setRemainder;
                },
                toSet: function (set, wheres) {
                    return assign(set, wheres);
                }
            })
        };
        var self = this;
        each(arguments, function (arg) {
            if (arg) {
                if (arg instanceof Translate) {
                    self.translators[arg.clause] = arg;
                } else {
                    assign(clauses[arg.constructor.type || 'where'], arg);
                }
            }
        });
    };
    Algebra.make = function (compare, count) {
        if (compare instanceof Algebra) {
            return compare;
        } else {
            return new Algebra(compare, count);
        }
    };
    assign(Algebra.prototype, {
        getClauseProperties: function (set, options) {
            options = options || {};
            var setClone = assign({}, set);
            var clauses = this.clauses;
            var checkClauses = [
                'order',
                'paginate',
                'id'
            ];
            var clauseProps = {
                enabled: {
                    where: true,
                    order: false,
                    paginate: false,
                    id: false
                }
            };
            if (options.omitClauses) {
                checkClauses = h.arrayUnionIntersectionDifference(checkClauses, options.omitClauses).difference;
            }
            each(checkClauses, function (clauseName) {
                var valuesForClause = {};
                var prop;
                for (prop in clauses[clauseName]) {
                    if (prop in setClone) {
                        valuesForClause[prop] = setClone[prop];
                        delete setClone[prop];
                    }
                }
                clauseProps[clauseName] = valuesForClause;
                clauseProps.enabled[clauseName] = !isEmptyObject(valuesForClause);
            });
            clauseProps.where = options.isProperties ? setClone : this.translators.where.fromSet(set, setClone);
            return clauseProps;
        },
        getDifferentClauseTypes: function (aClauses, bClauses) {
            var self = this;
            var differentTypes = [];
            each(clause.TYPES, function (type) {
                if (!self.evaluateOperator(compare.equal, aClauses[type], bClauses[type], { isProperties: true }, { isProperties: true })) {
                    differentTypes.push(type);
                }
            });
            return differentTypes;
        },
        updateSet: function (set, clause, result, useSet) {
            if (result && typeof result === 'object' && useSet !== false) {
                if (this.translators[clause]) {
                    set = this.translators.where.toSet(set, result);
                } else {
                    set = assign(set, result);
                }
                return true;
            } else if (result) {
                return useSet === undefined ? undefined : false;
            } else {
                return false;
            }
        },
        evaluateOperator: function (operator, a, b, aOptions, bOptions, evaluateOptions) {
            aOptions = aOptions || {};
            bOptions = bOptions || {};
            evaluateOptions = assign({
                evaluateWhere: operator,
                evaluatePaginate: operator,
                evaluateOrder: operator,
                shouldEvaluatePaginate: function (aClauseProps, bClauseProps) {
                    return aClauseProps.enabled.paginate || bClauseProps.enabled.paginate;
                },
                shouldEvaluateOrder: function (aClauseProps, bClauseProps) {
                    return aClauseProps.enabled.order && compare.equal(aClauseProps.order, bClauseProps.order, undefined, undefined, undefined, {}, {});
                }
            }, evaluateOptions || {});
            var aClauseProps = this.getClauseProperties(a, aOptions), bClauseProps = this.getClauseProperties(b, bOptions), set = {}, useSet;
            var result = evaluateOptions.evaluateWhere(aClauseProps.where, bClauseProps.where, undefined, undefined, undefined, this.clauses.where, {});
            useSet = this.updateSet(set, 'where', result, useSet);
            if (result && evaluateOptions.shouldEvaluatePaginate(aClauseProps, bClauseProps)) {
                if (evaluateOptions.shouldEvaluateOrder(aClauseProps, bClauseProps)) {
                    result = evaluateOptions.evaluateOrder(aClauseProps.order, bClauseProps.order, undefined, undefined, undefined, {}, {});
                    useSet = this.updateSet(set, 'order', result, useSet);
                }
                if (result) {
                    result = evaluateOptions.evaluatePaginate(aClauseProps.paginate, bClauseProps.paginate, undefined, undefined, undefined, this.clauses.paginate, {});
                    useSet = this.updateSet(set, 'paginate', result, useSet);
                }
            } else if (result && evaluateOptions.shouldEvaluateOrder(aClauseProps, bClauseProps)) {
                result = operator(aClauseProps.order, bClauseProps.order, undefined, undefined, undefined, {}, {});
                useSet = this.updateSet(set, 'order', result, useSet);
            }
            return result && useSet ? set : result;
        },
        equal: function (a, b) {
            return this.evaluateOperator(compare.equal, a, b);
        },
        subset: function (a, b) {
            var aClauseProps = this.getClauseProperties(a);
            var bClauseProps = this.getClauseProperties(b);
            var compatibleSort = true;
            var result;
            if (bClauseProps.enabled.paginate && (aClauseProps.enabled.order || bClauseProps.enabled.order)) {
                compatibleSort = compare.equal(aClauseProps.order, bClauseProps.order, undefined, undefined, undefined, {}, {});
            }
            if (!compatibleSort) {
                result = false;
            } else {
                result = this.evaluateOperator(compare.subset, a, b);
            }
            return result;
        },
        properSubset: function (a, b) {
            return this.subset(a, b) && !this.equal(a, b);
        },
        difference: function (a, b) {
            var aClauseProps = this.getClauseProperties(a);
            var bClauseProps = this.getClauseProperties(b);
            var differentClauses = this.getDifferentClauseTypes(aClauseProps, bClauseProps);
            var result;
            switch (differentClauses.length) {
            case 0: {
                    result = false;
                    break;
                }
            case 1: {
                    var clause = differentClauses[0];
                    result = compare.difference(aClauseProps[clause], bClauseProps[clause], undefined, undefined, undefined, this.clauses[clause], {});
                    if (this.translators[clause] && typeof result === 'object') {
                        result = this.translators[clause].toSet({}, result);
                    }
                    break;
                }
            }
            return result;
        },
        union: function (a, b) {
            return this.evaluateOperator(compare.union, a, b);
        },
        intersection: function (a, b) {
            return this.evaluateOperator(compare.intersection, a, b);
        },
        count: function (set) {
            return this.evaluateOperator(compare.count, set, {});
        },
        has: function (set, props) {
            var aClauseProps = this.getClauseProperties(set);
            var propsClauseProps = this.getClauseProperties(props, { isProperties: true });
            var compatibleSort = true;
            var result;
            if ((propsClauseProps.enabled.paginate || aClauseProps.enabled.paginate) && (propsClauseProps.enabled.order || aClauseProps.enabled.order)) {
                compatibleSort = compare.equal(propsClauseProps.order, aClauseProps.order, undefined, undefined, undefined, {}, {});
            }
            if (!compatibleSort) {
                result = false;
            } else {
                result = this.evaluateOperator(compare.subset, props, set, { isProperties: true }, undefined);
            }
            return result;
        },
        index: function (set, items, item) {
            var aClauseProps = this.getClauseProperties(set);
            var propName = h.firstProp(aClauseProps.order), compare, orderValue;
            if (propName) {
                compare = this.clauses.order[propName];
                orderValue = set[propName];
                return h.index(function (itemA, itemB) {
                    return compare(orderValue, itemA, itemB);
                }, items, item);
            }
            propName = h.firstProp(this.clauses.id);
            if (propName) {
                compare = h.defaultSort;
                orderValue = propName;
                return h.index(function (itemA, itemB) {
                    return compare(orderValue, itemA, itemB);
                }, items, item);
            }
            return;
        },
        getSubset: function (a, b, bData) {
            var aClauseProps = this.getClauseProperties(a);
            var bClauseProps = this.getClauseProperties(b);
            var isSubset = this.subset(assign({}, aClauseProps.where, aClauseProps.paginate), assign({}, bClauseProps.where, bClauseProps.paginate));
            if (isSubset) {
                return get.subsetData(a, b, bData, this);
            }
        },
        getUnion: function (a, b, aItems, bItems) {
            var aClauseProps = this.getClauseProperties(a);
            var bClauseProps = this.getClauseProperties(b);
            var algebra = this;
            var options;
            if (this.subset(a, b)) {
                return bItems;
            } else if (this.subset(b, a)) {
                return aItems;
            }
            var combined;
            if (aClauseProps.enabled.paginate || bClauseProps.enabled.paginate) {
                options = {};
                var isUnion = compare.union(aClauseProps.paginate, bClauseProps.paginate, undefined, undefined, undefined, this.clauses.paginate, options);
                if (!isUnion) {
                    return;
                } else {
                    each(options.getUnions, function (filter) {
                        var items = filter(a, b, aItems, bItems, algebra, options);
                        aItems = items[0];
                        bItems = items[1];
                    });
                    combined = aItems.concat(bItems);
                }
            } else {
                combined = aItems.concat(bItems);
            }
            if (combined.length && aClauseProps.enabled.order && compare.equal(aClauseProps.order, bClauseProps.order, undefined, undefined, undefined, {}, {})) {
                options = {};
                var propName = h.firstProp(aClauseProps.order), compareOrder = algebra.clauses.order[propName];
                combined = combined.sort(function (aItem, bItem) {
                    return compareOrder(a[propName], aItem, bItem);
                });
            }
            return combined;
        },
        id: function (props) {
            var keys = Object.keys(this.clauses.id);
            if (keys.length === 1) {
                return props[keys[0]];
            } else {
                var id = {};
                keys.forEach(function (key) {
                    id[key] = props[key];
                });
                return JSON.stringify(id);
            }
        }
    });
    var callOnAlgebra = function (methodName, algebraArgNumber) {
        return function () {
            var args = makeArray(arguments).slice(0, algebraArgNumber);
            var algebra = Algebra.make(arguments[algebraArgNumber]);
            return algebra[methodName].apply(algebra, args);
        };
    };
    module.exports = {
        Algebra: Algebra,
        Translate: Translate,
        difference: callOnAlgebra('difference', 2),
        equal: callOnAlgebra('equal', 2),
        subset: callOnAlgebra('subset', 2),
        properSubset: callOnAlgebra('properSubset', 2),
        union: callOnAlgebra('union', 2),
        intersection: callOnAlgebra('intersection', 2),
        count: callOnAlgebra('count', 1),
        has: callOnAlgebra('has', 2),
        index: callOnAlgebra('index', 3),
        getSubset: callOnAlgebra('getSubset', 3),
        getUnion: callOnAlgebra('getUnion', 4)
    };
});
/*can-set@1.3.0#src/set-core_test*/
define('can-set@1.3.0#src/set-core_test', function (require, exports, module) {
    require('steal-qunit');
    var set = require('./set-core');
    var ignoreProp = function () {
        return true;
    };
    QUnit.module('can-set core');
    test('set.equal', function () {
        var res, now;
        res = set.equal({ type: 'FOLDER' }, {
            type: 'FOLDER',
            count: 5
        }, { count: ignoreProp });
        ok(res, 'count ignored');
        res = set.equal({ type: 'folder' }, { type: 'FOLDER' }, {
            type: function (a, b) {
                return ('' + a).toLowerCase() === ('' + b).toLowerCase();
            }
        });
        ok(res, 'folder case ignored');
        res = set.equal({ foo: null }, { foo: new Date() });
        ok(!res, 'nulls and Dates are not considered the same. (#773)');
        res = set.equal({ foo: null }, { foo: {} });
        ok(!res, 'nulls and empty objects are not considered the same. (#773)');
        now = new Date();
        res = set.equal({ foo: now }, { foo: new Date(now.getTime()) });
        ok(res, 'date objects with same time values are considered the same. (#35)');
    });
    test('set.subset', function () {
        var res;
        res = set.subset({ type: 'FOLDER' }, { type: 'FOLDER' });
        ok(res, 'equal sets');
        res = set.subset({
            type: 'FOLDER',
            parentId: 5
        }, { type: 'FOLDER' });
        ok(res, 'sub set');
        res = set.subset({ type: 'FOLDER' }, {
            type: 'FOLDER',
            parentId: 5
        });
        ok(!res, 'wrong way');
        res = set.subset({
            type: 'FOLDER',
            parentId: 7
        }, {
            type: 'FOLDER',
            parentId: 5
        });
        ok(!res, 'different values');
        res = set.subset({
            type: 'FOLDER',
            count: 5
        }, { type: 'FOLDER' }, { count: ignoreProp });
        ok(res, 'count ignored');
        res = set.subset({
            type: 'FOLDER',
            kind: 'tree'
        }, {
            type: 'FOLDER',
            foo: true,
            bar: true
        }, {
            foo: ignoreProp,
            bar: ignoreProp
        });
        ok(res, 'understands a subset');
        res = set.subset({
            type: 'FOLDER',
            foo: true,
            bar: true
        }, {
            type: 'FOLDER',
            kind: 'tree'
        }, {
            foo: ignoreProp,
            bar: ignoreProp,
            kind: ignoreProp
        });
        ok(res, 'ignores nulls');
    });
    test('set.properSubset', function () {
        equal(set.properSubset({ foo: 'bar' }, {}), true);
        equal(set.properSubset({}, {}), false);
        equal(set.properSubset({}, { foo: 'bar' }), false);
    });
    test('set.difference', function () {
        var res = set.difference({}, { completed: true });
        ok(res === true, 'diff should be true');
        res = set.difference({ completed: true }, { completed: true });
        equal(res, false);
        res = set.difference({ completed: true }, {});
        equal(res, false);
        res = set.difference({ completed: true }, { userId: 5 });
        equal(res, false);
    });
    test('set.difference({ function })', function () {
        var res = set.difference({
            colors: [
                'red',
                'blue'
            ]
        }, { colors: ['blue'] }, {
            colors: function () {
                return {
                    difference: ['red'],
                    intersection: ['blue']
                };
            }
        });
        deepEqual(res, { colors: ['red'] });
    });
    test('set.union', function () {
        var res = set.union({}, { completed: true });
        deepEqual(res, {}, 'set / subset');
        res = set.union({ completed: true }, {});
        deepEqual(res, {}, 'subset / set');
        res = set.union({ foo: 'bar' }, { foo: 'bar' });
        deepEqual(res, { foo: 'bar' }, 'equal');
        res = set.union({ foo: 'bar' }, { foo: 'zed' });
        ok(!res, 'values not equal');
        res = set.union({ foo: 'bar' }, { name: 'A' });
        ok(!res, 'values not equal');
    });
    test('set.union Array', function () {
        var res = set.union({
            foo: [
                'a',
                'b'
            ]
        }, {
            foo: [
                'a',
                'c'
            ]
        });
        deepEqual(res, {
            foo: [
                'a',
                'b',
                'c'
            ]
        }, 'set / subset');
    });
    test('set.count', function () {
        ok(set.count({}) === Infinity, 'defaults to infinity');
        ok(set.count({ foo: 'bar' }, {}) === Infinity, 'defaults to infinity');
        equal(set.count({ foo: 'bar' }, {
            foo: function () {
                return { count: 100 };
            }
        }), 100, 'works with a single value');
    });
    test('set.intersection', function () {
        var res = set.intersection({}, { completed: true });
        deepEqual(res, { completed: true }, 'set / subset');
        res = set.intersection({ completed: true }, {});
        deepEqual(res, { completed: true }, 'subset / set');
        res = set.intersection({ foo: 'bar' }, { foo: 'bar' });
        deepEqual(res, { foo: 'bar' }, 'equal');
        res = set.intersection({ foo: 'bar' }, { foo: 'zed' });
        ok(!res, 'values not equal');
        res = set.intersection({ foo: 'bar' }, { completed: true });
        deepEqual(res, {
            foo: 'bar',
            completed: true
        }, 'intersection should combine definitions');
    });
    test('set.intersection Array', function () {
        var res = set.intersection({
            foo: [
                'a',
                'b'
            ]
        }, {
            foo: [
                'a',
                'c'
            ]
        });
        deepEqual(res, { foo: ['a'] }, 'intersection');
    });
    test('set.has', function () {
        var res;
        res = set.has({ type: 'FOLDER' }, { type: 'FOLDER' });
        ok(res, 'equal sets');
        res = set.has({ type: 'FOLDER' }, {
            type: 'FOLDER',
            parentId: 5
        });
        ok(res, 'sub set');
        res = set.has({
            type: 'FOLDER',
            parentId: 5
        }, { type: 'FOLDER' });
        ok(!res, 'wrong way');
        res = set.has({
            type: 'FOLDER',
            parentId: 7
        }, {
            type: 'FOLDER',
            parentId: 5
        });
        ok(!res, 'different values');
        res = set.has({ type: 'FOLDER' }, {
            type: 'FOLDER',
            count: 5
        }, { count: ignoreProp });
        ok(res, 'count ignored');
        res = set.has({
            type: 'FOLDER',
            foo: true,
            bar: true
        }, {
            type: 'FOLDER',
            kind: 'tree'
        }, {
            foo: ignoreProp,
            bar: ignoreProp
        });
        ok(res, 'understands a subset');
        res = set.has({
            type: 'FOLDER',
            kind: 'tree'
        }, {
            type: 'FOLDER',
            foo: true,
            bar: true
        }, {
            foo: ignoreProp,
            bar: ignoreProp,
            kind: ignoreProp
        });
        ok(res, 'ignores nulls');
    });
    test('set.index', function () {
        var index = set.index({ sort: 'name' }, [
            {
                id: 1,
                name: 'g'
            },
            {
                id: 2,
                name: 'j'
            },
            {
                id: 3,
                name: 'm'
            },
            {
                id: 4,
                name: 's'
            }
        ], { name: 'k' });
        equal(index, undefined, 'no value if nothing is set');
        var algebra = new set.Algebra(set.props.id('id'));
        index = algebra.index({ sort: 'name' }, [
            {
                id: 1,
                name: 'g'
            },
            {
                id: 2,
                name: 'j'
            },
            {
                id: 3,
                name: 'm'
            },
            {
                id: 4,
                name: 's'
            }
        ], {
            id: 0,
            name: 'k'
        });
        equal(index, 0);
    });
    test('algebra.id', function () {
        var algebra = new set.Algebra(set.props.id('_id'));
        QUnit.equal(algebra.id({ _id: 5 }), 5, 'only one id, returns value');
        algebra = new set.Algebra(set.props.id('studentId'), set.props.id('classId'));
        QUnit.equal(algebra.id({
            studentId: 6,
            classId: '7',
            foo: 'bar'
        }), JSON.stringify({
            studentId: 6,
            classId: '7'
        }), 'only one id, returns set as JSON');
    });
});
/*can-set@1.3.0#src/set-core-nested_test*/
define('can-set@1.3.0#src/set-core-nested_test', function (require, exports, module) {
    QUnit.module('can/set core - nested');
    require('steal-qunit');
    var set = require('./set-core');
    var ignoreProp = function () {
        return true;
    };
    QUnit.module('can-set core - nested where');
    test('set.equal', function () {
        var algebra = new set.Algebra(new set.Translate('where', '$where'), {
            count: ignoreProp,
            type: function (a, b) {
                return ('' + a).toLowerCase() === ('' + b).toLowerCase();
            }
        });
        var res;
        res = algebra.equal({ $where: { type: 'FOLDER' } }, {
            $where: {
                type: 'FOLDER',
                count: 5
            }
        });
        ok(res, 'count ignored');
        res = algebra.equal({ $where: { type: 'folder' } }, { $where: { type: 'FOLDER' } });
        ok(res, 'folder case ignored');
    });
    test('set.subset', function () {
        var algebra = new set.Algebra(new set.Translate('where', '$where'), {
            count: ignoreProp,
            type: function (a, b) {
                return ('' + a).toLowerCase() === ('' + b).toLowerCase();
            },
            foo: ignoreProp,
            bar: ignoreProp,
            kind: ignoreProp
        });
        var res;
        res = algebra.subset({ $where: { type: 'FOLDER' } }, { $where: { type: 'FOLDER' } });
        ok(res, 'equal sets');
        res = algebra.subset({
            $where: {
                type: 'FOLDER',
                parentId: 5
            }
        }, { $where: { type: 'FOLDER' } });
        ok(res, 'sub set');
        res = algebra.subset({ $where: { type: 'FOLDER' } }, {
            $where: {
                type: 'FOLDER',
                parentId: 5
            }
        });
        ok(!res, 'wrong way');
        res = algebra.subset({
            $where: {
                type: 'FOLDER',
                parentId: 7
            }
        }, {
            $where: {
                type: 'FOLDER',
                parentId: 5
            }
        });
        ok(!res, 'different values');
        res = algebra.subset({
            $where: {
                type: 'FOLDER',
                count: 5
            }
        }, { $where: { type: 'FOLDER' } });
        ok(res, 'count ignored');
        res = algebra.subset({
            $where: {
                type: 'FOLDER',
                category: 'tree'
            }
        }, {
            $where: {
                type: 'FOLDER',
                foo: true,
                bar: true
            }
        });
        ok(res, 'understands a subset');
        res = algebra.subset({
            $where: {
                type: 'FOLDER',
                foo: true,
                bar: true
            }
        }, {
            $where: {
                type: 'FOLDER',
                kind: 'tree'
            }
        });
        ok(res, 'ignores nulls');
    });
    test('set.properSubset', function () {
        var algebra = new set.Algebra(new set.Translate('where', '$where'));
        equal(algebra.properSubset({ $where: { foo: 'bar' } }, { $where: {} }), true);
        equal(algebra.properSubset({ $where: {} }, { $where: {} }), false);
        equal(algebra.properSubset({ $where: {} }, { $where: { foo: 'bar' } }), false);
    });
    test('set.difference', function () {
        var algebra = new set.Algebra(new set.Translate('where', '$where'));
        var res = algebra.difference({ $where: {} }, { $where: { completed: true } });
        ok(res === true, 'diff should be true');
        res = algebra.difference({ $where: { completed: true } }, { $where: { completed: true } });
        equal(res, false);
        res = algebra.difference({ $where: { completed: true } }, { $where: {} });
        equal(res, false);
        res = algebra.difference({ $where: { completed: true } }, { $where: { userId: 5 } });
        equal(res, false);
    });
    test('set.difference({ function })', function () {
        var algebra = new set.Algebra(new set.Translate('where', '$where'), {
            colors: function () {
                return {
                    difference: ['red'],
                    intersection: ['blue']
                };
            }
        });
        var res = algebra.difference({
            $where: {
                colors: [
                    'red',
                    'blue'
                ]
            }
        }, { $where: { colors: ['blue'] } });
        deepEqual(res, { $where: { colors: ['red'] } });
    });
    test('set.union', function () {
        var algebra = new set.Algebra(new set.Translate('where', '$where'));
        var res = algebra.union({ $where: {} }, { $where: { completed: true } });
        deepEqual(res, { $where: {} }, 'set / subset');
        res = algebra.union({ $where: { completed: true } }, { $where: {} });
        deepEqual(res, { $where: {} }, 'subset / set');
        res = algebra.union({ $where: { foo: 'bar' } }, { $where: { foo: 'bar' } });
        deepEqual(res, { $where: { foo: 'bar' } }, 'equal');
        res = algebra.union({ $where: { foo: 'bar' } }, { $where: { foo: 'zed' } });
        ok(!res, 'values not equal');
        res = algebra.union({ $where: { foo: 'bar' } }, { $where: { name: 'A' } });
        ok(!res, 'values not equal');
    });
    test('set.union Array', function () {
        var algebra = new set.Algebra(new set.Translate('where', '$where'));
        var res = algebra.union({
            $where: {
                foo: [
                    'a',
                    'b'
                ]
            }
        }, {
            $where: {
                foo: [
                    'a',
                    'c'
                ]
            }
        });
        deepEqual(res, {
            $where: {
                foo: [
                    'a',
                    'b',
                    'c'
                ]
            }
        }, 'set / subset');
    });
    test('set.count', function () {
        var algebra = new set.Algebra(new set.Translate('where', '$where'), {
            foo: function () {
                return { count: 100 };
            }
        });
        ok(algebra.count({ $where: {} }) === Infinity, 'defaults to infinity');
        ok(algebra.count({ $where: { bar: 'foo' } }) === Infinity, 'defaults to infinity');
        equal(algebra.count({ $where: { foo: 'bar' } }), 100, 'works with a single value');
    });
    test('set.intersection', function () {
        var algebra = new set.Algebra(new set.Translate('where', '$where'));
        var res = algebra.intersection({ $where: {} }, { $where: { completed: true } });
        deepEqual(res, { $where: { completed: true } }, 'set / subset');
        res = algebra.intersection({ $where: { completed: true } }, { $where: {} });
        deepEqual(res, { $where: { completed: true } }, 'subset / set');
        res = algebra.intersection({ $where: { foo: 'bar' } }, { $where: { foo: 'bar' } });
        deepEqual(res, { $where: { foo: 'bar' } }, 'equal');
        res = algebra.intersection({ $where: { foo: 'bar' } }, { $where: { foo: 'zed' } });
        ok(!res, 'values not equal');
        res = algebra.intersection({ $where: { foo: 'bar' } }, { $where: { completed: true } });
        deepEqual(res, {
            $where: {
                foo: 'bar',
                completed: true
            }
        }, 'intersection should combine definitions');
    });
    test('set.intersection Array', function () {
        var algebra = new set.Algebra(new set.Translate('where', '$where'));
        var res = algebra.intersection({
            $where: {
                foo: [
                    'a',
                    'b'
                ]
            }
        }, {
            $where: {
                foo: [
                    'a',
                    'c'
                ]
            }
        });
        deepEqual(res, { $where: { foo: ['a'] } }, 'intersection');
    });
    test('set.has', function () {
        var algebra = new set.Algebra(new set.Translate('where', '$where'), {
            count: ignoreProp,
            type: function (a, b) {
                return ('' + a).toLowerCase() === ('' + b).toLowerCase();
            },
            foo: ignoreProp,
            bar: ignoreProp,
            kind: ignoreProp
        });
        ok(algebra.has({ $where: { someId: 5 } }, {
            someId: 5,
            name: 'foo'
        }), 'contains');
        var res;
        res = algebra.has({ $where: { type: 'FOLDER' } }, { type: 'FOLDER' });
        ok(res, 'equal sets');
        res = algebra.has({
            $where: {
                type: 'FOLDER',
                parentId: 5
            }
        }, { type: 'FOLDER' });
        equal(res, false, 'doesnt match');
        res = algebra.has({ $where: { type: 'FOLDER' } }, {
            type: 'FOLDER',
            parentId: 5
        });
        ok(true, 'is a subset');
        res = algebra.has({
            $where: {
                type: 'FOLDER',
                parentId: 7
            }
        }, {
            type: 'FOLDER',
            parentId: 5
        });
        ok(!res, 'different values');
        res = algebra.has({
            $where: {
                type: 'FOLDER',
                count: 5
            }
        }, { type: 'FOLDER' }, { count: ignoreProp });
        ok(res, 'count ignored');
        res = algebra.has({
            $where: {
                type: 'FOLDER',
                kind: 'tree'
            }
        }, {
            type: 'FOLDER',
            foo: true,
            bar: true
        });
        ok(res, 'understands a subset');
        res = algebra.has({
            $where: {
                type: 'FOLDER',
                foo: true,
                bar: true
            }
        }, {
            type: 'FOLDER',
            kind: 'tree'
        });
        ok(res, 'ignores nulls');
    });
});
/*can-set@1.3.0#src/props*/
define('can-set@1.3.0#src/props', function (require, exports, module) {
    var h = require('./helpers');
    var clause = require('./clause');
    var each = require('can-util/js/each/each');
    var within = function (value, range) {
        return value >= range[0] && value <= range[1];
    };
    var numericProperties = function (setA, setB, property1, property2) {
        return {
            sAv1: +setA[property1],
            sAv2: +setA[property2],
            sBv1: +setB[property1],
            sBv2: +setB[property2]
        };
    };
    var diff = function (setA, setB, property1, property2) {
        var numProps = numericProperties(setA, setB, property1, property2);
        var sAv1 = numProps.sAv1, sAv2 = numProps.sAv2, sBv1 = numProps.sBv1, sBv2 = numProps.sBv2, count = sAv2 - sAv1 + 1;
        var after = {
            difference: [
                sBv2 + 1,
                sAv2
            ],
            intersection: [
                sAv1,
                sBv2
            ],
            union: [
                sBv1,
                sAv2
            ],
            count: count,
            meta: 'after'
        };
        var before = {
            difference: [
                sAv1,
                sBv1 - 1
            ],
            intersection: [
                sBv1,
                sAv2
            ],
            union: [
                sAv1,
                sBv2
            ],
            count: count,
            meta: 'before'
        };
        if (sAv1 === sBv1 && sAv2 === sBv2) {
            return {
                intersection: [
                    sAv1,
                    sAv2
                ],
                union: [
                    sAv1,
                    sAv2
                ],
                count: count,
                meta: 'equal'
            };
        } else if (sAv1 === sBv1 && sBv2 < sAv2) {
            return after;
        } else if (sAv2 === sBv2 && sBv1 > sAv1) {
            return before;
        } else if (within(sAv1, [
                sBv1,
                sBv2
            ]) && within(sAv2, [
                sBv1,
                sBv2
            ])) {
            return {
                intersection: [
                    sAv1,
                    sAv2
                ],
                union: [
                    sBv1,
                    sBv2
                ],
                count: count,
                meta: 'subset'
            };
        } else if (within(sBv1, [
                sAv1,
                sAv2
            ]) && within(sBv2, [
                sAv1,
                sAv2
            ])) {
            return {
                intersection: [
                    sBv1,
                    sBv2
                ],
                difference: [
                    null,
                    null
                ],
                union: [
                    sAv1,
                    sAv2
                ],
                count: count,
                meta: 'superset'
            };
        } else if (sAv1 < sBv1 && within(sAv2, [
                sBv1,
                sBv2
            ])) {
            return before;
        } else if (sBv1 < sAv1 && within(sBv2, [
                sAv1,
                sAv2
            ])) {
            return after;
        } else if (sAv2 === sBv1 - 1) {
            return {
                difference: [
                    sAv1,
                    sAv2
                ],
                union: [
                    sAv1,
                    sBv2
                ],
                count: count,
                meta: 'disjoint-before'
            };
        } else if (sBv2 === sAv1 - 1) {
            return {
                difference: [
                    sAv1,
                    sAv2
                ],
                union: [
                    sBv1,
                    sAv2
                ],
                count: count,
                meta: 'disjoint-after'
            };
        }
        if (!isNaN(count)) {
            return {
                count: count,
                meta: 'disjoint'
            };
        }
    };
    var cleanUp = function (value, enumData) {
        if (!value) {
            return enumData;
        }
        if (!Array.isArray(value)) {
            value = [value];
        }
        if (!value.length) {
            return enumData;
        }
        return value;
    };
    var stringConvert = {
        '0': false,
        'false': false,
        'null': undefined,
        'undefined': undefined
    };
    var convertToBoolean = function (value) {
        if (typeof value === 'string') {
            return value.toLowerCase() in stringConvert ? stringConvert[value.toLowerCase()] : true;
        }
        return value;
    };
    var props = {
        'enum': function (prop, enumData) {
            var compares = new clause.Where({});
            compares[prop] = function (vA, vB, A, B) {
                vA = cleanUp(vA, enumData);
                vB = cleanUp(vB, enumData);
                var data = h.arrayUnionIntersectionDifference(vA, vB);
                if (!data.difference.length) {
                    delete data.difference;
                }
                each(data, function (value, prop) {
                    if (Array.isArray(value)) {
                        if (h.arraySame(enumData, value)) {
                            data[prop] = undefined;
                        } else if (value.length === 1) {
                            data[prop] = value[0];
                        }
                    }
                });
                return data;
            };
            return compares;
        },
        paginate: function (propStart, propEnd, translateToStartEnd, reverseTranslate) {
            var compares = {};
            var makeResult = function (result, index) {
                var res = {};
                each([
                    'intersection',
                    'difference',
                    'union'
                ], function (prop) {
                    if (result[prop]) {
                        var set = {
                            start: result[prop][0],
                            end: result[prop][1]
                        };
                        res[prop] = reverseTranslate(set)[index === 0 ? propStart : propEnd];
                    }
                });
                if (result.count) {
                    res.count = result.count;
                }
                return res;
            };
            compares[propStart] = function (vA, vB, A, B) {
                if (vA === undefined) {
                    return;
                }
                var res = diff(translateToStartEnd(A), translateToStartEnd(B), 'start', 'end');
                var result = makeResult(res, 0);
                result.getSubset = function (a, b, bItems, algebra, options) {
                    return bItems;
                };
                result.getUnion = function (a, b, aItems, bItems, algebra, options) {
                    return [
                        aItems,
                        bItems
                    ];
                };
                return result;
            };
            compares[propEnd] = function (vA, vB, A, B) {
                if (vA === undefined) {
                    return;
                }
                var data = diff(translateToStartEnd(A), translateToStartEnd(B), 'start', 'end');
                var res = makeResult(data, 1);
                res.getSubset = function (a, b, bItems, algebra, options) {
                    var tA = translateToStartEnd(a);
                    var tB = translateToStartEnd(b);
                    var numProps = numericProperties(tA, tB, 'start', 'end');
                    var aStartValue = numProps.sAv1, aEndValue = numProps.sAv2;
                    var bStartValue = numProps.sBv1;
                    if (!('end' in tB) || !('end' in tA)) {
                        return bItems.slice(aStartValue, aEndValue + 1);
                    }
                    return bItems.slice(aStartValue - bStartValue, aEndValue - bStartValue + 1);
                };
                res.getUnion = function (a, b, aItems, bItems, algebra, options) {
                    var tA = translateToStartEnd(a);
                    var tB = translateToStartEnd(b);
                    if (data.meta.indexOf('after') >= 0) {
                        if (data.intersection) {
                            bItems = bItems.slice(0, data.intersection[0] - +tB.start);
                        }
                        return [
                            bItems,
                            aItems
                        ];
                    }
                    if (data.intersection) {
                        aItems = aItems.slice(0, data.intersection[0] - +tA.start);
                    }
                    return [
                        aItems,
                        bItems
                    ];
                };
                return res;
            };
            return new clause.Paginate(compares);
        },
        'boolean': function (propertyName) {
            var compares = new clause.Where({});
            compares[propertyName] = function (propA, propB) {
                propA = convertToBoolean(propA);
                propB = convertToBoolean(propB);
                var notA = !propA, notB = !propB;
                if (propA === notB && propB === notA) {
                    return {
                        difference: !propB,
                        union: undefined
                    };
                } else if (propA === undefined) {
                    return {
                        difference: !propB,
                        intersection: propB,
                        union: undefined
                    };
                } else if (propA === propB) {
                    return true;
                }
            };
            return compares;
        },
        'sort': function (prop, sortFunc) {
            if (!sortFunc) {
                sortFunc = h.defaultSort;
            }
            var compares = {};
            compares[prop] = sortFunc;
            return new clause.Order(compares);
        },
        'id': function (prop) {
            var compares = {};
            compares[prop] = prop;
            return new clause.Id(compares);
        }
    };
    var assignExcept = function (d, s, props) {
        for (var prop in s) {
            if (!props[prop]) {
                d[prop] = s[prop];
            }
        }
        return d;
    };
    var translateToOffsetLimit = function (set, offsetProp, limitProp) {
        var newSet = assignExcept({}, set, {
            start: 1,
            end: 1
        });
        if ('start' in set) {
            newSet[offsetProp] = set.start;
        }
        if ('end' in set) {
            newSet[limitProp] = set.end - set.start + 1;
        }
        return newSet;
    };
    var translateToStartEnd = function (set, offsetProp, limitProp) {
        var except = {};
        except[offsetProp] = except[limitProp] = 1;
        var newSet = assignExcept({}, set, except);
        if (offsetProp in set) {
            newSet.start = parseInt(set[offsetProp], 10);
        }
        if (limitProp in set) {
            newSet.end = newSet.start + parseInt(set[limitProp]) - 1;
        }
        return newSet;
    };
    props.offsetLimit = function (offsetProp, limitProp) {
        offsetProp = offsetProp || 'offset';
        limitProp = limitProp || 'limit';
        return props.paginate(offsetProp, limitProp, function (set) {
            return translateToStartEnd(set, offsetProp, limitProp);
        }, function (set) {
            return translateToOffsetLimit(set, offsetProp, limitProp);
        });
    };
    props.rangeInclusive = function (startIndexProperty, endIndexProperty) {
        startIndexProperty = startIndexProperty || 'start';
        endIndexProperty = endIndexProperty || 'end';
        return props.paginate(startIndexProperty, endIndexProperty, function (set) {
            var except = {};
            except[startIndexProperty] = except[endIndexProperty] = 1;
            var newSet = assignExcept({}, set, except);
            if (startIndexProperty in set) {
                newSet.start = set[startIndexProperty];
            }
            if (endIndexProperty in set) {
                newSet.end = set[endIndexProperty];
            }
            return newSet;
        }, function (set) {
            var except = {
                start: 1,
                end: 1
            };
            var newSet = assignExcept({}, set, except);
            newSet[startIndexProperty] = set.start;
            newSet[endIndexProperty] = set.end;
            return newSet;
        });
    };
    var nestedLookup = function (obj, propNameArray) {
        if (obj === undefined) {
            return undefined;
        }
        if (propNameArray.length === 1) {
            return obj[propNameArray[0]];
        } else {
            return nestedLookup(obj[propNameArray[0]], propNameArray.slice(1));
        }
    };
    props.dotNotation = function (dotProperty) {
        var compares = new clause.Where({});
        compares[dotProperty] = function (aVal, bVal, a, b, propertyName) {
            if (aVal === undefined) {
                aVal = nestedLookup(a, propertyName.split('.'));
            }
            if (bVal === undefined) {
                bVal = nestedLookup(b, propertyName.split('.'));
            }
            return aVal === bVal;
        };
        return compares;
    };
    module.exports = props;
});
/*can-set@1.3.0#src/prop_tests/sort_test*/
define('can-set@1.3.0#src/prop_tests/sort_test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var set = require('../set-core'), props = require('../props');
    var each = require('can-util/js/each/each');
    QUnit.module('can-set props.sort');
    test('set.difference', function () {
        var prop = props.sort('sort');
        var res = set.difference({ sort: 'foo' }, { completed: true }, prop);
        ok(res === true, 'diff should be true');
        res = set.difference({ completed: true }, {
            completed: true,
            sort: 'foo'
        }, prop);
        equal(res, false, 'the same except for sort');
        res = set.difference({ completed: true }, { sort: 'foo' }, prop);
        equal(res, false);
        res = set.difference({ completed: true }, {
            foo: 'bar',
            sort: 'foo'
        }, prop);
        equal(res, false);
    });
    test('set.difference({ function })', function () {
        var algebra = new set.Algebra(props.sort('sort'), {
            colors: function () {
                return {
                    difference: ['red'],
                    intersection: ['blue']
                };
            }
        });
        var res = algebra.difference({
            colors: [
                'red',
                'blue'
            ],
            sort: 'colors'
        }, { colors: ['blue'] });
        deepEqual(res, { colors: ['red'] });
    });
    test('set.union', function () {
        var prop = props.sort('sort');
        var res = set.union({ sort: 'name' }, { completed: true }, prop);
        deepEqual(res, {}, 'set / subset sort left');
        res = set.union({}, {
            completed: true,
            sort: 'name'
        }, prop);
        deepEqual(res, {}, 'set / subset sort right');
        res = set.union({ sort: 'name' }, {
            completed: true,
            sort: 'namer'
        }, prop);
        deepEqual(res, {}, 'set / subset both sorts');
        res = set.union({ completed: true }, { sort: 'foo' }, prop);
        deepEqual(res, {}, 'subset / set');
        res = set.union({
            foo: 'bar',
            sort: 'foo'
        }, { foo: 'bar' }, prop);
        deepEqual(res, { foo: 'bar' }, 'equal');
        res = set.union({ foo: 'bar' }, {
            foo: 'zed',
            sort: 'foo'
        }, prop);
        ok(!res, 'values not equal');
        res = set.union({
            foo: 'bar',
            sort: 'foo'
        }, { name: 'A' }, prop);
        ok(!res, 'values not equal');
    });
    test('set.union Array', function () {
        var prop = props.sort('sort');
        var res = set.union({
            foo: [
                'a',
                'b'
            ],
            sort: 'foo'
        }, {
            foo: [
                'a',
                'c'
            ]
        }, prop);
        deepEqual(res, {
            foo: [
                'a',
                'b',
                'c'
            ]
        }, 'set / subset');
    });
    test('set.count', function () {
        ok(set.count({ sort: 'name' }) === Infinity, 'defaults to infinity');
        ok(set.count({
            foo: 'bar',
            sort: 'foo'
        }, {}) === Infinity, 'defaults to infinity');
        equal(set.count({
            foo: 'bar',
            sort: 'foo'
        }, {
            foo: function () {
                return { count: 100 };
            }
        }), 100, 'works with a single value');
    });
    test('set.intersection', function () {
        var prop = props.sort('sort');
        var res = set.intersection({}, { sort: 'name' }, prop);
        deepEqual(res, {}, 'no sort if only one is sorted');
        res = set.intersection({ sort: 'name' }, { sort: 'name' }, prop);
        deepEqual(res, { sort: 'name' }, '');
        res = set.intersection({ type: 'new' }, {
            sort: 'name',
            userId: 5
        }, prop);
        deepEqual(res, {
            type: 'new',
            userId: 5
        }, '');
        res = set.intersection({
            type: 'new',
            sort: 'age'
        }, {
            sort: 'name',
            userId: 5
        }, prop);
        deepEqual(res, {
            type: 'new',
            userId: 5
        }, '');
    });
    test('set.intersection Array', function () {
        var prop = props.sort('sort');
        var res = set.intersection({
            foo: [
                'a',
                'b'
            ],
            sort: 'foo'
        }, {
            foo: [
                'a',
                'c'
            ]
        }, prop);
        deepEqual(res, { foo: ['a'] }, 'intersection');
    });
    test('set.subset', function () {
        var ignoreProp = function () {
            return true;
        };
        var algebra = new set.Algebra(props.sort('sort'), {
            foo: ignoreProp,
            bar: ignoreProp,
            kind: ignoreProp,
            count: ignoreProp
        });
        ok(algebra.subset({
            type: 'FOLDER',
            sort: 'thing'
        }, { type: 'FOLDER' }), 'equal sets with sort on the left');
        ok(algebra.subset({ type: 'FOLDER' }, {
            type: 'FOLDER',
            sort: 'thing'
        }), 'equal sets with sort on the right');
        ok(algebra.subset({
            type: 'FOLDER',
            parentId: 5,
            sort: 'thing'
        }, { type: 'FOLDER' }), 'sub set with sort on the left');
        ok(algebra.subset({
            type: 'FOLDER',
            parentId: 5
        }, {
            type: 'FOLDER',
            sort: 'thing'
        }), 'sub set with sort on the right');
        ok(!algebra.subset({
            type: 'FOLDER',
            sort: 'thing'
        }, {
            type: 'FOLDER',
            parentId: 5
        }), 'wrong way with sort on the left');
        ok(!algebra.subset({ type: 'FOLDER' }, {
            type: 'FOLDER',
            parentId: 5,
            sort: 'thing'
        }), 'wrong way with sort on the right');
        ok(!algebra.subset({
            type: 'FOLDER',
            parentId: 7,
            sort: 'thing'
        }, {
            type: 'FOLDER',
            parentId: 5
        }), 'different values with sort on the left');
        ok(!algebra.subset({
            type: 'FOLDER',
            parentId: 7
        }, {
            type: 'FOLDER',
            parentId: 5,
            sort: 'thing'
        }), 'different values with sort on the right');
    });
    test('set.subset with range', function () {
        var algebra = new set.Algebra(props.sort('sort'), props.rangeInclusive('start', 'end'));
        var addSort = function (set, value) {
            set.sort = value;
        };
        var sort = {
            left: function (setA, setB) {
                addSort(setA, 'prop');
            },
            right: function (setA, setB) {
                addSort(setB, 'prop');
            },
            same: function (setA, setB) {
                addSort(setA, 'prop');
                addSort(setB, 'prop');
            },
            different: function (setA, setB) {
                addSort(setA, 'propA');
                addSort(setB, 'propB');
            }
        };
        var addRange = function (set, start, end) {
            set.start = start;
            set.end = end;
        };
        var range = {
            left: function (setA, setB) {
                addRange(setA, 0, 9);
            },
            right: function (setA, setB) {
                addRange(setB, 0, 9);
            },
            same: function (setA, setB) {
                addRange(setA, 0, 9);
                addRange(setB, 0, 9);
            },
            superLeft: function (setA, setB) {
                addRange(setA, 0, 9);
                addRange(setB, 3, 7);
            },
            superRight: function (setA, setB) {
                addRange(setB, 0, 9);
                addRange(setA, 3, 7);
            }
        };
        var sets = {
            same: function (setA, setB) {
            },
            superLeft: function (setA, setB) {
                setB.type = 'apples';
            },
            superRight: function (setA, setB) {
                setA.type = 'apples';
            }
        };
        var make = function () {
            var setA = {}, setB = {};
            each(arguments, function (method) {
                method(setA, setB);
            });
            return {
                left: setA,
                right: setB
            };
        };
        var assertSubset = function (methods, result) {
            var sets = make.apply(null, methods);
            equal(algebra.subset(sets.left, sets.right), result, JSON.stringify(sets.left) + ' \u2282 ' + JSON.stringify(sets.right) + ' = ' + result);
        };
        assertSubset([
            sets.superRight,
            range.right,
            sort.right
        ], false);
        assertSubset([
            sets.same,
            range.same,
            sort.different
        ], false);
        assertSubset([
            sets.same,
            range.same,
            sort.same
        ], true);
        assertSubset([
            sets.same,
            range.superRight,
            sort.left
        ], false);
        assertSubset([
            sets.same,
            range.superRight,
            sort.same
        ], true);
    });
    test('set.index', function () {
        var algebra = new set.Algebra(props.sort('sort'));
        var index = algebra.index({ sort: 'name' }, [
            {
                id: 1,
                name: 'g'
            },
            {
                id: 2,
                name: 'j'
            },
            {
                id: 3,
                name: 'm'
            },
            {
                id: 4,
                name: 's'
            }
        ], { name: 'k' });
        equal(index, 2);
    });
    test('set.getSubset (#14)', function () {
        var algebra = new set.Algebra(props.sort('sort'));
        var subset = algebra.getSubset({ sort: 'name' }, {}, [
            {
                id: 1,
                name: 's'
            },
            {
                id: 2,
                name: 'j'
            },
            {
                id: 3,
                name: 'm'
            },
            {
                id: 4,
                name: 'g'
            }
        ]);
        deepEqual(subset, [
            {
                id: 4,
                name: 'g'
            },
            {
                id: 2,
                name: 'j'
            },
            {
                id: 3,
                name: 'm'
            },
            {
                id: 1,
                name: 's'
            }
        ]);
    });
    test('set.getUnion', function () {
        var algebra = new set.Algebra(props.sort('sort'), props.boolean('complete'));
        var union = algebra.getUnion({
            sort: 'name',
            complete: true
        }, {
            sort: 'name',
            complete: false
        }, [
            {
                id: 4,
                name: 'g',
                complete: true
            },
            {
                id: 3,
                name: 'm',
                complete: true
            }
        ], [
            {
                id: 2,
                name: 'j',
                complete: false
            },
            {
                id: 1,
                name: 's',
                complete: false
            }
        ]);
        deepEqual(union, [
            {
                id: 4,
                name: 'g',
                complete: true
            },
            {
                id: 2,
                name: 'j',
                complete: false
            },
            {
                id: 3,
                name: 'm',
                complete: true
            },
            {
                id: 1,
                name: 's',
                complete: false
            }
        ]);
    });
    test('set.union keeps sort', function () {
        var algebra = new set.Algebra(props.sort('sort'), props.boolean('complete'));
        var union = algebra.union({
            sort: 'name',
            complete: true
        }, {
            sort: 'name',
            complete: false
        });
        deepEqual(union, { sort: 'name' });
    });
    test('paginated and sorted is subset (#17)', function () {
        var algebra = new set.Algebra(props.sort('sort'), props.rangeInclusive('start', 'end'));
        var res = algebra.subset({
            start: 0,
            end: 100,
            sort: 'name'
        }, {
            start: 0,
            end: 100,
            sort: 'name'
        });
        equal(res, true, 'parent:paginate+order child:paginate+order (same set)');
        res = algebra.subset({
            start: 0,
            end: 100,
            sort: 'name'
        }, {
            start: 0,
            end: 100,
            sort: 'age'
        });
        equal(res, false, 'parent:paginate+order child:paginate+order (different order)');
        res = algebra.subset({
            start: 0,
            end: 100,
            sort: 'name'
        }, { sort: 'name' });
        equal(res, true, 'parent:order child:paginate+order');
        res = algebra.subset({ sort: 'name' }, { sort: 'name' });
        equal(res, true, 'parent:order child:order (same)');
        res = algebra.subset({ sort: 'name' }, { sort: 'age' });
        equal(res, true, 'parent:order child:order (different)');
        res = algebra.subset({
            start: 0,
            end: 100
        }, { sort: 'name' });
        equal(res, true, 'parent:order child:paginate');
        res = algebra.subset({
            start: 0,
            end: 100,
            sort: 'age'
        }, { sort: 'name' });
        equal(res, true, 'parent:order child:paginate+order');
        res = algebra.subset({
            start: 0,
            end: 100,
            sort: 'name'
        }, {
            start: 0,
            end: 100
        });
        equal(res, false, 'parent:paginate child:paginate+order');
        res = algebra.subset({ sort: 'name' }, {
            start: 0,
            end: 100
        });
        equal(res, false, 'parent:paginate child:order (same)');
        res = algebra.subset({
            start: 0,
            end: 100,
            sort: 'name'
        }, {});
        equal(res, true, 'parent:-- child:paginate+order');
        res = algebra.subset({
            start: 10,
            end: 90,
            sort: 'name'
        }, {
            start: 0,
            end: 100,
            sort: 'name'
        });
        equal(res, true, 'child in smaller range, same sort');
        res = algebra.subset({
            start: 10,
            end: 90,
            sort: 'name'
        }, {
            start: 0,
            end: 100,
            sort: 'age'
        });
        equal(res, false, 'child in smaller range, but different sort');
    });
});
/*can-set@1.3.0#src/prop_tests/rangeInclusive_test*/
define('can-set@1.3.0#src/prop_tests/rangeInclusive_test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var set = require('../set-core'), props = require('../props');
    QUnit.module('can-set props.rangeInclusive');
    test('rangeInclusive set.equal', function () {
        ok(set.equal({
            start: 0,
            end: 100
        }, {
            start: 0,
            end: 100
        }, props.rangeInclusive('start', 'end')), 'they are equal');
        ok(!set.equal({
            start: 0,
            end: 100
        }, {
            start: 0,
            end: 101
        }, props.rangeInclusive('start', 'end')), 'they are not equal');
        ok(!set.equal({
            start: 0,
            end: 100
        }, {
            start: 1,
            end: 100
        }, props.rangeInclusive('start', 'end')), 'they are not equal');
    });
    test('rangeInclusive set.subset', function () {
        ok(set.subset({
            start: 0,
            end: 100
        }, {
            start: 0,
            end: 100
        }, props.rangeInclusive('start', 'end')), 'self is a subset');
        ok(set.subset({
            start: 0,
            end: 100
        }, {
            start: 0,
            end: 101
        }, props.rangeInclusive('start', 'end')), 'end extends past subset');
        ok(!set.subset({
            start: 0,
            end: 101
        }, {
            start: 0,
            end: 100
        }, props.rangeInclusive('start', 'end')), 'non-subset extends past end');
        ok(set.subset({
            start: 1,
            end: 100
        }, {
            start: 0,
            end: 100
        }, props.rangeInclusive('start', 'end')), 'start extends before subset');
        ok(!set.subset({
            start: 0,
            end: 100
        }, {
            start: 1,
            end: 100
        }, props.rangeInclusive('start', 'end')), 'non-subset extends before start');
    });
    test('rangeInclusive set.difference', function () {
        var prop = props.rangeInclusive('start', 'end');
        var res = set.difference({
            start: 0,
            end: 99
        }, {
            start: 50,
            end: 101
        }, prop);
        deepEqual(res, {
            start: 0,
            end: 49
        }, 'got a diff');
        res = set.difference({}, {
            start: 0,
            end: 10
        }, prop);
        equal(res, true, 'universal set');
        res = set.difference({
            start: 0,
            end: 49
        }, {
            start: 50,
            end: 101
        }, prop);
        deepEqual(res, {
            start: 0,
            end: 49
        }, 'side by side');
        res = set.difference({
            start: 0,
            end: 49
        }, {
            start: 0,
            end: 20
        }, prop);
        deepEqual(res, {
            start: 21,
            end: 49
        }, 'first set extends past second');
        res = set.difference({
            start: 0,
            end: 49
        }, {
            start: 20,
            end: 49
        }, prop);
        deepEqual(res, {
            start: 0,
            end: 19
        }, 'first set starts before second');
    });
    test('rangeInclusive set.union', function () {
        var prop = props.rangeInclusive('start', 'end');
        var res = set.union({
            start: 0,
            end: 99
        }, {
            start: 50,
            end: 101
        }, prop);
        deepEqual(res, {
            start: 0,
            end: 101
        }, 'got a union');
        res = set.union({}, {
            start: 0,
            end: 10
        }, prop);
        deepEqual(res, {}, 'universal set');
        res = set.union({
            start: 100,
            end: 199
        }, {
            start: 200,
            end: 299
        }, prop);
        deepEqual(res, {
            start: 100,
            end: 299
        }, 'no intersection');
        res = set.union({
            start: 200,
            end: 299
        }, {
            start: 100,
            end: 199
        }, prop);
        deepEqual(res, {
            start: 100,
            end: 299
        }, 'no intersection with either argument order');
        res = set.union({
            start: 200,
            end: 299
        }, {
            start: 100,
            end: 209
        }, prop);
        deepEqual(res, {
            start: 100,
            end: 299
        }, 'sets can intersect');
        res = set.union({
            start: 100,
            end: 209
        }, {
            start: 200,
            end: 299
        }, prop);
        deepEqual(res, {
            start: 100,
            end: 299
        }, 'sets can intersect with either argument order');
        res = set.union({
            start: 100,
            end: 299
        }, {
            start: 103,
            end: 209
        }, prop);
        deepEqual(res, {
            start: 100,
            end: 299
        }, 'first set contains second');
        res = set.union({
            start: 100,
            end: 299
        }, {
            start: 103,
            end: 209
        }, prop);
        deepEqual(res, {
            start: 100,
            end: 299
        }, 'second set contains first');
        res = set.union({
            start: 100,
            end: 299
        }, {
            start: 100,
            end: 299
        }, prop);
        deepEqual(res, {
            start: 100,
            end: 299
        }, 'union of identical sets is the same as those sets');
    });
    test('rangeInclusive set.count', function () {
        var prop = props.rangeInclusive('start', 'end');
        var res = set.count({
            start: 0,
            end: 99
        }, prop);
        equal(res, 100, 'count is right');
    });
    test('rangeInclusive set.intersection', function () {
        var prop = props.rangeInclusive('start', 'end');
        var res = set.intersection({
            start: 0,
            end: 99
        }, {
            start: 50,
            end: 101
        }, prop);
        deepEqual(res, {
            start: 50,
            end: 99
        }, 'got a intersection');
    });
    test('rangeInclusive with string numbers (#17)', function () {
        var algebra = new set.Algebra(props.rangeInclusive('start', 'end'));
        ok(algebra.subset({
            start: '1',
            end: '100'
        }, {
            start: '0',
            end: '100'
        }), '.subset');
        var res = algebra.getSubset({
            start: '2',
            end: '3'
        }, {
            start: '1',
            end: '4'
        }, [
            { id: 1 },
            { id: 2 },
            { id: 3 },
            { id: 4 }
        ]);
        deepEqual(res, [
            { id: 2 },
            { id: 3 }
        ], '.getSubset');
        res = algebra.getUnion({
            start: '2',
            end: '3'
        }, {
            start: '1',
            end: '4'
        }, [
            { id: 2 },
            { id: 3 }
        ], [
            { id: 1 },
            { id: 2 },
            { id: 3 },
            { id: 4 }
        ]);
        deepEqual(res, [
            { id: 1 },
            { id: 2 },
            { id: 3 },
            { id: 4 }
        ], '.getUnion');
    });
});
/*can-set@1.3.0#src/prop_tests/offsetLimit_test*/
define('can-set@1.3.0#src/prop_tests/offsetLimit_test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var set = require('../set-core'), props = require('../props');
    QUnit.module('can-set props.limitOffset');
    test('offsetLimit set.equal', function () {
        ok(set.equal({
            offset: 0,
            limit: 99
        }, {
            offset: 0,
            limit: 99
        }, props.offsetLimit('offset', 'limit')), 'they are equal');
        ok(!set.equal({
            offset: 0,
            limit: 100
        }, {
            offset: 0,
            limit: 101
        }, props.offsetLimit('offset', 'limit')), 'they are not equal');
        ok(!set.equal({
            offset: 0,
            limit: 100
        }, {
            offset: 1,
            limit: 100
        }, props.offsetLimit('offset', 'limit')), 'they are not equal');
    });
    test('offsetLimit set.union', function () {
        var prop = props.offsetLimit('offset', 'limit');
        var res = set.union({
            offset: 0,
            limit: 100
        }, {
            offset: 50,
            limit: 52
        }, prop);
        deepEqual(res, {
            offset: 0,
            limit: 102
        }, 'got a union');
        res = set.union({}, {
            offset: 0,
            limit: 10
        }, prop);
        deepEqual(res, {}, 'universal set');
        res = set.union({
            offset: 100,
            limit: 100
        }, {
            offset: 200,
            limit: 100
        }, prop);
        deepEqual(res, {
            offset: 100,
            limit: 200
        }, 'no intersection');
        res = set.union({
            offset: 200,
            limit: 100
        }, {
            offset: 100,
            limit: 100
        }, prop);
        deepEqual(res, {
            offset: 100,
            limit: 200
        }, 'no intersection with either argument order');
        res = set.union({
            offset: 100,
            limit: 110
        }, {
            offset: 200,
            limit: 100
        }, prop);
        deepEqual(res, {
            offset: 100,
            limit: 200
        }, 'sets can intersect with either argument order');
    });
    test('rangeInclusive set.count', function () {
        var prop = props.offsetLimit('offset', 'limit');
        var res = set.count({
            offset: 0,
            limit: 100
        }, prop);
        equal(res, 100, 'count is right');
    });
    test('rangeInclusive set.intersection', function () {
        var prop = props.offsetLimit('offset', 'limit');
        var res = set.intersection({
            offset: 0,
            limit: 100
        }, {
            offset: 50,
            limit: 52
        }, prop);
        deepEqual(res, {
            offset: 50,
            limit: 50
        }, 'got a intersection');
    });
});
/*can-set@1.3.0#src/prop_tests/boolean_test*/
define('can-set@1.3.0#src/prop_tests/boolean_test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var set = require('../set-core'), props = require('../props');
    QUnit.module('can-set props.boolean');
    test('boolean set.difference', function () {
        var prop = props.boolean('completed');
        var res = set.difference({}, { completed: true }, prop);
        deepEqual(res, { completed: false }, 'inverse of true');
        res = set.difference({}, { completed: false }, prop);
        deepEqual(res, { completed: true }, 'inverse of false');
    });
    test('boolean set.union', function () {
        var prop = props.boolean('completed');
        var res = set.union({ completed: false }, { completed: true }, prop);
        deepEqual(res, {}, 'union of true and false is entire boolean set');
    });
    test('boolean set.intersection', function () {
        var prop = props.boolean('completed');
        var res = set.intersection({ foo: 'bar' }, { completed: true }, prop);
        deepEqual(res, {
            foo: 'bar',
            completed: true
        }, 'intersection is false (#4)');
    });
    test('strings false and true are treated as booleans', function () {
        var prop = props.boolean('completed');
        var res = set.subset({}, { completed: 'true' }, prop);
        ok(!res, '{} and \'true\' not a subset');
        res = set.subset({}, { completed: 'false' }, prop);
        ok(!res, '{} and \'false\' not a subset');
        res = set.subset({ completed: 'true' }, {}, prop);
        ok(res, 'subset');
        res = set.subset({ completed: 'false' }, {}, prop);
        ok(res, 'subset');
        res = set.union({ completed: 'false' }, { completed: 'true' }, prop);
        deepEqual(res, {}, 'union of true and false is entire boolean set');
        res = set.equal({ completed: false }, { completed: 'false' }, prop);
        ok(res, 'false and \'false\'');
    });
});
/*can-set@1.3.0#src/prop_tests/enum_test*/
define('can-set@1.3.0#src/prop_tests/enum_test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var set = require('../set-core'), props = require('../props');
    QUnit.module('can-set props.enum');
    test('enum set.intersection', function () {
        var prop = props['enum']('type', [
            'new',
            'prep',
            'deliver',
            'delivered'
        ]);
        var res = set.intersection({}, { type: 'new' }, prop);
        deepEqual(res, { type: 'new' }, 'single enum intersected with universal set is idempotent');
        res = set.intersection({}, {
            type: [
                'new',
                'prep'
            ]
        }, prop);
        deepEqual(res, {
            type: [
                'new',
                'prep'
            ]
        }, 'array enum intersected with unversal set is idempotent');
        res = set.intersection({ type: ['prep'] }, {
            type: [
                'new',
                'prep'
            ]
        }, prop);
        deepEqual(res, { type: 'prep' }, 'items v items intersection');
        res = set.intersection({ type: [] }, {
            type: [
                'new',
                'prep'
            ]
        }, prop);
        deepEqual(res, {
            type: [
                'new',
                'prep'
            ]
        }, 'empty v array intersection');
        res = set.intersection({ type: 'new' }, {}, prop);
        deepEqual(res, { type: 'new' }, 'single v all');
    });
    test('enum set.difference', function () {
        var prop = props['enum']('type', [
            'new',
            'prep',
            'deliver',
            'delivered'
        ]);
        var res = set.difference({}, { type: 'new' }, prop);
        deepEqual(res, {
            type: [
                'prep',
                'deliver',
                'delivered'
            ]
        }, 'difference from universal set');
        res = set.difference({}, {
            type: [
                'new',
                'prep'
            ]
        }, prop);
        deepEqual(res, {
            type: [
                'deliver',
                'delivered'
            ]
        }, 'difference from universal set');
        res = set.difference({ type: ['prep'] }, {
            type: [
                'new',
                'prep'
            ]
        }, prop);
        deepEqual(res, false, 'difference from a superset');
        res = set.difference({ type: [] }, {
            type: [
                'new',
                'prep'
            ]
        }, prop);
        deepEqual(res, {
            type: [
                'deliver',
                'delivered'
            ]
        }, 'empty enum definition is same as universal set');
        res = set.difference({ type: 'new' }, {}, prop);
        deepEqual(res, false, 'all');
    });
    test('enum set.union', function () {
        var prop = props['enum']('type', [
            'new',
            'prep',
            'deliver',
            'delivered'
        ]);
        var res = set.union({}, { type: 'new' }, prop);
        deepEqual(res, {}, 'all');
        res = set.union({}, {
            type: [
                'new',
                'prep'
            ]
        }, prop);
        deepEqual(res, {}, 'intersection');
        res = set.union({ type: ['prep'] }, {
            type: [
                'new',
                'prep'
            ]
        }, prop);
        deepEqual(res, {
            type: [
                'prep',
                'new'
            ]
        }, 'union of a superset is superset');
        res = set.union({ type: [] }, {
            type: [
                'new',
                'prep'
            ]
        }, prop);
        deepEqual(res, {}, 'intersection');
        res = set.union({ type: 'new' }, {}, prop);
        deepEqual(res, {}, 'all');
        res = set.union({
            type: [
                'deliver',
                'delivered'
            ]
        }, {
            type: [
                'new',
                'prep'
            ]
        }, prop);
        deepEqual(res, {}, 'intersection');
    });
    test('enum set.equal', function () {
        var prop = props['enum']('type', [
            'new',
            'prep',
            'deliver',
            'delivered'
        ]);
        var res = set.equal({}, { type: 'new' }, prop);
        deepEqual(res, false, 'proper subset is not the universal set');
        res = set.equal({}, {
            type: [
                'new',
                'prep',
                'deliver',
                'delivered'
            ]
        }, prop);
        deepEqual(res, true, 'subset of all possible enums is the same as universal set');
        res = set.equal({ type: ['prep'] }, { type: ['prep'] }, prop);
        deepEqual(res, true, 'identical sets with single array enum are equal');
        res = set.equal({ type: 'prep' }, { type: 'prep' }, prop);
        deepEqual(res, true, 'identical sets with single property enum are equal');
        res = set.equal({ type: 'new' }, { type: 'prep' }, prop);
        deepEqual(res, false, 'two sets with different enum properties are not equal');
    });
    test('enum set.subset', function () {
        var prop = props['enum']('type', [
            'new',
            'prep',
            'deliver',
            'delivered'
        ]);
        var res = set.subset({}, { type: 'new' }, prop);
        deepEqual(res, false, 'universal set is not a subset');
        res = set.subset({ type: 'new' }, {}, prop);
        deepEqual(res, true, 'any single enum is a subset of universal set');
        res = set.subset({}, {
            type: [
                'new',
                'prep',
                'deliver',
                'delivered'
            ]
        }, prop);
        deepEqual(res, true, 'enum set matching definition of universal set is a subset of universal set');
        res = set.subset({ type: ['prep'] }, { type: ['prep'] }, prop);
        deepEqual(res, true, 'any list of possible enums are subset of universal set');
        res = set.subset({ type: 'prep' }, { type: 'prep' }, prop);
        deepEqual(res, true, 'intersection');
        res = set.subset({ type: 'new' }, { type: 'prep' }, prop);
        deepEqual(res, false, 'all');
        res = set.subset({ type: 'prep' }, {
            type: [
                'new',
                'prep',
                'deliver',
                'delivered'
            ]
        }, prop);
        deepEqual(res, true, 'intersection');
    });
});
/*can-set@1.3.0#src/prop_tests/dotNotation_test*/
define('can-set@1.3.0#src/prop_tests/dotNotation_test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var set = require('../set-core'), props = require('../props');
    QUnit.module('can-set props.dotNotation');
    test('dotNotation set membership', function () {
        var prop = props.dotNotation('n.p'), alg = new set.Algebra(prop), res = alg.has({ 'n.p': 'IL' }, { n: { p: 'IL' } });
        ok(res, 'object with nested property is member of set using dotNotation');
        res = alg.has({ 'n.p': 'IL' }, { n: { p: 'MI' } });
        ok(res === false, 'object with nested property not a member of set using dotNotation');
        prop = props.dotNotation('n.p.s');
        alg = new set.Algebra(prop);
        res = alg.has({ 'n.p.s': 'IL' }, { n: { p: { s: 'IL' } } });
        ok(res, 'object with deep nested property is member of set using dotNotation');
    });
    test('dotNotation set equality', function () {
        var prop = props.dotNotation('n.p'), alg = new set.Algebra(prop), set1 = { 'n.p': 'IL' }, set2 = { 'n.p': 'IL' }, set3 = { 'n.p': 'MI' }, set4 = { n: { p: 'MI' } };
        ok(alg.equal(set1, set2) && alg.equal(set2, set1), 'sets with dotNotation properties are equivalent');
        ok(alg.equal(set1, set3) === false, 'sets with dotNotation properties are not equivalent');
        ok(alg.equal(set4, set3) === false, 'sets with dotNotation properties are equivalent to sets with nested properties');
    });
    test('dotNotation set subset', function () {
        var alg = new set.Algebra(props.dotNotation('address.state'), props.dotNotation('address.city')), set1 = { 'address.state': 'IL' }, set2 = {
                'address.state': 'IL',
                'address.city': 'Chicago'
            }, set3 = {
                address: {
                    state: 'IL',
                    city: 'Chicago'
                }
            };
        ok(alg.subset(set2, set1), 'sets with dotNotation property is a subset of another dotNotation set');
        ok(alg.subset(set3, set1), 'sets with nested property notation is a subset of a dotNotation set');
        ok(alg.subset(set1, {}), 'sets with dotNotation properties are subsets of the universal set');
        ok(alg.subset({}, set1) === false, 'the universal set is not a subset of a set with dotNotation');
    });
});
/*can-set@1.3.0#src/props_test*/
define('can-set@1.3.0#src/props_test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    QUnit.module('can-set props');
    require('./prop_tests/sort_test');
    require('./prop_tests/rangeInclusive_test');
    require('./prop_tests/offsetLimit_test');
    require('./prop_tests/boolean_test');
    require('./prop_tests/enum_test');
    require('./prop_tests/dotNotation_test');
});
/*can-set@1.3.0#src/set*/
define('can-set@1.3.0#src/set', function (require, exports, module) {
    var set = require('./set-core');
    var ns = require('can-namespace');
    var props = require('./props');
    var clause = require('./clause');
    set.comparators = props;
    set.props = props;
    set.helpers = require('./helpers');
    set.clause = clause;
    module.exports = ns.set = set;
});
/*can-set@1.3.0#src/get_test*/
define('can-set@1.3.0#src/get_test', function (require, exports, module) {
    var set = require('./set');
    var QUnit = require('steal-qunit');
    var props = require('./props');
    var h = require('./helpers');
    QUnit.module('can-set get');
    var getId = function (d) {
        return d.id;
    };
    var items = [
        {
            id: 0,
            note: 'C',
            type: 'eh'
        },
        {
            id: 1,
            note: 'D',
            type: 'critical'
        },
        {
            id: 2,
            note: 'E',
            type: 'critical'
        },
        {
            id: 3,
            note: 'F',
            type: 'eh'
        },
        {
            id: 4,
            note: 'G',
            type: 'critical'
        },
        {
            id: 5,
            note: 'A'
        },
        {
            id: 6,
            note: 'B',
            type: 'critical'
        },
        {
            id: 7,
            note: 'C',
            type: 'critical'
        }
    ];
    test('getSubset against non ranged set', function () {
        var res = set.getSubset({
            type: 'critical',
            start: 1,
            end: 3
        }, {}, items, props.rangeInclusive('start', 'end'));
        deepEqual(res && h.map.call(res, getId), [
            2,
            4,
            6
        ]);
    });
    test('getSubset ordered ascending and paginated', function () {
        var algebra = new set.Algebra(props.sort('sort'), props.rangeInclusive('start', 'end'));
        var res = set.getSubset({
            type: 'critical',
            start: 1,
            end: 3,
            sort: 'note AsC'
        }, {}, items, algebra);
        deepEqual(res && h.map.call(res, getId), [
            7,
            1,
            2
        ]);
    });
    test('getSubset ordered descending and paginated', function () {
        var algebra = new set.Algebra(props.sort('sort'), props.rangeInclusive('start', 'end'));
        var res = set.getSubset({
            type: 'critical',
            start: 1,
            end: 3,
            sort: 'note deSc'
        }, {}, items, algebra);
        deepEqual(res && h.map.call(res, getId), [
            2,
            1,
            7
        ]);
    });
    test('getSubset against paginated set', function () {
        var res = set.getSubset({
            type: 'critical',
            start: 21,
            end: 23
        }, {
            type: 'critical',
            start: 20,
            end: 27
        }, items, props.rangeInclusive('start', 'end'));
        deepEqual(res && h.map.call(res, getId), [
            2,
            4,
            6
        ]);
    });
    test('getSubset returns undefined against incompatible set', function () {
        var res = set.getSubset({ note: 'C' }, { type: 'critical' }, items);
        strictEqual(res, undefined);
    });
    test('getUnion basics', function () {
        var union = set.getUnion({}, { foo: 'bar' }, items, items.slice(0, 3));
        deepEqual(union, items);
    });
    test('getUnion against ranged sets', function () {
        var union = set.getUnion({
            start: 10,
            end: 13
        }, {
            start: 14,
            end: 17
        }, items.slice(0, 4), items.slice(4, 8), props.rangeInclusive('start', 'end'));
        deepEqual(union, items);
        union = set.getUnion({
            start: 14,
            end: 17
        }, {
            start: 10,
            end: 13
        }, items.slice(4, 8), items.slice(0, 4), props.rangeInclusive('start', 'end'));
        deepEqual(union, items, 'disjoint after');
    });
    test('getUnion against overlapping ranged sets', function () {
        var union = set.getUnion({
            start: 10,
            end: 14
        }, {
            start: 13,
            end: 17
        }, items.slice(0, 5), items.slice(3, 8), props.rangeInclusive('start', 'end'));
        deepEqual(union, items);
        union = set.getUnion({
            start: 10,
            end: 11
        }, {
            start: 11,
            end: 17
        }, items.slice(0, 2), items.slice(1, 8), props.rangeInclusive('start', 'end'));
        deepEqual(union, items);
        union = set.getUnion({
            start: 11,
            end: 17
        }, {
            start: 10,
            end: 11
        }, items.slice(1, 8), items.slice(0, 2), props.rangeInclusive('start', 'end'));
        deepEqual(union, items);
    });
    test('getSubset passed same object works (#3)', function () {
        var algebra = new set.Algebra(props.rangeInclusive('start', 'end'));
        var setObj = {
            start: 1,
            end: 2
        };
        var items = algebra.getSubset(setObj, setObj, [{ id: 1 }]);
        deepEqual(items, [{ id: 1 }]);
    });
});
/*can-set@1.3.0#src/set_test*/
define('can-set@1.3.0#src/set_test', function (require, exports, module) {
    require('steal-qunit');
    var set = require('./set');
    QUnit.module('can-set');
    test('set.Algebra constructors', function () {
        var algebra = new set.Algebra(set.props.rangeInclusive('start', 'end'), set.props.boolean('completed'), set.props['enum']('type', [
            'new',
            'prep',
            'deliver',
            'delivered'
        ]));
        var res = algebra.subset({ type: ['new'] }, {
            type: [
                'new',
                'prep'
            ]
        });
        deepEqual(res, true, 'enum');
    });
    test('set.clause', function () {
        QUnit.ok(set.clause);
    });
});
/*can-set@1.3.0#test/test*/
define('can-set@1.3.0#test/test', function (require, exports, module) {
    require('../src/set-core_test');
    require('../src/set-core-nested_test');
    require('../src/props_test');
    require('../src/get_test');
    require('../src/set_test');
});
/*can-stache@3.2.0#test/expression-test*/
define('can-stache@3.2.0#test/expression-test', function (require, exports, module) {
    var expression = require('../src/expression');
    var QUnit = require('steal-qunit');
    var each = require('can-util/js/each/each');
    var Scope = require('can-view-scope');
    var canCompute = require('can-compute');
    var CanMap = require('can-map');
    var CanList = require('can-list');
    var helpers = require('../helpers/converter');
    var canReflect = require('can-reflect');
    QUnit.module('can-stache/src/expression');
    test('expression.tokenize', function () {
        var literals = '\'quote\' "QUOTE" 1 undefined null true false 0.1';
        var res = expression.tokenize(literals);
        deepEqual(res, literals.split(' '));
        var keys = 'key foo.bar foo@bar %foo *foo foo/bar';
        res = expression.tokenize(keys);
        deepEqual(res, keys.split(' '));
        var syntax = '( ) , ~ =';
        res = expression.tokenize(syntax);
        deepEqual(res, syntax.split(' '));
        var curly = '{{ }}';
        res = expression.tokenize(curly);
        deepEqual(res, []);
        var bracket = '[foo] bar [baz]';
        res = expression.tokenize(bracket);
        deepEqual(res, [
            '[',
            'foo',
            ']',
            ' ',
            'bar',
            ' ',
            '[',
            'baz',
            ']',
            ' '
        ]);
    });
    test('expression.ast - helper followed by hash', function () {
        var ast = expression.ast('print_hash prop=own_prop');
        deepEqual(ast, {
            type: 'Helper',
            method: {
                type: 'Lookup',
                key: 'print_hash'
            },
            children: [{
                    type: 'Hashes',
                    children: [{
                            type: 'Hash',
                            prop: 'prop',
                            children: [{
                                    type: 'Lookup',
                                    key: 'own_prop'
                                }]
                        }]
                }]
        });
    });
    test('expression.ast - everything', function () {
        var ast = expression.ast('helperA helperB(1, valueA, propA=~valueB propC=2, 1).zed() \'def\' nested@prop outerPropA=helperC(2,valueB)');
        var helperBCall = {
            type: 'Call',
            method: {
                type: 'Lookup',
                key: '@helperB'
            },
            children: [
                {
                    type: 'Literal',
                    value: 1
                },
                {
                    type: 'Lookup',
                    key: 'valueA'
                },
                {
                    type: 'Hashes',
                    children: [
                        {
                            type: 'Hash',
                            prop: 'propA',
                            children: [{
                                    type: 'Arg',
                                    key: '~',
                                    children: [{
                                            type: 'Lookup',
                                            key: 'valueB'
                                        }]
                                }]
                        },
                        {
                            type: 'Hash',
                            prop: 'propC',
                            children: [{
                                    type: 'Literal',
                                    value: 2
                                }]
                        }
                    ]
                },
                {
                    type: 'Literal',
                    value: 1
                }
            ]
        };
        var helperCCall = {
            type: 'Call',
            method: {
                type: 'Lookup',
                key: '@helperC'
            },
            children: [
                {
                    type: 'Literal',
                    value: 2
                },
                {
                    type: 'Lookup',
                    key: 'valueB'
                }
            ]
        };
        deepEqual(ast, {
            type: 'Helper',
            method: {
                type: 'Lookup',
                key: 'helperA'
            },
            children: [
                {
                    type: 'Call',
                    method: {
                        type: 'Lookup',
                        root: helperBCall,
                        key: '@zed'
                    }
                },
                {
                    type: 'Literal',
                    value: 'def'
                },
                {
                    type: 'Lookup',
                    key: 'nested@prop'
                },
                {
                    type: 'Hashes',
                    children: [{
                            type: 'Hash',
                            prop: 'outerPropA',
                            children: [helperCCall]
                        }]
                }
            ]
        });
    });
    test('expression.parse - everything', function () {
        var exprData = expression.parse('helperA helperB(1, valueA, propA=~valueB propC=2, 1).zed \'def\' nested@prop outerPropA=helperC(2,valueB)');
        var oneExpr = new expression.Literal(1), twoExpr = new expression.Literal(2), def = new expression.Literal('def'), valueA = new expression.ScopeLookup('valueA'), valueB = new expression.ScopeLookup('valueB'), nested = new expression.HelperScopeLookup('nested@prop'), helperA = new expression.HelperLookup('helperA'), helperB = new expression.Lookup('@helperB'), helperC = new expression.Lookup('@helperC');
        var helperBHashArg = new expression.Hashes({
            propA: new expression.Arg(valueB, { compute: true }),
            propC: twoExpr
        });
        var callHelperB = new expression.Call(helperB, [
            oneExpr,
            valueA,
            helperBHashArg,
            oneExpr
        ]);
        var callHelperBdotZed = new expression.ScopeLookup('zed', callHelperB);
        var callHelperC = new expression.Call(helperC, [
            twoExpr,
            valueB
        ], {});
        var callHelperA = new expression.Helper(helperA, [
            callHelperBdotZed,
            def,
            nested
        ], { outerPropA: callHelperC });
        deepEqual(callHelperB, exprData.argExprs[0].rootExpr, 'call helper b');
        deepEqual(callHelperC, exprData.hashExprs.outerPropA, 'helperC call');
        deepEqual(callHelperBdotZed, exprData.argExprs[0], 'call helper b.zed');
        var expectedArgs = [
            callHelperBdotZed,
            def,
            nested
        ];
        each(exprData.argExprs, function (arg, i) {
            deepEqual(arg, expectedArgs[i], 'helperA arg[' + i);
        });
        deepEqual(exprData, callHelperA, 'full thing');
    });
    test('expression.parse(str, {lookupRule: \'method\', methodRule: \'call\'})', function () {
        var exprData = expression.parse('withArgs content=content', {
            lookupRule: 'method',
            methodRule: 'call'
        });
        var valueContent = new expression.ScopeLookup('content');
        var hashArg = new expression.Arg(new expression.Hashes({ content: valueContent }));
        equal(exprData.argExprs.length, 1, 'there is one arg');
        deepEqual(exprData.argExprs[0], hashArg, 'correct hashes');
    });
    test('numeric expression.Literal', function () {
        var exprData = expression.parse('3');
        var result = new expression.Literal(3);
        deepEqual(exprData, result);
    });
    test('expression.Helper:value non-observable values', function () {
        var scope = new Scope({
            fullName: function (first, last) {
                return first + ' ' + last;
            }
        });
        var callFullName = new expression.Helper(new expression.HelperLookup('fullName'), [
            new expression.Literal('marshall'),
            new expression.Literal('thompson')
        ], {});
        var result = callFullName.value(scope, new Scope({}), {});
        equal(expression.toComputeOrValue(result), 'marshall thompson');
    });
    test('expression.Helper:value observable values', function () {
        var obj = {
            fullName: function (first, last) {
                QUnit.equal(this, obj, 'this is right');
                return first() + ' ' + last;
            },
            first: canCompute('marshall')
        };
        var scope = new Scope(obj);
        var callFullName = new expression.Helper(new expression.HelperLookup('fullName'), [
            new expression.HelperLookup('first'),
            new expression.Literal('thompson')
        ], {});
        var result = callFullName.value(scope, new Scope({}));
        equal(result(), 'marshall thompson');
    });
    test('methods can return values (#1887)', function () {
        var MyMap = CanMap.extend({
            getSomething: function (arg) {
                return this.attr('foo') + arg();
            }
        });
        var scope = new Scope(new MyMap({
            foo: 2,
            bar: 3
        })).add({});
        var callGetSomething = new expression.Helper(new expression.HelperLookup('getSomething'), [new expression.ScopeLookup('bar')], {});
        var result = callGetSomething.value(scope, new Scope({}), { asCompute: true });
        equal(result(), 5);
    });
    test('methods don\'t update correctly (#1891)', function () {
        var map = new CanMap({
            num: 1,
            num2: function () {
                return this.attr('num') * 2;
            },
            runTest: function () {
                this.attr('num', this.attr('num') * 2);
            }
        });
        var scope = new Scope(map);
        var num2Expression = new expression.Lookup('num2');
        var num2 = num2Expression.value(scope, new Scope({}), { asCompute: true });
        canReflect.onValue(num2, function () {
        });
        map.runTest();
        equal(canReflect.getValue(num2), 4, 'num2 updated correctly');
    });
    test('call expressions called with different scopes give different results (#1791)', function () {
        var exprData = expression.parse('doSomething(number)');
        var res = exprData.value(new Scope({
            doSomething: function (num) {
                return num * 2;
            },
            number: canCompute(2)
        }));
        equal(res(), 4);
        res = exprData.value(new Scope({
            doSomething: function (num) {
                return num * 3;
            },
            number: canCompute(4)
        }));
        equal(res(), 12);
    });
    test('convertKeyToLookup', function () {
        equal(expression.convertKeyToLookup('../foo'), '../@foo');
        equal(expression.convertKeyToLookup('foo'), '@foo');
        equal(expression.convertKeyToLookup('.foo'), '@foo');
        equal(expression.convertKeyToLookup('./foo'), './@foo');
        equal(expression.convertKeyToLookup('foo.bar'), 'foo@bar');
    });
    test('expression.ast - [] operator', function () {
        deepEqual(expression.ast('[\'propName\']'), {
            type: 'Bracket',
            children: [{
                    type: 'Literal',
                    value: 'propName'
                }]
        }, '[\'propName\'] valid');
        deepEqual(expression.ast('[propName]'), {
            type: 'Bracket',
            children: [{
                    type: 'Lookup',
                    key: 'propName'
                }]
        }, '[propName] valid');
        deepEqual(expression.ast('foo[\'bar\']'), {
            type: 'Bracket',
            root: {
                type: 'Lookup',
                key: 'foo'
            },
            children: [{
                    type: 'Literal',
                    value: 'bar'
                }]
        }, 'foo[\'bar\'] valid');
        deepEqual(expression.ast('foo[bar]'), {
            type: 'Bracket',
            root: {
                type: 'Lookup',
                key: 'foo'
            },
            children: [{
                    type: 'Lookup',
                    key: 'bar'
                }]
        }, 'foo[bar] valid');
        deepEqual(expression.ast('foo[bar()]'), {
            type: 'Bracket',
            root: {
                type: 'Lookup',
                key: 'foo'
            },
            children: [{
                    type: 'Call',
                    method: {
                        key: '@bar',
                        type: 'Lookup'
                    }
                }]
        }, 'foo[bar()] valid');
        deepEqual(expression.ast('foo()[bar]'), {
            type: 'Bracket',
            root: {
                type: 'Call',
                method: {
                    key: '@foo',
                    type: 'Lookup'
                }
            },
            children: [{
                    type: 'Lookup',
                    key: 'bar'
                }]
        }, 'foo()[bar] valid');
        deepEqual(expression.ast('foo [bar]'), {
            type: 'Helper',
            method: {
                type: 'Lookup',
                key: 'foo'
            },
            children: [{
                    type: 'Bracket',
                    children: [{
                            type: 'Lookup',
                            key: 'bar'
                        }]
                }]
        }, 'foo [bar] valid');
        deepEqual(expression.ast('eq foo[\'bar\'] \'foo\''), {
            type: 'Helper',
            method: {
                type: 'Lookup',
                key: 'eq'
            },
            children: [
                {
                    type: 'Bracket',
                    root: {
                        type: 'Lookup',
                        key: 'foo'
                    },
                    children: [{
                            type: 'Literal',
                            value: 'bar'
                        }]
                },
                {
                    type: 'Literal',
                    value: 'foo'
                }
            ]
        }, 'eq foo[\'bar\'] \'foo\' valid');
        deepEqual(expression.ast('eq foo[bar] foo'), {
            type: 'Helper',
            method: {
                type: 'Lookup',
                key: 'eq'
            },
            children: [
                {
                    type: 'Bracket',
                    root: {
                        type: 'Lookup',
                        key: 'foo'
                    },
                    children: [{
                            type: 'Lookup',
                            key: 'bar'
                        }]
                },
                {
                    type: 'Lookup',
                    key: 'foo'
                }
            ]
        }, 'eq foo[bar] foo valid');
        deepEqual(expression.ast('foo[bar][baz]'), {
            type: 'Bracket',
            root: {
                type: 'Bracket',
                root: {
                    type: 'Lookup',
                    key: 'foo'
                },
                children: [{
                        type: 'Lookup',
                        key: 'bar'
                    }]
            },
            children: [{
                    type: 'Lookup',
                    key: 'baz'
                }]
        }, 'foo[bar][baz] valid');
        deepEqual(expression.ast('foo[bar].baz'), {
            type: 'Lookup',
            key: 'baz',
            root: {
                type: 'Bracket',
                root: {
                    type: 'Lookup',
                    key: 'foo'
                },
                children: [{
                        type: 'Lookup',
                        key: 'bar'
                    }]
            }
        }, 'foo[bar].baz');
        deepEqual(expression.ast('eq foo[bar].baz xyz'), {
            type: 'Helper',
            method: {
                type: 'Lookup',
                key: 'eq'
            },
            children: [
                {
                    type: 'Lookup',
                    key: 'baz',
                    root: {
                        type: 'Bracket',
                        root: {
                            type: 'Lookup',
                            key: 'foo'
                        },
                        children: [{
                                type: 'Lookup',
                                key: 'bar'
                            }]
                    }
                },
                {
                    type: 'Lookup',
                    key: 'xyz'
                }
            ]
        }, 'eq foo[bar].baz xyz');
    });
    test('expression.parse - [] operator', function () {
        deepEqual(expression.parse('[\'propName\']'), new expression.Bracket(new expression.Literal('propName')), '[\'propName\']');
        deepEqual(expression.parse('[propName]'), new expression.Bracket(new expression.Lookup('propName')), '[propName]');
        deepEqual(expression.parse('foo[\'bar\']'), new expression.Bracket(new expression.Literal('bar'), new expression.Lookup('foo')), 'foo[\'bar\']');
        deepEqual(expression.parse('foo[bar]'), new expression.Bracket(new expression.Lookup('bar'), new expression.Lookup('foo')), 'foo[bar]');
        deepEqual(expression.parse('foo()[bar]'), new expression.Bracket(new expression.Lookup('bar'), new expression.Call(new expression.Lookup('@foo'), [], {})), 'foo()[bar]');
        var exprData = expression.parse('foo[bar()]');
        deepEqual(exprData, new expression.Bracket(new expression.Call(new expression.Lookup('@bar'), [], {}), new expression.Lookup('foo')));
        exprData = expression.parse('foo()[bar()]');
        deepEqual(exprData, new expression.Bracket(new expression.Call(new expression.Lookup('@bar'), [], {}), new expression.Call(new expression.Lookup('@foo'), [], {})));
    });
    test('Bracket expression', function () {
        var expr = new expression.Bracket(new expression.Literal('bar'));
        var compute = expr.value(new Scope(new CanMap({ bar: 'name' })));
        equal(compute(), 'name');
        expr = new expression.Bracket(new expression.Lookup('bar'));
        compute = expr.value(new Scope(new CanMap({
            bar: 'name',
            name: 'Kevin'
        })));
        equal(compute(), 'Kevin');
        expr = new expression.Bracket(new expression.Literal('bar'), new expression.Lookup('foo'));
        compute = expr.value(new Scope(new CanMap({ foo: { bar: 'name' } })));
        equal(compute(), 'name');
        expr = new expression.Bracket(new expression.Literal('bar.baz'), new expression.Lookup('foo'));
        compute = expr.value(new Scope(new CanMap({ foo: { 'bar.baz': 'name' } })));
        equal(compute(), 'name');
        expr = new expression.Bracket(new expression.Lookup('bar'), new expression.Lookup('foo'));
        var state = new CanMap({
            foo: { name: 'Kevin' },
            bar: 'name'
        });
        compute = expr.value(new Scope(state));
        equal(compute(), 'Kevin');
        compute('Curtis');
        equal(state.attr('foo.name'), 'Curtis');
        expr = new expression.Bracket(new expression.Lookup('bar'), new expression.Call(new expression.Lookup('@foo'), [], {}));
        compute = expr.value(new Scope(new CanMap({
            foo: function () {
                return { name: 'Kevin' };
            },
            bar: 'name'
        })));
        equal(compute(), 'Kevin');
        expr = new expression.Bracket(new expression.Call(new expression.Lookup('@bar'), [], {}), new expression.Lookup('foo'));
        compute = expr.value(new Scope(new CanMap({
            foo: { name: 'Kevin' },
            bar: function () {
                return 'name';
            }
        })));
        equal(compute(), 'Kevin');
        expr = new expression.Bracket(new expression.Call(new expression.Lookup('@bar'), [], {}), new expression.Call(new expression.Lookup('@foo'), [], {}));
        compute = expr.value(new Scope(new CanMap({
            foo: function () {
                return { name: 'Kevin' };
            },
            bar: function () {
                return 'name';
            }
        })));
        equal(compute(), 'Kevin');
        expr = new expression.Call(new expression.Lookup('@foo'), [new expression.Bracket(new expression.Lookup('bar'))], {});
        compute = expr.value(new Scope(new CanMap({
            foo: function (val) {
                return val + '!';
            },
            bar: 'name',
            name: 'Kevin'
        })));
        equal(compute(), 'Kevin!');
    });
    test('registerConverter helpers push and pull correct values', function () {
        helpers.registerConverter('numberToHex', {
            get: function (valCompute) {
                return valCompute().toString(16);
            },
            set: function (val, valCompute) {
                return valCompute(parseInt('0x' + val));
            }
        });
        var data = new CanMap({ observeVal: 255 });
        var scope = new Scope(data);
        var parentExpression = expression.parse('numberToHex(~observeVal)', { baseMethodType: 'Call' });
        var twoWayCompute = parentExpression.value(scope, new Scope.Options({}));
        equal(twoWayCompute(), 'ff', 'Converter called');
        twoWayCompute('7f');
        equal(data.attr('observeVal'), 127, 'push converter called');
    });
    test('registerConverter helpers push and pull multiple values', function () {
        helpers.registerConverter('isInList', {
            get: function (valCompute, list) {
                return !!~list.indexOf(valCompute());
            },
            set: function (newVal, valCompute, list) {
                if (!~list.indexOf(newVal)) {
                    list.push(newVal);
                }
            }
        });
        var data = new CanMap({
            observeVal: 4,
            list: new CanList([
                1,
                2,
                3
            ])
        });
        var scope = new Scope(data);
        var parentExpression = expression.parse('isInList(~observeVal, list)', { baseMethodType: 'Call' });
        var twoWayCompute = parentExpression.value(scope, new Scope.Options({}));
        equal(twoWayCompute(), false, 'Converter called');
        twoWayCompute(5);
        deepEqual(data.attr('list').attr(), [
            1,
            2,
            3,
            5
        ], 'push converter called');
    });
    test('registerConverter helpers are chainable', function () {
        helpers.registerConverter('numberToHex', {
            get: function (valCompute) {
                return valCompute().toString(16);
            },
            set: function (val, valCompute) {
                return valCompute(parseInt('0x' + val));
            }
        });
        helpers.registerConverter('upperCase', {
            get: function (valCompute) {
                return valCompute().toUpperCase();
            },
            set: function (val, valCompute) {
                return valCompute(val.toLowerCase());
            }
        });
        var data = new CanMap({ observeVal: 255 });
        var scope = new Scope(data);
        var parentExpression = expression.parse('upperCase(~numberToHex(~observeVal))', { baseMethodType: 'Call' });
        var twoWayCompute = parentExpression.value(scope, new Scope.Options({}));
        equal(twoWayCompute(), 'FF', 'Converter called');
        twoWayCompute('7F');
        equal(data.attr('observeVal'), 127, 'push converter called');
    });
    test('foo().bar', function () {
        var ast4 = expression.ast('foo().bar');
        deepEqual(ast4, {
            type: 'Lookup',
            key: 'bar',
            root: {
                type: 'Call',
                method: {
                    key: '@foo',
                    type: 'Lookup'
                }
            }
        });
        var exprData = expression.parse('foo().bar');
        deepEqual(exprData, new expression.Lookup('bar', new expression.Call(new expression.Lookup('@foo'), [], {})));
        var expr = new expression.Lookup('bar', new expression.Call(new expression.Lookup('@foo'), [], {}));
        var compute = expr.value(new Scope(new CanMap({
            foo: function () {
                return { bar: 'Kevin' };
            }
        })));
        equal(compute(), 'Kevin');
    });
    test('Helper with a ~ key operator (#112)', function () {
        var ast = expression.ast('each ~foo');
        var expected = {
            type: 'Helper',
            method: {
                type: 'Lookup',
                key: 'each'
            },
            children: [{
                    type: 'Arg',
                    key: '~',
                    children: [{
                            type: 'Lookup',
                            key: 'foo'
                        }]
                }]
        };
        QUnit.deepEqual(ast, expected);
    });
    test('ast with [double][brackets] or [bracket].prop (#207)', function () {
        var ast = expression.ast('test[\'foo\'][0]');
        var expected = {
            type: 'Bracket',
            children: [{
                    type: 'Literal',
                    value: 0
                }],
            root: {
                type: 'Bracket',
                children: [{
                        type: 'Literal',
                        value: 'foo'
                    }],
                root: {
                    type: 'Lookup',
                    key: 'test'
                }
            }
        };
        QUnit.deepEqual(ast, expected);
        ast = expression.ast('test[\'foo\'].zed');
        expected = {
            type: 'Lookup',
            key: 'zed',
            root: {
                type: 'Bracket',
                children: [{
                        type: 'Literal',
                        value: 'foo'
                    }],
                root: {
                    type: 'Lookup',
                    key: 'test'
                }
            }
        };
        QUnit.deepEqual(ast, expected);
        ast = expression.ast('test[\'foo\'].zed[\'bar\']');
        expected = {
            type: 'Bracket',
            children: [{
                    type: 'Literal',
                    value: 'bar'
                }],
            root: {
                type: 'Lookup',
                key: 'zed',
                root: {
                    type: 'Bracket',
                    children: [{
                            type: 'Literal',
                            value: 'foo'
                        }],
                    root: {
                        type: 'Lookup',
                        key: 'test'
                    }
                }
            }
        };
        QUnit.deepEqual(ast, expected);
    });
});
/*can-stache@3.2.0#test/stache-define-test*/
define('can-stache@3.2.0#test/stache-define-test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var stache = require('can-stache');
    var DefineMap = require('can-define/map/map');
    var DefineList = require('can-define/list/list');
    var define = require('can-define');
    QUnit.module('can-stache with can-define');
    test('basic replacement and updating', function () {
        var map = new DefineMap({ message: 'World' });
        var stashed = stache('<h1 class=\'foo\'>{{message}}</h1>');
        var frag = stashed(map);
        equal(frag.firstChild.firstChild.nodeValue, 'World', 'got back the right text');
    });
    test('Helper each inside a text section (attribute) (#8)', function (assert) {
        var template = stache('<div class="{{#each list}}{{.}} {{/}}"></div>');
        var vm = new DefineMap({
            list: new DefineList([
                'one',
                'two'
            ])
        });
        var frag = template(vm);
        var className = frag.firstChild.className;
        assert.equal(className, 'one two ');
        vm.list.push('three');
        className = frag.firstChild.className;
        assert.equal(className, 'one two three ');
    });
    test('Using #each on a DefineMap', function (assert) {
        var template = stache('{{#each obj}}{{%key}}{{.}}{{/each}}');
        var VM = DefineMap.extend({ seal: false }, {
            foo: 'string',
            bar: 'string'
        });
        var vm = new VM({
            foo: 'bar',
            bar: 'foo'
        });
        vm.set('baz', 'qux');
        var frag = template({ obj: vm });
        var first = frag.firstChild, second = first.nextSibling.nextSibling, third = second.nextSibling.nextSibling;
        assert.equal(first.nodeValue, 'foo');
        assert.equal(first.nextSibling.nodeValue, 'bar');
        assert.equal(second.nodeValue, 'bar');
        assert.equal(second.nextSibling.nodeValue, 'foo');
        assert.equal(third.nodeValue, 'baz');
        assert.equal(third.nextSibling.nodeValue, 'qux');
    });
    QUnit.test('{{%index}} and {{@index}} work with {{#key}} iteration', function () {
        var template = stache('<p>{{#iter}}<span>{{@index}}</span>{{/iter}}</p> ' + '<p>{{#iter}}<span>{{%index}}</span>{{/iter}}</p>');
        var div = document.createElement('div');
        var dom = template({
            iter: new DefineList([
                'hey',
                'there'
            ])
        });
        div.appendChild(dom);
        var span = div.getElementsByTagName('span');
        equal(span[0].innerHTML, '0', 'iteration for @index');
        equal(span[1].innerHTML, '1', 'iteration for %index');
        equal(span[2].innerHTML, '0', 'iteration for %index');
        equal(span[3].innerHTML, '1', 'iteration for %index');
    });
    QUnit.test('iterate a DefineMap with {{#each}} (#can-define/125)', function () {
        var template = stache('<p>{{#each iter}}<span>{{%key}} {{.}}</span>{{/each}}</p>');
        var div = document.createElement('div');
        var dom = template({
            iter: new DefineMap({
                first: 'justin',
                last: 'meyer'
            })
        });
        div.appendChild(dom);
        var span = div.getElementsByTagName('span');
        equal(span[0].innerHTML, 'first justin', 'first');
        equal(span[1].innerHTML, 'last meyer', 'last');
    });
    QUnit.test('Stache with single property', function () {
        var Typer = define.Constructor({ foo: { type: 'string' } });
        var template = stache('{{foo}}');
        var t = new Typer({ foo: 'bar' });
        var frag = template(t);
        equal(frag.firstChild.nodeValue, 'bar');
        t.foo = 'baz';
        equal(frag.firstChild.nodeValue, 'baz');
    });
    QUnit.test('Stache with boolean property with {{#if}}', function () {
        var nailedIt = 'Nailed it';
        var Example = define.Constructor({ name: { value: nailedIt } });
        var NestedMap = define.Constructor({
            isEnabled: { value: true },
            test: { Value: Example },
            examples: {
                type: {
                    one: { Value: Example },
                    two: {
                        type: { deep: { Value: Example } },
                        Value: Object
                    }
                },
                Value: Object
            }
        });
        var nested = new NestedMap();
        var template = stache('{{#if isEnabled}}Enabled{{/if}}');
        var frag = template(nested);
        equal(frag.firstChild.nodeValue, 'Enabled');
    });
    QUnit.test('stache with double property', function () {
        var nailedIt = 'Nailed it';
        var Example = define.Constructor({ name: { value: nailedIt } });
        var NestedMap = define.Constructor({
            isEnabled: { value: true },
            test: { Value: Example },
            examples: {
                type: {
                    one: { Value: Example },
                    two: {
                        type: { deep: { Value: Example } },
                        Value: Object
                    }
                },
                Value: Object
            }
        });
        var nested = new NestedMap();
        var template = stache('{{test.name}}');
        var frag = template(nested);
        equal(frag.firstChild.nodeValue, nailedIt);
    });
    QUnit.test('Stache with one nested property', function () {
        var nailedIt = 'Nailed it';
        var Example = define.Constructor({ name: { value: nailedIt } });
        var NestedMap = define.Constructor({
            isEnabled: { value: true },
            test: { Value: Example },
            examples: {
                type: {
                    one: { Value: Example },
                    two: {
                        type: { deep: { Value: Example } },
                        Value: Object
                    }
                },
                Value: Object
            }
        });
        var nested = new NestedMap();
        var template = stache('{{examples.one.name}}');
        var frag = template(nested);
        equal(frag.firstChild.nodeValue, nailedIt);
    });
    QUnit.test('Stache with two nested property', function () {
        var nailedIt = 'Nailed it';
        var Example = define.Constructor({ name: { value: nailedIt } });
        var NestedMap = define.Constructor({
            isEnabled: { value: true },
            test: { Value: Example },
            examples: {
                type: {
                    one: { Value: Example },
                    two: {
                        type: { deep: { Value: Example } },
                        Value: Object
                    }
                },
                Value: Object
            }
        });
        var nested = new NestedMap();
        var template = stache('{{examples.two.deep.name}}');
        var frag = template(nested);
        equal(frag.firstChild.nodeValue, nailedIt);
    });
    test('list.sort a list of DefineMaps', function () {
        var Account = DefineMap.extend({
            name: 'string',
            amount: 'number',
            slug: {
                serialize: true,
                get: function () {
                    return this.name.toLowerCase().replace(/ /g, '-').replace(/[^\w-]+/g, '');
                }
            }
        });
        Account.List = DefineList.extend({
            '*': Account,
            limit: 'number',
            skip: 'number',
            total: 'number'
        });
        var accounts = new Account.List([
            {
                name: 'Savings',
                amount: 20
            },
            {
                name: 'Checking',
                amount: 103.24
            },
            {
                name: 'Kids Savings',
                amount: 48155.13
            }
        ]);
        accounts.limit = 3;
        var template = stache('{{#each accounts}}{{name}},{{/each}}')({ accounts: accounts });
        equal(template.textContent, 'Savings,Checking,Kids Savings,', 'template rendered properly.');
        accounts.sort(function (a, b) {
            if (a.name < b.name) {
                return -1;
            } else if (a.name > b.name) {
                return 1;
            } else {
                return 0;
            }
        });
        equal(accounts.length, 3);
        equal(template.textContent, 'Checking,Kids Savings,Savings,', 'template updated properly.');
        accounts.sort(function (a, b) {
            if (a.slug < b.slug) {
                return 1;
            } else if (a.slug > b.slug) {
                return -1;
            } else {
                return 0;
            }
        });
        equal(accounts.length, 3);
        equal(accounts.limit, 3, 'expandos still present after sorting/replacing.');
        equal(template.textContent, 'Savings,Kids Savings,Checking,', 'template updated properly.');
    });
});
/*can-deparam@1.0.1#can-deparam*/
define('can-deparam@1.0.1#can-deparam', function (require, exports, module) {
    var namespace = require('can-namespace');
    var digitTest = /^\d+$/, keyBreaker = /([^\[\]]+)|(\[\])/g, paramTest = /([^?#]*)(#.*)?$/, entityRegex = /%([^0-9a-f][0-9a-f]|[0-9a-f][^0-9a-f]|[^0-9a-f][^0-9a-f])/i, prep = function (str) {
            str = str.replace(/\+/g, ' ');
            try {
                return decodeURIComponent(str);
            } catch (e) {
                return decodeURIComponent(str.replace(entityRegex, function (match, hex) {
                    return '%25' + hex;
                }));
            }
        };
    module.exports = namespace.deparam = function (params) {
        var data = {}, pairs, lastPart;
        if (params && paramTest.test(params)) {
            pairs = params.split('&');
            pairs.forEach(function (pair) {
                var parts = pair.split('='), key = prep(parts.shift()), value = prep(parts.join('=')), current = data;
                if (key) {
                    parts = key.match(keyBreaker);
                    for (var j = 0, l = parts.length - 1; j < l; j++) {
                        if (!current[parts[j]]) {
                            current[parts[j]] = digitTest.test(parts[j + 1]) || parts[j + 1] === '[]' ? [] : {};
                        }
                        current = current[parts[j]];
                    }
                    lastPart = parts.pop();
                    if (lastPart === '[]') {
                        current.push(value);
                    } else {
                        current[lastPart] = value;
                    }
                }
            });
        }
        return data;
    };
});
/*can-util@3.9.6#js/diff-object/diff-object*/
define('can-util@3.9.6#js/diff-object/diff-object', function (require, exports, module) {
    'use strict';
    var assign = require('../assign/assign');
    module.exports = exports = function (oldObject, newObject) {
        var oldObjectClone, patches = [];
        oldObjectClone = assign({}, oldObject);
        for (var newProp in newObject) {
            if (!oldObject || !oldObject.hasOwnProperty(newProp)) {
                patches.push({
                    property: newProp,
                    type: 'add',
                    value: newObject[newProp]
                });
            } else if (newObject[newProp] !== oldObject[newProp]) {
                patches.push({
                    property: newProp,
                    type: 'set',
                    value: newObject[newProp]
                });
            }
            delete oldObjectClone[newProp];
        }
        for (var oldProp in oldObjectClone) {
            patches.push({
                property: oldProp,
                type: 'remove'
            });
        }
        return patches;
    };
});
/*can-route@3.2.0#can-route*/
define('can-route@3.2.0#can-route', function (require, exports, module) {
    var canBatch = require('can-event/batch/batch');
    var canEvent = require('can-event');
    var Observation = require('can-observation');
    var compute = require('can-compute');
    var namespace = require('can-namespace');
    var param = require('can-param');
    var deparam = require('can-deparam');
    var each = require('can-util/js/each/each');
    var string = require('can-util/js/string/string');
    var isFunction = require('can-util/js/is-function/is-function');
    var isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');
    var deepAssign = require('can-util/js/deep-assign/deep-assign');
    var isWebWorker = require('can-util/js/is-web-worker/is-web-worker');
    var isBrowserWindow = require('can-util/js/is-browser-window/is-browser-window');
    var makeArray = require('can-util/js/make-array/make-array');
    var assign = require('can-util/js/assign/assign');
    var types = require('can-types');
    var dev = require('can-util/js/dev/dev');
    var diff = require('can-util/js/diff/diff');
    var diffObject = require('can-util/js/diff-object/diff-object');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var curliesMatcher = /\{\s*([\w.]+)\s*\}/g;
    var colonMatcher = /\:([\w.]+)/g;
    var paramsMatcher = /^(?:&[^=]+=[^&]*)+/;
    var makeProps = function (props) {
        var tags = [];
        each(props, function (val, name) {
            tags.push((name === 'className' ? 'class' : name) + '="' + (name === 'href' ? val : string.esc(val)) + '"');
        });
        return tags.join(' ');
    };
    var matchesData = function (route, data) {
        var count = 0, i = 0, defaults = {};
        for (var name in route.defaults) {
            if (route.defaults[name] === data[name]) {
                defaults[name] = 1;
                count++;
            }
        }
        for (; i < route.names.length; i++) {
            if (!data.hasOwnProperty(route.names[i])) {
                return -1;
            }
            if (!defaults[route.names[i]]) {
                count++;
            }
        }
        return count;
    };
    var location = typeof window !== 'undefined' ? window.location : {};
    var wrapQuote = function (str) {
        return (str + '').replace(/([.?*+\^$\[\]\\(){}|\-])/g, '\\$1');
    };
    var attrHelper = function (prop, value) {
        if ('attr' in this) {
            return this.attr.apply(this, arguments);
        } else {
            if (arguments.length > 1) {
                canReflect.setKeyValue(this, prop, value);
                return this;
            } else if (typeof prop === 'object') {
                canReflect.assignDeep(this, prop);
                return this;
            } else if (arguments.length === 1) {
                return canReflect.getKeyValue(this, prop);
            } else {
                return canReflect.unwrap(this);
            }
        }
    };
    var stringify = function (obj) {
        if (obj && typeof obj === 'object') {
            if (obj && typeof obj === 'object' && 'serialize' in obj) {
                obj = obj.serialize();
            } else {
                obj = isFunction(obj.slice) ? obj.slice() : assign({}, obj);
            }
            each(obj, function (val, prop) {
                obj[prop] = stringify(val);
            });
        } else if (obj !== undefined && obj !== null && isFunction(obj.toString)) {
            obj = obj.toString();
        }
        return obj;
    };
    var removeBackslash = function (str) {
        return str.replace(/\\/g, '');
    };
    var timer;
    var curParams;
    var lastHash;
    var changingData;
    var changedAttrs = [];
    var eventsObject = assign({}, canEvent);
    var canRoute = function (url, defaults) {
        var root = canRoute._call('root');
        if (root.lastIndexOf('/') === root.length - 1 && url.indexOf('/') === 0) {
            url = url.substr(1);
        }
        defaults = defaults || {};
        var names = [], res, test = '', matcher, lastIndex, next, querySeparator = canRoute._call('querySeparator'), matchSlashes = canRoute._call('matchSlashes');
        if (colonMatcher.test(url)) {
            matcher = colonMatcher;
        } else {
            matcher = curliesMatcher;
        }
        lastIndex = matcher.lastIndex = 0;
        while (res = matcher.exec(url)) {
            names.push(res[1]);
            test += removeBackslash(url.substring(lastIndex, matcher.lastIndex - res[0].length));
            next = '\\' + (removeBackslash(url.substr(matcher.lastIndex, 1)) || querySeparator + (matchSlashes ? '' : '|/'));
            test += '([^' + next + ']' + (defaults[res[1]] ? '*' : '+') + ')';
            lastIndex = matcher.lastIndex;
        }
        test += url.substr(lastIndex).replace('\\', '');
        canRoute.routes[url] = {
            test: new RegExp('^' + test + '($|' + wrapQuote(querySeparator) + ')'),
            route: url,
            names: names,
            defaults: defaults,
            length: url.split('/').length
        };
        return canRoute;
    };
    var oldProperties = null;
    var onRouteDataChange = function (ev, newProps, oldProps) {
        changingData = 1;
        if (!oldProperties) {
            oldProperties = oldProps;
        }
        clearTimeout(timer);
        timer = setTimeout(function () {
            var old = oldProperties;
            oldProperties = null;
            changingData = 0;
            var serialized = canRoute.data.serialize(), path = canRoute.param(serialized, true);
            canRoute._call('setURL', path, newProps, old);
            canEvent.dispatch.call(eventsObject, '__url', [
                path,
                lastHash
            ]);
            lastHash = path;
            changedAttrs = [];
        }, 10);
    };
    var stringCoercingMapDecorator = function (map) {
        var attrSuper = map.attr;
        map.attr = function (prop, val) {
            var serializable = this.define === undefined || this.define[prop] === undefined || !!this.define[prop].serialize, args;
            if (serializable) {
                args = stringify(Array.apply(null, arguments));
            } else {
                args = arguments;
            }
            return attrSuper.apply(this, args);
        };
        return map;
    };
    var recursiveClean = function (old, cur, data) {
        for (var attr in old) {
            if (cur[attr] === undefined) {
                if ('removeAttr' in data) {
                    data.removeAttr(attr);
                } else {
                    cur[attr] = undefined;
                }
            } else if (Object.prototype.toString.call(old[attr]) === '[object Object]') {
                recursiveClean(old[attr], cur[attr], attrHelper.call(data, attr));
            }
        }
    };
    var matchCheck = function (source, matcher) {
        for (var prop in source) {
            var s = source[prop], m = matcher[prop];
            if (s && m && typeof s === 'object' && typeof matcher === 'object') {
                return matchCheck(s, m);
            }
            if (s != m) {
                return false;
            }
        }
        return true;
    };
    var setState = canRoute.setState = function () {
        var hash = canRoute._call('matchingPartOfURL');
        var oldParams = curParams;
        curParams = canRoute.deparam(hash);
        var matched;
        if (!changingData || hash !== lastHash) {
            canRoute.batch.start();
            recursiveClean(oldParams, curParams, canRoute.data);
            matched = curParams.route;
            delete curParams.route;
            canRoute.matched(matched);
            canRoute.attr(curParams);
            curParams.route = matched;
            canEvent.dispatch.call(eventsObject, '__url', [
                hash,
                lastHash
            ]);
            canRoute.batch.stop();
        }
    };
    var decode = function (str) {
        try {
            return decodeURIComponent(str);
        } catch (ex) {
            return unescape(str);
        }
    };
    assign(canRoute, {
        param: function (data, _setRoute) {
            var route, matches = 0, matchCount, routeName = data.route, propCount = 0, cpy, res, after, matcher;
            delete data.route;
            each(data, function () {
                propCount++;
            });
            each(canRoute.routes, function (temp, name) {
                matchCount = matchesData(temp, data);
                if (matchCount > matches) {
                    route = temp;
                    matches = matchCount;
                }
                if (matchCount >= propCount) {
                    return false;
                }
            });
            if (canRoute.routes[routeName] && matchesData(canRoute.routes[routeName], data) === matches) {
                route = canRoute.routes[routeName];
            }
            if (route) {
                cpy = assign({}, data);
                matcher = colonMatcher.test(route.route) ? colonMatcher : curliesMatcher;
                res = route.route.replace(matcher, function (whole, name) {
                    delete cpy[name];
                    return data[name] === route.defaults[name] ? '' : encodeURIComponent(data[name]);
                }).replace('\\', '');
                each(route.defaults, function (val, name) {
                    if (cpy[name] === val) {
                        delete cpy[name];
                    }
                });
                after = param(cpy);
                if (_setRoute) {
                    canRoute.matched(route.route);
                }
                return res + (after ? canRoute._call('querySeparator') + after : '');
            }
            return isEmptyObject(data) ? '' : canRoute._call('querySeparator') + param(data);
        },
        deparam: function (url) {
            var root = canRoute._call('root');
            if (root.lastIndexOf('/') === root.length - 1 && url.indexOf('/') === 0) {
                url = url.substr(1);
            }
            var route = { length: -1 }, querySeparator = canRoute._call('querySeparator'), paramsMatcher = canRoute._call('paramsMatcher');
            each(canRoute.routes, function (temp, name) {
                if (temp.test.test(url) && temp.length > route.length) {
                    route = temp;
                }
            });
            if (route.length > -1) {
                var parts = url.match(route.test), start = parts.shift(), remainder = url.substr(start.length - (parts[parts.length - 1] === querySeparator ? 1 : 0)), obj = remainder && paramsMatcher.test(remainder) ? deparam(remainder.slice(1)) : {};
                obj = deepAssign(true, {}, route.defaults, obj);
                each(parts, function (part, i) {
                    if (part && part !== querySeparator) {
                        obj[route.names[i]] = decode(part);
                    }
                });
                obj.route = route.route;
                return obj;
            }
            if (url.charAt(0) !== querySeparator) {
                url = querySeparator + url;
            }
            return paramsMatcher.test(url) ? deparam(url.slice(1)) : {};
        },
        map: function (data) {
            canRoute.data = data;
        },
        routes: {},
        ready: function (val) {
            if (val !== true) {
                canRoute._setup();
                if (isBrowserWindow() || isWebWorker()) {
                    canRoute.setState();
                }
            }
            return canRoute;
        },
        url: function (options, merge) {
            if (merge) {
                Observation.add(eventsObject, '__url');
                var baseOptions = canRoute.deparam(canRoute._call('matchingPartOfURL'));
                options = assign(assign({}, baseOptions), options);
            }
            return canRoute._call('root') + canRoute.param(options);
        },
        link: function (name, options, props, merge) {
            return '<a ' + makeProps(assign({ href: canRoute.url(options, merge) }, props)) + '>' + name + '</a>';
        },
        current: function (options, subsetMatch) {
            Observation.add(eventsObject, '__url');
            if (subsetMatch) {
                var baseOptions = canRoute.deparam(canRoute._call('matchingPartOfURL'));
                return matchCheck(options, baseOptions);
            } else {
                return this._call('matchingPartOfURL') === canRoute.param(options);
            }
        },
        bindings: {
            hashchange: {
                paramsMatcher: paramsMatcher,
                querySeparator: '&',
                matchSlashes: false,
                bind: function () {
                    canEvent.on.call(window, 'hashchange', setState);
                },
                unbind: function () {
                    canEvent.on.call(window, 'hashchange', setState);
                },
                matchingPartOfURL: function () {
                    var loc = canRoute.location || location;
                    return loc.href.split(/#!?/)[1] || '';
                },
                setURL: function (path) {
                    if (location.hash !== '#' + path) {
                        location.hash = '!' + path;
                    }
                    return path;
                },
                root: '#!'
            }
        },
        defaultBinding: 'hashchange',
        currentBinding: null,
        _setup: function () {
            if (!canRoute.currentBinding) {
                canRoute._call('bind');
                canRoute.serializedCompute.addEventListener('change', onRouteDataChange);
                canRoute.currentBinding = canRoute.defaultBinding;
            }
        },
        _teardown: function () {
            if (canRoute.currentBinding) {
                canRoute._call('unbind');
                canRoute.serializedCompute.removeEventListener('change', onRouteDataChange);
                canRoute.currentBinding = null;
            }
            clearTimeout(timer);
            changingData = 0;
        },
        _call: function () {
            var args = makeArray(arguments), prop = args.shift(), binding = canRoute.bindings[canRoute.currentBinding || canRoute.defaultBinding], method = binding[prop];
            if (method.apply) {
                return method.apply(binding, args);
            } else {
                return method;
            }
        },
        matched: compute()
    });
    each([
        'addEventListener',
        'removeEventListener',
        'bind',
        'unbind',
        'on',
        'off',
        'delegate',
        'undelegate',
        'removeAttr',
        'compute',
        '_get',
        '___get',
        'each'
    ], function (name) {
        canRoute[name] = function () {
            if (!canRoute.data[name]) {
                return;
            }
            return canRoute.data[name].apply(canRoute.data, arguments);
        };
    });
    var routeData;
    var setRouteData = function (data) {
        routeData = data;
        return routeData;
    };
    var serializedCompute;
    Object.defineProperty(canRoute, 'serializedCompute', {
        get: function () {
            if (!serializedCompute) {
                serializedCompute = compute(function () {
                    return canRoute.data.serialize();
                });
            }
            return serializedCompute;
        }
    });
    Object.defineProperty(canRoute, 'data', {
        get: function () {
            if (routeData) {
                return routeData;
            } else if (types.DefaultMap) {
                if (types.DefaultMap.prototype.toObject) {
                    var DefaultRouteMap = types.DefaultMap.extend({ seal: false }, { '*': 'stringOrObservable' });
                    return setRouteData(new DefaultRouteMap());
                } else {
                    return setRouteData(stringCoercingMapDecorator(new types.DefaultMap()));
                }
            } else {
                throw new Error('can.route.data accessed without being set');
            }
        },
        set: function (data) {
            if (canReflect.isConstructorLike(data)) {
                data = new data();
            }
            if ('attr' in data) {
                setRouteData(stringCoercingMapDecorator(data));
            } else {
                setRouteData(data);
            }
        }
    });
    canRoute.attr = function () {
        return attrHelper.apply(canRoute.data, arguments);
    };
    canRoute.batch = canBatch;
    canReflect.setKeyValue(canRoute, canSymbol.for('can.isFunctionLike'), false);
    module.exports = namespace.route = canRoute;
});
/*can-route@3.2.0#test/mock-route-binding*/
define('can-route@3.2.0#test/mock-route-binding', function (require, exports, module) {
    var canRoute = require('can-route');
    var compute = require('can-compute');
    var routeCompute = compute('');
    canRoute.bindings.mock = {
        paramsMatcher: /^(?:&[^=]+=[^&]*)+/,
        querySeparator: '&',
        matchSlashes: false,
        bind: function () {
            routeCompute.bind('change', canRoute.setState);
        },
        unbind: function () {
            routeCompute.unbind('change', canRoute.setState);
        },
        matchingPartOfURL: function () {
            return routeCompute().split(/#!?/)[1] || '';
        },
        setURL: function (path) {
            if (path[0] !== '#') {
                routeCompute('#' + (path || ''));
            } else {
                routeCompute(path || '');
            }
            return path;
        },
        root: '#!'
    };
    var oldDefault;
    module.exports = {
        start: function () {
            oldDefault = canRoute.defaultBinding;
            canRoute._teardown();
            canRoute.currentBinding = null;
            canRoute.defaultBinding = 'mock';
            routeCompute('');
        },
        stop: function () {
            canRoute._teardown();
            canRoute.defaultBinding = oldDefault;
        },
        hash: routeCompute
    };
});
/*can-stache@3.2.0#helpers/route*/
define('can-stache@3.2.0#helpers/route', function (require, exports, module) {
    var helpers = require('./core');
    var route = require('can-route');
    var getLast = require('can-util/js/last/last');
    var stacheExpression = require('../src/expression');
    var each = require('can-util/js/each/each');
    var looksLikeOptions = helpers.looksLikeOptions;
    var calculateArgs = function () {
        var finalParams, finalMerge, optionsArg;
        each(arguments, function (arg) {
            if (typeof arg === 'boolean') {
                finalMerge = arg;
            } else if (arg && typeof arg === 'object') {
                if (!looksLikeOptions(arg)) {
                    finalParams = helpers.resolveHash(arg);
                } else {
                    optionsArg = arg;
                }
            }
        });
        if (!finalParams && optionsArg) {
            finalParams = helpers.resolveHash(optionsArg.hash);
        }
        return {
            finalParams: finalParams || {},
            finalMerge: finalMerge,
            optionsArg: optionsArg
        };
    };
    helpers.registerHelper('routeUrl', function () {
        var args = calculateArgs.apply(this, arguments);
        return route.url(args.finalParams, typeof args.finalMerge === 'boolean' ? args.finalMerge : undefined);
    });
    var routeCurrent = function () {
        var args = calculateArgs.apply(this, arguments);
        var result = route.current(args.finalParams, typeof args.finalMerge === 'boolean' ? args.finalMerge : undefined);
        if (args.optionsArg && !(args.optionsArg instanceof stacheExpression.Call)) {
            if (result) {
                return args.optionsArg.fn();
            } else {
                return args.optionsArg.inverse();
            }
        } else {
            return result;
        }
    };
    routeCurrent.callAsMethod = true;
    helpers.registerHelper('routeCurrent', routeCurrent);
});
/*can-stache@3.2.0#helpers/route-test*/
define('can-stache@3.2.0#helpers/route-test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var stache = require('can-stache');
    var route = require('can-route');
    var mockRoute = require('can-route/test/mock-route-binding');
    var CanMap = require('can-map');
    require('./route');
    QUnit.module('can-stache/helpers/route');
    QUnit.test('routeUrl and routeCurrent', function () {
        stop();
        mockRoute.start();
        var routeData = new CanMap({});
        route.data = routeData;
        route.ready();
        var template = stache('<a href="{{routeUrl page=\'recipe\' id=recipe.id}}">{{recipe.name}}</a>');
        var frag = template({
            recipe: new CanMap({
                id: 5,
                name: 'Cool recipe'
            })
        });
        QUnit.equal(frag.firstChild.getAttribute('href'), '#!&page=recipe&id=5', 'href set');
        template = stache('<a href="{{routeUrl(page=\'recipe\' id=recipe.id}}">{{recipe.name}}</a>');
        frag = template({
            recipe: new CanMap({
                id: 5,
                name: 'Cool recipe'
            })
        });
        QUnit.equal(frag.firstChild.getAttribute('href'), '#!&page=recipe&id=5', 'href set');
        template = stache('{{#routeCurrent(undefined)}}yes{{else}}no{{/routeCurrent}}');
        frag = template({});
        QUnit.equal(frag.firstChild.nodeValue, 'yes', 'route is current');
        template = stache('{{#routeCurrent()}}yes{{else}}no{{/routeCurrent}}');
        frag = template({});
        QUnit.equal(frag.firstChild.nodeValue, 'yes', 'route is current');
        route.attr({
            'foo': 'bar',
            page: 'recipes'
        });
        setTimeout(function () {
            template = stache('{{#routeCurrent()}}yes{{else}}no{{/routeCurrent}}');
            frag = template({});
            QUnit.equal(frag.firstChild.nodeValue, 'no', 'route is not current');
            template = stache('{{#routeCurrent(foo=\'bar\', true)}}yes{{else}}no{{/routeCurrent}}');
            frag = template({});
            QUnit.equal(frag.firstChild.nodeValue, 'yes', 'route is somewhat current');
            template = stache('{{#routeCurrent foo=\'bar\' true}}yes{{else}}no{{/routeCurrent}}');
            frag = template({});
            QUnit.equal(frag.firstChild.nodeValue, 'yes', 'route is somewhat current');
            template = stache('<a href="{{routeUrl page=\'recipes\' id=6 true}}"></a>');
            frag = template({});
            QUnit.equal(frag.firstChild.getAttribute('href'), '#!&foo=bar&page=recipes&id=6', 'merge works helper');
            template = stache('<a href="{{routeUrl(page=\'recipe\' id=5,true)}}"></a>');
            frag = template({});
            QUnit.equal(frag.firstChild.getAttribute('href'), '#!&foo=bar&page=recipe&id=5', 'merge works call expression');
            mockRoute.stop();
            start();
        }, 100);
    });
});
/*can-stache@3.2.0#test/stache-test*/
define('can-stache@3.2.0#test/stache-test', function (require, exports, module) {
    (function (global) {
        require('./expression-test');
        require('./stache-define-test');
        require('../helpers/route-test');
        var stache = require('can-stache');
        var QUnit = require('steal-qunit');
        var CanMap = require('can-map');
        var CanList = require('can-list');
        var canCompute = require('can-compute');
        var DefineMap = require('can-define/map/map');
        var viewCallbacks = require('can-view-callbacks');
        var Scope = require('can-view-scope');
        var parser = require('can-view-parser');
        var nodeLists = require('can-view-nodelist');
        var canBatch = require('can-event/batch/batch');
        var makeDocument = require('can-vdom/make-document/make-document');
        var getChildNodes = require('can-util/dom/child-nodes/child-nodes');
        var domData = require('can-util/dom/data/data');
        var domMutate = require('can-util/dom/mutate/mutate');
        var DOCUMENT = require('can-util/dom/document/document');
        var MUTATION_OBSERVER = require('can-util/dom/mutation-observer/mutation-observer');
        var canEach = require('can-util/js/each/each');
        var canDev = require('can-util/js/dev/dev');
        var string = require('can-util/js/string/string');
        var makeArray = require('can-util/js/make-array/make-array');
        var joinURIs = require('can-util/js/join-uris/join-uris');
        var getBaseURL = require('can-util/js/base-url/base-url');
        var browserDoc = DOCUMENT();
        var mutationObserver = MUTATION_OBSERVER();
        makeTest('can/view/stache dom', browserDoc);
        makeTest('can/view/stache vdom', makeDocument());
        function makeTest(name, doc, mutation) {
            var isNormalDOM = doc === window.document;
            var innerHTML = function (node) {
                return 'innerHTML' in node ? node.innerHTML : undefined;
            };
            var getValue = function (node) {
                if (node.nodeName.toLowerCase() === 'textarea') {
                    return innerHTML(node);
                } else {
                    return node.value;
                }
            };
            var empty = function (node) {
                var last = node.lastChild;
                while (last) {
                    node.removeChild(last);
                    last = node.lastChild;
                }
            };
            var getText = function (template, data, options) {
                    var div = doc.createElement('div');
                    div.appendChild(stache(template)(data, options));
                    return cleanHTMLTextForIE(innerHTML(div));
                }, getAttr = function (el, attrName) {
                    return attrName === 'class' ? el.className : el.getAttribute(attrName);
                }, cleanHTMLTextForIE = function (html) {
                    return html.replace(/ stache_0\.\d+="[^"]+"/g, '').replace(/<(\/?[-A-Za-z0-9_]+)/g, function (whole, tagName) {
                        return '<' + tagName.toLowerCase();
                    }).replace(/\r?\n/g, '');
                }, getTextFromFrag = function (node) {
                    var txt = '';
                    node = node.firstChild;
                    while (node) {
                        if (node.nodeType === 3) {
                            txt += node.nodeValue;
                        } else {
                            txt += getTextFromFrag(node);
                        }
                        node = node.nextSibling;
                    }
                    return txt;
                };
            var oldDoc;
            QUnit.module(name, {
                setup: function () {
                    if (doc === window.document) {
                        DOCUMENT(null);
                        MUTATION_OBSERVER(mutationObserver);
                    } else {
                        oldDoc = window.document;
                        DOCUMENT(doc);
                        MUTATION_OBSERVER(null);
                    }
                    this.fixture = doc.createElement('div');
                    doc.body.appendChild(this.fixture);
                    this.animals = [
                        'sloth',
                        'bear',
                        'monkey'
                    ];
                },
                teardown: function () {
                    doc.body.removeChild(this.fixture);
                    stop();
                    setTimeout(function () {
                        DOCUMENT(window.document);
                        MUTATION_OBSERVER(mutationObserver);
                        start();
                    }, 1);
                }
            });
            test('html to html', function () {
                var stashed = stache('<h1 class=\'foo\'><span>Hello World!</span></h1>');
                var frag = stashed();
                equal(innerHTML(frag.childNodes.item(0)).toLowerCase(), '<span>hello world!</span>', 'got back the right text');
            });
            test('basic replacement', function () {
                var stashed = stache('<h1 class=\'foo\'><span>Hello {{message}}!</span></h1>');
                var frag = stashed({ message: 'World' });
                equal(innerHTML(frag.firstChild).toLowerCase(), '<span>hello world!</span>', 'got back the right text');
            });
            test('a section helper', function () {
                stache.registerHelper('helper', function (options) {
                    return options.fn({ message: 'World' });
                });
                var stashed = stache('<h1 class=\'foo\'>{{#helper}}<span>Hello {{message}}!</span>{{/helper}}</h1>');
                var frag = stashed({});
                equal(frag.firstChild.firstChild.nodeName.toLowerCase(), 'span', 'got a span');
                equal(innerHTML(frag.firstChild.firstChild), 'Hello World!', 'got back the right text');
            });
            if (System.env.indexOf('production') < 0) {
                test('helpers warn on overwrite (canjs/can-stache-converters#24)', function () {
                    var oldWarn = canDev.warn;
                    canDev.warn = function () {
                        ok(true, 'received warning');
                    };
                    stache.registerHelper('foobar', function () {
                    });
                    stache.registerHelper('foobar', function () {
                    });
                    canDev.warn = oldWarn;
                });
            }
            test('attributes sections', function () {
                var template = stache('<div {{attributes}}/>');
                var frag = template({ attributes: 'foo=\'bar\'' });
                equal(frag.firstChild.getAttribute('foo'), 'bar', 'set attribute');
                template = stache('<div {{#truthy}}foo=\'{{baz}}\'{{/truthy}}/>');
                frag = template({
                    truthy: true,
                    baz: 'bar'
                });
                equal(frag.firstChild.getAttribute('foo'), 'bar', 'set attribute');
                frag = template({
                    truthy: false,
                    baz: 'bar'
                });
                equal(frag.firstChild.getAttribute('foo'), null, 'attribute not set if not truthy');
            });
            test('boxes example', function () {
                var boxes = [], Box = CanMap.extend({
                        count: 0,
                        content: 0,
                        top: 0,
                        left: 0,
                        color: 0,
                        tick: function () {
                            var count = this.attr('count') + 1;
                            this.attr({
                                count: count,
                                left: Math.cos(count / 10) * 10,
                                top: Math.sin(count / 10) * 10,
                                color: count % 255,
                                content: count
                            });
                        }
                    });
                for (var i = 0; i < 1; i++) {
                    boxes.push(new Box({ number: i }));
                }
                var stashed = stache('<div class=\'box-view\'>' + '<div class=\'box\' style=\'top: {{top}}px; left: {{left}}px;\'>' + '</div>' + '</div>');
                var frag = stashed(boxes[0]);
                ok(/top: 0px/.test(frag.firstChild.firstChild.getAttribute('style')), '0px');
                boxes[0].tick();
                ok(!/top: 0px/.test(frag.firstChild.firstChild.getAttribute('style')), '!0px');
            });
            var override = {
                comments: {
                    'Standalone Without Newline': '!',
                    'Standalone Line Endings': '|\n|'
                },
                interpolation: {
                    'HTML Escaping': 'These characters should be HTML escaped: & " < >\n',
                    'Triple Mustache': 'These characters should not be HTML escaped: & " < >\n',
                    'Ampersand': 'These characters should not be HTML escaped: & " < >\n'
                },
                inverted: {
                    'Standalone Line Endings': '|\n\n|',
                    'Standalone Without Newline': '^\n/'
                },
                partials: {
                    'Standalone Line Endings': '|\n>\n|',
                    'Standalone Without Newline': '>\n  >\n>',
                    'Standalone Without Previous Line': '  >\n>\n>',
                    'Standalone Indentation': '\\\n |\n<\n->\n|\n\n/\n'
                },
                sections: {
                    'Standalone Line Endings': '|\n\n|',
                    'Standalone Without Newline': '#\n/'
                }
            };
            canEach(window.MUSTACHE_SPECS, function (specData) {
                var spec = specData.name;
                canEach(specData.data.tests, function (t) {
                    test('specs/' + spec + ' - ' + t.name + ': ' + t.desc, function () {
                        var expected = override[spec] && override[spec][t.name] || t.expected.replace(/&quot;/g, '"');
                        if (spec === 'partials' && t.name === 'Recursion') {
                            t.partials.node = t.partials.node.replace(/</g, '[').replace(/\}>/g, '}]');
                            expected = expected.replace(/</g, '[').replace(/>/g, ']');
                        } else if (spec === 'partials') {
                        }
                        if (t.partials) {
                            for (var name in t.partials) {
                                stache.registerPartial(name, t.partials[name]);
                            }
                        }
                        if (t.data.lambda && t.data.lambda.js) {
                            t.data.lambda = eval('(' + t.data.lambda.js + ')');
                        }
                        var res = stache(t.template)(t.data);
                        deepEqual(getTextFromFrag(res), expected);
                    });
                });
            });
            test('Tokens returning 0 where they should display the number', function () {
                var template = '<div id=\'zero\'>{{completed}}</div>';
                var frag = stache(template)({ completed: 0 });
                equal(frag.firstChild.firstChild.nodeValue, '0', 'zero shown');
            });
            test('Inverted section function returning numbers', function () {
                var template = '<div id=\'completed\'>{{^todos.completed}}hidden{{/todos.completed}}</div>';
                var obsvr = new CanMap({ named: false });
                var todos = {
                    completed: function () {
                        return obsvr.attr('named');
                    }
                };
                var frag = stache(template)({ todos: todos });
                deepEqual(frag.firstChild.firstChild.nodeValue, 'hidden', 'hidden shown');
                obsvr.attr('named', true);
                deepEqual(frag.firstChild.firstChild.nodeValue, '', 'hidden gone');
            });
            test('live-binding with escaping', function () {
                var template = '<span id=\'binder1\'>{{ name }}</span><span id=\'binder2\'>{{{name}}}</span>';
                var teacher = new CanMap({ name: '<strong>Mrs Peters</strong>' });
                var tpl = stache(template);
                var frag = tpl(teacher);
                deepEqual(innerHTML(frag.firstChild), '&lt;strong&gt;Mrs Peters&lt;/strong&gt;');
                deepEqual(innerHTML(frag.lastChild.firstChild), 'Mrs Peters');
                teacher.attr('name', '<i>Mr Scott</i>');
                deepEqual(innerHTML(frag.firstChild), '&lt;i&gt;Mr Scott&lt;/i&gt;');
                deepEqual(innerHTML(frag.lastChild.firstChild), 'Mr Scott');
            });
            test('truthy', function () {
                var t = {
                    template: '{{#name}}Do something, {{name}}!{{/name}}',
                    expected: 'Do something, Andy!',
                    data: { name: 'Andy' }
                };
                var expected = t.expected.replace(/&quot;/g, '&#34;').replace(/\r\n/g, '\n');
                deepEqual(getText(t.template, t.data), expected);
            });
            test('falsey', function () {
                var t = {
                    template: '{{^cannot}}Don\'t do it, {{name}}!{{/cannot}}',
                    expected: 'Don\'t do it, Andy!',
                    data: { name: 'Andy' }
                };
                var expected = t.expected.replace(/&quot;/g, '&#34;').replace(/\r\n/g, '\n');
                deepEqual(getText(t.template, t.data), expected);
            });
            test('Handlebars helpers', function () {
                stache.registerHelper('hello', function (options) {
                    return 'Should not hit this';
                });
                stache.registerHelper('there', function (options) {
                    return 'there';
                });
                stache.registerHelper('zero', function (options) {
                    return 0;
                });
                stache.registerHelper('bark', function (obj, str, number, options) {
                    var hash = options.hash || {};
                    return 'The ' + obj + ' barked at ' + str + ' ' + number + ' times, ' + 'then the ' + hash.obj + ' ' + hash.action + ' ' + hash.where + ' times' + (hash.loud === true ? ' loudly' : '') + '.';
                });
                var t = {
                    template: '{{hello}} {{there}}! {{bark name \'Austin and Andy\' 3 obj=name action=\'growled and snarled\' where=2 loud=true}} Then there were {{zero}} barks :(',
                    expected: 'Hello there! The dog barked at Austin and Andy 3 times, then the dog growled and snarled 2 times loudly. Then there were 0 barks :(',
                    data: {
                        name: 'dog',
                        hello: 'Hello'
                    }
                };
                var expected = t.expected.replace(/&quot;/g, '&#34;').replace(/\r\n/g, '\n');
                deepEqual(getText(t.template, t.data), expected);
            });
            test('Handlebars advanced helpers (from docs)', function () {
                stache.registerSimpleHelper('exercise', function (group, action, num, options) {
                    if (group && group.length > 0 && action && num > 0) {
                        return options.fn({
                            group: group,
                            action: action,
                            where: options.hash.where,
                            when: options.hash.when,
                            num: num
                        });
                    } else {
                        return options.inverse(this);
                    }
                });
                var t = {
                    template: '{{#exercise pets \'walked\' 3 where=\'around the block\' when=time}}' + 'Along with the {{#group}}{{.}}, {{/group}}' + 'we {{action}} {{where}} {{num}} times {{when}}.' + '{{else}}' + 'We were lazy today.' + '{{/exercise}}',
                    expected: 'Along with the cat, dog, parrot, we walked around the block 3 times this morning.',
                    expected2: 'We were lazy today.',
                    data: {
                        pets: [
                            'cat',
                            'dog',
                            'parrot'
                        ],
                        time: 'this morning'
                    }
                };
                var template = stache(t.template);
                var frag = template(t.data);
                var div = doc.createElement('div');
                div.appendChild(frag);
                equal(innerHTML(div), t.expected);
                equal(getText(t.template, {}), t.expected2);
            });
            test('Passing functions as data, then executing them', function () {
                var t = {
                    template: '{{#nested}}{{welcome name}}{{/nested}}',
                    expected: 'Welcome Andy!',
                    data: {
                        name: 'Andy',
                        nested: {
                            welcome: function (name) {
                                return 'Welcome ' + name + '!';
                            }
                        }
                    }
                };
                var expected = t.expected.replace(/&quot;/g, '&#34;').replace(/\r\n/g, '\n');
                deepEqual(getText(t.template, t.data), expected);
            });
            test('No arguments passed to helper', function () {
                var template = stache('{{noargHelper}}');
                stache.registerHelper('noargHelper', function () {
                    return 'foo';
                });
                var div1 = doc.createElement('div');
                var div2 = doc.createElement('div');
                div1.appendChild(template({}));
                div2.appendChild(template(new CanMap()));
                deepEqual(innerHTML(div1), 'foo');
                deepEqual(innerHTML(div2), 'foo');
            });
            test('String literals passed to helper should work (#1143)', 1, function () {
                stache.registerHelper('concatStrings', function (arg1, arg2) {
                    return arg1 + arg2;
                });
                var template = stache('{{concatStrings "==" "word"}}');
                var div = doc.createElement('div');
                div.appendChild(template({}));
                equal(innerHTML(div), '==word');
            });
            test('No arguments passed to helper with list', function () {
                var template = stache('{{#items}}{{noargHelper}}{{/items}}');
                var div = doc.createElement('div');
                div.appendChild(template({ items: new CanList([{ name: 'Brian' }]) }, {
                    noargHelper: function () {
                        return 'foo';
                    }
                }));
                deepEqual(innerHTML(div), 'foo');
            });
            if (isNormalDOM) {
                test('Partials and observes', function () {
                    var template;
                    var div = doc.createElement('div');
                    template = stache('<table><thead><tr>{{#data}}{{>list}}{{/data}}</tr></thead></table>');
                    var dom = template({
                        data: new CanMap({
                            list: [
                                'hi',
                                'there'
                            ]
                        })
                    }, { partials: { list: stache('{{#list}}<th>{{.}}</th>{{/list}}') } });
                    div.appendChild(dom);
                    var ths = div.getElementsByTagName('th');
                    equal(ths.length, 2, 'Got two table headings');
                    equal(innerHTML(ths[0]), 'hi', 'First column heading correct');
                    equal(innerHTML(ths[1]), 'there', 'Second column heading correct');
                });
            }
            test('Deeply nested partials', function () {
                var t = {
                    template: '{{#nest1}}{{#nest2}}{{>partial}}{{/nest2}}{{/nest1}}',
                    expected: 'Hello!',
                    partials: { partial: stache('{{#nest3}}{{name}}{{/nest3}}') },
                    data: { nest1: { nest2: { nest3: { name: 'Hello!' } } } }
                };
                deepEqual(getText(t.template, t.data, { partials: t.partials }), t.expected);
            });
            test('Partials correctly set context', function () {
                var t = {
                    template: '{{#users}}{{>partial}}{{/users}}',
                    expected: 'foo - bar',
                    partials: { partial: stache('{{ name }} - {{ company }}') },
                    data: {
                        users: [{ name: 'foo' }],
                        company: 'bar'
                    }
                };
                deepEqual(getText(t.template, t.data, { partials: t.partials }), t.expected);
            });
            test('Handlebars helper: if/else', function () {
                var expected;
                var t = {
                    template: '{{#if name}}{{name}}{{/if}}{{#if missing}} is missing!{{/if}}',
                    expected: 'Andy',
                    data: {
                        name: 'Andy',
                        missing: undefined
                    }
                };
                expected = t.expected.replace(/&quot;/g, '&#34;').replace(/\r\n/g, '\n');
                deepEqual(getText(t.template, t.data), expected);
                t.data.missing = null;
                expected = t.expected.replace(/&quot;/g, '&#34;').replace(/\r\n/g, '\n');
                deepEqual(getText(t.template, t.data), expected);
            });
            test('Handlebars helper: is/else (with \'eq\' alias)', function () {
                var expected;
                var t = {
                    template: '{{#eq ducks tenDucks "10"}}10 ducks{{else}}Not 10 ducks{{/eq}}',
                    expected: '10 ducks',
                    data: {
                        ducks: '10',
                        tenDucks: function () {
                            return '10';
                        }
                    },
                    liveData: new CanMap({
                        ducks: '10',
                        tenDucks: function () {
                            return '10';
                        }
                    })
                };
                expected = t.expected.replace(/&quot;/g, '&#34;').replace(/\r\n/g, '\n');
                deepEqual(getText(t.template, t.data), expected);
                deepEqual(getText(t.template, t.liveData), expected);
                t.data.ducks = 5;
                deepEqual(getText(t.template, t.data), 'Not 10 ducks');
            });
            test('Handlebars helper: unless', function () {
                var t = {
                    template: '{{#unless missing}}Andy is missing!{{/unless}}' + '{{#unless isCool}} But he wasn\'t cool anyways.{{/unless}}',
                    expected: 'Andy is missing! But he wasn\'t cool anyways.',
                    data: { name: 'Andy' },
                    liveData: new CanMap({
                        name: 'Andy',
                        isCool: canCompute(function () {
                            return t.liveData.attr('missing');
                        })
                    })
                };
                var expected = t.expected.replace(/&quot;/g, '&#34;').replace(/\r\n/g, '\n');
                deepEqual(getText(t.template, t.data), expected);
                var div = doc.createElement('div');
                div.appendChild(stache(t.template)(t.liveData));
                deepEqual(innerHTML(div), expected, '#unless condition false');
                t.liveData.attr('missing', true);
                deepEqual(innerHTML(div), '', '#unless condition true');
            });
            test('Handlebars helper: each', function () {
                var t = {
                    template: '{{#each names}}{{this}} {{/each}}',
                    expected: 'Andy Austin Justin ',
                    data: {
                        names: [
                            'Andy',
                            'Austin',
                            'Justin'
                        ]
                    },
                    data2: {
                        names: new CanList([
                            'Andy',
                            'Austin',
                            'Justin'
                        ])
                    }
                };
                var expected = t.expected.replace(/&quot;/g, '&#34;').replace(/\r\n/g, '\n');
                deepEqual(getText(t.template, t.data), expected);
                var div = doc.createElement('div');
                div.appendChild(stache(t.template)(t.data2));
                deepEqual(innerHTML(div), expected, 'Using Observe.List');
                t.data2.names.push('What');
            });
            test('Handlebars helper: with', function () {
                var t = {
                    template: '{{#with person}}{{name}}{{/with}}',
                    expected: 'Andy',
                    data: { person: { name: 'Andy' } }
                };
                var expected = t.expected.replace(/&quot;/g, '&#34;').replace(/\r\n/g, '\n');
                deepEqual(getText(t.template, t.data), expected);
            });
            test('render with double angle', function () {
                var text = '{{& replace_me }}{{{ replace_me_too }}}' + '<ul>{{#animals}}' + '<li>{{.}}</li>' + '{{/animals}}</ul>';
                var compiled = getText(text, { animals: this.animals });
                equal(compiled, '<ul><li>sloth</li><li>bear</li><li>monkey</li></ul>', 'works');
            });
            test('comments', function () {
                var text = '{{! replace_me }}' + '<ul>{{#animals}}' + '<li>{{.}}</li>' + '{{/animals}}</ul>';
                var compiled = getText(text, { animals: this.animals });
                equal(compiled, '<ul><li>sloth</li><li>bear</li><li>monkey</li></ul>');
            });
            test('multi line', function () {
                var text = 'a \n b \n c';
                equal(getTextFromFrag(stache(text)({})), text);
            });
            test('multi line elements', function () {
                var text = '<div\n class="{{myClass}}" />', result = stache(text)({ myClass: 'a' });
                equal(result.firstChild.className, 'a', 'class name is right');
            });
            test('escapedContent', function () {
                var text = '<span>{{ tags }}</span><label>&amp;</label><strong>{{ number }}</strong><input value=\'{{ quotes }}\'/>';
                var div = doc.createElement('div');
                div.appendChild(stache(text)({
                    tags: 'foo < bar < car > zar > poo',
                    quotes: 'I use \'quote\' fingers & &amp;ersands "a lot"',
                    number: 123
                }));
                equal(div.getElementsByTagName('span')[0].firstChild.nodeValue, 'foo < bar < car > zar > poo');
                equal(div.getElementsByTagName('strong')[0].firstChild.nodeValue, 123);
                equal(div.getElementsByTagName('input')[0].value, 'I use \'quote\' fingers & &amp;ersands "a lot"', 'attributes are always safe, and strings are kept as-is without additional escaping');
                equal(innerHTML(div.getElementsByTagName('label')[0]), '&amp;', 'text-based html entities work fine');
            });
            test('unescapedContent', function () {
                var text = '<span>{{{ tags }}}</span><div>{{{ tags }}}</div><input value=\'{{{ quotes }}}\'/>';
                var div = doc.createElement('div');
                div.appendChild(stache(text)({
                    tags: '<strong>foo</strong><strong>bar</strong>',
                    quotes: 'I use \'quote\' fingers "a lot"'
                }));
                equal(div.getElementsByTagName('span')[0].firstChild.nodeType, 1, '');
                equal(innerHTML(div.getElementsByTagName('div')[0]).toLowerCase(), '<strong>foo</strong><strong>bar</strong>');
                equal(innerHTML(div.getElementsByTagName('span')[0]).toLowerCase(), '<strong>foo</strong><strong>bar</strong>');
                equal(div.getElementsByTagName('input')[0].value, 'I use \'quote\' fingers "a lot"', 'escaped no matter what');
            });
            test('attribute single unescaped, html single unescaped', function () {
                var text = '<div id=\'me\' class=\'{{#task.completed}}complete{{/task.completed}}\'>{{ task.name }}</div>';
                var task = new CanMap({ name: 'dishes' });
                var div = doc.createElement('div');
                div.appendChild(stache(text)({ task: task }));
                equal(innerHTML(div.getElementsByTagName('div')[0]), 'dishes', 'html correctly dishes');
                equal(div.getElementsByTagName('div')[0].className, '', 'class empty');
                task.attr('name', 'lawn');
                equal(innerHTML(div.getElementsByTagName('div')[0]), 'lawn', 'html correctly lawn');
                equal(div.getElementsByTagName('div')[0].className, '', 'class empty');
                task.attr('completed', true);
                equal(div.getElementsByTagName('div')[0].className, 'complete', 'class changed to complete');
            });
            test('select live binding', function () {
                var text = '<select>{{ #todos }}<option>{{ name }}</option>{{ /todos }}</select>';
                var todos, div;
                todos = new CanList([{
                        id: 1,
                        name: 'Dishes'
                    }]);
                div = doc.createElement('div');
                div.appendChild(stache(text)({ todos: todos }));
                equal(div.getElementsByTagName('option').length, 1, '1 item in list');
                todos.push({
                    id: 2,
                    name: 'Laundry'
                });
                equal(div.getElementsByTagName('option').length, 2, '2 items in list');
                todos.splice(0, 2);
                equal(div.getElementsByTagName('option').length, 0, '0 items in list');
            });
            test('multiple hookups in a single attribute', function () {
                var text = '<div class=\'{{ obs.foo }}' + '{{ obs.bar }}{{ obs.baz }}{{ obs.nest.what }}\'></div>';
                var obs = new CanMap({
                    foo: 'a',
                    bar: 'b',
                    baz: 'c',
                    nest: new CanMap({ what: 'd' })
                });
                var div = doc.createElement('div');
                div.appendChild(stache(text)({ obs: obs }));
                var innerDiv = div.firstChild;
                equal(getAttr(innerDiv, 'class'), 'abcd', 'initial render');
                obs.attr('bar', 'e');
                equal(getAttr(innerDiv, 'class'), 'aecd', 'initial render');
                obs.attr('bar', 'f');
                equal(getAttr(innerDiv, 'class'), 'afcd', 'initial render');
                obs.nest.attr('what', 'g');
                equal(getAttr(innerDiv, 'class'), 'afcg', 'nested observe');
            });
            test('adding and removing multiple html content within a single element', function () {
                var text, obs;
                text = '<div>{{ obs.a }}{{ obs.b }}{{ obs.c }}</div>';
                obs = new CanMap({
                    a: 'a',
                    b: 'b',
                    c: 'c'
                });
                var div = doc.createElement('div');
                div.appendChild(stache(text)({ obs: obs }));
                equal(innerHTML(div.firstChild), 'abc', 'initial render');
                obs.attr({
                    a: '',
                    b: '',
                    c: ''
                });
                equal(innerHTML(div.firstChild), '', 'updated values');
                obs.attr({ c: 'c' });
                equal(innerHTML(div.firstChild), 'c', 'updated values');
            });
            test('live binding and removeAttr', function () {
                var text = '{{ #obs.show }}' + '<p {{ obs.attributes }} class="{{ obs.className }}"><span>{{ obs.message }}</span></p>' + '{{ /obs.show }}', obs = new CanMap({
                        show: true,
                        className: 'myMessage',
                        attributes: 'some="myText"',
                        message: 'Live long and prosper'
                    }), div = doc.createElement('div');
                div.appendChild(stache(text)({ obs: obs }));
                var p = div.getElementsByTagName('p')[0], span = p.getElementsByTagName('span')[0];
                equal(p.getAttribute('some'), 'myText', 'initial render attr');
                equal(getAttr(p, 'class'), 'myMessage', 'initial render class');
                equal(innerHTML(span), 'Live long and prosper', 'initial render innerHTML');
                obs.removeAttr('className');
                equal(getAttr(p, 'class'), '', 'class is undefined');
                obs.attr('className', 'newClass');
                equal(getAttr(p, 'class'), 'newClass', 'class updated');
                obs.removeAttr('attributes');
                equal(p.getAttribute('some'), null, 'attribute is undefined');
                obs.attr('attributes', 'some="newText"');
                equal(p.getAttribute('some'), 'newText', 'attribute updated');
                obs.removeAttr('message');
                equal(innerHTML(span), '', 'text node value is empty');
                obs.attr('message', 'Warp drive, Mr. Sulu');
                equal(innerHTML(span), 'Warp drive, Mr. Sulu', 'text node updated');
                obs.removeAttr('show');
                equal(innerHTML(div), '', 'value in block statement is undefined');
                obs.attr('show', true);
                p = div.getElementsByTagName('p')[0];
                span = p.getElementsByTagName('span')[0];
                equal(p.getAttribute('some'), 'newText', 'value in block statement updated attr');
                equal(getAttr(p, 'class'), 'newClass', 'value in block statement updated class');
                equal(innerHTML(span), 'Warp drive, Mr. Sulu', 'value in block statement updated innerHTML');
            });
            test('hookup within a tag', function () {
                var text = '<div {{ obs.foo }} ' + '{{ obs.baz }}>lorem ipsum</div>', obs = new CanMap({
                        foo: 'class="a"',
                        baz: 'some=\'property\''
                    }), compiled = stache(text)({ obs: obs });
                var div = doc.createElement('div');
                div.appendChild(compiled);
                var anchor = div.getElementsByTagName('div')[0];
                equal(getAttr(anchor, 'class'), 'a');
                equal(anchor.getAttribute('some'), 'property');
                obs.attr('foo', 'class="b"');
                equal(getAttr(anchor, 'class'), 'b');
                equal(anchor.getAttribute('some'), 'property');
                obs.attr('baz', 'some=\'new property\'');
                equal(getAttr(anchor, 'class'), 'b');
                equal(anchor.getAttribute('some'), 'new property');
                obs.attr('foo', 'class=""');
                obs.attr('baz', '');
                equal(getAttr(anchor, 'class'), '', 'anchor class blank');
                equal(anchor.getAttribute('some'), undefined, 'attribute "some" is undefined');
            });
            test('single escaped tag, removeAttr', function () {
                var text = '<div {{ obs.foo }}>lorem ipsum</div>', obs = new CanMap({ foo: 'data-bar="john doe\'s bar"' }), compiled = stache(text)({ obs: obs });
                var div = doc.createElement('div');
                div.appendChild(compiled);
                var anchor = div.getElementsByTagName('div')[0];
                equal(anchor.getAttribute('data-bar'), 'john doe\'s bar');
                obs.removeAttr('foo');
                equal(anchor.getAttribute('data-bar'), null);
                obs.attr('foo', 'data-bar="baz"');
                equal(anchor.getAttribute('data-bar'), 'baz');
            });
            test('html comments', function () {
                var text = '<!-- bind to changes in the todo list --> <div>{{obs.foo}}</div>';
                var obs = new CanMap({ foo: 'foo' });
                var compiled = stache(text)({ obs: obs });
                var div = doc.createElement('div');
                div.appendChild(compiled);
                equal(innerHTML(div.getElementsByTagName('div')[0]), 'foo', 'Element as expected');
            });
            test('hookup and live binding', function () {
                var text = '<div class=\'{{ task.completed }}\' {{ data \'task\' task }}>' + '{{ task.name }}' + '</div>', task = new CanMap({
                        completed: false,
                        className: 'someTask',
                        name: 'My Name'
                    }), compiled = stache(text)({ task: task }), div = doc.createElement('div');
                div.appendChild(compiled);
                var child = div.getElementsByTagName('div')[0];
                ok(child.className.indexOf('false') > -1, 'is incomplete');
                ok(!!domData.get.call(child, 'task'), 'has data');
                equal(innerHTML(child), 'My Name', 'has name');
                task.attr({
                    completed: true,
                    name: 'New Name'
                });
                ok(child.className.indexOf('true') !== -1, 'is complete');
                equal(innerHTML(child), 'New Name', 'has new name');
            });
            test('multiple curly braces in a block', function () {
                var text = '{{^obs.items}}' + '<li>No items</li>' + '{{/obs.items}}' + '{{#obs.items}}' + '<li>{{name}}</li>' + '{{/obs.items}}', obs = new CanMap({ items: [] }), compiled = stache(text)({ obs: obs });
                var ul = doc.createElement('ul');
                ul.appendChild(compiled);
                equal(innerHTML(ul.getElementsByTagName('li')[0]), 'No items', 'initial observable state');
                obs.attr('items', [{ name: 'foo' }]);
                equal(innerHTML(ul.getElementsByTagName('li')[0]), 'foo', 'updated observable');
            });
            test('unescape bindings change', function () {
                var l = new CanList([
                    { complete: true },
                    { complete: false },
                    { complete: true }
                ]);
                var completed = function () {
                    l.attr('length');
                    var num = 0;
                    l.each(function (item) {
                        if (item.attr('complete')) {
                            num++;
                        }
                    });
                    return num;
                };
                var text = '<div>{{ completed }}</div>', compiled = stache(text)({ completed: completed });
                var div = doc.createElement('div');
                div.appendChild(compiled);
                var child = div.getElementsByTagName('div')[0];
                equal(innerHTML(child), '2', 'at first there are 2 true bindings');
                var item = new CanMap({
                    complete: true,
                    id: 'THIS ONE'
                });
                l.push(item);
                equal(innerHTML(child), '3', 'now there are 3 complete');
                item.attr('complete', false);
                equal(innerHTML(child), '2', 'now there are 2 complete');
                l.pop();
                item.attr('complete', true);
                equal(innerHTML(child), '2', 'there are still 2 complete');
            });
            test('escape bindings change', function () {
                var l = new CanList([
                    { complete: true },
                    { complete: false },
                    { complete: true }
                ]);
                var completed = function () {
                    l.attr('length');
                    var num = 0;
                    l.each(function (item) {
                        if (item.attr('complete')) {
                            num++;
                        }
                    });
                    return num;
                };
                var text = '<div>{{{ completed }}}</div>', compiled = stache(text)({ completed: completed });
                var div = doc.createElement('div');
                div.appendChild(compiled);
                var child = div.getElementsByTagName('div')[0];
                equal(innerHTML(child), '2', 'at first there are 2 true bindings');
                var item = new CanMap({ complete: true });
                l.push(item);
                equal(innerHTML(child), '3', 'now there are 3 complete');
                item.attr('complete', false);
                equal(innerHTML(child), '2', 'now there are 2 complete');
            });
            test('tag bindings change', function () {
                var l = new CanList([
                    { complete: true },
                    { complete: false },
                    { complete: true }
                ]);
                var completed = function () {
                    l.attr('length');
                    var num = 0;
                    l.each(function (item) {
                        if (item.attr('complete')) {
                            num++;
                        }
                    });
                    return 'items=\'' + num + '\'';
                };
                var text = '<div {{{ completed }}}></div>', compiled = stache(text)({ completed: completed });
                var div = doc.createElement('div');
                div.appendChild(compiled);
                var child = div.getElementsByTagName('div')[0];
                equal(child.getAttribute('items'), '2', 'at first there are 2 true bindings');
                var item = new CanMap({ complete: true });
                l.push(item);
                equal(child.getAttribute('items'), '3', 'now there are 3 complete');
                item.attr('complete', false);
                equal(child.getAttribute('items'), '2', 'now there are 2 complete');
            });
            test('attribute value bindings change', function () {
                var l = new CanList([
                    { complete: true },
                    { complete: false },
                    { complete: true }
                ]);
                var completed = function () {
                    l.attr('length');
                    var num = 0;
                    l.each(function (item) {
                        if (item.attr('complete')) {
                            num++;
                        }
                    });
                    return num;
                };
                var text = '<div items="{{{ completed }}}"></div>', compiled = stache(text)({ completed: completed });
                var div = doc.createElement('div');
                div.appendChild(compiled);
                var child = div.getElementsByTagName('div')[0];
                equal(child.getAttribute('items'), '2', 'at first there are 2 true bindings');
                var item = new CanMap({ complete: true });
                l.push(item);
                equal(child.getAttribute('items'), '3', 'now there are 3 complete');
                item.attr('complete', false);
                equal(child.getAttribute('items'), '2', 'now there are 2 complete');
            });
            test('in tag toggling', function () {
                var text = '<div {{ obs.val }}></div>';
                var obs = new CanMap({ val: 'foo="bar"' });
                var compiled = stache(text)({ obs: obs });
                var div = doc.createElement('div');
                div.appendChild(compiled);
                obs.attr('val', 'bar=\'foo\'');
                obs.attr('val', 'foo="bar"');
                var d2 = div.getElementsByTagName('div')[0];
                equal(d2.getAttribute('foo'), 'bar', 'bar set');
                equal(d2.getAttribute('bar'), null, 'bar set');
            });
            test('nested properties', function () {
                var text = '<div>{{ obs.name.first }}</div>';
                var obs = new CanMap({ name: { first: 'Justin' } });
                var compiled = stache(text)({ obs: obs });
                var div = doc.createElement('div');
                div.appendChild(compiled);
                div = div.getElementsByTagName('div')[0];
                equal(innerHTML(div), 'Justin');
                obs.attr('name.first', 'Brian');
                equal(innerHTML(div), 'Brian');
            });
            test('tags without chidren or ending with /> do not change the state', function () {
                var text = '<table><tr><td/>{{{ obs.content }}}</tr></div>';
                var obs = new CanMap({ content: '<td>Justin</td>' });
                var compiled = stache(text)({ obs: obs });
                var div = doc.createElement('div');
                var html = compiled;
                div.appendChild(html);
                equal(div.getElementsByTagName('span').length, 0, 'there are no spans');
                equal(div.getElementsByTagName('td').length, 2, 'there are 2 td');
            });
            test('nested live bindings', function () {
                expect(0);
                var items = new CanList([{
                        title: 0,
                        is_done: false,
                        id: 0
                    }]);
                var div = doc.createElement('div');
                var template = stache('<form>{{#items}}{{^is_done}}<div id="{{title}}"></div>{{/is_done}}{{/items}}</form>');
                div.appendChild(template({ items: items }));
                items.push({
                    title: 1,
                    is_done: false,
                    id: 1
                });
                items[0].attr('is_done', true);
            });
            test('list nested in observe live bindings', function () {
                var template = stache('<ul>{{#data.items}}<li>{{name}}</li>{{/data.items}}</ul>');
                var data = new CanMap({
                    items: [
                        { name: 'Brian' },
                        { name: 'Fara' }
                    ]
                });
                var div = doc.createElement('div');
                div.appendChild(template({ data: data }));
                data.items.push(new CanMap({ name: 'Scott' }));
                ok(/Brian/.test(innerHTML(div)), 'added first name');
                ok(/Fara/.test(innerHTML(div)), 'added 2nd name');
                ok(/Scott/.test(innerHTML(div)), 'added name after push');
            });
            test('trailing text', function () {
                var template = stache('There are {{ length }} todos');
                var div = doc.createElement('div');
                div.appendChild(template(new CanList([
                    {},
                    {}
                ])));
                ok(/There are 2 todos/.test(innerHTML(div)), 'got all text');
            });
            if (isNormalDOM) {
                test('recursive views', function () {
                    var template = stache('<div class="template">' + '{{#items}}' + '<div class="loop">' + '{{#item.children}}' + '<div class="node">' + '{{>recursive}}' + '</div>' + '{{/item.children}}' + '{{^item.children}}' + '<div class="leaf">L</div>' + '{{/item.children}}' + '</div>' + '{{/items}}' + '</div>');
                    var data = new CanList([{
                            label: 'branch1',
                            children: [{
                                    id: 2,
                                    label: 'branch2'
                                }]
                        }]);
                    var div = doc.createElement('div');
                    var frag = template({ items: data }, { partials: { recursive: template } });
                    div.appendChild(frag);
                    ok(/class="?leaf"?/.test(innerHTML(div)), 'we have a leaf');
                });
            }
            test('live binding textarea', function () {
                var template = stache('<textarea>Before{{ obs.middle }}After</textarea>');
                var obs = new CanMap({ middle: 'yes' }), div = doc.createElement('div');
                div.appendChild(template({ obs: obs }));
                var textarea = div.firstChild;
                equal(getValue(textarea), 'BeforeyesAfter');
                obs.attr('middle', 'Middle');
                equal(getValue(textarea), 'BeforeMiddleAfter');
            });
            test('reading a property from a parent object when the current context is an observe', function () {
                var template = stache('{{#foos}}<span>{{bar}}</span>{{/foos}}');
                var data = {
                    foos: new CanList([
                        { name: 'hi' },
                        { name: 'bye' }
                    ]),
                    bar: 'Hello World'
                };
                var div = doc.createElement('div');
                var res = template(data);
                div.appendChild(res);
                var spans = div.getElementsByTagName('span');
                equal(spans.length, 2, 'Got two <span> elements');
                equal(innerHTML(spans[0]), 'Hello World', 'First span Hello World');
                equal(innerHTML(spans[1]), 'Hello World', 'Second span Hello World');
            });
            test('helper parameters don\'t convert functions', function () {
                stache.registerHelper('helperWithFn', function (fn) {
                    ok(typeof fn === 'function', 'Parameter is a function');
                    equal(fn(), 'Hit me!', 'Got the expected function');
                });
                var renderer = stache('{{helperWithFn test}}');
                renderer({
                    test: function () {
                        return 'Hit me!';
                    }
                });
            });
            test('computes as helper parameters don\'t get converted', function () {
                stache.registerHelper('computeTest', function (no) {
                    equal(no(), 5, 'Got computed calue');
                    ok(no.isComputed, 'no is still a compute');
                });
                var renderer = stache('{{computeTest test}}');
                renderer({ test: canCompute(5) });
            });
            test('computes are supported in default helpers', function () {
                var staches = {
                    'if': '{{#if test}}if{{else}}else{{/if}}',
                    'not_if': 'not_{{^if test}}not{{/if}}if',
                    'each': '{{#each test}}{{.}}{{/each}}',
                    'with': 'wit{{#with test}}<span>{{3}}</span>{{/with}}'
                };
                var template = stache('There are {{ length }} todos');
                var div = doc.createElement('div');
                div.appendChild(template(new CanList([
                    {},
                    {}
                ])));
                ok(/There are 2 todos/.test(innerHTML(div)), 'got all text');
                var renderer, result, data, actual, span;
                for (result in staches) {
                    renderer = stache(staches[result]);
                    data = [
                        'e',
                        'a',
                        'c',
                        'h'
                    ];
                    div = doc.createElement('div');
                    actual = renderer({ test: canCompute(data) });
                    div.appendChild(actual);
                    span = div.getElementsByTagName('span')[0];
                    if (span && span.firstChild) {
                        div.insertBefore(span.firstChild, span);
                        div.removeChild(span);
                    }
                    actual = innerHTML(div);
                    equal(actual, result, 'canCompute resolved for helper ' + result);
                }
                var inv_staches = {
                    'else': '{{#if test}}if{{else}}else{{/if}}',
                    'not_not_if': 'not_{{^if test}}not_{{/if}}if',
                    'not_each': 'not_{{#each test}}_{{/each}}each',
                    'not_with': 'not{{#with test}}_{{/with}}_with'
                };
                for (result in inv_staches) {
                    renderer = stache(inv_staches[result]);
                    data = null;
                    div = doc.createElement('div');
                    actual = renderer({ test: canCompute(data) });
                    div.appendChild(actual);
                    actual = innerHTML(div);
                    equal(actual, result, 'canCompute resolved for helper ' + result);
                }
            });
            test('multiple tbodies in table hookup', function () {
                var text = '<table>' + '{{#people}}' + '<tbody><tr><td>{{name}}</td></tr></tbody>' + '{{/people}}' + '</table>', people = new CanList([
                        { name: 'Steve' },
                        { name: 'Doug' }
                    ]), compiled = stache(text)({ people: people });
                equal(compiled.firstChild.getElementsByTagName('tbody').length, 2, 'two tbodies');
            });
            test('Observe with array attributes', function () {
                var renderer = stache('<ul>{{#todos}}<li>{{.}}</li>{{/todos}}</ul><div>{{message}}</div>');
                var div = doc.createElement('div');
                var data = new CanMap({
                    todos: [
                        'Line #1',
                        'Line #2',
                        'Line #3'
                    ],
                    message: 'Hello',
                    count: 2
                });
                div.appendChild(renderer(data));
                equal(innerHTML(div.getElementsByTagName('li')[1]), 'Line #2', 'Check initial array');
                equal(innerHTML(div.getElementsByTagName('div')[0]), 'Hello', 'Check initial message');
                data.attr('todos.1', 'Line #2 changed');
                data.attr('message', 'Hello again');
                equal(innerHTML(div.getElementsByTagName('li')[1]), 'Line #2 changed', 'Check updated array');
                equal(innerHTML(div.getElementsByTagName('div')[0]), 'Hello again', 'Check updated message');
            });
            test('Observe list returned from the function', function () {
                var renderer = stache('<ul>{{#todos}}<li>{{.}}</li>{{/todos}}</ul>');
                var div = doc.createElement('div');
                var todos = new CanList();
                var data = {
                    todos: function () {
                        return todos;
                    }
                };
                div.appendChild(renderer(data));
                todos.push('Todo #1');
                equal(div.getElementsByTagName('li').length, 1, 'Todo is successfuly created');
                equal(innerHTML(div.getElementsByTagName('li')[0]), 'Todo #1', 'Pushing to the list works');
            });
            test('Contexts within helpers not always resolved correctly', function () {
                stache.registerHelper('bad_context', function (context, options) {
                    return [
                        '<span>' + this.text + '</span> should not be ',
                        options.fn(context)
                    ];
                });
                var renderer = stache('{{#bad_context next_level}}<span>{{text}}</span><br/><span>{{other_text}}</span>{{/bad_context}}'), data = {
                        next_level: {
                            text: 'bar',
                            other_text: 'In the inner context'
                        },
                        text: 'foo'
                    }, div = doc.createElement('div');
                div.appendChild(renderer(data));
                equal(innerHTML(div.getElementsByTagName('span')[0]), 'foo', 'Incorrect context passed to helper');
                equal(innerHTML(div.getElementsByTagName('span')[1]), 'bar', 'Incorrect text in helper inner template');
                equal(innerHTML(div.getElementsByTagName('span')[2]), 'In the inner context', 'Incorrect other_text in helper inner template');
            });
            test('Contexts are not always passed to partials properly', function () {
                var inner = stache('{{#if other_first_level}}{{other_first_level}}{{else}}{{second_level}}{{/if}}');
                var renderer = stache('{{#first_level}}<span>{{> inner}}</span> should equal <span>{{other_first_level}}</span>{{/first_level}}'), data = {
                        first_level: { second_level: 'bar' },
                        other_first_level: 'foo'
                    }, div = doc.createElement('div');
                div.appendChild(renderer(data, { partials: { inner: inner } }));
                equal(innerHTML(div.getElementsByTagName('span')[0]), 'foo', 'Incorrect context passed to helper');
                equal(innerHTML(div.getElementsByTagName('span')[1]), 'foo', 'Incorrect text in helper inner template');
            });
            test('Functions and helpers should be passed the same context', function () {
                var textNodes = function (el, cb) {
                    var cur = el.firstChild;
                    while (cur) {
                        if (cur.nodeType === 3) {
                            cb(cur);
                        } else if (el.nodeType === 1) {
                            textNodes(cur, cb);
                        }
                        cur = cur.nextSibling;
                    }
                };
                stache.registerHelper('to_upper', function (fn, options) {
                    if (!fn.fn) {
                        return typeof fn === 'function' ? fn().toString().toUpperCase() : fn.toString().toUpperCase();
                    } else {
                        var frag = fn.fn(this);
                        textNodes(frag, function (el) {
                            el.nodeValue = el.nodeValue.toUpperCase();
                        });
                        return frag;
                    }
                });
                var renderer = stache(' "<span>{{#to_upper}}{{next_level.text}}{{/to_upper}}</span>"'), data = {
                        next_level: {
                            text: function () {
                                return this.other_text;
                            },
                            other_text: 'In the inner context'
                        }
                    }, div = doc.createElement('div');
                window.other_text = 'Window context';
                div.appendChild(renderer(data));
                equal(innerHTML(div.getElementsByTagName('span')[0]), data.next_level.other_text.toUpperCase(), 'correct context passed to helper');
            });
            test('Interpolated values when iterating through an Observe.List should still render when not surrounded by a DOM node', function () {
                var renderer = stache('{{ #todos }}{{ name }}{{ /todos }}'), renderer2 = stache('{{ #todos }}<span>{{ name }}</span>{{ /todos }}'), todos = [
                        {
                            id: 1,
                            name: 'Dishes'
                        },
                        {
                            id: 2,
                            name: 'Forks'
                        }
                    ], liveData = { todos: new CanList(todos) }, plainData = { todos: todos }, div = doc.createElement('div');
                div.appendChild(renderer2(plainData));
                equal(innerHTML(div.getElementsByTagName('span')[0]), 'Dishes', 'Array item rendered with DOM container');
                equal(innerHTML(div.getElementsByTagName('span')[1]), 'Forks', 'Array item rendered with DOM container');
                div.innerHTML = '';
                div.appendChild(renderer2(liveData));
                equal(innerHTML(div.getElementsByTagName('span')[0]), 'Dishes', 'List item rendered with DOM container');
                equal(innerHTML(div.getElementsByTagName('span')[1]), 'Forks', 'List item rendered with DOM container');
                div = doc.createElement('div');
                div.appendChild(renderer(plainData));
                equal(innerHTML(div), 'DishesForks', 'Array item rendered without DOM container');
                div = doc.createElement('div');
                div.appendChild(renderer(liveData));
                equal(innerHTML(div), 'DishesForks', 'List item rendered without DOM container');
                liveData.todos.push({
                    id: 3,
                    name: 'Knives'
                });
                equal(innerHTML(div), 'DishesForksKnives', 'New list item rendered without DOM container');
            });
            test('objects with a \'key\' or \'index\' property should work in helpers', function () {
                var renderer = stache('{{ #obj }}{{ show_name }}{{ /obj }}'), div = doc.createElement('div');
                div.appendChild(renderer({
                    obj: {
                        id: 2,
                        name: 'Forks',
                        key: 'bar'
                    }
                }, {
                    show_name: function () {
                        return this.name;
                    }
                }));
                equal(innerHTML(div), 'Forks', 'item name rendered');
                div = doc.createElement('div');
                div.appendChild(renderer({
                    obj: {
                        id: 2,
                        name: 'Forks',
                        index: 'bar'
                    }
                }, {
                    show_name: function () {
                        return this.name;
                    }
                }));
                equal(innerHTML(div), 'Forks', 'item name rendered');
            });
            test('2 way binding helpers', function () {
                var Value = function (el, value) {
                    this.updateElement = function (ev, newVal) {
                        el.value = newVal || '';
                    };
                    value.bind('change', this.updateElement);
                    el.onchange = function () {
                        value(el.value);
                    };
                    this.teardown = function () {
                        value.unbind('change', this.updateElement);
                        el.onchange = null;
                    };
                    el.value = value() || '';
                };
                var val;
                stache.registerHelper('myValue', function (value) {
                    return function (el) {
                        val = new Value(el, value);
                    };
                });
                var renderer = stache('<input {{myValue user.name}}/>');
                var div = doc.createElement('div'), u = new CanMap({ name: 'Justin' });
                div.appendChild(renderer({ user: u }));
                var input = div.getElementsByTagName('input')[0];
                equal(input.value, 'Justin', 'Name is set correctly');
                u.attr('name', 'Eli');
                equal(input.value, 'Eli', 'Changing observe updates value');
                input.value = 'Austin';
                input.onchange();
                equal(u.attr('name'), 'Austin', 'Name changed by input field');
                val.teardown();
                renderer = stache('<input {{myValue user.name}}/>');
                div = doc.createElement('div');
                u = new CanMap({});
                div.appendChild(renderer({ user: u }));
                input = div.getElementsByTagName('input')[0];
                equal(input.value, '', 'Name is set correctly');
                u.attr('name', 'Eli');
                equal(input.value, 'Eli', 'Changing observe updates value');
                input.value = 'Austin';
                input.onchange();
                equal(u.attr('name'), 'Austin', 'Name changed by input field');
                val.teardown();
                renderer = stache('<input {{myValue user.name}}/>');
                div = doc.createElement('div');
                u = new CanMap({ name: null });
                div.appendChild(renderer({ user: u }));
                input = div.getElementsByTagName('input')[0];
                equal(input.value, '', 'Name is set correctly with null');
                u.attr('name', 'Eli');
                equal(input.value, 'Eli', 'Changing observe updates value');
                input.value = 'Austin';
                input.onchange();
                equal(u.attr('name'), 'Austin', 'Name changed by input field');
                val.teardown();
            });
            test('can pass in partials', function () {
                var hello = stache('<p>Hello {{> name}}</p>');
                var fancyName = stache('<span class=\'fancy\'>{{name}}</span>');
                var result = hello({ name: 'World' }, { partials: { name: fancyName } });
                ok(/World/.test(innerHTML(result.firstChild)), 'Hello World worked');
            });
            test('can pass in helpers', function () {
                var helpers = stache('<p>Hello {{cap name}}</p>');
                var result = helpers({ name: 'world' }, {
                    helpers: {
                        cap: function (name) {
                            return string.capitalize(name);
                        }
                    }
                });
                ok(/World/.test(innerHTML(result.firstChild)), 'Hello World worked');
            });
            test('HTML comment with helper', function () {
                var text = [
                        '<ul>',
                        '{{#todos}}',
                        '<li {{data \'todo\'}}>',
                        '<!-- html comment #1 -->',
                        '{{name}}',
                        '<!-- html comment #2 -->',
                        '</li>',
                        '{{/todos}}',
                        '</ul>'
                    ], todos = new CanList([{
                            id: 1,
                            name: 'Dishes'
                        }]), compiled = stache(text.join('\n'))({ todos: todos }), div = doc.createElement('div'), li;
                var comments = function (el) {
                    var count = 0;
                    var cur = el.firstChild;
                    while (cur) {
                        if (cur.nodeType === 8) {
                            ++count;
                        }
                        cur = cur.nextSibling;
                    }
                    return count;
                };
                div.appendChild(compiled);
                li = div.getElementsByTagName('ul')[0].getElementsByTagName('li');
                equal(li.length, 1, '1 item in list');
                equal(comments(li[0]), 2, '2 comments in item #1');
                todos.push({
                    id: 2,
                    name: 'Laundry'
                });
                li = div.getElementsByTagName('ul')[0].getElementsByTagName('li');
                equal(li.length, 2, '2 items in list');
                equal(comments(li[0]), 2, '2 comments in item #1');
                equal(comments(li[1]), 2, '2 comments in item #2');
                todos.splice(0, 2);
                li = div.getElementsByTagName('ul')[0].getElementsByTagName('li');
                equal(li.length, 0, '0 items in list');
            });
            test('Empty strings in arrays within Observes that are iterated should return blank strings', function () {
                var data = new CanMap({
                        colors: [
                            '',
                            'red',
                            'green',
                            'blue'
                        ]
                    }), compiled = stache('<select>{{#colors}}<option>{{.}}</option>{{/colors}}</select>')(data), div = doc.createElement('div');
                div.appendChild(compiled);
                equal(innerHTML(div.getElementsByTagName('option')[0]), '', 'Blank string should return blank');
            });
            test('Null properties do not throw errors', function () {
                var renderer = stache('Foo bar {{#foo.bar}}exists{{/foo.bar}}{{^foo.bar}}does not exist{{/foo.bar}}'), div = doc.createElement('div'), div2 = doc.createElement('div'), frag, frag2;
                try {
                    frag = renderer(new CanMap({ foo: null }));
                } catch (e) {
                    ok(false, 'rendering with null threw an error');
                }
                frag2 = renderer(new CanMap({ foo: { bar: 'baz' } }));
                div.appendChild(frag);
                div2.appendChild(frag2);
                equal(innerHTML(div), 'Foo bar does not exist');
                equal(innerHTML(div2), 'Foo bar exists');
            });
            test('Data helper should set proper data instead of a context stack', function () {
                var partials = {
                    'nested_data': stache('<span id="has_data" {{data "attr"}}></span>'),
                    'nested_data2': stache('{{#this}}<span id="has_data" {{data "attr"}}></span>{{/this}}'),
                    'nested_data3': stache('{{#bar}}<span id="has_data" {{data "attr"}}></span>{{/bar}}')
                };
                var renderer = stache('{{#bar}}{{> nested_data}}{{/bar}}'), renderer2 = stache('{{#bar}}{{> nested_data2}}{{/bar}}'), renderer3 = stache('{{#bar}}{{> nested_data3}}{{/bar}}'), div = doc.createElement('div'), data = new CanMap({
                        foo: 'bar',
                        bar: new CanMap({})
                    }), span;
                div = doc.createElement('div');
                div.appendChild(renderer(data, { partials: partials }));
                span = div.getElementsByTagName('span')[0];
                strictEqual(domData.get.call(span, 'attr'), data.bar, 'Nested data 1 should have correct data');
                div = doc.createElement('div');
                div.appendChild(renderer2(data, { partials: partials }));
                span = div.getElementsByTagName('span')[0];
                strictEqual(domData.get.call(span, 'attr'), data.bar, 'Nested data 2 should have correct data');
                div = doc.createElement('div');
                div.appendChild(renderer3(data, { partials: partials }));
                span = div.getElementsByTagName('span')[0];
                strictEqual(domData.get.call(span, 'attr'), data.bar, 'Nested data 3 should have correct data');
            });
            test('Functions passed to default helpers should be evaluated', function () {
                var renderer = stache('{{#if hasDucks}}Ducks: {{ducks}}{{else}}No ducks!{{/if}}'), div = doc.createElement('div'), data = new CanMap({
                        ducks: '',
                        hasDucks: function () {
                            return this.attr('ducks').length > 0;
                        }
                    });
                var span;
                div.appendChild(renderer(data));
                span = div.getElementsByTagName('span')[0];
                equal(innerHTML(div), 'No ducks!', 'The function evaluated should evaluate false');
            });
            test('avoid global helpers', function () {
                var noglobals = stache('{{sometext person.name}}');
                var div = doc.createElement('div'), div2 = doc.createElement('div');
                var person = new CanMap({ name: 'Brian' });
                var result = noglobals({ person: person }, {
                    sometext: function (name) {
                        return 'Mr. ' + name();
                    }
                });
                var result2 = noglobals({ person: person }, {
                    sometext: function (name) {
                        return name() + ' rules';
                    }
                });
                div.appendChild(result);
                div2.appendChild(result2);
                person.attr('name', 'Ajax');
                equal(innerHTML(div), 'Mr. Ajax');
                equal(innerHTML(div2), 'Ajax rules');
            });
            test('Helpers always have priority (#258)', function () {
                stache.registerHelper('callMe', function (arg) {
                    return arg + ' called me!';
                });
                var t = {
                    template: '<div>{{callMe \'Tester\'}}</div>',
                    expected: '<div>Tester called me!</div>',
                    data: {
                        callMe: function (arg) {
                            return arg + ' hanging up!';
                        }
                    }
                };
                var expected = t.expected.replace(/&quot;/g, '&#34;').replace(/\r\n/g, '\n');
                deepEqual(getText(t.template, t.data), expected);
            });
            test('avoid global helpers', function () {
                var noglobals = stache('{{sometext person.name}}');
                var div = doc.createElement('div'), div2 = doc.createElement('div');
                var person = new CanMap({ name: 'Brian' });
                var result = noglobals({ person: person }, {
                    sometext: function (name) {
                        return 'Mr. ' + name();
                    }
                });
                var result2 = noglobals({ person: person }, {
                    sometext: function (name) {
                        return name() + ' rules';
                    }
                });
                div.appendChild(result);
                div2.appendChild(result2);
                person.attr('name', 'Ajax');
                equal(innerHTML(div), 'Mr. Ajax');
                equal(innerHTML(div2), 'Ajax rules');
            });
            test('Each does not redraw items', function () {
                var animals = new CanList([
                        'sloth',
                        'bear'
                    ]), renderer = stache('<div>my<b>favorite</b>animals:{{#each animals}}<label>Animal=</label> <span>{{this}}</span>{{/}}!</div>');
                var div = doc.createElement('div');
                var frag = renderer({ animals: animals });
                div.appendChild(frag);
                div.getElementsByTagName('label')[0].myexpando = 'EXPANDO-ED';
                equal(div.getElementsByTagName('label').length, 2, 'There are 2 labels');
                animals.push('turtle');
                equal(div.getElementsByTagName('label')[0].myexpando, 'EXPANDO-ED', 'same expando');
                equal(innerHTML(div.getElementsByTagName('span')[2]), 'turtle', 'turtle added');
            });
            test('Each works with the empty list', function () {
                var animals = new CanList([]), renderer = stache('<div>my<b>favorite</b>animals:{{#each animals}}<label>Animal=</label> <span>{{this}}</span>{{/}}!</div>');
                var div = doc.createElement('div');
                var frag = renderer({ animals: animals });
                div.appendChild(frag);
                animals.push('sloth', 'bear');
                equal(div.getElementsByTagName('label').length, 2, 'There are 2 labels');
            });
            test('each works within another branch', function () {
                var animals = new CanList(['sloth']), template = '<div>Animals:' + '{{#if animals.length}}~' + '{{#each animals}}' + '<span>{{.}}</span>' + '{{/each}}' + '{{else}}' + 'No animals' + '{{/if}}' + '!</div>';
                var renderer = stache(template);
                var div = doc.createElement('div');
                var frag = renderer({ animals: animals });
                div.appendChild(frag);
                equal(div.getElementsByTagName('span').length, 1, 'There is 1 sloth');
                animals.pop();
                equal(innerHTML(div.getElementsByTagName('div')[0]), 'Animals:No animals!');
            });
            test('a compute gets passed to a plugin', function () {
                stache.registerHelper('iamhungryforcomputes', function (value) {
                    ok(value.isComputed, 'value is a compute');
                    return function (el) {
                    };
                });
                var renderer = stache('<input {{iamhungryforcomputes userName}}/>');
                var div = doc.createElement('div'), u = new CanMap({ name: 'Justin' });
                var nameCompute = canCompute(function () {
                    return u.attr('name');
                });
                div.appendChild(renderer({ userName: nameCompute }));
            });
            test('Object references can escape periods for key names containing periods', function () {
                var template = stache('{{#foo.bar}}' + '{{some\\.key\\.name}} {{some\\.other\\.key.with\\.more}}' + '{{/foo.bar}}'), data = {
                        foo: {
                            bar: [{
                                    'some.key.name': 100,
                                    'some.other.key': { 'with.more': 'values' }
                                }]
                        }
                    };
                var div = doc.createElement('div');
                div.appendChild(template(data));
                equal(innerHTML(div), '100 values');
            });
            test('Computes should be resolved prior to accessing attributes', function () {
                var template = stache('{{list.length}}'), data = { list: canCompute(new CanList()) };
                var div = doc.createElement('div');
                div.appendChild(template(data));
                equal(innerHTML(div), '0');
            });
            test('Helpers can be passed . or this for the active context', function () {
                stache.registerHelper('rsvp', function (attendee, event) {
                    return attendee.name + ' is attending ' + event.name;
                });
                var template = stache('{{#attendee}}{{#events}}<div>{{rsvp attendee .}}</div>{{/events}}{{/#attendee}}'), data = {
                        attendee: { name: 'Justin' },
                        events: [
                            { name: 'Reception' },
                            { name: 'Wedding' }
                        ]
                    };
                var div = doc.createElement('div');
                div.appendChild(template(data));
                var children = div.getElementsByTagName('div');
                equal(innerHTML(children[0]), 'Justin is attending Reception');
                equal(innerHTML(children[1]), 'Justin is attending Wedding');
            });
            test('helpers only called once (#477)', function () {
                var callCount = 0;
                stache.registerHelper('foo', function (text) {
                    callCount++;
                    equal(callCount, 1, 'call count is only ever one');
                    return 'result';
                });
                var obs = new CanMap({ quux: false });
                var template = stache('Foo text is: {{#if quux}}{{foo \'bar\'}}{{/if}}');
                template(obs);
                obs.attr('quux', true);
            });
            test('helpers between tags (#469)', function () {
                stache.registerHelper('itemsHelper', function () {
                    return function (textNode) {
                        equal(textNode.nodeType, 3, 'right nodeType');
                    };
                });
                var template = stache('<ul>{{itemsHelper}}</ul>');
                template();
            });
            test('hiding image srcs (#157)', function () {
                var template = stache('<img {{#image}}src="{{.}}"{{/image}} alt="An image" />'), data = new CanMap({ image: null }), url = 'http://canjs.us/scripts/static/img/canjs_logo_yellow_small.png';
                var frag = template(data), img = frag.firstChild;
                equal(img.getAttribute('src'), null, 'there is no src');
                data.attr('image', url);
                notEqual(img.getAttribute('src'), null, 'Image should have src');
                equal(img.getAttribute('src'), url, 'images src is correct');
            });
            test('live binding in a truthy section', function () {
                var template = stache('<div {{#width}}width="{{.}}"{{/width}}></div>'), data = new CanMap({ width: '100' });
                var frag = template(data), img = frag.firstChild;
                equal(img.getAttribute('width'), '100', 'initial width is correct');
                data.attr('width', '300');
                equal(img.getAttribute('width'), '300', 'updated width is correct');
            });
            test('backtracks in mustache (#163)', function () {
                var template = stache('{{#grid.rows}}' + '{{#grid.cols}}' + '<div>{{columnData ../. .}}</div>' + '{{/grid.cols}}' + '{{/grid.rows}}');
                var grid = new CanMap({
                    rows: [
                        {
                            first: 'Justin',
                            last: 'Meyer'
                        },
                        {
                            first: 'Brian',
                            last: 'Moschel'
                        }
                    ],
                    cols: [
                        { prop: 'first' },
                        { prop: 'last' }
                    ]
                });
                var frag = template({ grid: grid }, {
                    columnData: function (row, col) {
                        return row().attr(col().attr('prop'));
                    }
                });
                var divs = getChildNodes(frag);
                equal(divs.length, 4, 'there are 4 divs');
                var vals = makeArray(divs).map(function (div) {
                    return innerHTML(div);
                });
                deepEqual(vals, [
                    'Justin',
                    'Meyer',
                    'Brian',
                    'Moschel'
                ], 'div values are the same');
            });
            test('support null and undefined as an argument', function () {
                var template = stache('{{aHelper null undefined}}');
                template({}, {
                    aHelper: function (arg1, arg2) {
                        ok(arg1 === null);
                        ok(arg2 === undefined);
                    }
                });
            });
            test('passing CanList to helper (#438)', function () {
                var renderer = stache('<ul><li {{helper438 observeList}}>observeList broken</li>' + '<li {{helper438 array}}>plain arrays work</li></ul>');
                stache.registerHelper('helper438', function (classnames) {
                    return function (el) {
                        empty(el);
                        el.appendChild(el.ownerDocument.createTextNode('Helper called'));
                    };
                });
                var frag = renderer({
                    observeList: new CanList([
                        { test: 'first' },
                        { test: 'second' }
                    ]),
                    array: [
                        { test: 'first' },
                        { test: 'second' }
                    ]
                });
                var div = doc.createElement('div');
                div.appendChild(frag);
                var ul = div.firstChild;
                equal(innerHTML(ul.childNodes.item(0)), 'Helper called', 'Helper called');
                equal(innerHTML(ul.childNodes.item(1)), 'Helper called', 'Helper called');
            });
            test('hiding image srcs (#494)', function () {
                var template = stache('<img src="{{image}}"/>'), data = new CanMap({ image: '' }), url = 'http://canjs.us/scripts/static/img/canjs_logo_yellow_small.png';
                var frag = template(data), img = frag.firstChild;
                equal(img.getAttribute('src'), null, 'there is no src');
                data.attr('image', url);
                notEqual(img.getAttribute('src'), '', 'Image should have src');
                equal(img.getAttribute('src'), url, 'images src is correct');
            });
            test('hiding image srcs with complex content (#494)', function () {
                var template = stache('<img src="{{#image}}http://{{domain}}/{{loc}}.png{{/image}}"/>'), data = new CanMap({}), imgData = {
                        domain: 'canjs.us',
                        loc: 'scripts/static/img/canjs_logo_yellow_small'
                    }, url = 'http://canjs.us/scripts/static/img/canjs_logo_yellow_small.png';
                var frag = template(data), img = frag.firstChild;
                equal(img.getAttribute('src'), null, 'there is no src');
                data.attr('image', imgData);
                notEqual(img.getAttribute('src'), '', 'Image should have src');
                equal(img.getAttribute('src'), url, 'images src is correct');
            });
            test('empty lists update', 2, function () {
                var template = stache('<p>{{#list}}{{.}}{{/list}}</p>');
                var map = new CanMap({ list: ['something'] });
                var frag = template(map);
                var div = doc.createElement('div');
                div.appendChild(frag);
                equal(innerHTML(div.childNodes.item(0)), 'something', 'initial list content set');
                map.attr('list', [
                    'one',
                    'two'
                ]);
                equal(innerHTML(div.childNodes.item(0)), 'onetwo', 'updated list content set');
            });
            test('attributes in truthy section', function () {
                var template = stache('<p {{#attribute}}data-test="{{attribute}}"{{/attribute}}></p>');
                var data1 = { attribute: 'test-value' };
                var frag1 = template(data1);
                var div1 = doc.createElement('div');
                div1.appendChild(frag1);
                equal(div1.childNodes.item(0).getAttribute('data-test'), 'test-value', 'hyphenated attribute value');
                var data2 = { attribute: 'test value' };
                var frag2 = template(data2);
                var div2 = doc.createElement('div');
                div2.appendChild(frag2);
                equal(div2.childNodes.item(0).getAttribute('data-test'), 'test value', 'whitespace in attribute value');
            });
            test('live bound attributes with no \'=\'', function () {
                var template = stache('<input type="radio" {{#selected}}checked{{/selected}}>');
                var data = new CanMap({ selected: false });
                var frag = template(data);
                var div = doc.createElement('div');
                div.appendChild(frag);
                data.attr('selected', true);
                equal(div.childNodes.item(0).checked, true, 'hyphenated attribute value');
                data.attr('selected', false);
                equal(div.childNodes.item(0).checked, false, 'hyphenated attribute value');
            });
            test('outputting array of attributes', function () {
                var template = stache('<p {{#attribute}}{{name}}="{{value}}"{{/attribute}}></p>');
                var data = {
                    attribute: [
                        {
                            'name': 'data-test1',
                            'value': 'value1'
                        },
                        {
                            'name': 'data-test2',
                            'value': 'value2'
                        },
                        {
                            'name': 'data-test3',
                            'value': 'value3'
                        }
                    ]
                };
                var frag = template(data);
                var div = doc.createElement('div');
                div.appendChild(frag);
                equal(div.childNodes.item(0).getAttribute('data-test1'), 'value1', 'first value');
                equal(div.childNodes.item(0).getAttribute('data-test2'), 'value2', 'second value');
                equal(div.childNodes.item(0).getAttribute('data-test3'), 'value3', 'third value');
            });
            test('incremental updating of #each within an if', function () {
                var template = stache('{{#if items.length}}<ul>{{#each items}}<li/>{{/each}}</ul>{{/if}}');
                var items = new CanList([
                    {},
                    {}
                ]);
                var div = doc.createElement('div');
                div.appendChild(template({ items: items }));
                var ul = div.getElementsByTagName('ul')[0];
                ul.setAttribute('original', 'yup');
                items.push({});
                ok(ul === div.getElementsByTagName('ul')[0], 'ul is still the same');
            });
            test('stache.safeString', function () {
                var text = 'Google', url = 'http://google.com/', templateEscape = stache('{{link "' + text + '" "' + url + '"}}'), templateUnescape = stache('{{{link "' + text + '" "' + url + '"}}}');
                stache.registerHelper('link', function (text, url) {
                    var link = '<a href="' + url + '">' + text + '</a>';
                    return stache.safeString(link);
                });
                var div = doc.createElement('div');
                var frag = templateEscape({});
                div.appendChild(frag);
                equal(getChildNodes(div).length, 1, 'rendered a DOM node');
                equal(div.childNodes.item(0).nodeName, 'A', 'rendered an anchor tag');
                equal(innerHTML(div.childNodes.item(0)), text, 'rendered the text properly');
                equal(div.childNodes.item(0).getAttribute('href'), url, 'rendered the href properly');
                div = doc.createElement('div');
                div.appendChild(templateUnescape({}));
                equal(getChildNodes(div).length, 1, 'rendered a DOM node');
                equal(div.childNodes.item(0).nodeName, 'A', 'rendered an anchor tag');
                equal(innerHTML(div.childNodes.item(0)), text, 'rendered the text properly');
                equal(div.childNodes.item(0).getAttribute('href'), url, 'rendered the href properly');
            });
            test('changing the list works with each', function () {
                var template = stache('<ul>{{#each list}}<li>.</li>{{/each}}</ul>');
                var map = new CanMap({ list: ['foo'] });
                var tpl = template(map).firstChild;
                equal(tpl.getElementsByTagName('li').length, 1, 'one li');
                map.attr('list', new CanList([
                    'bar',
                    'car'
                ]));
                equal(tpl.getElementsByTagName('li').length, 2, 'two lis');
            });
            test('nested properties binding (#525)', function () {
                var template = stache('<label>{{name.first}}</label>');
                var me = new CanMap();
                var label = template(me).firstChild;
                me.attr('name', { first: 'Justin' });
                equal(innerHTML(label), 'Justin', 'set name object');
                me.attr('name', { first: 'Brian' });
                equal(innerHTML(label), 'Brian', 'merged name object');
                me.removeAttr('name');
                me.attr({ name: { first: 'Payal' } });
                equal(innerHTML(label), 'Payal', 'works after parent removed');
            });
            test('Rendering indicies of an array with @index', function () {
                var template = stache('<ul>{{#each list}}<li>{{@index}} {{.}}</li>{{/each}}</ul>');
                var list = [
                    0,
                    1,
                    2,
                    3
                ];
                var lis = template({ list: list }).firstChild.getElementsByTagName('li');
                for (var i = 0; i < lis.length; i++) {
                    equal(innerHTML(lis[i]), i + ' ' + i, 'rendered index and value are correct');
                }
            });
            test('Rendering indicies of an array with @index + offset (#1078)', function () {
                var template = stache('<ul>{{#each list}}<li>{{@index 5}} {{.}}</li>{{/each}}</ul>');
                var list = [
                    0,
                    1,
                    2,
                    3
                ];
                var lis = template({ list: list }).firstChild.getElementsByTagName('li');
                for (var i = 0; i < lis.length; i++) {
                    equal(innerHTML(lis[i]), i + 5 + ' ' + i, 'rendered index and value are correct');
                }
            });
            test('Passing indices into helpers as values', function () {
                var template = stache('<ul>{{#each list}}<li>{{test @index}} {{.}}</li>{{/each}}</ul>');
                var list = [
                    0,
                    1,
                    2,
                    3
                ];
                var lis = template({ list: list }, {
                    test: function (index) {
                        return '' + index;
                    }
                }).firstChild.getElementsByTagName('li');
                for (var i = 0; i < lis.length; i++) {
                    equal(innerHTML(lis[i]), i + ' ' + i, 'rendered index and value are correct');
                }
            });
            test('Rendering live bound indicies with #each, @index and a simple CanList', function () {
                var list = new CanList([
                    'a',
                    'b',
                    'c'
                ]);
                var template = stache('<ul>{{#each list}}<li>{{%index}} {{.}}</li>{{/each}}</ul>');
                var tpl = template({ list: list }).firstChild;
                var lis = tpl.getElementsByTagName('li');
                equal(lis.length, 3, 'three lis');
                equal(innerHTML(lis[0]), '0 a', 'first index and value are correct');
                equal(innerHTML(lis[1]), '1 b', 'second index and value are correct');
                equal(innerHTML(lis[2]), '2 c', 'third index and value are correct');
                list.push('d', 'e');
                lis = tpl.getElementsByTagName('li');
                equal(lis.length, 5, 'five lis');
                equal(innerHTML(lis[3]), '3 d', 'fourth index and value are correct');
                equal(innerHTML(lis[4]), '4 e', 'fifth index and value are correct');
                list.splice(0, 2, 'z', 'y');
                lis = tpl.getElementsByTagName('li');
                equal(lis.length, 5, 'five lis');
                equal(innerHTML(lis[0]), '0 z', 'first item updated');
                equal(innerHTML(lis[1]), '1 y', 'second item updated');
                equal(innerHTML(lis[2]), '2 c', 'third item the same');
                equal(innerHTML(lis[3]), '3 d', 'fourth item the same');
                equal(innerHTML(lis[4]), '4 e', 'fifth item the same');
                list.splice(2, 2);
                lis = tpl.getElementsByTagName('li');
                equal(lis.length, 3, 'three lis');
                equal(innerHTML(lis[0]), '0 z', 'first item the same');
                equal(innerHTML(lis[1]), '1 y', 'second item the same');
                equal(innerHTML(lis[2]), '2 e', 'fifth item now the 3rd item');
            });
            test('Rendering keys of an object with #each and @key', function () {
                var template = stache('<ul>{{#each obj}}<li>{{@key}} {{.}}</li>{{/each}}</ul>');
                var obj = {
                    foo: 'string',
                    bar: 1,
                    baz: false
                };
                var lis = template({ obj: obj }).firstChild.getElementsByTagName('li');
                equal(lis.length, 3, 'three lis');
                equal(innerHTML(lis[0]), 'foo string', 'first key value pair rendered');
                equal(innerHTML(lis[1]), 'bar 1', 'second key value pair rendered');
                equal(innerHTML(lis[2]), 'baz false', 'third key value pair rendered');
            });
            test('Live bound iteration of keys of a CanMap with #each and @key', function () {
                var template = stache('<ul>{{#each map}}<li>{{@key}} {{.}}</li>{{/each}}</ul>');
                var map = new CanMap({
                    foo: 'string',
                    bar: 1,
                    baz: false
                });
                var tpl = template({ map: map });
                var lis = tpl.firstChild.getElementsByTagName('li');
                equal(lis.length, 3, 'three lis');
                equal(innerHTML(lis[0]), 'foo string', 'first key value pair rendered');
                equal(innerHTML(lis[1]), 'bar 1', 'second key value pair rendered');
                equal(innerHTML(lis[2]), 'baz false', 'third key value pair rendered');
                map.attr('qux', true);
                lis = tpl.firstChild.getElementsByTagName('li');
                equal(lis.length, 4, 'four lis');
                equal(innerHTML(lis[3]), 'qux true', 'fourth key value pair rendered');
                map.removeAttr('foo');
                lis = tpl.firstChild.getElementsByTagName('li');
                equal(lis.length, 3, 'three lis');
                equal(innerHTML(lis[0]), 'bar 1', 'new first key value pair rendered');
                equal(innerHTML(lis[1]), 'baz false', 'new second key value pair rendered');
                equal(innerHTML(lis[2]), 'qux true', 'new third key value pair rendered');
            });
            test('Make sure data passed into template does not call helper by mistake', function () {
                var template = stache('<h1>{{text}}</h1>');
                var data = { text: 'with' };
                var h1 = template(data).firstChild;
                equal(innerHTML(h1), 'with');
            });
            test('no memory leaks with #each (#545)', function () {
                var tmp = stache('<ul id=\'ul-remove\'>{{#each children}}<li></li>{{/each}}</ul>');
                var data = new CanMap({
                    children: [
                        { name: 'A1' },
                        { name: 'A2' },
                        { name: 'A3' }
                    ]
                });
                var div = doc.createElement('div');
                this.fixture.appendChild(div);
                div.id = 'div-remove';
                domMutate.appendChild.call(div, tmp(data));
                stop();
                setTimeout(function () {
                    domMutate.removeChild.call(div, div.firstChild);
                    setTimeout(function () {
                        equal(data.__bindEvents._lifecycleBindings, 0, 'there are no bindings');
                        start();
                    }, 30);
                }, 10);
            });
            test('each directly within live html section', function () {
                var tmp = stache('<ul>{{#if showing}}' + '{{#each items}}<li>item</li>{{/items}}' + '{{/if}}</ul>');
                var items = new CanList([
                    1,
                    2,
                    3
                ]);
                var showing = canCompute(true);
                var frag = tmp({
                    showing: showing,
                    items: items
                });
                showing(false);
                items.pop();
                showing(true);
                items.push('a');
                equal(frag.firstChild.getElementsByTagName('li').length, 3, 'there are 3 elements');
            });
            test('mustache loops with 0 (#568)', function () {
                var tmp = stache('<ul>{{#array}}<li>{{.}}</li>{{/array}}');
                var data = {
                    array: [
                        0,
                        null
                    ]
                };
                var frag = tmp(data);
                equal(innerHTML(frag.firstChild.getElementsByTagName('li')[0]), '0');
                equal(innerHTML(frag.firstChild.getElementsByTagName('li')[1]), '');
            });
            test('@index is correctly calculated when there are identical elements in the array', function () {
                var data = new CanList([
                    'foo',
                    'bar',
                    'baz',
                    'qux',
                    'foo'
                ]);
                var tmp = stache('{{#each data}}{{@index}} {{/each}}');
                var div = doc.createElement('div');
                var frag = tmp({ data: data });
                div.appendChild(frag);
                equal(innerHTML(div), '0 1 2 3 4 ');
            });
            test('if helper within className (#592)', function () {
                var tmp = stache('<div class="fails {{#state}}animate-{{.}}{{/state}}"></div>');
                var data = new CanMap({ state: 'ready' });
                var frag = tmp(data);
                equal(frag.firstChild.className, 'fails animate-ready');
                tmp = stache('<div class="fails {{#if state}}animate-{{state}}{{/if}}"></div>');
                data = new CanMap({ state: 'ready' });
                tmp(data);
                equal(frag.firstChild.className, 'fails animate-ready');
            });
            test('html comments must not break mustache scanner', function () {
                canEach([
                    'text<!-- comment -->',
                    'text<!-- comment-->',
                    'text<!--comment -->',
                    'text<!--comment-->'
                ], function (content) {
                    var div = doc.createElement('div');
                    div.appendChild(stache(content)());
                    equal(innerHTML(div), content, 'Content did not change: "' + content + '"');
                });
            });
            test('Rendering live bound indicies with #each, @index and a simple CanList when remove first item (#613)', function () {
                var list = new CanList([
                    'a',
                    'b',
                    'c'
                ]);
                var template = stache('<ul>{{#each list}}<li>{{@index}} {{.}}</li>{{/each}}</ul>');
                var tpl = template({ list: list });
                list.shift();
                var lis = tpl.firstChild.getElementsByTagName('li');
                equal(lis.length, 2, 'two lis');
                equal(innerHTML(lis[0]), '0 b', 'second item now the 1st item');
                equal(innerHTML(lis[1]), '1 c', 'third item now the 2nd item');
            });
            test('stache.safestring works on live binding (#606)', function () {
                var num = canCompute(1);
                stache.registerHelper('safeHelper', function () {
                    return stache.safeString('<p>' + num() + '</p>');
                });
                var template = stache('<div>{{safeHelper}}</div>');
                var frag = template();
                equal(frag.firstChild.firstChild.nodeName.toLowerCase(), 'p', 'got a p element');
            });
            test('directly nested subitems and each (#605)', function () {
                var template = stache('<div>' + '{{#item}}' + '<p>This is the item:</p>' + '{{#each subitems}}' + '<label>' + 'item' + '</label>' + '{{/each}}' + '{{/item}}' + '</div>');
                var data = new CanMap({ item: { subitems: ['first'] } });
                var frag = template(data), div = frag.firstChild, labels = div.getElementsByTagName('label');
                equal(labels.length, 1, 'initially one label');
                data.attr('item.subitems').push('second');
                labels = div.getElementsByTagName('label');
                equal(labels.length, 2, 'after pushing two label');
                data.removeAttr('item');
                labels = div.getElementsByTagName('label');
                equal(labels.length, 0, 'after removing item no label');
            });
            test('directly nested live sections unbind without needing the element to be removed', function () {
                var template = stache('<div>' + '{{#items}}' + '<p>first</p>' + '{{#visible}}<label>foo</label>{{/visible}}' + '<p>second</p>' + '{{/items}}' + '</div>');
                var data = new CanMap({ items: [{ visible: true }] });
                var bindings = 0;
                function addEventListener(eventType) {
                    bindings++;
                    return CanMap.prototype.addEventListener.apply(this, arguments);
                }
                function removeEventListener(eventType) {
                    CanMap.prototype.removeEventListener.apply(this, arguments);
                    bindings--;
                    if (eventType === 'visible') {
                        ok(true, 'unbound visible');
                    }
                    if (bindings === 0) {
                        start();
                        ok(true, 'unbound visible');
                    }
                }
                data.attr('items.0').addEventListener = addEventListener;
                data.attr('items.0').removeEventListener = removeEventListener;
                template(data);
                data.attr('items', [{ visible: true }]);
                stop();
            });
            test('direct live section', function () {
                var template = stache('{{#if visible}}<label/>{{/if}}');
                var data = new CanMap({ visible: true });
                var div = doc.createElement('div');
                div.appendChild(template(data));
                equal(div.getElementsByTagName('label').length, 1, 'there are 1 items');
                data.attr('visible', false);
                equal(div.getElementsByTagName('label').length, 0, 'there are 0 items');
            });
            test('Rendering keys of an object with #each and @key in a Component', function () {
                var template = stache('<ul>' + '{{#each data}}' + '<li>{{@key}} : {{.}}</li>' + '{{/data}}' + '</ul>');
                var map = new CanMap({
                    data: {
                        some: 'test',
                        things: false,
                        other: 'things'
                    }
                });
                var frag = template(map);
                var lis = frag.firstChild.getElementsByTagName('li');
                equal(lis.length, 3, 'there are 3 properties of map\'s data property');
                equal(innerHTML(lis[0]), 'some : test');
            });
            test('{{each}} does not error with undefined list (#602)', function () {
                var text = '<div>{{#each data}}{{name}}{{/each}}</div>';
                equal(getText(text, {}), '<div></div>', 'Empty text rendered');
                equal(getText(text, { data: false }), '<div></div>', 'Empty text rendered');
                equal(getText(text, { data: null }), '<div></div>', 'Empty text rendered');
                equal(getText(text, { data: [{ name: 'David' }] }), '<div>David</div>', 'Expected name rendered');
            });
            test('{{#each}} helper works reliably with nested sections (#604)', function () {
                var renderer = stache('{{#if first}}<ul>{{#each list}}<li>{{name}}</li>{{/each}}</ul>' + '{{else}}<ul>{{#each list2}}<li>{{name}}</li>{{/each}}</ul>{{/if}}');
                var data = new CanMap({
                    first: true,
                    list: [
                        { name: 'Something' },
                        { name: 'Else' }
                    ],
                    list2: [
                        { name: 'Foo' },
                        { name: 'Bar' }
                    ]
                });
                var div = doc.createElement('div');
                var frag = renderer(data);
                div.appendChild(frag);
                var lis = div.getElementsByTagName('li');
                deepEqual(makeArray(lis).map(function (li) {
                    return innerHTML(li);
                }), [
                    'Something',
                    'Else'
                ], 'Expected HTML with first set');
                data.attr('first', false);
                lis = div.getElementsByTagName('li');
                deepEqual(makeArray(lis).map(function (li) {
                    return innerHTML(li);
                }), [
                    'Foo',
                    'Bar'
                ], 'Expected HTML with first false set');
            });
            test('Block bodies are properly escaped inside attributes', function () {
                var html = '<div title=\'{{#test}}{{.}}{{{.}}}{{/test}}\'></div>', div = doc.createElement('div'), title = 'Alpha&Beta';
                var frag = stache(html)(new CanMap({ test: title }));
                div.appendChild(frag);
                equal(div.firstChild.getAttribute('title'), title + title);
            });
            test('Constructor static properties are accessible (#634)', function () {
                var Foo = CanMap.extend('Foo', { static_prop: 'baz' }, { proto_prop: 'thud' });
                var template = '                  Straight access: <br/>                       <span>{{own_prop}}</span><br/>                       <span>{{constructor.static_prop}}</span><br/>                       <span>{{constructor.proto_prop}}</span><br/>                       <span>{{proto_prop}}</span><br/>                   Helper argument: <br/>                       <span>{{print_prop own_prop}}</span><br/>                       <span>{{print_prop constructor.static_prop}}</span><br/>                       <span>{{print_prop constructor.proto_prop}}</span><br/>                       <span>{{print_prop proto_prop}}</span><br/>                   Helper hash argument: <br/>                       <span>{{print_hash prop=own_prop}}</span><br/>                       <span>{{print_hash prop=constructor.static_prop}}</span><br/>                       <span>{{print_hash prop=constructor.proto_prop}}</span><br/>                       <span>{{print_hash prop=proto_prop}}</span><br/>', renderer = stache(template), data = new Foo({ own_prop: 'quux' }), div = doc.createElement('div');
                div.appendChild(renderer(data, {
                    print_prop: function (arg) {
                        return arg && arg.isComputed ? arg() : arg;
                    },
                    print_hash: function () {
                        var ret = [];
                        canEach(arguments[arguments.length - 1].hash, function (arg, key) {
                            while (arg && arg.isComputed) {
                                arg = arg();
                            }
                            ret.push([
                                key,
                                arg
                            ].join('='));
                        });
                        return ret.join(' ');
                    }
                }));
                var spans = div.getElementsByTagName('span'), i = 0;
                equal(innerHTML(spans[i++]), 'quux', 'Expected "quux"');
                equal(innerHTML(spans[i++]), 'baz', 'Expected "baz"');
                equal(innerHTML(spans[i++]), '', 'Expected ""');
                equal(innerHTML(spans[i++]), 'thud', 'Expected "thud"');
                equal(innerHTML(spans[i++]), 'quux', 'Expected "quux"');
                equal(innerHTML(spans[i++]), 'baz', 'Expected "baz"');
                equal(innerHTML(spans[i++]), '', 'Expected ""');
                equal(innerHTML(spans[i++]), 'thud', 'Expected "thud"');
                equal(innerHTML(spans[i++]), 'prop=quux', 'Expected "prop=quux"');
                equal(innerHTML(spans[i++]), 'prop=baz', 'Expected "prop=baz"');
                equal(innerHTML(spans[i++]), 'prop=', 'Expected "prop="');
                equal(innerHTML(spans[i++]), 'prop=thud', 'Expected "prop=thud"');
            });
            test('{{#each}} handles an undefined list changing to a defined list (#629)', function () {
                var renderer = stache('    {{description}}:           <ul>           {{#each list}}                   <li>{{name}}</li>           {{/each}}           </ul>');
                var div = doc.createElement('div'), data1 = new CanMap({ description: 'Each without list' }), data2 = new CanMap({
                        description: 'Each with empty list',
                        list: []
                    });
                div.appendChild(renderer(data1));
                div.appendChild(renderer(data2));
                equal(div.getElementsByTagName('ul')[0].getElementsByTagName('li').length, 0, 'there are no lis in the undefined list');
                equal(div.getElementsByTagName('ul')[1].getElementsByTagName('li').length, 0, 'there are no lis in the empty list');
                stop();
                setTimeout(function () {
                    start();
                    data1.attr('list', [{ name: 'first' }]);
                    data2.attr('list', [{ name: 'first' }]);
                    equal(div.getElementsByTagName('ul')[0].getElementsByTagName('li').length, 1, 'there should be an li as we set an attr to an array');
                    equal(div.getElementsByTagName('ul')[1].getElementsByTagName('li').length, 1);
                    equal(innerHTML(div.getElementsByTagName('ul')[0].getElementsByTagName('li')[0]), 'first');
                    equal(innerHTML(div.getElementsByTagName('ul')[1].getElementsByTagName('li')[0]), 'first');
                }, 250);
            });
            test('canCompute should live bind when the value is changed to a Construct (#638)', function () {
                var renderer = stache('<p>{{#counter}} Clicked <span>{{count}}</span> times {{/counter}}</p>'), div = doc.createElement('div'), counter = canCompute(), data = { counter: counter };
                div.appendChild(renderer(data));
                equal(div.getElementsByTagName('span').length, 0);
                stop();
                setTimeout(function () {
                    start();
                    counter({ count: 1 });
                    equal(div.getElementsByTagName('span').length, 1);
                    equal(innerHTML(div.getElementsByTagName('span')[0]), '1');
                }, 10);
            });
            test('@index in partials loaded from script templates', function () {
                if (doc === window.document) {
                    var script = doc.createElement('script');
                    script.type = 'text/mustache';
                    script.id = 'itempartial';
                    script.text = '<label></label>';
                    doc.body.appendChild(script);
                    var itemsTemplate = stache('<div>' + '{{#each items}}' + '{{>itempartial}}' + '{{/each}}' + '</div>');
                    var items = new CanList([
                        {},
                        {}
                    ]);
                    var frag = itemsTemplate({ items: items }), div = frag.firstChild, labels = div.getElementsByTagName('label');
                    equal(labels.length, 2, 'two labels');
                    items.shift();
                    labels = div.getElementsByTagName('label');
                    equal(labels.length, 1, 'first label removed');
                } else {
                    expect(0);
                }
            });
            test('#each with #if directly nested (#750)', function () {
                var template = stache('<ul>{{#each list}} {{#if visible}}<li>{{name}}</li>{{/if}} {{/each}}</ul>');
                var data = new CanMap({
                    list: [
                        {
                            name: 'first',
                            visible: true
                        },
                        {
                            name: 'second',
                            visible: false
                        },
                        {
                            name: 'third',
                            visible: true
                        }
                    ]
                });
                var frag = template(data);
                data.attr('list').pop();
                equal(frag.firstChild.getElementsByTagName('li').length, 1, 'only first should be visible');
            });
            test('viewCallbacks.tag', function () {
                expect(4);
                viewCallbacks.tag('stache-tag', function (el, tagData) {
                    ok(tagData.scope instanceof Scope, 'got scope');
                    ok(tagData.options instanceof Scope, 'got options');
                    equal(typeof tagData.subtemplate, 'function', 'got subtemplate');
                    var frag = tagData.subtemplate(tagData.scope.add({ last: 'Meyer' }), tagData.options);
                    equal(innerHTML(frag.firstChild), 'Justin Meyer', 'rendered right');
                });
                var template = stache('<stache-tag><span>{{first}} {{last}}</span></stache-tag>');
                template({ first: 'Justin' });
            });
            test('viewCallbacks.attr', function () {
                expect(3);
                viewCallbacks.attr('stache-attr', function (el, attrData) {
                    ok(attrData.scope instanceof Scope, 'got scope');
                    ok(attrData.options instanceof Scope, 'got options');
                    equal(attrData.attributeName, 'stache-attr', 'got attribute name');
                });
                var template = stache('<div stache-attr=\'foo\'></div>');
                template({});
            });
            test('./ in key', function () {
                var template = stache('<div><label>{{name}}</label>{{#children}}<span>{{./name}}-{{name}}</span>{{/children}}</div>');
                var data = {
                    name: 'CanJS',
                    children: [
                        {},
                        { name: 'stache' }
                    ]
                };
                var res = template(data);
                var spans = res.firstChild.getElementsByTagName('span');
                equal(innerHTML(spans[0]), '-CanJS', 'look in current level');
                equal(innerHTML(spans[1]), 'stache-stache', 'found in current level');
            });
            test('self closing tags callback custom tag callbacks (#880)', function () {
                viewCallbacks.tag('stache-tag', function (el, tagData) {
                    ok(true, 'tag callback called');
                    equal(tagData.scope.peek('.').foo, 'bar', 'got scope');
                    ok(!tagData.subtemplate, 'there is no subtemplate');
                });
                var template = stache('<div><stache-tag/></div>');
                template({ foo: 'bar' });
            });
            test('empty custom tags do not have a subtemplate (#880)', function () {
                viewCallbacks.tag('stache-tag', function (el, tagData) {
                    ok(true, 'tag callback called');
                    equal(tagData.scope.peek('.').foo, 'bar', 'got scope');
                    ok(!tagData.subtemplate, 'there is no subtemplate');
                });
                var template = stache('<div><stache-tag></stache-tag></div>');
                template({ foo: 'bar' });
            });
            test('inverse in tag', function () {
                var template = stache('<span {{^isBlack}} style="display:none"{{/if}}>Hi</span>');
                var res = template({ isBlack: false });
                ok(/display:\s*none/.test(res.firstChild.getAttribute('style')), 'display none is not set');
            });
            test('Calling .fn without arguments should forward scope by default (#658)', function () {
                var tmpl = '{{#foo}}<span>{{bar}}</span>{{/foo}}';
                var frag = stache(tmpl)(new CanMap({ bar: 'baz' }), {
                    foo: function (opts) {
                        return opts.fn();
                    }
                });
                var node = frag.firstChild;
                equal(innerHTML(node), 'baz', 'Context is forwarded correctly');
            });
            test('Calling .fn with falsy value as the context will render correctly (#658)', function () {
                var tmpl = '{{#zero}}<span>{{ . }}</span>{{/zero}}{{#emptyString}}<span>{{ . }}</span>{{/emptyString}}{{#nullVal}}<span>{{ . }}</span>{{/nullVal}}';
                var frag = stache(tmpl)({ foo: 'bar' }, {
                    zero: function (opts) {
                        return opts.fn(0);
                    },
                    emptyString: function (opts) {
                        return opts.fn('');
                    },
                    nullVal: function (opts) {
                        return opts.fn(null);
                    }
                });
                equal(innerHTML(frag.firstChild), '0', 'Context is set correctly for falsy values');
                equal(innerHTML(frag.childNodes.item(1)), '', 'Context is set correctly for falsy values');
                equal(innerHTML(frag.childNodes.item(2)), '', 'Context is set correctly for falsy values');
            });
            test('Custom elements created with default namespace in IE8', function () {
                viewCallbacks.tag('my-tag', function () {
                });
                var tmpl = '<my-tag></my-tag>';
                var frag = stache(tmpl)({});
                this.fixture.appendChild(frag);
                equal(this.fixture.getElementsByTagName('my-tag').length, 1, 'Element created in default namespace');
            });
            test('Partials are passed helpers (#791)', function () {
                var t = {
                        template: '{{>partial}}',
                        expected: 'foo',
                        partials: { partial: '{{ help }}' },
                        helpers: {
                            'help': function () {
                                return 'foo';
                            }
                        }
                    }, frag;
                for (var name in t.partials) {
                    stache.registerPartial(name, t.partials[name]);
                }
                frag = stache(t.template)({}, t.helpers);
                equal(frag.firstChild.nodeValue, t.expected);
            });
            test('{{else}} with {{#unless}} (#988)', function () {
                var tmpl = '<div>{{#unless noData}}data{{else}}no data{{/unless}}</div>';
                var frag = stache(tmpl)({ noData: true });
                equal(innerHTML(frag.firstChild), 'no data', 'else with unless worked');
            });
            test('{{else}} within an attribute (#974)', function () {
                var tmpl = '<div class="{{#if color}}{{color}}{{else}}red{{/if}}"></div>', data = new CanMap({ color: 'orange' }), frag = stache(tmpl)(data);
                equal(frag.firstChild.className, 'orange', 'if branch');
                data.attr('color', false);
                equal(frag.firstChild.className, 'red', 'else branch');
            });
            test('returns correct value for DOM attributes (#1065)', 3, function () {
                var template = '<h2 class="{{#if shown}}foo{{/if}} test1 {{#shown}}muh{{/shown}}"></h2>' + '<h3 class="{{#if shown}}bar{{/if}} test2 {{#shown}}kuh{{/shown}}"></h3>' + '<h4 class="{{#if shown}}baz{{/if}} test3 {{#shown}}boom{{/shown}}"></h4>';
                var frag = stache(template)({ shown: true });
                equal(frag.firstChild.className, 'foo test1 muh');
                equal(frag.childNodes.item(1).className, 'bar test2 kuh');
                equal(frag.childNodes.item(2).className, 'baz test3 boom');
            });
            test('single character attributes work (#1132)', function () {
                if (doc.createElementNS) {
                    var template = '<svg width="50" height="50">' + '<circle r="25" cx="25" cy="25"></circle>' + '</svg>';
                    var frag = stache(template)({});
                    equal(frag.firstChild.firstChild.getAttribute('r'), '25');
                } else {
                    expect(0);
                }
            });
            test('single property read does not infinitely loop (#1155)', function () {
                stop();
                var map = new CanMap({ state: false });
                var current = false;
                var source = canCompute(1);
                var number = canCompute(function () {
                    map.attr('state', current = !current);
                    return source();
                });
                number.bind('change', function () {
                });
                var template = stache('<div>{{#if map.state}}<span>Hi</span>{{/if}}</div>');
                template({ map: map });
                source(2);
                map.attr('state', current = !current);
                ok(true, 'no error at this point');
                start();
            });
            test('methods become observable (#1164)', function () {
                var TeamModel = CanMap.extend({
                    shortName: function () {
                        return this.attr('nickname') && this.attr('nickname').length <= 8 ? this.attr('nickname') : this.attr('abbreviation');
                    }
                });
                var team = new TeamModel({
                    nickname: 'Arsenal London',
                    abbreviation: 'ARS'
                });
                var template = stache('<span>{{team.shortName}}</span>');
                var frag = template({ team: team });
                equal(innerHTML(frag.firstChild), 'ARS', 'got value');
            });
            test('<col> inside <table> renders correctly (#1013)', 1, function () {
                var template = '<table><colgroup>{{#columns}}<col class="{{class}}" />{{/columns}}</colgroup><tbody></tbody></table>';
                var frag = stache(template)({ columns: new CanList([{ 'class': 'test' }]) });
                var index = getChildNodes(frag).length === 2 ? 1 : 0;
                var tagName = frag.childNodes.item(index).firstChild.firstChild.tagName.toLowerCase();
                equal(tagName, 'col', '<col> nodes added in proper position');
            });
            test('splicing negative indices works (#1038)', function () {
                var template = '{{#each list}}<p>{{.}}</p>{{/each}}';
                var list = new CanList([
                    'a',
                    'b',
                    'c',
                    'd'
                ]);
                var frag = stache(template)({ list: list });
                var children = getChildNodes(frag).length;
                list.splice(-1);
                equal(getChildNodes(frag).length, children - 1, 'Child node removed');
            });
            test('stache can accept an intermediate (#1387)', function () {
                var template = '<div class=\'{{className}}\'>{{message}}</div>';
                var intermediate = parser(template, {}, true);
                var renderer = stache(intermediate);
                var frag = renderer({
                    className: 'foo',
                    message: 'bar'
                });
                equal(frag.firstChild.className, 'foo', 'correct class name');
                equal(innerHTML(frag.firstChild), 'bar', 'correct innerHTMl');
            });
            test('Passing Partial set in options (#1388 and #1389). Support live binding of partial', function () {
                var data = new CanMap({
                    name: 'World',
                    greeting: 'hello'
                });
                stache.registerPartial('hello', 'hello {{name}}', '.stache');
                stache.registerPartial('goodbye', 'goodbye {{name}}', '.stache');
                var template = stache('<div>{{>greeting}}</div>')(data);
                var div = doc.createElement('div');
                div.appendChild(template);
                equal(innerHTML(div.firstChild), 'hello World', 'partial retreived and rendered');
                data.attr('greeting', 'goodbye');
                equal(innerHTML(div.firstChild), 'goodbye World', 'Partial updates when attr is updated');
            });
            test('#each with null or undefined and then a list', function () {
                var template = stache('<ul>{{#each items}}<li>{{name}}</li>{{/each}}');
                var data = new CanMap({ items: null });
                var frag = template(data);
                var div = doc.createElement('div');
                div.appendChild(frag);
                data.attr('items', [{ name: 'foo' }]);
                equal(div.getElementsByTagName('li').length, 1, 'li added');
            });
            test('promises work (#179)', function () {
                var template = stache('{{#if promise.isPending}}<span class=\'pending\'></span>{{/if}}' + '{{#if promise.isRejected}}<span class=\'rejected\'>{{promise.reason.message}}</span>{{/if}}' + '{{#if promise.isResolved}}<span class=\'resolved\'>{{promise.value.message}}</span>{{/if}}');
                var def = {};
                var promise = new Promise(function (resolve, reject) {
                    def.resolve = resolve;
                    def.reject = reject;
                });
                var data = { promise: promise };
                var frag = template(data);
                var rootDiv = doc.createElement('div');
                rootDiv.appendChild(frag);
                var spans = rootDiv.getElementsByTagName('span');
                equal(spans.length, 1);
                equal(spans[0].getAttribute('class'), 'pending');
                stop();
                def.resolve({ message: 'Hi there' });
                setTimeout(function () {
                    spans = rootDiv.getElementsByTagName('span');
                    equal(spans.length, 1);
                    equal(spans[0].getAttribute('class'), 'resolved');
                    equal(innerHTML(spans[0]), 'Hi there');
                    var def = {};
                    var promise = new Promise(function (resolve, reject) {
                        def.resolve = resolve;
                        def.reject = reject;
                    });
                    var data = { promise: promise };
                    var frag = template(data);
                    var div = doc.createElement('div');
                    div.appendChild(frag);
                    spans = div.getElementsByTagName('span');
                    def.reject({ message: 'BORKED' });
                    setTimeout(function () {
                        spans = div.getElementsByTagName('span');
                        equal(spans.length, 1);
                        equal(spans[0].getAttribute('class'), 'rejected');
                        equal(innerHTML(spans[0]), 'BORKED');
                        start();
                    }, 30);
                }, 30);
            });
            test('{#list} works right (#1551)', function () {
                var data = new CanMap({});
                var template = stache('<div>{{#items}}<span/>{{/items}}</div>');
                var frag = template(data);
                data.attr('items', new CanList());
                data.attr('items').push('foo');
                var spans = frag.firstChild.getElementsByTagName('span');
                equal(spans.length, 1, 'one span');
            });
            test('promises are not rebound (#1572)', function () {
                stop();
                var d = {};
                var promise = new Promise(function (resolve, reject) {
                    d.resolve = resolve;
                    d.reject = reject;
                });
                var compute = canCompute(promise);
                var template = stache('<div>{{#if promise.isPending}}<span/>{{/if}}</div>');
                var frag = template({ promise: compute });
                var div = frag.firstChild, spans = div.getElementsByTagName('span');
                var d2 = {};
                var promise2 = new Promise(function (resolve, reject) {
                    d2.resolve = resolve;
                    d2.reject = reject;
                });
                compute(promise2);
                setTimeout(function () {
                    d2.resolve('foo');
                    setTimeout(function () {
                        spans = div.getElementsByTagName('span');
                        equal(spans.length, 0, 'there should be no spans');
                        start();
                    }, 30);
                }, 10);
            });
            test('reading alternate values on promises (#1572)', function () {
                var promise = new Promise(function (resolve, reject) {
                });
                promise.myAltProp = 'AltValue';
                var template = stache('<div>{{d.myAltProp}}</div>');
                var frag = template({ d: promise });
                equal(innerHTML(frag.firstChild), 'AltValue', 'read value');
            });
            test('possible to teardown immediate nodeList (#1593)', function () {
                expect(3);
                var map = new CanMap({ show: true });
                var oldBind = map.addEventListener, oldUnbind = map.removeEventListener;
                map.addEventListener = function () {
                    ok(true, 'bound', 'bound');
                    return oldBind.apply(this, arguments);
                };
                map.removeEventListener = function () {
                    ok(true, 'unbound', 'unbound');
                    return oldUnbind.apply(this, arguments);
                };
                var template = stache('{{#if show}}<span/>TEXT{{/if}}');
                var nodeList = nodeLists.register([], undefined, true);
                var frag = template(map, {}, nodeList);
                nodeLists.update(nodeList, getChildNodes(frag));
                equal(nodeList.length, 1, 'our nodeList has the nodeList of #if show');
                nodeLists.unregister(nodeList);
                stop();
                setTimeout(function () {
                    start();
                }, 10);
            });
            test('#1590 #each with surrounding block and setter', function () {
                var product = canCompute();
                var people = canCompute(function () {
                    var newList = new CanList();
                    newList.replace(['Brian']);
                    return newList;
                });
                var frag = stache('<div>{{#if product}}<div>{{#each people}}<span/>{{/each}}</div>{{/if}}</div>')({
                    people: people,
                    product: product
                });
                canBatch.start();
                product(1);
                canBatch.stop();
                equal(frag.firstChild.getElementsByTagName('span').length, 1, 'no duplicates');
            });
            if (doc.createElementNS && System.env !== 'canjs-test') {
                test('svg elements for (#1327)', function () {
                    var template = stache('<svg height="120" width="400">' + '<circle cx="50" cy="50" r="{{radius}}" stroke="black" stroke-width="3" fill="blue" />' + '</svg>');
                    var frag = template({ radius: 6 });
                    equal(frag.firstChild.namespaceURI, 'http://www.w3.org/2000/svg', 'svg namespace');
                });
            }
            test('using #each when toggling between list and null', function () {
                var state = new CanMap();
                var frag = stache('{{#each deepness.rows}}<div></div>{{/each}}')(state);
                state.attr('deepness', { rows: ['test'] });
                state.attr('deepness', null);
                equal(getChildNodes(frag).length, 1, 'only the placeholder textnode');
            });
            test('compute defined after template (#1617)', function () {
                var myMap = new CanMap();
                var frag = stache('<span>{{ myMap.test }}</span>')({ myMap: myMap });
                myMap.attr('test', canCompute(function () {
                    return 'def';
                }));
                equal(frag.firstChild.firstChild.nodeValue, 'def', 'correct value');
            });
            test('template with a block section and nested if doesnt render correctly', function () {
                var myMap = new CanMap({ bar: true });
                var frag = stache('{{#bar}}<div>{{#if foo}}My Meals{{else}}My Order{{/if}}</div>{{/bar}}')(myMap);
                equal(innerHTML(frag.firstChild), 'My Order', 'shows else case');
                myMap.attr('foo', true);
                equal(innerHTML(frag.firstChild), 'My Meals', 'shows if case');
            });
            test('registerSimpleHelper', 3, function () {
                var template = stache('<div>Result: {{simple first second}}</div>');
                stache.registerSimpleHelper('simple', function (first, second) {
                    equal(first, 2);
                    equal(second, 4);
                    return first + second;
                });
                var frag = template(new CanMap({
                    first: 2,
                    second: 4
                }));
                equal(innerHTML(frag.firstChild), 'Result: 6');
            });
            test('Helper handles list replacement (#1652)', 3, function () {
                var state = new CanMap({ list: [] });
                var helpers = {
                    listHasLength: function (options) {
                        ok(true, 'listHasLength helper evaluated');
                        return this.attr('list').attr('length') ? options.fn() : options.inverse();
                    }
                };
                stache('{{#listHasLength}}{{/listHasLength}}')(state, helpers);
                state.attr('list', []);
                state.attr('list').push('...');
            });
            test('Helper binds to nested properties (#1651)', function () {
                var nestedAttrsCount = 0, state = new CanMap({ parent: null });
                var helpers = {
                    bindViaNestedAttrs: function (options) {
                        nestedAttrsCount++;
                        if (nestedAttrsCount === 3) {
                            ok(true, 'bindViaNestedAttrs helper evaluated 3 times');
                        }
                        return this.attr('parent') && this.attr('parent').attr('child') ? options.fn() : options.inverse();
                    }
                };
                stache('{{#bindViaNestedAttrs}}{{/bindViaNestedAttrs}}')(state, helpers);
                state.attr('parent', { child: 'foo' });
                state.attr('parent.child', 'bar');
            });
            test('Using a renderer function as a partial', function () {
                var template = stache('{{> other}}');
                var partial = stache('hello there');
                var map = new CanMap({ other: null });
                var frag = template(map);
                equal(frag.firstChild.nodeValue, '', 'Initially it is a blank textnode');
                map.attr('other', partial);
                equal(frag.firstChild.nodeValue, 'hello there', 'partial rendered');
            });
            test('Handlebars helper: switch/case', function () {
                var expected;
                var t = {
                    template: '{{#switch ducks}}{{#case "10"}}10 ducks{{/case}}' + '{{#default}}Not 10 ducks{{/default}}{{/switch}}',
                    expected: '10 ducks',
                    data: {
                        ducks: '10',
                        tenDucks: function () {
                            return '10';
                        }
                    },
                    liveData: new CanMap({
                        ducks: '10',
                        tenDucks: function () {
                            return '10';
                        }
                    })
                };
                expected = t.expected.replace(/&quot;/g, '&#34;').replace(/\r\n/g, '\n');
                deepEqual(getText(t.template, t.data), expected);
                deepEqual(getText(t.template, t.liveData), expected);
                t.data.ducks = 5;
                deepEqual(getText(t.template, t.data), 'Not 10 ducks');
            });
            test('Handlerbars helper: switch - changing to default (#1857)', function () {
                var template = stache('{{#switch ducks}}{{#case "10"}}10 ducks{{/case}}' + '{{#default}}Not 10 ducks{{/default}}{{/switch}}');
                var map = new CanMap({ ducks: '10' });
                var frag = template(map);
                deepEqual(getTextFromFrag(frag), '10 ducks');
                map.attr('ducks', '12');
                deepEqual(getTextFromFrag(frag), 'Not 10 ducks');
            });
            test('joinBase helper joins to the baseURL', function () {
                var baseUrl = System.baseURL || getBaseURL();
                var template = stache('{{joinBase \'hello/\' name}}');
                var map = new CanMap({ name: 'world' });
                var frag = template(map);
                equal(frag.firstChild.nodeValue, joinURIs(baseUrl, 'hello/world'), 'joined from baseUrl');
            });
            test('joinBase helper can be relative to template module', function () {
                var baseUrl = 'http://foocdn.com/bitovi';
                var template = stache('{{joinBase \'../hello/\' name}}');
                var map = new CanMap({ name: 'world' });
                var frag = template(map, { module: { uri: baseUrl } });
                equal(frag.firstChild.nodeValue, 'http://foocdn.com/hello/world', 'relative lookup works');
            });
            test('Custom attribute callbacks are called when in a conditional within a live section', 8, function () {
                viewCallbacks.attr('test-attr', function (el, attrData) {
                    ok(true, 'test-attr called');
                    equal(attrData.attributeName, 'test-attr', 'attributeName set correctly');
                    ok(attrData.scope, 'scope isn\'t undefined');
                    ok(attrData.options, 'options isn\'t undefined');
                });
                var state = new CanMap({ showAttr: true });
                var template = stache('<button id="find-me" {{#if showAttr}}test-attr{{/if}}></button>');
                template(state);
                state.attr('showAttr', false);
                state.attr('showAttr', true);
            });
            test('inner expressions (#1769)', function () {
                var template = stache('{{helperA helperB(1,valueA,propA=valueB propC=2) \'def\' outerPropA=helperC(2, ~valueB)}}');
                var frag = template(new CanMap({
                    valueA: 'A',
                    valueB: 'B'
                }), {
                    helperA: function (arg1, arg2, options) {
                        equal(arg1(), 'helperB value', 'call expression argument to helperA');
                        equal(arg2, 'def', 'scope argument');
                        equal(options.hash.outerPropA(), 'helperC value', 'scope hash');
                        return 'helperA value';
                    },
                    helperB: function (arg1, arg2, options) {
                        equal(arg1, 1, 'static argument');
                        equal(arg2, 'A', 'scope argument');
                        equal(options.propA, 'B', 'scope hash');
                        equal(options.propC, 2, 'static hash');
                        return 'helperB value';
                    },
                    helperC: function (arg1, arg2) {
                        equal(arg1, 2, 'helperC static argument');
                        equal(arg2(), 'B', 'helperC scope argument');
                        return 'helperC value';
                    }
                });
                equal(frag.firstChild.nodeValue, 'helperA value');
            });
            test('inner expressions with computes', function () {
                var template = stache('{{helperA helperB(1,valueA,propA=valueB propC=2) \'def\' outerPropA=helperC(2,valueB)}}');
                var valueB = canCompute('B');
                var changes = 0;
                var frag = template({
                    valueA: 'A',
                    valueB: valueB
                }, {
                    helperA: function (arg1, arg2, options) {
                        if (changes === 0) {
                            equal(arg1(), 'helperB=B', 'static argument');
                            equal(options.hash.outerPropA(), 'helperC=B', 'scope hash 0');
                        } else {
                            equal(arg1(), 'helperB=X', 'static argument');
                            equal(options.hash.outerPropA(), 'helperC=X', 'scope hash 1');
                        }
                        equal(arg2, 'def', 'scope argument');
                        return arg1() + '-' + options.hash.outerPropA();
                    },
                    helperB: function (arg1, arg2, options) {
                        equal(arg1, 1, 'static argument');
                        equal(arg2, 'A', 'scope argument');
                        if (changes === 0) {
                            equal(options.propA, 'B', 'scope hash');
                        } else {
                            equal(options.propA, 'X', 'scope hash');
                        }
                        equal(options.propC, 2, 'static hash');
                        return 'helperB=' + options.propA;
                    },
                    helperC: function (arg1, arg2) {
                        equal(arg1, 2, 'helperC static argument');
                        if (changes === 0) {
                            equal(arg2, 'B', 'helperC scope argument');
                        } else {
                            equal(arg2, 'X', 'helperC scope argument');
                        }
                        return 'helperC=' + arg2;
                    }
                });
                equal(frag.firstChild.nodeValue, 'helperB=B-helperC=B');
                changes++;
                canBatch.start();
                valueB('X');
                canBatch.stop();
                equal(frag.firstChild.nodeValue, 'helperB=X-helperC=X');
            });
            test('parent scope functions not called with arguments (#1833)', function () {
                var data = {
                    child: { value: 1 },
                    method: function (arg) {
                        equal(arg, 1, 'got the right arg');
                    }
                };
                var template = stache('{{#child}}{{method value}}{{/child}}');
                template(data);
            });
            test('call expression - simple', function () {
                var template = stache('{{method(arg)}}');
                var age = canCompute(32);
                var frag = template({
                    method: function (num) {
                        return num * 2;
                    },
                    arg: age
                });
                equal(frag.firstChild.nodeValue, '64', 'method call works');
            });
            test('call expression #each passed list', function () {
                var animals = new CanList([
                        'sloth',
                        'bear'
                    ]), renderer = stache('<div>my<b>favorite</b>animals:{{#eachOf(animals)}}<label>Animal=</label> <span>{{this}}</span>{{/}}!</div>');
                var div = doc.createElement('div');
                var frag = renderer({ animals: animals });
                div.appendChild(frag);
                div.getElementsByTagName('label')[0].myexpando = 'EXPANDO-ED';
                equal(div.getElementsByTagName('label').length, 2, 'There are 2 labels');
                animals.push('turtle');
                equal(div.getElementsByTagName('label')[0].myexpando, 'EXPANDO-ED', 'same expando');
                equal(innerHTML(div.getElementsByTagName('span')[2]), 'turtle', 'turtle added');
            });
            test('call expression #each passed compute', function () {
                var animals = canCompute(new CanList([
                        'sloth',
                        'bear'
                    ])), renderer = stache('<div>my<b>favorite</b>animals:{{#eachOf(~animals)}}<label>Animal=</label> <span>{{this}}</span>{{/}}!</div>');
                var div = doc.createElement('div');
                var frag = renderer({ animals: animals });
                div.appendChild(frag);
                div.getElementsByTagName('label')[0].myexpando = 'EXPANDO-ED';
                equal(div.getElementsByTagName('label').length, 2, 'There are 2 labels');
                animals(new CanList([
                    'sloth',
                    'bear',
                    'turtle'
                ]));
                equal(div.getElementsByTagName('label')[0].myexpando, 'EXPANDO-ED', 'same expando');
                equal(innerHTML(div.getElementsByTagName('span')[2]), 'turtle', 'turtle added');
            });
            test('call expression with #if', function () {
                var truthy = canCompute(true);
                var template = stache('{{#if(truthy)}}true{{else}}false{{/if}}');
                var frag = template({ truthy: truthy });
                equal(frag.firstChild.nodeValue, 'true', 'set to true');
                truthy(false);
                equal(frag.firstChild.nodeValue, 'false', 'set to false');
            });
            test('getHelper w/o optional options argument (#1497)', function () {
                var options = stache.getHelper('each');
                ok(typeof options.fn === 'function', 'each helper returned');
            });
            test('methods don\'t update correctly (#1891)', function () {
                var map = new CanMap({
                    num1: 1,
                    num2: function () {
                        return this.attr('num1') * 2;
                    }
                });
                var frag = stache('<span class="num1">{{num1}}</span>' + '<span class="num2">{{num2}}</span>')(map);
                equal(frag.firstChild.firstChild.nodeValue, '1', 'Rendered correct value');
                equal(frag.lastChild.firstChild.nodeValue, '2', 'Rendered correct value');
                map.attr('num1', map.attr('num1') * 2);
                equal(frag.firstChild.firstChild.nodeValue, '2', 'Rendered correct value');
                equal(frag.lastChild.firstChild.nodeValue, '4', 'Rendered correct value');
            });
            test('eq called twice (#1931)', function () {
                expect(1);
                var oldIs = stache.getHelper('is').fn;
                stache.registerHelper('is', function () {
                    ok(true, 'comparator invoked only once during setup');
                    return oldIs.apply(this, arguments);
                });
                var a = canCompute(0), b = canCompute(0);
                stache('{{eq a b}}')({
                    a: a,
                    b: b
                });
                canBatch.start();
                a(1);
                b(1);
                canBatch.stop();
                stache.registerHelper('is', oldIs);
            });
            test('#each with else works (#1979)', function () {
                var list = new CanList([
                    'a',
                    'b'
                ]);
                var template = stache('<div>{{#each list}}<span>{{.}}</span>{{else}}<label>empty</label>{{/each}}</div>');
                var frag = template({ list: list });
                list.replace([]);
                var spans = frag.firstChild.getElementsByTagName('span');
                var labels = frag.firstChild.getElementsByTagName('label');
                equal(spans.length, 0, 'truthy case doesn\'t render');
                equal(labels.length, 1, 'empty case');
            });
            test('Re-evaluating a case in a switch (#1988)', function () {
                var template = stache('{{#switch page}}{{#case \'home\'}}<h1 id=\'home\'>Home</h1>' + '{{/case}}{{#case \'users\'}}{{#if slug}}<h1 id=\'user\'>User - {{slug}}</h1>' + '{{else}}<h1 id=\'users\'>Users</h1><ul><li>User 1</li><li>User 2</li>' + '</ul>{{/if}}{{/case}}{{/switch}}');
                var map = new CanMap({ page: 'home' });
                var frag = template(map);
                equal(frag.firstChild.getAttribute('id'), 'home', '\'home\' is the first item shown');
                map.attr('page', 'users');
                equal(frag.firstChild.nextSibling.getAttribute('id'), 'users', '\'users\' is the item shown when the page is users');
                map.attr('slug', 'Matthew');
                equal(frag.firstChild.nextSibling.getAttribute('id'), 'user', '\'user\' is the item shown when the page is users and there is a slug');
                canBatch.start();
                map.attr('page', 'home');
                map.removeAttr('slug');
                canBatch.stop();
                equal(frag.firstChild.getAttribute('id'), 'home', '\'home\' is the first item shown');
                equal(frag.firstChild.nextSibling.nodeType, 3, 'the next sibling is a TextNode');
                equal(frag.firstChild.nextSibling.nextSibling, undefined, 'there are no more nodes');
            });
            test('#each passed a method (2001)', function () {
                var users = new CanList([
                    {
                        name: 'Alexis',
                        num: 4,
                        age: 88
                    },
                    {
                        name: 'Brian',
                        num: 2,
                        age: 31
                    }
                ]);
                var template = stache('<div>{{#each people}}<span/>{{/each}}</div>');
                var VM = CanMap.extend({
                    people: function () {
                        return this.attr('users');
                    },
                    remove: function () {
                        $('#content').empty();
                    }
                });
                var frag = template(new VM({ users: users })), div = frag.firstChild, spans = div.getElementsByTagName('span');
                equal(spans.length, 2, 'two spans');
                domMutate.appendChild.call(this.fixture, frag);
                var fixture = this.fixture;
                stop();
                setTimeout(function () {
                    start();
                    domMutate.removeChild.call(fixture, div);
                    ok(true, 'removed without breaking');
                }, 10);
            });
            test('Rendering live bound indicies with #each, @index and a simple CanList (#2067)', function () {
                var list = new CanList([
                    { value: 'a' },
                    { value: 'b' },
                    { value: 'c' }
                ]);
                var template = stache('<ul>{{#each list}}<li>{{%index}} {{value}}</li>{{/each}}</ul>');
                var tpl = template({ list: list }).firstChild;
                var lis = tpl.getElementsByTagName('li');
                equal(lis.length, 3, 'three lis');
                equal(innerHTML(lis[0]), '0 a', 'first index and value are correct');
                equal(innerHTML(lis[1]), '1 b', 'second index and value are correct');
                equal(innerHTML(lis[2]), '2 c', 'third index and value are correct');
            });
            test('%index content should be skipped by ../ (#1554)', function () {
                var list = new CanList([
                    'a',
                    'b'
                ]);
                var tmpl = stache('{{#each items}}<li>{{.././items.indexOf(this)}}</li>{{/each}}');
                var frag = tmpl({ items: list });
                equal(frag.lastChild.firstChild.nodeValue, '1', 'read indexOf');
            });
            test('rendering style tag (#2035)', function () {
                var map = new CanMap({ color: 'green' });
                var frag = stache('<style>body {color: {{color}} }</style>')(map);
                var content = frag.firstChild.firstChild.nodeValue;
                equal(content, 'body {color: green }', 'got the right style text');
                map = new CanMap({ showGreen: true });
                frag = stache('<style>body {color: {{#showGreen}}green{{/showGreen}} }</style>')(map);
                content = frag.firstChild.firstChild.nodeValue;
                equal(content, 'body {color: green }', 'sub expressions work');
            });
            test('checked as a custom attribute', function () {
                var map = new CanMap({ preview: true });
                var frag = stache('<div {{#if preview}}checked{{/if}}></div>')(map);
                equal(frag.firstChild.getAttribute('checked'), '', 'got attribute');
            });
            test('sections with attribute spacing (#2097)', function () {
                var template = stache('<div {{#foo}} disabled {{/foo}}>');
                var frag = template({ foo: true });
                equal(frag.firstChild.getAttribute('disabled'), '', 'disabled set');
            });
            test('readonly as a custom attribute', function () {
                var map = new DefineMap({ conditions: false });
                var frag = stache('<input {{^conditions}}readonly{{/conditions}} name="password" type="password" />')(map);
                equal(frag.firstChild.getAttribute('readonly'), '', 'readonly set');
            });
            test('keep @index working with multi-dimensional arrays (#2127)', function () {
                var data = new CanMap({
                    array2: [
                        ['asd'],
                        ['sdf']
                    ]
                });
                var template = stache('<div>{{#each array2}}<span>{{@index}}</span>{{/each}}</div>');
                var frag = template(data);
                var spans = frag.firstChild.getElementsByTagName('span');
                equal(spans[0].firstChild.nodeValue, '0');
            });
            test('partials are not working within an {{#each}} (#2174)', function () {
                var data = new CanMap({
                    items: [{ name: 'foo' }],
                    itemRender: stache('{{name}}')
                });
                var renderer = stache('<div>{{#each items}}{{name}}{{/each}}</div>');
                var frag = renderer(data);
                data.attr('items.0.name', 'WORLD');
                equal(innerHTML(frag.firstChild), 'WORLD', 'updated to world');
                data.attr('items').splice(0, 0, { name: 'HELLO' });
                equal(innerHTML(frag.firstChild), 'HELLOWORLD');
            });
            test('partials don\'t leak (#2174)', function () {
                stache.registerHelper('somethingCrazy', function (name, options) {
                    return function (el) {
                        var nodeList = [el];
                        nodeList.expression = 'something crazy';
                        nodeLists.register(nodeList, function () {
                            ok(true, 'nodeList torn down');
                        }, options.nodeList, true);
                        nodeLists.update(options.nodeList, [el]);
                    };
                });
                var data = new CanMap({
                    items: [{ name: 'foo' }],
                    itemRender: stache('{{somethingCrazy name}}')
                });
                var renderer = stache('<div>{{#each items}}{{>itemRender}}{{/each}}</div>');
                renderer(data);
                data.attr('items').pop();
            });
            test('partials should leave binding to helpers and properties (#2174)', function () {
                stache.registerPartial('test', '<input id="one"> {{name}}');
                var renderer = stache('{{#each items}}{{>test}}{{/each}}');
                var data = new CanMap({ items: [] });
                var frag = renderer(data);
                data.attr('items').splice(0, 0, { name: 'bob' });
                frag.firstChild.nextSibling.setAttribute('value', 'user text');
                data.attr('items.0.name', 'dave');
                equal(frag.firstChild.nextSibling.getAttribute('value'), 'user text');
            });
            test('nested switch statement fail (#2188)', function () {
                var template = stache('<div>{{#switch outer}}' + '{{#case "outerValue1"}}' + '{{#switch inner}}' + '{{#case \'innerValue1\'}}' + 'INNER1' + '{{/case}}' + '{{/switch}}' + '{{/case}}' + '{{#case "outerValue2"}}' + 'OUTER2' + '{{/case}}' + '{{/switch}}</div>');
                var vm = new CanMap({
                    outer: 'outerValue1',
                    inner: 'innerValue1'
                });
                var frag = template(vm);
                canBatch.start();
                vm.removeAttr('inner');
                vm.attr('outer', 'outerValue2');
                canBatch.stop();
                ok(innerHTML(frag.firstChild).indexOf('OUTER2') >= 0, 'has OUTER2');
                ok(innerHTML(frag.firstChild).indexOf('INNER1') === -1, 'does not have INNER1');
            });
            test('Child bindings are called before the parent', function () {
                var template = '{{#eq page \'todos\'}}' + '{{#eq action \'view\'}} {{trace \'view todos\'}} {{/eq}}' + '{{#eq action \'edit\'}} {{trace \'edit todos\'}} {{/eq}}' + '{{/eq}}' + '{{#eq page \'recipes\'}}' + '{{#eq action \'view\'}} {{trace \'view recipes\'}} {{/eq}}' + '{{#eq action \'edit\'}} {{trace \'edit recipes\'}} {{/eq}}' + '{{/eq}}';
                var state = new CanMap({
                    action: 'view',
                    page: 'todos'
                });
                var counter = 0;
                stache(template)(state, {
                    trace: function (value, options) {
                        if (counter === 0) {
                            equal(value, 'view todos');
                        } else if (counter === 1) {
                            equal(value, 'edit recipes');
                        } else {
                            ok(false, 'Traced an unexpected template call');
                        }
                        counter++;
                    }
                });
                state.attr({
                    action: 'edit',
                    page: 'recipes'
                });
                equal(counter, 2, 'Counter incremented twice');
            });
            test('%index is double wrapped compute in helper (#2179)', function () {
                var appState = new CanMap({
                    todos: [
                        { description: 'Foo' },
                        { description: 'Bar' }
                    ]
                });
                var template = stache('{{#each todos}}<div>{{indexPlusOne %index}}</div>{{/each}}');
                stache.registerHelper('indexPlusOne', function (val, options) {
                    var resolved = val();
                    equal(typeof resolved, 'number', 'should be a number');
                    return resolved + 2;
                });
                template(appState);
            });
            test('%index is double wrapped compute in helper (#2179)', function () {
                var appState = new CanMap({
                    todos: [
                        { description: 'Foo' },
                        { description: 'Bar' }
                    ]
                });
                var template = stache('{{#each todos}}<div>{{indexPlusOne %index}}</div>{{/each}}');
                stache.registerHelper('indexPlusOne', function (val, options) {
                    var resolved = val();
                    equal(typeof resolved, 'number', 'should be a number');
                    return resolved + 2;
                });
                template(appState);
            });
            test('content within {{#if}} inside partial surrounded by {{#if}} should not display outside partial (#2186)', function () {
                stache.registerPartial('partial', '{{#showHiddenSection}}<div>Hidden</div>{{/showHiddenSection}}');
                var renderer = stache('<div>{{#showPartial}}{{>partial}}{{/showPartial}}</div>');
                var data = new CanMap({
                    showPartial: true,
                    showHiddenSection: false
                });
                var frag = renderer(data);
                data.attr('showHiddenSection', true);
                data.attr('showPartial', false);
                equal(innerHTML(frag.firstChild), '');
            });
            test('nested sections work (#2229)', function () {
                var template = stache('<div {{#a}}' + '{{#b}}f="f"' + '{{else}}' + '{{#c}}f="f"{{/c}}' + '{{/b}}' + '{{/a}}/>');
                var frag = template(new CanMap({
                    a: true,
                    b: false,
                    c: true
                }));
                equal(frag.firstChild.getAttribute('f'), 'f', 'able to set f');
            });
            test('Render with #each by assigning values to a specific variable wrapped in quotes', function () {
                var template = '{{#each animals \'animal\'}}' + '<span>{{animal.name}}</span>' + '{{/each}}';
                var renderer = stache(template);
                var animals = new CanList([{ name: 'sloth' }]);
                var frag = renderer({ animals: animals });
                var div = doc.createElement('div');
                div.appendChild(frag);
                equal(div.getElementsByTagName('span')[0].innerHTML, 'sloth');
            });
            test('Render with #each by assigning values to a specific variable without quotes', function () {
                var template = '{{#each animals animal}}' + '<span>{{animal.name}}</span>' + '{{/each}}';
                var renderer = stache(template);
                var animals = new CanList([{ name: 'sloth' }]);
                var frag = renderer({ animals: animals });
                var div = doc.createElement('div');
                div.appendChild(frag);
                equal(div.getElementsByTagName('span')[0].innerHTML, 'sloth');
            });
            test('Render with #each by assigning values to a specific variable and expressing it with `as` between list and value variable', function () {
                var template = '{{#each animals as animal}}' + '<span>{{animal.name}}</span>' + '{{/each}}';
                var renderer = stache(template);
                var animals = new CanList([{ name: 'sloth' }]);
                var frag = renderer({ animals: animals });
                var div = doc.createElement('div');
                div.appendChild(frag);
                equal(div.getElementsByTagName('span')[0].innerHTML, 'sloth');
            });
            test('Partials with custom context', function () {
                var template;
                var div = doc.createElement('div');
                template = stache('{{>dude dudes}}');
                var data = new CanMap({
                    dudes: [
                        { name: 'austin' },
                        { name: 'justin' }
                    ]
                });
                var dom = template(data, { partials: { dude: stache('{{#this}}<span>{{name}}</span>{{/this}}') } });
                div.appendChild(dom);
                var spans = div.getElementsByTagName('span');
                equal(spans.length, 2, 'Got two dudes');
                equal(innerHTML(spans[0]), 'austin', 'custom context inside');
                equal(innerHTML(spans[1]), 'justin', 'custom context inside');
            });
            test('Partials with nested custom context and parent lookup', function () {
                var template;
                var div = doc.createElement('div');
                template = stache('{{#data}}{{>dude dudes}}{{/data}}');
                var dom = template({
                    data: new CanMap({
                        hello: 'Hello',
                        dudes: [
                            { name: 'austin' },
                            { name: 'justin' }
                        ]
                    })
                }, {
                    helpers: {
                        cap: function (name) {
                            return string.capitalize(name());
                        }
                    },
                    partials: { dude: stache('{{#this}}<span>{{../hello}} {{name}}</span>{{/this}}') }
                });
                div.appendChild(dom);
                var spans = div.getElementsByTagName('span');
                equal(spans.length, 2, 'Got two dudes');
                equal(innerHTML(spans[0]), 'Hello austin', 'correct context');
                equal(innerHTML(spans[1]), 'Hello justin', 'and parent lookup worked also');
            });
            test('Partials with custom context and helper', function () {
                var template;
                var div = doc.createElement('div');
                template = stache('{{>dude dudes}}');
                var data = new CanMap({
                    dudes: [
                        { name: 'austin' },
                        { name: 'justin' }
                    ]
                });
                var dom = template(data, {
                    helpers: {
                        cap: function (name) {
                            return string.capitalize(name());
                        }
                    },
                    partials: { dude: stache('{{#this}}<span>{{cap name}}</span>{{/this}}') }
                });
                div.appendChild(dom);
                var spans = div.getElementsByTagName('span');
                equal(spans.length, 2, 'Got two dudes');
                equal(innerHTML(spans[0]), 'Austin', 'correct context');
                equal(innerHTML(spans[1]), 'Justin', 'and helpers worked also');
            });
            test('Bracket expression', function () {
                var template;
                var div = doc.createElement('div');
                template = stache('<p>{{ foo[bar] }}</p>');
                var data = new CanMap({
                    bar: 'name',
                    foo: {
                        name: 'Kevin',
                        fullName: 'Kevin Phillips'
                    }
                });
                var dom = template(data);
                div.appendChild(dom);
                var p = div.getElementsByTagName('p');
                equal(innerHTML(p[0]), 'Kevin', 'correct value for foo[bar]');
                data.attr('bar', 'fullName');
                equal(innerHTML(p[0]), 'Kevin Phillips', 'updated value for foo[bar]');
            });
            test('Bracket expression as argument to helper', function () {
                var template;
                var div = doc.createElement('div');
                template = stache('<p>{{#if [bar]}}if{{else}}else{{/if}}</p>');
                var data = new CanMap({
                    bar: 'key',
                    key: false
                });
                var dom = template(data);
                div.appendChild(dom);
                var p = div.getElementsByTagName('p');
                equal(innerHTML(p[0]), 'else', 'correctly displays {{else}} section');
                data.attr('key', true);
                equal(innerHTML(p[0]), 'if', 'correctly displays {{#if}} section');
            });
            test('Bracket expression in attributes', function () {
                var template;
                var div = doc.createElement('div');
                template = stache('<p id=\'{{ foo[bar] }}\' class=\'{{ foo[\'bar:baz\'] }}\'></p>');
                var data = new CanMap({
                    bar: 'name',
                    foo: {
                        'bar:baz': 'zulu',
                        name: 'Kevin',
                        fullName: 'Kevin Phillips'
                    }
                });
                var dom = template(data);
                div.appendChild(dom);
                var p = div.getElementsByTagName('p')[0];
                equal(getAttr(p, 'id'), 'Kevin', 'correct value for foo[bar]');
                equal(getAttr(p, 'class'), 'zulu', 'correct value for foo[\'bar:baz\']');
                data.attr('bar', 'fullName');
                data.attr('foo.bar:baz', 'tango');
                equal(getAttr(p, 'id'), 'Kevin Phillips', 'correct value for foo[bar]');
                equal(getAttr(p, 'class'), 'tango', 'correct value for foo[\'bar:baz\']');
            });
            test('Bracket expression - DefineMap', function () {
                var template;
                var div = doc.createElement('div');
                template = stache('<p>{{ foo[bar] }}</p>');
                var data = new DefineMap({
                    bar: 'name',
                    foo: {
                        name: 'Kevin',
                        fullName: 'Kevin Phillips'
                    }
                });
                var dom = template(data);
                div.appendChild(dom);
                var p = div.getElementsByTagName('p');
                equal(innerHTML(p[0]), 'Kevin', 'correct value for foo[bar]');
                data.bar = 'fullName';
                equal(innerHTML(p[0]), 'Kevin Phillips', 'updated value for foo[bar]');
            });
            test('context is observable (#38)', function () {
                var computes = [];
                stache.registerHelper('contextHelper', function (context) {
                    QUnit.equal(typeof context, 'function', 'got a compute');
                    computes.push(context);
                    return context();
                });
                var template = stache('<ul>{{#each .}}<li>{{contextHelper .}}</li>{{/each}}</ul>');
                var items = new CanList([
                    'one',
                    'two'
                ]);
                var frag = template(items);
                var lis = frag.firstChild.getElementsByTagName('li');
                items.attr(1, 'TWO');
                lis = frag.firstChild.getElementsByTagName('li');
                QUnit.equal(lis[1].innerHTML, 'TWO', 'is TWO');
                computes[1]('2');
                lis = frag.firstChild.getElementsByTagName('li');
                QUnit.equal(lis[1].innerHTML, '2', 'is 2');
            });
            if (window.console && window.console.log) {
                test('log', function () {
                    var oldLog = console.log;
                    var FIRST = {}, SECOND = {};
                    console.log = function (first, second) {
                        QUnit.equal(first, FIRST);
                        QUnit.equal(second, SECOND);
                    };
                    var template1 = stache('{{log first second}}'), template2 = stache('{{ log(first, second) }}');
                    template1({
                        first: FIRST,
                        second: SECOND
                    });
                    template2({
                        first: FIRST,
                        second: SECOND
                    });
                    console.log = oldLog;
                });
            }
            test('Nested if-s inside a text section (#9)', function (assert) {
                var template = stache('<div class="{{#if sorting}}sort{{#if ascending}}-ascend{{/if}}{{/if}}"></div>');
                var vm = new CanMap({
                    sorting: true,
                    ascending: false
                });
                var frag = template(vm);
                var className = frag.firstChild.className;
                assert.equal(className, 'sort');
                vm.attr('ascending', true);
                className = frag.firstChild.className;
                assert.equal(className, 'sort-ascend');
            });
            test('Helper each inside a text section (attribute) (#8)', function (assert) {
                var template = stache('<div class="{{#each list}}{{.}} {{/}}"></div>');
                var vm = new CanMap({
                    list: new CanList([
                        'one',
                        'two'
                    ])
                });
                var frag = template(vm);
                var className = frag.firstChild.className;
                assert.equal(className, 'one two ');
                vm.attr('list').push('three');
                className = frag.firstChild.className;
                assert.equal(className, 'one two three ');
            });
            test('stache.from works (#57)', function (assert) {
                var script = DOCUMENT().createElement('script');
                script.type = 'type/stache';
                script.innerHTML = '{{message}}';
                script.setAttribute('id', 'some-template');
                DOCUMENT().body.appendChild(script);
                var template = stache.from('some-template');
                var frag = template({ message: 'Hello' });
                assert.equal(frag.firstChild.nodeValue, 'Hello');
            });
            test('foo().bar', function () {
                var template = stache('<p>{{ person().name }}</p>');
                var div = doc.createElement('div');
                var data = new CanMap({
                    name: 'Kevin',
                    person: function () {
                        return { name: this.attr('name') };
                    }
                });
                var dom = template(data);
                div.appendChild(dom);
                var p = div.getElementsByTagName('p');
                equal(innerHTML(p[0]), 'Kevin', 'correct value for person().name');
                data.attr('name', 'Kevin Phillips');
                equal(innerHTML(p[0]), 'Kevin Phillips', 'updated value for person().name');
            });
            test('foo().bar - DefineMap', function () {
                var template = stache('<p>{{ person().name }}</p>');
                var div = doc.createElement('div');
                var data = new DefineMap({
                    name: 'Kevin',
                    person: function () {
                        return { name: this.name };
                    }
                });
                var dom = template(data);
                div.appendChild(dom);
                var p = div.getElementsByTagName('p');
                equal(innerHTML(p[0]), 'Kevin', 'correct value for person().name');
                data.name = 'Kevin Phillips';
                equal(innerHTML(p[0]), 'Kevin Phillips', 'updated value for person().name');
            });
            test('each values update when replaced in a can map (#62)', function () {
                var template = stache('{{#each this}}<p>{{.}}</p>{{/each}}');
                var div = doc.createElement('div');
                var vm = new CanMap({ foo: 'foo-value' });
                var dom = template(vm);
                div.appendChild(dom);
                vm.attr('foo', 'bar-value');
                var p = div.getElementsByTagName('p');
                equal(innerHTML(p[0]), 'bar-value', 'updated the value inside #each');
            });
            test('Bracket expression as argument to Call expression', function () {
                var template = stache('{{ foo([bar]) }}');
                var div = doc.createElement('div');
                var vm = new CanMap({
                    foo: function (key) {
                        return key + '!';
                    },
                    bar: 'name',
                    name: 'Kevin'
                });
                var dom = template(vm);
                div.appendChild(dom);
                equal(innerHTML(div), 'Kevin!', 'works');
            });
            test('Bracket expression with undefined value', function () {
                var template = stache('{{ place[\'place:name\'] }}');
                var div = doc.createElement('div');
                var vm = new CanMap({ 'place:name': 'foo' });
                var dom = template(vm);
                div.appendChild(dom);
                equal(innerHTML(div), '', 'empty');
                vm.attr('place', { 'place:name': 'bar' });
                equal(innerHTML(div), 'bar', 'updated');
            });
            test('Bracket expression in multi-argument helpers (Literals)', function () {
                var template = stache('{{#eq place[\'place:name\'] \'foo\' }}yes{{else}}no{{/eq}}');
                var div = doc.createElement('div');
                var vm = new CanMap({ place: { 'place:name': 'foo' } });
                var dom = template(vm);
                div.appendChild(dom);
                equal(innerHTML(div), 'yes', 'initially true');
                vm.attr('place.place:name', 'bar');
                equal(innerHTML(div), 'no', 'updated');
            });
            test('Bracket expression in multi-argument helpers (Lookups)', function () {
                var template = stache('{{#eq place[foo] foo }}yes{{else}}no{{/eq}}');
                var div = doc.createElement('div');
                var vm = new CanMap({
                    place: { 'foo': 'foo' },
                    foo: 'foo'
                });
                var dom = template(vm);
                div.appendChild(dom);
                equal(innerHTML(div), 'yes', 'initially true');
                vm.attr('place.foo', 'bar');
                equal(innerHTML(div), 'no', 'updated');
            });
            test('Bracket expression followed by bracket expression', function () {
                var template;
                var div = doc.createElement('div');
                template = stache('<p>{{ foo[bar][baz] }}</p>');
                var data = new CanMap({
                    baz: 'first',
                    bar: 'name',
                    foo: {
                        name: {
                            first: 'K',
                            last: 'P'
                        },
                        fullName: {
                            first: 'Kevin',
                            last: 'Phillips'
                        }
                    }
                });
                var dom = template(data);
                div.appendChild(dom);
                var p = div.getElementsByTagName('p');
                equal(innerHTML(p[0]), 'K', 'correct value for foo[bar][baz]');
                data.attr('bar', 'fullName');
                equal(innerHTML(p[0]), 'Kevin', 'updated value for bar in foo[bar][baz]');
                data.attr('baz', 'last');
                equal(innerHTML(p[0]), 'Phillips', 'updated value for baz in foo[bar][baz]');
            });
            test('Bracket expression with numeric index', function () {
                var template, dom, p;
                var div = doc.createElement('div');
                template = stache('<p>{{ foo[0] }}</p>');
                var data = new CanMap({
                    bar: [
                        'thud',
                        'jeek'
                    ],
                    foo: [
                        'baz',
                        'quux'
                    ]
                });
                dom = template(data);
                div.appendChild(dom);
                p = div.getElementsByTagName('p');
                equal(innerHTML(p[0]), 'baz', 'correct value for foo[0]');
                div.innerHTML = '';
                template = stache('<p>{{#each foo}}{{ bar[%index] }}{{/each}}</p>');
                dom = template(data);
                div.appendChild(dom);
                p = div.getElementsByTagName('p');
                equal(innerHTML(p[0]), 'thudjeek', 'correct value for bar[%index] when iterating foo (Map/List data)');
                div.innerHTML = '';
                dom = template(data.attr());
                div.appendChild(dom);
                p = div.getElementsByTagName('p');
                equal(innerHTML(p[0]), 'thudjeek', 'correct value for bar[%index] when iterating foo (plain object data)');
            });
            test('Bracket expression followed by Lookup expression', function () {
                var template;
                var div = doc.createElement('div');
                template = stache('<p>{{ foo[bar].first }}</p><p>{{#is foo[bar].first "K"}}short{{else}}long{{/is}}</p>');
                var data = new CanMap({
                    baz: 'first',
                    bar: 'name',
                    foo: {
                        name: { first: 'K' },
                        fullName: { first: 'Kevin' }
                    }
                });
                var dom = template(data);
                div.appendChild(dom);
                var p = div.getElementsByTagName('p');
                equal(innerHTML(p[0]), 'K', 'correct value for foo[bar].first');
                equal(innerHTML(p[1]), 'short', 'correct value for `is foo[bar].first "K"`');
                data.attr('bar', 'fullName');
                equal(innerHTML(p[0]), 'Kevin', 'updated value for foo[bar].first');
                equal(innerHTML(p[1]), 'long', 'updated value for `is foo[bar].first "K"`');
            });
            test('renderer itself is not observable', function () {
                var first = canCompute('Justin'), last = canCompute('Meyer');
                var renderer = stache('{{first}} {{last}}');
                var fullNameFrag = canCompute(function () {
                    return renderer({
                        first: first,
                        last: last
                    });
                });
                fullNameFrag.on('change', function () {
                    QUnit.ok(false);
                });
                this.fixture.appendChild(fullNameFrag());
                first('Josh');
                equal(this.fixture.innerHTML, 'Josh Meyer');
            });
            QUnit.test('content is registered (#163)', function () {
                QUnit.ok(viewCallbacks.tag('content'), 'registered content');
            });
            if (System.env.indexOf('production') < 0) {
                test('warn on missmatched tag (canjs/canjs#1476)', function () {
                    var makeWarnChecks = function (input, texts) {
                        var count = 0;
                        var _warn = canDev.warn;
                        canDev.warn = function (text) {
                            equal(text, texts[count++]);
                        };
                        stache(input);
                        equal(count, texts.length);
                        canDev.warn = _warn;
                    };
                    makeWarnChecks('{{#if someCondition}}...{{/foo}}', ['unexpected closing tag {{/foo}} expected {{/if}}']);
                    makeWarnChecks('{{^if someCondition}}...{{/foo}}', ['unexpected closing tag {{/foo}} expected {{/if}}']);
                    makeWarnChecks('{{#call()}}...{{/foo}}', ['unexpected closing tag {{/foo}} expected {{/call}}']);
                    makeWarnChecks('{{#if}}...{{/}}', []);
                    makeWarnChecks('{{#if someCondition}}...{{/if}}', []);
                    makeWarnChecks('{{^if someCondition}}...{{/if}}', []);
                    makeWarnChecks('{{#call()}}...{{/call}}', []);
                });
            }
            test('@arg functions are not called (#172)', function () {
                var data = new DefineMap({
                    func1: function () {
                        return 'called';
                    },
                    func2: function () {
                        ok(false, 'this method should not be called.');
                        return true;
                    },
                    noop: undefined
                });
                equal(getText('{{func1}}', data), 'called');
                equal(getText('{{#if func1}}yes{{else}}no{{/if}}', data), 'yes');
                equal(getText('{{#if @func2}}yes{{else}}no{{/if}}', data), 'yes');
                equal(getText('{{noop}}', data), '');
                equal(getText('{{#if noop}}yes{{else}}no{{/if}}', data), 'no');
                equal(getText('{{#if @noop}}yes{{else}}no{{/if}}', data), 'no');
            });
            test('can-template works', function () {
                var frag;
                var template = stache('<my-email>' + '<can-template name="subject">' + '<h2>{{subject}}</h2>' + '</can-template>' + '</my-email>');
                viewCallbacks.tag('my-email', function (el, tagData) {
                    ok(tagData.templates, 'has templates');
                    frag = tagData.templates.subject({ subject: 'Hello' });
                    QUnit.equal(frag.firstChild.nodeName, 'H2');
                    QUnit.equal(frag.firstChild.firstChild.nodeValue, 'Hello');
                });
                frag = template({});
            });
            test('can-template works with multiple can-templates of the same name', function () {
                var count = 2, frag;
                var template = stache('<my-email>' + '<can-template name="subject">' + '<h2>{{subject}}</h2>' + '</can-template>' + '</my-email>' + '<my-email>' + '<can-template name="subject">' + '<h3>{{subject}}</h3>' + '</can-template>' + '</my-email>');
                viewCallbacks.tag('my-email', function (el, tagData) {
                    ok(tagData.templates, 'has templates');
                    frag = tagData.templates.subject({ subject: 'Hello' });
                    QUnit.equal(frag.firstChild.nodeName, 'H' + count++);
                    QUnit.equal(frag.firstChild.firstChild.nodeValue, 'Hello');
                });
                frag = template({});
            });
            test('#each with arrays (#215)', function () {
                var which = canCompute(false);
                var a = {}, b = {}, c = {};
                var list = canCompute(function () {
                    return which() ? [
                        a,
                        b,
                        c
                    ] : [
                        a,
                        c
                    ];
                });
                var template = stache('<ul>{{#each list}}<li/>{{/each}}</ul>');
                var frag = template({ list: list });
                var ul = frag.firstChild;
                var lis = ul.getElementsByTagName('li');
                var aLI = lis[0], cLI = lis[1];
                which(true);
                lis = ul.getElementsByTagName('li');
                var aLI2 = lis[0], cLI2 = lis[2];
                QUnit.equal(aLI, aLI2, 'a li was reused');
                QUnit.equal(cLI, cLI2, 'c li was reused');
            });
        }
    }(function () {
        return this;
    }()));
});
/*can-stache-bindings@3.4.4#test/mock-component*/
define('can-stache-bindings@3.4.4#test/mock-component', function (require, exports, module) {
    var stacheBindings = require('can-stache-bindings');
    var CanMap = require('can-map');
    var viewCallbacks = require('can-view-callbacks');
    var Scope = require('can-view-scope');
    var nodeLists = require('can-view-nodelist');
    var domData = require('can-util/dom/data/data');
    var domMutate = require('can-util/dom/mutate/mutate');
    var MockComponent;
    module.exports = MockComponent = {
        extend: function (proto) {
            viewCallbacks.tag(proto.tag, function (el, componentTagData) {
                var viewModel;
                var teardownBindings = stacheBindings.behaviors.viewModel(el, componentTagData, function (initialViewModelData) {
                    if (typeof proto.viewModel === 'function') {
                        return viewModel = new proto.viewModel(initialViewModelData);
                    } else if (proto.viewModel instanceof CanMap) {
                        return viewModel = proto.viewModel;
                    } else {
                        var VM = CanMap.extend(proto.viewModel);
                        return viewModel = new VM(initialViewModelData);
                    }
                }, {});
                domData.set.call(el, 'viewModel', viewModel);
                domData.set.call(el, 'preventDataBindings', true);
                if (proto.template) {
                    var shadowScope = componentTagData.scope.add(new Scope.Refs()).add(viewModel, { viewModel: true });
                    domData.set.call(el, 'shadowScope', shadowScope);
                    var nodeList = nodeLists.register([], function () {
                        teardownBindings();
                    }, componentTagData.parentNodeList || true, false);
                    var frag = proto.template(shadowScope, componentTagData.options, nodeList);
                    domMutate.appendChild.call(el, frag);
                }
            });
        }
    };
});
/*can-stache-bindings@3.4.4#test/bindings-define-test*/
define('can-stache-bindings@3.4.4#test/bindings-define-test', function (require, exports, module) {
    var bindings = require('can-stache-bindings');
    var compute = require('can-compute');
    var QUnit = require('steal-qunit');
    var DefineMap = require('can-define/map/map');
    var stache = require('can-stache');
    var canViewModel = require('can-view-model');
    var define = require('can-define');
    var canEvent = require('can-event');
    var viewCallbacks = require('can-view-callbacks');
    var domAttr = require('can-util/dom/attr/attr');
    var domData = require('can-util/dom/data/data');
    var domDispatch = require('can-util/dom/dispatch/dispatch');
    var MockComponent = require('./mock-component');
    var viewModelFor = function (tag, viewModel) {
        viewCallbacks.tag(tag, function (el) {
            domData.set.call(el, 'viewModel', viewModel);
        });
    };
    QUnit.module('can-stache-bindings (can-define)');
    test('two way - viewModel', 7, function () {
        var ViewModel = define.Constructor({ vmProp: {} });
        MockComponent.extend({
            tag: 'two-way-viewmodel',
            viewModel: ViewModel
        });
        var template = stache('<two-way-viewmodel {(vm-prop)}="scopeProp" />');
        var Context = define.Constructor({ scopeProp: { value: 'Bing!' } });
        var context = new Context();
        var frag = template(context);
        var viewModel = canViewModel(frag.firstChild);
        ok(viewModel instanceof ViewModel, 'ViewModel is a can-define object');
        equal(viewModel.vmProp, 'Bing!', 'ViewModel property set via scope property set');
        equal(context.scopeProp, 'Bing!', 'Scope property is correct');
        viewModel.vmProp = 'Bang!';
        equal(viewModel.vmProp, 'Bang!', 'ViewModel property was set');
        equal(context.scopeProp, 'Bang!', 'Scope property set via viewModel property set');
        context.scopeProp = 'BOOM!';
        equal(context.scopeProp, 'BOOM!', 'Scope property was set');
        equal(viewModel.vmProp, 'BOOM!', 'ViewModel property set via scope property set');
    });
    test('one-way - parent to child - viewModel', function () {
        var VM = DefineMap.extend({ viewModelProp: '*' });
        viewModelFor('parent-to-child', new VM());
        var template = stache('<parent-to-child {view-model-prop}="scopeProp" />');
        var Context = define.Constructor({ scopeProp: { value: 'Venus' } });
        var context = new Context();
        var frag = template(context);
        var viewModel = canViewModel(frag.firstChild);
        equal(viewModel.viewModelProp, 'Venus', 'ViewModel property initially set from scope');
        viewModel.viewModelProp = 'Earth';
        equal(context.scopeProp, 'Venus', 'Scope property unchanged by viewModel set');
        context.scopeProp = 'Mars';
        equal(viewModel.viewModelProp, 'Mars', 'ViewModel property was set via scope set');
    });
    test('one-way - child to parent - viewModel', function () {
        var ViewModel = define.Constructor({ viewModelProp: { value: 'Mercury' } });
        MockComponent.extend({
            tag: 'view-model-able',
            viewModel: ViewModel
        });
        var template = stache('<view-model-able {^view-model-prop}="scopeProp" />');
        var Context = define.Constructor({ scopeProp: { value: 'Venus' } });
        var context = new Context();
        var frag = template(context);
        var viewModel = canViewModel(frag.firstChild);
        equal(viewModel.viewModelProp, 'Mercury', 'ViewModel property unchanged by scope property');
        equal(context.scopeProp, 'Mercury', 'Scope property initially set from viewModel');
        viewModel.viewModelProp = 'Earth';
        equal(context.scopeProp, 'Earth', 'Scope property set via viewModel set');
        context.scopeProp = 'Mars';
        equal(viewModel.viewModelProp, 'Earth', 'ViewModel property unchanged by scope set');
    });
    test('two-way - DOM - input text (#1700)', function () {
        var template = stache('<input {($value)}=\'age\'/>');
        var MyMap = define.Constructor({ age: { type: 'string' } });
        var map = new MyMap();
        var frag = template(map);
        var ta = document.getElementById('qunit-fixture');
        ta.appendChild(frag);
        var input = ta.getElementsByTagName('input')[0];
        equal(input.value, '', 'input value set correctly if key does not exist in map');
        map.age = 30;
        equal(input.value, '30', 'input value set correctly');
        map.age = '31';
        equal(input.value, '31', 'input value update correctly');
        input.value = '32';
        canEvent.trigger.call(input, 'change');
        equal(map.age, '32', 'updated from input');
    });
    test('Binding to a special property - values', function () {
        var template = stache('<select multiple {($values)}=\'values\'><option value=\'one\'>One</option><option value=\'two\'></option></select>');
        var map = new DefineMap({ values: [] });
        var slice = [].slice;
        var select = template(map).firstChild;
        var option1 = select.firstChild;
        var option2 = option1.nextSibling;
        option2.selected = true;
        canEvent.trigger.call(select, 'change');
        deepEqual(slice.call(map.values), ['two'], 'two is chosen');
        map.values = ['one'];
        equal(option1.selected, true, 'option1 selected');
        equal(option2.selected, false, 'option2 not selected');
    });
    test('Binding to a special property - option\'s selected', function () {
        var template = stache('<select><option {($selected)}=\'a\' value=\'one\'>One</option><option {($selected)}=\'b\' value=\'two\'>Two</option></select>');
        var map = new DefineMap({
            a: true,
            b: false
        });
        var select = template(map).firstChild;
        var option1 = select.firstChild;
        var option2 = option1.nextSibling;
        option2.selected = true;
        canEvent.trigger.call(select, 'change');
        equal(map.a, false, 'map.a false');
        equal(map.b, true, 'map.b true');
    });
    if (System.env !== 'canjs-test') {
        test('Can two way bind to focused', function () {
            stop();
            var template = stache('<input {($focused)}=\'show\' type=\'text\'/>');
            var map = new DefineMap({ show: false });
            var ta = document.getElementById('qunit-fixture');
            var frag = template(map);
            var input = frag.firstChild;
            ta.appendChild(frag);
            map.show = true;
            if (!document.hasFocus()) {
                domDispatch.call(input, 'focus');
            }
            setTimeout(function () {
                ok(input === document.activeElement, 'now focused');
                domAttr.set(input, 'focused', false);
                if (!document.hasFocus()) {
                    domDispatch.call(input, 'blur');
                }
                setTimeout(function () {
                    ok(input !== document.activeElement, 'not focused');
                    equal(map.show, false, 'set the boolean');
                    start();
                }, 50);
            }, 50);
        });
    }
    function makeKeyboardEvent() {
        var event;
        try {
            event = new KeyboardEvent('keyup', { key: 'Enter' });
            return event;
        } catch (e) {
            event = document.createEvent('KeyboardEvent');
            event.initKeyboardEvent('keyup', true, false, document.parentWindow, 'Enter', 16, '', false, 'en-US');
            return event;
        }
    }
    var supportsKeyboardEvents = function () {
        if (typeof KeyboardEvent !== 'undefined') {
            try {
                var supports = false;
                var el = document.createElement('div');
                el.addEventListener('keyup', function (ev) {
                    supports = ev.key === 'Enter';
                });
                el.dispatchEvent(makeKeyboardEvent());
                return supports;
            } catch (e) {
                return false;
            }
        } else {
            return false;
        }
    }();
    if (supportsKeyboardEvents) {
        QUnit.test('KeyboardEvent dispatching works with .key (#93)', function () {
            var template = stache('<input ($enter)=\'method(%event)\' type=\'text\'/>');
            var frag = template({
                method: function (event) {
                    QUnit.ok(true, 'method was called');
                }
            });
            var input = frag.firstChild;
            var event = makeKeyboardEvent();
            input.dispatchEvent(event);
        });
    }
    QUnit.test('Two way bindings should be sticky (#122)', function () {
        var template = stache('<input {($value)}=\'firstName\'/>');
        var MyMap = define.Constructor({
            firstName: {
                set: function (newVal) {
                    return newVal.toLowerCase();
                }
            }
        });
        var map = new MyMap({ firstName: 'matthew' });
        var frag = template(map);
        var ta = document.getElementById('qunit-fixture');
        ta.appendChild(frag);
        var input = ta.getElementsByTagName('input')[0];
        QUnit.equal(input.value, 'matthew', 'input value set correctly');
        input.value = 'MATTHEW';
        canEvent.trigger.call(input, 'change');
        QUnit.equal(map.firstName, 'matthew', 'vm stays the same');
        QUnit.equal(input.value, 'matthew', 'input stays the same');
    });
    test('scope method called when scope property changes on DefineMap (#197)', function () {
        stop();
        expect(1);
        MockComponent.extend({ tag: 'view-model-able' });
        var template = stache('<view-model-able (. prop)=\'someMethod\'/>');
        var map = new DefineMap({
            prop: 'Mercury',
            someMethod: function (scope, el, ev, newVal) {
                start();
                ok(true, 'method called');
            }
        });
        template(map);
        map.prop = 'Venus';
    });
    test('.viewModel() can work with this {^this}=\'bar\'', function () {
        expect(2);
        var vm, teardown;
        viewCallbacks.tag('export-this', function (el, componentTagData) {
            domData.set.call(el, 'preventDataBindings', true);
            teardown = bindings.behaviors.viewModel(el, componentTagData, function (initialData, hasDataBindings) {
                QUnit.ok(hasDataBindings, 'has data bindings');
                return vm = compute(initialData);
            });
        });
        var myMap = new DefineMap({ value: null });
        var template = stache('<export-this {^this}="value"/>');
        template(myMap);
        vm(10);
        QUnit.equal(myMap.value, 10, 'changed the value');
    });
    test('.viewModel() can work with this {this}=\'bar\'', function () {
        expect(3);
        var vm, teardown;
        viewCallbacks.tag('export-this', function (el, componentTagData) {
            domData.set.call(el, 'preventDataBindings', true);
            teardown = bindings.behaviors.viewModel(el, componentTagData, function (initialData, hasDataBindings) {
                QUnit.ok(hasDataBindings, 'has data bindings');
                QUnit.equal(initialData, 10, 'initial value right');
                return vm = compute(initialData);
            });
        });
        var myMap = new DefineMap({ value: 10 });
        var template = stache('<export-this {this}="value"/>');
        template(myMap);
        myMap.value = 11;
        QUnit.equal(vm(), 11, 'updated VM by changing scope');
    });
    test('Will not accept more than one data binding if this is bound', function () {
        expect(2);
        var vm, teardown;
        viewCallbacks.tag('export-this', function (el, componentTagData) {
            teardown = bindings.behaviors.viewModel(el, componentTagData, function (initialData) {
                return vm = compute(initialData);
            });
        });
        var myMap = new DefineMap({
            value: 10,
            bar: 'baz'
        });
        var template = stache('<export-this {this}="value" {foo}="bar" />');
        try {
            template(myMap);
        } catch (error) {
            QUnit.equal(error.message, 'can-stache-bindings - you can not have contextual bindings ( {this}=\'value\' ) and key bindings ( {prop}=\'value\' ) on one element.', 'Succesfully errored');
        }
        template = stache('<export-this {foo}="bar" {this}="value" />');
        try {
            template(myMap);
        } catch (error) {
            QUnit.equal(error.message, 'can-stache-bindings - you can not have contextual bindings ( {this}=\'value\' ) and key bindings ( {prop}=\'value\' ) on one element.', 'Succesfully errored');
        }
    });
    test('.viewModel() can bypass dynamic bindings', function () {
        expect(1);
        var teardown;
        viewCallbacks.tag('export-this', function (el, componentTagData) {
            domData.set.call(el, 'preventDataBindings', true);
            teardown = bindings.behaviors.viewModel(el, componentTagData, function (initialData, hasDataBindings) {
                QUnit.ok(false, 'no bindings, this shouldn\'t be called');
            }, undefined, true);
            QUnit.notOk(teardown, 'we should get no teardown b/c there\'s no bindings');
        });
        var myMap = new DefineMap({ value: 10 });
        var template = stache('<export-this/>');
        template(myMap);
    });
});
/*can-stache-bindings@3.4.4#test/bindings-test*/
define('can-stache-bindings@3.4.4#test/bindings-test', function (require, exports, module) {
    require('./bindings-define-test');
    var stacheBindings = require('can-stache-bindings');
    var QUnit = require('steal-qunit');
    var CanList = require('can-list');
    var CanMap = require('can-map');
    var stache = require('can-stache');
    var canEvent = require('can-event');
    var canBatch = require('can-event/batch/batch');
    var viewCallbacks = require('can-view-callbacks');
    var canCompute = require('can-compute');
    var canViewModel = require('can-view-model');
    var canSymbol = require('can-symbol');
    var canReflect = require('can-reflect');
    var stacheExpression = require('can-stache/src/expression');
    var domData = require('can-util/dom/data/data');
    var domMutate = require('can-util/dom/mutate/mutate');
    var domEvents = require('can-util/dom/events/events');
    require('can-util/dom/events/inserted/inserted');
    var makeDocument = require('can-vdom/make-document/make-document');
    var MUTATION_OBSERVER = require('can-util/dom/mutation-observer/mutation-observer');
    var DOCUMENT = require('can-util/dom/document/document');
    var dev = require('can-util/js/dev/dev');
    var canEach = require('can-util/js/each/each');
    var types = require('can-types');
    var MockComponent = require('./mock-component');
    var DefaultMap = types.DefaultMap;
    function afterMutation(cb) {
        var doc = DOCUMENT();
        var div = doc.createElement('div');
        domEvents.addEventListener.call(div, 'inserted', function () {
            doc.body.removeChild(div);
            setTimeout(cb, 5);
        });
        domMutate.appendChild.call(doc.body, div);
    }
    var DOC = DOCUMENT();
    var MUT_OBS = MUTATION_OBSERVER();
    makeTest('can-stache-bindings - dom', document, MUT_OBS);
    makeTest('can-stache-bindings - vdom', makeDocument(), null);
    function makeTest(name, doc, mutObs) {
        var testIfRealDocument = function () {
            if (doc === document) {
                test.apply(null, arguments);
            } else {
            }
        };
        var isRealDocument = function () {
            return doc === document;
        };
        QUnit.module(name, {
            setup: function () {
                DOCUMENT(doc);
                MUTATION_OBSERVER(mutObs);
                types.DefaultMap = CanMap;
                if (doc === document) {
                    this.fixture = document.getElementById('qunit-fixture');
                } else {
                    this.fixture = doc.createElement('qunit-fixture');
                    doc.body.appendChild(this.fixture);
                }
            },
            teardown: function () {
                if (doc !== document) {
                    doc.body.removeChild(this.fixture);
                }
                stop();
                afterMutation(function () {
                    types.DefaultMap = DefaultMap;
                    DOCUMENT(DOC);
                    MUTATION_OBSERVER(MUT_OBS);
                    var fixture = document.getElementById('qunit-fixture');
                    while (fixture && fixture.hasChildNodes()) {
                        domData.delete.call(fixture.lastChild);
                        fixture.removeChild(fixture.lastChild);
                    }
                    start();
                });
            }
        });
        test('attributeNameInfo', function () {
            var info = stacheBindings.getBindingInfo({
                name: 'foo',
                value: 'bar'
            }, { foo: '@' }, 'legacy');
            deepEqual(info, {
                parent: 'attribute',
                child: 'viewModel',
                parentToChild: true,
                childToParent: true,
                childName: 'foo',
                parentName: 'foo',
                bindingAttributeName: 'foo',
                syncChildWithParent: true
            }, 'legacy with @');
            info = stacheBindings.getBindingInfo({
                name: 'foo-ed',
                value: 'bar'
            }, {}, 'legacy');
            deepEqual(info, {
                parent: 'scope',
                child: 'viewModel',
                parentToChild: true,
                childToParent: true,
                childName: 'fooEd',
                parentName: 'bar',
                bindingAttributeName: 'foo-ed',
                syncChildWithParent: true
            }, 'legacy');
            info = stacheBindings.getBindingInfo({
                name: 'foo-ed',
                value: 'bar'
            });
            deepEqual(info, {
                parent: 'attribute',
                child: 'viewModel',
                parentToChild: true,
                childToParent: true,
                childName: 'fooEd',
                parentName: 'foo-ed',
                bindingAttributeName: 'foo-ed',
                syncChildWithParent: true
            }, 'OG stache attr binding');
            info = stacheBindings.getBindingInfo({
                name: 'foo-ed',
                value: '{bar}'
            });
            deepEqual(info, {
                parent: 'scope',
                child: 'viewModel',
                parentToChild: true,
                childToParent: true,
                childName: 'fooEd',
                parentName: 'bar',
                bindingAttributeName: 'foo-ed',
                syncChildWithParent: true
            }, 'OG stache vm binding');
            info = stacheBindings.getBindingInfo({
                name: '{$foo-ed}',
                value: 'bar'
            });
            deepEqual(info, {
                parent: 'scope',
                child: 'attribute',
                childToParent: false,
                parentToChild: true,
                parentName: 'bar',
                childName: 'foo-ed',
                bindingAttributeName: '{$foo-ed}',
                initializeValues: true,
                syncChildWithParent: false
            }, 'new el binding');
            info = stacheBindings.getBindingInfo({
                name: '{($foo-ed)}',
                value: 'bar'
            });
            deepEqual(info, {
                parent: 'scope',
                child: 'attribute',
                childToParent: true,
                parentToChild: true,
                parentName: 'bar',
                childName: 'foo-ed',
                bindingAttributeName: '{($foo-ed)}',
                initializeValues: true,
                syncChildWithParent: true
            }, 'new el binding');
            info = stacheBindings.getBindingInfo({
                name: '{^$foo-ed}',
                value: 'bar'
            });
            deepEqual(info, {
                parent: 'scope',
                child: 'attribute',
                childToParent: true,
                parentToChild: false,
                parentName: 'bar',
                childName: 'foo-ed',
                bindingAttributeName: '{^$foo-ed}',
                initializeValues: true,
                syncChildWithParent: false
            }, 'new el binding');
            info = stacheBindings.getBindingInfo({
                name: '{foo-ed}',
                value: 'bar'
            });
            deepEqual(info, {
                parent: 'scope',
                child: 'viewModel',
                parentToChild: true,
                childToParent: false,
                childName: 'fooEd',
                parentName: 'bar',
                bindingAttributeName: '{foo-ed}',
                initializeValues: true,
                syncChildWithParent: false
            }, 'new vm binding');
            info = stacheBindings.getBindingInfo({
                name: '{(foo-ed)}',
                value: 'bar'
            });
            deepEqual(info, {
                parent: 'scope',
                child: 'viewModel',
                parentToChild: true,
                childToParent: true,
                childName: 'fooEd',
                parentName: 'bar',
                bindingAttributeName: '{(foo-ed)}',
                initializeValues: true,
                syncChildWithParent: true
            }, 'new el binding');
            info = stacheBindings.getBindingInfo({
                name: '{^foo-ed}',
                value: 'bar'
            });
            deepEqual(info, {
                parent: 'scope',
                child: 'viewModel',
                parentToChild: false,
                childToParent: true,
                childName: 'fooEd',
                parentName: 'bar',
                bindingAttributeName: '{^foo-ed}',
                initializeValues: true,
                syncChildWithParent: false
            }, 'new el binding');
        });
        var foodTypes = new CanList([
            {
                title: 'Fruits',
                content: 'oranges, apples'
            },
            {
                title: 'Breads',
                content: 'pasta, cereal'
            },
            {
                title: 'Sweets',
                content: 'ice cream, candy'
            }
        ]);
        if (typeof doc.getElementsByClassName === 'function') {
            test('can-event handlers', function () {
                var ta = this.fixture;
                var template = stache('<div>' + '{{#each foodTypes}}' + '<p can-click=\'doSomething\'>{{content}}</p>' + '{{/each}}' + '</div>');
                function doSomething(foodType, el, ev) {
                    ok(true, 'doSomething called');
                    equal(el.nodeName.toLowerCase(), 'p', 'this is the element');
                    equal(ev.type, 'click', '1st argument is the event');
                    equal(foodType, foodTypes[0], '2nd argument is the 1st foodType');
                }
                var frag = template({
                    foodTypes: foodTypes,
                    doSomething: doSomething
                });
                ta.appendChild(frag);
                var p0 = ta.getElementsByTagName('p')[0];
                canEvent.trigger.call(p0, 'click');
            });
            test('can-event special keys', function () {
                var scope = new CanMap({ test: 'testval' });
                var ta = this.fixture;
                MockComponent.extend({
                    tag: 'can-event-args-tester',
                    viewModel: scope
                });
                var template = stache('<div>' + '{{#each foodTypes}}' + '<can-event-args-tester class=\'with-args\' can-click=\'{withArgs @event @element @viewModel @viewModel.test . title content=content}\'/>' + '{{/each}}' + '</div>');
                function withArgs(ev1, el1, compScope, testVal, context, title, hash) {
                    ok(true, 'withArgs called');
                    equal(el1.nodeName.toLowerCase(), 'can-event-args-tester', '@element is the event\'s DOM element');
                    equal(ev1.type, 'click', '@event is the click event');
                    equal(scope, compScope, 'Component scope accessible through @viewModel');
                    equal(testVal, scope.attr('test'), 'Attributes accessible');
                    equal(context.title, foodTypes[0].title, 'Context passed in');
                    equal(title, foodTypes[0].title, 'Title passed in');
                    equal(hash.content, foodTypes[0].content, 'Args with = passed in as a hash');
                }
                var frag = template({
                    foodTypes: foodTypes,
                    withArgs: withArgs
                });
                ta.innerHTML = '';
                ta.appendChild(frag);
                var p0 = ta.getElementsByClassName('with-args')[0];
                canEvent.trigger.call(p0, 'click');
            });
            test('(event) handlers', 12, function () {
                var ta = this.fixture;
                var template = stache('<div>' + '{{#each foodTypes}}' + '<p ($click)=\'doSomething\'>{{content}}</p>' + '{{/each}}' + '</div>');
                var foodTypes = new CanList([
                    {
                        title: 'Fruits',
                        content: 'oranges, apples'
                    },
                    {
                        title: 'Breads',
                        content: 'pasta, cereal'
                    },
                    {
                        title: 'Sweets',
                        content: 'ice cream, candy'
                    }
                ]);
                function doSomething(foodType, el, ev) {
                    ok(true, 'doSomething called');
                    equal(el.nodeName.toLowerCase(), 'p', 'this is the element');
                    equal(ev.type, 'click', '1st argument is the event');
                    equal(foodType, foodTypes[0], '2nd argument is the 1st foodType');
                }
                var frag = template({
                    foodTypes: foodTypes,
                    doSomething: doSomething
                });
                ta.appendChild(frag);
                var p0 = ta.getElementsByTagName('p')[0];
                canEvent.trigger.call(p0, 'click');
                var scope = new CanMap({ test: 'testval' });
                MockComponent.extend({
                    tag: 'fancy-event-args-tester',
                    viewModel: scope
                });
                template = stache('<div>' + '{{#each foodTypes}}' + '<fancy-event-args-tester class=\'with-args\' ($click)=\'withArgs @event @element @viewModel @viewModel.test . title content=content\'/>' + '{{/each}}' + '</div>');
                function withArgs(ev1, el1, compScope, testVal, context, title, hash) {
                    ok(true, 'withArgs called');
                    equal(el1.nodeName.toLowerCase(), 'fancy-event-args-tester', '@element is the event\'s DOM element');
                    equal(ev1.type, 'click', '@event is the click event');
                    equal(scope, compScope, 'Component scope accessible through @viewModel');
                    equal(testVal, scope.attr('test'), 'Attributes accessible');
                    equal(context.title, foodTypes[0].title, 'Context passed in');
                    equal(title, foodTypes[0].title, 'Title passed in');
                    equal(hash.content, foodTypes[0].content, 'Args with = passed in as a hash');
                }
                frag = template({
                    foodTypes: foodTypes,
                    withArgs: withArgs
                });
                ta.innerHTML = '';
                ta.appendChild(frag);
                p0 = ta.getElementsByClassName('with-args')[0];
                canEvent.trigger.call(p0, 'click');
            });
        }
        test('can-value input text', function () {
            var template = stache('<input can-value=\'age\'/>');
            var map = new CanMap();
            var frag = template(map);
            var ta = this.fixture;
            ta.appendChild(frag);
            var input = ta.getElementsByTagName('input')[0];
            equal(input.value, '', 'input value set correctly if key does not exist in map');
            map.attr('age', '30');
            equal(input.value, '30', 'input value set correctly');
            map.attr('age', '31');
            equal(input.value, '31', 'input value update correctly');
            input.value = '32';
            canEvent.trigger.call(input, 'change');
            equal(map.attr('age'), '32', 'updated from input');
        });
        test('can-value with spaces (#1477)', function () {
            var template = stache('<input can-value=\'{ age }\'/>');
            var map = new CanMap();
            var frag = template(map);
            var ta = this.fixture;
            ta.appendChild(frag);
            var input = ta.getElementsByTagName('input')[0];
            equal(input.value, '', 'input value set correctly if key does not exist in map');
            map.attr('age', '30');
            equal(input.value, '30', 'input value set correctly');
            map.attr('age', '31');
            equal(input.value, '31', 'input value update correctly');
            input.value = '32';
            canEvent.trigger.call(input, 'change');
            equal(map.attr('age'), '32', 'updated from input');
        });
        test('can-value input radio', function () {
            var template = stache('<input type=\'radio\' can-value=\'color\' value=\'red\'/> Red<br/>' + '<input type=\'radio\' can-value=\'color\' value=\'green\'/> Green<br/>');
            var map = new CanMap({ color: 'red' });
            var frag = template(map);
            var ta = this.fixture;
            ta.appendChild(frag);
            var inputs = ta.getElementsByTagName('input');
            ok(inputs[0].checked, 'first input checked');
            ok(!inputs[1].checked, 'second input not checked');
            map.attr('color', 'green');
            ok(!inputs[0].checked, 'first notinput checked');
            ok(inputs[1].checked, 'second input checked');
            inputs[0].checked = true;
            inputs[1].checked = false;
            canEvent.trigger.call(inputs[0], 'change');
            equal(map.attr('color'), 'red', 'updated from input');
        });
        test('can-enter', function () {
            var template = stache('<input can-enter=\'update\'/>');
            var called = 0;
            var frag = template({
                update: function () {
                    called++;
                    equal(called, 1, 'update called once');
                }
            });
            var input = frag.childNodes.item(0);
            canEvent.trigger.call(input, {
                type: 'keyup',
                keyCode: 38
            });
            canEvent.trigger.call(input, {
                type: 'keyup',
                keyCode: 13
            });
        });
        testIfRealDocument('{($checked)} should trigger a radiochange event for radio buttons', function () {
            var template = stache([
                '<input type="radio" name="baz" {($checked)}="foo"/><span>{{foo}}</span>',
                '<input type="radio" name="baz" {($checked)}="bar"/><span>{{bar}}</span>'
            ].join(''));
            var data = new CanMap({
                foo: false,
                bar: false
            });
            var fragment = template(data);
            domMutate.appendChild.call(this.fixture, fragment);
            var self = this;
            function child(index) {
                return self.fixture.childNodes.item(index);
            }
            var fooRadio = child(0);
            var fooText = child(1);
            var barRadio = child(2);
            var barText = child(3);
            function text(node) {
                while (node && node.nodeType !== 3) {
                    node = node.firstChild;
                }
                return node && node.nodeValue;
            }
            fooRadio.checked = true;
            canEvent.trigger.call(fooRadio, 'change');
            barRadio.checked = true;
            canEvent.trigger.call(barRadio, 'change');
            equal(text(fooText), 'false');
            equal(text(barText), 'true');
            equal(data.foo, false);
            equal(data.bar, true);
        });
        testIfRealDocument('{($checked)} radio elements should update via the radiochange event', function () {
            var template = stache([
                '<input type="radio" name="baz" {($checked)}="foo"/><span>{{foo}}</span>',
                '<input type="radio" name="baz"/>'
            ].join(''));
            var data = new CanMap({ foo: false });
            var fragment = template(data);
            domMutate.appendChild.call(this.fixture, fragment);
            var self = this;
            function child(index) {
                return self.fixture.childNodes.item(index);
            }
            var fooRadio = child(0);
            var fooText = child(1);
            var barRadio = child(2);
            function text(node) {
                while (node && node.nodeType !== 3) {
                    node = node.firstChild;
                }
                return node && node.nodeValue;
            }
            fooRadio.checked = true;
            canEvent.trigger.call(fooRadio, 'change');
            equal(text(fooText), 'true');
            equal(data.foo, true);
            barRadio.checked = true;
            canEvent.trigger.call(barRadio, 'change');
            equal(text(fooText), 'false');
            equal(data.foo, false);
        });
        test('two bindings on one element call back the correct method', function () {
            expect(2);
            var template = stache('<input can-mousemove=\'first\' can-click=\'second\'/>');
            var callingFirst = false, callingSecond = false;
            var frag = template({
                first: function () {
                    ok(callingFirst, 'called first');
                },
                second: function () {
                    ok(callingSecond, 'called second');
                }
            });
            var input = frag.childNodes.item(0);
            callingFirst = true;
            canEvent.trigger.call(input, { type: 'mousemove' });
            callingFirst = false;
            callingSecond = true;
            canEvent.trigger.call(input, { type: 'click' });
        });
        test('event bindings should be removed when the bound element is', function (assert) {
            var template = stache('<div>{{#if isShowing}}<input ($click)="onClick()"><span></span>{{/if}}</div>');
            var viewModel = new CanMap({
                isShowing: false,
                onClick: function () {
                }
            });
            var bindingListenerCount = 0;
            var hasAddedBindingListener = false;
            var hasRemovedBindingListener = false;
            var fragment = template(viewModel);
            domMutate.appendChild.call(this.fixture, fragment);
            var isInputBindingEvent = function (element, eventName) {
                return element.nodeName === 'INPUT' && eventName === 'click';
            };
            var realAddEventListener = domEvents.addEventListener;
            var realRemoveEventListener = domEvents.removeEventListener;
            domEvents.addEventListener = function (eventName) {
                if (isInputBindingEvent(this, eventName)) {
                    bindingListenerCount++;
                    hasAddedBindingListener = true;
                }
                return realAddEventListener.apply(this, arguments);
            };
            domEvents.removeEventListener = function (eventName) {
                if (isInputBindingEvent(this, eventName)) {
                    bindingListenerCount--;
                    hasRemovedBindingListener = true;
                }
                return realRemoveEventListener.apply(this, arguments);
            };
            viewModel.attr('isShowing', true);
            var andThen = function () {
                domEvents.removeEventListener.call(span, 'removed', andThen);
                start();
                domEvents.addEventListener = realAddEventListener;
                domEvents.removeEventListener = realRemoveEventListener;
                assert.ok(hasAddedBindingListener, 'An event listener should have been added for the binding');
                assert.ok(hasRemovedBindingListener, 'An event listener should have been removed for the binding');
                var message = bindingListenerCount + ' event listeners were added but not removed';
                if (removeEventListener < 0) {
                    message = 'Event listeners were removed more than necessary';
                }
                assert.equal(bindingListenerCount, 0, message);
            };
            var span = this.fixture.firstChild.lastChild;
            domEvents.addEventListener.call(span, 'removed', andThen);
            viewModel.attr('isShowing', false);
            stop();
        });
        test('can-value select remove from DOM', function () {
            stop();
            expect(1);
            var template = stache('<select can-value=\'color\'>' + '<option value=\'red\'>Red</option>' + '<option value=\'green\'>Green</option>' + '</select>'), frag = template(), ta = this.fixture;
            domMutate.appendChild.call(ta, frag);
            domMutate.removeChild.call(ta, ta.firstChild);
            afterMutation(function () {
                start();
                ok(true, 'Nothing should break if we just add and then remove the select');
            });
        });
        test('checkboxes with can-value bind properly (#628)', function () {
            var data = new CanMap({ completed: true }), frag = stache('<input type="checkbox" can-value="completed"/>')(data);
            domMutate.appendChild.call(this.fixture, frag);
            var input = this.fixture.getElementsByTagName('input')[0];
            equal(input.checked, data.attr('completed'), 'checkbox value bound (via attr check)');
            data.attr('completed', false);
            equal(input.checked, data.attr('completed'), 'checkbox value bound (via attr uncheck)');
            input.checked = true;
            canEvent.trigger.call(input, 'change');
            equal(input.checked, true, 'checkbox value bound (via check)');
            equal(data.attr('completed'), true, 'checkbox value bound (via check)');
            input.checked = false;
            canEvent.trigger.call(input, 'change');
            equal(input.checked, false, 'checkbox value bound (via uncheck)');
            equal(data.attr('completed'), false, 'checkbox value bound (via uncheck)');
        });
        test('checkboxes with can-true-value bind properly', function () {
            var data = new CanMap({ sex: 'male' }), frag = stache('<input type="checkbox" can-value="sex" can-true-value="male" can-false-value="female"/>')(data);
            domMutate.appendChild.call(this.fixture, frag);
            var input = this.fixture.getElementsByTagName('input')[0];
            stop();
            afterMutation(function () {
                start();
                equal(input.checked, true, 'checkbox value bound (via attr check)');
                data.attr('sex', 'female');
                equal(input.checked, false, 'checkbox value unbound (via attr uncheck)');
                input.checked = true;
                canEvent.trigger.call(input, 'change');
                equal(input.checked, true, 'checkbox value bound (via check)');
                equal(data.attr('sex'), 'male', 'checkbox value bound (via check)');
                input.checked = false;
                canEvent.trigger.call(input, 'change');
                equal(input.checked, false, 'checkbox value bound (via uncheck)');
                equal(data.attr('sex'), 'female', 'checkbox value bound (via uncheck)');
            });
        });
        testIfRealDocument('can-value select single', function () {
            var template = stache('<select can-value=\'color\'>' + '<option value=\'red\'>Red</option>' + '<option value=\'green\'>Green</option>' + '</select>');
            var map = new CanMap({ color: 'red' });
            var frag = template(map);
            var ta = this.fixture;
            ta.appendChild(frag);
            var inputs = ta.getElementsByTagName('select');
            equal(inputs[0].value, 'red', 'default value set');
            map.attr('color', 'green');
            equal(inputs[0].value, 'green', 'alternate value set');
            canEach(ta.getElementsByTagName('option'), function (opt) {
                if (opt.value === 'red') {
                    opt.selected = 'selected';
                }
            });
            equal(map.attr('color'), 'green', 'not yet updated from input');
            canEvent.trigger.call(inputs[0], 'change');
            equal(map.attr('color'), 'red', 'updated from input');
            canEach(ta.getElementsByTagName('option'), function (opt) {
                if (opt.value === 'green') {
                    opt.selected = 'selected';
                }
            });
            equal(map.attr('color'), 'red', 'not yet updated from input');
            canEvent.trigger.call(inputs[0], 'change');
            equal(map.attr('color'), 'green', 'updated from input');
        });
        testIfRealDocument('can-value select multiple with values cross bound to an array', function () {
            var template = stache('<select can-value=\'colors\' multiple>' + '<option value=\'red\'>Red</option>' + '<option value=\'green\'>Green</option>' + '<option value=\'ultraviolet\'>Ultraviolet</option>' + '</select>');
            var map = new CanMap({});
            stop();
            var frag = template(map);
            var ta = this.fixture;
            ta.appendChild(frag);
            var select = ta.getElementsByTagName('select')[0], options = select.getElementsByTagName('option');
            setTimeout(function () {
                options[0].selected = true;
                canEvent.trigger.call(select, 'change');
                deepEqual(map.attr('colors').attr(), ['red'], 'A CanList property is set even if none existed');
                options[1].selected = true;
                canEvent.trigger.call(select, 'change');
                deepEqual(map.attr('colors').attr(), [
                    'red',
                    'green'
                ], 'Adds items to the list');
                options[0].selected = false;
                canEvent.trigger.call(select, 'change');
                deepEqual(map.attr('colors').attr(), ['green'], 'Removes items from the list');
                map.attr('colors').push('ultraviolet');
                options[0].selected = false;
                options[1].selected = true;
                options[2].selected = true;
                ta.removeChild(select);
                start();
            }, 1);
        });
        testIfRealDocument('can-value multiple select with a CanList', function () {
            var template = stache('<select can-value=\'colors\' multiple>' + '<option value=\'red\'>Red</option>' + '<option value=\'green\'>Green</option>' + '<option value=\'ultraviolet\'>Ultraviolet</option>' + '</select>');
            var list = new CanList();
            stop();
            var frag = template({ colors: list });
            var ta = this.fixture;
            ta.appendChild(frag);
            var select = ta.getElementsByTagName('select')[0], options = select.getElementsByTagName('option');
            setTimeout(function () {
                options[0].selected = true;
                canEvent.trigger.call(select, 'change');
                deepEqual(list.attr(), ['red'], 'A CanList property is set even if none existed');
                options[1].selected = true;
                canEvent.trigger.call(select, 'change');
                deepEqual(list.attr(), [
                    'red',
                    'green'
                ], 'Adds items to the list');
                options[0].selected = false;
                canEvent.trigger.call(select, 'change');
                deepEqual(list.attr(), ['green'], 'Removes items from the list');
                list.push('ultraviolet');
                options[0].selected = false;
                options[1].selected = true;
                options[2].selected = true;
                ta.removeChild(select);
                start();
            }, 1);
        });
        test('can-value contenteditable', function () {
            var template = stache('<div id=\'cdiv\' contenteditable can-value=\'age\'></div>');
            var map = new CanMap();
            var frag = template(map);
            var ta = this.fixture;
            ta.appendChild(frag);
            var div = doc.getElementById('cdiv');
            equal(div.innerHTML, '', 'contenteditable set correctly if key does not exist in map');
            map.attr('age', '30');
            equal(div.innerHTML, '30', 'contenteditable set correctly');
            map.attr('age', '31');
            equal(div.innerHTML, '31', 'contenteditable update correctly');
            div.innerHTML = '32';
            canEvent.trigger.call(div, 'blur');
            equal(map.attr('age'), '32', 'updated from contenteditable');
        });
        test('can-event handlers work with {} (#905)', function () {
            expect(4);
            var template = stache('<div>' + '{{#each foodTypes}}' + '<p can-click=\'{doSomething}\'>{{content}}</p>' + '{{/each}}' + '</div>');
            var foodTypes = new CanList([
                {
                    title: 'Fruits',
                    content: 'oranges, apples'
                },
                {
                    title: 'Breads',
                    content: 'pasta, cereal'
                },
                {
                    title: 'Sweets',
                    content: 'ice cream, candy'
                }
            ]);
            var doSomething = function (foodType, el, ev) {
                ok(true, 'doSomething called');
                equal(el.nodeName.toLowerCase(), 'p', 'this is the element');
                equal(ev.type, 'click', '1st argument is the event');
                equal(foodType, foodTypes[0], '2nd argument is the 1st foodType');
            };
            var frag = template({
                foodTypes: foodTypes,
                doSomething: doSomething
            });
            var ta = this.fixture;
            ta.appendChild(frag);
            var p0 = ta.getElementsByTagName('p')[0];
            canEvent.trigger.call(p0, 'click');
        });
        test('can-value works with {} (#905)', function () {
            var template = stache('<input can-value=\'{age}\'/>');
            var map = new CanMap();
            var frag = template(map);
            var ta = this.fixture;
            ta.appendChild(frag);
            var input = ta.getElementsByTagName('input')[0];
            equal(input.value, '', 'input value set correctly if key does not exist in map');
            map.attr('age', '30');
            equal(input.value, '30', 'input value set correctly');
            map.attr('age', '31');
            equal(input.value, '31', 'input value update correctly');
            input.value = '32';
            canEvent.trigger.call(input, 'change');
            equal(map.attr('age'), '32', 'updated from input');
        });
        test('can-value select with null or undefined value (#813)', function () {
            var template = stache('<select id=\'null-select\' can-value=\'color-1\'>' + '<option value=\'\'>Choose</option>' + '<option value=\'red\'>Red</option>' + '<option value=\'green\'>Green</option>' + '</select>' + '<select id=\'undefined-select\' can-value=\'color-2\'>' + '<option value=\'\'>Choose</option>' + '<option value=\'red\'>Red</option>' + '<option value=\'green\'>Green</option>' + '</select>');
            var map = new CanMap({
                'color-1': null,
                'color-2': undefined
            });
            stop();
            var frag = template(map);
            var ta = this.fixture;
            ta.appendChild(frag);
            var nullInput = doc.getElementById('null-select');
            var nullInputOptions = nullInput.getElementsByTagName('option');
            var undefinedInput = doc.getElementById('undefined-select');
            var undefinedInputOptions = undefinedInput.getElementsByTagName('option');
            afterMutation(function () {
                ok(nullInputOptions[0].selected, 'default (null) value set');
                ok(undefinedInputOptions[0].selected, 'default (undefined) value set');
                start();
            });
        });
        test('radio type conversion (#811)', function () {
            var data = new CanMap({ id: 1 }), frag = stache('<input type="radio" can-value="id" value="1"/>')(data);
            domMutate.appendChild.call(this.fixture, frag);
            var input = this.fixture.getElementsByTagName('input')[0];
            ok(input.checked, 'checkbox value bound');
        });
        test('template with view binding breaks in stache, not in mustache (#966)', function () {
            var templateString = '<a href="javascript://" can-click="select">' + '{{#if thing}}\n<div />{{/if}}' + '<span>{{name}}</span>' + '</a>';
            var stacheRenderer = stache(templateString);
            var obj = new CanMap({ thing: 'stuff' });
            stacheRenderer(obj);
            ok(true, 'stache worked without errors');
        });
        test('can-event throws an error when inside #if block (#1182)', function (assert) {
            var done = assert.async();
            var flag = canCompute(false), clickHandlerCount = 0;
            var frag = stache('<div {{#if flag}}can-click=\'foo\'{{/if}}>Click</div>')({
                flag: flag,
                foo: function () {
                    clickHandlerCount++;
                }
            });
            var fixture = this.fixture;
            var trig = function () {
                var div = fixture.getElementsByTagName('div')[0];
                canEvent.trigger.call(div, { type: 'click' });
            };
            domMutate.appendChild.call(this.fixture, frag);
            trig();
            afterMutation(function () {
                equal(clickHandlerCount, 0, 'click handler not called');
                done();
            });
        });
        testIfRealDocument('can-EVENT removed in live bindings doesn\'t unbind (#1112)', function () {
            var flag = canCompute(true), clickHandlerCount = 0;
            var frag = stache('<div {{#if flag}}can-click=\'foo\'{{/if}}>Click</div>')({
                flag: flag,
                foo: function () {
                    clickHandlerCount++;
                }
            });
            var testEnv = this;
            var trig = function () {
                var div = testEnv.fixture.getElementsByTagName('div')[0];
                canEvent.trigger.call(div, { type: 'click' });
            };
            domMutate.appendChild.call(this.fixture, frag);
            stop();
            var numTrigs = 3;
            var testTimer = setInterval(function () {
                if (numTrigs--) {
                    trig();
                    flag(!flag());
                } else {
                    clearTimeout(testTimer);
                    equal(clickHandlerCount, 2, 'click handler called twice');
                    start();
                }
            }, 100);
        });
        test('can-value compute rejects new value (#887)', function () {
            var template = stache('<input can-value=\'age\'/>');
            var compute = canCompute(30, function (newVal, oldVal) {
                if (isNaN(+newVal)) {
                    return oldVal;
                } else {
                    return +newVal;
                }
            });
            var frag = template({ age: compute });
            var ta = this.fixture;
            ta.appendChild(frag);
            var input = ta.getElementsByTagName('input')[0];
            input.value = '30f';
            canEvent.trigger.call(input, 'change');
            equal(compute(), 30, 'Still the old value');
            equal(input.value, '30', 'Text input has also not changed');
        });
        testIfRealDocument('can-value select multiple applies initial value, when options rendered from array (#1414)', function () {
            var template = stache('<select can-value=\'colors\' multiple>' + '{{#each allColors}}<option value=\'{{value}}\'>{{label}}</option>{{/each}}' + '</select>');
            var map = new CanMap({
                colors: [
                    'red',
                    'green'
                ],
                allColors: [
                    {
                        value: 'red',
                        label: 'Red'
                    },
                    {
                        value: 'green',
                        label: 'Green'
                    },
                    {
                        value: 'blue',
                        label: 'Blue'
                    }
                ]
            });
            stop();
            var frag = template(map);
            var ta = this.fixture;
            ta.appendChild(frag);
            var select = ta.getElementsByTagName('select')[0], options = select.getElementsByTagName('option');
            afterMutation(function () {
                ok(options[0].selected, 'red should be set initially');
                ok(options[1].selected, 'green should be set initially');
                ok(!options[2].selected, 'blue should not be set initially');
                start();
            });
        });
        test('can-value with truthy and falsy values binds to checkbox (#1478)', function () {
            var data = new CanMap({ completed: 1 }), frag = stache('<input type="checkbox" can-value="completed"/>')(data);
            stop();
            domMutate.appendChild.call(this.fixture, frag);
            var input = this.fixture.getElementsByTagName('input')[0];
            equal(input.checked, true, 'checkbox value bound (via attr check)');
            data.attr('completed', 0);
            equal(input.checked, false, 'checkbox value bound (via attr check)');
            afterMutation(start);
        });
        test('can-EVENT can call intermediate functions before calling the final function(#1474)', function () {
            var ta = this.fixture;
            var template = stache('<div id=\'click-me\' can-click=\'{does.some.thing}\'></div>');
            var frag = template({
                does: function () {
                    return {
                        some: function () {
                            return {
                                thing: function (context) {
                                    ok(typeof context.does === 'function');
                                    start();
                                }
                            };
                        }
                    };
                }
            });
            stop();
            ta.appendChild(frag);
            canEvent.trigger.call(doc.getElementById('click-me'), 'click');
        });
        test('by default can-EVENT calls with values, not computes', function () {
            stop();
            var ta = this.fixture;
            var template = stache('<div id=\'click-me\' can-click=\'{map.method one map.two map.three}\'></div>');
            var one = canCompute(1);
            var three = canCompute(3);
            var MyMap = CanMap.extend({
                method: function (ONE, two, three) {
                    equal(ONE, 1);
                    equal(two, 2);
                    equal(three, 3);
                    equal(this, map, 'this set right');
                    start();
                }
            });
            var map = new MyMap({
                'two': 2,
                'three': three
            });
            var frag = template({
                one: one,
                map: map
            });
            ta.appendChild(frag);
            canEvent.trigger.call(doc.getElementById('click-me'), 'click');
        });
        test('Conditional can-EVENT bindings are bound/unbound', 2, function () {
            var state = new CanMap({
                enableClick: true,
                clickHandler: function () {
                    ok(true, '"click" was handled');
                }
            });
            var template = stache('<button id="find-me" {{#if enableClick}}can-click="{clickHandler}"{{/if}}></button>');
            var frag = template(state);
            var sandbox = this.fixture;
            sandbox.appendChild(frag);
            var btn = doc.getElementById('find-me');
            canEvent.trigger.call(btn, 'click');
            state.attr('enableClick', false);
            stop();
            afterMutation(function () {
                canEvent.trigger.call(btn, 'click');
                state.attr('enableClick', true);
                afterMutation(function () {
                    canEvent.trigger.call(btn, 'click');
                    start();
                });
            });
        });
        testIfRealDocument('<select can-value={value}> with undefined value selects option without value', function () {
            var template = stache('<select can-value=\'opt\'><option>Loading...</option></select>');
            var map = new CanMap();
            var frag = template(map);
            var ta = this.fixture;
            ta.appendChild(frag);
            var select = ta.childNodes.item(0);
            QUnit.equal(select.selectedIndex, 0, 'Got selected index');
        });
        testIfRealDocument('<select can-value> keeps its value as <option>s change with {{#list}} (#1762)', function () {
            var template = stache('<select can-value=\'{id}\'>{{#values}}<option value=\'{{.}}\'>{{.}}</option>{{/values}}</select>');
            var values = canCompute([
                '1',
                '2',
                '3',
                '4'
            ]);
            var id = canCompute('2');
            var frag = template({
                values: values,
                id: id
            });
            stop();
            var select = frag.firstChild;
            afterMutation(function () {
                ok(select.childNodes.item(1).selected, 'value is initially selected');
                values([
                    '7',
                    '2',
                    '5',
                    '4'
                ]);
                ok(select.childNodes.item(1).selected, 'after changing options, value should still be selected');
                start();
            });
        });
        testIfRealDocument('<select can-value> keeps its value as <option>s change with {{#each}} (#1762)', function () {
            var template = stache('<select can-value=\'{id}\'>{{#each values}}<option value=\'{{.}}\'>{{.}}</option>{{/each}}</select>');
            var values = canCompute([
                '1',
                '2',
                '3',
                '4'
            ]);
            var id = canCompute('2');
            var frag = template({
                values: values,
                id: id
            });
            stop();
            var select = frag.firstChild;
            var options = select.getElementsByTagName('option');
            afterMutation(function () {
                ok(options[1].selected, 'value is initially selected');
                values([
                    '7',
                    '2',
                    '5',
                    '4'
                ]);
                afterMutation(function () {
                    ok(options[1].selected, 'after changing options, value should still be selected');
                    start();
                });
            });
        });
        test('(event) methods on objects are called (#1839)', function () {
            var template = stache('<div ($click)=\'setSomething person.message\'/>');
            var data = {
                setSomething: function (message) {
                    equal(message, 'Matthew P finds good bugs');
                    equal(this, data, 'setSomething called with correct scope');
                },
                person: {
                    name: 'Matthew P',
                    message: function () {
                        return this.name + ' finds good bugs';
                    }
                }
            };
            var frag = template(data);
            canEvent.trigger.call(frag.firstChild, 'click');
        });
        test('(event) methods on objects are called with call expressions (#1839)', function () {
            var template = stache('<div ($click)=\'setSomething(person.message)\'/>');
            var data = {
                setSomething: function (message) {
                    equal(message, 'Matthew P finds good bugs');
                    equal(this, data, 'setSomething called with correct scope');
                },
                person: {
                    name: 'Matthew P',
                    message: function () {
                        return this.name + ' finds good bugs';
                    }
                }
            };
            var frag = template(data);
            canEvent.trigger.call(frag.firstChild, 'click');
        });
        test('two way - viewModel (#1700)', function () {
            var template = stache('<div {(view-model-prop)}=\'scopeProp\'/>');
            var map = new CanMap({ scopeProp: 'Hello' });
            var scopeMapSetCalled = 0;
            var origMapSetKeyValue = map[canSymbol.for('can.setKeyValue')];
            map[canSymbol.for('can.setKeyValue')] = function (attrName, value) {
                if (typeof attrName === 'string' && arguments.length > 1) {
                    scopeMapSetCalled++;
                }
                return origMapSetKeyValue.apply(this, arguments);
            };
            var origMapSet = map._set;
            map._set = function (attrName, value) {
                if (typeof attrName === 'string' && arguments.length > 1) {
                    scopeMapSetCalled++;
                }
                return origMapSet.apply(this, arguments);
            };
            var frag = template(map);
            var viewModel = canViewModel(frag.firstChild);
            equal(scopeMapSetCalled, 0, 'set is not called on scope map');
            equal(viewModel.attr('viewModelProp'), 'Hello', 'initial value set');
            viewModel = canViewModel(frag.firstChild);
            var viewModelSetCalled = 1;
            var origViewModelSet = viewModel[canSymbol.for('can.setKeyValue')];
            viewModel[canSymbol.for('can.setKeyValue')] = function (attrName) {
                if (typeof attrName === 'string' && arguments.length > 1) {
                    viewModelSetCalled++;
                }
                return origViewModelSet.apply(this, arguments);
            };
            viewModel.attr('viewModelProp', 'HELLO');
            equal(map.attr('scopeProp'), 'HELLO', 'binding from child to parent');
            equal(scopeMapSetCalled, 1, 'set is called on scope map');
            equal(viewModelSetCalled, 2, 'set is called viewModel');
            map.attr('scopeProp', 'WORLD');
            equal(viewModel.attr('viewModelProp'), 'WORLD', 'binding from parent to child');
            equal(scopeMapSetCalled, 2, 'set is called again on scope map');
            equal(viewModelSetCalled, 3, 'set is called again on viewModel');
        });
        test('two-way - DOM - input text (#1700)', function () {
            var template = stache('<input {($value)}=\'age\'/>');
            var map = new CanMap();
            var frag = template(map);
            var ta = this.fixture;
            ta.appendChild(frag);
            var input = ta.getElementsByTagName('input')[0];
            equal(input.value, '', 'input value set correctly if key does not exist in map');
            map.attr('age', '30');
            stop();
            afterMutation(function () {
                start();
                equal(input.value, '30', 'input value set correctly');
                map.attr('age', '31');
                stop();
                afterMutation(function () {
                    start();
                    equal(input.value, '31', 'input value update correctly');
                    input.value = '32';
                    canEvent.trigger.call(input, 'change');
                    stop();
                    afterMutation(function () {
                        start();
                        equal(map.attr('age'), '32', 'updated from input');
                    });
                });
            });
        });
        test('two-way - DOM - {($checked)} with truthy and falsy values binds to checkbox (#1700)', function () {
            var data = new CanMap({ completed: 1 }), frag = stache('<input type="checkbox" {($checked)}="completed"/>')(data);
            domMutate.appendChild.call(this.fixture, frag);
            var input = this.fixture.getElementsByTagName('input')[0];
            equal(input.checked, true, 'checkbox value bound (via attr check)');
            data.attr('completed', 0);
            stop();
            afterMutation(function () {
                start();
                equal(input.checked, false, 'checkbox value bound (via attr check)');
            });
        });
        test('one-way - DOM - {$checked} with undefined (#135)', function () {
            var data = new CanMap({ completed: undefined }), frag = stache('<input type="checkbox" {$checked}="completed"/>')(data);
            domMutate.appendChild.call(this.fixture, frag);
            var input = this.fixture.getElementsByTagName('input')[0];
            equal(input.checked, false, 'checkbox value should be false for undefined');
        });
        test('one-way - DOM - parent value undefined (#189)', function () {
            MockComponent.extend({
                tag: 'toggle-button',
                viewModel: {
                    value: false,
                    toggle: function () {
                        this.attr('value', !this.attr('value'));
                    }
                },
                template: stache('<button type="button" ($click)="toggle()">{{value}}</button>')
            });
            var template = stache('<toggle-button {(value)}="./does-not-exist" />');
            var fragment = template({});
            domMutate.appendChild.call(this.fixture, fragment);
            var button = this.fixture.getElementsByTagName('button')[0];
            function text(node) {
                while (node && node.nodeType !== 3) {
                    node = node.firstChild;
                }
                return node && node.nodeValue;
            }
            equal(text(button), 'false', 'Initial value is "false"');
            canEvent.trigger.call(button, 'click');
            equal(text(button), 'true', 'Value is "true" after first click');
            canEvent.trigger.call(button, 'click');
            equal(text(button), 'false', 'Value is "false" after second click');
        });
        test('two-way - reference - {(child)}="*ref" (#1700)', function () {
            var data = new CanMap({ person: { name: {} } });
            MockComponent.extend({
                tag: 'reference-export',
                viewModel: { tag: 'reference-export' }
            });
            MockComponent.extend({
                tag: 'ref-import',
                viewModel: { tag: 'ref-import' }
            });
            var template = stache('<reference-export {(name)}=\'*refName\'/>' + '<ref-import {(name)}=\'*refName\'/> {{helperToGetScope}}');
            var scope;
            var frag = template(data, {
                helperToGetScope: function (options) {
                    scope = options.scope;
                }
            });
            var refExport = canViewModel(frag.firstChild);
            var refImport = canViewModel(frag.firstChild.nextSibling);
            refExport.attr('name', 'v1');
            equal(scope.getRefs()._context.attr('*refName'), 'v1', 'reference scope updated');
            equal(refImport.attr('name'), 'v1', 'updated ref-import');
            refImport.attr('name', 'v2');
            equal(refExport.attr('name'), 'v2', 'updated ref-export');
            equal(scope.getRefs()._context.attr('*refName'), 'v2', 'actually put in refs scope');
        });
        test('two-way - reference shorthand (#1700)', function () {
            var data = new CanMap({ person: { name: {} } });
            MockComponent.extend({
                tag: 'reference-export',
                template: stache('<span>{{*referenceExport.name}}</span>'),
                viewModel: {}
            });
            var template = stache('{{#person}}{{#name}}' + '<reference-export *reference-export/>' + '{{/name}}{{/person}}<span>{{*referenceExport.name}}</span>');
            var frag = template(data);
            var refExport = canViewModel(frag.firstChild);
            refExport.attr('name', 'done');
            equal(frag.lastChild.firstChild.nodeValue, 'done');
            equal(frag.firstChild.firstChild.firstChild.nodeValue, '', 'not done');
        });
        test('one-way - parent to child - viewModel', function () {
            var template = stache('<div {view-model-prop}=\'scopeProp\'/>');
            var map = new CanMap({ scopeProp: 'Venus' });
            var frag = template(map);
            var viewModel = canViewModel(frag.firstChild);
            equal(viewModel.attr('viewModelProp'), 'Venus', 'initial value set');
            viewModel.attr('viewModelProp', 'Earth');
            equal(map.attr('scopeProp'), 'Venus', 'no binding from child to parent');
            map.attr('scopeProp', 'Mars');
            equal(viewModel.attr('viewModelProp'), 'Mars', 'binding from parent to child');
        });
        test('one-way - child to parent - viewModel', function () {
            MockComponent.extend({
                tag: 'view-model-able',
                viewModel: { viewModelProp: 'Mercury' }
            });
            var template = stache('<view-model-able {^view-model-prop}=\'scopeProp\'/>');
            var map = new CanMap({ scopeProp: 'Venus' });
            var frag = template(map);
            var viewModel = canViewModel(frag.firstChild);
            equal(viewModel.attr('viewModelProp'), 'Mercury', 'initial value kept');
            equal(map.attr('scopeProp'), 'Mercury', 'initial value set on parent');
            viewModel.attr('viewModelProp', 'Earth');
            equal(map.attr('scopeProp'), 'Earth', 'binding from child to parent');
            map.attr('scopeProp', 'Mars');
            equal(viewModel.attr('viewModelProp'), 'Earth', 'no binding from parent to child');
        });
        test('one way - child to parent - importing viewModel {^.}="test"', function () {
            MockComponent.extend({
                tag: 'import-scope',
                template: stache('Hello {{name}}'),
                viewModel: {
                    name: 'David',
                    age: 7
                }
            });
            MockComponent.extend({
                tag: 'import-parent',
                template: stache('<import-scope {^.}="test"></import-scope>' + '<div>Imported: {{test.name}} {{test.age}}</div>')
            });
            var template = stache('<import-parent></import-parent>');
            var frag = template({});
            equal(frag.childNodes.item(0).childNodes.item(1).innerHTML, 'Imported: David 7', '{.} component scope imported into variable');
        });
        test('one way - child to parent - importing viewModel {^prop}="test"', function () {
            MockComponent.extend({
                tag: 'import-prop-scope',
                template: stache('Hello {{name}}'),
                viewModel: {
                    name: 'David',
                    age: 7
                }
            });
            MockComponent.extend({
                tag: 'import-prop-parent',
                template: stache('<import-prop-scope {^name}="test"></import-prop-scope>' + '<div>Imported: {{test}}</div>')
            });
            var template = stache('<import-prop-parent></import-prop-parent>');
            var frag = template({});
            equal(frag.childNodes.item(0).childNodes.item(1).innerHTML, 'Imported: David', '{name} component scope imported into variable');
        });
        test('one way - child to parent - importing viewModel {^hypenated-prop}="test"', function () {
            MockComponent.extend({
                tag: 'import-prop-scope',
                template: stache('Hello {{userName}}'),
                viewModel: {
                    userName: 'David',
                    age: 7,
                    updateName: function () {
                        this.attr('userName', 'Justin');
                    }
                }
            });
            MockComponent.extend({
                tag: 'import-prop-parent',
                template: stache('<import-prop-scope {^user-name}="test" {^.}="childComponent"></import-prop-scope>' + '<div>Imported: {{test}}</div>')
            });
            var template = stache('<import-prop-parent></import-prop-parent>');
            var frag = template({});
            var importPropParent = frag.firstChild;
            var importPropScope = importPropParent.getElementsByTagName('import-prop-scope')[0];
            canViewModel(importPropScope).updateName();
            var importPropParentViewModel = canViewModel(importPropParent);
            equal(importPropParentViewModel.attr('test'), 'Justin', 'got hypenated prop');
            equal(importPropParentViewModel.attr('childComponent'), canViewModel(importPropScope), 'got view model');
        });
        test('viewModel binding (event)', function () {
            MockComponent.extend({
                tag: 'viewmodel-binding',
                viewModel: {
                    makeMyEvent: function () {
                        this.dispatch('myevent');
                    }
                }
            });
            var frag = stache('<viewmodel-binding (myevent)=\'doSomething()\'/>')({
                doSomething: function () {
                    ok(true, 'called!');
                }
            });
            canViewModel(frag.firstChild).makeMyEvent();
        });
        test('checkboxes with {($checked)} bind properly', function () {
            var data = new CanMap({ completed: true }), frag = stache('<input type="checkbox" {($checked)}="completed"/>')(data);
            domMutate.appendChild.call(this.fixture, frag);
            var input = this.fixture.getElementsByTagName('input')[0];
            equal(input.checked, data.attr('completed'), 'checkbox value bound (via attr check)');
            data.attr('completed', false);
            equal(input.checked, data.attr('completed'), 'checkbox value bound (via attr uncheck)');
            input.checked = true;
            canEvent.trigger.call(input, 'change');
            stop();
            afterMutation(function () {
                start();
                equal(input.checked, true, 'checkbox value bound (via check)');
                equal(data.attr('completed'), true, 'checkbox value bound (via check)');
                input.checked = false;
                canEvent.trigger.call(input, 'change');
                stop();
                afterMutation(function () {
                    start();
                    equal(input.checked, false, 'checkbox value bound (via uncheck)');
                    equal(data.attr('completed'), false, 'checkbox value bound (via uncheck)');
                });
            });
        });
        test('two-way element empty value (1996)', function () {
            var template = stache('<input can-value=\'age\'/>');
            var map = new CanMap();
            var frag = template(map);
            var ta = this.fixture;
            ta.appendChild(frag);
            var input = ta.getElementsByTagName('input')[0];
            equal(input.value, '', 'input value set correctly if key does not exist in map');
            map.attr('age', '30');
            equal(input.value, '30', 'input value set correctly');
            map.attr('age', '31');
            equal(input.value, '31', 'input value update correctly');
            input.value = '';
            canEvent.trigger.call(input, 'change');
            equal(map.attr('age'), '', 'updated from input');
        });
        test('exporting methods (#2051)', function () {
            expect(2);
            MockComponent.extend({
                tag: 'foo-bar',
                viewModel: {
                    method: function () {
                        ok(true, 'foo called');
                        return 5;
                    }
                }
            });
            var template = stache('<foo-bar {^@method}=\'@*refKey\'></foo-bar>{{*refKey()}}');
            var frag = template({});
            equal(frag.lastChild.nodeValue, '5');
        });
        test('renders dynamic custom attributes (#1800)', function () {
            var template = stache('<ul>{{#actions}}<li can-click=\'{{.}}\'>{{.}}</li>{{/actions}}</ul>');
            var map = new CanMap({
                actions: [
                    'action1',
                    'action2'
                ],
                action1: function () {
                    equal(calling, 0, 'action1');
                },
                action2: function () {
                    equal(calling, 1, 'action2');
                }
            });
            var frag = template(map), lis = frag.firstChild.getElementsByTagName('li');
            var calling = 0;
            canEvent.trigger.call(lis[0], 'click');
            calling = 1;
            canEvent.trigger.call(lis[1], 'click');
        });
        if (System.env.indexOf('production') < 0) {
            test('warning on a mismatched quote (#1995)', function () {
                expect(4);
                var oldlog = dev.warn, message = 'can-stache-bindings: mismatched binding syntax - (foo}';
                var thisTest = QUnit.config.current;
                dev.warn = function (text) {
                    if (QUnit.config.current === thisTest) {
                        equal(text, message, 'Got expected message logged.');
                    }
                };
                stache('<div (foo}=\'bar\'/>')();
                message = 'can-stache-bindings: mismatched binding syntax - {foo)';
                stache('<div {foo)=\'bar\'/>')();
                message = 'can-stache-bindings: mismatched binding syntax - {(foo})';
                stache('<div {(foo})=\'bar\'/>')();
                message = 'can-stache-bindings: mismatched binding syntax - ({foo})';
                stache('<div ({foo})=\'bar\'/>')();
                dev.warn = oldlog;
            });
        }
        testIfRealDocument('One way binding from a select\'s value to a parent compute updates the parent with the select\'s initial value (#2027)', function () {
            var template = stache('<select {^$value}=\'value\'><option value=\'One\'>One</option></select>');
            var map = new CanMap();
            var frag = template(map);
            var select = frag.childNodes.item(0);
            afterMutation(function () {
                equal(select.selectedIndex, 0, 'selectedIndex is 0 because no value exists on the map');
                equal(map.attr('value'), 'One', 'The map\'s value property is set to the select\'s value');
                start();
            });
            stop();
        });
        testIfRealDocument('two way binding from a select\'s value to null has no selection (#2027)', function () {
            var template = stache('<select {($value)}=\'key\'><option value=\'One\'>One</option></select>');
            var map = new CanMap({ key: null });
            var frag = template(map);
            var select = frag.childNodes.item(0);
            afterMutation(function () {
                equal(select.selectedIndex, -1, 'selectedIndex is 0 because no value exists on the map');
                equal(map.attr('key'), null, 'The map\'s value property is set to the select\'s value');
                start();
            });
            stop();
        });
        testIfRealDocument('two-way bound values that do not match a select option set selectedIndex to -1 (#2027)', function () {
            var renderer = stache('<select {($value)}="key"><option value="foo">foo</option><option value="bar">bar</option></select>');
            var map = new CanMap({});
            var frag = renderer(map);
            equal(frag.firstChild.selectedIndex, 0, 'undefined <- {($first value)}: selectedIndex = 0');
            map.attr('key', 'notfoo');
            stop();
            afterMutation(function () {
                start();
                equal(frag.firstChild.selectedIndex, -1, 'notfoo: selectedIndex = -1');
                map.attr('key', 'foo');
                strictEqual(frag.firstChild.selectedIndex, 0, 'foo: selectedIndex = 0');
                map.attr('key', 'notbar');
                stop();
                afterMutation(function () {
                    start();
                    equal(frag.firstChild.selectedIndex, -1, 'notbar: selectedIndex = -1');
                    map.attr('key', 'bar');
                    strictEqual(frag.firstChild.selectedIndex, 1, 'bar: selectedIndex = 1');
                    map.attr('key', 'bar');
                    strictEqual(frag.firstChild.selectedIndex, 1, 'bar (no change): selectedIndex = 1');
                });
            });
        });
        testIfRealDocument('two way bound select empty string null or undefined value (#2027)', function () {
            var template = stache('<select id=\'null-select\' {($value)}=\'color-1\'>' + '<option value=\'\'>Choose</option>' + '<option value=\'red\'>Red</option>' + '<option value=\'green\'>Green</option>' + '</select>' + '<select id=\'undefined-select\' {($value)}=\'color-2\'>' + '<option value=\'\'>Choose</option>' + '<option value=\'red\'>Red</option>' + '<option value=\'green\'>Green</option>' + '</select>' + '<select id=\'string-select\' {($value)}=\'color-3\'>' + '<option value=\'\'>Choose</option>' + '<option value=\'red\'>Red</option>' + '<option value=\'green\'>Green</option>' + '</select>');
            var map = new CanMap({
                'color-1': null,
                'color-2': undefined,
                'color-3': ''
            });
            stop();
            var frag = template(map);
            domMutate.appendChild.call(this.fixture, frag);
            var nullInput = doc.getElementById('null-select');
            var nullInputOptions = nullInput.getElementsByTagName('option');
            var undefinedInput = doc.getElementById('undefined-select');
            var undefinedInputOptions = undefinedInput.getElementsByTagName('option');
            var stringInput = doc.getElementById('string-select');
            var stringInputOptions = stringInput.getElementsByTagName('option');
            afterMutation(function () {
                ok(!nullInputOptions[0].selected, 'default (null) value set');
                ok(undefinedInputOptions[0].selected, 'default (undefined) value set');
                ok(stringInputOptions[0].selected, 'default (\'\') value set');
                start();
            });
        });
        if (System.env !== 'canjs-test') {
            test('dynamic attribute bindings (#2016)', function (assert) {
                var done = assert.async();
                var template = stache('<input {($value)}=\'{{propName}}\'/>');
                var map = new CanMap({
                    propName: 'first',
                    first: 'Justin',
                    last: 'Meyer'
                });
                var frag = template(map);
                var ta = this.fixture;
                ta.appendChild(frag);
                var input = ta.getElementsByTagName('input')[0];
                afterMutation(function () {
                    equal(input.value, 'Justin', 'input value set correctly if key does not exist in map');
                    map.attr('propName', 'last');
                    afterMutation(function () {
                        equal(input.value, 'Meyer', 'input value set correctly if key does not exist in map');
                        input.value = 'Lueke';
                        canEvent.trigger.call(input, 'change');
                        afterMutation(function () {
                            equal(map.attr('last'), 'Lueke', 'updated from input');
                            done();
                        });
                    });
                });
            });
        }
        test('select bindings respond to changes immediately or during insert (#2134)', function () {
            var countries = [
                {
                    code: 'MX',
                    countryName: 'MEXICO'
                },
                {
                    code: 'US',
                    countryName: 'USA'
                },
                {
                    code: 'IND',
                    countryName: 'INDIA'
                },
                {
                    code: 'RUS',
                    countryName: 'RUSSIA'
                }
            ];
            var template = stache('<select {($value)}="countryCode">' + '{{#each countries}}' + '<option value="{{code}}">{{countryName}}</option>' + '{{/each}}' + '</select>');
            var data = new CanMap({
                countryCode: 'US',
                countries: countries
            });
            var frag = template(data);
            data.attr('countryCode', 'IND');
            stop();
            afterMutation(function () {
                start();
                equal(frag.firstChild.value, 'IND', 'got last updated value');
            });
        });
        test('select bindings respond to changes immediately or during insert using can-value (#2134)', function () {
            var countries = [
                {
                    code: 'MX',
                    countryName: 'MEXICO'
                },
                {
                    code: 'US',
                    countryName: 'USA'
                },
                {
                    code: 'IND',
                    countryName: 'INDIA'
                },
                {
                    code: 'RUS',
                    countryName: 'RUSSIA'
                }
            ];
            var template = stache('<select can-value="{countryCode}">' + '{{#each countries}}' + '<option value="{{code}}">{{countryName}}</option>' + '{{/each}}' + '</select>');
            var data = new CanMap({
                countryCode: 'US',
                countries: countries
            });
            var frag = template(data);
            data.attr('countryCode', 'IND');
            stop();
            afterMutation(function () {
                start();
                equal(frag.firstChild.value, 'IND', 'got last updated value');
            });
        });
        testIfRealDocument('two-way <select> bindings update to `undefined` if options are replaced (#1762)', function () {
            var countries = [
                {
                    code: 'MX',
                    countryName: 'MEXICO'
                },
                {
                    code: 'US',
                    countryName: 'USA'
                }
            ];
            var data = new CanMap({
                countryCode: 'US',
                countries: countries
            });
            var template = stache('<select {($value)}="countryCode">' + '{{#countries}}' + '<option value="{{code}}">{{countryName}}</option>' + '{{/countries}}' + '</select>');
            template(data);
            stop();
            afterMutation(function () {
                data.attr('countries').replace([]);
                afterMutation(function () {
                    equal(data.attr('countryCode'), undefined, 'countryCode set to undefined');
                    start();
                });
            });
        });
        testIfRealDocument('two-way <select> bindings update to `undefined` if options are replaced - each (#1762)', function () {
            var countries = [
                {
                    code: 'MX',
                    countryName: 'MEXICO'
                },
                {
                    code: 'US',
                    countryName: 'USA'
                }
            ];
            var data = new CanMap({
                countryCode: 'US',
                countries: countries
            });
            var template = stache('<select {($value)}="countryCode">' + '{{#each countries}}' + '<option value="{{code}}">{{countryName}}</option>' + '{{/each}}' + '</select>');
            template(data);
            stop();
            afterMutation(function () {
                data.attr('countries').replace([]);
                afterMutation(function () {
                    equal(data.attr('countryCode'), undefined, 'countryCode set to undefined');
                    start();
                });
            });
        });
        testIfRealDocument('previously non-existing select value gets selected from a list when it is added (#1762)', function () {
            var template = stache('<select {($value)}="{person}">' + '<option></option>' + '{{#each people}}<option value="{{.}}">{{.}}</option>{{/each}}' + '</select>' + '<input type="text" size="5" {($value)}="person">');
            var people = new CanList([
                'Alexis',
                'Mihael',
                'Curtis',
                'David'
            ]);
            var vm = new CanMap({
                person: 'Brian',
                people: people
            });
            stop();
            vm.bind('person', function (ev, newVal, oldVal) {
                ok(false, 'person attribute should not change');
            });
            var frag = template(vm);
            equal(vm.attr('person'), 'Brian', 'Person is still set');
            afterMutation(function () {
                people.push('Brian');
                afterMutation(function () {
                    var select = frag.firstChild;
                    ok(select.lastChild.selected, 'New child should be selected');
                    start();
                });
            });
        });
        test('one-way <select> bindings keep value if options are replaced (#1762)', function () {
            var countries = [
                {
                    code: 'MX',
                    countryName: 'MEXICO'
                },
                {
                    code: 'US',
                    countryName: 'USA'
                }
            ];
            var data = new CanMap({
                countryCode: 'US',
                countries: countries
            });
            var template = stache('<select {$value}="countryCode">' + '{{#countries}}' + '<option value="{{code}}">{{countryName}}</option>' + '{{/countries}}' + '</select>');
            var frag = template(data);
            var select = frag.firstChild;
            stop();
            afterMutation(function () {
                data.attr('countries').replace([]);
                afterMutation(function () {
                    data.attr('countries').replace(countries);
                    equal(data.attr('countryCode'), 'US', 'country kept as USA');
                    afterMutation(function () {
                        ok(select.getElementsByTagName('option')[1].selected, 'USA still selected');
                    });
                    start();
                });
            });
        });
        test('one-way <select> bindings keep value if options are replaced - each (#1762)', function () {
            var countries = [
                {
                    code: 'MX',
                    countryName: 'MEXICO'
                },
                {
                    code: 'US',
                    countryName: 'USA'
                }
            ];
            var data = new CanMap({
                countryCode: 'US',
                countries: countries
            });
            var template = stache('<select {$value}="countryCode">' + '{{#each countries}}' + '<option value="{{code}}">{{countryName}}</option>' + '{{/each}}' + '</select>');
            var frag = template(data);
            var select = frag.firstChild;
            stop();
            afterMutation(function () {
                data.attr('countries').replace([]);
                afterMutation(function () {
                    data.attr('countries').replace(countries);
                    equal(data.attr('countryCode'), 'US', 'country kept as USA');
                    afterMutation(function () {
                        ok(select.getElementsByTagName('option')[1].selected, 'USA still selected');
                    });
                    start();
                });
            });
        });
        test('@function reference to child (#2116)', function () {
            expect(2);
            var template = stache('<foo-bar {@child}="@parent"></foo-bar>');
            MockComponent.extend({
                tag: 'foo-bar',
                viewModel: {
                    method: function () {
                        ok(false, 'should not be called');
                    }
                }
            });
            var VM = CanMap.extend({
                parent: function () {
                    ok(false, 'should not be called');
                }
            });
            var vm = new VM({});
            var frag = template(vm);
            equal(typeof canViewModel(frag.firstChild).attr('child'), 'function', 'to child binding');
            template = stache('<foo-bar {^@method}="@vmMethod"></foo-bar>');
            vm = new VM({});
            template(vm);
            ok(typeof vm.attr('vmMethod') === 'function', 'parent export function');
        });
        test('setter only gets called once (#2117)', function () {
            expect(1);
            var VM = CanMap.extend({
                __set: function (prop, val) {
                    if (prop === 'bar') {
                        equal(val, 'BAR');
                    }
                    return CanMap.prototype.__set.apply(this, arguments);
                }
            });
            MockComponent.extend({
                tag: 'foo-bar',
                viewModel: VM
            });
            var template = stache('<foo-bar {bar}="bar"/>');
            template(new CanMap({ bar: 'BAR' }));
        });
        test('function reference to child binding (#2116)', function () {
            expect(2);
            var template = stache('<foo-bar {child}="@parent"></foo-bar>');
            MockComponent.extend({
                tag: 'foo-bar',
                viewModel: {}
            });
            var VM = CanMap.extend({});
            var vm = new VM({});
            var frag = template(vm);
            vm.attr('parent', function () {
                ok(false, 'should not be called');
            });
            equal(typeof canViewModel(frag.firstChild).attr('child'), 'function', 'to child binding');
            template = stache('<foo-bar {^@method}="vmMethod"></foo-bar>');
            vm = new VM({});
            frag = template(vm);
            canViewModel(frag.firstChild).attr('method', function () {
                ok(false, 'method should not be called');
            });
            equal(typeof vm.attr('vmMethod'), 'function', 'parent export function');
        });
        test('backtrack path in to-parent bindings (#2132)', function () {
            MockComponent.extend({
                tag: 'parent-export',
                viewModel: { value: 'VALUE' }
            });
            var template = stache('{{#innerMap}}<parent-export {^value}=\'../parentValue\'/>{{/innerMap}}');
            var data = new CanMap({ innerMap: {} });
            template(data);
            equal(data.attr('parentValue'), 'VALUE', 'set on correct context');
            equal(data.attr('innerMap.parentValue'), undefined, 'nothing on innerMap');
        });
        test('two-way binding with empty strings (#2147)', function () {
            var template = stache('<select {($value)}=\'val\'>' + '<option value="">Loading...</option>' + '<option>Empty...</option>' + '</select>');
            var map = new CanMap({
                foo: true,
                val: ''
            });
            var frag = template(map);
            afterMutation(function () {
                equal(frag.firstChild.value, '', 'is an empty string');
                if (isRealDocument()) {
                    equal(frag.firstChild.selectedIndex, 0, 'empty strings are bound');
                }
                start();
            });
            stop();
        });
        test('double render with batched / unbatched events (#2223)', function () {
            var template = stache('{{#page}}{{doLog}}<input {($value)}=\'notAHelper\'/>{{/page}}');
            var appVM = new CanMap();
            var logCalls = 0;
            stache.registerHelper('doLog', function () {
                logCalls++;
            });
            template(appVM);
            canBatch.start();
            appVM.attr('page', true);
            canBatch.stop();
            appVM.attr('notAHelper', 'bar');
            stop();
            afterMutation(function () {
                start();
                equal(logCalls, 1, 'input rendered the right number of times');
            });
        });
        test('Child bindings updated before parent (#2252)', function () {
            var template = stache('{{#eq page \'view\'}}<child-binder {page}=\'page\'/>{{/eq}}');
            MockComponent.extend({
                tag: 'child-binder',
                template: stache('<span/>'),
                viewModel: {
                    __set: function (prop, val) {
                        if (prop === 'page') {
                            equal(val, 'view', 'value should not be edit');
                        }
                        return CanMap.prototype.__set.apply(this, arguments);
                    }
                }
            });
            var vm = new CanMap({ page: 'view' });
            template(vm);
            canBatch.start();
            vm.attr('page', 'edit');
            canBatch.stop();
        });
        test('can-value memory leak (#2270)', function () {
            var template = stache('<div><input can-value="foo"></div>');
            var vm = new CanMap({ foo: '' });
            var frag = template(vm);
            var ta = this.fixture;
            domMutate.appendChild.call(ta, frag);
            stop();
            afterMutation(function () {
                domMutate.removeChild.call(ta, ta.firstChild);
                afterMutation(function () {
                    var checkLifecycleBindings = function () {
                        if (vm.__bindEvents._lifecycleBindings === 0) {
                            equal(vm.__bindEvents._lifecycleBindings, 0, 'no bindings');
                            start();
                        } else {
                            setTimeout(checkLifecycleBindings, 10);
                        }
                    };
                    checkLifecycleBindings();
                });
            });
        });
        test('converters work (#2299)', function () {
            stache.registerHelper('numberToString', function (newVal, source) {
                if (newVal instanceof stacheExpression.SetIdentifier) {
                    source(newVal.value === '' ? null : +newVal.value);
                } else {
                    source = newVal;
                    return source() + '';
                }
            });
            var template = stache('<input {($value)}="numberToString(~age)">');
            var map = new CanMap({ age: 25 });
            var frag = template(map);
            equal(frag.firstChild.value, '25');
            equal(map.attr('age'), 25);
            map.attr('age', 33);
            equal(frag.firstChild.value, '33');
            equal(map.attr('age'), 33);
            frag.firstChild.value = '1';
            canEvent.trigger.call(frag.firstChild, 'change');
            stop();
            afterMutation(function () {
                start();
                equal(frag.firstChild.value, '1');
                equal(map.attr('age'), 1);
            });
        });
        test('Multi-select empty string works(#1263)', function () {
            var data = {
                isMultiple: 1,
                isSelect: 1,
                name: 'attribute_ 0',
                options: [
                    {
                        label: 'empty',
                        value: ''
                    },
                    {
                        label: 'zero',
                        value: 0
                    },
                    {
                        label: 'one',
                        value: 1
                    },
                    {
                        label: 'two',
                        value: 2
                    },
                    {
                        label: 'three',
                        value: 3
                    },
                    {
                        label: 'four',
                        value: 4
                    }
                ],
                value: [1]
            };
            var template = stache('<select {{#if isMultiple}}multiple{{/if}} can-value=\'value\'> ' + '{{#each options}} <option value=\'{{value}}\' >{{label}}</option>{{/each}} </select>');
            var frag = template(new CanMap(data));
            equal(frag.firstChild.getElementsByTagName('option')[0].selected, false, 'The first empty value is not selected');
        });
        test('$element is wrapped with types.wrapElement', function () {
            var $ = function (element) {
                this.element = element;
            };
            var wrapElement = types.wrapElement, unwrapElement = types.unwrapElement;
            types.wrapElement = function (element) {
                return new $(element);
            };
            types.unwrapElement = function (object) {
                return object.element;
            };
            var template = stache('<button ($click)=\'doSomething($element)\'>Clicky</button>');
            var MyMap = DefaultMap.extend({
                doSomething: function (element) {
                    types.wrapElement = wrapElement;
                    types.unwrapElement = unwrapElement;
                    ok(element instanceof $);
                }
            });
            var button = template(new MyMap()).firstChild;
            canEvent.trigger.call(button, 'click');
        });
        if (System.env.indexOf('production') < 0) {
            test('No warn on id=\'{{foo}}\' or class=\'{{bar}}\' expressions', function () {
                var _warn = dev.warn;
                dev.warn = function () {
                    ok(false, 'dev.warn was called incorrectly');
                    _warn.apply(dev, arguments);
                };
                try {
                    delete viewCallbacks._tags['special-attrs'];
                    expect(2);
                    MockComponent.extend({
                        tag: 'special-attrs',
                        viewModel: {
                            foo: 'skippy',
                            baz: 'xyzzy'
                        }
                    });
                    stache('<special-attrs id=\'{{foo}}\' class=\'{{baz}}\'></special-attrs>')({
                        foo: 'bar',
                        baz: 'quux'
                    });
                    stache('<special-attrs id=\'foo\' class=\'baz\'></special-attrs>')({
                        foo: 'bar',
                        baz: 'quux'
                    });
                    dev.warn = function () {
                        ok(true, 'dev.warn was called correctly');
                        _warn.apply(dev, arguments);
                    };
                    stache('<special-attrs id=\'{foo}\' class=\'{baz}\'></special-attrs>')({
                        foo: 'bar',
                        baz: 'quux'
                    });
                } finally {
                    dev.warn = _warn;
                }
            });
        }
        test('one-way pass computes to components with ~', function (assert) {
            expect(7);
            MockComponent.extend({ tag: 'foo-bar' });
            var baseVm = new CanMap({ foo: 'bar' });
            this.fixture.appendChild(stache('<foo-bar {compute}="~foo"></foo-bar>')(baseVm));
            var vm = canViewModel(this.fixture.firstChild);
            ok(vm.attr('compute').isComputed, 'Compute returned');
            equal(vm.attr('compute')(), 'bar', 'Compute has correct value');
            canReflect.onValue(vm.attr('compute'), function () {
                ok(true, 'Change handler called');
            });
            baseVm.attr('foo', 'quux');
            equal(vm.attr('compute')(), 'quux', 'Compute updates');
            vm.attr('compute')('xyzzy');
            equal(baseVm.attr('foo'), 'quux', 'Compute does not update the other direction');
            vm.attr('compute', 'notACompute');
            baseVm.attr('foo', 'thud');
            equal(vm.attr('compute')(), 'thud', 'Back to being a compute');
        });
        test('special values get called', function (assert) {
            assert.expect(2);
            var done = assert.async(1);
            MockComponent.extend({
                tag: 'ref-syntax',
                template: stache('<input ($change)="%scope.attr(\'*foo\', $element.value)">'),
                viewModel: new CanMap({
                    method: function () {
                        assert.ok(true, 'method called');
                        done();
                    }
                })
            });
            var template = stache('<ref-syntax ($inserted)="%viewModel.method()"></ref-syntax>');
            var frag = template({});
            domMutate.appendChild.call(this.fixture, frag);
            stop();
            afterMutation(function () {
                var input = doc.getElementsByTagName('input')[0];
                input.value = 'bar';
                canEvent.trigger.call(input, 'change');
                var scope = domData.get.call(this.fixture.firstChild).shadowScope;
                assert.equal(scope.get('*foo'), 'bar', 'Reference attribute set');
                start();
            }.bind(this));
        });
        test('%arguments gives the event arguments', function () {
            var template = stache('<button ($click)=\'doSomething(%event, %arguments)\'>Default Args</button>');
            var MyMap = DefaultMap.extend({
                doSomething: function (ev, args) {
                    equal(args[0], ev, 'default arg is ev');
                }
            });
            var frag = template(new MyMap());
            var button = frag.firstChild;
            canEvent.trigger.call(button, 'click');
        });
        if (System.env.indexOf('production') < 0) {
            test('Warning happens when changing the map that a to-parent binding points to.', function () {
                var tagName = 'merge-warn-test';
                delete viewCallbacks._tags[tagName];
                expect(4);
                var step1 = { 'baz': 'quux' };
                var overwrite = { 'plonk': 'waldo' };
                var useCanMap = true;
                var oldlog = dev.warn, message = 'can-view-scope: Merging data into "bar" because its parent is non-observable';
                var thisTest = QUnit.config.current;
                dev.warn = function (text) {
                    if (QUnit.config.current === thisTest) {
                        equal(text, message, 'Got expected message logged.');
                    }
                };
                MockComponent.extend({
                    tag: tagName,
                    viewModel: function () {
                        if (useCanMap) {
                            return new CanMap({ 'foo': {} });
                        } else {
                            return new DefaultMap({ 'foo': {} });
                        }
                    }
                });
                var template = stache('<merge-warn-test {(foo)}=\'bar\'/>');
                var viewModel = { bar: new DefaultMap(step1) };
                this.fixture.appendChild(template(viewModel));
                canViewModel(this.fixture.firstChild).attr('foo', overwrite);
                deepEqual(viewModel.bar.get(), overwrite, 'sanity check: parent binding set (default map -> default map)');
                this.fixture.removeChild(this.fixture.firstChild);
                useCanMap = false;
                viewModel.bar = new CanMap(step1);
                this.fixture.appendChild(template(viewModel));
                canViewModel(this.fixture.firstChild).set('foo', overwrite);
                deepEqual(viewModel.bar.attr(), overwrite, 'sanity check: parent binding set (can map -> default map)');
                dev.warn = oldlog;
            });
        }
        test('updates happen on two-way even when one binding is satisfied', function () {
            var template = stache('<input {($value)}="firstName"/>');
            var ViewModel = DefaultMap.extend({
                firstName: {
                    set: function (newValue) {
                        if (newValue) {
                            return newValue.toLowerCase();
                        }
                    }
                }
            });
            var viewModel = new ViewModel({ firstName: 'jeffrey' });
            stop();
            var frag = template(viewModel);
            domMutate.appendChild.call(this.fixture, frag);
            equal(this.fixture.firstChild.value, 'jeffrey');
            this.fixture.firstChild.value = 'JEFFREY';
            canEvent.trigger.call(this.fixture.firstChild, 'change');
            equal(this.fixture.firstChild.value, 'jeffrey');
            afterMutation(start);
        });
        test('updates happen on changed two-way even when one binding is satisfied', function () {
            stop();
            var template = stache('<input {($value)}="{{bindValue}}"/>');
            var ViewModel = DefaultMap.extend({
                firstName: {
                    set: function (newValue) {
                        if (newValue) {
                            return newValue.toLowerCase();
                        }
                    }
                },
                lastName: {
                    set: function (newValue) {
                        if (newValue) {
                            return newValue.toLowerCase();
                        }
                    }
                },
                bindValue: 'string'
            });
            var viewModel = new ViewModel({
                firstName: 'Jeffrey',
                lastName: 'King',
                bindValue: 'firstName'
            });
            var frag = template(viewModel);
            domMutate.appendChild.call(this.fixture, frag);
            afterMutation(function () {
                equal(this.fixture.firstChild.value, 'jeffrey');
                viewModel.bindValue = 'lastName';
                afterMutation(function () {
                    equal(this.fixture.firstChild.value, 'king');
                    this.fixture.firstChild.value = 'KING';
                    canEvent.trigger.call(this.fixture.firstChild, 'change');
                    equal(this.fixture.firstChild.value, 'king');
                    start();
                }.bind(this));
            }.bind(this));
        });
        test('plain data objects should work for checkboxes [can-value] (#161)', function () {
            var template = stache([
                '<input type="checkbox" name="status1" value="yes" can-value="status" can-true-value="yes"/>',
                '<input type="checkbox" name="status2" value="no" can-value="status" can-true-value="no"/>'
            ].join(''));
            var object = { status: 'yes' };
            var fragment = template(object);
            domMutate.appendChild.call(this.fixture, fragment);
            var yesInput = this.fixture.firstChild;
            var noInput = this.fixture.firstChild.nextSibling;
            equal(yesInput.checked, true, 'yes-checkbox is initially checked');
            equal(noInput.checked, false, 'no-checkbox is initially not checked');
        });
        test('plain data objects should work for radio buttons [can-value] (#161)', function () {
            var template = stache([
                '<input type="radio" name="status" value="no" can-value="status"/>',
                '<input type="radio" name="status" value="yes" can-value="status"/>'
            ].join(''));
            var object = { status: 'no' };
            var fragment = template(object);
            domMutate.appendChild.call(this.fixture, fragment);
            var noInput = this.fixture.firstChild;
            var yesInput = this.fixture.firstChild.nextSibling;
            equal(noInput.checked, true, 'no-radio is initially checked');
            equal(yesInput.checked, false, 'yes-radio is initially not checked');
        });
        test('changing a scope property calls registered stache helper', function () {
            expect(1);
            stop();
            var scope = new CanMap({ test: 'testval' });
            MockComponent.extend({
                tag: 'test-component',
                viewModel: scope,
                template: stache('<span>Hello world</span>')
            });
            stache.registerHelper('propChangeEventStacheHelper', function () {
                start();
                ok(true, 'helper called');
            });
            var template = stache('<test-component (test)="propChangeEventStacheHelper" />');
            template(new CanMap({}));
            scope.attr('test', 'changed');
        });
        test('changing a scope property calls registered stache helper\'s returned function', function () {
            expect(1);
            stop();
            var scope = new CanMap({ test: 'testval' });
            MockComponent.extend({
                tag: 'test-component',
                viewModel: scope,
                template: stache('<span>Hello world</span>')
            });
            stache.registerHelper('propChangeEventStacheHelper', function () {
                return function () {
                    start();
                    ok(true, 'helper\'s returned function called');
                };
            });
            var template = stache('<test-component (test)="propChangeEventStacheHelper" />');
            template(new CanMap({}));
            scope.attr('test', 'changed');
        });
        test('scope method called when scope property changes (#197)', function () {
            stop();
            expect(1);
            MockComponent.extend({ tag: 'view-model-able' });
            var template = stache('<view-model-able (. prop)=\'someMethod\'/>');
            var map = new CanMap({
                prop: 'Mercury',
                someMethod: function (scope, el, ev, newVal) {
                    start();
                    ok(true, 'method called');
                }
            });
            template(map);
            map.attr('prop', 'Venus');
        });
        test('scope method called when nested scope property changes (#216)', function () {
            stop();
            expect(1);
            var template = stache('<div (./prop nestedprop)=\'someMethod\'/>');
            var map = new CanMap({
                prop: new CanMap({ nestedprop: 'Mercury' }),
                someMethod: function (scope, el, ev, newVal) {
                    start();
                    ok(true, 'method called');
                }
            });
            template(map);
            map.attr('prop.nestedprop', 'Venus');
        });
        test('change event handler set up when binding on radiochange (#206)', function () {
            stop();
            var template = stache('<input type="radio" {($checked)}="attending" />');
            var map = new CanMap({
                attending: function () {
                    start();
                    ok(true, 'method called');
                }
            });
            var frag = template(map);
            var input = frag.firstChild;
            input.checked = true;
            canEvent.trigger.call(input, 'change');
            QUnit.equal(map.attr('attending'), true, 'now it is true');
        });
        test('call expressions work (#208)', function () {
            expect(2);
            stache.registerHelper('addTwo', function (arg) {
                return arg + 2;
            });
            stache.registerHelper('helperWithArgs', function (arg) {
                QUnit.equal(arg, 3, 'got the helper');
                ok(true, 'helper called');
            });
            var template = stache('<p ($click)=\'helperWithArgs(addTwo(arg))\'></p>');
            var frag = template({ arg: 1 });
            this.fixture.appendChild(frag);
            var p0 = this.fixture.getElementsByTagName('p')[0];
            canEvent.trigger.call(p0, 'click');
        });
    }
});
/*can@3.9.0-pre.0#view/stache/stache_test*/
define('can@3.9.0-pre.0#view/stache/stache_test', function (require, exports, module) {
    require('can-stache/test/stache-test');
    require('can-stache-bindings/test/bindings-test');
});
/*can-stache-converters@3.2.0#can-stache-converters*/
define('can-stache-converters@3.2.0#can-stache-converters', function (require, exports, module) {
    var stache = require('can-stache');
    var stringToAny = require('can-util/js/string-to-any/string-to-any');
    var makeArray = require('can-util/js/make-array/make-array');
    require('can-stache-bindings');
    stache.registerConverter('boolean-to-inList', {
        get: function (item, list) {
            if (!list) {
                return false;
            } else {
                return list.indexOf(item) !== -1;
            }
        },
        set: function (newVal, item, list) {
            if (!list) {
                return;
            }
            if (!newVal) {
                var idx = list.indexOf(item);
                if (idx !== -1) {
                    list.splice(idx, 1);
                }
            } else {
                list.push(item);
            }
        }
    });
    stache.registerConverter('string-to-any', {
        get: function (compute) {
            return '' + compute();
        },
        set: function (newVal, compute) {
            var converted = stringToAny(newVal);
            compute(converted);
        }
    });
    stache.registerConverter('not', {
        get: function (compute) {
            return !compute();
        },
        set: function (newVal, compute) {
            compute(!newVal);
        }
    });
    stache.registerConverter('index-to-selected', {
        get: function (item, list) {
            var val = item.isComputed ? item() : item;
            var idx = list.indexOf(val);
            return idx;
        },
        set: function (idx, item, list) {
            var newVal = list[idx];
            if (newVal !== -1 && item.isComputed) {
                item(newVal);
            }
        }
    });
    stache.registerConverter('either-or', {
        get: function (chosen, a, b) {
            return b !== chosen();
        },
        set: function (newVal, chosen, a, b) {
            chosen(newVal ? a : b);
        }
    });
    stache.registerConverter('equal', {
        get: function () {
            var args = makeArray(arguments);
            if (args.length > 1) {
                var comparer = args.pop();
                return args.every(function (compute) {
                    return (compute && compute.isComputed ? compute() : compute) === comparer;
                });
            }
        },
        set: function () {
            var args = makeArray(arguments);
            if (args.length > 2) {
                var b = args.shift();
                var comparer = args.pop();
                if (b) {
                    for (var i = 0; i < args.length; i++) {
                        args[i](comparer);
                    }
                }
            }
        }
    });
});
/*can-stache-converters@3.2.0#test/boolean-to-inList_test*/
define('can-stache-converters@3.2.0#test/boolean-to-inList_test', function (require, exports, module) {
    require('can-stache-converters');
    var canEvent = require('can-event');
    var DefineList = require('can-define/list/list');
    var DefineMap = require('can-define/map/map');
    var stache = require('can-stache');
    var each = require('can-util/js/each/each');
    var QUnit = require('steal-qunit');
    QUnit.module('boolean-to-inList', {
        setup: function () {
            this.fixture = document.getElementById('qunit-fixture');
        }
    });
    QUnit.test('Works with checkboxes', function () {
        var template = stache('<input type=\'checkbox\' {($checked)}=\'boolean-to-inList(item, list)\' />');
        var map = new DefineMap({
            item: 2,
            list: new DefineList([
                1,
                2,
                3
            ])
        });
        var frag = template(map);
        var input = frag.firstChild;
        QUnit.ok(input.checked, 'it is initially checked');
        QUnit.equal(map.list.indexOf(2), 1, 'two is in the list');
        input.checked = false;
        canEvent.trigger.call(input, 'change');
        QUnit.equal(map.list.indexOf(2), -1, 'No longer in the list');
        map.item = 3;
        QUnit.ok(input.checked, '3 is in the list');
        map.item = 5;
        QUnit.ok(!input.checked, '5 is not in the list');
        map.list.push(5);
        QUnit.ok(input.checked, 'Now 5 is in the list');
        map.item = 6;
        input.checked = true;
        canEvent.trigger.call(input, 'change');
        QUnit.equal(map.list.indexOf(6), 3, 'pushed into the list');
    });
    QUnit.test('If there is no list, treated as false', function () {
        var template = stache('<input type=\'checkbox\' {($checked)}=\'boolean-to-inList(item, list)\' />');
        var map = new DefineMap({
            item: 2,
            list: undefined
        });
        var frag = template(map);
        var input = frag.firstChild;
        QUnit.ok(!input.checked, 'not checked because there is no list');
        input.checked = true;
        canEvent.trigger.call(input, 'change');
        QUnit.ok(true, 'no errors thrown');
    });
    QUnit.test('works with radio buttons', function () {
        var template = stache('<form><input type=\'radio\' name=\'name\' value=\'Matthew\' {($checked)}=\'boolean-to-inList("Matthew", names)\' /><input type=\'radio\' name=\'name\' value=\'Wilbur\' {($checked)}=\'boolean-to-inList("Wilbur", names)\' /></form>');
        var map = new DefineMap({ names: ['Wilbur'] });
        var frag = template(map);
        var radioOne = frag.firstChild.firstChild;
        var radioTwo = radioOne.nextSibling;
        this.fixture.appendChild(frag);
        QUnit.equal(radioOne.checked, false, 'Matthew not checked');
        QUnit.equal(radioTwo.checked, true, 'Wilbur is checked');
        radioOne.checked = true;
        canEvent.trigger.call(radioOne, 'change');
        QUnit.equal(radioOne.checked, true, 'Matthew is checked');
        QUnit.equal(radioTwo.checked, false, 'Wilbur is not checked');
    });
});
/*can-stache-converters@3.2.0#test/index-to-selected_test*/
define('can-stache-converters@3.2.0#test/index-to-selected_test', function (require, exports, module) {
    require('can-stache-converters');
    var canEvent = require('can-event');
    var DefineList = require('can-define/list/list');
    var DefineMap = require('can-define/map/map');
    var stache = require('can-stache');
    var each = require('can-util/js/each/each');
    var QUnit = require('steal-qunit');
    QUnit.module('index-to-selected');
    QUnit.test('chooses select option by the index from a list', function () {
        var template = stache('<select {($value)}="index-to-selected(~person, people)"><option value="none"></option>{{#each people}}<option value="{{%index}}">{{name}}</option>{{/each}}</select>');
        var map = new DefineMap({
            person: 'Anne',
            people: [
                'Matthew',
                'Anne',
                'Wilbur'
            ]
        });
        var select = template(map).firstChild;
        QUnit.equal(select.value, 1, 'initially set to the first value');
        select.value = 2;
        canEvent.trigger.call(select, 'change');
        QUnit.equal(map.person, 'Wilbur', 'now it is me');
        map.person = map.people.item(0);
        QUnit.equal(select.value, 0, 'set back');
        select.value = 'none';
        canEvent.trigger.call(select, 'change');
        QUnit.equal(map.person, undefined, 'now undefined because not in the list');
    });
});
/*can-stache-converters@3.2.0#test/string-to-any_test*/
define('can-stache-converters@3.2.0#test/string-to-any_test', function (require, exports, module) {
    require('can-stache-converters');
    var canEvent = require('can-event');
    var DefineList = require('can-define/list/list');
    var DefineMap = require('can-define/map/map');
    var stache = require('can-stache');
    var each = require('can-util/js/each/each');
    var QUnit = require('steal-qunit');
    QUnit.module('string-to-any');
    QUnit.test('Works on all the types', function () {
        var types = {
            '22.3': 22.3,
            'foo': 'foo',
            'true': true,
            'false': false,
            'undefined': undefined,
            'null': null,
            'Infinity': Infinity,
            'NaN': {
                expected: NaN,
                equalityTest: function (a) {
                    return isNaN(a);
                }
            }
        };
        var defaultEquality = function (a, b) {
            return a === b;
        };
        each(types, function (expected, type) {
            var template = stache('<select {($value)}="string-to-any(~val)"><option value="test">test</option><option value="' + type + '">' + type + '</option></select>');
            var map = new DefineMap({ val: 'test' });
            var frag = template(map);
            var select = frag.firstChild;
            var option = select.firstChild.nextSibling;
            var equality = defaultEquality;
            if (expected != null && expected.equalityTest) {
                equality = expected.equalityTest;
                expected = expected.expected;
            }
            select.value = type;
            canEvent.trigger.call(select, 'change');
            QUnit.ok(equality(map.val, expected), 'map\'s value updated to: ' + type);
            map.val = 'test';
            map.val = expected;
            QUnit.equal(select.value, type, 'select\'s value updated to: ' + type);
        });
    });
});
/*can-stache-converters@3.2.0#test/not_test*/
define('can-stache-converters@3.2.0#test/not_test', function (require, exports, module) {
    require('can-stache-converters');
    var canEvent = require('can-event');
    var DefineList = require('can-define/list/list');
    var DefineMap = require('can-define/map/map');
    var stache = require('can-stache');
    var each = require('can-util/js/each/each');
    var QUnit = require('steal-qunit');
    QUnit.module('not');
    QUnit.test('saves the inverse of the selected value', function () {
        var template = stache('<input type="checkbox" {($checked)}="not(~val)" />');
        var map = new DefineMap({ val: true });
        var input = template(map).firstChild;
        QUnit.equal(input.checked, false, 'initially false');
        map.val = false;
        QUnit.equal(input.checked, true, 'true because map val is false');
        input.checked = false;
        canEvent.trigger.call(input, 'change');
        QUnit.equal(map.val, true, 'map is now true because checkbox is false');
    });
    QUnit.test('works with boolean-to-inList', function () {
        var template = stache('<input type=\'checkbox\' {($checked)}=\'not(~boolean-to-inList(item, list))\' />');
        var map = new DefineMap({
            item: 2,
            list: new DefineList([
                1,
                2,
                3
            ])
        });
        var input = template(map).firstChild;
        QUnit.equal(input.checked, false, 'not checked because it is in the list');
        map.item = 4;
        QUnit.equal(input.checked, true, 'checked because not in the list');
        input.checked = false;
        canEvent.trigger.call(input, 'change');
        QUnit.equal(map.list.indexOf(4), 3, 'it was pushed into the list');
        map.list.splice(3, 1);
        QUnit.equal(input.checked, true, 'now it\'s checked because not in the list');
    });
});
/*can-stache-converters@3.2.0#test/either-or_test*/
define('can-stache-converters@3.2.0#test/either-or_test', function (require, exports, module) {
    require('can-stache-converters');
    var canEvent = require('can-event');
    var DefineMap = require('can-define/map/map');
    var stache = require('can-stache');
    var QUnit = require('steal-qunit');
    QUnit.module('either-or');
    QUnit.test('can bind to a checkbox', function () {
        var template = stache('<input type=\'checkbox\' {($checked)}=\'either-or(~pref, "Star Trek", "Star Wars")\' />');
        var map = new DefineMap({ pref: 'Star Trek' });
        var input = template(map).firstChild;
        QUnit.equal(input.checked, true, 'initial value is right');
        input.checked = false;
        canEvent.trigger.call(input, 'change');
        QUnit.equal(map.pref, 'Star Wars', 'changed because input changed');
        map.pref = 'Star Trek';
        QUnit.equal(input.checked, true, 'changed because map changed');
    });
});
/*can-stache-converters@3.2.0#test/equal_test*/
define('can-stache-converters@3.2.0#test/equal_test', function (require, exports, module) {
    require('can-stache-converters');
    var canEvent = require('can-event');
    var compute = require('can-compute');
    var DefineList = require('can-define/list/list');
    var DefineMap = require('can-define/map/map');
    var stache = require('can-stache');
    var each = require('can-util/js/each/each');
    var QUnit = require('steal-qunit');
    QUnit.module('equal');
    QUnit.test('Basics works', function () {
        var template = stache('<input type="radio" {($checked)}="equal(~attending, \'yes\'" /><input type="radio" {($checked)}="equal(~attending, \'no\'" />');
        var attending = compute('yes');
        var yes = template({ attending: attending }).firstChild, no = yes.nextSibling;
        QUnit.equal(yes.checked, true, 'initially a yes');
        QUnit.equal(no.checked, false, 'initially unchecked');
        attending('no');
        QUnit.equal(yes.checked, false, 'now not checked');
        QUnit.equal(no.checked, true, 'now checked');
        yes.checked = true;
        canEvent.trigger.call(yes, 'change');
        QUnit.equal(attending(), 'yes', 'now it is yes');
        QUnit.equal(yes.checked, true, 'yes is checked');
        QUnit.equal(no.checked, false, 'no is unchecked');
    });
    QUnit.test('Allows one-way binding when passed a non-compute as the first argument', function () {
        var template = stache('<input type="radio" {($checked)}="equal(attending, true)" />');
        var attending = compute(false);
        var input = template({ attending: attending }).firstChild;
        QUnit.equal(input.checked, false, 'initially false');
        attending(true);
        QUnit.equal(input.checked, true, 'can be changed to true');
        input.checked = false;
        QUnit.equal(attending(), true, 'does not change compute');
    });
    QUnit.test('Allow multiple expressions to be passed in', function () {
        var template = stache('<input type="radio" {($checked)}="equal(~foo, ~bar, true)" />');
        var foo = compute(true);
        var bar = compute(false);
        var input = template({
            foo: foo,
            bar: bar
        }).firstChild;
        QUnit.equal(input.checked, false, 'initially unchecked');
        bar(true);
        QUnit.equal(input.checked, true, 'now checked');
        foo(false);
        bar(false);
        QUnit.equal(input.checked, false, 'now unchecked');
        input.checked = true;
        canEvent.trigger.call(input, 'change');
        QUnit.equal(foo(), true, 'computed foo value is true');
        QUnit.equal(bar(), true, 'computed bar value is true');
    });
});
/*can-stache-converters@3.2.0#test/test*/
define('can-stache-converters@3.2.0#test/test', function (require, exports, module) {
    require('./boolean-to-inList_test');
    require('./index-to-selected_test');
    require('./string-to-any_test');
    require('./not_test');
    require('./either-or_test');
    require('./equal_test');
});
/*can-deparam@1.0.1#can-deparam-test*/
define('can-deparam@1.0.1#can-deparam-test', function (require, exports, module) {
    var deparam = require('./can-deparam');
    var QUnit = require('steal-qunit');
    QUnit.module('can/util/string/deparam');
    test('Nested deparam', function () {
        var data = deparam('a[b]=1&a[c]=2');
        equal(data.a.b, 1);
        equal(data.a.c, 2);
        data = deparam('a[]=1&a[]=2');
        equal(data.a[0], 1);
        equal(data.a[1], 2);
        data = deparam('a[b][]=1&a[b][]=2');
        equal(data.a.b[0], 1);
        equal(data.a.b[1], 2);
        data = deparam('a[0]=1&a[1]=2');
        equal(data.a[0], 1);
        equal(data.a[1], 2);
    });
    test('Remaining ampersand', function () {
        var data = deparam('a[b]=1&a[c]=2&');
        deepEqual(data, {
            a: {
                b: '1',
                c: '2'
            }
        });
    });
    test('Invalid encoding', function () {
        var data = deparam('foo=%0g');
        deepEqual(data, { foo: '%0g' });
    });
});
/*can-param@1.0.1#can-param-test*/
define('can-param@1.0.1#can-param-test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var param = require('./can-param');
    QUnit.module('can-param');
    QUnit.test('can-param', function () {
        QUnit.deepEqual(param({
            foo: 'bar',
            baz: 'zed'
        }), 'foo=bar&baz=zed', 'Regular object');
        QUnit.deepEqual(param({ foo: { bar: 'baz' } }), encodeURI('foo[bar]=baz'), 'Nested object');
        QUnit.deepEqual(param({
            foo: [
                'bar',
                'baz'
            ]
        }), encodeURI('foo[]=bar&foo[]=baz'), 'Nested array');
        QUnit.deepEqual(param({ foo: 'bar & baz' }), 'foo=bar+%26+baz', 'Spec chars values');
    });
});
/*can-event@3.5.0#batch/batch-test*/
define('can-event@3.5.0#batch/batch-test', function (require, exports, module) {
    var canEvent = require('can-event');
    var QUnit = require('steal-qunit');
    var assign = require('can-util/js/assign/assign');
    var canBatch = require('can-event/batch/batch');
    var eventAsync = require('can-event/async/async');
    require('can-util/dom/events/delegate/delegate');
    QUnit.module('can-event/batch', {
        setup: function () {
            eventAsync.sync();
        },
        teardown: function () {
            eventAsync.async();
        }
    });
    QUnit.test('basics', function () {
        var collecting;
        var secondFired = false;
        var obj = assign({}, canEvent);
        obj.on('first', function (ev, arg1, arg2) {
            QUnit.equal(collecting.number, ev.batchNum, 'same batch num');
            QUnit.equal(canBatch.dispatching(), collecting, 'dispatching old collecting');
            QUnit.equal(arg1, 1, 'first arg');
            QUnit.equal(arg2, 2, 'second arg');
            collecting = canBatch.collecting();
            QUnit.ok(!collecting, 'not collecting b/c we\'re not in a batch yet');
            obj.dispatch('second');
            collecting = canBatch.collecting();
            QUnit.ok(collecting, 'forced a batch');
            QUnit.equal(secondFired, false, 'don\'t fire yet, put in next batch');
        });
        obj.on('second', function (ev) {
            secondFired = true;
            QUnit.equal(collecting.number, ev.batchNum, 'same batch num on second');
            QUnit.equal(canBatch.dispatching(), collecting, 'dispatching second collecting');
        });
        canBatch.start();
        collecting = canBatch.collecting();
        QUnit.ok(canBatch.collecting(), 'is collecting');
        obj.dispatch('first', [
            1,
            2
        ]);
        canBatch.stop();
    });
    QUnit.test('events are queued and dispatched without .stop being called (#14)', function () {
        var obj = assign({}, canEvent);
        obj.on('first', function (ev) {
            obj.dispatch('second');
            QUnit.ok(canBatch.collecting() !== canBatch.dispatching(), 'dispatching is not collecting');
        });
        obj.on('second', function () {
            QUnit.ok(canBatch.collecting() !== canBatch.dispatching(), 'dispatching is not collecting');
            QUnit.ok(true, 'called');
        });
        canBatch.start();
        obj.dispatch('first');
        canBatch.stop();
    });
    test('Everything is part of a batch', function () {
        var obj = {};
        assign(obj, canEvent);
        obj.on('foo', function (ev) {
            ok(ev.batchNum);
        });
        obj.dispatch('foo');
    });
    test('batch.queue callback called after events fired in the same fn', function () {
        var obj = assign({}, canEvent);
        var thirdCalled = false, firstBatch;
        obj.on('third', function (ev) {
            QUnit.equal(firstBatch, ev.batchNum, 'third is right');
            thirdCalled = true;
        });
        obj.on('first', function (ev) {
            equal(typeof ev.batchNum, 'number', 'got a batch number');
            firstBatch = ev.batchNum;
            canBatch.queue([
                function () {
                    equal(thirdCalled, true, 'third called before this');
                },
                null,
                []
            ]);
            obj.dispatch({
                type: 'third',
                batchNum: ev.batchNum
            });
        });
        obj.dispatch('first');
    });
    QUnit.test('afterPreviousEvents doesn\'t run after all collecting previous events (#17)', function () {
        var obj = assign({}, canEvent);
        var afterPreviousEventsFired = false;
        obj.on('first', function () {
            QUnit.ok(!afterPreviousEventsFired, 'after previous should fire after');
        });
        canBatch.start();
        obj.dispatch('first');
        canBatch.afterPreviousEvents(function () {
            afterPreviousEventsFired = true;
        });
        canBatch.stop();
    });
    QUnit.test('flushing works (#18)', function () {
        var firstFired, secondFired, thirdFired;
        var obj = assign({}, canEvent);
        obj.on('first', function () {
            canBatch.flush();
            QUnit.ok(firstFired, 'first fired');
            QUnit.ok(secondFired, 'second fired');
            QUnit.ok(thirdFired, 'third fired');
        });
        obj.on('first', function () {
            firstFired = true;
        });
        obj.on('second', function () {
            secondFired = true;
        });
        obj.on('third', function () {
            thirdFired = true;
        });
        canBatch.start();
        obj.dispatch('first');
        obj.dispatch('second');
        obj.dispatch('third');
        canBatch.stop();
    });
    QUnit.test('flush is non enumerable (#18)', 1, function () {
        QUnit.equal(canEvent.flush, canBatch.flush);
        for (var prop in canEvent) {
            if (prop === 'flush') {
                ok(false, 'flush is enumerable');
            }
        }
    });
    QUnit.test('flushing a future batch (#18)', function () {
        var firstFired, secondFired, thirdFired;
        var obj = assign({}, canEvent);
        obj.on('first', function () {
            canBatch.start();
            obj.dispatch('second');
            obj.dispatch('third');
            canBatch.stop();
            canBatch.flush();
            QUnit.ok(firstFired, 'first fired');
            QUnit.ok(secondFired, 'second fired');
            QUnit.ok(thirdFired, 'third fired');
        });
        obj.on('first', function () {
            firstFired = true;
        });
        obj.on('second', function () {
            secondFired = true;
        });
        obj.on('third', function () {
            thirdFired = true;
        });
        canBatch.start();
        obj.dispatch('first');
        canBatch.stop();
    });
    QUnit.test('batchNumber is set by .dispatch that has a batchNum', function () {
        var obj = assign({}, canEvent);
        var firstBN;
        obj.on('first', function (ev) {
            firstBN = ev.batchNum;
            canEvent.flush();
            obj.dispatch({
                type: 'second',
                batchNum: ev.batchNum
            });
        });
        obj.on('second', function (ev) {
            QUnit.equal(firstBN, ev.batchNum, 'batch num set');
            QUnit.equal(canBatch.batchNum, ev.batchNum, 'batch num set');
        });
        canBatch.start();
        obj.dispatch('first');
        canBatch.stop();
    });
});
/*can-event@3.5.0#async/async-test*/
define('can-event@3.5.0#async/async-test', function (require, exports, module) {
    var canEvent = require('can-event');
    var QUnit = require('steal-qunit');
    var assign = require('can-util/js/assign/assign');
    var eventAsync = require('can-event/async/async');
    require('can-util/dom/events/delegate/delegate');
    QUnit.module('can-event/async', {
        setup: function () {
            eventAsync.async();
        },
        teardown: function () {
            eventAsync.sync();
        }
    });
    QUnit.asyncTest('removing an event handler, nothing called', 5, function () {
        var obj = {};
        assign(obj, canEvent);
        var handler = function (ev, arg1, arg2) {
            ok(true, 'foo called');
            equal(ev.type, 'foo');
            equal(arg1, 1, 'one');
            equal(arg2, 2, 'two');
        };
        obj.addEventListener('foo', handler);
        obj.dispatch({ type: 'foo' }, [
            1,
            2
        ]);
        obj.removeEventListener('foo', handler);
        obj.addEventListener('foo', function () {
            QUnit.ok(true, 'this handler called');
            QUnit.start();
        });
        obj.dispatch({
            type: 'foo',
            data: [
                1,
                2
            ]
        });
    });
    QUnit.asyncTest('removing an event handler, nothing called with on', 6, function () {
        var obj = {};
        assign(obj, canEvent);
        var dispatched = false;
        var handler = function (ev, arg1, arg2) {
            ok(dispatched, 'dispatched should be async');
            ok(true, 'foo called');
            equal(ev.type, 'foo');
            equal(arg1, 1, 'one');
            equal(arg2, 2, 'two');
        };
        obj.on('foo', handler);
        obj.dispatch({ type: 'foo' }, [
            1,
            2
        ]);
        dispatched = true;
        obj.off('foo', handler);
        obj.on('foo', function () {
            QUnit.ok(true, 'this handler called');
            QUnit.start();
        });
        obj.dispatch({
            type: 'foo',
            data: [
                1,
                2
            ]
        });
    });
    QUnit.asyncTest('async with same batch number is fired right away', function () {
        var obj = assign({}, canEvent);
        var secondDispatched = false;
        var secondBatchNum;
        obj.on('first', function (ev) {
            obj.dispatch({
                batchNum: ev.batchNum,
                type: 'second'
            });
            equal(secondBatchNum, ev.batchNum, 'batch nums the same');
            ok(secondDispatched, 'dispatched event immediately');
            QUnit.start();
        });
        obj.on('second', function (ev) {
            secondDispatched = true;
            secondBatchNum = ev.batchNum;
        });
        obj.dispatch('first');
    });
});
/*can-event@3.5.0#lifecycle/lifecycle-test*/
define('can-event@3.5.0#lifecycle/lifecycle-test', function (require, exports, module) {
    var canEvent = require('can-event');
    var lifecycle = require('can-event/lifecycle/lifecycle');
    var QUnit = require('steal-qunit');
    QUnit.module('can-event/lifecycle');
    QUnit.test('Mixins your addEventListener', function () {
        var proto = {
            addEventListener: function () {
                QUnit.ok(true, 'this was called');
            },
            removeEventListener: function () {
            }
        };
        var obj = lifecycle(proto);
        obj.addEventListener('Hello world!');
    });
    QUnit.test('Mixins your removeEventListener', function () {
        var proto = {
            removeEventListener: function () {
                QUnit.ok(true, 'this was called');
            },
            addEventListener: canEvent.addEventListener
        };
        var obj = lifecycle(proto);
        obj.addEventListener('some-event');
        obj.removeEventListener('some-event');
    });
    QUnit.test('Calls _eventSetup on the first addEventListener', function () {
        var proto = {
            _eventSetup: function () {
                QUnit.ok(true, 'eventSetup was called');
            },
            addEventListener: function () {
            },
            removeEventListener: function () {
            }
        };
        var obj = lifecycle(proto);
        obj.addEventListener('Something');
    });
    QUnit.test('Calls _eventTeardown on the last removeEventListener', function () {
        var proto = {
            _eventTeardown: function () {
                QUnit.ok(true, 'eventTeardown was called');
            },
            addEventListener: canEvent.addEventListener,
            removeEventListener: canEvent.removeEventListener
        };
        var obj = lifecycle(proto);
        var handler = function () {
        };
        obj.addEventListener('Something', handler);
        obj.removeEventListener('Something', handler);
    });
});
/*can-event@3.5.0#can-event_test*/
define('can-event@3.5.0#can-event_test', function (require, exports, module) {
    var canEvent = require('can-event');
    var QUnit = require('steal-qunit');
    var assign = require('can-util/js/assign/');
    var canDev = require('can-util/js/dev/dev');
    require('can-util/dom/events/delegate/');
    require('can-event/batch/batch-test');
    require('can-event/async/async-test');
    require('can-event/lifecycle/lifecycle-test');
    QUnit.module('can-event');
    test('basics', 4, function () {
        var obj = {
            addEvent: canEvent.addEvent,
            removeEvent: canEvent.removeEvent,
            dispatch: canEvent.dispatch
        };
        var handler = function (ev, arg1, arg2) {
            ok(true, 'foo called');
            equal(ev.type, 'foo');
            equal(arg1, 1, 'one');
            equal(arg2, 2, 'two');
        };
        obj.addEvent('foo', handler);
        obj.dispatch({ type: 'foo' }, [
            1,
            2
        ]);
        obj.removeEvent('foo', handler);
        obj.dispatch({
            type: 'foo',
            data: [
                1,
                2
            ]
        });
    });
    test('listenTo and stopListening', 9, function () {
        var parent = {
            bind: canEvent.bind,
            unbind: canEvent.unbind,
            listenTo: canEvent.listenTo,
            stopListening: canEvent.stopListening
        };
        var child1 = {
            bind: canEvent.bind,
            unbind: canEvent.unbind
        };
        var child2 = {
            bind: canEvent.bind,
            unbind: canEvent.unbind
        };
        var change1WithId = 0;
        parent.listenTo(child1, 'change', function () {
            change1WithId++;
            if (change1WithId === 1) {
                ok(true, 'child 1 handler with id called');
            } else {
                ok(false, 'child 1 handler with id should only be called once');
            }
        });
        child1.bind('change', function () {
            ok(true, 'child 1 handler without id called');
        });
        var foo1WidthId = 0;
        parent.listenTo(child1, 'foo', function () {
            foo1WidthId++;
            if (foo1WidthId === 1) {
                ok(true, 'child 1 foo handler with id called');
            } else {
                ok(false, 'child 1 foo handler should not be called twice');
            }
        });
        (function () {
            var okToCall = true;
            parent.listenTo(child2, 'change', function () {
                ok(okToCall, 'child 2 handler with id called');
                okToCall = false;
            });
        }());
        child2.bind('change', function () {
            ok(true, 'child 2 handler without id called');
        });
        parent.listenTo(child2, 'foo', function () {
            ok(true, 'child 2 foo handler with id called');
        });
        canEvent.trigger.call(child1, 'change');
        canEvent.trigger.call(child1, 'foo');
        canEvent.trigger.call(child2, 'change');
        canEvent.trigger.call(child2, 'foo');
        parent.stopListening(child1);
        parent.stopListening(child2, 'change');
        canEvent.trigger.call(child1, 'change');
        canEvent.trigger.call(child1, 'foo');
        canEvent.trigger.call(child2, 'change');
        canEvent.trigger.call(child2, 'foo');
    });
    test('stopListening on something you\'ve never listened to ', function () {
        var parent = {
            bind: canEvent.bind,
            unbind: canEvent.unbind,
            listenTo: canEvent.listenTo,
            stopListening: canEvent.stopListening
        };
        var child = {
            bind: canEvent.bind,
            unbind: canEvent.unbind
        };
        parent.listenTo({}, 'foo');
        parent.stopListening(child, 'change');
        ok(true, 'did not error');
    });
    test('bind on document', function () {
        var called = false, handler = function () {
                called = true;
            };
        canEvent.on.call(document, 'click', handler);
        canEvent.trigger.call(document, 'click');
        ok(called, 'got click event');
        ok(true, 'did not error');
        canEvent.off.call(document, 'click', handler);
    });
    test('delegate on document', function () {
        var called = false, handler = function () {
                called = true;
            };
        canEvent.delegate.call(document, 'click', 'body', handler);
        canEvent.trigger.call(document.body, 'click');
        ok(called, 'got click event');
        ok(true, 'did not error');
        canEvent.undelegate.call(document, 'body', 'click', handler);
    });
    test('One will listen to an event once, then unbind', function () {
        var obj = {}, count = 0, mixin = 0;
        canEvent.one.call(obj, 'action', function () {
            count++;
        });
        canEvent.dispatch.call(obj, 'action');
        canEvent.dispatch.call(obj, 'action');
        canEvent.dispatch.call(obj, 'action');
        equal(count, 1, 'one should only fire a handler once (direct)');
        assign(obj, canEvent);
        obj.one('mixin', function () {
            mixin++;
        });
        obj.dispatch('mixin');
        obj.dispatch('mixin');
        obj.dispatch('mixin');
        equal(mixin, 1, 'one should only fire a handler once (mixin)');
    });
    test('Test events using mixin', function () {
        var obj = {}, fn;
        assign(obj, canEvent);
        var bindCount = 0;
        obj.bind('action', fn = function () {
            ++bindCount;
        });
        obj.dispatch('action');
        obj.dispatch('action');
        obj.unbind('action', fn);
        obj.dispatch('action');
        equal(bindCount, 2, 'action triggered twice');
        bindCount = 0;
        obj.one('action', fn = function () {
            ++bindCount;
        });
        obj.dispatch('action');
        obj.dispatch('action');
        equal(bindCount, 1, 'action triggered only once, then unbound');
        var other = {};
        bindCount = 0;
        assign(other, canEvent);
        obj.listenTo(other, 'action', fn = function () {
            ++bindCount;
        });
        other.dispatch('action');
        other.dispatch('action');
        obj.stopListening(other, 'action', fn);
        other.dispatch('action');
        equal(bindCount, 2, 'action triggered twice');
    });
    QUnit.test('makeHandlerArgs and handlers are non enumerable', 0, function () {
        for (var prop in canEvent) {
            if (prop === 'makeHandlerArgs' || prop === 'handlers') {
                ok(false, prop + ' is enumerable');
            }
        }
    });
});
/*can@3.9.0-pre.0#event/event_test*/
define('can@3.9.0-pre.0#event/event_test', function (require, exports, module) {
    require('can-event/can-event_test');
});
/*can-util@3.9.6#test/qunit*/
define('can-util@3.9.6#test/qunit', function (require, exports, module) {
    (function (global) {
        if (typeof QUnit === 'undefined') {
            module.exports = require('steal-qunit');
        } else {
            QUnit.test = test;
            module.exports = QUnit;
        }
    }(function () {
        return this;
    }()));
});
/*can-util@3.9.6#js/assign/assign-test*/
define('can-util@3.9.6#js/assign/assign-test', function (require, exports, module) {
    'use strict';
    var assign = require('./assign');
    var QUnit = require('../../test/qunit');
    QUnit.module('can-util/js/assign');
    QUnit.test('Assign all properties to an object', function () {
        var a = {
            a: 1,
            b: 2,
            d: 3
        };
        var b = {
            a: 1,
            b: 3,
            c: 2
        };
        var expected = {
            a: 1,
            b: 3,
            c: 2,
            d: 3
        };
        var actual = assign(a, b);
        for (var prop in actual) {
            equal(expected[prop], actual[prop]);
        }
    });
});
/*can-util@3.9.6#js/set-not-enumerable/set-not-enumerable*/
define('can-util@3.9.6#js/set-not-enumerable/set-not-enumerable', function (require, exports, module) {
    'use strict';
    module.exports = function (obj, prop, value) {
        Object.defineProperty(obj, prop, {
            configurable: true,
            enumerable: false,
            writable: true,
            value: value
        });
    };
});
/*can-util@3.9.6#js/assign-non-enumerable/assign-non-enumerable*/
define('can-util@3.9.6#js/assign-non-enumerable/assign-non-enumerable', function (require, exports, module) {
    var setNotEnumerable = require('../set-not-enumerable/set-not-enumerable');
    module.exports = function (d, s) {
        for (var prop in s) {
            setNotEnumerable(d, prop, s[prop]);
        }
        return d;
    };
});
/*can-util@3.9.6#js/assign-non-enumerable/assign-non-enumerable-test*/
define('can-util@3.9.6#js/assign-non-enumerable/assign-non-enumerable-test', function (require, exports, module) {
    var assignNonEnumerable = require('./assign-non-enumerable');
    var QUnit = require('../../test/qunit');
    QUnit.module('can-util/js/assign-non-enumerable');
    QUnit.test('Assign all properties to an object', function () {
        var a = { a: 1 };
        var b = {
            b: 3,
            c: 2
        };
        var actual = assignNonEnumerable(a, b);
        QUnit.equal(a, actual);
        for (var prop in a) {
            if (prop !== 'a') {
                QUnit.ok(false, 'we got a prop of ' + prop);
            }
        }
        QUnit.equal(actual.b, 3);
        QUnit.equal(actual.c, 2);
        actual.b = 'B';
        QUnit.equal(actual.b, 'B');
    });
});
/*can-util@3.9.6#js/base-url/base-url-test*/
define('can-util@3.9.6#js/base-url/base-url-test', function (require, exports, module) {
    (function (global) {
        'use strict';
        var QUnit = require('../../test/qunit');
        var getBaseUrl = require('./base-url');
        var getGlobal = require('../global/global');
        var getDomDocument = require('../../dom/document/document');
        QUnit.module('can-util/js/base-url');
        test('basics', function () {
            var global = getGlobal(), domDocument = getDomDocument();
            if (domDocument && 'baseURI' in domDocument) {
                ok(getBaseUrl() === global.document.baseURI, getBaseUrl());
            } else if (global.location) {
                ok(getBaseUrl() === global.location.href.substr(0, global.location.href.lastIndexOf('/')), getBaseUrl());
            } else if (typeof process !== 'undefined') {
                ok(getBaseUrl() === process.cwd(), getBaseUrl());
            }
        });
    }(function () {
        return this;
    }()));
});
/*can-util@3.9.6#js/cid-map/cid-map-test*/
define('can-util@3.9.6#js/cid-map/cid-map-test', function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var CIDMap = require('./cid-map');
    QUnit.module('can-util/js/cid-map');
    QUnit.test('basics', function () {
        var o1 = {}, o2 = {}, o3 = {};
        var map = new CIDMap();
        map.set(o1, 'o1');
        map.set(o2, 'o2');
        QUnit.equal(map.get(o1), 'o1');
        QUnit.equal(map.get(o2), 'o2');
        QUnit.equal(map.get(o3), undefined);
        QUnit.equal(map.size, 2);
        map.clear();
        QUnit.equal(map.size, 0);
    });
    QUnit.test('forEach', function () {
        var o1 = {}, o2 = {};
        var map = new CIDMap();
        map.set(o1, 'o1');
        map.set(o2, 'o2');
        map.forEach(function (value, key) {
            if (value === 'o1') {
                QUnit.equal(key, o1);
            } else if (value === 'o2') {
                QUnit.equal(key, o2);
            } else {
                QUnit.ok(false, 'key shouldn\'t be ' + value);
            }
        });
    });
});
/*can-util@3.9.6#js/cid-set/cid-set-test*/
define('can-util@3.9.6#js/cid-set/cid-set-test', function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var CIDSet = require('./cid-set');
    QUnit.module('can-util/js/cid-set');
    QUnit.test('basics', function () {
        var o1 = {}, o2 = {};
        var set = new CIDSet();
        set.add(o1);
        set.add(o2);
        QUnit.ok(set.has(o1));
        QUnit.ok(set.has(o2));
        QUnit.equal(set.size, 2);
        set.clear();
        QUnit.equal(set.size, 0);
    });
    QUnit.test('primitives', function () {
        var set = new CIDSet();
        set.add(0);
        set.add(1);
        set.add(1);
        set.add('1');
        QUnit.equal(set.size, 3);
        QUnit.ok(set.has(0), 'has 0');
        QUnit.ok(!set.has('0'));
        QUnit.ok(set.has(1));
        QUnit.ok(set.has('1'));
        set.clear();
        QUnit.equal(set.size, 0);
    });
});
/*can-util@3.9.6#js/deep-assign/deep-assign-test*/
define('can-util@3.9.6#js/deep-assign/deep-assign-test', function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var deepAssign = require('./deep-assign');
    QUnit.module('can-util/js/deep-assign');
    QUnit.test('basics', function () {
        var original = { nested: { foo: 'bar' } };
        var res = deepAssign(true, {}, original);
        deepEqual(res, { nested: { foo: 'bar' } }, 'they look the same');
        ok(res.nested !== original.nested, 'different objects');
    });
});
/*can-util@3.9.6#js/defaults/defaults-test*/
define('can-util@3.9.6#js/defaults/defaults-test', function (require, exports, module) {
    'use strict';
    var defaults = require('./defaults');
    var QUnit = require('../../test/qunit');
    QUnit.module('can-util/js/defaults');
    QUnit.test('Assigns props from sources to object if they are undefined in object', function () {
        var a = {
            a: 1,
            b: 2,
            c: 3
        };
        var b = {
            a: 2,
            b: 3,
            d: 4
        };
        var c = {
            d: 5,
            e: 5
        };
        var expected = {
            a: 1,
            b: 2,
            c: 3,
            d: 4,
            e: 5
        };
        var actual = defaults(a, b, c);
        for (var prop in actual) {
            equal(expected[prop], actual[prop]);
        }
    });
});
/*can-util@3.9.6#js/dev/dev-test*/
define('can-util@3.9.6#js/dev/dev-test', function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var dev = require('./dev');
    QUnit.module('can-util/js/dev');
    QUnit.test('stringify', function () {
        strictEqual(dev.stringify(undefined), 'undefined');
        ok(/\"foo\": undefined/.test(dev.stringify({ foo: undefined })));
        ok(/\"bar\": undefined/.test(dev.stringify({
            foo: undefined,
            bar: undefined
        })));
        ok(/\"7\": undefined/.test(dev.stringify({
            foo: undefined,
            7: undefined,
            bar: undefined
        })));
    });
});
/*can-util@3.9.6#js/log/log-test*/
define('can-util@3.9.6#js/log/log-test', function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var canLog = require('./log');
    if (typeof console !== 'undefined') {
        QUnit.module('can-util/js/log');
        QUnit.test('log.log works', function () {
            QUnit.expect(2);
            var log = console.log;
            console.log = function (type, msg) {
                QUnit.equal(type, 'INFO:');
                QUnit.equal(msg, 'it worked');
                console.log = log;
            };
            canLog.log('it worked');
        });
        QUnit.test('log.warn works', function () {
            QUnit.expect(2);
            var warn = console.warn;
            console.warn = function (type, msg) {
                QUnit.equal(type, 'WARN:');
                QUnit.equal(msg, 'it worked');
                console.warn = warn;
            };
            canLog.warn('it worked');
        });
        QUnit.test('log.error works', function () {
            QUnit.expect(2);
            var error = console.error;
            console.error = function (type, msg) {
                QUnit.equal(type, 'ERROR:');
                QUnit.equal(msg, 'an error');
                console.error = error;
            };
            canLog.error('an error');
        });
    }
});
/*can-util@3.9.6#js/diff/diff-test*/
define('can-util@3.9.6#js/diff/diff-test', function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var diff = require('./diff');
    QUnit.module('can-util/js/diff');
    QUnit.test('basics', function () {
        var patches = diff([], [
            1,
            2,
            3
        ]);
        deepEqual(patches, [{
                index: 0,
                deleteCount: 0,
                insert: [
                    1,
                    2,
                    3
                ]
            }], 'insert many at end');
        patches = diff([
            1,
            2,
            3
        ], [
            1,
            2,
            3
        ]);
        deepEqual(patches, [], 'no changes');
        patches = diff([
            1,
            2,
            3
        ], [
            1,
            2,
            3,
            4
        ]);
        deepEqual(patches, [{
                index: 3,
                deleteCount: 0,
                insert: [4]
            }], 'add one at the end');
        patches = diff([
            1,
            2,
            3,
            4
        ], [
            1,
            2,
            4
        ]);
        deepEqual(patches, [{
                index: 2,
                deleteCount: 1,
                insert: []
            }], 'remove one in the middle');
        patches = diff([
            'a',
            'b',
            'z',
            'f',
            'x'
        ], [
            'a',
            'b',
            'f',
            'w',
            'z'
        ]);
        deepEqual(patches, [
            {
                index: 2,
                insert: [],
                deleteCount: 1
            },
            {
                index: 3,
                deleteCount: 1,
                insert: [
                    'w',
                    'z'
                ]
            }
        ]);
        patches = diff([
            'a',
            'b',
            'b'
        ], [
            'c',
            'a',
            'b'
        ]);
        deepEqual(patches, [
            {
                index: 0,
                insert: ['c'],
                deleteCount: 0
            },
            {
                index: 3,
                deleteCount: 1,
                insert: []
            }
        ]);
        patches = diff([
            'a',
            'b',
            'c',
            'd',
            'e',
            'f',
            'g'
        ], [
            'a',
            'c',
            'e',
            'g'
        ]);
        deepEqual(patches, [
            {
                index: 1,
                insert: [],
                deleteCount: 1
            },
            {
                index: 2,
                deleteCount: 1,
                insert: []
            },
            {
                index: 3,
                deleteCount: 1,
                insert: []
            }
        ]);
        patches = diff([
            { id: 1 },
            { id: 2 }
        ], [
            { id: 1 },
            { id: 1.5 },
            { id: 3 }
        ], function (a, b) {
            return a.id === b.id;
        });
        deepEqual(patches, [{
                index: 1,
                deleteCount: 1,
                insert: [
                    { id: 1.5 },
                    { id: 3 }
                ]
            }], 'identity works');
        patches = diff([
            { id: 1 },
            { id: 2 }
        ], [
            { id: 1 },
            { id: 3 },
            { id: 2 }
        ], function (a, b) {
            return a.id === b.id;
        });
        deepEqual(patches, [{
                index: 1,
                deleteCount: 0,
                insert: [{ id: 3 }]
            }], 'identity for a single middle insertion');
    });
});
/*can-util@3.9.6#js/diff-array/diff-array*/
define('can-util@3.9.6#js/diff-array/diff-array', function (require, exports, module) {
    'use strict';
    var diff = require('../diff/diff');
    module.exports = exports = diff;
});
/*can-util@3.9.6#js/diff-array/diff-array-test*/
define('can-util@3.9.6#js/diff-array/diff-array-test', function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var diffArray = require('./diff-array');
    QUnit.module('can-util/js/diff-array');
    QUnit.test('basics', function () {
        var patches = diffArray([], [
            1,
            2,
            3
        ]);
        deepEqual(patches, [{
                index: 0,
                deleteCount: 0,
                insert: [
                    1,
                    2,
                    3
                ]
            }], 'insert many at end');
        patches = diffArray([
            1,
            2,
            3
        ], [
            1,
            2,
            3
        ]);
        deepEqual(patches, [], 'no changes');
        patches = diffArray([
            1,
            2,
            3
        ], [
            1,
            2,
            3,
            4
        ]);
        deepEqual(patches, [{
                index: 3,
                deleteCount: 0,
                insert: [4]
            }], 'add one at the end');
        patches = diffArray([
            1,
            2,
            3,
            4
        ], [
            1,
            2,
            4
        ]);
        deepEqual(patches, [{
                index: 2,
                deleteCount: 1,
                insert: []
            }], 'remove one in the middle');
        patches = diffArray([
            'a',
            'b',
            'z',
            'f',
            'x'
        ], [
            'a',
            'b',
            'f',
            'w',
            'z'
        ]);
        deepEqual(patches, [
            {
                index: 2,
                deleteCount: 1,
                insert: []
            },
            {
                index: 3,
                deleteCount: 1,
                insert: [
                    'w',
                    'z'
                ]
            }
        ], 'can delete one');
        patches = diffArray([
            'a',
            'b',
            'b'
        ], [
            'c',
            'a',
            'b'
        ]);
        deepEqual(patches, [
            {
                index: 0,
                insert: ['c'],
                deleteCount: 0
            },
            {
                index: 3,
                deleteCount: 1,
                insert: []
            }
        ]);
        patches = diffArray([
            'a',
            'b',
            'c',
            'd',
            'e',
            'f',
            'g'
        ], [
            'a',
            'c',
            'e',
            'g'
        ]);
        deepEqual(patches, [
            {
                index: 1,
                insert: [],
                deleteCount: 1
            },
            {
                index: 2,
                deleteCount: 1,
                insert: []
            },
            {
                index: 3,
                deleteCount: 1,
                insert: []
            }
        ]);
    });
    QUnit.test('handle swaps at the end (#193)', function () {
        var patches = diffArray([
            'a',
            'b',
            'c',
            'd',
            'e'
        ], [
            'a',
            'x',
            'y',
            'z',
            'e'
        ]);
        deepEqual(patches, [{
                index: 1,
                deleteCount: 3,
                insert: [
                    'x',
                    'y',
                    'z'
                ]
            }], 'handle reverse patch');
    });
    QUnit.test('handle swaps at the end after a delete (#193)', function () {
        var patches = diffArray([
            'a',
            'b',
            'c',
            'd',
            'e'
        ], [
            'a',
            'x',
            'b',
            'y',
            'z',
            'e'
        ]);
        deepEqual(patches, [
            {
                index: 1,
                deleteCount: 0,
                insert: ['x']
            },
            {
                index: 3,
                deleteCount: 2,
                insert: [
                    'y',
                    'z'
                ]
            }
        ], 'handle reverse patch');
    });
});
/*can-util@3.9.6#js/diff-object/diff-object-test*/
define('can-util@3.9.6#js/diff-object/diff-object-test', function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var diffObject = require('./diff-object');
    QUnit.module('can-util/js/diff');
    QUnit.test('basics', function () {
        var patches = diffObject({}, { a: 'foo' });
        deepEqual(patches, [{
                property: 'a',
                type: 'add',
                value: 'foo'
            }], 'add property');
        patches = diffObject(null, { a: 'foo' });
        deepEqual(patches, [{
                property: 'a',
                type: 'add',
                value: 'foo'
            }], 'add property - oldObject null');
        patches = diffObject({ a: 'foo' }, { a: 'bar' });
        deepEqual(patches, [{
                property: 'a',
                type: 'set',
                value: 'bar'
            }], 'change property');
        patches = diffObject({ a: 'foo' }, {});
        deepEqual(patches, [{
                property: 'a',
                type: 'remove'
            }], 'remove property');
        patches = diffObject({
            a: 'foo',
            b: 'baz'
        }, {
            a: 'bar',
            c: 'quz'
        });
        deepEqual(patches, [
            {
                property: 'a',
                type: 'set',
                value: 'bar'
            },
            {
                property: 'c',
                type: 'add',
                value: 'quz'
            },
            {
                property: 'b',
                type: 'remove'
            }
        ], 'add, set, and remove');
    });
    QUnit.test('mutation test', function () {
        var oldObject = {
            a: 'foo',
            b: 'baz'
        };
        var newObject = {
            a: 'bar',
            c: 'quz'
        };
        diffObject(oldObject, newObject);
        deepEqual(oldObject, {
            a: 'foo',
            b: 'baz'
        }, 'should not mutate old object');
        deepEqual(newObject, {
            a: 'bar',
            c: 'quz'
        }, 'should not mutate new object');
    });
});
/*can-util@3.9.6#js/each/each-test*/
define('can-util@3.9.6#js/each/each-test', function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var each = require('./each');
    var canSymbol = require('can-symbol');
    QUnit.module('can-util/js/each');
    test('iOS 8 64-bit JIT object length bug', function () {
        expect(4);
        var i;
        for (i = 0; i < 1000; i++) {
            each([]);
        }
        i = 0;
        each({
            1: '1',
            2: '2',
            3: '3'
        }, function (index) {
            equal(++i, index, 'Iterate over object');
        });
        equal(i, 3, 'Last index should be the length of the array');
    });
    test('#1989 - isArrayLike needs to check for object type', function () {
        try {
            each(true, function (index) {
            });
            ok(true, 'each on true worked');
        } catch (e) {
            ok(false, 'Should not fail');
        }
    });
    test('objects that implement iterators work', function () {
        var Ctr = function () {
        };
        Ctr.prototype[canSymbol.iterator || canSymbol.for('iterator')] = function () {
            return {
                i: 0,
                next: function () {
                    if (this.i === 1) {
                        return {
                            value: undefined,
                            done: true
                        };
                    }
                    this.i++;
                    return {
                        value: [
                            'a',
                            'b'
                        ],
                        done: false
                    };
                }
            };
        };
        var obj = new Ctr();
        each(obj, function (value, key) {
            equal(key, 'a');
            equal(value, 'b');
        });
    });
});
/*can-util@3.9.6#js/get/get-test*/
define('can-util@3.9.6#js/get/get-test', function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var get = require('./get');
    QUnit.module('can-util/js/get');
    QUnit.test('get Single root', function () {
        var root, result;
        root = { foo: 'bar' };
        result = get(root, 'foo');
        equal(result, 'bar', 'got \'bar\'');
        result = get(root, 'baz');
        equal(result, undefined, 'got \'undefined\'');
    });
    QUnit.test('get Deep objects', function () {
        var root, result;
        root = { foo: { bar: 'baz' } };
        result = get(root, 'foo.bar');
        equal(result, 'baz', 'got \'baz\'');
        result = get(root, 'foo.world');
        equal(result, undefined, 'got \'undefined\'');
    });
    QUnit.test('get with numeric index', function () {
        var list = [
                1,
                2,
                3
            ], result0 = get(list, 0);
        equal(result0, 1, 'got the 1st element of the list');
        var result1 = get(list, 1);
        equal(result1, 2, 'got the 2nd element of the list');
    });
});
/*can-util@3.9.6#js/global/global-test*/
define('can-util@3.9.6#js/global/global-test', function (require, exports, module) {
    (function (global) {
        var QUnit = require('../../test/qunit');
        var getGlobal = require('./global');
        var isBrowserWindow = require('../is-browser-window/is-browser-window');
        QUnit.module('can-util/js/global');
        test('basics', function () {
            if (isBrowserWindow()) {
                ok(getGlobal() === window);
            } else {
                ok(getGlobal() === global);
            }
        });
        if (!isBrowserWindow()) {
            QUnit.module('in Node with fake window', {
                setup: function () {
                    this.oldWindow = global.window;
                    global.window = {};
                },
                teardown: function () {
                    global.window = this.oldWindow;
                }
            });
            test('Gets the Node global', function () {
                ok(getGlobal() === global);
            });
        }
    }(function () {
        return this;
    }()));
});
/*can-util@3.9.6#js/import/import-test*/
define('can-util@3.9.6#js/import/import-test', function (require, exports, module) {
    (function (global, __dirname) {
        'use strict';
        var QUnit = require('../../test/qunit');
        var load = require('./import');
        var isNode = require('../is-node/is-node')();
        if (!isNode) {
            QUnit.module('can-util/js/import');
            if (__dirname !== '/') {
                QUnit.test('basic can-import works', function () {
                    stop();
                    load('can-util/js/import/testmodule', __dirname).then(function (data) {
                        QUnit.equal(data, 'Hello world');
                    }).then(null, function (err) {
                        QUnit.ok(false, err);
                    }).then(start, start);
                });
            }
        } else {
            QUnit.module('can-util/js/import - Node', {
                setup: function () {
                    this.oldSystem = global.System;
                    global.System = {
                        'import': function (name) {
                            name = name.replace('can-util', '');
                            return new Promise(function (resolve, reject) {
                                try {
                                    var mod = require(process.cwd() + name);
                                    resolve(mod);
                                } catch (err) {
                                    reject(err);
                                }
                            });
                        }
                    };
                },
                teardown: function () {
                    global.System = this.oldSystem;
                }
            });
            QUnit.test('basic can-import works', function () {
                stop();
                load('can-util/js/import/testmodule', __dirname).then(function (data) {
                    QUnit.equal(data, 'Hello world');
                }).then(null, function (err) {
                    QUnit.ok(false, err);
                }).then(start, start);
            });
        }
    }(function () {
        return this;
    }(), '/'));
});
/*can-util@3.9.6#js/is-array/is-array-test*/
define('can-util@3.9.6#js/is-array/is-array-test', function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var isArray = require('./is-array');
    QUnit.module('can-util/js/is-array');
    QUnit.test('basics', function () {
        ok(isArray([]));
        ok(!isArray({
            0: 'a',
            length: 1
        }));
    });
});
/*can-util@3.9.6#js/is-array-like/is-array-like-test*/
define('can-util@3.9.6#js/is-array-like/is-array-like-test', function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var isArrayLike = require('./is-array-like');
    QUnit.module('can-util/js/is-array-like');
    QUnit.test('basics', function () {
        ok(isArrayLike({
            0: 1,
            length: 1
        }));
    });
    QUnit.test('string', function () {
        ok(isArrayLike('yes'));
    });
    QUnit.test('Object with a .length property', function () {
        var obj = { length: 0 };
        ok(isArrayLike(obj));
    });
    QUnit.test('function should be false', function () {
        var func = function () {
        };
        ok(!isArrayLike(func));
    });
    QUnit.test('0 should be false', function () {
        ok(!isArrayLike(0));
    });
});
/*can-util@3.9.6#js/is-browser-window/is-browser-window-test*/
define('can-util@3.9.6#js/is-browser-window/is-browser-window-test', function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var isBrowserWindow = require('./is-browser-window');
    QUnit.module('can-util/js/is-browser-window');
    QUnit.test('basics', function () {
        equal(typeof isBrowserWindow(), 'boolean');
    });
});
/*can-util@3.9.6#js/is-container/is-container-test*/
define('can-util@3.9.6#js/is-container/is-container-test', function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var isContainer = require('./is-container');
    QUnit.module('can-util/js/is-container');
    QUnit.test('object', function () {
        ok(isContainer({ 'a': 1 }));
    });
    QUnit.test('function', function () {
        var sum = function (num1, num2) {
            return num1 + num2;
        };
        ok(isContainer(sum));
    });
    QUnit.test('NaN and undefined is not a container', function () {
        ok(!isContainer(NaN));
        ok(!isContainer());
    });
});
/*can-util@3.9.6#js/is-empty-object/is-empty-object-test*/
define('can-util@3.9.6#js/is-empty-object/is-empty-object-test', function (require, exports, module) {
    'use strict';
    var isEmptyObject = require('./is-empty-object');
    var QUnit = require('../../test/qunit');
    QUnit.module('can-util/js/is-empty-object/is-empty-object');
    QUnit.test('Returns true for plain objects', function (assert) {
        assert.ok(isEmptyObject({}), '{} is true');
        assert.ok(isEmptyObject(new Object()), 'new Object is true');
    });
    QUnit.test('Plain objects with properties are false', function (assert) {
        assert.equal(isEmptyObject({ a: 1 }), false, 'not empty');
    });
    QUnit.test('Returns true for custom objects with no props', function (assert) {
        var Thing = function () {
        };
        assert.equal(isEmptyObject(new Thing()), true, 'is empty');
        var thing2 = new Thing();
        thing2.foo = 'bar';
        assert.equal(isEmptyObject(thing2), false, 'not empty');
    });
});
/*can-util@3.9.6#js/is-function/is-function-test*/
define('can-util@3.9.6#js/is-function/is-function-test', function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var isFunction = require('./is-function');
    QUnit.module('can-util/js/is-function');
    QUnit.test('basics', function () {
        QUnit.ok(isFunction(function () {
        }));
    });
});
/*can-util@3.9.6#js/is-node/is-node-test*/
define('can-util@3.9.6#js/is-node/is-node-test', function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var isNode = require('./is-node');
    QUnit.module('can-util/js/is-node');
    test('basics', function () {
        QUnit.equal(typeof isNode(), 'boolean');
    });
});
/*can-util@3.9.6#js/is-plain-object/is-plain-object-test*/
define('can-util@3.9.6#js/is-plain-object/is-plain-object-test', function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var isPlainObject = require('./is-plain-object');
    QUnit.module('can-util/js/is-plain-object');
    QUnit.test('basics', function () {
        QUnit.ok(isPlainObject({ foo: 'bar' }));
    });
    QUnit.test('objects with prototypes', function () {
        var Ctr = function () {
        };
        var obj = new Ctr();
        QUnit.equal(isPlainObject(obj), false, 'not a plain object');
    });
    QUnit.test('new Object', function () {
        var obj;
        obj = new Object();
        QUnit.equal(isPlainObject(obj), true, 'using new Object gives you a plain object');
    });
    QUnit.test('Booleans', function () {
        QUnit.equal(isPlainObject(true), false, 'Boolean value true is false');
        QUnit.equal(isPlainObject(Boolean(true)), false, 'Boolean constructor');
    });
    QUnit.test('Numbers', function () {
        QUnit.equal(isPlainObject(15.66), false, 'number is not a plain object');
        QUnit.equal(isPlainObject(parseInt(13)), false, 'integer is not a plain object');
    });
    QUnit.test('NaN', function () {
        QUnit.equal(isPlainObject(NaN), false, 'NaN is not a plain object');
    });
});
/*can-util@3.9.6#js/is-promise-like/is-promise-like-test*/
define('can-util@3.9.6#js/is-promise-like/is-promise-like-test', function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var isPromise = require('./is-promise-like');
    QUnit.module('can-util/js/is-promise-like');
    QUnit.test('basics', function () {
        QUnit.ok(isPromise({
            then: function () {
            }
        }));
    });
});
/*can-util@3.9.6#js/make-promise/make-promise*/
define('can-util@3.9.6#js/make-promise/make-promise', function (require, exports, module) {
    'use strict';
    var isPromiseLike = require('../is-promise-like/is-promise-like');
    var isPromise = require('../is-promise/is-promise');
    module.exports = function (obj) {
        if (isPromiseLike(obj) && !isPromise(obj)) {
            return new Promise(function (resolve, reject) {
                obj.then(resolve, reject);
            });
        } else {
            return obj;
        }
    };
});
/*can-util@3.9.6#js/make-promise/make-promise-test*/
define('can-util@3.9.6#js/make-promise/make-promise-test', function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var isPromise = require('../is-promise/is-promise');
    var makePromise = require('./make-promise');
    QUnit.module('can-util/js/make-promise');
    QUnit.test('basics', function () {
        var obj = {
            fail: function () {
            },
            then: function () {
            }
        };
        var promise = makePromise(obj);
        QUnit.ok(isPromise(promise));
        obj = {
            catch: function () {
            },
            then: function () {
            }
        };
        promise = makePromise(obj);
        QUnit.ok(isPromise(promise));
    });
});
/*can-util@3.9.6#js/omit/omit-test*/
define('can-util@3.9.6#js/omit/omit-test', function (require, exports, module) {
    'use strict';
    var omit = require('./omit');
    var QUnit = require('../../test/qunit');
    QUnit.module('can-util/js/omit');
    QUnit.test('Omit properties from an object', function () {
        var source = {
            a: 1,
            b: 2,
            c: 3,
            d: 4
        };
        var propsToOmit = [
            'b',
            'd'
        ];
        var expected = {
            a: 1,
            c: 3
        };
        var actual = omit(source, propsToOmit);
        deepEqual(expected, actual);
    });
});
/*can-util@3.9.6#js/is-string/is-string-test*/
define('can-util@3.9.6#js/is-string/is-string-test', function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var isString = require('./is-string');
    QUnit.module('can-util/js/is-string');
    QUnit.test('basics', function () {
        QUnit.equal(isString('yes'), true);
        QUnit.equal(isString(String('yes')), true);
    });
});
/*can-util@3.9.6#js/is-web-worker/is-web-worker-test*/
define('can-util@3.9.6#js/is-web-worker/is-web-worker-test', function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var isWebWorker = require('./is-web-worker');
    QUnit.module('can-util/js/is-web-worker');
    QUnit.test('basics', function () {
        QUnit.equal(typeof isWebWorker(), 'boolean');
    });
});
/*can-util@3.9.6#js/join-uris/join-uris-test*/
define('can-util@3.9.6#js/join-uris/join-uris-test', function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var joinURIs = require('./join-uris');
    QUnit.module('can-util/js/join-uris');
    QUnit.test('basics', function () {
        QUnit.deepEqual(joinURIs('foo/bar/car.html', '../zed.html'), 'foo/zed.html');
    });
});
/*can-util@3.9.6#js/parse-uri/parse-uri-test*/
define('can-util@3.9.6#js/parse-uri/parse-uri-test', function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var parseURI = require('./parse-uri');
    QUnit.module('can-util/js/parse-uri');
    QUnit.test('basics', function () {
        QUnit.deepEqual(parseURI('http://foo:8080/bar.html#change'), {
            authority: '//foo:8080',
            hash: '#change',
            host: 'foo:8080',
            hostname: 'foo',
            href: 'http://foo:8080/bar.html#change',
            pathname: '/bar.html',
            port: '8080',
            protocol: 'http:',
            search: ''
        });
    });
});
/*can-util@3.9.6#js/last/last-test*/
define('can-util@3.9.6#js/last/last-test', function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var last = require('./last');
    QUnit.module('can-util/js/last');
    QUnit.test('basics', function () {
        QUnit.equal(last([
            'a',
            'b'
        ]), 'b');
    });
});
/*can-util@3.9.6#js/make-array/make-array-test*/
define('can-util@3.9.6#js/make-array/make-array-test', function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var makeArray = require('./make-array');
    QUnit.module('can-util/js/make-array');
    QUnit.test('basics', function () {
        var res = makeArray({
            0: 'a',
            length: 1
        });
        QUnit.deepEqual(res, ['a']);
        QUnit.ok(res instanceof Array);
    });
    QUnit.test('with Object', function () {
        var res = makeArray({
            abc: 'xyz',
            bar: 'foo'
        });
        QUnit.deepEqual(res, [{
                abc: 'xyz',
                bar: 'foo'
            }]);
        QUnit.ok(res instanceof Array);
    });
    QUnit.test('with number', function () {
        var res = makeArray(1);
        QUnit.deepEqual(res, [1]);
        QUnit.ok(res instanceof Array);
    });
    QUnit.test('with zero', function () {
        var res = makeArray(0);
        QUnit.deepEqual(res, [0]);
        QUnit.ok(res instanceof Array);
    });
    QUnit.test('with null', function () {
        var res = makeArray(null);
        QUnit.deepEqual(res, []);
        QUnit.ok(res instanceof Array);
    });
});
/*can-util@3.9.6#js/make-map/make-map*/
define('can-util@3.9.6#js/make-map/make-map', function (require, exports, module) {
    'use strict';
    var each = require('../each/each');
    function makeMap(str) {
        var obj = {}, items = str.split(',');
        each(items, function (name) {
            obj[name] = true;
        });
        return obj;
    }
    module.exports = makeMap;
});
/*can-util@3.9.6#js/make-map/make-map-test*/
define('can-util@3.9.6#js/make-map/make-map-test', function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var makeMap = require('./make-map');
    QUnit.module('can-util/js/make-map');
    QUnit.test('basics', function () {
        var res = makeMap('a,b,c');
        QUnit.deepEqual(res, {
            a: true,
            b: true,
            c: true
        });
        QUnit.ok(res instanceof Object);
    });
});
/*can-util@3.9.6#js/set-not-enumerable/set-not-enumerable-test*/
define('can-util@3.9.6#js/set-not-enumerable/set-not-enumerable-test', function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var setNotEnumerable = require('./set-not-enumerable');
    QUnit.module('can-util/js/set-not-enumerable');
    QUnit.test('basics', 0, function () {
        var obj = {};
        setNotEnumerable(obj, 'prop', 'val');
        for (var prop in obj) {
            ok(false, prop);
        }
    });
});
/*can-util@3.9.6#js/single-reference/single-reference-test*/
define('can-util@3.9.6#js/single-reference/single-reference-test', function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var singleReference = require('./single-reference');
    QUnit.module('can-util/js/single-reference');
    QUnit.test('basics', function () {
        var obj = {};
        singleReference.set(obj, 'pet', 'dog');
        var retrieved = singleReference.getAndDelete(obj, 'pet');
        QUnit.equal(retrieved, 'dog', 'sets and retrieves successfully');
        QUnit.equal(Object.keys(obj).length, 0, 'also deletes when retrieved');
    });
});
/*can-util@3.9.6#js/string/string-test*/
define('can-util@3.9.6#js/string/string-test', function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var string = require('./string');
    QUnit.module('can-util/js/string');
    QUnit.test('string.sub', function () {
        equal(string.sub('a{b}', { b: 'c' }), 'ac');
        var foo = { b: 'c' };
        equal(string.sub('a{b}', foo, true), 'ac');
        ok(!foo.b, 'b\'s value was removed');
    });
    QUnit.test('string.sub with undefined values', function () {
        var subbed = string.sub('test{exists} plus{noexists}', { exists: 'test' });
        deepEqual(subbed, null, 'Rendering with undefined values should return null');
        subbed = string.sub('test{exists} plus{noexists}', { exists: 'test' }, true);
        deepEqual(subbed, null, 'Rendering with undefined values should return null even when remove param is true');
    });
    QUnit.test('string.sub with null values', function () {
        var subbed = string.sub('test{exists} plus{noexists}', {
            exists: 'test',
            noexists: null
        });
        deepEqual(subbed, null, 'Rendering with null values should return null');
        subbed = string.sub('test{exists} plus{noexists}', {
            exists: 'test',
            noexists: null
        }, true);
        deepEqual(subbed, null, 'Rendering with null values should return null even when remove param is true');
    });
    QUnit.test('string.sub double', function () {
        equal(string.sub('{b} {d}', {
            b: 'c',
            d: 'e'
        }), 'c e');
    });
    QUnit.test('String.underscore', function () {
        equal(string.underscore('Foo.Bar.ZarDar'), 'foo.bar.zar_dar');
    });
    QUnit.test('string.sub remove', function () {
        var obj = { a: 'a' };
        equal(string.sub('{a}', obj, false), 'a');
        deepEqual(obj, { a: 'a' });
        equal(string.sub('{a}', obj, true), 'a');
        deepEqual(obj, {});
    });
    QUnit.test('string.getObject Single root', function () {
        var root, result;
        root = { foo: 'bar' };
        result = string.getObject('foo', root);
        equal(result, 'bar', 'got \'bar\'');
        result = string.getObject('baz', root);
        equal(result, undefined, 'got \'undefined\'');
    });
    QUnit.test('string.getObject Multiple root', function () {
        var root1, root2, roots, result;
        root1 = { a: 1 };
        root2 = { b: 2 };
        roots = [
            root1,
            root2
        ];
        result = string.getObject('a', roots);
        equal(result, 1, 'got \'1\'');
        result = string.getObject('b', roots);
        equal(result, 2, 'got \'2\'');
        result = string.getObject('c', roots);
        equal(result, undefined, 'got \'undefined\'');
        root1 = undefined;
        root2 = { b: 2 };
        roots = [
            root1,
            root2
        ];
        result = string.getObject('b', roots);
        equal(result, 2, 'got \'2\'');
    });
    QUnit.test('string.getObject Deep objects', function () {
        var root, result;
        root = { foo: { bar: 'baz' } };
        result = string.getObject('foo.bar', root);
        equal(result, 'baz', 'got \'baz\'');
        result = string.getObject('foo.world', root);
        equal(result, undefined, 'got \'undefined\'');
    });
    QUnit.test('string.esc', function () {
        var text = string.esc(0);
        equal(text, '0', '0 value properly rendered');
        text = string.esc(null);
        deepEqual(text, '', 'null value returns empty string');
        text = string.esc();
        deepEqual(text, '', 'undefined returns empty string');
        text = string.esc(NaN);
        deepEqual(text, '', 'NaN returns empty string');
        text = string.esc('<div>&nbsp;</div>');
        equal(text, '&lt;div&gt;&amp;nbsp;&lt;/div&gt;', 'HTML escaped properly');
    });
    QUnit.test('string.camelize', function () {
        var text = string.camelize(0);
        equal(text, '0', '0 value properly rendered');
        text = string.camelize(null);
        equal(text, '', 'null value returns empty string');
        text = string.camelize();
        equal(text, '', 'undefined returns empty string');
        text = string.camelize(NaN);
        equal(text, '', 'NaN returns empty string');
        text = string.camelize('-moz-index');
        equal(text, 'MozIndex');
        text = string.camelize('foo-bar');
        equal(text, 'fooBar');
    });
    QUnit.test('string.hyphenate', function () {
        var text = string.hyphenate(0);
        equal(text, '0', '0 value properly rendered');
        text = string.hyphenate(null);
        equal(text, '', 'null value returns empty string');
        text = string.hyphenate();
        equal(text, '', 'undefined returns empty string');
        text = string.hyphenate(NaN);
        equal(text, '', 'NaN returns empty string');
        text = string.hyphenate('ABC');
        equal(text, 'ABC');
        text = string.hyphenate('dataNode');
        equal(text, 'data-node');
    });
});
/*can-util@3.9.6#js/string-to-any/string-to-any-test*/
define('can-util@3.9.6#js/string-to-any/string-to-any-test', function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var stringToAny = require('./string-to-any');
    var each = require('../each/each');
    QUnit.module('can-util/js/string-to-any');
    QUnit.test('works with primitive types', function () {
        var fixture = {
            'foo': 'foo',
            '33': 33,
            'true': true,
            'false': false,
            'undefined': undefined,
            'null': null,
            'Infinity': Infinity
        };
        each(fixture, function (value, key) {
            QUnit.ok(stringToAny(key) === value, 'Correctly converted type: ' + key);
        });
        QUnit.ok(isNaN(stringToAny('NaN')), 'Correclty converted type: NaN');
    });
});
/*can-util@3.9.6#js/tests*/
define('can-util@3.9.6#js/tests', function (require, exports, module) {
    (function (global) {
        'use strict';
        require('./assign/assign-test');
        require('./assign-non-enumerable/assign-non-enumerable-test');
        require('./base-url/base-url-test');
        require('./cid-map/cid-map-test');
        require('./cid-set/cid-set-test');
        require('./deep-assign/deep-assign-test');
        require('./defaults/defaults-test');
        require('./dev/dev-test');
        require('./log/log-test');
        require('./diff/diff-test');
        require('./diff-array/diff-array-test');
        require('./diff-object/diff-object-test');
        require('./each/each-test');
        require('./get/get-test');
        require('./global/global-test');
        require('./import/import-test');
        require('./is-array/is-array-test');
        require('./is-array-like/is-array-like-test');
        require('./is-browser-window/is-browser-window-test');
        require('./is-container/is-container-test');
        require('./is-empty-object/is-empty-object-test');
        require('./is-function/is-function-test');
        require('./is-node/is-node-test');
        require('./is-plain-object/is-plain-object-test');
        require('./is-promise-like/is-promise-like-test');
        require('./make-promise/make-promise-test');
        require('./omit/omit-test');
        require('./is-string/is-string-test');
        require('./is-web-worker/is-web-worker-test');
        require('./join-uris/join-uris-test');
        require('./parse-uri/parse-uri-test');
        require('./last/last-test');
        require('./make-array/make-array-test');
        require('./make-map/make-map-test');
        require('./set-not-enumerable/set-not-enumerable-test');
        require('./single-reference/single-reference-test');
        require('./string/string-test');
        require('./string-to-any/string-to-any-test');
    }(function () {
        return this;
    }()));
});
/*can-util@3.9.6#dom/ajax/ajax-test*/
define('can-util@3.9.6#dom/ajax/ajax-test', function (require, exports, module) {
    (function (global, __dirname) {
        'use strict';
        var ajax = require('can-util/dom/ajax/ajax');
        var namespace = require('can-namespace');
        var makeMap = require('can-util/js/make-map/make-map');
        var GLOBAL = require('../../js/global/global');
        var parseURI = require('../../js/parse-uri/parse-uri');
        QUnit = require('steal-qunit');
        QUnit.module('can-util/dom/ajax');
        var makeFixture = function (XHR) {
            var oldXhr = window.XMLHttpRequest || window.ActiveXObject;
            if (window.XMLHttpRequest) {
                window.XMLHttpRequest = XHR;
            } else if (window.ActiveXObject) {
                window.ActiveXObject = XHR;
            }
            return function restoreXHR() {
                if (window.XMLHttpRequest) {
                    window.XMLHttpRequest = oldXhr;
                } else if (window.ActiveXObject) {
                    window.ActiveXObject = oldXhr;
                }
            };
        };
        var makePredicateContains = function (str) {
            var obj = makeMap(str);
            return function (val) {
                return obj[val];
            };
        };
        if (__dirname !== '/') {
            QUnit.asyncTest('basic get request', function () {
                ajax({
                    type: 'get',
                    url: __dirname + '/test-result.json'
                }).then(function (resp) {
                    QUnit.equal(resp.message, 'VALUE');
                    start();
                });
            });
        }
        QUnit.test('added to namespace (#99)', function () {
            QUnit.equal(namespace.ajax, ajax);
        });
        if (__dirname !== '/') {
            QUnit.asyncTest('GET requests with dataType parse JSON (#106)', function () {
                ajax({
                    type: 'get',
                    url: __dirname + '/test-result.txt',
                    dataType: 'json'
                }).then(function (resp) {
                    QUnit.equal(resp.message, 'VALUE');
                    start();
                });
            });
        }
        QUnit.asyncTest('ignores case of type parameter for a post request (#100)', function () {
            var requestHeaders = { CONTENT_TYPE: 'Content-Type' }, restore = makeFixture(function () {
                    this.open = function (type, url) {
                    };
                    this.send = function () {
                        this.readyState = 4;
                        this.status = 200;
                        this.onreadystatechange();
                    };
                    this.setRequestHeader = function (header, value) {
                        if (header === requestHeaders.CONTENT_TYPE) {
                            var o = {};
                            o[header] = value;
                            this.responseText = JSON.stringify(o);
                        }
                    };
                });
            ajax({
                type: 'post',
                url: 'http://anotherdomain.com/foo',
                data: { bar: 'qux' }
            }).then(function (value) {
                QUnit.equal(value[requestHeaders.CONTENT_TYPE], 'application/x-www-form-urlencoded');
            }, function (reason) {
                QUnit.notOk(reason, 'request failed with reason = ', reason);
            }).then(function () {
                restore();
                start();
            });
        });
        QUnit.asyncTest('url encodes GET requests when no contentType', function () {
            var restore = makeFixture(function () {
                var o = {};
                this.open = function (type, url) {
                    o.url = url;
                };
                this.send = function (data) {
                    o.data = data;
                    this.readyState = 4;
                    this.status = 200;
                    this.responseText = JSON.stringify(o);
                    this.onreadystatechange();
                };
                this.setRequestHeader = function (header, value) {
                    if (header === 'Content-Type') {
                        o[header] = value;
                    }
                };
            });
            ajax({
                type: 'get',
                url: 'http://anotherdomain.com/foo',
                data: { foo: 'bar' }
            }).then(function (value) {
                QUnit.equal(value['Content-Type'], 'application/x-www-form-urlencoded');
                QUnit.equal(value.data, undefined, 'No data provided because it\'s a GET');
                QUnit.equal(value.url, 'http://anotherdomain.com/foo?foo=bar');
            }, function (reason) {
                QUnit.notOk(reason, 'request failed with reason = ', reason);
            }).then(function () {
                restore();
                start();
            });
        });
        QUnit.asyncTest('Stringifies GET requests when contentType=application/json', function () {
            var restore = makeFixture(function () {
                var o = {};
                this.open = function (type, url) {
                    o.url = url;
                };
                this.send = function (data) {
                    o.data = data;
                    this.readyState = 4;
                    this.status = 200;
                    this.responseText = JSON.stringify(o);
                    this.onreadystatechange();
                };
                this.setRequestHeader = function (header, value) {
                    if (header === 'Content-Type') {
                        o[header] = value;
                    }
                };
            });
            ajax({
                type: 'get',
                url: 'http://anotherdomain.com/foo',
                data: { foo: 'bar' },
                contentType: 'application/json'
            }).then(function (value) {
                QUnit.equal(value['Content-Type'], 'application/json');
                QUnit.equal(value.data, undefined, 'No data provided because it\'s a GET');
                QUnit.equal(value.url, 'http://anotherdomain.com/foo?{"foo":"bar"}');
            }, function (reason) {
                QUnit.notOk(reason, 'request failed with reason = ', reason);
            }).then(function () {
                restore();
                start();
            });
        });
        QUnit.asyncTest('Stringifies POST requests when there is no contentType', function () {
            var restore = makeFixture(function () {
                var o = {};
                this.open = function (type, url) {
                    o.url = url;
                };
                this.send = function (data) {
                    o.data = data;
                    this.readyState = 4;
                    this.status = 200;
                    this.responseText = JSON.stringify(o);
                    this.onreadystatechange();
                };
                this.setRequestHeader = function (header, value) {
                    if (header === 'Content-Type') {
                        o[header] = value;
                    }
                };
            });
            var origin = parseURI(GLOBAL().location.href);
            var url = origin.protocol + origin.authority + '/foo';
            ajax({
                type: 'post',
                url: url,
                data: { foo: 'bar' }
            }).then(function (value) {
                QUnit.equal(value['Content-Type'], 'application/json');
                QUnit.equal(value.data, '{"foo":"bar"}', 'Data was stringified');
                QUnit.equal(value.url, url);
            }, function (reason) {
                QUnit.notOk(reason, 'request failed with reason = ', reason);
            }).then(function () {
                restore();
                start();
            });
        });
        QUnit.asyncTest('url encodes POST requests when contentType=application/x-www-form-urlencoded', function () {
            var restore = makeFixture(function () {
                var o = {};
                this.open = function (type, url) {
                    o.url = url;
                };
                this.send = function (data) {
                    o.data = data;
                    this.readyState = 4;
                    this.status = 200;
                    this.responseText = JSON.stringify(o);
                    this.onreadystatechange();
                };
                this.setRequestHeader = function (header, value) {
                    if (header === 'Content-Type') {
                        o[header] = value;
                    }
                };
            });
            ajax({
                type: 'post',
                url: 'http://anotherdomain.com/foo',
                data: { foo: 'bar' },
                contentType: 'application/x-www-form-urlencoded'
            }).then(function (value) {
                QUnit.equal(value['Content-Type'], 'application/x-www-form-urlencoded');
                QUnit.equal(value.data, 'foo=bar', 'Data was url encoded');
                QUnit.equal(value.url, 'http://anotherdomain.com/foo');
            }, function (reason) {
                QUnit.notOk(reason, 'request failed with reason = ', reason);
            }).then(function () {
                restore();
                start();
            });
        });
        if (typeof XDomainRequest === 'undefined') {
            QUnit.asyncTest('cross domain post request should change data to form data (#90)', function () {
                ajax({
                    type: 'POST',
                    url: 'http://httpbin.org/post',
                    data: { 'message': 'VALUE' },
                    dataType: 'application/json'
                }).then(function (resp) {
                    QUnit.equal(resp.form.message, 'VALUE');
                    start();
                });
            });
            QUnit.asyncTest('GET CORS should be a simple request - without a preflight (#187)', function () {
                var isSimpleRequest = true, restore;
                var isSimpleMethod = makePredicateContains('GET,POST,HEAD');
                var isSimpleHeader = makePredicateContains('Accept,Accept-Language,Content-Language,Content-Type,DPR,Downlink,Save-Data,Viewport-Width,Width');
                var isSimpleContentType = makePredicateContains('application/x-www-form-urlencoded,multipart/form-data,text/plain');
                restore = makeFixture(function () {
                    this.open = function (type, url) {
                        if (!isSimpleMethod(type)) {
                            isSimpleRequest = false;
                        }
                    };
                    var response = {};
                    this.send = function () {
                        this.responseText = JSON.stringify(response);
                        this.readyState = 4;
                        this.status = 200;
                        this.onreadystatechange();
                    };
                    this.setRequestHeader = function (header, value) {
                        if (header === 'Content-Type' && !isSimpleContentType(value)) {
                            isSimpleRequest = false;
                        }
                        if (isSimpleRequest && !isSimpleHeader(header)) {
                            isSimpleRequest = false;
                        }
                        response[header] = value;
                    };
                });
                ajax({
                    url: 'http://query.yahooapis.com/v1/public/yql',
                    data: {
                        q: 'select * from geo.places where text="sunnyvale, ca"',
                        format: 'json'
                    }
                }).then(function (response) {
                    QUnit.ok(isSimpleRequest, 'CORS GET is simple');
                    restore();
                    start();
                }, function (err) {
                    QUnit.ok(false, 'Should be resolved');
                    restore();
                    start();
                });
            });
        }
        if (System.env !== 'canjs-test' && __dirname !== '/') {
            QUnit.asyncTest('abort', function () {
                var promise = ajax({
                    type: 'get',
                    url: __dirname + '/test-result.json'
                });
                promise.catch(function (xhr) {
                    if (xhr instanceof Error) {
                        QUnit.equal(xhr.message, 'Could not complete the operation due to error c00c023f.');
                        start();
                    } else {
                        setTimeout(function () {
                            QUnit.equal(xhr.readyState, 0, 'aborts the promise');
                            start();
                        }, 50);
                    }
                });
                promise.abort();
            });
        }
        QUnit.asyncTest('crossDomain is true for relative requests', function () {
            var headers = {}, restore = makeFixture(function () {
                    this.open = function (type, url) {
                    };
                    this.send = function () {
                        this.readyState = 4;
                        this.status = 200;
                        this.responseText = JSON.stringify({ great: 'success' });
                        this.onreadystatechange();
                    };
                    this.setRequestHeader = function (header, value) {
                        headers[header] = value;
                    };
                });
            ajax({
                type: 'post',
                url: '/foo',
                data: { bar: 'qux' },
                dataType: 'json'
            }).then(function (value) {
                QUnit.deepEqual(headers, {
                    'Content-Type': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest'
                });
            }, function (reason) {
                QUnit.notOk(reason, 'request failed with reason = ', reason);
            }).then(function () {
                restore();
                start();
            });
        });
        if (__dirname !== '/') {
            QUnit.asyncTest('correctly serializes null and undefined values (#177)', function () {
                ajax({
                    type: 'get',
                    url: __dirname + '/test-result.txt',
                    data: { foo: null }
                }).then(function (resp) {
                    QUnit.equal(resp.message, 'VALUE');
                    start();
                });
            });
        }
    }(function () {
        return this;
    }(), '/'));
});
/*can-util@3.9.6#dom/attr/attr-test*/
define('can-util@3.9.6#dom/attr/attr-test', function (require, exports, module) {
    'use strict';
    var domAttr = require('../attr/attr');
    var domEvents = require('../events/events');
    var domData = require('../data/data');
    var domDispatch = require('../dispatch/dispatch');
    var mutate = require('../mutate/mutate');
    var MUTATION_OBSERVER = require('can-util/dom/mutation-observer/mutation-observer');
    var types = require('can-types');
    QUnit = require('steal-qunit');
    QUnit.module('can-util/dom/attr');
    test('attributes event', function () {
        var div = document.createElement('div');
        var attrHandler1 = function (ev) {
            equal(ev.attributeName, 'foo', 'attribute name is correct');
            equal(ev.target, div, 'target');
            equal(ev.oldValue, null, 'oldValue');
            equal(div.getAttribute(ev.attributeName), 'bar');
            domEvents.removeEventListener.call(div, 'attributes', attrHandler1);
        };
        domEvents.addEventListener.call(div, 'attributes', attrHandler1);
        domAttr.set(div, 'foo', 'bar');
        stop();
        setTimeout(function () {
            var attrHandler = function (ev) {
                ok(true, 'removed event handler should be called');
                equal(ev.attributeName, 'foo', 'attribute name is correct');
                equal(ev.target, div, 'target');
                equal(ev.oldValue, 'bar', 'oldValue should be \'bar\'');
                equal(div.getAttribute(ev.attributeName), null, 'value of the attribute should be null after the remove.');
                domEvents.removeEventListener.call(div, 'attributes', attrHandler);
                start();
            };
            domEvents.addEventListener.call(div, 'attributes', attrHandler);
            domAttr.remove(div, 'foo');
        }, 50);
    });
    test('attr events without MUTATION_OBSERVER', 9, function () {
        var MO = MUTATION_OBSERVER();
        MUTATION_OBSERVER(null);
        var div = document.createElement('div');
        var attrHandler1 = function (ev) {
            equal(ev.attributeName, 'foo', 'attribute name is correct');
            equal(ev.target, div, 'target');
            equal(ev.oldValue, null, 'oldValue');
            equal(div.getAttribute(ev.attributeName), 'bar');
            domEvents.removeEventListener.call(div, 'attributes', attrHandler1);
        };
        domEvents.addEventListener.call(div, 'attributes', attrHandler1);
        domAttr.set(div, 'foo', 'bar');
        stop();
        setTimeout(function () {
            var attrHandler = function (ev) {
                ok(true, 'removed event handler should be called');
                equal(ev.attributeName, 'foo', 'attribute name is correct');
                equal(ev.target, div, 'target');
                equal(ev.oldValue, 'bar', 'oldValue should be \'bar\'');
                equal(div.getAttribute(ev.attributeName), null, 'value of the attribute should be null after the remove.');
                domEvents.removeEventListener.call(div, 'attributes', attrHandler);
                MUTATION_OBSERVER(MO);
                start();
            };
            domEvents.addEventListener.call(div, 'attributes', attrHandler);
            domAttr.remove(div, 'foo');
        }, 50);
    });
    test('attr.set CHECKED attribute works', function () {
        var input = document.createElement('input');
        input.type = 'checkbox';
        document.getElementById('qunit-fixture').appendChild(input);
        domAttr.set(input, 'CHECKED');
        equal(input.checked, true);
        input.checked = false;
        domAttr.set(input, 'CHECKED');
        equal(input.checked, true);
        document.getElementById('qunit-fixture').removeChild(input);
    });
    test('Map special attributes', function () {
        var div = document.createElement('label');
        document.getElementById('qunit-fixture').appendChild(div);
        domAttr.set(div, 'for', 'my-for');
        equal(div.htmlFor, 'my-for', 'Map for to htmlFor');
        if ('innerText' in div) {
            domAttr.set(div, 'innertext', 'my-inner-text');
            equal(div.innerText, 'my-inner-text', 'Map innertext to innerText');
        }
        domAttr.set(div, 'textcontent', 'my-content');
        equal(div.textContent, 'my-content', 'Map textcontent to textContent');
        document.getElementById('qunit-fixture').removeChild(div);
        div = document.createElement('input');
        div.type = 'text';
        document.getElementById('qunit-fixture').appendChild(div);
        domAttr.set(div, 'readonly');
        equal(div.readOnly, true, 'Map readonly to readOnly');
        domAttr.set(div, 'readonly', false);
        equal(div.readOnly, false, 'not readonly');
        domAttr.set(div, 'readonly', '');
        equal(div.readOnly, true, 'readonly again');
        document.getElementById('qunit-fixture').removeChild(div);
    });
    test('set class attribute via className or setAttribute for svg (#2015)', function () {
        var div = document.createElement('div');
        var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        var obj = {
            toString: function () {
                return 'my-class';
            }
        };
        domAttr.set(div, 'class', 'my-class');
        equal(div.getAttribute('class'), 'my-class', 'class mapped to className');
        domAttr.set(div, 'class', undefined);
        equal(div.getAttribute('class'), '', 'an undefined className is an empty string');
        domAttr.set(div, 'class', obj);
        equal(div.getAttribute('class'), 'my-class', 'you can pass an object to className');
        domAttr.set(svg, 'class', 'my-class');
        equal(svg.getAttribute('class'), 'my-class', 'svg class was set as an attribute');
        domAttr.set(svg, 'class', undefined);
        equal(svg.getAttribute('class'), '', 'an undefined svg class is an empty string');
        domAttr.set(svg, 'class', obj);
        equal(svg.getAttribute('class'), 'my-class', 'you can pass an object to svg class');
    });
    test('set xlink:href attribute via setAttributeNS for svg-use (#2384)', function () {
        var use = document.createElementNS('http://www.w3.org/2000/svg', 'use');
        domAttr.set(use, 'xlink:href', 'svgUri');
        equal(use.getAttributeNS('http://www.w3.org/1999/xlink', 'href'), 'svgUri', 'svg-use xlink:href was set with setAttributeNS');
    });
    test('attr.special addEventListener allows custom binding', function () {
        var trigger;
        domAttr.special.foo = {
            addEventListener: function (eventName, handler) {
                trigger = function () {
                    handler();
                };
                return function () {
                    trigger = function () {
                    };
                };
            },
            set: function (val) {
                this.foo = val;
                trigger();
            }
        };
        var div = document.createElement('div');
        var times = 0;
        var handler = function () {
            times++;
            equal(times, 1, 'addEventListener called');
        };
        domEvents.addEventListener.call(div, 'foo', handler);
        domAttr.set(div, 'foo', 'bar');
        domEvents.removeEventListener.call(div, 'foo', handler);
        domAttr.set(div, 'foo', 'baz');
        delete domAttr.special.foo;
    });
    test('\'selected\' is bindable on an <option>', function () {
        var select = document.createElement('select');
        var option1 = document.createElement('option');
        option1.value = 'one';
        var option2 = document.createElement('option');
        option2.value = 'two';
        select.appendChild(option1);
        select.appendChild(option2);
        domEvents.addEventListener.call(option2, 'selected', function () {
            ok(true, 'selected was called on the option');
        });
        option2.selected = true;
        domDispatch.call(select, 'change');
        equal(domAttr.get(option1, 'selected'), false, 'option1 is not selected');
        equal(domAttr.get(option2, 'selected'), true, 'option2 is selected');
    });
    test('get, set, and addEventListener on values', function () {
        var select = document.createElement('select');
        select.multiple = true;
        var option1 = document.createElement('option');
        option1.value = 'one';
        var option2 = document.createElement('option');
        option2.value = 'two';
        select.appendChild(option1);
        select.appendChild(option2);
        var valuesCount = 0;
        domEvents.addEventListener.call(select, 'values', function () {
            valuesCount++;
        });
        deepEqual(domAttr.get(select, 'values'), [], 'None selected to start');
        option1.selected = true;
        domDispatch.call(select, 'change');
        equal(valuesCount, 1, 'values event');
        deepEqual(domAttr.get(select, 'values'), ['one'], 'First option is in values');
        option2.selected = true;
        domDispatch.call(select, 'change');
        equal(valuesCount, 2, 'values event');
        deepEqual(domAttr.get(select, 'values'), [
            'one',
            'two'
        ], 'both selected');
        option1.selected = option2.selected = false;
        domDispatch.call(select, 'change');
        equal(valuesCount, 3, 'values event');
        deepEqual(domAttr.get(select, 'values'), [], 'none selected');
        domAttr.set(select, 'values', ['two']);
        equal(option1.selected, false, 'option1 not selected');
        equal(option2.selected, true, 'option2 selected');
        deepEqual(domAttr.get(select, 'values'), ['two'], 'two is only selected');
    });
    test('get, set, and addEventListener on innerHTML', function () {
        var div = document.createElement('div');
        div.appendChild(document.createElement('span'));
        var count = 0;
        domEvents.addEventListener.call(div, 'innerHTML', function () {
            count++;
        });
        equal(domAttr.get(div, 'innerHTML'), '<span></span>', 'got innerhtml');
        domAttr.set(div, 'innerHTML', '<p>hello</p>');
        domDispatch.call(div, 'change');
        equal(count, 1, 'innerHTML event');
        equal(domAttr.get(div, 'innerHTML'), '<p>hello</p>', 'got innerhtml');
    });
    test('get, set on \'value\'', function () {
        var input = document.createElement('input');
        input.value = 'foo';
        equal(domAttr.get(input, 'value'), 'foo', 'got the value');
        domAttr.set(input, 'value', 'bar');
        equal(domAttr.get(input, 'value'), 'bar', 'got the value');
        input.value = '';
        equal(domAttr.get(input, 'value'), '', 'value is an empty string');
    });
    test('get/sets the checkedness of a checkbox', function () {
        var input = document.createElement('input');
        input.type = 'checkbox';
        equal(domAttr.get(input, 'checked'), false, 'not checked');
        domAttr.set(input, 'checked', true);
        equal(domAttr.get(input, 'checked'), true, 'now it is true');
        domAttr.set(input, 'checked', false);
        equal(domAttr.get(input, 'checked'), false, 'now it is false');
        domAttr.set(input, 'checked');
        equal(domAttr.get(input, 'checked'), true, 'now it is true');
        domAttr.set(input, 'checked', 0);
        equal(domAttr.get(input, 'checked'), false, 'now it is false');
        domAttr.set(input, 'checked', '');
        equal(domAttr.get(input, 'checked'), true, 'now it is true');
    });
    test('For inputs checked is set as an attribute', function () {
        var input = document.createElement('input');
        input.type = 'checkbox';
        domAttr.set(input, 'checked', '');
        equal(input.checked, true, 'checked is true');
        equal(input.getAttribute('checked'), undefined, 'no checked attr');
        var customEl = document.createElement('custom-element');
        domAttr.set(customEl, 'checked', '');
        ok(customEl.hasAttribute('checked'), 'has checked attr');
        equal(customEl.getAttribute('checked'), '', 'attr is an empty string');
        equal(domAttr.get(customEl, 'checked'), '', 'attr from get');
    });
    test('attr.special.value, fallback to the attribute', function () {
        var customEl = document.createElement('custom-element');
        customEl.setAttribute('value', 'foo');
        equal(domAttr.get(customEl, 'value'), 'foo', 'value is foo');
    });
    test('Setting a select\'s value updates child\'s selectedness', function () {
        var select = document.createElement('select');
        var option1 = document.createElement('option');
        option1.value = 'one';
        option1.selected = true;
        var option2 = document.createElement('option');
        option2.value = 'two';
        select.appendChild(option1);
        select.appendChild(option2);
        equal(domAttr.get(select, 'value'), 'one', 'initial value');
        domAttr.set(select, 'value', 'two');
        equal(option1.selected, false, 'not selected');
        equal(option2.selected, true, 'now it is selected');
    });
    test('Removing an option causes the select\'s value to be re-evaluated', function () {
        var select = document.createElement('select');
        var option1 = document.createElement('option');
        option1.value = 'one';
        var option2 = document.createElement('option');
        option2.value = 'two';
        select.appendChild(option1);
        select.appendChild(option2);
        domAttr.set(select, 'value', 'one');
        equal(option1.selected, true, 'selected');
        equal(domAttr.get(select, 'value'), 'one', 'got the value');
        domEvents.addEventListener.call(select, 'change', function () {
            equal(domAttr.get(select, 'value'), undefined, 'no value now');
            start();
        });
        stop();
        select.removeChild(option1);
        if (!MUTATION_OBSERVER()) {
            var data = domData.get.call(select, 'canBindingCallback');
            data.onMutation();
        }
    });
    test('Multiselect values is updated on any children added/removed', function () {
        var select = document.createElement('select');
        select.multiple = true;
        var option1 = document.createElement('option');
        option1.value = 'one';
        var option2 = document.createElement('option');
        option2.value = 'two';
        var option3 = document.createElement('option');
        option3.value = 'three';
        option3.selected = true;
        select.appendChild(option1);
        select.appendChild(option2);
        select.appendChild(option3);
        domAttr.set(select, 'values', [
            'one',
            'three'
        ]);
        deepEqual(domAttr.get(select, 'values'), [
            'one',
            'three'
        ], 'initial value is right');
        domEvents.addEventListener.call(select, 'values', function () {
            deepEqual(domAttr.get(select, 'values'), ['three'], 'new val is right');
            start();
        });
        stop();
        select.removeChild(option1);
        if (!MUTATION_OBSERVER()) {
            var data = domData.get.call(select, 'canBindingCallback');
            data.onMutation();
        }
    });
    test('Select options within optgroups should be set via `value` properly', function () {
        function tag(tag, value) {
            var el = document.createElement(tag);
            if (value) {
                el.value = value;
            }
            return el;
        }
        var select = tag('select');
        var optgroup1 = tag('optgroup');
        var option11 = tag('option', 'list1-item1');
        option11.selected = true;
        var option12 = tag('option', 'list1-item2');
        var optgroup2 = tag('optgroup');
        var option21 = tag('option', 'list2-item1');
        var option22 = tag('option', 'list2-item2');
        select.appendChild(optgroup1);
        select.appendChild(optgroup2);
        optgroup1.appendChild(option11);
        optgroup1.appendChild(option12);
        optgroup2.appendChild(option21);
        optgroup2.appendChild(option22);
        equal(domAttr.get(select, 'value'), 'list1-item1', 'initial value');
        domAttr.set(select, 'value', 'list2-item2');
        equal(domAttr.get(select, 'value'), 'list2-item2', 'updated value');
        equal(option11.selected, false, 'initial option is not selected');
        equal(option22.selected, true, 'second option is selected');
    });
    test('Select options within optgroups should be set via `values` properly', function () {
        function tag(tag, value) {
            var el = document.createElement(tag);
            if (value) {
                el.value = value;
            }
            return el;
        }
        var select = tag('select');
        select.multiple = true;
        var optgroup1 = tag('optgroup');
        var option11 = tag('option', 'list1-item1');
        option11.selected = true;
        var option12 = tag('option', 'list1-item2');
        var optgroup2 = tag('optgroup');
        var option21 = tag('option', 'list2-item1');
        var option22 = tag('option', 'list2-item2');
        select.appendChild(optgroup1);
        select.appendChild(optgroup2);
        optgroup1.appendChild(option11);
        optgroup1.appendChild(option12);
        optgroup2.appendChild(option21);
        optgroup2.appendChild(option22);
        deepEqual(domAttr.get(select, 'values'), ['list1-item1'], 'initial value');
        domAttr.set(select, 'values', [
            'list1-item2',
            'list2-item2'
        ]);
        deepEqual(domAttr.get(select, 'values'), [
            'list1-item2',
            'list2-item2'
        ], 'updated value');
        equal(option11.selected, false, 'initial option is not selected');
        equal(option12.selected, true, 'second option is selected');
        equal(option22.selected, true, 'third option is selected');
    });
    test('Setting a value that will be appended later', function () {
        var select = document.createElement('select');
        var option1 = document.createElement('option');
        option1.value = 'one';
        domAttr.set(select, 'value', 'two');
        var option2 = document.createElement('option');
        option2.value = 'two';
        domEvents.addEventListener.call(select, 'change', function () {
            equal(domAttr.get(select, 'value'), 'two', 'option2 is selected');
            start();
        });
        stop();
        select.appendChild(option2);
        if (!MUTATION_OBSERVER()) {
            var data = domData.get.call(select, 'canBindingCallback');
            data.onMutation();
        }
    });
    test('Calling remove on checked sets it to false', function () {
        var input = document.createElement('input');
        input.type = 'checkbox';
        domAttr.set(input, 'checked');
        equal(input.checked, true, 'it is checked');
        domAttr.remove(input, 'checked');
        equal(input.checked, false, 'not checked');
    });
    test('Boolean attrs that don\'t support a prop sets the attribute', function () {
        var div = document.createElement('div');
        domAttr.set(div, 'disabled');
        equal(domAttr.get(div, 'disabled'), '', 'empty string');
    });
    test('Setting a non-string value on a select correctly selects the child', function () {
        var select = document.createElement('select');
        var option1 = document.createElement('option');
        option1.value = '1';
        var option2 = document.createElement('option');
        option2.value = '2';
        select.appendChild(option1);
        select.appendChild(option2);
        domAttr.set(select, 'value', 2);
        equal(option2.selected, true, 'second one is selected');
    });
    test('Setting null doesn\'t select the default value on a select', function () {
        var select = document.createElement('select');
        var option1 = document.createElement('option');
        option1.value = '';
        var option2 = document.createElement('option');
        option2.value = 'two';
        select.appendChild(option1);
        select.appendChild(option2);
        domAttr.set(select, 'value', null);
        equal(option1.selected, false, 'option1 not selected');
        equal(option2.selected, false, 'option2 not selected');
        equal(select.selectedIndex, -1, 'no selected index, wha-wha');
    });
    test('setting .value on an input to undefined or null makes value empty (#83)', function () {
        var input = document.createElement('input');
        input.value = 'something';
        domAttr.set(input, 'value', null);
        QUnit.equal(input.value, '', 'null');
        domAttr.set(input, 'value', undefined);
        QUnit.equal(input.value, '', 'undefined');
    });
    test('attr.special.focused calls after previous events', function () {
        var oldQueue = types.queueTask;
        types.queueTask = function (task) {
            setTimeout(function () {
                task[0].apply(task[1], task[2]);
            }, 5);
        };
        var input = document.createElement('input');
        input.type = 'text';
        var ta = document.getElementById('qunit-fixture');
        ta.appendChild(input);
        stop();
        domAttr.set(input, 'focused', true);
        setTimeout(function () {
            equal(domAttr.get(input, 'focused'), true, 'it is now focused');
            types.queueTask = oldQueue;
            start();
        }, 10);
        equal(domAttr.get(input, 'focused'), false, 'not focused yet');
    });
    test('attr.special.focused binds on inserted if element is detached', 2, function () {
        var input = document.createElement('input');
        input.type = 'text';
        var ta = document.getElementById('qunit-fixture');
        stop();
        domAttr.set(input, 'focused', true);
        equal(domAttr.get(input, 'focused'), false, 'not focused yet');
        domEvents.addEventListener.call(input, 'inserted', function () {
            equal(domAttr.get(input, 'focused'), true, 'it is now focused');
            start();
        });
        mutate.appendChild.call(ta, input);
    });
    test('handles removing multiple event handlers', function () {
        var handler1 = function () {
        };
        var handler2 = function () {
        };
        var div = document.createElement('div');
        domEvents.addEventListener.call(div, 'attributes', handler1, false);
        domEvents.addEventListener.call(div, 'attributes', handler2, false);
        domEvents.removeEventListener.call(div, 'attributes', handler1);
        domEvents.removeEventListener.call(div, 'attributes', handler2);
        ok(true, 'should not throw');
    });
    test('handles removing multiple event handlers without MUTATION_OBSERVER', function () {
        var MO = MUTATION_OBSERVER();
        MUTATION_OBSERVER(null);
        var handler1 = function () {
        };
        var handler2 = function () {
        };
        var div = document.createElement('div');
        domEvents.addEventListener.call(div, 'attributes', handler1, false);
        domEvents.addEventListener.call(div, 'attributes', handler2, false);
        domEvents.removeEventListener.call(div, 'attributes', handler1);
        domEvents.removeEventListener.call(div, 'attributes', handler2);
        ok(true, 'should not throw');
        MUTATION_OBSERVER(MO);
    });
    if (window.eventsBubble) {
        test('get, set, and addEventListener on focused', function () {
            var input = document.createElement('input');
            var ta = document.getElementById('qunit-fixture');
            var test;
            var focusedCount = 0;
            ta.appendChild(input);
            var tests = [
                {
                    action: function () {
                        equal(domAttr.get(input, 'focused'), false, 'get not focused');
                        domAttr.set(input, 'focused', true);
                        if (!document.hasFocus()) {
                            domDispatch.call(input, 'focus');
                        }
                    },
                    test: function () {
                        equal(focusedCount, 1, 'focused event');
                        equal(domAttr.get(input, 'focused'), true, 'get focused');
                    }
                },
                {
                    action: function () {
                        domAttr.set(input, 'focused', false);
                        if (!document.hasFocus()) {
                            domDispatch.call(input, 'blur');
                        }
                    },
                    test: function () {
                        equal(focusedCount, 2, 'focused event');
                        equal(domAttr.get(input, 'focused'), false, 'get not focused after blur');
                    }
                }
            ];
            function next() {
                test = tests.shift();
                if (!test) {
                    start();
                    return;
                }
                test.action();
            }
            ok(domAttr.special.focused.addEventListener, 'addEventListener implemented');
            domEvents.addEventListener.call(input, 'focused', function () {
                focusedCount++;
                test.test();
                setTimeout(next, 50);
            });
            stop();
            next();
        });
    }
    test('Binding to selected updates the selectedness of options', function () {
        expect(3);
        var select = document.createElement('select');
        var option1 = document.createElement('option');
        option1.selected = false;
        option1.value = 'one';
        select.appendChild(option1);
        var option2 = document.createElement('option');
        option2.value = 'two';
        select.appendChild(option2);
        domEvents.addEventListener.call(option1, 'selected', function () {
            ok(true, 'this was called');
        });
        domAttr.set(option1, 'selected', true);
        option2.selected = true;
        domDispatch.call(select, 'change');
        equal(option2.selected, true);
        equal(option1.selected, false);
    });
    test('Select\'s value is preserved when inserted into the document', function () {
        stop();
        var select = document.createElement('select');
        var option1 = document.createElement('option');
        option1.value = 'one';
        select.appendChild(option1);
        domAttr.set(select, 'value', null);
        equal(select.selectedIndex, -1, 'was set to -1');
        var ta = document.getElementById('qunit-fixture');
        mutate.appendChild.call(ta, select);
        setTimeout(function () {
            equal(select.selectedIndex, -1, 'still is -1');
            start();
        }, 50);
    });
    test('multi-select does not dispatch a values change event if its selected options are unchanged (#105)', function () {
        var div = document.createElement('div');
        div.innerHTML = '<select multiple><option selected>2</option><option selected>1</option><option>3</option></select>';
        var select = div.firstChild;
        document.body.appendChild(div);
        var valuesChanges = 0;
        domEvents.addEventListener.call(select, 'values', function () {
            valuesChanges++;
        });
        domAttr.set(select, 'values', [
            '1',
            '2'
        ]);
        select.innerHTML = '<option selected>1</option><option selected>2</option><option>3</option>';
        QUnit.stop();
        setTimeout(function () {
            QUnit.strictEqual(valuesChanges, 0, 'we do not dispatch a change event');
            document.body.removeChild(div);
            QUnit.start();
        }, 50);
    });
    test('setting checked to undefined should result in false for checkboxes (#184)', function () {
        var input = document.createElement('input');
        input.type = 'checkbox';
        domAttr.set(input, 'checked', undefined);
        QUnit.equal(input.checked, false, 'Should set checked to false');
        domAttr.set(input, 'checked', true);
        QUnit.equal(input.checked, true, 'Should become true');
        domAttr.set(input, 'checked', undefined);
        QUnit.equal(input.checked, false, 'Should become false again');
    });
});
/*can-util@3.9.6#dom/data/data-test*/
define('can-util@3.9.6#dom/data/data-test', function (require, exports, module) {
    'use strict';
    var domData = require('./data');
    var domDataCore = require('./core');
    var diff = require('../../js/diff-object/diff-object');
    var assign = require('../../js/assign/assign');
    var getDocument = require('../document/document');
    var mutate = require('../mutate/mutate');
    var QUnit = require('steal-qunit');
    var document = getDocument();
    QUnit.module('can-util/dom/data', {
        beforeEach: function () {
            this.fixture = document.getElementById('qunit-fixture');
        },
        afterEach: function () {
            this.fixture = null;
        }
    });
    test('domData should be cleaned up if element is removed from DOM', function (assert) {
        var done = assert.async();
        var origData = assign({}, domDataCore._data);
        var div = document.createElement('div');
        mutate.appendChild.call(this.fixture, div);
        domData.set.call(div, 'div-data', { abc: 'def' });
        var newData = assign({}, domDataCore._data);
        QUnit.ok(diff(origData, newData).length > 0, 'items added to domData._data for div');
        mutate.removeChild.call(this.fixture, div);
        var maxTime = Date.now() + 1.5 * 60 * 1000;
        var checkResetChanges = function () {
            var newData = assign({}, domDataCore._data);
            if (diff(origData, newData).length === 0) {
                QUnit.ok(true, 'domData._data returned to initial state');
                done();
            } else {
                if (Date.now() > maxTime) {
                    QUnit.ok(false, 'domData._data not returned to initial state');
                    done();
                } else {
                    setTimeout(checkResetChanges, 10);
                }
            }
        };
        checkResetChanges();
    });
    test('domData should be cleaned up if multiple elements are removed from DOM', function (assert) {
        var done = assert.async();
        var origData = assign({}, domDataCore._data);
        var div = document.createElement('div');
        mutate.appendChild.call(this.fixture, div);
        domData.set.call(div, 'div-data', { abc: 'def' });
        var newData = assign({}, domDataCore._data);
        QUnit.ok(diff(origData, newData).length > 0, 'items added to domData._data for div');
        var p = document.createElement('p');
        mutate.appendChild.call(this.fixture, p);
        domData.set.call(p, 'p-data', { ghi: 'jkl' });
        newData = assign({}, domDataCore._data);
        QUnit.ok(diff(origData, newData).length > 0, 'items added to domData._data for p');
        mutate.removeChild.call(this.fixture, div);
        mutate.removeChild.call(this.fixture, p);
        setTimeout(function () {
            QUnit.deepEqual(domDataCore._data, origData, 'domData._data returned to initial state');
            done();
        }, 10);
    });
    test('domData should be cleaned up if element is removed from DOM after calling setData for two different keys', function (assert) {
        var done = assert.async();
        var origData = assign({}, domDataCore._data);
        var div = document.createElement('div');
        mutate.appendChild.call(this.fixture, div);
        domData.set.call(div, 'div-data', { abc: 'def' });
        domData.set.call(div, 'div-other-data', { ghi: 'jkl' });
        var newData = assign({}, domDataCore._data);
        QUnit.ok(diff(origData, newData).length > 0, 'items added to domData._data for div');
        mutate.removeChild.call(this.fixture, div);
        setTimeout(function () {
            QUnit.deepEqual(domDataCore._data, origData, 'domData._data returned to initial state');
            done();
        }, 10);
    });
    test('domData should be cleaned up if element is removed from DOM after calling setData twice for the same key', function (assert) {
        var done = assert.async();
        var origData = assign({}, domDataCore._data);
        var div = document.createElement('div');
        mutate.appendChild.call(this.fixture, div);
        domData.set.call(div, 'div-data', { abc: 'def' });
        domData.set.call(div, 'div-data', { ghi: 'jkl' });
        var newData = assign({}, domDataCore._data);
        QUnit.ok(diff(origData, newData).length > 0, 'items added to domData._data for div');
        mutate.removeChild.call(this.fixture, div);
        setTimeout(function () {
            QUnit.deepEqual(domDataCore._data, origData, 'domData._data returned to initial state');
            done();
        }, 10);
    });
});
/*can-util@3.9.6#dom/dispatch/dispatch-test*/
define('can-util@3.9.6#dom/dispatch/dispatch-test', function (require, exports, module) {
    'use strict';
    var domDispatch = require('can-util/dom/dispatch/');
    var domEvents = require('can-util/dom/events/');
    QUnit = require('steal-qunit');
    QUnit.module('can-util/dom/dispatch');
    test('basic synthetic events', function () {
        var div = document.createElement('div');
        domEvents.addEventListener.call(div, 'foo', function () {
            ok(true, 'called back');
        });
        domDispatch.call(div, 'foo');
    });
    test('more complex synthetic events', function () {
        var div = document.createElement('div');
        var arr = [];
        domEvents.addEventListener.call(div, 'attributes', function (ev) {
            ok(true, 'called back');
            equal(ev.something, arr, 'got data');
        });
        domDispatch.call(div, {
            type: 'attributes',
            something: arr
        }, ['a']);
    });
});
/*can-util@3.9.6#dom/events/delegate/delegate-test*/
define('can-util@3.9.6#dom/events/delegate/delegate-test', function (require, exports, module) {
    'use strict';
    require('can-util/dom/events/inserted/');
    var domEvents = require('can-util/dom/events/');
    var domDispatch = require('can-util/dom/dispatch/');
    var domData = require('can-util/dom/data/');
    require('can-util/dom/events/delegate/');
    require('can-util/dom/events/delegate/enter-leave');
    var buildFrag = require('can-util/dom/fragment/');
    QUnit = require('steal-qunit');
    QUnit.module('can-util/dom/events/delegate');
    test('basics', 2, function () {
        stop();
        var frag = buildFrag('<ul><li><span/></li><li></li></ul>');
        var ul = frag.firstChild;
        document.getElementById('qunit-fixture').appendChild(ul);
        var handler = function (ev) {
            ok(true, 'called');
            domEvents.removeDelegateListener.call(ul, 'click', 'li', handler);
            var dE = domData.get.call(this, 'delegateEvents');
            equal(dE, undefined, 'data removed');
            domEvents.addDelegateListener.call(ul, 'click', 'li', handler);
            start();
        };
        domEvents.addDelegateListener.call(ul, 'click', 'li', handler);
        domDispatch.call(ul.firstChild.firstChild, 'click');
    });
    test('focus', 2, function () {
        stop();
        var frag = buildFrag('<div><input type=\'text\'></div>');
        var div = frag.firstChild;
        document.getElementById('qunit-fixture').appendChild(div);
        var handler = function (ev) {
            ok(true, 'called');
            domEvents.removeDelegateListener.call(div, 'focus', 'input', handler);
            var dE = domData.get.call(this, 'delegateEvents');
            equal(dE, undefined, 'data removed');
            start();
        };
        domEvents.addDelegateListener.call(div, 'focus', 'input', handler);
        domDispatch.call(div.firstChild, 'focus', [], false);
    });
    test('blur', 2, function () {
        stop();
        var frag = buildFrag('<div><input type=\'text\'></div>');
        var div = frag.firstChild;
        document.getElementById('qunit-fixture').appendChild(div);
        var handler = function (ev) {
            ok(true, 'called');
            domEvents.removeDelegateListener.call(div, 'blur', 'input', handler);
            var dE = domData.get.call(this, 'delegateEvents');
            equal(dE, undefined, 'data removed');
            start();
        };
        domEvents.addDelegateListener.call(div, 'blur', 'input', handler);
        domDispatch.call(div.firstChild, 'blur', [], false);
    });
    test('mouseenter', 3, function () {
        stop();
        var frag = buildFrag('<div><button></button></div>'), div = frag.firstChild;
        document.getElementById('qunit-fixture').appendChild(div);
        var handler = function (ev) {
            ok(true, 'called');
            equal(ev.type, 'mouseenter', 'event in handler has delegated event type');
            domEvents.removeDelegateListener.call(div, 'mouseenter', 'button', handler);
            var dE = domData.get.call(this, 'delegateEvents');
            equal(dE, undefined, 'data removed');
            start();
        };
        domEvents.addDelegateListener.call(div, 'mouseenter', 'button', handler);
        domDispatch.call(div.firstChild, {
            type: 'mouseover',
            view: window,
            relatedTarget: div
        }, [], true);
    });
});
/*can-util@3.9.6#dom/events/inserted/inserted-test*/
define('can-util@3.9.6#dom/events/inserted/inserted-test', function (require, exports, module) {
    'use strict';
    require('can-util/dom/events/inserted/');
    var domEvents = require('can-util/dom/events/');
    var MUTATION_OBSERVER = require('can-util/dom/mutation-observer/');
    var domMutate = require('can-util/dom/mutate/');
    var dev = require('can-util/js/dev/dev');
    QUnit = require('steal-qunit');
    function runTest(name, MUT_OBS) {
        var oldMutObs;
        QUnit.module(name, {
            setup: function () {
                oldMutObs = MUTATION_OBSERVER();
                MUTATION_OBSERVER(MUT_OBS);
            },
            teardown: function () {
                MUTATION_OBSERVER(oldMutObs);
            }
        });
        asyncTest('basic insertion', function () {
            var div = document.createElement('div');
            domEvents.addEventListener.call(div, 'inserted', function () {
                ok(true, 'called back');
                start();
            });
            domMutate.appendChild.call(document.getElementById('qunit-fixture'), div);
        });
        if (System.env.indexOf('production') < 0) {
            asyncTest('basic disabled insertion', function () {
                var oldlog = dev.warn;
                var message = 'can-util/dom/events::dispatch';
                var thisTest = QUnit.config.current;
                dev.warn = function (text) {
                    if (QUnit.config.current === thisTest) {
                        equal(text.slice(0, message.length), message, 'Got expected warning.');
                        start();
                        dev.warn = oldlog;
                    }
                };
                expect(1);
                var input = document.createElement('input');
                input.disabled = true;
                domEvents.addEventListener.call(input, 'inserted', function () {
                });
                domMutate.appendChild.call(document.getElementById('qunit-fixture'), input);
            });
        }
        asyncTest('parent then child inserted - appendChild', function () {
            expect(1);
            var div = document.createElement('div');
            var span = document.createElement('span');
            domEvents.addEventListener.call(span, 'inserted', function () {
                ok(true, 'called back');
                start();
            });
            domMutate.appendChild.call(document.getElementById('qunit-fixture'), div);
            domMutate.appendChild.call(div, span);
        });
        asyncTest('parent then child inserted in callback - appendChild', function () {
            expect(1);
            var div = document.createElement('div');
            var span = document.createElement('span');
            domEvents.addEventListener.call(div, 'inserted', function () {
                domMutate.appendChild.call(div, span);
            });
            domEvents.addEventListener.call(span, 'inserted', function () {
                ok(true, 'called back');
                start();
            });
            domMutate.appendChild.call(document.getElementById('qunit-fixture'), div);
        });
    }
    runTest('can-util/dom/events/inserted - MutationObserver', MUTATION_OBSERVER());
    runTest('can-util/dom/events/inserted - no MutationObserver', null);
});
/*can-util@3.9.6#dom/events/removed/removed-test*/
define('can-util@3.9.6#dom/events/removed/removed-test', function (require, exports, module) {
    'use strict';
    require('can-util/dom/events/removed/');
    var each = require('can-util/js/each/');
    var domEvents = require('can-util/dom/events/');
    var getMutationObserver = require('can-util/dom/mutation-observer/');
    var domMutate = require('can-util/dom/mutate/');
    QUnit = require('steal-qunit');
    var events = [];
    var addEvent = function (el, event, handler) {
        domEvents.addEventListener.call(el, event, handler);
        events.push({
            el: el,
            event: event,
            handler: handler
        });
    };
    var removeEvents = function () {
        if (events.length) {
            each(events, function (ev) {
                domEvents.removeEventListener.call(ev.el, ev.event, ev.handler);
            });
        }
        events = [];
    };
    QUnit.module('can-util/dom/events/removed', { teardown: removeEvents });
    var _MutationObserver = getMutationObserver();
    if (_MutationObserver) {
        asyncTest('with mutation observer - basic removal - removeChild', function () {
            var div = document.createElement('div');
            domEvents.addEventListener.call(div, 'removed', function () {
                ok(true, 'called back');
                start();
            });
            document.getElementById('qunit-fixture').appendChild(div);
            document.getElementById('qunit-fixture').removeChild(div);
        });
        asyncTest('with mutation observer - disabled removal - removeChild', function () {
            var input = document.createElement('removed');
            input.disabled = true;
            domEvents.addEventListener.call(input, 'removed', function () {
                ok(true, 'called back');
                start();
            });
            document.getElementById('qunit-fixture').appendChild(input);
            document.getElementById('qunit-fixture').removeChild(input);
        });
        asyncTest('with mutation observer - basic removal - replaceChild', function () {
            var div = document.createElement('div');
            var div2 = document.createElement('div');
            domEvents.addEventListener.call(div, 'removed', function () {
                ok(true, 'called back');
                start();
            });
            document.getElementById('qunit-fixture').appendChild(div);
            document.getElementById('qunit-fixture').replaceChild(div2, div);
        });
        asyncTest('with mutation observer - nested removal - removeChild', function () {
            var div = document.createElement('div');
            var span = document.createElement('span');
            div.appendChild(span);
            domEvents.addEventListener.call(span, 'removed', function () {
                ok(true, 'called back');
                start();
            });
            document.getElementById('qunit-fixture').appendChild(div);
            document.getElementById('qunit-fixture').removeChild(div);
        });
        asyncTest('with mutation observer - move', function () {
            expect(0);
            var div = document.createElement('div');
            var span = document.createElement('span');
            var p = document.createElement('p');
            div.appendChild(span);
            div.appendChild(p);
            domMutate.appendChild.call(document.getElementById('qunit-fixture'), div);
            addEvent(p, 'removed', function () {
                ok(false, 'called removed');
            });
            div.insertBefore(p, span);
            start();
        });
        asyncTest('with mutation observer - move and remove (#146)', function () {
            var fixture = document.getElementById('qunit-fixture');
            var div = document.createElement('div');
            var span = document.createElement('span');
            var p = document.createElement('p');
            div.appendChild(span);
            div.appendChild(p);
            domMutate.appendChild.call(fixture, div);
            var div2 = document.createElement('div');
            domMutate.appendChild.call(fixture, div2);
            addEvent(p, 'removed', function () {
                ok(false, 'called removed');
            });
            addEvent(div2, 'removed', function () {
                ok(true, 'div removed');
                start();
            });
            div.insertBefore(p, span);
            domMutate.removeChild.call(fixture, div2);
        });
        asyncTest('with mutation observer - remaining event handlers fire after one is removed (#236)', function () {
            var div = document.createElement('div');
            domEvents.addEventListener.call(div, 'removed', function () {
                ok(true, 'called back');
                start();
            });
            function removeTwo() {
            }
            domEvents.addEventListener.call(div, 'removed', removeTwo);
            domEvents.removeEventListener.call(div, 'removed', removeTwo);
            document.getElementById('qunit-fixture').appendChild(div);
            document.getElementById('qunit-fixture').removeChild(div);
        });
    }
    asyncTest('basic removal without mutation observer - removeChild', function () {
        getMutationObserver(null);
        var div = document.createElement('div');
        domEvents.addEventListener.call(div, 'removed', function () {
            ok(true, 'called back');
            getMutationObserver(_MutationObserver);
            start();
        });
        domMutate.appendChild.call(document.getElementById('qunit-fixture'), div);
        domMutate.removeChild.call(document.getElementById('qunit-fixture'), div);
    });
    asyncTest('disabled removal without mutation observer - removeChild', function () {
        getMutationObserver(null);
        var input = document.createElement('input');
        input.disabled = true;
        domEvents.addEventListener.call(input, 'removed', function () {
            ok(true, 'called back');
            getMutationObserver(_MutationObserver);
            start();
        });
        domMutate.appendChild.call(document.getElementById('qunit-fixture'), input);
        domMutate.removeChild.call(document.getElementById('qunit-fixture'), input);
    });
    asyncTest('basic insertion without mutation observer - replaceChild', function () {
        getMutationObserver(null);
        var div = document.createElement('div');
        var div2 = document.createElement('div');
        domEvents.addEventListener.call(div, 'removed', function () {
            ok(true, 'called back');
            getMutationObserver(_MutationObserver);
            start();
        });
        domMutate.appendChild.call(document.getElementById('qunit-fixture'), div);
        domMutate.replaceChild.call(document.getElementById('qunit-fixture'), div2, div);
    });
});
/*can-util@3.9.6#dom/mutate/mutate-test*/
define('can-util@3.9.6#dom/mutate/mutate-test', function (require, exports, module) {
    'use strict';
    var mutate = require('./mutate');
    var MUTATION_OBSERVER = require('../mutation-observer/mutation-observer');
    var DOCUMENT = require('../document/document');
    var makeDocument = require('can-vdom/make-document/make-document');
    QUnit = require('steal-qunit');
    QUnit.module('can-util/dom/mutate');
    function disableMO() {
        var old = MUTATION_OBSERVER();
        MUTATION_OBSERVER(null);
        return function () {
            MUTATION_OBSERVER(old);
        };
    }
    test('inserting empty frag', function () {
        var enableMO = disableMO();
        var frag = document.createDocumentFragment();
        mutate.appendChild.call(document.getElementById('qunit-fixture'), frag);
        var div = document.createElement('div');
        div.addEventListener('inserted', function () {
            ok(true, 'called');
        });
        mutate.appendChild.call(document.getElementById('qunit-fixture'), div);
        stop();
        setTimeout(function () {
            enableMO();
            start();
        }, 10);
    });
    test('removing the body causes removed events', function () {
        var enableMO = disableMO();
        var oldDoc = DOCUMENT();
        var doc = makeDocument();
        DOCUMENT(doc);
        var div = doc.createElement('div');
        mutate.appendChild.call(doc.body, div);
        div.addEventListener('removed', function () {
            ok(true, 'called');
        });
        mutate.removeChild.call(doc.documentElement, doc.body);
        stop();
        setTimeout(function () {
            enableMO();
            DOCUMENT(oldDoc);
            start();
        }, 10);
    });
    if (window.eventsBubble) {
        test('inserting into a different document fires inserted', function () {
            var enableMO = disableMO();
            var doc = document.implementation.createHTMLDocument('Demo');
            var oldDoc = DOCUMENT();
            DOCUMENT(doc);
            var div = document.createElement('div');
            div.addEventListener('inserted', function () {
                ok(true, 'called');
            });
            mutate.appendChild.call(doc.body, div);
            stop();
            setTimeout(function () {
                enableMO();
                DOCUMENT(oldDoc);
                start();
            }, 10);
        });
    }
});
/*can-util@3.9.6#dom/matches/matches-test*/
define('can-util@3.9.6#dom/matches/matches-test', function (require, exports, module) {
    'use strict';
    var matches = require('./matches');
    QUnit = require('steal-qunit');
    QUnit.module('can-util/dom/matches');
    QUnit.test('basics', function () {
        var a = document.createElement('a');
        a.id = 'foo';
        document.getElementById('qunit-fixture').appendChild(a);
        QUnit.ok(matches.call(a, '#foo'), 'matches selector');
    });
    QUnit.test('returns false for document', function () {
        var res = matches.call(document, 'a');
        QUnit.equal(res, false, 'document never matches');
    });
});
/*can-util@3.9.6#dom/location/location*/
define('can-util@3.9.6#dom/location/location', function (require, exports, module) {
    (function (global) {
        'use strict';
        var global = require('../../js/global/global');
        var setLocation;
        module.exports = function (setLoc) {
            if (setLoc) {
                setLocation = setLoc;
            }
            return setLocation || global().location;
        };
    }(function () {
        return this;
    }()));
});
/*can-util@3.9.6#dom/location/location-test*/
define('can-util@3.9.6#dom/location/location-test', function (require, exports, module) {
    'use strict';
    var LOCATION = require('./location');
    QUnit = require('steal-qunit');
    QUnit.module('can-util/dom/location/location');
    QUnit.test('Can set a location', function () {
        var myLoc = {};
        var oldLoc = LOCATION();
        LOCATION(myLoc);
        QUnit.equal(LOCATION(), myLoc, 'It was set');
        LOCATION(oldLoc);
    });
});
/*can-util@3.9.6#dom/tests*/
define('can-util@3.9.6#dom/tests', function (require, exports, module) {
    'use strict';
    require('./ajax/ajax-test');
    require('./attr/attr-test');
    require('./data/data-test');
    require('./dispatch/dispatch-test');
    require('./events/delegate/delegate-test');
    require('./events/inserted/inserted-test');
    require('./events/removed/removed-test');
    require('./mutate/mutate-test');
    require('./matches/matches-test');
    require('./location/location-test');
});
/*can-util@3.9.6#test/test*/
define('can-util@3.9.6#test/test', function (require, exports, module) {
    require('../js/tests.js');
    require('../dom/tests.js');
    var domDispatch = require('can-util/dom/dispatch/');
    var buildFrag = require('can-util/dom/fragment/');
    window.eventsBubble = function () {
        var frag = buildFrag('<div><span></span></div>');
        var bubbles = false;
        frag.firstChild.addEventListener('click', function () {
            bubbles = true;
        });
        domDispatch.call(frag.firstChild.firstChild, 'click');
        return bubbles;
    }();
});
/*can@3.9.0-pre.0#util/util_test*/
define('can@3.9.0-pre.0#util/util_test', function (require, exports, module) {
    require('can-util/test/test');
});
/*can-view-import@3.1.0#can-view-import*/
define('can-view-import@3.1.0#can-view-import', function (require, exports, module) {
    var assign = require('can-util/js/assign/assign');
    var canData = require('can-util/dom/data/data');
    var DOCUMENT = require('can-util/dom/document/document');
    var getChildNodes = require('can-util/dom/child-nodes/child-nodes');
    var importer = require('can-util/js/import/import');
    var mutate = require('can-util/dom/mutate/mutate');
    var nodeLists = require('can-view-nodelist');
    var tag = require('can-view-callbacks').tag;
    var events = require('can-event');
    var canLog = require('can-util/js/log/log');
    tag('can-import', function (el, tagData) {
        var moduleName = el.getAttribute('from');
        var templateModule = tagData.options.get('helpers.module');
        var parentName = templateModule ? templateModule.id : undefined;
        if (!moduleName) {
            return Promise.reject('No module name provided');
        }
        var importPromise = importer(moduleName, parentName);
        importPromise.catch(function (err) {
            canLog.error(err);
        });
        canData.set.call(el, 'viewModel', importPromise);
        canData.set.call(el, 'scope', importPromise);
        var scope = tagData.scope.add(importPromise);
        var handOffTag = el.getAttribute('can-tag');
        if (handOffTag) {
            var callback = tag(handOffTag);
            canData.set.call(el, 'preventDataBindings', true);
            callback(el, assign(tagData, { scope: scope }));
            canData.set.call(el, 'preventDataBindings', false);
            canData.set.call(el, 'viewModel', importPromise);
            canData.set.call(el, 'scope', importPromise);
        } else {
            var frag = tagData.subtemplate ? tagData.subtemplate(scope, tagData.options) : DOCUMENT().createDocumentFragment();
            var nodeList = nodeLists.register([], undefined, tagData.parentNodeList || true);
            nodeList.expression = '<can-import>';
            events.one.call(el, 'removed', function () {
                nodeLists.unregister(nodeList);
            });
            mutate.appendChild.call(el, frag);
            nodeLists.update(nodeList, getChildNodes(el));
        }
    });
});
/*can-view-import@3.1.0#can-view-import_test*/
define('can-view-import@3.1.0#can-view-import_test', function (require, exports, module) {
    var CanMap = require('can-map');
    var Component = require('can-component');
    var stache = require('can-stache');
    var compute = require('can-compute');
    var getIntermediateAndImports = require('can-stache/src/intermediate_and_imports');
    var QUnit = require('steal-qunit');
    var importer = require('can-util/js/import/import');
    var tag = require('can-view-callbacks').tag;
    require('./can-view-import');
    if (window.steal) {
        QUnit.module('can/view/import');
        var test = QUnit.test;
        var equal = QUnit.equal;
        test('static imports are imported', function () {
            var iai = getIntermediateAndImports('<can-import from=\'can-view-import/test/hello\'/>' + '<hello-world></hello-world>');
            equal(iai.imports.length, 1, 'There is one import');
        });
        test('dynamic imports are not imported', function () {
            var iai = getIntermediateAndImports('{{#if a}}<can-import from=\'can-view-import/test/hello\'>' + '<hello-world></hello-world></can-import>{{/if a}}');
            equal(iai.imports.length, 0, 'There are no imports');
        });
        if (!System.isEnv('production')) {
            asyncTest('dynamic imports will only load when in scope', function () {
                expect(4);
                var iai = getIntermediateAndImports('{{#if a}}<can-import from=\'can-view-import/test/hello\'>' + '{{#eq state \'resolved\'}}<hello-world></hello-world>{{/eq}}</can-import>{{/if a}}');
                var template = stache(iai.intermediate);
                var a = compute(false);
                var res = template({ a: a });
                equal(res.childNodes[0].childNodes.length, 0, 'There are no child nodes immediately');
                a(true);
                importer('can-view-import/test/hello').then(function () {
                    equal(res.childNodes[0].childNodes.length, 1, 'There is now a nested component');
                    equal(res.childNodes[0].childNodes[0].tagName.toUpperCase(), 'HELLO-WORLD', 'imported the tag');
                    equal(res.childNodes[0].childNodes[0].childNodes[0].nodeValue, 'Hello world!', 'text inserted');
                    start();
                });
            });
        }
        test('if a can-tag is present, handed over rendering to that tag', function () {
            var iai = getIntermediateAndImports('<can-import from=\'can-view-import/test/hello\' can-tag=\'loading\'/>');
            tag('loading', function (el) {
                var template = stache('it worked');
                el.appendChild(template());
            });
            var template = stache(iai.intermediate);
            var res = template();
            equal(res.childNodes[0].childNodes[0].nodeValue, 'it worked', 'Rendered with the can-tag');
        });
        if (!System.isEnv('production')) {
            asyncTest('can use an import\'s value', function () {
                var template = '<can-import from=\'can-view-import/test/person\' {^value}=\'*person\' />hello {{*person.name}}';
                var iai = getIntermediateAndImports(template);
                var renderer = stache(iai.intermediate);
                var res = renderer(new CanMap());
                importer('can-view-import/test/person').then(function () {
                    equal(res.childNodes[2].nodeValue, 'world', 'Got the person.name from the import');
                    start();
                });
            });
        }
        if (!System.isEnv('production')) {
            asyncTest('can import a template and use it', function () {
                var template = '<can-import from=\'can-view-import/test/other.stache!\' {^@value}=\'*other\' />{{{*other()}}}';
                stache.async(template).then(function (renderer) {
                    var frag = renderer();
                    importer('can-view-import/test/other.stache!').then(function () {
                        equal(frag.childNodes[3].firstChild.nodeValue, 'hi there', 'Partial was renderered right after the can-import');
                        QUnit.start();
                    });
                });
            });
        }
        if (!System.isEnv('production')) {
            asyncTest('can import a template and use it using the > syntax', function () {
                var template = '<can-import from=\'can-view-import/test/other.stache!\' {^@value}=\'*other\' />{{> *other}}';
                stache.async(template).then(function (renderer) {
                    var frag = renderer();
                    importer('can-view-import/test/other.stache!').then(function () {
                        equal(frag.childNodes[3].firstChild.nodeValue, 'hi there', 'Partial was renderered right after the can-import');
                        QUnit.start();
                    });
                });
            });
        }
        if (!System.isEnv('production')) {
            asyncTest('importing a template works with can-tag', function () {
                Component.extend({
                    tag: 'my-waiter',
                    view: stache('{{#isResolved}}' + '<content></content>' + '{{else}}' + '<div class=\'loading\'></div>' + '{{/isResolved}}'),
                    leakScope: true
                });
                var template = '<can-import from=\'can-view-import/test/other.stache\' {^@value}=\'*other\' can-tag=\'my-waiter\'>{{{*other()}}}</can-import>';
                stache.async(template).then(function (renderer) {
                    var frag = renderer(new CanMap());
                    importer('can-view-import/test/other.stache').then(function () {
                        ok(frag.childNodes[0].childNodes.length > 1, 'Something besides a text node is inserted');
                        equal(frag.childNodes[0].childNodes[2].firstChild.nodeValue, 'hi there', 'Partial worked with can-tag');
                        QUnit.start();
                    });
                });
            });
        }
        if (!System.isEnv('production')) {
            asyncTest('can dynamically import a template and use it', function () {
                var template = '<can-import from=\'can-view-import/test/other-dynamic.stache!\' {^@value}=\'*other\'/>{{> *other}}';
                stache.async(template).then(function (renderer) {
                    var frag = renderer();
                    importer('can-view-import/test/other.stache!').then(function () {
                        equal(frag.childNodes[3].firstChild.nodeValue, 'hi there', 'Partial was renderered right after the can-import');
                        QUnit.start();
                    });
                });
            });
        }
        if (!System.isEnv('production') && typeof console === 'object') {
            asyncTest('loading errors are logged to the console', function () {
                var template = '<can-import from=\'can-view-import/test/error\'></can-import>';
                var error = console.error;
                console.error = function (type) {
                    console.error = error;
                    QUnit.ok(/ERROR/.test(type), 'Logged an error that originated from the dynamically imported module');
                    QUnit.start();
                };
                stache.async(template).then(function (renderer) {
                    renderer({});
                });
            });
        }
    }
});
/*can@3.9.0-pre.0#view/import/import_test*/
define('can@3.9.0-pre.0#view/import/import_test', function (require, exports, module) {
    require('can-view-import/can-view-import_test');
});
/*can-view-live@3.2.0#test/live-test*/
define('can-view-live@3.2.0#test/live-test', function (require, exports, module) {
    var live = require('can-view-live');
    var compute = require('can-compute');
    var Map = require('can-map');
    var List = require('can-list');
    var nodeLists = require('can-view-nodelist');
    var canBatch = require('can-event/batch/batch');
    var Observation = require('can-observation');
    var domEvents = require('can-util/dom/events/events');
    var QUnit = require('steal-qunit');
    var isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');
    var domMutate = require('can-util/dom/mutate/mutate');
    var domAttr = require('can-util/dom/attr/attr');
    QUnit.module('can-view-live', {
        setup: function () {
            this.fixture = document.getElementById('qunit-fixture');
        }
    });
    test('html', function () {
        var div = document.createElement('div'), span = document.createElement('span');
        div.appendChild(span);
        var items = new List([
            'one',
            'two'
        ]);
        var html = compute(function () {
            var html = '';
            items.each(function (item) {
                html += '<label>' + item + '</label>';
            });
            return html;
        });
        live.html(span, html, div);
        equal(div.getElementsByTagName('label').length, 2);
        items.push('three');
        equal(div.getElementsByTagName('label').length, 3);
    });
    var esc = function (str) {
        return str.replace(/</g, '&lt;').replace(/>/g, '&gt;');
    };
    test('text', function () {
        var div = document.createElement('div'), span = document.createElement('span');
        div.appendChild(span);
        var items = new List([
            'one',
            'two'
        ]);
        var text = compute(function () {
            var html = '';
            items.each(function (item) {
                html += '<label>' + item + '</label>';
            });
            return html;
        });
        live.text(span, text, div);
        equal(div.innerHTML, esc('<label>one</label><label>two</label>'));
        items.push('three');
        equal(div.innerHTML, esc('<label>one</label><label>two</label><label>three</label>'));
    });
    test('attributes', function () {
        var div = document.createElement('div');
        var items = new List([
            'class',
            'foo'
        ]);
        var text = compute(function () {
            var html = '';
            if (items.attr(0) && items.attr(1)) {
                html += items.attr(0) + '=\'' + items.attr(1) + '\'';
            }
            return html;
        });
        live.attrs(div, text);
        equal(div.className, 'foo');
        items.splice(0, 2);
        equal(div.className, '');
        items.push('foo', 'bar');
        equal(div.getAttribute('foo'), 'bar');
    });
    test('attributes - should remove `removed` events listener', function () {
        QUnit.stop();
        var origAddEventListener = domEvents.addEventListener;
        var origRemoveEventListener = domEvents.removeEventListener;
        domEvents.addEventListener = function () {
            QUnit.ok(true, 'addEventListener called');
            origAddEventListener.apply(this, arguments);
            domEvents.addEventListener = origAddEventListener;
        };
        domEvents.removeEventListener = function () {
            QUnit.ok(true, 'addEventListener called');
            origRemoveEventListener.apply(this, arguments);
            domEvents.removeEventListener = origRemoveEventListener;
            QUnit.start();
        };
        var div = document.createElement('div');
        var text = compute('hello');
        domMutate.appendChild.call(this.fixture, div);
        live.attrs(div, text);
        domMutate.removeChild.call(this.fixture, div);
    });
    test('attribute', function () {
        var div = document.createElement('div');
        var firstObject = new Map({});
        var first = compute(function () {
            return firstObject.attr('selected') ? 'selected' : '';
        });
        var secondObject = new Map({});
        var second = compute(function () {
            return secondObject.attr('active') ? 'active' : '';
        });
        var className = compute(function () {
            return 'foo ' + first() + ' ' + second() + ' end';
        });
        live.attr(div, 'class', className);
        equal(div.className, 'foo   end');
        firstObject.attr('selected', true);
        equal(div.className, 'foo selected  end');
        secondObject.attr('active', true);
        equal(div.className, 'foo selected active end');
        firstObject.attr('selected', false);
        equal(div.className, 'foo  active end');
    });
    test('specialAttribute with new line', function () {
        var div = document.createElement('div');
        var style = compute('width: 50px;\nheight:50px;');
        live.attr(div, 'style', style);
        equal(div.style.height, '50px');
        equal(div.style.width, '50px');
    });
    test('list', function () {
        var div = document.createElement('div'), list = new List([
                'sloth',
                'bear'
            ]), template = function (animal) {
                return '<label>Animal=</label> <span>' + animal.get() + '</span>';
            };
        div.innerHTML = 'my <b>fav</b> animals: <span></span> !';
        var el = div.getElementsByTagName('span')[0];
        live.list(el, list, template, {});
        equal(div.getElementsByTagName('label').length, 2, 'There are 2 labels');
        div.getElementsByTagName('label')[0].myexpando = 'EXPANDO-ED';
        list.push('turtle');
        equal(div.getElementsByTagName('label')[0].myexpando, 'EXPANDO-ED', 'same expando');
        equal(div.getElementsByTagName('span')[2].innerHTML, 'turtle', 'turtle added');
    });
    test('list within a compute', function () {
        var div = document.createElement('div'), map = new Map({
                animals: [
                    'bear',
                    'turtle'
                ]
            }), template = function (animal) {
                return '<label>Animal=</label> <span>' + animal.get() + '</span>';
            };
        var listCompute = compute(function () {
            return map.attr('animals');
        });
        div.innerHTML = 'my <b>fav</b> animals: <span></span> !';
        var el = div.getElementsByTagName('span')[0];
        live.list(el, listCompute, template, {});
        equal(div.getElementsByTagName('label').length, 2, 'There are 2 labels');
        div.getElementsByTagName('label')[0].myexpando = 'EXPANDO-ED';
        map.attr('animals').push('turtle');
        equal(div.getElementsByTagName('label')[0].myexpando, 'EXPANDO-ED', 'same expando');
        equal(div.getElementsByTagName('span')[2].innerHTML, 'turtle', 'turtle added');
        map.attr('animals', new List([
            'sloth',
            'bear',
            'turtle'
        ]));
        var spans = div.getElementsByTagName('span');
        equal(spans.length, 3, 'there are 3 spans');
        ok(!div.getElementsByTagName('label')[0].myexpando, 'no expando');
    });
    test('list with a compute that returns a list', function () {
        var div = document.createElement('div'), template = function (num) {
                return '<label>num=</label> <span>' + num + '</span>';
            };
        var arrCompute = compute([
            0,
            1
        ]);
        div.innerHTML = 'my <b>fav</b> nums: <span></span> !';
        var el = div.getElementsByTagName('span')[0];
        live.list(el, arrCompute, template, {});
        equal(div.getElementsByTagName('label').length, 2, 'There are 2 labels');
        arrCompute([
            0,
            1,
            2
        ]);
        var spans = div.getElementsByTagName('span');
        equal(spans.length, 3, 'there are 3 spans');
    });
    test('text binding is memory safe (#666)', function () {
        nodeLists.nodeMap.clear();
        var div = document.createElement('div'), span = document.createElement('span'), text = compute(function () {
                return 'foo';
            });
        div.appendChild(span);
        domMutate.appendChild.call(this.fixture, div);
        live.text(span, text, div);
        domMutate.removeChild.call(this.fixture, div);
        stop();
        setTimeout(function () {
            ok(!nodeLists.nodeMap.size, 'nothing in nodeMap');
            start();
        }, 100);
    });
    test('html live binding handles getting a function from a compute', 5, function () {
        var handler = function (el) {
            ok(true, 'called handler');
            equal(el.nodeType, 3, 'got a placeholder');
        };
        var div = document.createElement('div'), placeholder = document.createTextNode('');
        div.appendChild(placeholder);
        var count = compute(0);
        var html = compute(function () {
            if (count() === 0) {
                return '<h1>Hello World</h1>';
            } else {
                return handler;
            }
        });
        live.html(placeholder, html, div);
        equal(div.getElementsByTagName('h1').length, 1, 'got h1');
        count(1);
        equal(div.getElementsByTagName('h1').length, 0, 'got h1');
        count(0);
        equal(div.getElementsByTagName('h1').length, 1, 'got h1');
    });
    test('live.list does not unbind on a list unnecessarily (#1835)', function () {
        expect(0);
        var div = document.createElement('div'), list = new List([
                'sloth',
                'bear'
            ]), template = function (animal) {
                return '<label>Animal=</label> <span>' + animal + '</span>';
            }, unbind = list.unbind;
        list.unbind = function () {
            ok(false, 'unbind called');
            return unbind.apply(this, arguments);
        };
        div.innerHTML = 'my <b>fav</b> animals: <span></span> !';
        var el = div.getElementsByTagName('span')[0];
        live.list(el, list, template, {});
    });
    test('can.live.attr works with non-string attributes (#1790)', function () {
        var el = document.createElement('div'), attrCompute = compute(function () {
                return 2;
            });
        domAttr.set(el, 'value', 1);
        live.attr(el, 'value', attrCompute);
        ok(true, 'No exception thrown.');
    });
    test('list and an falsey section (#1979)', function () {
        var div = document.createElement('div'), template = function (num) {
                return '<label>num=</label> <span>' + num + '</span>';
            }, falseyTemplate = function (num) {
                return '<p>NOTHING</p>';
            };
        var listCompute = compute([
            0,
            1
        ]);
        div.innerHTML = 'my <b>fav</b> nums: <span></span> !';
        var el = div.getElementsByTagName('span')[0];
        live.list(el, listCompute, template, {}, undefined, undefined, falseyTemplate);
        equal(div.getElementsByTagName('label').length, 2, 'There are 2 labels');
        listCompute([]);
        var spans = div.getElementsByTagName('span');
        equal(spans.length, 0, 'there are 0 spans');
        var ps = div.getElementsByTagName('p');
        equal(ps.length, 1, 'there is 1 p');
        listCompute([2]);
        spans = div.getElementsByTagName('span');
        equal(spans.length, 1, 'there is 1 spans');
        ps = div.getElementsByTagName('p');
        equal(ps.length, 0, 'there is 1 p');
    });
    test('list and an initial falsey section (#1979)', function () {
        var div = document.createElement('div'), template = function (num) {
                return '<label>num=</label> <span>' + num + '</span>';
            }, falseyTemplate = function (num) {
                return '<p>NOTHING</p>';
            };
        var listCompute = compute([]);
        div.innerHTML = 'my <b>fav</b> nums: <span></span> !';
        var el = div.getElementsByTagName('span')[0];
        live.list(el, listCompute, template, {}, undefined, undefined, falseyTemplate);
        var spans = div.getElementsByTagName('span');
        equal(spans.length, 0, 'there are 0 spans');
        var ps = div.getElementsByTagName('p');
        equal(ps.length, 1, 'there is 1 p');
        listCompute([2]);
        spans = div.getElementsByTagName('span');
        equal(spans.length, 1, 'there is 1 spans');
        ps = div.getElementsByTagName('p');
        equal(ps.length, 0, 'there is 1 p');
    });
    test('rendered list items should re-render when updated (#2007)', function () {
        var partial = document.createElement('div');
        var placeholderElement = document.createElement('span');
        var list = new List(['foo']);
        var renderer = function (item) {
            return '<span>' + item.get() + '</span>';
        };
        partial.appendChild(placeholderElement);
        live.list(placeholderElement, list, renderer, {});
        equal(partial.getElementsByTagName('span')[0].firstChild.data, 'foo', 'list item 0 is foo');
        list.push('bar');
        equal(partial.getElementsByTagName('span')[1].firstChild.data, 'bar', 'list item 1 is bar');
        list.attr(0, 'baz');
        equal(partial.getElementsByTagName('span')[0].firstChild.data, 'baz', 'list item 0 is baz');
    });
    test('list items should be correct even if renderer flushes batch (#8)', function () {
        var partial = document.createElement('div');
        var placeholderElement = document.createElement('span');
        var list = new List([
            'one',
            'two'
        ]);
        var renderer = function (item) {
            canBatch.flush();
            return '<span>' + item.get() + '</span>';
        };
        partial.appendChild(placeholderElement);
        live.list(placeholderElement, list, renderer, {});
        equal(partial.getElementsByTagName('span').length, 2, 'should be two items');
        equal(partial.getElementsByTagName('span')[0].firstChild.data, 'one', 'list item 0 is "one"');
        equal(partial.getElementsByTagName('span')[1].firstChild.data, 'two', 'list item 1 is "two"');
        canBatch.start();
        list.splice(0, 0, 'three');
        list.splice(2, 1);
        canBatch.stop();
        equal(partial.getElementsByTagName('span').length, 2, 'should be two items');
        equal(partial.getElementsByTagName('span')[0].firstChild.data, 'three', 'list item 0 is "three"');
        equal(partial.getElementsByTagName('span')[1].firstChild.data, 'one', 'list item 1 is "one"');
    });
    QUnit.test('Works with Observations - .html', function () {
        var div = document.createElement('div'), span = document.createElement('span');
        div.appendChild(span);
        var items = new List([
            'one',
            'two'
        ]);
        var html = new Observation(function () {
            var html = '';
            items.each(function (item) {
                html += '<label>' + item + '</label>';
            });
            return html;
        });
        live.html(span, html, div);
        equal(div.getElementsByTagName('label').length, 2);
        items.push('three');
        equal(div.getElementsByTagName('label').length, 3);
    });
    QUnit.test('Works with Observations - .list', function () {
        var div = document.createElement('div'), map = new Map({
                animals: [
                    'bear',
                    'turtle'
                ]
            }), template = function (animal) {
                return '<label>Animal=</label> <span>' + animal.get() + '</span>';
            };
        var listObservation = new Observation(function () {
            return map.attr('animals');
        });
        div.innerHTML = 'my <b>fav</b> animals: <span></span> !';
        var el = div.getElementsByTagName('span')[0];
        live.list(el, listObservation, template, {});
        equal(div.getElementsByTagName('label').length, 2, 'There are 2 labels');
        div.getElementsByTagName('label')[0].myexpando = 'EXPANDO-ED';
        map.attr('animals').push('turtle');
        equal(div.getElementsByTagName('label')[0].myexpando, 'EXPANDO-ED', 'same expando');
        equal(div.getElementsByTagName('span')[2].innerHTML, 'turtle', 'turtle added');
        map.attr('animals', new List([
            'sloth',
            'bear',
            'turtle'
        ]));
        var spans = div.getElementsByTagName('span');
        equal(spans.length, 3, 'there are 3 spans');
        ok(!div.getElementsByTagName('label')[0].myexpando, 'no expando');
    });
    QUnit.test('Works with Observations - .attrs', function () {
        var div = document.createElement('div');
        var items = new List([
            'class',
            'foo'
        ]);
        var text = new Observation(function () {
            var html = '';
            if (items.attr(0) && items.attr(1)) {
                html += items.attr(0) + '=\'' + items.attr(1) + '\'';
            }
            return html;
        });
        live.attrs(div, text);
        equal(div.className, 'foo');
        items.splice(0, 2);
        equal(div.className, '');
        items.push('foo', 'bar');
        equal(div.getAttribute('foo'), 'bar');
    });
    QUnit.test('Works with Observations - .attr', function () {
        var div = document.createElement('div');
        var firstObject = new Map({});
        var first = compute(function () {
            return firstObject.attr('selected') ? 'selected' : '';
        });
        var secondObject = new Map({});
        var second = compute(function () {
            return secondObject.attr('active') ? 'active' : '';
        });
        var className = new Observation(function () {
            return 'foo ' + first() + ' ' + second() + ' end';
        });
        live.attr(div, 'class', className);
        equal(div.className, 'foo   end');
        firstObject.attr('selected', true);
        equal(div.className, 'foo selected  end');
        secondObject.attr('active', true);
        equal(div.className, 'foo selected active end');
        firstObject.attr('selected', false);
        equal(div.className, 'foo  active end');
    });
});
/*can@3.9.0-pre.0#view/live/live_test*/
define('can@3.9.0-pre.0#view/live/live_test', function (require, exports, module) {
    require('can-view-live/test/live-test');
});
/*can-view-model@3.4.0#can-view-model_test*/
define('can-view-model@3.4.0#can-view-model_test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var viewModel = require('can-view-model');
    var SimpleMap = require('can-simple-map');
    var CanMap = require('can-map');
    var DefineMap = require('can-define/map/map');
    var types = require('can-types');
    QUnit.module('can-view-model');
    QUnit.test('basics', function () {
        var DefaultMap = types.DefaultMap;
        types.DefaultMap = undefined;
        var el = document.createElement('div');
        viewModel(el, 'foo', 'bar');
        QUnit.equal(viewModel(el, 'foo'), 'bar');
        QUnit.ok(viewModel(el) instanceof SimpleMap, 'is can-map');
        types.DefaultMap = DefaultMap;
    });
    QUnit.test('a selector can be passed as the first argument (#6)', function () {
        var DefaultMap = types.DefaultMap;
        types.DefaultMap = undefined;
        var el = document.createElement('div');
        el.className = 'the-el';
        document.getElementById('qunit-fixture').appendChild(el);
        viewModel('.the-el', 'foo', 'bar');
        QUnit.equal(viewModel('.the-el', 'foo'), 'bar');
        QUnit.ok(viewModel(el) instanceof SimpleMap, 'is can-map');
        types.DefaultMap = DefaultMap;
    });
    QUnit.test('set custom can-simple-map on element (#5)', function () {
        var vm, elVm;
        var CustomMap = SimpleMap.extend({});
        var el = document.createElement('div');
        document.getElementById('qunit-fixture').appendChild(el);
        vm = new CustomMap({ foo: 'bar' });
        elVm = viewModel(el, vm);
        QUnit.equal(viewModel(el, 'foo'), 'bar');
    });
    QUnit.test('set custom can-map on element (#5)', function () {
        var vm, elVm;
        var CustomMap = CanMap.extend({});
        var el = document.createElement('div');
        document.getElementById('qunit-fixture').appendChild(el);
        vm = new CustomMap({ foo: 'bar' });
        elVm = viewModel(el, vm);
        QUnit.equal(viewModel(el, 'foo'), 'bar');
    });
    QUnit.test('set custom can-define-map on element (#5)', function () {
        var vm, elVm;
        var CustomMap = DefineMap.extend({});
        var el = document.createElement('div');
        document.getElementById('qunit-fixture').appendChild(el);
        vm = new CustomMap({ foo: 'bar' });
        elVm = viewModel(el, vm);
        QUnit.equal(viewModel(el, 'foo'), 'bar');
    });
    QUnit.test('Allow passing array like (jQuery) element', function () {
        var DefaultMap = types.DefaultMap;
        var $el = {};
        types.DefaultMap = undefined;
        var el = document.createElement('div');
        el.className = 'the-el';
        $el[0] = el;
        $el.length = 1;
        document.getElementById('qunit-fixture').appendChild(el);
        viewModel($el, 'foo', 'bar');
        QUnit.equal(viewModel('.the-el', 'foo'), 'bar', 'It reads view scope from html element');
        QUnit.equal(viewModel($el, 'foo'), 'bar', 'It reads view scope from array like (jQuery) element');
        QUnit.ok(viewModel(el) instanceof SimpleMap, 'is can-map');
        types.DefaultMap = DefaultMap;
    });
    QUnit.test('elements with length property not treated as arraylikes (#31)', function () {
        var el = document.createElement('select');
        document.getElementById('qunit-fixture').appendChild(el);
        QUnit.equal(el.length, 0, 'Select has length property (0 for empty)');
        QUnit.deepEqual(viewModel(el).get(), {}, 'viewModel created on empty select');
        var opt = document.createElement('option');
        el.appendChild(opt);
        QUnit.equal(el.length, 1, 'Select has length 1');
        QUnit.deepEqual(viewModel(el).get(), {}, 'viewModel created on non-empty select');
    });
});
/*can-view-model@3.4.0#test/test*/
define('can-view-model@3.4.0#test/test', function (require, exports, module) {
    require('../can-view-model_test');
});
/*can-view-nodelist@3.1.0#test/can-view-nodelist-test*/
define('can-view-nodelist@3.1.0#test/can-view-nodelist-test', function (require, exports, module) {
    var nodeLists = require('can-view-nodelist');
    var fragment = require('can-util/dom/fragment/fragment');
    var makeArray = require('can-util/js/make-array/make-array');
    var frag = require('can-util/dom/frag/frag');
    var QUnit = require('steal-qunit');
    QUnit.module('can-view-nodelist');
    test('unregisters child nodeLists', function () {
        expect(3);
        var spansFrag = fragment('<span>1</span><span>2</span>');
        var spansList = makeArray(spansFrag.childNodes);
        nodeLists.register(spansList, function () {
            ok(true, 'unregistered spansList');
        });
        var labelFrag = fragment('<label>l</label>');
        var labelList = makeArray(labelFrag.childNodes);
        nodeLists.register(labelList, function () {
            ok(true, 'unregistered labelList');
        });
        var ifPreHookupFrag = frag([
                '~',
                '',
                '-',
                ''
            ]), ifChildNodes = ifPreHookupFrag.childNodes, ifEls = makeArray(ifChildNodes);
        nodeLists.replace([ifChildNodes[1]], spansFrag);
        nodeLists.replace([ifChildNodes[4]], labelFrag);
        var ifList = makeArray(ifPreHookupFrag.childNodes);
        nodeLists.register(ifList, function () {
            ok(true, 'unregistered ifList');
        });
        deepEqual(ifList, [
            ifEls[0],
            spansList,
            ifEls[2],
            labelList
        ]);
        nodeLists.update(ifList, [document.createTextNode('empty')]);
    });
});
/*can@3.9.0-pre.0#view/node_lists/node_lists_test*/
define('can@3.9.0-pre.0#view/node_lists/node_lists_test', function (require, exports, module) {
    require('can-view-nodelist/test/can-view-nodelist-test');
});
/*can-view-parser@3.4.0#test/can-view-parser-test*/
define('can-view-parser@3.4.0#test/can-view-parser-test', function (require, exports, module) {
    var parser = require('can-view-parser');
    var QUnit = require('steal-qunit');
    var canDev = require('can-util/js/dev/dev');
    QUnit.module('can-view-parser');
    var makeChecks = function (tests) {
        var count = 0;
        var makeCheck = function (name) {
            return function () {
                if (count >= tests.length) {
                    ok(false, 'called ' + name + ' with ' + arguments[0]);
                } else {
                    var test = tests[count], args = test[1];
                    equal(name, test[0], 'test ' + count + ' ' + name + '(');
                    for (var i = 0; i < args.length; i++) {
                        equal(arguments[i], args[i], i + 1 + ' arg -> ' + args[i]);
                    }
                    count++;
                }
            };
        };
        return {
            start: makeCheck('start'),
            end: makeCheck('end'),
            close: makeCheck('close'),
            attrStart: makeCheck('attrStart'),
            attrEnd: makeCheck('attrEnd'),
            attrValue: makeCheck('attrValue'),
            chars: makeCheck('chars'),
            comment: makeCheck('comment'),
            special: makeCheck('special'),
            done: makeCheck('done')
        };
    };
    test('html to html', function () {
        var tests = [
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'attrStart',
                ['id']
            ],
            [
                'attrValue',
                ['foo']
            ],
            [
                'attrEnd',
                ['id']
            ],
            [
                'special',
                ['#if']
            ],
            [
                'special',
                ['.']
            ],
            [
                'special',
                ['/if']
            ],
            [
                'attrStart',
                ['class']
            ],
            [
                'attrValue',
                ['a']
            ],
            [
                'special',
                ['foo']
            ],
            [
                'attrEnd',
                ['class']
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'chars',
                ['Hello ']
            ],
            [
                'special',
                ['message']
            ],
            [
                'chars',
                ['!']
            ],
            [
                'close',
                ['h1']
            ],
            [
                'done',
                []
            ]
        ];
        parser('<h1 id=\'foo\' {{#if}}{{.}}{{/if}} class=\'a{{foo}}\'>Hello {{message}}!</h1>', makeChecks(tests));
    });
    test('uppercase html to html', function () {
        var tests = [
            [
                'start',
                [
                    'div',
                    false
                ]
            ],
            [
                'end',
                [
                    'div',
                    false
                ]
            ],
            [
                'chars',
                ['sibling']
            ],
            [
                'close',
                ['div']
            ],
            [
                'start',
                [
                    'div',
                    false
                ]
            ],
            [
                'end',
                [
                    'div',
                    false
                ]
            ],
            [
                'chars',
                ['sibling']
            ],
            [
                'close',
                ['div']
            ],
            [
                'done',
                []
            ]
        ];
        parser('<DIV>sibling</DIV><DIV>sibling</DIV>', makeChecks(tests));
    });
    test('camelCase attributes stay untouched (svg) - #22', function () {
        var tests = [
            [
                'start',
                [
                    'svg',
                    false
                ]
            ],
            [
                'attrStart',
                ['viewBox']
            ],
            [
                'attrValue',
                ['0 0 15 22']
            ],
            [
                'attrEnd',
                ['viewBox']
            ],
            [
                'end',
                [
                    'svg',
                    false
                ]
            ],
            [
                'close',
                ['svg']
            ],
            [
                'done',
                []
            ]
        ];
        parser('<svg viewBox="0 0 15 22"></svg>', makeChecks(tests));
    });
    test('camelCase tags stay untouched (svg)', function () {
        var tests = [
            [
                'start',
                [
                    'svg',
                    false
                ]
            ],
            [
                'end',
                [
                    'svg',
                    false
                ]
            ],
            [
                'start',
                [
                    'radialGradient',
                    false
                ]
            ],
            [
                'end',
                [
                    'radialGradient',
                    false
                ]
            ],
            [
                'close',
                ['radialGradient']
            ],
            [
                'close',
                ['svg']
            ],
            [
                'done',
                []
            ]
        ];
        parser('<svg><radialGradient></radialGradient></svg>', makeChecks(tests));
    });
    test('special in an attribute in an in-tag section', function () {
        parser('<div {{#truthy}}foo=\'{{baz}}\'{{/truthy}}></div>', makeChecks([
            [
                'start',
                [
                    'div',
                    false
                ]
            ],
            [
                'special',
                ['#truthy']
            ],
            [
                'attrStart',
                ['foo']
            ],
            [
                'special',
                ['baz']
            ],
            [
                'attrEnd',
                ['foo']
            ],
            [
                'special',
                ['/truthy']
            ],
            [
                'end',
                [
                    'div',
                    false
                ]
            ],
            [
                'close',
                ['div']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('special with a custom attribute', function () {
        parser('<div {{#attribute}} {{name}}="{{value}}" {{/attribute}}></div>', makeChecks([
            [
                'start',
                [
                    'div',
                    false
                ]
            ],
            [
                'special',
                ['#attribute']
            ],
            [
                'special',
                ['name']
            ],
            [
                'attrStart',
                ['']
            ],
            [
                'special',
                ['value']
            ],
            [
                'attrEnd',
                ['']
            ],
            [
                'special',
                ['/attribute']
            ],
            [
                'end',
                [
                    'div',
                    false
                ]
            ],
            [
                'close',
                ['div']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('single attribute value', function () {
        parser('<input DISABLED/>', makeChecks([
            [
                'start',
                [
                    'input',
                    true
                ]
            ],
            [
                'attrStart',
                ['DISABLED']
            ],
            [
                'attrEnd',
                ['DISABLED']
            ],
            [
                'end',
                [
                    'input',
                    true
                ]
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('trailing linebreaks in IE', function () {
        parser('12345{{!\n  This is a\n  multi-line comment...\n}}67890\n', makeChecks([
            [
                'chars',
                ['12345']
            ],
            [
                'special',
                ['!\n  This is a\n  multi-line comment...\n']
            ],
            [
                'chars',
                ['67890\n']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('block are allowed inside anchor tags', function () {
        parser('<a><div></div></a>', makeChecks([
            [
                'start',
                [
                    'a',
                    false
                ]
            ],
            [
                'end',
                [
                    'a',
                    false
                ]
            ],
            [
                'start',
                [
                    'div',
                    false
                ]
            ],
            [
                'end',
                [
                    'div',
                    false
                ]
            ],
            [
                'close',
                ['div']
            ],
            [
                'close',
                ['a']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('anchors are allowed as children of inline elements - #2169', function () {
        parser('<span><a></a></span>', makeChecks([
            [
                'start',
                [
                    'span',
                    false
                ]
            ],
            [
                'end',
                [
                    'span',
                    false
                ]
            ],
            [
                'start',
                [
                    'a',
                    false
                ]
            ],
            [
                'end',
                [
                    'a',
                    false
                ]
            ],
            [
                'close',
                ['a']
            ],
            [
                'close',
                ['span']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('inline tags encapsulate inner block elements', function () {
        parser('<span><div></div></span>', makeChecks([
            [
                'start',
                [
                    'span',
                    false
                ]
            ],
            [
                'end',
                [
                    'span',
                    false
                ]
            ],
            [
                'start',
                [
                    'div',
                    false
                ]
            ],
            [
                'end',
                [
                    'div',
                    false
                ]
            ],
            [
                'close',
                ['div']
            ],
            [
                'close',
                ['span']
            ],
            [
                'done',
                []
            ]
        ]));
        parser('<em><h1></h1></em>', makeChecks([
            [
                'start',
                [
                    'em',
                    false
                ]
            ],
            [
                'end',
                [
                    'em',
                    false
                ]
            ],
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'close',
                ['h1']
            ],
            [
                'close',
                ['em']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('unordered lists will contain their list items', function () {
        parser('<ul><li></li><li></li></ul>', makeChecks([
            [
                'start',
                [
                    'ul',
                    false
                ]
            ],
            [
                'end',
                [
                    'ul',
                    false
                ]
            ],
            [
                'start',
                [
                    'li',
                    false
                ]
            ],
            [
                'end',
                [
                    'li',
                    false
                ]
            ],
            [
                'close',
                ['li']
            ],
            [
                'start',
                [
                    'li',
                    false
                ]
            ],
            [
                'end',
                [
                    'li',
                    false
                ]
            ],
            [
                'close',
                ['li']
            ],
            [
                'close',
                ['ul']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('supports single character attributes (#1132)', function () {
        parser('<circle r="25"></circle>', makeChecks([
            [
                'start',
                [
                    'circle',
                    false
                ]
            ],
            [
                'attrStart',
                ['r']
            ],
            [
                'attrValue',
                ['25']
            ],
            [
                'attrEnd',
                ['r']
            ],
            [
                'end',
                [
                    'circle',
                    false
                ]
            ],
            [
                'close',
                ['circle']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('accept custom tag with colon ":" #1108', function () {
        parser('<x:widget/>', makeChecks([
            [
                'start',
                [
                    'x:widget',
                    true
                ]
            ],
            [
                'end',
                [
                    'x:widget',
                    true
                ]
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('output json', function () {
        var tests = [
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'attrStart',
                ['id']
            ],
            [
                'attrValue',
                ['foo']
            ],
            [
                'attrEnd',
                ['id']
            ],
            [
                'special',
                ['#if']
            ],
            [
                'special',
                ['.']
            ],
            [
                'special',
                ['/if']
            ],
            [
                'attrStart',
                ['class']
            ],
            [
                'attrValue',
                ['a']
            ],
            [
                'special',
                ['foo']
            ],
            [
                'attrEnd',
                ['class']
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'chars',
                ['Hello ']
            ],
            [
                'special',
                ['message']
            ],
            [
                'chars',
                ['!']
            ],
            [
                'close',
                ['h1']
            ],
            [
                'done',
                []
            ]
        ];
        var intermediate = parser('<h1 id=\'foo\' {{#if}}{{.}}{{/if}} class=\'a{{foo}}\'>Hello {{message}}!</h1>', makeChecks(tests), true);
        parser(intermediate, makeChecks(tests));
    });
    test('less than outside of an element', function () {
        var tests = [
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'chars',
                [' < ']
            ],
            [
                'close',
                ['h1']
            ],
            [
                'done',
                []
            ]
        ];
        var intermediate = parser('<h1> < </h1>', makeChecks(tests), true);
        parser(intermediate, makeChecks(tests));
    });
    test('allow () and [] to enclose attributes', function () {
        parser('<p [click]="test"></p>', makeChecks([
            [
                'start',
                [
                    'p',
                    false
                ]
            ],
            [
                'attrStart',
                ['[click]']
            ],
            [
                'attrValue',
                ['test']
            ],
            [
                'attrEnd',
                ['[click]']
            ],
            [
                'end',
                ['p']
            ],
            [
                'close',
                ['p']
            ],
            [
                'done',
                []
            ]
        ]));
        parser('<p (click)="test"></p>', makeChecks([
            [
                'start',
                [
                    'p',
                    false
                ]
            ],
            [
                'attrStart',
                ['(click)']
            ],
            [
                'attrValue',
                ['test']
            ],
            [
                'attrEnd',
                ['(click)']
            ],
            [
                'end',
                ['p']
            ],
            [
                'close',
                ['p']
            ],
            [
                'done',
                []
            ]
        ]));
        parser('<p (click-me)="test"></p>', makeChecks([
            [
                'start',
                [
                    'p',
                    false
                ]
            ],
            [
                'attrStart',
                ['(click-me)']
            ],
            [
                'attrValue',
                ['test']
            ],
            [
                'attrEnd',
                ['(click-me)']
            ],
            [
                'end',
                ['p']
            ],
            [
                'close',
                ['p']
            ],
            [
                'done',
                []
            ]
        ]));
        parser('<p (click_me)="test"></p>', makeChecks([
            [
                'start',
                [
                    'p',
                    false
                ]
            ],
            [
                'attrStart',
                ['(click_me)']
            ],
            [
                'attrValue',
                ['test']
            ],
            [
                'attrEnd',
                ['(click_me)']
            ],
            [
                'end',
                ['p']
            ],
            [
                'close',
                ['p']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('allow {} to enclose attributes', function () {
        parser.parseAttrs('{a}="b" {{#c}}d{{/c}}', makeChecks([
            [
                'attrStart',
                ['{a}']
            ],
            [
                'attrValue',
                ['b']
            ],
            [
                'attrEnd',
                ['{a}']
            ],
            [
                'special',
                ['#c']
            ],
            [
                'attrStart',
                ['d']
            ],
            [
                'attrEnd',
                ['d']
            ],
            [
                'special',
                ['/c']
            ]
        ]));
    });
    test('tripple curly in attrs', function () {
        parser.parseAttrs('items="{{{ completed }}}"', makeChecks([
            [
                'attrStart',
                ['items']
            ],
            [
                'special',
                ['{ completed ']
            ],
            [
                'attrEnd',
                ['items']
            ]
        ]));
    });
    test('something', function () {
        parser.parseAttrs('c d=\'e\'', makeChecks([
            [
                'attrStart',
                ['c']
            ],
            [
                'attrEnd',
                ['c']
            ],
            [
                'attrStart',
                ['d']
            ],
            [
                'attrValue',
                ['e']
            ],
            [
                'attrEnd',
                ['d']
            ]
        ]));
    });
    test('references', function () {
        parser('<year-selector *y />', makeChecks([
            [
                'start',
                [
                    'year-selector',
                    true
                ]
            ],
            [
                'attrStart',
                ['*y']
            ],
            [
                'attrEnd',
                ['*y']
            ],
            [
                'end',
                ['year-selector']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('quotes around attributes and other lazy attribute writing (#2097)', function () {
        parser('<c-d a={z}/>', makeChecks([
            [
                'start',
                [
                    'c-d',
                    true
                ]
            ],
            [
                'attrStart',
                ['a']
            ],
            [
                'attrValue',
                ['{z}']
            ],
            [
                'attrEnd',
                ['a']
            ],
            [
                'end',
                ['c-d']
            ],
            [
                'done',
                []
            ]
        ]));
        parser('<span v={{.}}/>', makeChecks([
            [
                'start',
                [
                    'span',
                    true
                ]
            ],
            [
                'attrStart',
                ['v']
            ],
            [
                'special',
                ['.']
            ],
            [
                'attrEnd',
                ['v']
            ],
            [
                'end',
                ['span']
            ],
            [
                'done',
                []
            ]
        ]));
        parser('<div {{^f}} d {{/f}}/>', makeChecks([
            [
                'start',
                [
                    'div',
                    true
                ]
            ],
            [
                'special',
                ['^f']
            ],
            [
                'attrStart',
                ['d']
            ],
            [
                'attrEnd',
                ['d']
            ],
            [
                'special',
                ['/f']
            ],
            [
                'end',
                ['div']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('camelCased attributes are converted to spinal-case', function () {
        parser.parseAttrs('({camelCase})=\'assigned\'', makeChecks([
            [
                'attrStart',
                ['({camel-case})']
            ],
            [
                'attrValue',
                ['assigned']
            ],
            [
                'attrEnd',
                ['({camel-case})']
            ]
        ]));
    });
    test('elements that have attributes with equal signs and no values are handled appropriately (#17)', function () {
        parser('<input class=\'toggle\' type=\'checkbox\' {($checked)}=\'complete\' ($change)=>', makeChecks([
            [
                'start',
                [
                    'input',
                    true
                ]
            ],
            [
                'attrStart',
                ['class']
            ],
            [
                'attrValue',
                ['toggle']
            ],
            [
                'attrEnd',
                ['class']
            ],
            [
                'attrStart',
                ['type']
            ],
            [
                'attrValue',
                ['checkbox']
            ],
            [
                'attrEnd',
                ['type']
            ],
            [
                'attrStart',
                ['{($checked)}']
            ],
            [
                'attrValue',
                ['complete']
            ],
            [
                'attrEnd',
                ['{($checked)}']
            ],
            [
                'attrStart',
                ['($change)']
            ],
            [
                'attrEnd',
                ['($change)']
            ],
            [
                'end',
                ['input']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('supports other delimiters (#31)', function () {
        var checks = makeChecks([
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'attrStart',
                ['id']
            ],
            [
                'attrValue',
                ['foo']
            ],
            [
                'attrEnd',
                ['id']
            ],
            [
                'special',
                ['#if']
            ],
            [
                'special',
                ['.']
            ],
            [
                'special',
                ['/if']
            ],
            [
                'attrStart',
                ['class']
            ],
            [
                'attrValue',
                ['a']
            ],
            [
                'special',
                ['foo']
            ],
            [
                'attrEnd',
                ['class']
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'chars',
                ['Hello ']
            ],
            [
                'special',
                ['message']
            ],
            [
                'chars',
                ['!']
            ],
            [
                'close',
                ['h1']
            ],
            [
                'done',
                []
            ]
        ]);
        checks.magicStart = '{';
        checks.magicMatch = /\{([^\}]*)\}/g;
        parser('<h1 id=\'foo\' {#if}{.}{/if} class=\'a{foo}\'>Hello {message}!</h1>', checks);
    });
    test('{{}} in attribute values are handled correctly (#34)', function () {
        var tests = [
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'attrStart',
                ['class']
            ],
            [
                'special',
                ['foo']
            ],
            [
                'attrValue',
                ['a']
            ],
            [
                'attrEnd',
                ['class']
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'close',
                ['h1']
            ],
            [
                'done',
                []
            ]
        ];
        parser('<h1 class=\'{{foo}}a\'></h1>', makeChecks(tests));
    });
    test('tags with data attributes are allowed in comments (#2)', function () {
        parser('{{! foo }}', makeChecks([
            [
                'special',
                ['! foo ']
            ],
            [
                'done',
                []
            ]
        ]));
        parser('{{! <foo /> }}', makeChecks([
            [
                'special',
                ['! <foo /> ']
            ],
            [
                'done',
                []
            ]
        ]));
        parser('{{! <foo bar="{bam}" /> }}', makeChecks([
            [
                'special',
                ['! <foo bar="{bam}" /> ']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('multiline special comments (#14)', function () {
        parser('{{! foo !}}', makeChecks([
            [
                'special',
                ['! foo !']
            ],
            [
                'done',
                []
            ]
        ]));
        parser('{{! {{foo}} {{bar}} !}}', makeChecks([
            [
                'special',
                ['! {{foo}} {{bar}} !']
            ],
            [
                'done',
                []
            ]
        ]));
        parser('{{!\n{{foo}}\n{{bar}}\n!}}', makeChecks([
            [
                'special',
                ['!\n{{foo}}\n{{bar}}\n!']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('spaces in attribute names that start with `{` or `(` are encoded (#48)', function () {
        var tests = [
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'attrStart',
                ['{foo\\sbar}']
            ],
            [
                'attrValue',
                ['a']
            ],
            [
                'attrEnd',
                ['{foo\\sbar}']
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'close',
                ['h1']
            ],
            [
                'done',
                []
            ]
        ];
        parser('<h1 {foo bar}=\'a\'></h1>', makeChecks(tests));
    });
    test('for attributes without values, spaces in attribute names that start with `{` or `(` are encoded (#48)', function () {
        var tests = [
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'attrStart',
                ['{foo\\s}']
            ],
            [
                'attrEnd',
                ['{foo\\s}']
            ],
            [
                'attrStart',
                ['{bar\\s}']
            ],
            [
                'attrEnd',
                ['{bar\\s}']
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'close',
                ['h1']
            ],
            [
                'done',
                []
            ]
        ];
        parser('<h1 {foo } {bar }></h1>', makeChecks(tests));
    });
    test('mismatched brackets work: {(foo})', function () {
        var tests = [
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'attrStart',
                ['{(foo})']
            ],
            [
                'attrValue',
                ['a']
            ],
            [
                'attrEnd',
                ['{(foo})']
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'close',
                ['h1']
            ],
            [
                'done',
                []
            ]
        ];
        parser('<h1 {(foo})=\'a\'></h1>', makeChecks(tests));
    });
    test('mismatched brackets work: ({foo)}', function () {
        var tests = [
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'attrStart',
                ['({foo)}']
            ],
            [
                'attrValue',
                ['a']
            ],
            [
                'attrEnd',
                ['({foo)}']
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'close',
                ['h1']
            ],
            [
                'done',
                []
            ]
        ];
        parser('<h1 ({foo)}=\'a\'></h1>', makeChecks(tests));
    });
    test('forward slashes are encoded (#52)', function () {
        var tests = [
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'attrStart',
                ['{foo\\fbar}']
            ],
            [
                'attrValue',
                ['a']
            ],
            [
                'attrEnd',
                ['{foo\\fbar}']
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'close',
                ['h1']
            ],
            [
                'done',
                []
            ]
        ];
        parser('<h1 {foo/bar}=\'a\'></h1>', makeChecks(tests));
    });
});
/*can@3.9.0-pre.0#view/parser/parser_test*/
define('can@3.9.0-pre.0#view/parser/parser_test', function (require, exports, module) {
    require('can-view-parser/test/can-view-parser-test');
});
/*can-view-scope@3.3.0#test/scope-define-test*/
define('can-view-scope@3.3.0#test/scope-define-test', function (require, exports, module) {
    'use strict';
    var Scope = require('can-view-scope');
    var DefineMap = require('can-define/map/map');
    var DefineList = require('can-define/list/list');
    var observeReader = require('can-stache-key');
    var compute = require('can-compute');
    var QUnit = require('steal-qunit');
    QUnit.module('can-view-scope with define');
    test('basics', function () {
        var items = new DefineMap({
            people: [
                { name: 'Justin' },
                { name: 'Brian' }
            ],
            count: 1000
        });
        var itemsScope = new Scope(items), arrayScope = new Scope(itemsScope.peek('people'), itemsScope), firstItem = new Scope(arrayScope.peek('0'), arrayScope);
        var nameInfo;
        var c = compute(function () {
            nameInfo = firstItem.read('name');
        });
        c.bind('change', function () {
        });
        deepEqual(nameInfo.reads, [{
                key: 'name',
                at: false
            }], 'reads');
        equal(nameInfo.scope, firstItem, 'scope');
        equal(nameInfo.value, 'Justin', 'value');
        equal(nameInfo.rootObserve, items.people[0], 'rootObserve');
    });
    test('Scope.prototype.computeData', function () {
        var map = new DefineMap({ age: undefined });
        var base = new Scope(map);
        var age = base.computeData('age').compute;
        equal(age(), undefined, 'age is not set');
        age.bind('change', function (ev, newVal, oldVal) {
            equal(newVal, 31, 'newVal is provided correctly');
            equal(oldVal, undefined, 'oldVal is undefined');
        });
        age(31);
        equal(map.age, 31, 'maps age is set correctly');
    });
    test('backtrack path (#163)', function () {
        var row = new DefineMap({ first: 'Justin' }), col = { format: 'str' }, base = new Scope(row), cur = base.add(col);
        equal(cur.peek('.'), col, 'got col');
        equal(cur.peek('..'), row, 'got row');
        equal(cur.peek('../first'), 'Justin', 'got row');
    });
    test('nested properties with compute', function () {
        var me = new DefineMap({ name: { first: 'Justin' } });
        var cur = new Scope(me);
        var compute = cur.computeData('name.first').compute;
        var changes = 0;
        compute.bind('change', function (ev, newVal, oldVal) {
            if (changes === 0) {
                equal(oldVal, 'Justin');
                equal(newVal, 'Brian');
            } else if (changes === 1) {
                equal(oldVal, 'Brian');
                equal(newVal, undefined);
            } else if (changes === 2) {
                equal(oldVal, undefined);
                equal(newVal, 'Payal');
            } else if (changes === 3) {
                equal(oldVal, 'Payal');
                equal(newVal, 'Curtis');
            }
            changes++;
        });
        equal(compute(), 'Justin', 'read value after bind');
        me.name.first = 'Brian';
        me.name = undefined;
        me.name = { first: 'Payal' };
        me.name = new DefineMap({ first: 'Curtis' });
    });
    test('binds to the right scope only', 3, function () {
        var baseMap = new DefineMap({ me: { name: { first: 'Justin' } } });
        var base = new Scope(baseMap);
        var topMap = new DefineMap({ me: { name: {} } });
        var scope = base.add(topMap);
        var compute = scope.computeData('me.name.first').compute;
        compute.bind('change', function (ev, newVal, oldVal) {
            equal(oldVal, 'Justin');
            equal(newVal, 'Brian');
        });
        equal(compute(), 'Justin');
        baseMap.me.name.first = 'Brian';
    });
    test('Scope read returnObserveMethods=true', function () {
        var MapConstruct = DefineMap.extend({
            foo: function (arg) {
                equal(this, data.map, 'correct this');
                equal(arg, true, 'correct arg');
            }
        });
        var data = { map: new MapConstruct() };
        var res = Scope.read(data, observeReader.reads('map.foo'), { isArgument: true });
        res.value(true);
    });
    test('rooted observable is able to update correctly', function () {
        var baseMap = new DefineMap({ name: { first: 'Justin' } });
        var scope = new Scope(baseMap);
        var compute = scope.computeData('name.first').compute;
        equal(compute(), 'Justin');
        baseMap.name = new DefineMap({ first: 'Brian' });
        equal(compute(), 'Brian');
    });
    test('Can read static properties on constructors (#634)', function () {
        var Foo = DefineMap.extend({ static_prop: 'baz' }, { proto_prop: 'thud' });
        var data = new Foo({ own_prop: 'quux' }), scope = new Scope(data);
        equal(scope.computeData('constructor.static_prop').compute(), 'baz', 'static prop');
    });
    test('setting props in a compute (#18)', function () {
        var map = new DefineMap({ complete: true });
        var computeVal = compute(map);
        var base = new Scope(computeVal);
        var complete = base.computeData('complete').compute;
        equal(complete(), true, 'can read the value');
        complete(false);
        QUnit.equal(map.complete, false, 'value set');
    });
    test('undefined DefineMap props should be a scope hit (#20)', function () {
        var MyType = DefineMap.extend('MyType', { value: 'string' });
        var EmptyType = DefineMap.extend('EmptyType', {});
        var instance = new MyType();
        var scope = new Scope(instance).add(new EmptyType());
        var c1 = scope.computeData('value').compute;
        c1.on('change', function () {
        });
        c1('BAR');
        QUnit.equal(instance.value, 'BAR');
        var instance2 = new MyType();
        var scope2 = new Scope(instance2).add(compute());
        var c2 = scope2.computeData('value').compute;
        c2.on('change', function () {
        });
        c2('BAR');
        QUnit.equal(instance2.value, 'BAR');
    });
    test('that .set with ../ is able to skip notContext scopes (#43)', function () {
        var instance = new DefineMap({ prop: 0 });
        var notContextContext = { NAME: 'NOT CONTEXT' };
        var top = { NAME: 'TOP' };
        var scope = new Scope(instance).add(notContextContext, { notContext: true }).add(top);
        scope.set('../prop', 1);
        QUnit.equal(instance.prop, 1);
    });
    QUnit.test('this works everywhere (#45)', function () {
        var obj = { foo: 'bar' };
        var scope = new Scope(obj);
        QUnit.equal(scope.get('this.foo'), 'bar');
    });
});
/*can-view-scope@3.3.0#test/scope-test*/
define('can-view-scope@3.3.0#test/scope-test', function (require, exports, module) {
    require('./scope-define-test');
    var Scope = require('can-view-scope');
    var Map = require('can-map');
    var List = require('can-list');
    var observeReader = require('can-stache-key');
    var compute = require('can-compute');
    var ReferenceMap = require('../reference-map');
    var canSymbol = require('can-symbol');
    var QUnit = require('steal-qunit');
    var canBatch = require('can-event/batch/batch');
    var canReflect = require('can-reflect');
    QUnit.module('can/view/scope');
    test('basics', function () {
        var items = new Map({
            people: [
                { name: 'Justin' },
                [{ name: 'Brian' }]
            ],
            count: 1000
        });
        var itemsScope = new Scope(items), arrayScope = new Scope(itemsScope.peek('people'), itemsScope), firstItem = new Scope(arrayScope.peek('0'), arrayScope);
        var nameInfo;
        var c = compute(function () {
            nameInfo = firstItem.read('name');
        });
        c.bind('change', function () {
        });
        deepEqual(nameInfo.reads, [{
                key: 'name',
                at: false
            }], 'reads');
        equal(nameInfo.scope, firstItem, 'scope');
        equal(nameInfo.value, 'Justin', 'value');
        equal(nameInfo.rootObserve, items.people[0], 'rootObserve');
    });
    test('Scope.prototype.computeData', function () {
        var map = new Map();
        var base = new Scope(map);
        var age = base.computeData('age').compute;
        equal(age(), undefined, 'age is not set');
        age.bind('change', function (ev, newVal, oldVal) {
            equal(newVal, 31, 'newVal is provided correctly');
            equal(oldVal, undefined, 'oldVal is undefined');
        });
        age(31);
        equal(map.attr('age'), 31, 'maps age is set correctly');
    });
    test('backtrack path (#163)', function () {
        var row = new Map({ first: 'Justin' }), col = { format: 'str' }, base = new Scope(row), cur = base.add(col);
        equal(cur.peek('.'), col, 'got col');
        equal(cur.peek('..'), row, 'got row');
        equal(cur.peek('../first'), 'Justin', 'got row');
    });
    test('nested properties with compute', function () {
        var me = new Map({ name: { first: 'Justin' } });
        var cur = new Scope(me);
        var compute = cur.computeData('name.first').compute;
        var changes = 0;
        compute.bind('change', function (ev, newVal, oldVal) {
            if (changes === 0) {
                equal(oldVal, 'Justin');
                equal(newVal, 'Brian');
            } else if (changes === 1) {
                equal(oldVal, 'Brian');
                equal(newVal, undefined);
            } else if (changes === 2) {
                equal(oldVal, undefined);
                equal(newVal, 'Payal');
            } else if (changes === 3) {
                equal(oldVal, 'Payal');
                equal(newVal, 'Curtis');
            }
            changes++;
        });
        equal(compute(), 'Justin', 'read value after bind');
        me.attr('name.first', 'Brian');
        me.removeAttr('name');
        me.attr('name', { first: 'Payal' });
        me.attr('name', new Map({ first: 'Curtis' }));
    });
    test('function at the end', function () {
        var compute = new Scope({
            me: {
                info: function () {
                    return 'Justin';
                }
            }
        }).computeData('me.info').compute;
        equal(compute(), 'Justin');
        var fn = function () {
            return this.name;
        };
        var compute2 = new Scope({
            me: {
                info: fn,
                name: 'Hank'
            }
        }).computeData('me.info', {
            isArgument: true,
            args: []
        }).compute;
        equal(compute2()(), 'Hank');
    });
    test('binds to the right scope only', function () {
        var baseMap = new Map({ me: { name: { first: 'Justin' } } });
        var base = new Scope(baseMap);
        var topMap = new Map({ me: { name: {} } });
        var scope = base.add(topMap);
        var compute = scope.computeData('me.name.first').compute;
        compute.bind('change', function (ev, newVal, oldVal) {
            equal(oldVal, 'Justin');
            equal(newVal, 'Brian');
        });
        equal(compute(), 'Justin');
        topMap.attr('me.name.first', 'Payal');
        baseMap.attr('me.name.first', 'Brian');
    });
    test('Scope read returnObserveMethods=true', function () {
        var MapConstruct = Map.extend({
            foo: function (arg) {
                equal(this, data.map, 'correct this');
                equal(arg, true, 'correct arg');
            }
        });
        var data = { map: new MapConstruct() };
        var res = Scope.read(data, observeReader.reads('map.foo'), { isArgument: true });
        res.value(true);
    });
    test('rooted observable is able to update correctly', function () {
        var baseMap = new Map({ name: { first: 'Justin' } });
        var scope = new Scope(baseMap);
        var compute = scope.computeData('name.first').compute;
        equal(compute(), 'Justin');
        baseMap.attr('name', new Map({ first: 'Brian' }));
        equal(compute(), 'Brian');
    });
    test('computeData reading an object with a compute', function () {
        var sourceAge = 21;
        var age = compute(function (newVal) {
            if (newVal) {
                sourceAge = newVal;
            } else {
                return sourceAge;
            }
        });
        var scope = new Scope({ person: { age: age } });
        var computeData = scope.computeData('person.age');
        var value = computeData.compute();
        equal(value, 21, 'correct value');
        computeData.compute(31);
        equal(age(), 31, 'age updated');
    });
    test('computeData with initial empty compute (#638)', function () {
        expect(2);
        var c = compute();
        var scope = new Scope({ compute: c });
        var computeData = scope.computeData('compute');
        equal(computeData.compute(), undefined);
        computeData.compute.bind('change', function (ev, newVal) {
            equal(newVal, 'compute value');
        });
        c('compute value');
    });
    test('Can read static properties on constructors (#634)', function () {
        var Foo = Map.extend({ static_prop: 'baz' }, { proto_prop: 'thud' });
        var data = new Foo({ own_prop: 'quux' }), scope = new Scope(data);
        equal(scope.computeData('constructor.static_prop').compute(), 'baz', 'static prop');
    });
    test('Can read static properties on constructors (#634)', function () {
        var Foo = Map.extend({ static_prop: 'baz' }, { proto_prop: 'thud' });
        var data = new Foo({ own_prop: 'quux' }), scope = new Scope(data);
        equal(scope.computeData('constructor.static_prop').compute(), 'baz', 'static prop');
    });
    test('Scope lookup restricted to current scope with ./ (#874)', function () {
        var current;
        var scope = new Scope(new Map({ value: 'A Value' })).add(current = new Map({}));
        var compute = scope.computeData('./value').compute;
        equal(compute(), undefined, 'no initial value');
        compute.bind('change', function (ev, newVal) {
            equal(newVal, 'B Value', 'changed');
        });
        compute('B Value');
        equal(current.attr('value'), 'B Value', 'updated');
    });
    test('reading properties on undefined (#1314)', function () {
        var scope = new Scope(undefined);
        var compute = scope.compute('property');
        equal(compute(), undefined, 'got back undefined');
    });
    test('Scope attributes can be set (#1297, #1304)', function () {
        var comp = compute('Test');
        var map = new Map({ other: { name: 'Justin' } });
        var scope = new Scope({
            name: 'Matthew',
            other: {
                person: { name: 'David' },
                comp: comp
            }
        });
        scope.set('name', 'Wilbur');
        equal(scope.get('name'), 'Wilbur', 'Value updated');
        scope.set('other.person.name', 'Dave');
        equal(scope.get('other.person.name'), 'Dave', 'Value updated');
        scope.set('other.comp', 'Changed');
        equal(comp(), 'Changed', 'Compute updated');
        scope = new Scope(map);
        scope.set('other.name', 'Brian');
        equal(scope.get('other.name'), 'Brian', 'Value updated');
        equal(map.attr('other.name'), 'Brian', 'Name update in map');
    });
    test('computeData.compute get/sets computes in maps', function () {
        var cmpt = compute(4);
        var map = new Map();
        map.attr('computer', cmpt);
        var scope = new Scope(map);
        var computeData = scope.computeData('computer', {});
        equal(computeData.compute(), 4, 'got the value');
        computeData.compute(5);
        equal(cmpt(), 5, 'updated compute value');
        equal(computeData.compute(), 5, 'the compute has the right value');
    });
    test('computesData can find update when initially undefined parent scope becomes defined (#579)', function () {
        expect(2);
        var map = new Map();
        var scope = new Scope(map);
        var top = scope.add(new Map());
        var computeData = top.computeData('value', {});
        equal(computeData.compute(), undefined, 'initially undefined');
        computeData.compute.bind('change', function (ev, newVal) {
            equal(newVal, 'first');
        });
        map.attr('value', 'first');
    });
    test('A scope\'s %root is the last context', function () {
        var map = new Map();
        var refs = Scope.refsScope();
        var scope = refs.add(map).add(new Scope.Refs()).add(new Map());
        var root = scope.peek('%root');
        ok(!(root instanceof Scope.Refs), 'root isn\'t a reference');
        equal(root, map, 'The root is the map passed into the scope');
    });
    test('can set scope attributes with ../ (#2132)', function () {
        var map = new Map();
        var scope = new Scope(map);
        var top = scope.add(new Map());
        top.set('../foo', 'bar');
        equal(map.attr('foo'), 'bar');
    });
    test('can read parent context with ../ (#2244)', function () {
        var map = new Map();
        var scope = new Scope(map);
        var top = scope.add(new Map());
        equal(top.peek('../'), map, 'looked up value correctly');
    });
    test('trying to read constructor from refs scope is ok', function () {
        var map = new ReferenceMap();
        var construct = compute(function () {
            return map.attr('constructor');
        });
        construct.bind('change', function () {
        });
        equal(construct(), ReferenceMap);
    });
    test('reading from a string in a nested scope doesn\'t throw an error (#22)', function () {
        var foo = compute('foo');
        var bar = compute('bar');
        var scope = new Scope(foo);
        var localScope = scope.add(bar);
        equal(localScope.read('foo').value, undefined);
    });
    test('Optimize for compute().observableProperty (#29)', function () {
        var map = new Map({ value: 'a' });
        var wrap = compute(map);
        var scope = new Scope(wrap);
        var scopeKeyData = scope.computeData('value');
        var scopeCompute = scopeKeyData.compute;
        var changeNumber = 0;
        scopeCompute.on('change', function (ev, newVal, oldVal) {
            if (changeNumber === 1) {
                QUnit.equal(newVal, 'b');
                QUnit.equal(oldVal, 'a');
                QUnit.ok(scopeKeyData.fastPath, 'still fast path');
                changeNumber++;
                wrap(new Map({ value: 'c' }));
            } else if (changeNumber === 2) {
                QUnit.equal(newVal, 'c', 'got new value');
                QUnit.equal(oldVal, 'b', 'got old value');
                QUnit.notOk(scopeKeyData.fastPath, 'still fast path');
            }
        });
        QUnit.ok(scopeKeyData.fastPath, 'fast path');
        changeNumber++;
        map.attr('value', 'b');
    });
    test('read should support passing %scope (#24)', function () {
        var scope = new Scope(new Map({
            foo: '',
            bar: ''
        }));
        equal(scope.read('%scope').value, scope, 'looked up %scope correctly');
    });
    test('a compute can observe the ScopeKeyData', 2, function () {
        var map = new Map({
            value: 'a',
            other: 'b'
        });
        var wrap = compute(map);
        var scope = new Scope(wrap);
        var scopeKeyData = scope.computeData('value');
        var oldOnValue = scopeKeyData[canSymbol.for('can.onValue')];
        scopeKeyData[canSymbol.for('can.onValue')] = function () {
            QUnit.ok(true, 'bound on the scopeKeyData');
            return oldOnValue.apply(this, arguments);
        };
        var c = compute(function () {
            return scopeKeyData.getValue() + map.attr('other');
        });
        c.on('change', function (ev, newValue) {
            QUnit.equal(newValue, 'Ab');
        });
        map.attr('value', 'A');
    });
    QUnit.asyncTest('unbinding clears all event bindings', function () {
        var map = new Map({
            value: 'a',
            other: 'b'
        });
        var wrap = compute(map);
        var scope = new Scope(wrap);
        var scopeKeyData = scope.computeData('value');
        var c = compute(function () {
            return scopeKeyData.getValue() + map.attr('other');
        });
        var handlers = function (ev, newValue) {
            QUnit.equal(newValue, 'Ab');
        };
        c.on('change', handlers);
        c.off('change', handlers);
        setTimeout(function () {
            equal(map.__bindEvents._lifecycleBindings, 0, 'there are no bindings');
            start();
        }, 30);
    });
    QUnit.test('computes are read as this and . and  ../', function () {
        var value = compute(1);
        var scope = new Scope(value);
        QUnit.equal(scope.get('this'), 1, 'this read value');
        QUnit.equal(scope.get('.'), 1, '. read value');
        scope = scope.add({});
        QUnit.equal(scope.get('..'), 1, '.. read value');
    });
    QUnit.test('computes are set as this and . and  ../', function () {
        var value = compute(1);
        var scope = new Scope(value);
        scope.set('this', 2);
        QUnit.equal(scope.get('this'), 2, 'this read value');
        scope.set('.', 3);
        QUnit.equal(scope.get('this'), 3, '. read value');
        scope = scope.add({});
        scope.set('..', 4);
        QUnit.equal(scope.get('..'), 4, '.. read value');
    });
    QUnit.test('maps are set with this.foo and ./foo', function () {
        var map = compute(new Map({ value: 1 }));
        var scope = new Scope(map);
        scope.set('this.value', 2);
        QUnit.equal(scope.get('this.value'), 2, 'this read value');
        scope.set('./value', 3);
        QUnit.equal(scope.get('./value'), 3, '. read value');
    });
    QUnit.test('scopeKeyData fires during batch', function () {
        var map = new Map({
            value: 'a',
            other: 'b'
        });
        var scope = new Scope(map);
        var batchNum;
        map.on('value', function () {
            batchNum = canBatch.batchNum;
        });
        var scopeKeyData = scope.computeData('value');
        scopeKeyData[canSymbol.for('can.onValue')](function (value) {
            QUnit.equal(batchNum, canBatch.batchNum);
        });
        map.attr('value', 'A');
    });
    QUnit.test('setting a key on a non observable context', function () {
        var context = { colors: new List([]) };
        var scope = new Scope(context);
        scope.set('colors', ['red']);
        QUnit.deepEqual(context.colors.attr(), ['red'], 'can updateDeep');
    });
    QUnit.test('observing scope key data does not observe observation', function () {
        var map = new Map({ value: 'a' });
        var scope = new Scope(map);
        var computeData = scope.computeData('value');
        var oldOnValue = computeData.observation[canSymbol.for('can.onValue')];
        var bindCount = 0;
        computeData.observation[canSymbol.for('can.onValue')] = function () {
            bindCount++;
            return oldOnValue.apply(this, arguments);
        };
        var valueCompute = computeData.compute;
        var oldComputeOnValue = valueCompute.computeInstance[canSymbol.for('can.onValue')];
        valueCompute.computeInstance[canSymbol.for('can.onValue')] = function () {
            bindCount++;
            return oldComputeOnValue.apply(this, arguments);
        };
        var c = compute(function () {
            return valueCompute();
        });
        c.on('change', function () {
        });
        QUnit.equal(bindCount, 2, 'there should only be one event bound');
    });
});
/*can@3.9.0-pre.0#view/scope/scope_test*/
define('can@3.9.0-pre.0#view/scope/scope_test', function (require, exports, module) {
    require('can-view-scope/test/scope-test');
    require('can-view-scope/test/scope-define-test');
});
/*can-view-autorender@3.1.0#can-view-autorender_test*/
define('can-view-autorender@3.1.0#can-view-autorender_test', function (require, exports, module) {
    (function (__dirname) {
        var QUnit = require('steal-qunit');
        var makeIframe = function (src) {
            var iframe = document.createElement('iframe');
            window.removeMyself = function () {
                delete window.removeMyself;
                delete window.isReady;
                delete window.hasError;
                document.body.removeChild(iframe);
                start();
            };
            window.hasError = function (error) {
                ok(false, error.message || error);
                window.removeMyself();
            };
            document.body.appendChild(iframe);
            iframe.src = src;
        };
        var get = function (map, prop) {
            return map.attr ? map.attr(prop) : map.get(prop);
        };
        var makeBasicTestIframe = function (src) {
            var iframe = document.createElement('iframe');
            window.removeMyself = function () {
                delete window.removeMyself;
                delete window.isReady;
                delete window.hasError;
                document.body.removeChild(iframe);
                start();
            };
            window.hasError = function (error) {
                ok(false, error.message || error);
                window.removeMyself();
            };
            window.isReady = function (el, scope) {
                equal(el.length, 1, 'only one my-component');
                equal(el[0].innerHTML, 'Hello World', 'template rendered');
                equal(get(scope, 'message'), 'Hello World', 'Scope correctly setup');
                window.removeMyself();
            };
            document.body.appendChild(iframe);
            iframe.src = src;
        };
        QUnit.module('can-view-autorender');
        if (__dirname !== '/') {
            QUnit.asyncTest('the basics are able to work for steal', function () {
                makeBasicTestIframe(__dirname + '/test/basics.html?' + Math.random());
            });
            QUnit.asyncTest('autoload loads a jquery viewmodel fn', function () {
                makeIframe(__dirname + '/test/steal-viewmodel.html?' + Math.random());
            });
            QUnit.asyncTest('works with a can-define/map/map', function () {
                makeBasicTestIframe(__dirname + '/test/define.html?' + Math.random());
            });
        }
    }('/'));
});
/*can@3.9.0-pre.0#view/autorender/autorender_test*/
define('can@3.9.0-pre.0#view/autorender/autorender_test', function (require, exports, module) {
    require('can-view-autorender/can-view-autorender_test');
});
/*can-view-target@3.1.0#test/test*/
define('can-view-target@3.1.0#test/test', function (require, exports, module) {
    var target = require('can-view-target');
    var simpleDom = require('can-simple-dom');
    var QUnit = require('steal-qunit');
    var MUTATION_OBSERVER = require('can-util/dom/mutation-observer/mutation-observer');
    QUnit.module('can-view-target');
    test('basics', function () {
        var classCallback = function () {
                equal(this.nodeName.toLowerCase(), 'h1', 'class on the right element');
                this.className = 'selected';
            }, attributesCallback = function () {
                equal(this.nodeName.toLowerCase(), 'h1', 'attributes on the right element');
            }, textNodeCallback = function () {
                equal(this.nodeType, 3, 'got a text node');
                this.nodeValue = 'World';
            };
        var data = target([{
                tag: 'h1',
                attrs: {
                    'id': 'myh1',
                    'class': classCallback
                },
                attributes: [attributesCallback],
                children: [{
                        tag: 'span',
                        children: [
                            'Hello ',
                            textNodeCallback,
                            '!'
                        ]
                    }]
            }]);
        equal(data.clone.childNodes.length, 1, 'there is one child');
        var h1 = data.clone.childNodes[0];
        equal(h1.nodeName.toLowerCase(), 'h1', 'there is one h1');
        equal(h1.id, 'myh1', 'the h1 has the right id');
        equal(h1.childNodes.length, 1, 'the h1 has span');
        equal(h1.childNodes[0].childNodes.length, 3, 'the span has 3 children');
        deepEqual(data.paths, [{
                path: [0],
                callbacks: [
                    { callback: classCallback },
                    { callback: attributesCallback }
                ],
                paths: [{
                        path: [
                            0,
                            1
                        ],
                        callbacks: [{ callback: target.keepsTextNodes ? textNodeCallback : data.paths[0].paths[0].callbacks[0].callback }]
                    }]
            }]);
        var result = data.hydrate();
        var newH1 = result.childNodes[0];
        equal(newH1.className, 'selected', 'got selected class name');
        equal(newH1.innerHTML.toLowerCase(), '<span>hello world!</span>');
    });
    test('replacing items', function () {
        var data = target([
            function () {
                this.parentNode.insertBefore(document.createTextNode('inserted'), this.nextSibling);
            },
            'hi',
            function () {
                equal(this.previousSibling.nodeValue, 'hi', 'previous is as expected');
            }
        ]);
        data.hydrate();
    });
    test('comments', function () {
        var data = target([
            { tag: 'h1' },
            { comment: 'foo bar' }
        ]);
        var node = data.clone.childNodes[1];
        equal(node.nodeValue, 'foo bar', 'node value is right');
        equal(node.nodeType, 8, 'node is a comment');
    });
    test('paths should be run in reverse order (#966)', function () {
        var data = target([{
                tag: 'h1',
                attributes: [function () {
                    }],
                children: [
                    function () {
                        this.parentNode.insertBefore(document.createElement('div'), this.nextSibling);
                    },
                    {
                        tag: 'span',
                        children: [function () {
                                equal(this.nodeType, 3, 'got an element');
                            }]
                    }
                ]
            }]);
        data.hydrate();
    });
    test('renderToVirtualDOM', function () {
        var simpleDocument = new simpleDom.Document();
        var innerData = target([{ tag: 'span' }], simpleDocument);
        var outerData = target([{
                tag: 'h1',
                children: [
                    function (data) {
                        this.parentNode.insertBefore(innerData.hydrate(data), this);
                        this.parentNode.removeChild(this);
                    },
                    'foo'
                ]
            }], simpleDocument);
        var out = outerData.hydrate({ foo: true });
        equal(out.firstChild.nodeName, 'H1');
        equal(out.firstChild.firstChild.nodeName, 'SPAN');
        equal(out.firstChild.lastChild.nodeValue, 'foo');
    });
    test('cloneNode works in IE11', function () {
        var frag = document.createDocumentFragment();
        var text = document.createTextNode('some-text');
        var MO = MUTATION_OBSERVER();
        var observer;
        frag.appendChild(text);
        var clone = target.cloneNode(frag);
        equal(clone.childNodes.length, 1, 'cloneNode should work');
        if (MO) {
            observer = new MO(function (mutations) {
            });
            observer.observe(document.documentElement, {
                childList: true,
                subtree: true
            });
            clone = target.cloneNode(frag);
            equal(clone.childNodes.length, 1, 'cloneNode should work after creating MutationObserver');
        }
    });
});
/*can-simple-dom@1.0.10#test/support*/
define('can-simple-dom@1.0.10#test/support', [
    'exports',
    'can-simple-dom/simple-dom/document'
], function (exports, _document) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.document = undefined;
    exports.element = element;
    exports.fragment = fragment;
    exports.text = text;
    exports.comment = comment;
    var _document2 = _interopRequireDefault(_document);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    var root = typeof window !== 'undefined' ? window : global;
    var document = exports.document = undefined;
    exports.document = document = new _document2.default();
    function element(tagName, attrs) {
        var el = document.createElement(tagName);
        for (var key in attrs) {
            el.setAttribute(key, attrs[key]);
        }
        for (var i = 2; i < arguments.length; i++) {
            el.appendChild(arguments[i]);
        }
        return el;
    }
    function fragment() {
        var frag = document.createDocumentFragment();
        for (var i = 0; i < arguments.length; i++) {
            frag.appendChild(arguments[i]);
        }
        return frag;
    }
    function text(s) {
        return document.createTextNode(s);
    }
    function comment(s) {
        return document.createComment(s);
    }
});
/*can-simple-dom@1.0.10#test/element-test*/
define('can-simple-dom@1.0.10#test/element-test', [
    'can-simple-dom/simple-dom/document',
    'can-simple-dom/simple-dom/html-serializer',
    'can-simple-dom/simple-dom/void-map',
    './support',
    'steal-qunit'
], function (_document, _htmlSerializer, _voidMap, _support, _stealQunit) {
    'use strict';
    var _document2 = _interopRequireDefault(_document);
    var _htmlSerializer2 = _interopRequireDefault(_htmlSerializer);
    var _voidMap2 = _interopRequireDefault(_voidMap);
    var _stealQunit2 = _interopRequireDefault(_stealQunit);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    _stealQunit2.default.module('can-simple-dom - Element');
    _stealQunit2.default.test('appending a document fragment appends the fragment\'s children and not the fragment itself', function (assert) {
        var document = new _document2.default();
        var frag = document.createDocumentFragment();
        var elem = document.createElement('div');
        var body = document.body;
        assert.strictEqual(body.firstChild, null, 'body has no children');
        frag.appendChild(elem);
        body.appendChild(frag);
        assert.strictEqual(body.firstChild.tagName, 'DIV', 'fragment\'s child is added as child of document');
    });
    _stealQunit2.default.test('appending a document fragment (via insertBefore) appends the fragment\'s children and not the fragment itself', function (assert) {
        var document = new _document2.default();
        var frag = document.createDocumentFragment();
        var elem = document.createElement('div');
        var existing = document.createElement('main');
        var body = document.body;
        body.appendChild(existing);
        assert.strictEqual(body.firstChild.tagName, 'MAIN', 'sanity check: the main element was actually inserted');
        assert.strictEqual(body.lastChild.tagName, 'MAIN', 'sanity check: the main element was actually inserted');
        frag.appendChild(elem);
        body.insertBefore(frag, existing);
        assert.strictEqual(body.firstChild.tagName, 'DIV', 'The body\'s first child is now DIV');
        assert.strictEqual(body.lastChild.tagName, 'MAIN', 'The body\'s last child is now MAIN');
    });
    _stealQunit2.default.test('child nodes can be access via item()', function (assert) {
        var document = new _document2.default();
        var parent = document.createElement('div');
        var child1 = document.createElement('p');
        var child2 = document.createElement('img');
        assert.strictEqual(parent.childNodes.item(0), null, 'attempting to access an item that doesn\'t exist returns null');
        parent.appendChild(child1);
        parent.appendChild(child2);
        assert.strictEqual(parent.childNodes.item(0), child1);
        assert.strictEqual(parent.childNodes.item(1), child2);
        assert.strictEqual(parent.childNodes.item(2), null);
        parent.removeChild(child1);
        assert.strictEqual(parent.childNodes.item(0), child2);
        assert.strictEqual(parent.childNodes.item(1), null);
        parent.removeChild(child2);
        assert.strictEqual(parent.childNodes.item(0), null);
        assert.strictEqual(parent.childNodes.item(1), null);
    });
    _stealQunit2.default.test('insertBefore can insert before the last child node', function (assert) {
        var document = new _document2.default();
        var parent = document.createElement('div');
        var child1 = document.createElement('p');
        var child2 = document.createElement('img');
        var child3 = document.createElement('span');
        parent.appendChild(child1);
        parent.appendChild(child2);
        parent.insertBefore(child3, child2);
        assert.strictEqual(parent.childNodes.item(1), child3);
    });
    _stealQunit2.default.test('cloneNode(true) recursively clones nodes', function (assert) {
        var parent = (0, _support.element)('div');
        var child1 = (0, _support.element)('p');
        var child2 = (0, _support.element)('img', { src: 'hamster.png' });
        var child3 = (0, _support.element)('span');
        parent.appendChild(child1);
        parent.appendChild(child2);
        parent.appendChild(child3);
        var child11 = (0, _support.text)('hello');
        var child12 = (0, _support.element)('span');
        child12.appendChild((0, _support.text)(' world'));
        var child13 = (0, _support.text)('!');
        child1.appendChild(child11);
        child1.appendChild(child12);
        child1.appendChild(child13);
        var clone = parent.cloneNode(true);
        assert.notEqual(parent.firstChild, null);
        assert.notStrictEqual(clone.firstChild, parent.firstChild);
        var clone2 = parent.cloneNode(true);
        assert.notEqual(parent.firstChild, null);
        assert.notStrictEqual(clone2.firstChild, clone.firstChild);
        assert.notStrictEqual(clone2.firstChild, parent.firstChild);
        var actual = new _htmlSerializer2.default(_voidMap2.default).serialize((0, _support.fragment)(clone));
        assert.equal(actual, '<div><p>hello<span> world</span>!</p><img src="hamster.png"><span></span></div>');
    });
    _stealQunit2.default.test('anchor element is created successfully - micro-location works (see #11)', function (assert) {
        assert.expect(0);
        var document = new _document2.default();
        try {
            document.createElement('a');
        } catch (ex) {
            assert.ok(false, 'Anchor throws exception');
        }
    });
    _stealQunit2.default.test('style.cssText is two way bound to the style attribute (#13)', function (assert) {
        var document = new _document2.default();
        var el = document.createElement('div');
        el.style.cssText = 'color: green;';
        assert.equal(el.getAttribute('style'), 'color: green;');
    });
    _stealQunit2.default.test('replaceChild works', function (assert) {
        var document = new _document2.default();
        var parent = document.createElement('div');
        var one = document.createElement('p');
        var two = document.createElement('span');
        parent.appendChild(one);
        assert.equal(parent.firstChild.nodeName, 'P', 'first child is a p');
        var oldChild = parent.replaceChild(two, one);
        assert.equal(oldChild, one, 'correct return value');
        assert.equal(parent.firstChild.nodeName, 'SPAN', 'child is now the span');
    });
    _stealQunit2.default.test('Replacing the document\'s firstChild updates documentElement', function (assert) {
        var document = new _document2.default();
        var first = document.documentElement;
        var html = document.createElement('html');
        var head = document.createElement('head');
        var body = document.createElement('body');
        html.appendChild(head);
        html.appendChild(body);
        document.replaceChild(html, document.documentElement);
        assert.equal(document.documentElement, html, 'documentElement is updated');
        assert.equal(document.body, body, 'document.body is updated');
        assert.equal(document.head, head, 'document.head is updated');
    });
    _stealQunit2.default.test('setAttribute(\'class\', value) updates the className', function (assert) {
        var document = new _document2.default();
        var el = document.createElement('div');
        el.setAttribute('class', 'foo bar');
        assert.equal(el.className, 'foo bar', 'Element\'s className is same as the attribute class');
    });
    _stealQunit2.default.test('innerHTML does not parse the contents of SCRIPT and STYLE nodes', function (assert) {
        var document = new _document2.default();
        var div = document.createElement('div');
        var script = document.createElement('script');
        try {
            div.innerHTML = '<span>foo</span>';
            ok(0, 'should not make it here b/c no parser is shipped');
        } catch (ex) {
            ok(1, 'tried to parse content');
        }
        var jsCode = 'var foo = \'<span>bar</span>\';';
        try {
            script.innerHTML = jsCode;
            equal(script.firstChild, script.lastChild, 'script has one child');
            equal(script.firstChild.nodeType, 3, 'only child is a text node');
            equal(script.firstChild.nodeValue, jsCode, 'code matches');
        } catch (ex) {
            ok(0, 'should not cause an error');
        }
    });
    _stealQunit2.default.test('removeChild should return the removed node', function (assert) {
        var document = new _document2.default();
        var parent = document.createElement('div');
        var child = document.createElement('p');
        parent.appendChild(child);
        var removedNode = parent.removeChild(child);
        assert.strictEqual(removedNode, child, 'removeChild should return the removed node');
    });
    _stealQunit2.default.test('Input\'s type property is two-way bound to the attribute', function (assert) {
        var document = new _document2.default();
        var input = document.createElement('input');
        input.setAttribute('type', 'text');
        assert.equal(input.type, 'text');
        input.type = 'radio';
        assert.equal(input.type, 'radio');
        assert.equal(input.getAttribute('type'), 'radio');
    });
    _stealQunit2.default.test('Input\'s value property is two-way bound to the attribute', function (assert) {
        var document = new _document2.default();
        var input = document.createElement('input');
        input.setAttribute('value', 'foo');
        assert.equal(input.value, 'foo');
        input.value = 'bar';
        assert.equal(input.value, 'bar');
        assert.equal(input.getAttribute('value'), 'bar');
    });
    _stealQunit2.default.test('Input\'s checked value is two-way bound', function (assert) {
        var document = new _document2.default();
        var input = document.createElement('input');
        input.setAttribute('checked', '');
        assert.ok(input.checked);
        input.checked = false;
        assert.equal(input.hasAttribute('checked'), false);
        assert.equal(input.checked, false);
    });
    _stealQunit2.default.test('Select\'s value attribute is two-way bound', function (assert) {
        var document = new _document2.default();
        var select = document.createElement('select');
        select.setAttribute('value', 'foo');
        assert.equal(select.value, 'foo');
        select.value = 'bar';
        assert.equal(select.value, 'bar');
        assert.equal(select.getAttribute('value'), 'bar');
    });
    _stealQunit2.default.test('Option\'s value attribute is two-way bound', function (assert) {
        var document = new _document2.default();
        var option = document.createElement('option');
        option.setAttribute('value', 'foo');
        assert.equal(option.value, 'foo');
        option.value = 'bar';
        assert.equal(option.value, 'bar');
        assert.equal(option.getAttribute('value'), 'bar');
    });
    _stealQunit2.default.test('Option\'s selected value is tied to parent select\'s value', function (assert) {
        var document = new _document2.default();
        var select = document.createElement('select');
        var option = document.createElement('option');
        select.appendChild(option);
        select.value = 'foo';
        option.value = 'foo';
        assert.equal(option.selected, true);
        option.value = 'bar';
        assert.equal(option.selected, false);
        option.selected = true;
        assert.equal(select.value, 'bar');
    });
    _stealQunit2.default.test('option\'s selected property is configurable and enumerable', function (assert) {
        var document = new _document2.default();
        var option = document.createElement('option');
        var proto = Object.getPrototypeOf(option);
        var desc = Object.getOwnPropertyDescriptor(proto, 'selected');
        assert.equal(desc.enumerable, true, 'selected is enumerable');
        assert.equal(desc.configurable, true, 'selected is configurable');
    });
    _stealQunit2.default.test('The className property is configurable and enumerable', function (assert) {
        var document = new _document2.default();
        var option = document.createElement('some-el');
        var proto = Object.getPrototypeOf(option);
        var desc = Object.getOwnPropertyDescriptor(proto, 'className');
        assert.equal(desc.enumerable, true, 'selected is enumerable');
        assert.equal(desc.configurable, true, 'selected is configurable');
    });
    _stealQunit2.default.test('The innerHTML property is configurable and enumerable', function (assert) {
        var document = new _document2.default();
        var option = document.createElement('some-el');
        var proto = Object.getPrototypeOf(option);
        var desc = Object.getOwnPropertyDescriptor(proto, 'innerHTML');
        assert.equal(desc.enumerable, true, 'selected is enumerable');
        assert.equal(desc.configurable, true, 'selected is configurable');
    });
});
/*can-simple-dom@1.0.10#test/serializer-test*/
define('can-simple-dom@1.0.10#test/serializer-test', [
    './support',
    'can-simple-dom/simple-dom/html-serializer',
    'can-simple-dom/simple-dom/void-map',
    'steal-qunit'
], function (_support, _htmlSerializer, _voidMap, _stealQunit) {
    'use strict';
    var _htmlSerializer2 = _interopRequireDefault(_htmlSerializer);
    var _voidMap2 = _interopRequireDefault(_voidMap);
    var _stealQunit2 = _interopRequireDefault(_stealQunit);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    _stealQunit2.default.module('can-simple-dom - Serializer', {
        beforeEach: function beforeEach() {
            this.serializer = new _htmlSerializer2.default(_voidMap2.default);
        }
    });
    _stealQunit2.default.test('simple text', function (assert) {
        var actual = this.serializer.serialize((0, _support.fragment)((0, _support.text)('hello > world &amp; &nbsp;&nbsp; & goodbye')));
        assert.equal(actual, 'hello &gt; world &amp; &nbsp;&nbsp; &amp; goodbye');
    });
    _stealQunit2.default.test('serializes correctly', function (assert) {
        var actual = this.serializer.serialize((0, _support.fragment)((0, _support.element)('div', {
            id: 'foo',
            title: '&amp;&"'
        }, (0, _support.element)('b', {}, (0, _support.text)('Foo & Bar &amp; Baz < Buz > Biz \xA9')))));
        assert.equal(actual, '<div id="foo" title="&amp;&amp;&quot;"><b>Foo &amp; Bar &amp; Baz &lt; Buz &gt; Biz \xA9</b></div>');
    });
    _stealQunit2.default.test('serializes image correctly', function (assert) {
        var actual = this.serializer.serialize((0, _support.fragment)((0, _support.element)('img', { src: 'https://foo.com/foobar.jpg?foo=bar&bar=foo' })));
        assert.equal(actual, '<img src="https://foo.com/foobar.jpg?foo=bar&bar=foo">');
    });
    _stealQunit2.default.test('serializes textContent', function (assert) {
        var el, actual, frag;
        el = (0, _support.element)('div', {});
        el.textContent = 'hello world';
        actual = this.serializer.serialize((0, _support.fragment)(el));
        assert.equal(actual, '<div>hello world</div>');
    });
    _stealQunit2.default.test('correctly serializes code blocks', function (assert) {
        var el, actual, frag;
        el = (0, _support.element)('script', {});
        el.appendChild((0, _support.text)('<anonymous>'));
        actual = this.serializer.serialize((0, _support.fragment)(el));
        assert.equal(actual, '<script><anonymous></script>', 'script tag content serialized');
    });
});
/*simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/utils*/
define('simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/utils', ['exports'], function (exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.isSpace = isSpace;
    exports.isAlpha = isAlpha;
    exports.preprocessInput = preprocessInput;
    var WSP = /[\t\n\f ]/;
    var ALPHA = /[A-Za-z]/;
    var CRLF = /\r\n?/g;
    function isSpace(char) {
        return WSP.test(char);
    }
    function isAlpha(char) {
        return ALPHA.test(char);
    }
    function preprocessInput(input) {
        return input.replace(CRLF, '\n');
    }
});
/*simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/evented-tokenizer*/
define('simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/evented-tokenizer', [
    'exports',
    './utils'
], function (exports, _utils) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    function EventedTokenizer(delegate, entityParser) {
        this.delegate = delegate;
        this.entityParser = entityParser;
        this.state = null;
        this.input = null;
        this.index = -1;
        this.line = -1;
        this.column = -1;
        this.tagLine = -1;
        this.tagColumn = -1;
        this.reset();
    }
    EventedTokenizer.prototype = {
        reset: function reset() {
            this.state = 'beforeData';
            this.input = '';
            this.index = 0;
            this.line = 1;
            this.column = 0;
            this.tagLine = -1;
            this.tagColumn = -1;
            this.delegate.reset();
        },
        tokenize: function tokenize(input) {
            this.reset();
            this.tokenizePart(input);
            this.tokenizeEOF();
        },
        tokenizePart: function tokenizePart(input) {
            this.input += (0, _utils.preprocessInput)(input);
            while (this.index < this.input.length) {
                this.states[this.state].call(this);
            }
        },
        tokenizeEOF: function tokenizeEOF() {
            this.flushData();
        },
        flushData: function flushData() {
            if (this.state === 'data') {
                this.delegate.finishData();
                this.state = 'beforeData';
            }
        },
        peek: function peek() {
            return this.input.charAt(this.index);
        },
        consume: function consume() {
            var char = this.peek();
            this.index++;
            if (char === '\n') {
                this.line++;
                this.column = 0;
            } else {
                this.column++;
            }
            return char;
        },
        consumeCharRef: function consumeCharRef() {
            var endIndex = this.input.indexOf(';', this.index);
            if (endIndex === -1) {
                return;
            }
            var entity = this.input.slice(this.index, endIndex);
            var chars = this.entityParser.parse(entity);
            if (chars) {
                var count = entity.length;
                while (count) {
                    this.consume();
                    count--;
                }
                this.consume();
                return chars;
            }
        },
        markTagStart: function markTagStart() {
            this.tagLine = this.line;
            this.tagColumn = this.column;
            if (this.delegate.tagOpen) {
                this.delegate.tagOpen();
            }
        },
        states: {
            beforeData: function beforeData() {
                var char = this.peek();
                if (char === '<') {
                    this.state = 'tagOpen';
                    this.markTagStart();
                    this.consume();
                } else {
                    this.state = 'data';
                    this.delegate.beginData();
                }
            },
            data: function data() {
                var char = this.peek();
                if (char === '<') {
                    this.delegate.finishData();
                    this.state = 'tagOpen';
                    this.markTagStart();
                    this.consume();
                } else if (char === '&') {
                    this.consume();
                    this.delegate.appendToData(this.consumeCharRef() || '&');
                } else {
                    this.consume();
                    this.delegate.appendToData(char);
                }
            },
            tagOpen: function tagOpen() {
                var char = this.consume();
                if (char === '!') {
                    this.state = 'markupDeclaration';
                } else if (char === '/') {
                    this.state = 'endTagOpen';
                } else if ((0, _utils.isAlpha)(char)) {
                    this.state = 'tagName';
                    this.delegate.beginStartTag();
                    this.delegate.appendToTagName(char.toLowerCase());
                }
            },
            markupDeclaration: function markupDeclaration() {
                var char = this.consume();
                if (char === '-' && this.input.charAt(this.index) === '-') {
                    this.consume();
                    this.state = 'commentStart';
                    this.delegate.beginComment();
                }
            },
            commentStart: function commentStart() {
                var char = this.consume();
                if (char === '-') {
                    this.state = 'commentStartDash';
                } else if (char === '>') {
                    this.delegate.finishComment();
                    this.state = 'beforeData';
                } else {
                    this.delegate.appendToCommentData(char);
                    this.state = 'comment';
                }
            },
            commentStartDash: function commentStartDash() {
                var char = this.consume();
                if (char === '-') {
                    this.state = 'commentEnd';
                } else if (char === '>') {
                    this.delegate.finishComment();
                    this.state = 'beforeData';
                } else {
                    this.delegate.appendToCommentData('-');
                    this.state = 'comment';
                }
            },
            comment: function comment() {
                var char = this.consume();
                if (char === '-') {
                    this.state = 'commentEndDash';
                } else {
                    this.delegate.appendToCommentData(char);
                }
            },
            commentEndDash: function commentEndDash() {
                var char = this.consume();
                if (char === '-') {
                    this.state = 'commentEnd';
                } else {
                    this.delegate.appendToCommentData('-' + char);
                    this.state = 'comment';
                }
            },
            commentEnd: function commentEnd() {
                var char = this.consume();
                if (char === '>') {
                    this.delegate.finishComment();
                    this.state = 'beforeData';
                } else {
                    this.delegate.appendToCommentData('--' + char);
                    this.state = 'comment';
                }
            },
            tagName: function tagName() {
                var char = this.consume();
                if ((0, _utils.isSpace)(char)) {
                    this.state = 'beforeAttributeName';
                } else if (char === '/') {
                    this.state = 'selfClosingStartTag';
                } else if (char === '>') {
                    this.delegate.finishTag();
                    this.state = 'beforeData';
                } else {
                    this.delegate.appendToTagName(char);
                }
            },
            beforeAttributeName: function beforeAttributeName() {
                var char = this.peek();
                if ((0, _utils.isSpace)(char)) {
                    this.consume();
                    return;
                } else if (char === '/') {
                    this.state = 'selfClosingStartTag';
                    this.consume();
                } else if (char === '>') {
                    this.consume();
                    this.delegate.finishTag();
                    this.state = 'beforeData';
                } else {
                    this.state = 'attributeName';
                    this.delegate.beginAttribute();
                    this.consume();
                    this.delegate.appendToAttributeName(char);
                }
            },
            attributeName: function attributeName() {
                var char = this.peek();
                if ((0, _utils.isSpace)(char)) {
                    this.state = 'afterAttributeName';
                    this.consume();
                } else if (char === '/') {
                    this.delegate.beginAttributeValue(false);
                    this.delegate.finishAttributeValue();
                    this.consume();
                    this.state = 'selfClosingStartTag';
                } else if (char === '=') {
                    this.state = 'beforeAttributeValue';
                    this.consume();
                } else if (char === '>') {
                    this.delegate.beginAttributeValue(false);
                    this.delegate.finishAttributeValue();
                    this.consume();
                    this.delegate.finishTag();
                    this.state = 'beforeData';
                } else {
                    this.consume();
                    this.delegate.appendToAttributeName(char);
                }
            },
            afterAttributeName: function afterAttributeName() {
                var char = this.peek();
                if ((0, _utils.isSpace)(char)) {
                    this.consume();
                    return;
                } else if (char === '/') {
                    this.delegate.beginAttributeValue(false);
                    this.delegate.finishAttributeValue();
                    this.consume();
                    this.state = 'selfClosingStartTag';
                } else if (char === '=') {
                    this.consume();
                    this.state = 'beforeAttributeValue';
                } else if (char === '>') {
                    this.delegate.beginAttributeValue(false);
                    this.delegate.finishAttributeValue();
                    this.consume();
                    this.delegate.finishTag();
                    this.state = 'beforeData';
                } else {
                    this.delegate.beginAttributeValue(false);
                    this.delegate.finishAttributeValue();
                    this.consume();
                    this.state = 'attributeName';
                    this.delegate.beginAttribute();
                    this.delegate.appendToAttributeName(char);
                }
            },
            beforeAttributeValue: function beforeAttributeValue() {
                var char = this.peek();
                if ((0, _utils.isSpace)(char)) {
                    this.consume();
                } else if (char === '"') {
                    this.state = 'attributeValueDoubleQuoted';
                    this.delegate.beginAttributeValue(true);
                    this.consume();
                } else if (char === '\'') {
                    this.state = 'attributeValueSingleQuoted';
                    this.delegate.beginAttributeValue(true);
                    this.consume();
                } else if (char === '>') {
                    this.delegate.beginAttributeValue(false);
                    this.delegate.finishAttributeValue();
                    this.consume();
                    this.delegate.finishTag();
                    this.state = 'beforeData';
                } else {
                    this.state = 'attributeValueUnquoted';
                    this.delegate.beginAttributeValue(false);
                    this.consume();
                    this.delegate.appendToAttributeValue(char);
                }
            },
            attributeValueDoubleQuoted: function attributeValueDoubleQuoted() {
                var char = this.consume();
                if (char === '"') {
                    this.delegate.finishAttributeValue();
                    this.state = 'afterAttributeValueQuoted';
                } else if (char === '&') {
                    this.delegate.appendToAttributeValue(this.consumeCharRef('"') || '&');
                } else {
                    this.delegate.appendToAttributeValue(char);
                }
            },
            attributeValueSingleQuoted: function attributeValueSingleQuoted() {
                var char = this.consume();
                if (char === '\'') {
                    this.delegate.finishAttributeValue();
                    this.state = 'afterAttributeValueQuoted';
                } else if (char === '&') {
                    this.delegate.appendToAttributeValue(this.consumeCharRef('\'') || '&');
                } else {
                    this.delegate.appendToAttributeValue(char);
                }
            },
            attributeValueUnquoted: function attributeValueUnquoted() {
                var char = this.peek();
                if ((0, _utils.isSpace)(char)) {
                    this.delegate.finishAttributeValue();
                    this.consume();
                    this.state = 'beforeAttributeName';
                } else if (char === '&') {
                    this.consume();
                    this.delegate.appendToAttributeValue(this.consumeCharRef('>') || '&');
                } else if (char === '>') {
                    this.delegate.finishAttributeValue();
                    this.consume();
                    this.delegate.finishTag();
                    this.state = 'beforeData';
                } else {
                    this.consume();
                    this.delegate.appendToAttributeValue(char);
                }
            },
            afterAttributeValueQuoted: function afterAttributeValueQuoted() {
                var char = this.peek();
                if ((0, _utils.isSpace)(char)) {
                    this.consume();
                    this.state = 'beforeAttributeName';
                } else if (char === '/') {
                    this.consume();
                    this.state = 'selfClosingStartTag';
                } else if (char === '>') {
                    this.consume();
                    this.delegate.finishTag();
                    this.state = 'beforeData';
                } else {
                    this.state = 'beforeAttributeName';
                }
            },
            selfClosingStartTag: function selfClosingStartTag() {
                var char = this.peek();
                if (char === '>') {
                    this.consume();
                    this.delegate.markTagAsSelfClosing();
                    this.delegate.finishTag();
                    this.state = 'beforeData';
                } else {
                    this.state = 'beforeAttributeName';
                }
            },
            endTagOpen: function endTagOpen() {
                var char = this.consume();
                if ((0, _utils.isAlpha)(char)) {
                    this.state = 'tagName';
                    this.delegate.beginEndTag();
                    this.delegate.appendToTagName(char.toLowerCase());
                }
            }
        }
    };
    exports.default = EventedTokenizer;
});
/*simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/tokenizer*/
define('simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/tokenizer', [
    'exports',
    './evented-tokenizer'
], function (exports, _eventedTokenizer) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    var _eventedTokenizer2 = _interopRequireDefault(_eventedTokenizer);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    function Tokenizer(entityParser, options) {
        this.token = null;
        this.startLine = 1;
        this.startColumn = 0;
        this.options = options || {};
        this.tokenizer = new _eventedTokenizer2.default(this, entityParser);
    }
    Tokenizer.prototype = {
        tokenize: function tokenize(input) {
            this.tokens = [];
            this.tokenizer.tokenize(input);
            return this.tokens;
        },
        tokenizePart: function tokenizePart(input) {
            this.tokens = [];
            this.tokenizer.tokenizePart(input);
            return this.tokens;
        },
        tokenizeEOF: function tokenizeEOF() {
            this.tokens = [];
            this.tokenizer.tokenizeEOF();
            return this.tokens[0];
        },
        reset: function reset() {
            this.token = null;
            this.startLine = 1;
            this.startColumn = 0;
        },
        addLocInfo: function addLocInfo() {
            if (this.options.loc) {
                this.token.loc = {
                    start: {
                        line: this.startLine,
                        column: this.startColumn
                    },
                    end: {
                        line: this.tokenizer.line,
                        column: this.tokenizer.column
                    }
                };
            }
            this.startLine = this.tokenizer.line;
            this.startColumn = this.tokenizer.column;
        },
        beginData: function beginData() {
            this.token = {
                type: 'Chars',
                chars: ''
            };
            this.tokens.push(this.token);
        },
        appendToData: function appendToData(char) {
            this.token.chars += char;
        },
        finishData: function finishData() {
            this.addLocInfo();
        },
        beginComment: function beginComment() {
            this.token = {
                type: 'Comment',
                chars: ''
            };
            this.tokens.push(this.token);
        },
        appendToCommentData: function appendToCommentData(char) {
            this.token.chars += char;
        },
        finishComment: function finishComment() {
            this.addLocInfo();
        },
        beginStartTag: function beginStartTag() {
            this.token = {
                type: 'StartTag',
                tagName: '',
                attributes: [],
                selfClosing: false
            };
            this.tokens.push(this.token);
        },
        beginEndTag: function beginEndTag() {
            this.token = {
                type: 'EndTag',
                tagName: ''
            };
            this.tokens.push(this.token);
        },
        finishTag: function finishTag() {
            this.addLocInfo();
        },
        markTagAsSelfClosing: function markTagAsSelfClosing() {
            this.token.selfClosing = true;
        },
        appendToTagName: function appendToTagName(char) {
            this.token.tagName += char;
        },
        beginAttribute: function beginAttribute() {
            this._currentAttribute = [
                '',
                '',
                null
            ];
            this.token.attributes.push(this._currentAttribute);
        },
        appendToAttributeName: function appendToAttributeName(char) {
            this._currentAttribute[0] += char;
        },
        beginAttributeValue: function beginAttributeValue(isQuoted) {
            this._currentAttribute[2] = isQuoted;
        },
        appendToAttributeValue: function appendToAttributeValue(char) {
            this._currentAttribute[1] = this._currentAttribute[1] || '';
            this._currentAttribute[1] += char;
        },
        finishAttributeValue: function finishAttributeValue() {
        }
    };
    exports.default = Tokenizer;
});
/*simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/entity-parser*/
define('simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/entity-parser', ['exports'], function (exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    function EntityParser(named) {
        this.named = named;
    }
    var HEXCHARCODE = /^#[xX]([A-Fa-f0-9]+)$/;
    var CHARCODE = /^#([0-9]+)$/;
    var NAMED = /^([A-Za-z0-9]+)$/;
    EntityParser.prototype.parse = function (entity) {
        if (!entity) {
            return;
        }
        var matches = entity.match(HEXCHARCODE);
        if (matches) {
            return String.fromCharCode(parseInt(matches[1], 16));
        }
        matches = entity.match(CHARCODE);
        if (matches) {
            return String.fromCharCode(parseInt(matches[1], 10));
        }
        matches = entity.match(NAMED);
        if (matches) {
            return this.named[matches[1]];
        }
    };
    exports.default = EntityParser;
});
/*simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/html5-named-char-refs*/
define('simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/html5-named-char-refs', ['exports'], function (exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.default = {
        Aacute: 'Á',
        aacute: 'á',
        Abreve: 'Ă',
        abreve: 'ă',
        ac: '\u223E',
        acd: '\u223F',
        acE: '\u223E̳',
        Acirc: 'Â',
        acirc: 'â',
        acute: '\xB4',
        Acy: 'А',
        acy: 'а',
        AElig: 'Æ',
        aelig: 'æ',
        af: '\u2061',
        Afr: '\uD835\uDD04',
        afr: '\uD835\uDD1E',
        Agrave: 'À',
        agrave: 'à',
        alefsym: 'ℵ',
        aleph: 'ℵ',
        Alpha: 'Α',
        alpha: 'α',
        Amacr: 'Ā',
        amacr: 'ā',
        amalg: '\u2A3F',
        AMP: '&',
        amp: '&',
        And: '\u2A53',
        and: '\u2227',
        andand: '\u2A55',
        andd: '\u2A5C',
        andslope: '\u2A58',
        andv: '\u2A5A',
        ang: '\u2220',
        ange: '\u29A4',
        angle: '\u2220',
        angmsd: '\u2221',
        angmsdaa: '\u29A8',
        angmsdab: '\u29A9',
        angmsdac: '\u29AA',
        angmsdad: '\u29AB',
        angmsdae: '\u29AC',
        angmsdaf: '\u29AD',
        angmsdag: '\u29AE',
        angmsdah: '\u29AF',
        angrt: '\u221F',
        angrtvb: '\u22BE',
        angrtvbd: '\u299D',
        angsph: '\u2222',
        angst: 'Å',
        angzarr: '\u237C',
        Aogon: 'Ą',
        aogon: 'ą',
        Aopf: '\uD835\uDD38',
        aopf: '\uD835\uDD52',
        ap: '\u2248',
        apacir: '\u2A6F',
        apE: '\u2A70',
        ape: '\u224A',
        apid: '\u224B',
        apos: '\'',
        ApplyFunction: '\u2061',
        approx: '\u2248',
        approxeq: '\u224A',
        Aring: 'Å',
        aring: 'å',
        Ascr: '\uD835\uDC9C',
        ascr: '\uD835\uDCB6',
        Assign: '\u2254',
        ast: '*',
        asymp: '\u2248',
        asympeq: '\u224D',
        Atilde: 'Ã',
        atilde: 'ã',
        Auml: 'Ä',
        auml: 'ä',
        awconint: '\u2233',
        awint: '\u2A11',
        backcong: '\u224C',
        backepsilon: '\u03F6',
        backprime: '\u2035',
        backsim: '\u223D',
        backsimeq: '\u22CD',
        Backslash: '\u2216',
        Barv: '\u2AE7',
        barvee: '\u22BD',
        Barwed: '\u2306',
        barwed: '\u2305',
        barwedge: '\u2305',
        bbrk: '\u23B5',
        bbrktbrk: '\u23B6',
        bcong: '\u224C',
        Bcy: 'Б',
        bcy: 'б',
        bdquo: '\u201E',
        becaus: '\u2235',
        Because: '\u2235',
        because: '\u2235',
        bemptyv: '\u29B0',
        bepsi: '\u03F6',
        bernou: 'ℬ',
        Bernoullis: 'ℬ',
        Beta: 'Β',
        beta: 'β',
        beth: 'ℶ',
        between: '\u226C',
        Bfr: '\uD835\uDD05',
        bfr: '\uD835\uDD1F',
        bigcap: '\u22C2',
        bigcirc: '\u25EF',
        bigcup: '\u22C3',
        bigodot: '\u2A00',
        bigoplus: '\u2A01',
        bigotimes: '\u2A02',
        bigsqcup: '\u2A06',
        bigstar: '\u2605',
        bigtriangledown: '\u25BD',
        bigtriangleup: '\u25B3',
        biguplus: '\u2A04',
        bigvee: '\u22C1',
        bigwedge: '\u22C0',
        bkarow: '\u290D',
        blacklozenge: '\u29EB',
        blacksquare: '\u25AA',
        blacktriangle: '\u25B4',
        blacktriangledown: '\u25BE',
        blacktriangleleft: '\u25C2',
        blacktriangleright: '\u25B8',
        blank: '\u2423',
        blk12: '\u2592',
        blk14: '\u2591',
        blk34: '\u2593',
        block: '\u2588',
        bne: '=⃥',
        bnequiv: '\u2261⃥',
        bNot: '\u2AED',
        bnot: '\u2310',
        Bopf: '\uD835\uDD39',
        bopf: '\uD835\uDD53',
        bot: '\u22A5',
        bottom: '\u22A5',
        bowtie: '\u22C8',
        boxbox: '\u29C9',
        boxDL: '\u2557',
        boxDl: '\u2556',
        boxdL: '\u2555',
        boxdl: '\u2510',
        boxDR: '\u2554',
        boxDr: '\u2553',
        boxdR: '\u2552',
        boxdr: '\u250C',
        boxH: '\u2550',
        boxh: '\u2500',
        boxHD: '\u2566',
        boxHd: '\u2564',
        boxhD: '\u2565',
        boxhd: '\u252C',
        boxHU: '\u2569',
        boxHu: '\u2567',
        boxhU: '\u2568',
        boxhu: '\u2534',
        boxminus: '\u229F',
        boxplus: '\u229E',
        boxtimes: '\u22A0',
        boxUL: '\u255D',
        boxUl: '\u255C',
        boxuL: '\u255B',
        boxul: '\u2518',
        boxUR: '\u255A',
        boxUr: '\u2559',
        boxuR: '\u2558',
        boxur: '\u2514',
        boxV: '\u2551',
        boxv: '\u2502',
        boxVH: '\u256C',
        boxVh: '\u256B',
        boxvH: '\u256A',
        boxvh: '\u253C',
        boxVL: '\u2563',
        boxVl: '\u2562',
        boxvL: '\u2561',
        boxvl: '\u2524',
        boxVR: '\u2560',
        boxVr: '\u255F',
        boxvR: '\u255E',
        boxvr: '\u251C',
        bprime: '\u2035',
        Breve: '\u02D8',
        breve: '\u02D8',
        brvbar: '\xA6',
        Bscr: 'ℬ',
        bscr: '\uD835\uDCB7',
        bsemi: '\u204F',
        bsim: '\u223D',
        bsime: '\u22CD',
        bsol: '\\',
        bsolb: '\u29C5',
        bsolhsub: '\u27C8',
        bull: '\u2022',
        bullet: '\u2022',
        bump: '\u224E',
        bumpE: '\u2AAE',
        bumpe: '\u224F',
        Bumpeq: '\u224E',
        bumpeq: '\u224F',
        Cacute: 'Ć',
        cacute: 'ć',
        Cap: '\u22D2',
        cap: '\u2229',
        capand: '\u2A44',
        capbrcup: '\u2A49',
        capcap: '\u2A4B',
        capcup: '\u2A47',
        capdot: '\u2A40',
        CapitalDifferentialD: 'ⅅ',
        caps: '\u2229︀',
        caret: '\u2041',
        caron: 'ˇ',
        Cayleys: 'ℭ',
        ccaps: '\u2A4D',
        Ccaron: 'Č',
        ccaron: 'č',
        Ccedil: 'Ç',
        ccedil: 'ç',
        Ccirc: 'Ĉ',
        ccirc: 'ĉ',
        Cconint: '\u2230',
        ccups: '\u2A4C',
        ccupssm: '\u2A50',
        Cdot: 'Ċ',
        cdot: 'ċ',
        cedil: '\xB8',
        Cedilla: '\xB8',
        cemptyv: '\u29B2',
        cent: '\xA2',
        CenterDot: '\xB7',
        centerdot: '\xB7',
        Cfr: 'ℭ',
        cfr: '\uD835\uDD20',
        CHcy: 'Ч',
        chcy: 'ч',
        check: '\u2713',
        checkmark: '\u2713',
        Chi: 'Χ',
        chi: 'χ',
        cir: '\u25CB',
        circ: 'ˆ',
        circeq: '\u2257',
        circlearrowleft: '\u21BA',
        circlearrowright: '\u21BB',
        circledast: '\u229B',
        circledcirc: '\u229A',
        circleddash: '\u229D',
        CircleDot: '\u2299',
        circledR: '\xAE',
        circledS: '\u24C8',
        CircleMinus: '\u2296',
        CirclePlus: '\u2295',
        CircleTimes: '\u2297',
        cirE: '\u29C3',
        cire: '\u2257',
        cirfnint: '\u2A10',
        cirmid: '\u2AEF',
        cirscir: '\u29C2',
        ClockwiseContourIntegral: '\u2232',
        CloseCurlyDoubleQuote: '\u201D',
        CloseCurlyQuote: '\u2019',
        clubs: '\u2663',
        clubsuit: '\u2663',
        Colon: '\u2237',
        colon: ':',
        Colone: '\u2A74',
        colone: '\u2254',
        coloneq: '\u2254',
        comma: ',',
        commat: '@',
        comp: '\u2201',
        compfn: '\u2218',
        complement: '\u2201',
        complexes: 'ℂ',
        cong: '\u2245',
        congdot: '\u2A6D',
        Congruent: '\u2261',
        Conint: '\u222F',
        conint: '\u222E',
        ContourIntegral: '\u222E',
        Copf: 'ℂ',
        copf: '\uD835\uDD54',
        coprod: '\u2210',
        Coproduct: '\u2210',
        COPY: '\xA9',
        copy: '\xA9',
        copysr: '\u2117',
        CounterClockwiseContourIntegral: '\u2233',
        crarr: '\u21B5',
        Cross: '\u2A2F',
        cross: '\u2717',
        Cscr: '\uD835\uDC9E',
        cscr: '\uD835\uDCB8',
        csub: '\u2ACF',
        csube: '\u2AD1',
        csup: '\u2AD0',
        csupe: '\u2AD2',
        ctdot: '\u22EF',
        cudarrl: '\u2938',
        cudarrr: '\u2935',
        cuepr: '\u22DE',
        cuesc: '\u22DF',
        cularr: '\u21B6',
        cularrp: '\u293D',
        Cup: '\u22D3',
        cup: '\u222A',
        cupbrcap: '\u2A48',
        CupCap: '\u224D',
        cupcap: '\u2A46',
        cupcup: '\u2A4A',
        cupdot: '\u228D',
        cupor: '\u2A45',
        cups: '\u222A︀',
        curarr: '\u21B7',
        curarrm: '\u293C',
        curlyeqprec: '\u22DE',
        curlyeqsucc: '\u22DF',
        curlyvee: '\u22CE',
        curlywedge: '\u22CF',
        curren: '\xA4',
        curvearrowleft: '\u21B6',
        curvearrowright: '\u21B7',
        cuvee: '\u22CE',
        cuwed: '\u22CF',
        cwconint: '\u2232',
        cwint: '\u2231',
        cylcty: '\u232D',
        Dagger: '\u2021',
        dagger: '\u2020',
        daleth: 'ℸ',
        Darr: '\u21A1',
        dArr: '\u21D3',
        darr: '\u2193',
        dash: '\u2010',
        Dashv: '\u2AE4',
        dashv: '\u22A3',
        dbkarow: '\u290F',
        dblac: '\u02DD',
        Dcaron: 'Ď',
        dcaron: 'ď',
        Dcy: 'Д',
        dcy: 'д',
        DD: 'ⅅ',
        dd: 'ⅆ',
        ddagger: '\u2021',
        ddarr: '\u21CA',
        DDotrahd: '\u2911',
        ddotseq: '\u2A77',
        deg: '\xB0',
        Del: '\u2207',
        Delta: 'Δ',
        delta: 'δ',
        demptyv: '\u29B1',
        dfisht: '\u297F',
        Dfr: '\uD835\uDD07',
        dfr: '\uD835\uDD21',
        dHar: '\u2965',
        dharl: '\u21C3',
        dharr: '\u21C2',
        DiacriticalAcute: '\xB4',
        DiacriticalDot: '\u02D9',
        DiacriticalDoubleAcute: '\u02DD',
        DiacriticalGrave: '`',
        DiacriticalTilde: '\u02DC',
        diam: '\u22C4',
        Diamond: '\u22C4',
        diamond: '\u22C4',
        diamondsuit: '\u2666',
        diams: '\u2666',
        die: '\xA8',
        DifferentialD: 'ⅆ',
        digamma: 'ϝ',
        disin: '\u22F2',
        div: '\xF7',
        divide: '\xF7',
        divideontimes: '\u22C7',
        divonx: '\u22C7',
        DJcy: 'Ђ',
        djcy: 'ђ',
        dlcorn: '\u231E',
        dlcrop: '\u230D',
        dollar: '$',
        Dopf: '\uD835\uDD3B',
        dopf: '\uD835\uDD55',
        Dot: '\xA8',
        dot: '\u02D9',
        DotDot: '⃜',
        doteq: '\u2250',
        doteqdot: '\u2251',
        DotEqual: '\u2250',
        dotminus: '\u2238',
        dotplus: '\u2214',
        dotsquare: '\u22A1',
        doublebarwedge: '\u2306',
        DoubleContourIntegral: '\u222F',
        DoubleDot: '\xA8',
        DoubleDownArrow: '\u21D3',
        DoubleLeftArrow: '\u21D0',
        DoubleLeftRightArrow: '\u21D4',
        DoubleLeftTee: '\u2AE4',
        DoubleLongLeftArrow: '\u27F8',
        DoubleLongLeftRightArrow: '\u27FA',
        DoubleLongRightArrow: '\u27F9',
        DoubleRightArrow: '\u21D2',
        DoubleRightTee: '\u22A8',
        DoubleUpArrow: '\u21D1',
        DoubleUpDownArrow: '\u21D5',
        DoubleVerticalBar: '\u2225',
        DownArrow: '\u2193',
        Downarrow: '\u21D3',
        downarrow: '\u2193',
        DownArrowBar: '\u2913',
        DownArrowUpArrow: '\u21F5',
        DownBreve: '̑',
        downdownarrows: '\u21CA',
        downharpoonleft: '\u21C3',
        downharpoonright: '\u21C2',
        DownLeftRightVector: '\u2950',
        DownLeftTeeVector: '\u295E',
        DownLeftVector: '\u21BD',
        DownLeftVectorBar: '\u2956',
        DownRightTeeVector: '\u295F',
        DownRightVector: '\u21C1',
        DownRightVectorBar: '\u2957',
        DownTee: '\u22A4',
        DownTeeArrow: '\u21A7',
        drbkarow: '\u2910',
        drcorn: '\u231F',
        drcrop: '\u230C',
        Dscr: '\uD835\uDC9F',
        dscr: '\uD835\uDCB9',
        DScy: 'Ѕ',
        dscy: 'ѕ',
        dsol: '\u29F6',
        Dstrok: 'Đ',
        dstrok: 'đ',
        dtdot: '\u22F1',
        dtri: '\u25BF',
        dtrif: '\u25BE',
        duarr: '\u21F5',
        duhar: '\u296F',
        dwangle: '\u29A6',
        DZcy: 'Џ',
        dzcy: 'џ',
        dzigrarr: '\u27FF',
        Eacute: 'É',
        eacute: 'é',
        easter: '\u2A6E',
        Ecaron: 'Ě',
        ecaron: 'ě',
        ecir: '\u2256',
        Ecirc: 'Ê',
        ecirc: 'ê',
        ecolon: '\u2255',
        Ecy: 'Э',
        ecy: 'э',
        eDDot: '\u2A77',
        Edot: 'Ė',
        eDot: '\u2251',
        edot: 'ė',
        ee: 'ⅇ',
        efDot: '\u2252',
        Efr: '\uD835\uDD08',
        efr: '\uD835\uDD22',
        eg: '\u2A9A',
        Egrave: 'È',
        egrave: 'è',
        egs: '\u2A96',
        egsdot: '\u2A98',
        el: '\u2A99',
        Element: '\u2208',
        elinters: '\u23E7',
        ell: 'ℓ',
        els: '\u2A95',
        elsdot: '\u2A97',
        Emacr: 'Ē',
        emacr: 'ē',
        empty: '\u2205',
        emptyset: '\u2205',
        EmptySmallSquare: '\u25FB',
        emptyv: '\u2205',
        EmptyVerySmallSquare: '\u25AB',
        emsp: '\u2003',
        emsp13: '\u2004',
        emsp14: '\u2005',
        ENG: 'Ŋ',
        eng: 'ŋ',
        ensp: '\u2002',
        Eogon: 'Ę',
        eogon: 'ę',
        Eopf: '\uD835\uDD3C',
        eopf: '\uD835\uDD56',
        epar: '\u22D5',
        eparsl: '\u29E3',
        eplus: '\u2A71',
        epsi: 'ε',
        Epsilon: 'Ε',
        epsilon: 'ε',
        epsiv: 'ϵ',
        eqcirc: '\u2256',
        eqcolon: '\u2255',
        eqsim: '\u2242',
        eqslantgtr: '\u2A96',
        eqslantless: '\u2A95',
        Equal: '\u2A75',
        equals: '=',
        EqualTilde: '\u2242',
        equest: '\u225F',
        Equilibrium: '\u21CC',
        equiv: '\u2261',
        equivDD: '\u2A78',
        eqvparsl: '\u29E5',
        erarr: '\u2971',
        erDot: '\u2253',
        Escr: 'ℰ',
        escr: 'ℯ',
        esdot: '\u2250',
        Esim: '\u2A73',
        esim: '\u2242',
        Eta: 'Η',
        eta: 'η',
        ETH: 'Ð',
        eth: 'ð',
        Euml: 'Ë',
        euml: 'ë',
        euro: '\u20AC',
        excl: '!',
        exist: '\u2203',
        Exists: '\u2203',
        expectation: 'ℰ',
        ExponentialE: 'ⅇ',
        exponentiale: 'ⅇ',
        fallingdotseq: '\u2252',
        Fcy: 'Ф',
        fcy: 'ф',
        female: '\u2640',
        ffilig: 'ﬃ',
        fflig: 'ﬀ',
        ffllig: 'ﬄ',
        Ffr: '\uD835\uDD09',
        ffr: '\uD835\uDD23',
        filig: 'ﬁ',
        FilledSmallSquare: '\u25FC',
        FilledVerySmallSquare: '\u25AA',
        fjlig: 'fj',
        flat: '\u266D',
        fllig: 'ﬂ',
        fltns: '\u25B1',
        fnof: 'ƒ',
        Fopf: '\uD835\uDD3D',
        fopf: '\uD835\uDD57',
        ForAll: '\u2200',
        forall: '\u2200',
        fork: '\u22D4',
        forkv: '\u2AD9',
        Fouriertrf: 'ℱ',
        fpartint: '\u2A0D',
        frac12: '\xBD',
        frac13: '\u2153',
        frac14: '\xBC',
        frac15: '\u2155',
        frac16: '\u2159',
        frac18: '\u215B',
        frac23: '\u2154',
        frac25: '\u2156',
        frac34: '\xBE',
        frac35: '\u2157',
        frac38: '\u215C',
        frac45: '\u2158',
        frac56: '\u215A',
        frac58: '\u215D',
        frac78: '\u215E',
        frasl: '\u2044',
        frown: '\u2322',
        Fscr: 'ℱ',
        fscr: '\uD835\uDCBB',
        gacute: 'ǵ',
        Gamma: 'Γ',
        gamma: 'γ',
        Gammad: 'Ϝ',
        gammad: 'ϝ',
        gap: '\u2A86',
        Gbreve: 'Ğ',
        gbreve: 'ğ',
        Gcedil: 'Ģ',
        Gcirc: 'Ĝ',
        gcirc: 'ĝ',
        Gcy: 'Г',
        gcy: 'г',
        Gdot: 'Ġ',
        gdot: 'ġ',
        gE: '\u2267',
        ge: '\u2265',
        gEl: '\u2A8C',
        gel: '\u22DB',
        geq: '\u2265',
        geqq: '\u2267',
        geqslant: '\u2A7E',
        ges: '\u2A7E',
        gescc: '\u2AA9',
        gesdot: '\u2A80',
        gesdoto: '\u2A82',
        gesdotol: '\u2A84',
        gesl: '\u22DB︀',
        gesles: '\u2A94',
        Gfr: '\uD835\uDD0A',
        gfr: '\uD835\uDD24',
        Gg: '\u22D9',
        gg: '\u226B',
        ggg: '\u22D9',
        gimel: 'ℷ',
        GJcy: 'Ѓ',
        gjcy: 'ѓ',
        gl: '\u2277',
        gla: '\u2AA5',
        glE: '\u2A92',
        glj: '\u2AA4',
        gnap: '\u2A8A',
        gnapprox: '\u2A8A',
        gnE: '\u2269',
        gne: '\u2A88',
        gneq: '\u2A88',
        gneqq: '\u2269',
        gnsim: '\u22E7',
        Gopf: '\uD835\uDD3E',
        gopf: '\uD835\uDD58',
        grave: '`',
        GreaterEqual: '\u2265',
        GreaterEqualLess: '\u22DB',
        GreaterFullEqual: '\u2267',
        GreaterGreater: '\u2AA2',
        GreaterLess: '\u2277',
        GreaterSlantEqual: '\u2A7E',
        GreaterTilde: '\u2273',
        Gscr: '\uD835\uDCA2',
        gscr: 'ℊ',
        gsim: '\u2273',
        gsime: '\u2A8E',
        gsiml: '\u2A90',
        GT: '>',
        Gt: '\u226B',
        gt: '>',
        gtcc: '\u2AA7',
        gtcir: '\u2A7A',
        gtdot: '\u22D7',
        gtlPar: '\u2995',
        gtquest: '\u2A7C',
        gtrapprox: '\u2A86',
        gtrarr: '\u2978',
        gtrdot: '\u22D7',
        gtreqless: '\u22DB',
        gtreqqless: '\u2A8C',
        gtrless: '\u2277',
        gtrsim: '\u2273',
        gvertneqq: '\u2269︀',
        gvnE: '\u2269︀',
        Hacek: 'ˇ',
        hairsp: '\u200A',
        half: '\xBD',
        hamilt: 'ℋ',
        HARDcy: 'Ъ',
        hardcy: 'ъ',
        hArr: '\u21D4',
        harr: '\u2194',
        harrcir: '\u2948',
        harrw: '\u21AD',
        Hat: '^',
        hbar: 'ℏ',
        Hcirc: 'Ĥ',
        hcirc: 'ĥ',
        hearts: '\u2665',
        heartsuit: '\u2665',
        hellip: '\u2026',
        hercon: '\u22B9',
        Hfr: 'ℌ',
        hfr: '\uD835\uDD25',
        HilbertSpace: 'ℋ',
        hksearow: '\u2925',
        hkswarow: '\u2926',
        hoarr: '\u21FF',
        homtht: '\u223B',
        hookleftarrow: '\u21A9',
        hookrightarrow: '\u21AA',
        Hopf: 'ℍ',
        hopf: '\uD835\uDD59',
        horbar: '\u2015',
        HorizontalLine: '\u2500',
        Hscr: 'ℋ',
        hscr: '\uD835\uDCBD',
        hslash: 'ℏ',
        Hstrok: 'Ħ',
        hstrok: 'ħ',
        HumpDownHump: '\u224E',
        HumpEqual: '\u224F',
        hybull: '\u2043',
        hyphen: '\u2010',
        Iacute: 'Í',
        iacute: 'í',
        ic: '\u2063',
        Icirc: 'Î',
        icirc: 'î',
        Icy: 'И',
        icy: 'и',
        Idot: 'İ',
        IEcy: 'Е',
        iecy: 'е',
        iexcl: '\xA1',
        iff: '\u21D4',
        Ifr: 'ℑ',
        ifr: '\uD835\uDD26',
        Igrave: 'Ì',
        igrave: 'ì',
        ii: 'ⅈ',
        iiiint: '\u2A0C',
        iiint: '\u222D',
        iinfin: '\u29DC',
        iiota: '\u2129',
        IJlig: 'Ĳ',
        ijlig: 'ĳ',
        Im: 'ℑ',
        Imacr: 'Ī',
        imacr: 'ī',
        image: 'ℑ',
        ImaginaryI: 'ⅈ',
        imagline: 'ℐ',
        imagpart: 'ℑ',
        imath: 'ı',
        imof: '\u22B7',
        imped: 'Ƶ',
        Implies: '\u21D2',
        in: '\u2208',
        incare: '\u2105',
        infin: '\u221E',
        infintie: '\u29DD',
        inodot: 'ı',
        Int: '\u222C',
        int: '\u222B',
        intcal: '\u22BA',
        integers: 'ℤ',
        Integral: '\u222B',
        intercal: '\u22BA',
        Intersection: '\u22C2',
        intlarhk: '\u2A17',
        intprod: '\u2A3C',
        InvisibleComma: '\u2063',
        InvisibleTimes: '\u2062',
        IOcy: 'Ё',
        iocy: 'ё',
        Iogon: 'Į',
        iogon: 'į',
        Iopf: '\uD835\uDD40',
        iopf: '\uD835\uDD5A',
        Iota: 'Ι',
        iota: 'ι',
        iprod: '\u2A3C',
        iquest: '\xBF',
        Iscr: 'ℐ',
        iscr: '\uD835\uDCBE',
        isin: '\u2208',
        isindot: '\u22F5',
        isinE: '\u22F9',
        isins: '\u22F4',
        isinsv: '\u22F3',
        isinv: '\u2208',
        it: '\u2062',
        Itilde: 'Ĩ',
        itilde: 'ĩ',
        Iukcy: 'І',
        iukcy: 'і',
        Iuml: 'Ï',
        iuml: 'ï',
        Jcirc: 'Ĵ',
        jcirc: 'ĵ',
        Jcy: 'Й',
        jcy: 'й',
        Jfr: '\uD835\uDD0D',
        jfr: '\uD835\uDD27',
        jmath: 'ȷ',
        Jopf: '\uD835\uDD41',
        jopf: '\uD835\uDD5B',
        Jscr: '\uD835\uDCA5',
        jscr: '\uD835\uDCBF',
        Jsercy: 'Ј',
        jsercy: 'ј',
        Jukcy: 'Є',
        jukcy: 'є',
        Kappa: 'Κ',
        kappa: 'κ',
        kappav: 'ϰ',
        Kcedil: 'Ķ',
        kcedil: 'ķ',
        Kcy: 'К',
        kcy: 'к',
        Kfr: '\uD835\uDD0E',
        kfr: '\uD835\uDD28',
        kgreen: 'ĸ',
        KHcy: 'Х',
        khcy: 'х',
        KJcy: 'Ќ',
        kjcy: 'ќ',
        Kopf: '\uD835\uDD42',
        kopf: '\uD835\uDD5C',
        Kscr: '\uD835\uDCA6',
        kscr: '\uD835\uDCC0',
        lAarr: '\u21DA',
        Lacute: 'Ĺ',
        lacute: 'ĺ',
        laemptyv: '\u29B4',
        lagran: 'ℒ',
        Lambda: 'Λ',
        lambda: 'λ',
        Lang: '\u27EA',
        lang: '\u27E8',
        langd: '\u2991',
        langle: '\u27E8',
        lap: '\u2A85',
        Laplacetrf: 'ℒ',
        laquo: '\xAB',
        Larr: '\u219E',
        lArr: '\u21D0',
        larr: '\u2190',
        larrb: '\u21E4',
        larrbfs: '\u291F',
        larrfs: '\u291D',
        larrhk: '\u21A9',
        larrlp: '\u21AB',
        larrpl: '\u2939',
        larrsim: '\u2973',
        larrtl: '\u21A2',
        lat: '\u2AAB',
        lAtail: '\u291B',
        latail: '\u2919',
        late: '\u2AAD',
        lates: '\u2AAD︀',
        lBarr: '\u290E',
        lbarr: '\u290C',
        lbbrk: '\u2772',
        lbrace: '{',
        lbrack: '[',
        lbrke: '\u298B',
        lbrksld: '\u298F',
        lbrkslu: '\u298D',
        Lcaron: 'Ľ',
        lcaron: 'ľ',
        Lcedil: 'Ļ',
        lcedil: 'ļ',
        lceil: '\u2308',
        lcub: '{',
        Lcy: 'Л',
        lcy: 'л',
        ldca: '\u2936',
        ldquo: '\u201C',
        ldquor: '\u201E',
        ldrdhar: '\u2967',
        ldrushar: '\u294B',
        ldsh: '\u21B2',
        lE: '\u2266',
        le: '\u2264',
        LeftAngleBracket: '\u27E8',
        LeftArrow: '\u2190',
        Leftarrow: '\u21D0',
        leftarrow: '\u2190',
        LeftArrowBar: '\u21E4',
        LeftArrowRightArrow: '\u21C6',
        leftarrowtail: '\u21A2',
        LeftCeiling: '\u2308',
        LeftDoubleBracket: '\u27E6',
        LeftDownTeeVector: '\u2961',
        LeftDownVector: '\u21C3',
        LeftDownVectorBar: '\u2959',
        LeftFloor: '\u230A',
        leftharpoondown: '\u21BD',
        leftharpoonup: '\u21BC',
        leftleftarrows: '\u21C7',
        LeftRightArrow: '\u2194',
        Leftrightarrow: '\u21D4',
        leftrightarrow: '\u2194',
        leftrightarrows: '\u21C6',
        leftrightharpoons: '\u21CB',
        leftrightsquigarrow: '\u21AD',
        LeftRightVector: '\u294E',
        LeftTee: '\u22A3',
        LeftTeeArrow: '\u21A4',
        LeftTeeVector: '\u295A',
        leftthreetimes: '\u22CB',
        LeftTriangle: '\u22B2',
        LeftTriangleBar: '\u29CF',
        LeftTriangleEqual: '\u22B4',
        LeftUpDownVector: '\u2951',
        LeftUpTeeVector: '\u2960',
        LeftUpVector: '\u21BF',
        LeftUpVectorBar: '\u2958',
        LeftVector: '\u21BC',
        LeftVectorBar: '\u2952',
        lEg: '\u2A8B',
        leg: '\u22DA',
        leq: '\u2264',
        leqq: '\u2266',
        leqslant: '\u2A7D',
        les: '\u2A7D',
        lescc: '\u2AA8',
        lesdot: '\u2A7F',
        lesdoto: '\u2A81',
        lesdotor: '\u2A83',
        lesg: '\u22DA︀',
        lesges: '\u2A93',
        lessapprox: '\u2A85',
        lessdot: '\u22D6',
        lesseqgtr: '\u22DA',
        lesseqqgtr: '\u2A8B',
        LessEqualGreater: '\u22DA',
        LessFullEqual: '\u2266',
        LessGreater: '\u2276',
        lessgtr: '\u2276',
        LessLess: '\u2AA1',
        lesssim: '\u2272',
        LessSlantEqual: '\u2A7D',
        LessTilde: '\u2272',
        lfisht: '\u297C',
        lfloor: '\u230A',
        Lfr: '\uD835\uDD0F',
        lfr: '\uD835\uDD29',
        lg: '\u2276',
        lgE: '\u2A91',
        lHar: '\u2962',
        lhard: '\u21BD',
        lharu: '\u21BC',
        lharul: '\u296A',
        lhblk: '\u2584',
        LJcy: 'Љ',
        ljcy: 'љ',
        Ll: '\u22D8',
        ll: '\u226A',
        llarr: '\u21C7',
        llcorner: '\u231E',
        Lleftarrow: '\u21DA',
        llhard: '\u296B',
        lltri: '\u25FA',
        Lmidot: 'Ŀ',
        lmidot: 'ŀ',
        lmoust: '\u23B0',
        lmoustache: '\u23B0',
        lnap: '\u2A89',
        lnapprox: '\u2A89',
        lnE: '\u2268',
        lne: '\u2A87',
        lneq: '\u2A87',
        lneqq: '\u2268',
        lnsim: '\u22E6',
        loang: '\u27EC',
        loarr: '\u21FD',
        lobrk: '\u27E6',
        LongLeftArrow: '\u27F5',
        Longleftarrow: '\u27F8',
        longleftarrow: '\u27F5',
        LongLeftRightArrow: '\u27F7',
        Longleftrightarrow: '\u27FA',
        longleftrightarrow: '\u27F7',
        longmapsto: '\u27FC',
        LongRightArrow: '\u27F6',
        Longrightarrow: '\u27F9',
        longrightarrow: '\u27F6',
        looparrowleft: '\u21AB',
        looparrowright: '\u21AC',
        lopar: '\u2985',
        Lopf: '\uD835\uDD43',
        lopf: '\uD835\uDD5D',
        loplus: '\u2A2D',
        lotimes: '\u2A34',
        lowast: '\u2217',
        lowbar: '_',
        LowerLeftArrow: '\u2199',
        LowerRightArrow: '\u2198',
        loz: '\u25CA',
        lozenge: '\u25CA',
        lozf: '\u29EB',
        lpar: '(',
        lparlt: '\u2993',
        lrarr: '\u21C6',
        lrcorner: '\u231F',
        lrhar: '\u21CB',
        lrhard: '\u296D',
        lrm: '\u200E',
        lrtri: '\u22BF',
        lsaquo: '\u2039',
        Lscr: 'ℒ',
        lscr: '\uD835\uDCC1',
        Lsh: '\u21B0',
        lsh: '\u21B0',
        lsim: '\u2272',
        lsime: '\u2A8D',
        lsimg: '\u2A8F',
        lsqb: '[',
        lsquo: '\u2018',
        lsquor: '\u201A',
        Lstrok: 'Ł',
        lstrok: 'ł',
        LT: '<',
        Lt: '\u226A',
        lt: '<',
        ltcc: '\u2AA6',
        ltcir: '\u2A79',
        ltdot: '\u22D6',
        lthree: '\u22CB',
        ltimes: '\u22C9',
        ltlarr: '\u2976',
        ltquest: '\u2A7B',
        ltri: '\u25C3',
        ltrie: '\u22B4',
        ltrif: '\u25C2',
        ltrPar: '\u2996',
        lurdshar: '\u294A',
        luruhar: '\u2966',
        lvertneqq: '\u2268︀',
        lvnE: '\u2268︀',
        macr: '\xAF',
        male: '\u2642',
        malt: '\u2720',
        maltese: '\u2720',
        Map: '\u2905',
        map: '\u21A6',
        mapsto: '\u21A6',
        mapstodown: '\u21A7',
        mapstoleft: '\u21A4',
        mapstoup: '\u21A5',
        marker: '\u25AE',
        mcomma: '\u2A29',
        Mcy: 'М',
        mcy: 'м',
        mdash: '\u2014',
        mDDot: '\u223A',
        measuredangle: '\u2221',
        MediumSpace: '\u205F',
        Mellintrf: 'ℳ',
        Mfr: '\uD835\uDD10',
        mfr: '\uD835\uDD2A',
        mho: '\u2127',
        micro: 'µ',
        mid: '\u2223',
        midast: '*',
        midcir: '\u2AF0',
        middot: '\xB7',
        minus: '\u2212',
        minusb: '\u229F',
        minusd: '\u2238',
        minusdu: '\u2A2A',
        MinusPlus: '\u2213',
        mlcp: '\u2ADB',
        mldr: '\u2026',
        mnplus: '\u2213',
        models: '\u22A7',
        Mopf: '\uD835\uDD44',
        mopf: '\uD835\uDD5E',
        mp: '\u2213',
        Mscr: 'ℳ',
        mscr: '\uD835\uDCC2',
        mstpos: '\u223E',
        Mu: 'Μ',
        mu: 'μ',
        multimap: '\u22B8',
        mumap: '\u22B8',
        nabla: '\u2207',
        Nacute: 'Ń',
        nacute: 'ń',
        nang: '\u2220⃒',
        nap: '\u2249',
        napE: '\u2A70̸',
        napid: '\u224B̸',
        napos: 'ŉ',
        napprox: '\u2249',
        natur: '\u266E',
        natural: '\u266E',
        naturals: 'ℕ',
        nbsp: '\xA0',
        nbump: '\u224E̸',
        nbumpe: '\u224F̸',
        ncap: '\u2A43',
        Ncaron: 'Ň',
        ncaron: 'ň',
        Ncedil: 'Ņ',
        ncedil: 'ņ',
        ncong: '\u2247',
        ncongdot: '\u2A6D̸',
        ncup: '\u2A42',
        Ncy: 'Н',
        ncy: 'н',
        ndash: '\u2013',
        ne: '\u2260',
        nearhk: '\u2924',
        neArr: '\u21D7',
        nearr: '\u2197',
        nearrow: '\u2197',
        nedot: '\u2250̸',
        NegativeMediumSpace: '\u200B',
        NegativeThickSpace: '\u200B',
        NegativeThinSpace: '\u200B',
        NegativeVeryThinSpace: '\u200B',
        nequiv: '\u2262',
        nesear: '\u2928',
        nesim: '\u2242̸',
        NestedGreaterGreater: '\u226B',
        NestedLessLess: '\u226A',
        NewLine: '\n',
        nexist: '\u2204',
        nexists: '\u2204',
        Nfr: '\uD835\uDD11',
        nfr: '\uD835\uDD2B',
        ngE: '\u2267̸',
        nge: '\u2271',
        ngeq: '\u2271',
        ngeqq: '\u2267̸',
        ngeqslant: '\u2A7E̸',
        nges: '\u2A7E̸',
        nGg: '\u22D9̸',
        ngsim: '\u2275',
        nGt: '\u226B⃒',
        ngt: '\u226F',
        ngtr: '\u226F',
        nGtv: '\u226B̸',
        nhArr: '\u21CE',
        nharr: '\u21AE',
        nhpar: '\u2AF2',
        ni: '\u220B',
        nis: '\u22FC',
        nisd: '\u22FA',
        niv: '\u220B',
        NJcy: 'Њ',
        njcy: 'њ',
        nlArr: '\u21CD',
        nlarr: '\u219A',
        nldr: '\u2025',
        nlE: '\u2266̸',
        nle: '\u2270',
        nLeftarrow: '\u21CD',
        nleftarrow: '\u219A',
        nLeftrightarrow: '\u21CE',
        nleftrightarrow: '\u21AE',
        nleq: '\u2270',
        nleqq: '\u2266̸',
        nleqslant: '\u2A7D̸',
        nles: '\u2A7D̸',
        nless: '\u226E',
        nLl: '\u22D8̸',
        nlsim: '\u2274',
        nLt: '\u226A⃒',
        nlt: '\u226E',
        nltri: '\u22EA',
        nltrie: '\u22EC',
        nLtv: '\u226A̸',
        nmid: '\u2224',
        NoBreak: '\u2060',
        NonBreakingSpace: '\xA0',
        Nopf: 'ℕ',
        nopf: '\uD835\uDD5F',
        Not: '\u2AEC',
        not: '\xAC',
        NotCongruent: '\u2262',
        NotCupCap: '\u226D',
        NotDoubleVerticalBar: '\u2226',
        NotElement: '\u2209',
        NotEqual: '\u2260',
        NotEqualTilde: '\u2242̸',
        NotExists: '\u2204',
        NotGreater: '\u226F',
        NotGreaterEqual: '\u2271',
        NotGreaterFullEqual: '\u2267̸',
        NotGreaterGreater: '\u226B̸',
        NotGreaterLess: '\u2279',
        NotGreaterSlantEqual: '\u2A7E̸',
        NotGreaterTilde: '\u2275',
        NotHumpDownHump: '\u224E̸',
        NotHumpEqual: '\u224F̸',
        notin: '\u2209',
        notindot: '\u22F5̸',
        notinE: '\u22F9̸',
        notinva: '\u2209',
        notinvb: '\u22F7',
        notinvc: '\u22F6',
        NotLeftTriangle: '\u22EA',
        NotLeftTriangleBar: '\u29CF̸',
        NotLeftTriangleEqual: '\u22EC',
        NotLess: '\u226E',
        NotLessEqual: '\u2270',
        NotLessGreater: '\u2278',
        NotLessLess: '\u226A̸',
        NotLessSlantEqual: '\u2A7D̸',
        NotLessTilde: '\u2274',
        NotNestedGreaterGreater: '\u2AA2̸',
        NotNestedLessLess: '\u2AA1̸',
        notni: '\u220C',
        notniva: '\u220C',
        notnivb: '\u22FE',
        notnivc: '\u22FD',
        NotPrecedes: '\u2280',
        NotPrecedesEqual: '\u2AAF̸',
        NotPrecedesSlantEqual: '\u22E0',
        NotReverseElement: '\u220C',
        NotRightTriangle: '\u22EB',
        NotRightTriangleBar: '\u29D0̸',
        NotRightTriangleEqual: '\u22ED',
        NotSquareSubset: '\u228F̸',
        NotSquareSubsetEqual: '\u22E2',
        NotSquareSuperset: '\u2290̸',
        NotSquareSupersetEqual: '\u22E3',
        NotSubset: '\u2282⃒',
        NotSubsetEqual: '\u2288',
        NotSucceeds: '\u2281',
        NotSucceedsEqual: '\u2AB0̸',
        NotSucceedsSlantEqual: '\u22E1',
        NotSucceedsTilde: '\u227F̸',
        NotSuperset: '\u2283⃒',
        NotSupersetEqual: '\u2289',
        NotTilde: '\u2241',
        NotTildeEqual: '\u2244',
        NotTildeFullEqual: '\u2247',
        NotTildeTilde: '\u2249',
        NotVerticalBar: '\u2224',
        npar: '\u2226',
        nparallel: '\u2226',
        nparsl: '\u2AFD⃥',
        npart: '\u2202̸',
        npolint: '\u2A14',
        npr: '\u2280',
        nprcue: '\u22E0',
        npre: '\u2AAF̸',
        nprec: '\u2280',
        npreceq: '\u2AAF̸',
        nrArr: '\u21CF',
        nrarr: '\u219B',
        nrarrc: '\u2933̸',
        nrarrw: '\u219D̸',
        nRightarrow: '\u21CF',
        nrightarrow: '\u219B',
        nrtri: '\u22EB',
        nrtrie: '\u22ED',
        nsc: '\u2281',
        nsccue: '\u22E1',
        nsce: '\u2AB0̸',
        Nscr: '\uD835\uDCA9',
        nscr: '\uD835\uDCC3',
        nshortmid: '\u2224',
        nshortparallel: '\u2226',
        nsim: '\u2241',
        nsime: '\u2244',
        nsimeq: '\u2244',
        nsmid: '\u2224',
        nspar: '\u2226',
        nsqsube: '\u22E2',
        nsqsupe: '\u22E3',
        nsub: '\u2284',
        nsubE: '\u2AC5̸',
        nsube: '\u2288',
        nsubset: '\u2282⃒',
        nsubseteq: '\u2288',
        nsubseteqq: '\u2AC5̸',
        nsucc: '\u2281',
        nsucceq: '\u2AB0̸',
        nsup: '\u2285',
        nsupE: '\u2AC6̸',
        nsupe: '\u2289',
        nsupset: '\u2283⃒',
        nsupseteq: '\u2289',
        nsupseteqq: '\u2AC6̸',
        ntgl: '\u2279',
        Ntilde: 'Ñ',
        ntilde: 'ñ',
        ntlg: '\u2278',
        ntriangleleft: '\u22EA',
        ntrianglelefteq: '\u22EC',
        ntriangleright: '\u22EB',
        ntrianglerighteq: '\u22ED',
        Nu: 'Ν',
        nu: 'ν',
        num: '#',
        numero: '\u2116',
        numsp: '\u2007',
        nvap: '\u224D⃒',
        nVDash: '\u22AF',
        nVdash: '\u22AE',
        nvDash: '\u22AD',
        nvdash: '\u22AC',
        nvge: '\u2265⃒',
        nvgt: '>⃒',
        nvHarr: '\u2904',
        nvinfin: '\u29DE',
        nvlArr: '\u2902',
        nvle: '\u2264⃒',
        nvlt: '<⃒',
        nvltrie: '\u22B4⃒',
        nvrArr: '\u2903',
        nvrtrie: '\u22B5⃒',
        nvsim: '\u223C⃒',
        nwarhk: '\u2923',
        nwArr: '\u21D6',
        nwarr: '\u2196',
        nwarrow: '\u2196',
        nwnear: '\u2927',
        Oacute: 'Ó',
        oacute: 'ó',
        oast: '\u229B',
        ocir: '\u229A',
        Ocirc: 'Ô',
        ocirc: 'ô',
        Ocy: 'О',
        ocy: 'о',
        odash: '\u229D',
        Odblac: 'Ő',
        odblac: 'ő',
        odiv: '\u2A38',
        odot: '\u2299',
        odsold: '\u29BC',
        OElig: 'Œ',
        oelig: 'œ',
        ofcir: '\u29BF',
        Ofr: '\uD835\uDD12',
        ofr: '\uD835\uDD2C',
        ogon: '\u02DB',
        Ograve: 'Ò',
        ograve: 'ò',
        ogt: '\u29C1',
        ohbar: '\u29B5',
        ohm: 'Ω',
        oint: '\u222E',
        olarr: '\u21BA',
        olcir: '\u29BE',
        olcross: '\u29BB',
        oline: '\u203E',
        olt: '\u29C0',
        Omacr: 'Ō',
        omacr: 'ō',
        Omega: 'Ω',
        omega: 'ω',
        Omicron: 'Ο',
        omicron: 'ο',
        omid: '\u29B6',
        ominus: '\u2296',
        Oopf: '\uD835\uDD46',
        oopf: '\uD835\uDD60',
        opar: '\u29B7',
        OpenCurlyDoubleQuote: '\u201C',
        OpenCurlyQuote: '\u2018',
        operp: '\u29B9',
        oplus: '\u2295',
        Or: '\u2A54',
        or: '\u2228',
        orarr: '\u21BB',
        ord: '\u2A5D',
        order: 'ℴ',
        orderof: 'ℴ',
        ordf: 'ª',
        ordm: 'º',
        origof: '\u22B6',
        oror: '\u2A56',
        orslope: '\u2A57',
        orv: '\u2A5B',
        oS: '\u24C8',
        Oscr: '\uD835\uDCAA',
        oscr: 'ℴ',
        Oslash: 'Ø',
        oslash: 'ø',
        osol: '\u2298',
        Otilde: 'Õ',
        otilde: 'õ',
        Otimes: '\u2A37',
        otimes: '\u2297',
        otimesas: '\u2A36',
        Ouml: 'Ö',
        ouml: 'ö',
        ovbar: '\u233D',
        OverBar: '\u203E',
        OverBrace: '\u23DE',
        OverBracket: '\u23B4',
        OverParenthesis: '\u23DC',
        par: '\u2225',
        para: '\xB6',
        parallel: '\u2225',
        parsim: '\u2AF3',
        parsl: '\u2AFD',
        part: '\u2202',
        PartialD: '\u2202',
        Pcy: 'П',
        pcy: 'п',
        percnt: '%',
        period: '.',
        permil: '\u2030',
        perp: '\u22A5',
        pertenk: '\u2031',
        Pfr: '\uD835\uDD13',
        pfr: '\uD835\uDD2D',
        Phi: 'Φ',
        phi: 'φ',
        phiv: 'ϕ',
        phmmat: 'ℳ',
        phone: '\u260E',
        Pi: 'Π',
        pi: 'π',
        pitchfork: '\u22D4',
        piv: 'ϖ',
        planck: 'ℏ',
        planckh: 'ℎ',
        plankv: 'ℏ',
        plus: '+',
        plusacir: '\u2A23',
        plusb: '\u229E',
        pluscir: '\u2A22',
        plusdo: '\u2214',
        plusdu: '\u2A25',
        pluse: '\u2A72',
        PlusMinus: '\xB1',
        plusmn: '\xB1',
        plussim: '\u2A26',
        plustwo: '\u2A27',
        pm: '\xB1',
        Poincareplane: 'ℌ',
        pointint: '\u2A15',
        Popf: 'ℙ',
        popf: '\uD835\uDD61',
        pound: '\xA3',
        Pr: '\u2ABB',
        pr: '\u227A',
        prap: '\u2AB7',
        prcue: '\u227C',
        prE: '\u2AB3',
        pre: '\u2AAF',
        prec: '\u227A',
        precapprox: '\u2AB7',
        preccurlyeq: '\u227C',
        Precedes: '\u227A',
        PrecedesEqual: '\u2AAF',
        PrecedesSlantEqual: '\u227C',
        PrecedesTilde: '\u227E',
        preceq: '\u2AAF',
        precnapprox: '\u2AB9',
        precneqq: '\u2AB5',
        precnsim: '\u22E8',
        precsim: '\u227E',
        Prime: '\u2033',
        prime: '\u2032',
        primes: 'ℙ',
        prnap: '\u2AB9',
        prnE: '\u2AB5',
        prnsim: '\u22E8',
        prod: '\u220F',
        Product: '\u220F',
        profalar: '\u232E',
        profline: '\u2312',
        profsurf: '\u2313',
        prop: '\u221D',
        Proportion: '\u2237',
        Proportional: '\u221D',
        propto: '\u221D',
        prsim: '\u227E',
        prurel: '\u22B0',
        Pscr: '\uD835\uDCAB',
        pscr: '\uD835\uDCC5',
        Psi: 'Ψ',
        psi: 'ψ',
        puncsp: '\u2008',
        Qfr: '\uD835\uDD14',
        qfr: '\uD835\uDD2E',
        qint: '\u2A0C',
        Qopf: 'ℚ',
        qopf: '\uD835\uDD62',
        qprime: '\u2057',
        Qscr: '\uD835\uDCAC',
        qscr: '\uD835\uDCC6',
        quaternions: 'ℍ',
        quatint: '\u2A16',
        quest: '?',
        questeq: '\u225F',
        QUOT: '"',
        quot: '"',
        rAarr: '\u21DB',
        race: '\u223Ḏ',
        Racute: 'Ŕ',
        racute: 'ŕ',
        radic: '\u221A',
        raemptyv: '\u29B3',
        Rang: '\u27EB',
        rang: '\u27E9',
        rangd: '\u2992',
        range: '\u29A5',
        rangle: '\u27E9',
        raquo: '\xBB',
        Rarr: '\u21A0',
        rArr: '\u21D2',
        rarr: '\u2192',
        rarrap: '\u2975',
        rarrb: '\u21E5',
        rarrbfs: '\u2920',
        rarrc: '\u2933',
        rarrfs: '\u291E',
        rarrhk: '\u21AA',
        rarrlp: '\u21AC',
        rarrpl: '\u2945',
        rarrsim: '\u2974',
        Rarrtl: '\u2916',
        rarrtl: '\u21A3',
        rarrw: '\u219D',
        rAtail: '\u291C',
        ratail: '\u291A',
        ratio: '\u2236',
        rationals: 'ℚ',
        RBarr: '\u2910',
        rBarr: '\u290F',
        rbarr: '\u290D',
        rbbrk: '\u2773',
        rbrace: '}',
        rbrack: ']',
        rbrke: '\u298C',
        rbrksld: '\u298E',
        rbrkslu: '\u2990',
        Rcaron: 'Ř',
        rcaron: 'ř',
        Rcedil: 'Ŗ',
        rcedil: 'ŗ',
        rceil: '\u2309',
        rcub: '}',
        Rcy: 'Р',
        rcy: 'р',
        rdca: '\u2937',
        rdldhar: '\u2969',
        rdquo: '\u201D',
        rdquor: '\u201D',
        rdsh: '\u21B3',
        Re: 'ℜ',
        real: 'ℜ',
        realine: 'ℛ',
        realpart: 'ℜ',
        reals: 'ℝ',
        rect: '\u25AD',
        REG: '\xAE',
        reg: '\xAE',
        ReverseElement: '\u220B',
        ReverseEquilibrium: '\u21CB',
        ReverseUpEquilibrium: '\u296F',
        rfisht: '\u297D',
        rfloor: '\u230B',
        Rfr: 'ℜ',
        rfr: '\uD835\uDD2F',
        rHar: '\u2964',
        rhard: '\u21C1',
        rharu: '\u21C0',
        rharul: '\u296C',
        Rho: 'Ρ',
        rho: 'ρ',
        rhov: 'ϱ',
        RightAngleBracket: '\u27E9',
        RightArrow: '\u2192',
        Rightarrow: '\u21D2',
        rightarrow: '\u2192',
        RightArrowBar: '\u21E5',
        RightArrowLeftArrow: '\u21C4',
        rightarrowtail: '\u21A3',
        RightCeiling: '\u2309',
        RightDoubleBracket: '\u27E7',
        RightDownTeeVector: '\u295D',
        RightDownVector: '\u21C2',
        RightDownVectorBar: '\u2955',
        RightFloor: '\u230B',
        rightharpoondown: '\u21C1',
        rightharpoonup: '\u21C0',
        rightleftarrows: '\u21C4',
        rightleftharpoons: '\u21CC',
        rightrightarrows: '\u21C9',
        rightsquigarrow: '\u219D',
        RightTee: '\u22A2',
        RightTeeArrow: '\u21A6',
        RightTeeVector: '\u295B',
        rightthreetimes: '\u22CC',
        RightTriangle: '\u22B3',
        RightTriangleBar: '\u29D0',
        RightTriangleEqual: '\u22B5',
        RightUpDownVector: '\u294F',
        RightUpTeeVector: '\u295C',
        RightUpVector: '\u21BE',
        RightUpVectorBar: '\u2954',
        RightVector: '\u21C0',
        RightVectorBar: '\u2953',
        ring: '\u02DA',
        risingdotseq: '\u2253',
        rlarr: '\u21C4',
        rlhar: '\u21CC',
        rlm: '\u200F',
        rmoust: '\u23B1',
        rmoustache: '\u23B1',
        rnmid: '\u2AEE',
        roang: '\u27ED',
        roarr: '\u21FE',
        robrk: '\u27E7',
        ropar: '\u2986',
        Ropf: 'ℝ',
        ropf: '\uD835\uDD63',
        roplus: '\u2A2E',
        rotimes: '\u2A35',
        RoundImplies: '\u2970',
        rpar: ')',
        rpargt: '\u2994',
        rppolint: '\u2A12',
        rrarr: '\u21C9',
        Rrightarrow: '\u21DB',
        rsaquo: '\u203A',
        Rscr: 'ℛ',
        rscr: '\uD835\uDCC7',
        Rsh: '\u21B1',
        rsh: '\u21B1',
        rsqb: ']',
        rsquo: '\u2019',
        rsquor: '\u2019',
        rthree: '\u22CC',
        rtimes: '\u22CA',
        rtri: '\u25B9',
        rtrie: '\u22B5',
        rtrif: '\u25B8',
        rtriltri: '\u29CE',
        RuleDelayed: '\u29F4',
        ruluhar: '\u2968',
        rx: '\u211E',
        Sacute: 'Ś',
        sacute: 'ś',
        sbquo: '\u201A',
        Sc: '\u2ABC',
        sc: '\u227B',
        scap: '\u2AB8',
        Scaron: 'Š',
        scaron: 'š',
        sccue: '\u227D',
        scE: '\u2AB4',
        sce: '\u2AB0',
        Scedil: 'Ş',
        scedil: 'ş',
        Scirc: 'Ŝ',
        scirc: 'ŝ',
        scnap: '\u2ABA',
        scnE: '\u2AB6',
        scnsim: '\u22E9',
        scpolint: '\u2A13',
        scsim: '\u227F',
        Scy: 'С',
        scy: 'с',
        sdot: '\u22C5',
        sdotb: '\u22A1',
        sdote: '\u2A66',
        searhk: '\u2925',
        seArr: '\u21D8',
        searr: '\u2198',
        searrow: '\u2198',
        sect: '\xA7',
        semi: ';',
        seswar: '\u2929',
        setminus: '\u2216',
        setmn: '\u2216',
        sext: '\u2736',
        Sfr: '\uD835\uDD16',
        sfr: '\uD835\uDD30',
        sfrown: '\u2322',
        sharp: '\u266F',
        SHCHcy: 'Щ',
        shchcy: 'щ',
        SHcy: 'Ш',
        shcy: 'ш',
        ShortDownArrow: '\u2193',
        ShortLeftArrow: '\u2190',
        shortmid: '\u2223',
        shortparallel: '\u2225',
        ShortRightArrow: '\u2192',
        ShortUpArrow: '\u2191',
        shy: '\xAD',
        Sigma: 'Σ',
        sigma: 'σ',
        sigmaf: 'ς',
        sigmav: 'ς',
        sim: '\u223C',
        simdot: '\u2A6A',
        sime: '\u2243',
        simeq: '\u2243',
        simg: '\u2A9E',
        simgE: '\u2AA0',
        siml: '\u2A9D',
        simlE: '\u2A9F',
        simne: '\u2246',
        simplus: '\u2A24',
        simrarr: '\u2972',
        slarr: '\u2190',
        SmallCircle: '\u2218',
        smallsetminus: '\u2216',
        smashp: '\u2A33',
        smeparsl: '\u29E4',
        smid: '\u2223',
        smile: '\u2323',
        smt: '\u2AAA',
        smte: '\u2AAC',
        smtes: '\u2AAC︀',
        SOFTcy: 'Ь',
        softcy: 'ь',
        sol: '/',
        solb: '\u29C4',
        solbar: '\u233F',
        Sopf: '\uD835\uDD4A',
        sopf: '\uD835\uDD64',
        spades: '\u2660',
        spadesuit: '\u2660',
        spar: '\u2225',
        sqcap: '\u2293',
        sqcaps: '\u2293︀',
        sqcup: '\u2294',
        sqcups: '\u2294︀',
        Sqrt: '\u221A',
        sqsub: '\u228F',
        sqsube: '\u2291',
        sqsubset: '\u228F',
        sqsubseteq: '\u2291',
        sqsup: '\u2290',
        sqsupe: '\u2292',
        sqsupset: '\u2290',
        sqsupseteq: '\u2292',
        squ: '\u25A1',
        Square: '\u25A1',
        square: '\u25A1',
        SquareIntersection: '\u2293',
        SquareSubset: '\u228F',
        SquareSubsetEqual: '\u2291',
        SquareSuperset: '\u2290',
        SquareSupersetEqual: '\u2292',
        SquareUnion: '\u2294',
        squarf: '\u25AA',
        squf: '\u25AA',
        srarr: '\u2192',
        Sscr: '\uD835\uDCAE',
        sscr: '\uD835\uDCC8',
        ssetmn: '\u2216',
        ssmile: '\u2323',
        sstarf: '\u22C6',
        Star: '\u22C6',
        star: '\u2606',
        starf: '\u2605',
        straightepsilon: 'ϵ',
        straightphi: 'ϕ',
        strns: '\xAF',
        Sub: '\u22D0',
        sub: '\u2282',
        subdot: '\u2ABD',
        subE: '\u2AC5',
        sube: '\u2286',
        subedot: '\u2AC3',
        submult: '\u2AC1',
        subnE: '\u2ACB',
        subne: '\u228A',
        subplus: '\u2ABF',
        subrarr: '\u2979',
        Subset: '\u22D0',
        subset: '\u2282',
        subseteq: '\u2286',
        subseteqq: '\u2AC5',
        SubsetEqual: '\u2286',
        subsetneq: '\u228A',
        subsetneqq: '\u2ACB',
        subsim: '\u2AC7',
        subsub: '\u2AD5',
        subsup: '\u2AD3',
        succ: '\u227B',
        succapprox: '\u2AB8',
        succcurlyeq: '\u227D',
        Succeeds: '\u227B',
        SucceedsEqual: '\u2AB0',
        SucceedsSlantEqual: '\u227D',
        SucceedsTilde: '\u227F',
        succeq: '\u2AB0',
        succnapprox: '\u2ABA',
        succneqq: '\u2AB6',
        succnsim: '\u22E9',
        succsim: '\u227F',
        SuchThat: '\u220B',
        Sum: '\u2211',
        sum: '\u2211',
        sung: '\u266A',
        Sup: '\u22D1',
        sup: '\u2283',
        sup1: '\xB9',
        sup2: '\xB2',
        sup3: '\xB3',
        supdot: '\u2ABE',
        supdsub: '\u2AD8',
        supE: '\u2AC6',
        supe: '\u2287',
        supedot: '\u2AC4',
        Superset: '\u2283',
        SupersetEqual: '\u2287',
        suphsol: '\u27C9',
        suphsub: '\u2AD7',
        suplarr: '\u297B',
        supmult: '\u2AC2',
        supnE: '\u2ACC',
        supne: '\u228B',
        supplus: '\u2AC0',
        Supset: '\u22D1',
        supset: '\u2283',
        supseteq: '\u2287',
        supseteqq: '\u2AC6',
        supsetneq: '\u228B',
        supsetneqq: '\u2ACC',
        supsim: '\u2AC8',
        supsub: '\u2AD4',
        supsup: '\u2AD6',
        swarhk: '\u2926',
        swArr: '\u21D9',
        swarr: '\u2199',
        swarrow: '\u2199',
        swnwar: '\u292A',
        szlig: 'ß',
        Tab: '\t',
        target: '\u2316',
        Tau: 'Τ',
        tau: 'τ',
        tbrk: '\u23B4',
        Tcaron: 'Ť',
        tcaron: 'ť',
        Tcedil: 'Ţ',
        tcedil: 'ţ',
        Tcy: 'Т',
        tcy: 'т',
        tdot: '⃛',
        telrec: '\u2315',
        Tfr: '\uD835\uDD17',
        tfr: '\uD835\uDD31',
        there4: '\u2234',
        Therefore: '\u2234',
        therefore: '\u2234',
        Theta: 'Θ',
        theta: 'θ',
        thetasym: 'ϑ',
        thetav: 'ϑ',
        thickapprox: '\u2248',
        thicksim: '\u223C',
        ThickSpace: '\u205F\u200A',
        thinsp: '\u2009',
        ThinSpace: '\u2009',
        thkap: '\u2248',
        thksim: '\u223C',
        THORN: 'Þ',
        thorn: 'þ',
        Tilde: '\u223C',
        tilde: '\u02DC',
        TildeEqual: '\u2243',
        TildeFullEqual: '\u2245',
        TildeTilde: '\u2248',
        times: '\xD7',
        timesb: '\u22A0',
        timesbar: '\u2A31',
        timesd: '\u2A30',
        tint: '\u222D',
        toea: '\u2928',
        top: '\u22A4',
        topbot: '\u2336',
        topcir: '\u2AF1',
        Topf: '\uD835\uDD4B',
        topf: '\uD835\uDD65',
        topfork: '\u2ADA',
        tosa: '\u2929',
        tprime: '\u2034',
        TRADE: '\u2122',
        trade: '\u2122',
        triangle: '\u25B5',
        triangledown: '\u25BF',
        triangleleft: '\u25C3',
        trianglelefteq: '\u22B4',
        triangleq: '\u225C',
        triangleright: '\u25B9',
        trianglerighteq: '\u22B5',
        tridot: '\u25EC',
        trie: '\u225C',
        triminus: '\u2A3A',
        TripleDot: '⃛',
        triplus: '\u2A39',
        trisb: '\u29CD',
        tritime: '\u2A3B',
        trpezium: '\u23E2',
        Tscr: '\uD835\uDCAF',
        tscr: '\uD835\uDCC9',
        TScy: 'Ц',
        tscy: 'ц',
        TSHcy: 'Ћ',
        tshcy: 'ћ',
        Tstrok: 'Ŧ',
        tstrok: 'ŧ',
        twixt: '\u226C',
        twoheadleftarrow: '\u219E',
        twoheadrightarrow: '\u21A0',
        Uacute: 'Ú',
        uacute: 'ú',
        Uarr: '\u219F',
        uArr: '\u21D1',
        uarr: '\u2191',
        Uarrocir: '\u2949',
        Ubrcy: 'Ў',
        ubrcy: 'ў',
        Ubreve: 'Ŭ',
        ubreve: 'ŭ',
        Ucirc: 'Û',
        ucirc: 'û',
        Ucy: 'У',
        ucy: 'у',
        udarr: '\u21C5',
        Udblac: 'Ű',
        udblac: 'ű',
        udhar: '\u296E',
        ufisht: '\u297E',
        Ufr: '\uD835\uDD18',
        ufr: '\uD835\uDD32',
        Ugrave: 'Ù',
        ugrave: 'ù',
        uHar: '\u2963',
        uharl: '\u21BF',
        uharr: '\u21BE',
        uhblk: '\u2580',
        ulcorn: '\u231C',
        ulcorner: '\u231C',
        ulcrop: '\u230F',
        ultri: '\u25F8',
        Umacr: 'Ū',
        umacr: 'ū',
        uml: '\xA8',
        UnderBar: '_',
        UnderBrace: '\u23DF',
        UnderBracket: '\u23B5',
        UnderParenthesis: '\u23DD',
        Union: '\u22C3',
        UnionPlus: '\u228E',
        Uogon: 'Ų',
        uogon: 'ų',
        Uopf: '\uD835\uDD4C',
        uopf: '\uD835\uDD66',
        UpArrow: '\u2191',
        Uparrow: '\u21D1',
        uparrow: '\u2191',
        UpArrowBar: '\u2912',
        UpArrowDownArrow: '\u21C5',
        UpDownArrow: '\u2195',
        Updownarrow: '\u21D5',
        updownarrow: '\u2195',
        UpEquilibrium: '\u296E',
        upharpoonleft: '\u21BF',
        upharpoonright: '\u21BE',
        uplus: '\u228E',
        UpperLeftArrow: '\u2196',
        UpperRightArrow: '\u2197',
        Upsi: 'ϒ',
        upsi: 'υ',
        upsih: 'ϒ',
        Upsilon: 'Υ',
        upsilon: 'υ',
        UpTee: '\u22A5',
        UpTeeArrow: '\u21A5',
        upuparrows: '\u21C8',
        urcorn: '\u231D',
        urcorner: '\u231D',
        urcrop: '\u230E',
        Uring: 'Ů',
        uring: 'ů',
        urtri: '\u25F9',
        Uscr: '\uD835\uDCB0',
        uscr: '\uD835\uDCCA',
        utdot: '\u22F0',
        Utilde: 'Ũ',
        utilde: 'ũ',
        utri: '\u25B5',
        utrif: '\u25B4',
        uuarr: '\u21C8',
        Uuml: 'Ü',
        uuml: 'ü',
        uwangle: '\u29A7',
        vangrt: '\u299C',
        varepsilon: 'ϵ',
        varkappa: 'ϰ',
        varnothing: '\u2205',
        varphi: 'ϕ',
        varpi: 'ϖ',
        varpropto: '\u221D',
        vArr: '\u21D5',
        varr: '\u2195',
        varrho: 'ϱ',
        varsigma: 'ς',
        varsubsetneq: '\u228A︀',
        varsubsetneqq: '\u2ACB︀',
        varsupsetneq: '\u228B︀',
        varsupsetneqq: '\u2ACC︀',
        vartheta: 'ϑ',
        vartriangleleft: '\u22B2',
        vartriangleright: '\u22B3',
        Vbar: '\u2AEB',
        vBar: '\u2AE8',
        vBarv: '\u2AE9',
        Vcy: 'В',
        vcy: 'в',
        VDash: '\u22AB',
        Vdash: '\u22A9',
        vDash: '\u22A8',
        vdash: '\u22A2',
        Vdashl: '\u2AE6',
        Vee: '\u22C1',
        vee: '\u2228',
        veebar: '\u22BB',
        veeeq: '\u225A',
        vellip: '\u22EE',
        Verbar: '\u2016',
        verbar: '|',
        Vert: '\u2016',
        vert: '|',
        VerticalBar: '\u2223',
        VerticalLine: '|',
        VerticalSeparator: '\u2758',
        VerticalTilde: '\u2240',
        VeryThinSpace: '\u200A',
        Vfr: '\uD835\uDD19',
        vfr: '\uD835\uDD33',
        vltri: '\u22B2',
        vnsub: '\u2282⃒',
        vnsup: '\u2283⃒',
        Vopf: '\uD835\uDD4D',
        vopf: '\uD835\uDD67',
        vprop: '\u221D',
        vrtri: '\u22B3',
        Vscr: '\uD835\uDCB1',
        vscr: '\uD835\uDCCB',
        vsubnE: '\u2ACB︀',
        vsubne: '\u228A︀',
        vsupnE: '\u2ACC︀',
        vsupne: '\u228B︀',
        Vvdash: '\u22AA',
        vzigzag: '\u299A',
        Wcirc: 'Ŵ',
        wcirc: 'ŵ',
        wedbar: '\u2A5F',
        Wedge: '\u22C0',
        wedge: '\u2227',
        wedgeq: '\u2259',
        weierp: '\u2118',
        Wfr: '\uD835\uDD1A',
        wfr: '\uD835\uDD34',
        Wopf: '\uD835\uDD4E',
        wopf: '\uD835\uDD68',
        wp: '\u2118',
        wr: '\u2240',
        wreath: '\u2240',
        Wscr: '\uD835\uDCB2',
        wscr: '\uD835\uDCCC',
        xcap: '\u22C2',
        xcirc: '\u25EF',
        xcup: '\u22C3',
        xdtri: '\u25BD',
        Xfr: '\uD835\uDD1B',
        xfr: '\uD835\uDD35',
        xhArr: '\u27FA',
        xharr: '\u27F7',
        Xi: 'Ξ',
        xi: 'ξ',
        xlArr: '\u27F8',
        xlarr: '\u27F5',
        xmap: '\u27FC',
        xnis: '\u22FB',
        xodot: '\u2A00',
        Xopf: '\uD835\uDD4F',
        xopf: '\uD835\uDD69',
        xoplus: '\u2A01',
        xotime: '\u2A02',
        xrArr: '\u27F9',
        xrarr: '\u27F6',
        Xscr: '\uD835\uDCB3',
        xscr: '\uD835\uDCCD',
        xsqcup: '\u2A06',
        xuplus: '\u2A04',
        xutri: '\u25B3',
        xvee: '\u22C1',
        xwedge: '\u22C0',
        Yacute: 'Ý',
        yacute: 'ý',
        YAcy: 'Я',
        yacy: 'я',
        Ycirc: 'Ŷ',
        ycirc: 'ŷ',
        Ycy: 'Ы',
        ycy: 'ы',
        yen: '\xA5',
        Yfr: '\uD835\uDD1C',
        yfr: '\uD835\uDD36',
        YIcy: 'Ї',
        yicy: 'ї',
        Yopf: '\uD835\uDD50',
        yopf: '\uD835\uDD6A',
        Yscr: '\uD835\uDCB4',
        yscr: '\uD835\uDCCE',
        YUcy: 'Ю',
        yucy: 'ю',
        Yuml: 'Ÿ',
        yuml: 'ÿ',
        Zacute: 'Ź',
        zacute: 'ź',
        Zcaron: 'Ž',
        zcaron: 'ž',
        Zcy: 'З',
        zcy: 'з',
        Zdot: 'Ż',
        zdot: 'ż',
        zeetrf: 'ℨ',
        ZeroWidthSpace: '\u200B',
        Zeta: 'Ζ',
        zeta: 'ζ',
        Zfr: 'ℨ',
        zfr: '\uD835\uDD37',
        ZHcy: 'Ж',
        zhcy: 'ж',
        zigrarr: '\u21DD',
        Zopf: 'ℤ',
        zopf: '\uD835\uDD6B',
        Zscr: '\uD835\uDCB5',
        zscr: '\uD835\uDCCF',
        zwj: '‍',
        zwnj: '‌'
    };
});
/*simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/tokenize*/
define('simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/tokenize', [
    'exports',
    './tokenizer',
    './entity-parser',
    './html5-named-char-refs'
], function (exports, _tokenizer, _entityParser, _html5NamedCharRefs) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.default = tokenize;
    var _tokenizer2 = _interopRequireDefault(_tokenizer);
    var _entityParser2 = _interopRequireDefault(_entityParser);
    var _html5NamedCharRefs2 = _interopRequireDefault(_html5NamedCharRefs);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    function tokenize(input, options) {
        var tokenizer = new _tokenizer2.default(new _entityParser2.default(_html5NamedCharRefs2.default), options);
        return tokenizer.tokenize(input);
    }
});
/*can-simple-dom@1.0.10#simple-dom/default-tokenize*/
define('can-simple-dom@1.0.10#simple-dom/default-tokenize', [
    'exports',
    'simple-html-tokenizer/lib/simple-html-tokenizer/tokenize'
], function (exports, _tokenize) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.default = function (input) {
        return (0, _tokenize2.default)(input);
    };
    var _tokenize2 = _interopRequireDefault(_tokenize);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    ;
});
/*can-simple-dom@1.0.10#test/element-sp-test*/
define('can-simple-dom@1.0.10#test/element-sp-test', [
    'can-simple-dom',
    'steal-qunit',
    'can-simple-dom/simple-dom/html-parser',
    'can-simple-dom/simple-dom/void-map',
    'can-simple-dom/simple-dom/html-serializer',
    'can-simple-dom/simple-dom/default-tokenize'
], function (_canSimpleDom, _stealQunit, _htmlParser, _voidMap, _htmlSerializer, _defaultTokenize) {
    'use strict';
    var _stealQunit2 = _interopRequireDefault(_stealQunit);
    var _htmlParser2 = _interopRequireDefault(_htmlParser);
    var _voidMap2 = _interopRequireDefault(_voidMap);
    var _htmlSerializer2 = _interopRequireDefault(_htmlSerializer);
    var _defaultTokenize2 = _interopRequireDefault(_defaultTokenize);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    _stealQunit2.default.module('can-simple-dom - Element with serialization and parsing');
    _stealQunit2.default.test('document.implementation is supported (#23)', function () {
        var document = new _canSimpleDom.Document();
        document.__addSerializerAndParser(new _htmlSerializer2.default(_voidMap2.default), new _htmlParser2.default(_defaultTokenize2.default, document, _voidMap2.default));
        ok(document.implementation, 'implementation exists');
        var doc2 = document.implementation.createHTMLDocument('');
        ok(doc2.body, 'has a body');
    });
    _stealQunit2.default.test('innerHTML supported', function () {
        var document = new _canSimpleDom.Document();
        document.__addSerializerAndParser(new _htmlSerializer2.default(_voidMap2.default), new _htmlParser2.default(_defaultTokenize2.default, document, _voidMap2.default));
        document.body.innerHTML = '<span class=\'bar\'>HI</span>';
        _stealQunit2.default.equal(document.body.firstChild.nodeName, 'SPAN');
        _stealQunit2.default.equal(document.body.firstChild.className, 'bar');
        _stealQunit2.default.equal(document.body.firstChild.firstChild.nodeValue, 'HI');
        _stealQunit2.default.equal(document.body.innerHTML, '<span class="bar">HI</span>');
    });
    _stealQunit2.default.test('outerHTML supported', function () {
        var document = new _canSimpleDom.Document();
        document.__addSerializerAndParser(new _htmlSerializer2.default(_voidMap2.default), new _htmlParser2.default(_defaultTokenize2.default, document, _voidMap2.default));
        document.body.innerHTML = '<span/><div id=\'item\'>HI</div><span/>';
        var item = document.getElementById('item');
        _stealQunit2.default.equal(item.outerHTML, '<div id="item">HI</div>', 'getter');
        item.outerHTML = '<label>IT</label>';
        _stealQunit2.default.equal(document.body.innerHTML, '<span></span><label>IT</label><span></span>', 'setter');
    });
});
/*can-simple-dom@1.0.10#test/element-event-test*/
define('can-simple-dom@1.0.10#test/element-event-test', [
    'can-simple-dom/simple-dom/document',
    'can-simple-dom/simple-dom/html-serializer',
    'can-simple-dom/simple-dom/void-map',
    './support',
    'steal-qunit'
], function (_document, _htmlSerializer, _voidMap, _support, _stealQunit) {
    'use strict';
    var _document2 = _interopRequireDefault(_document);
    var _htmlSerializer2 = _interopRequireDefault(_htmlSerializer);
    var _voidMap2 = _interopRequireDefault(_voidMap);
    var _stealQunit2 = _interopRequireDefault(_stealQunit);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    _stealQunit2.default.module('can-simple-dom - Event');
    _stealQunit2.default.test('basic bubbling', 4, function (assert) {
        var document = new _document2.default();
        var elem = document.createElement('div');
        document.body.appendChild(elem);
        document.addEventListener('foo', function (event) {
            assert.strictEqual(event.currentTarget, document, 'document current target');
        });
        document.documentElement.addEventListener('foo', function (event) {
            assert.strictEqual(event.currentTarget, document.documentElement, 'documentElement current target');
        });
        document.body.addEventListener('foo', function (event) {
            assert.strictEqual(event.currentTarget, document.body, 'body current target');
        });
        elem.addEventListener('foo', function (event) {
            assert.strictEqual(event.currentTarget, elem, 'elem current target');
        });
        document.body.appendChild(elem);
        var ev = document.createEvent('HTMLEvents');
        ev.initEvent('foo', true, false);
        elem.dispatchEvent(ev);
    });
    _stealQunit2.default.test('stop propagation', 2, function (assert) {
        var document = new _document2.default();
        var elem = document.createElement('div');
        document.body.appendChild(elem);
        document.addEventListener('foo', function (event) {
            assert.strictEqual(event.currentTarget, document, 'document current target');
        });
        document.documentElement.addEventListener('foo', function (event) {
            assert.strictEqual(event.currentTarget, document.documentElement, 'documentElement current target');
        });
        document.body.addEventListener('foo', function (event) {
            assert.strictEqual(event.currentTarget, document.body, 'body current target');
            event.stopPropagation();
        });
        elem.addEventListener('foo', function (event) {
            assert.strictEqual(event.currentTarget, elem, 'elem current target');
        });
        document.body.appendChild(elem);
        var ev = document.createEvent('HTMLEvents');
        ev.initEvent('foo', true, false);
        elem.dispatchEvent(ev);
    });
    _stealQunit2.default.test('initEvent without bubbling', 2, function (assert) {
        var document = new _document2.default();
        var elem = document.createElement('div');
        document.body.appendChild(elem);
        document.body.addEventListener('foo', function (event) {
            assert.strictEqual(event.currentTarget, document.body, 'body current target');
            event.stopPropagation();
        });
        elem.addEventListener('foo', function (event) {
            assert.strictEqual(event.currentTarget, elem, 'elem current target');
        });
        elem.addEventListener('foo', function (event) {
            assert.strictEqual(event.currentTarget, elem, 'elem current target');
        });
        document.body.appendChild(elem);
        var ev = document.createEvent('HTMLEvents');
        ev.initEvent('foo', false, false);
        elem.dispatchEvent(ev);
    });
    _stealQunit2.default.test('this inside event handler', function (assert) {
        var document = new _document2.default();
        var elem = document.createElement('div');
        document.body.appendChild(elem);
        elem.addEventListener('foo', function () {
            assert.equal(this, elem, 'this is the element');
        });
        var ev = document.createEvent('HTMLEvents');
        ev.initEvent('foo', true, false);
        elem.dispatchEvent(ev);
    });
});
/*can-simple-dom@1.0.10#test/parser-test*/
define('can-simple-dom@1.0.10#test/parser-test', [
    './support',
    'can-simple-dom/simple-dom/html-parser',
    'can-simple-dom/simple-dom/void-map',
    'can-simple-dom/simple-dom/default-tokenize',
    'steal-qunit'
], function (_support, _htmlParser, _voidMap, _defaultTokenize, _stealQunit) {
    'use strict';
    var _htmlParser2 = _interopRequireDefault(_htmlParser);
    var _voidMap2 = _interopRequireDefault(_voidMap);
    var _defaultTokenize2 = _interopRequireDefault(_defaultTokenize);
    var _stealQunit2 = _interopRequireDefault(_stealQunit);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    _stealQunit2.default.module('can-simple-dom - Basic HTML parsing', {
        beforeEach: function beforeEach() {
            this.parser = new _htmlParser2.default(_defaultTokenize2.default, _support.document, _voidMap2.default);
        }
    });
    _stealQunit2.default.test('simple parse', function (assert) {
        var fragment = this.parser.parse('<div>Hello</div>');
        assert.ok(fragment);
        var node = fragment.firstChild;
        assert.ok(node);
        assert.equal(node.nodeType, 1);
        assert.equal(node.nodeName.toLowerCase(), 'div');
        assert.ok(node.firstChild);
        assert.equal(node.firstChild.nodeType, 3);
        assert.equal(node.firstChild.nodeValue, 'Hello');
    });
    _stealQunit2.default.test('nested parse', function (assert) {
        var fragment = this.parser.parse('text before<div>Hello</div>text between<div id=foo title="Hello World">World</div>text after');
        assert.ok(fragment);
        var node = fragment.firstChild;
        assert.ok(node);
        assert.equal(node.nodeType, 3);
        assert.equal(node.nodeValue, 'text before');
        node = node.nextSibling;
        assert.ok(node);
        assert.equal(node.nodeType, 1);
        assert.equal(node.nodeName, 'DIV');
        assert.ok(node.firstChild);
        assert.equal(node.firstChild.nodeType, 3);
        assert.equal(node.firstChild.nodeValue, 'Hello');
        node = node.nextSibling;
        assert.ok(node);
        assert.equal(node.nodeType, 3);
        assert.equal(node.nodeValue, 'text between');
        node = node.nextSibling;
        assert.ok(node);
        assert.equal(node.nodeType, 1);
        assert.equal(node.nodeName, 'DIV');
        var expectedValues = {
            id: 'foo',
            title: 'Hello World'
        };
        assert.equal(node.attributes.length, 2);
        assert.equal(node.attributes[0].value, expectedValues[node.attributes[0].name]);
        assert.equal(node.attributes[1].value, expectedValues[node.attributes[1].name]);
        assert.equal(node.attributes.length, 2);
        assert.ok(node.firstChild);
        assert.equal(node.firstChild.nodeType, 3);
        assert.equal(node.firstChild.nodeValue, 'World');
        node = node.nextSibling;
        assert.ok(node);
        assert.equal(node.nodeType, 3);
        assert.equal(node.nodeValue, 'text after');
    });
    _stealQunit2.default.test('void tags', function (assert) {
        var fragment = this.parser.parse('<div>Hello<br>World<img src="http://example.com/image.png?foo=bar&bar=foo"></div>');
        assert.ok(fragment);
        var node = fragment.firstChild;
        assert.ok(node);
        assert.equal(node.nodeType, 1);
        assert.equal(node.nodeName, 'DIV');
        node = node.firstChild;
        assert.ok(node);
        assert.equal(node.nodeType, 3);
        assert.equal(node.nodeValue, 'Hello');
        node = node.nextSibling;
        assert.ok(node);
        assert.equal(node.nodeType, 1);
        assert.equal(node.nodeName, 'BR');
        node = node.nextSibling;
        assert.ok(node);
        assert.equal(node.nodeType, 3);
        assert.equal(node.nodeValue, 'World');
        node = node.nextSibling;
        assert.ok(node);
        assert.equal(node.nodeType, 1);
        assert.equal(node.nodeName, 'IMG');
        assert.equal(node.getAttribute('src'), 'http://example.com/image.png?foo=bar&bar=foo');
        assert.equal(node.nextSibling, null);
    });
    _stealQunit2.default.test('node attribute charater encode', function (assert) {
        var fragment = this.parser.parse('<div title="&nbsp;foo & bar &amp; baz < buz > biz"></div>');
        assert.ok(fragment);
        var node = fragment.firstChild;
        assert.ok(node);
        assert.equal(node.nodeType, 1);
        assert.equal(node.nodeName, 'DIV');
        var attibutes = node.attributes;
        assert.ok(attibutes.length);
        var title = attibutes[0];
        assert.equal(title.name, 'title');
        assert.equal(title.value, '&#xA0;foo &#x26; bar &#x26; baz &#x3C; buz &#x3E; biz');
    });
});
/*can-simple-dom@1.0.10#test/style-test*/
define('can-simple-dom@1.0.10#test/style-test', [
    'steal-qunit',
    'can-simple-dom/simple-dom/document/style'
], function (_stealQunit, _style) {
    'use strict';
    var _stealQunit2 = _interopRequireDefault(_stealQunit);
    var _style2 = _interopRequireDefault(_style);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    _stealQunit2.default.module('can-simple-dom - CSStyleDeclaration');
    _stealQunit2.default.test('cssText is enumerable', function () {
        var proto = _style2.default.prototype;
        var descriptor = Object.getOwnPropertyDescriptor(proto, 'cssText');
        _stealQunit2.default.equal(descriptor.enumerable, true, 'it is enumerable');
    });
    _stealQunit2.default.test('cssText is configurable', function () {
        var proto = _style2.default.prototype;
        var descriptor = Object.getOwnPropertyDescriptor(proto, 'cssText');
        _stealQunit2.default.equal(descriptor.configurable, true, 'it is configurable');
    });
});
/*can-simple-dom@1.0.10#test/test*/
define('can-simple-dom@1.0.10#test/test', [
    './element-test',
    './serializer-test',
    './element-sp-test',
    './element-event-test',
    './parser-test',
    './style-test'
], function () {
    'use strict';
});
/*can-symbol@1.0.0#can-symbol-test*/
define('can-symbol@1.0.0#can-symbol-test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var canSymbol = require('can-symbol');
    QUnit.module('can-symbol');
    QUnit.test('for and keyFor', function () {
        var symbol = canSymbol.for('abc');
        QUnit.ok(canSymbol.for('abc') === canSymbol.for('abc'));
        QUnit.equal(canSymbol.keyFor(symbol), 'abc', 'key for');
    });
    QUnit.test('can get/set symbols', function () {
        var obj = {};
        var symbol1 = canSymbol('prop1'), symbol2 = canSymbol('prop2');
        obj[symbol1] = 'VALUE';
        QUnit.equal(obj[symbol1], 'VALUE', 'got value');
        Object.defineProperty(obj, symbol2, { value: 'DP-VALUE' });
        QUnit.equal(obj[symbol2], 'DP-VALUE', 'got define property value');
    });
});
/*can-reflect@1.2.3#reflections/type/type-test*/
define('can-reflect@1.2.3#reflections/type/type-test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var canSymbol = require('can-symbol');
    var typeReflections = require('./type');
    var getSetReflections = require('../get-set/get-set');
    var setSupported = function () {
        if (typeof Set === 'undefined') {
            return false;
        }
        var theSet = new Set();
        return canSymbol.iterator in theSet;
    }();
    QUnit.module('can-reflect: type reflections');
    QUnit.test('isConstructorLike', function () {
        var Constructor = function () {
        };
        Constructor.prototype.method = function () {
        };
        ok(typeReflections.isConstructorLike(Constructor));
        ok(!typeReflections.isConstructorLike(Constructor.prototype.method));
        var obj = {};
        getSetReflections.setKeyValue(obj, canSymbol.for('can.new'), function () {
        });
        ok(typeReflections.isConstructorLike(obj));
        ok(!typeReflections.isConstructorLike({}));
    });
    QUnit.test('isFunctionLike', function () {
        ok(!typeReflections.isFunctionLike({}), 'object is not function like');
        ok(typeReflections.isFunctionLike(function () {
        }), 'function is function like');
        var nonFunctionFunction = function () {
        };
        getSetReflections.setKeyValue(nonFunctionFunction, canSymbol.for('can.isFunctionLike'), false);
        ok(!typeReflections.isFunctionLike(nonFunctionFunction), 'function with can.isFunctionLike set to false is not function like');
        var obj = {};
        var func = function () {
        };
        getSetReflections.setKeyValue(obj, canSymbol.for('can.new'), func);
        getSetReflections.setKeyValue(obj, canSymbol.for('can.apply'), func);
        ok(typeReflections.isFunctionLike(obj), 'object with can.new and can.apply symbols is function like');
        getSetReflections.setKeyValue(obj, canSymbol.for('can.isFunctionLike'), false);
        ok(!typeReflections.isFunctionLike(obj), 'object with can.new, can.apply, and can.isFunctionLike set to false is not function like');
    });
    QUnit.test('isIteratorLike', function () {
        ok(!typeReflections.isIteratorLike({}));
        ok(typeReflections.isIteratorLike({
            next: function () {
            }
        }));
    });
    QUnit.test('isListLike', function () {
        ok(typeReflections.isListLike({
            0: 1,
            length: 1
        }));
        ok(typeReflections.isListLike('yes'), 'string');
        ok(typeReflections.isListLike({ length: 0 }), 'object with 0 length');
        var symboled = {};
        getSetReflections.setKeyValue(symboled, canSymbol.for('can.isListLike'), false);
        ok(!typeReflections.isListLike(symboled), '!@@can.isListLike');
        getSetReflections.setKeyValue(symboled, canSymbol.for('can.isListLike'), true);
        ok(typeReflections.isListLike(symboled), '@@can.isListLike');
        if (typeof document !== 'undefined') {
            var ul = document.createElement('ul');
            ul.innerHTML = '<li/><li/>';
            ok(typeReflections.isListLike(ul.childNodes), 'nodeList');
        }
        if (setSupported) {
            ok(typeReflections.isListLike(new Set()), 'Set');
        }
    });
    QUnit.test('isMapLike', function () {
        ok(typeReflections.isMapLike({}), 'Object');
        ok(typeReflections.isMapLike([]), 'Array');
        var symboled = {};
        getSetReflections.setKeyValue(symboled, canSymbol.for('can.isMapLike'), false);
        ok(!typeReflections.isMapLike(symboled), '!@@can.isMapLike');
        getSetReflections.setKeyValue(symboled, canSymbol.for('can.isMapLike'), true);
        ok(typeReflections.isMapLike(symboled), '@@can.isMapLike');
        ok(!typeReflections.isMapLike('String'), 'String');
    });
    QUnit.test('isMoreListLikeThanMapLike', function () {
        QUnit.equal(typeReflections.isMoreListLikeThanMapLike({}), false, 'Object');
        QUnit.equal(typeReflections.isMoreListLikeThanMapLike([]), true, 'Array');
    });
    QUnit.test('isObservableLike', function () {
        ok(!typeReflections.isObservableLike({}), 'Object');
        var obj = {};
        getSetReflections.setKeyValue(obj, canSymbol.for('can.onValue'), function () {
        });
        ok(typeReflections.isObservableLike(obj), 'Object');
    });
    QUnit.test('isPrimitive', function () {
        ok(!typeReflections.isPrimitive({}), 'Object');
        ok(typeReflections.isPrimitive(null), 'null');
        ok(typeReflections.isPrimitive(1), '1');
    });
    QUnit.test('isValueLike', function () {
        ok(!typeReflections.isValueLike({}), 'Object');
        ok(!typeReflections.isValueLike(function () {
        }), 'Function');
        ok(typeReflections.isValueLike('String'), 'String');
        var obj = {};
        getSetReflections.setKeyValue(obj, canSymbol.for('can.getValue'), true);
        ok(typeReflections.isValueLike(obj), 'symboled');
        var symboled = {};
        getSetReflections.setKeyValue(symboled, canSymbol.for('can.isValueLike'), false);
        ok(!typeReflections.isValueLike(symboled), '!@@can.isValueLike');
        getSetReflections.setKeyValue(symboled, canSymbol.for('can.isValueLike'), true);
        ok(typeReflections.isValueLike(symboled), '@@can.isValueLike');
    });
    QUnit.test('isSymbolLike', function () {
        if (typeof Symbol !== 'undefined') {
            ok(typeReflections.isSymbolLike(Symbol('a symbol')), 'Native Symbol');
        }
        ok(typeReflections.isSymbolLike(canSymbol('another Symbol')), 'canSymbol Symbol');
    });
    QUnit.test('isPromise', function () {
        QUnit.ok(!typeReflections.isPromise({}), 'Object is not a promise');
        QUnit.ok(!typeReflections.isPromise({
            catch: function () {
            },
            then: function () {
            }
        }), 'function with then and catch is not a Promise');
        QUnit.ok(typeReflections.isPromise(new Promise(function () {
        })), 'a new Promise() is a Promise');
    });
    QUnit.test('isConstructor - non enumerable properties on the prototype chain (#18)', function () {
        var Constructor = function () {
        };
        Object.defineProperty(Constructor.prototype, 'prop', {
            enumerable: false,
            value: 1
        });
        QUnit.ok(typeReflections.isConstructorLike(Constructor), 'decorated prototype means constructor');
    });
    QUnit.test('functions without prototypes (#20)', function () {
        var method = function () {
        }.bind({});
        QUnit.notOk(typeReflections.isConstructorLike(method), 'not a constructor');
    });
    QUnit.test('functions with deep non enumerable properties - non default proto chains (#22)', function () {
        var Base = function () {
        };
        Object.defineProperty(Base.prototype, 'prop', {
            enumerable: false,
            value: 1
        });
        var Constructor = function () {
        };
        Constructor.prototype = new Base();
        Constructor.prototype.constructor = Constructor;
        QUnit.ok(typeReflections.isConstructorLike(Constructor), 'decorated prototype means constructor');
    });
});
/*can-reflect@1.2.3#reflections/shape/shape-test*/
define('can-reflect@1.2.3#reflections/shape/shape-test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var canSymbol = require('can-symbol');
    var shapeReflections = require('./shape');
    var getSetReflections = require('../get-set/get-set');
    var mapSupported = function () {
        return typeof Map !== 'undefined' && typeof Map.prototype.keys === 'function';
    }();
    QUnit.module('can-reflect: shape reflections: own+enumerable');
    function testModifiedMap(callback, symbolToMethod) {
        symbolToMethod = symbolToMethod || {
            getOwnEnumerableKeys: 'keys',
            hasOwnKey: 'has',
            getKeyValue: 'get'
        };
        if (mapSupported) {
            shapeReflections.eachKey(symbolToMethod, function (method, symbol) {
                getSetReflections.setKeyValue(Map.prototype, canSymbol.for('can.' + symbol), function () {
                    return this[method].apply(this, arguments);
                });
            });
            callback();
            shapeReflections.eachKey(symbolToMethod, function (symbol) {
                delete Map.prototype[canSymbol.for(symbol)];
            });
        }
    }
    QUnit.test('getOwnEnumerableKeys (aka: keys)', function () {
        QUnit.deepEqual(shapeReflections.keys({
            foo: 1,
            bar: 2
        }), [
            'foo',
            'bar'
        ], 'POJO');
        QUnit.deepEqual(shapeReflections.keys([
            '0',
            '1'
        ]), Object.keys([
            1,
            2
        ]), 'Array');
        testModifiedMap(function () {
            var map = new Map(), obj = {};
            map.set('foo', 1);
            map.set(obj, 2);
            QUnit.deepEqual(shapeReflections.toArray(shapeReflections.keys(map)), [
                'foo',
                {}
            ], 'Decorated Map with can.getOwnEnumerableKeys');
        });
        var proto = {};
        getSetReflections.setKeyValue(proto, canSymbol.for('can.getOwnKeys'), function () {
            return [
                'a',
                'b',
                'c'
            ];
        });
        getSetReflections.setKeyValue(proto, canSymbol.for('can.getOwnKeyDescriptor'), function (key) {
            return {
                a: { enumerable: false },
                b: { enumerable: true },
                c: { enumerable: true }
            }[key];
        });
        var defineMapLike = Object.create(proto, {});
        QUnit.deepEqual(shapeReflections.toArray(shapeReflections.keys(defineMapLike)), [
            'b',
            'c'
        ], 'Decorated Object with can.getOwnKeys and can.getOwnKeyDescriptor');
    });
    QUnit.test('eachIndex', function () {
        var Ctr = function () {
        };
        var arr = [
            'a',
            'b'
        ];
        getSetReflections.setKeyValue(Ctr.prototype, canSymbol.iterator, function () {
            return {
                i: 0,
                next: function () {
                    if (this.i === 1) {
                        return {
                            value: undefined,
                            done: true
                        };
                    }
                    this.i++;
                    return {
                        value: arr,
                        done: false
                    };
                }
            };
        });
        var obj = new Ctr();
        shapeReflections.eachIndex(obj, function (value, index) {
            QUnit.equal(index, 0);
            QUnit.equal(value, arr);
        });
        shapeReflections.eachIndex(['a'], function (value, index) {
            QUnit.equal(index, 0);
            QUnit.equal(value, 'a');
        });
        function ArrayLike() {
        }
        ArrayLike.prototype = [];
        ArrayLike.prototype[canSymbol.iterator] = null;
        var noniterator = new ArrayLike();
        noniterator.push('a');
        shapeReflections.eachIndex(noniterator, function (value, index) {
            QUnit.equal(index, 0);
            QUnit.equal(value, 'a');
        });
    });
    QUnit.test('eachKey', function () {
        var index;
        var answers, map;
        testModifiedMap(function () {
            var o1 = {}, o2 = {};
            map = new Map([
                [
                    o1,
                    '1'
                ],
                [
                    o2,
                    2
                ]
            ]);
            index = 0;
            answers = [
                [
                    o1,
                    '1'
                ],
                [
                    o2,
                    2
                ]
            ];
            shapeReflections.eachKey(map, function (value, key) {
                var answer = answers[index++];
                QUnit.equal(value, answer[1], 'map value');
                QUnit.equal(key, answer[0], 'map key');
            });
        });
        var obj = {
            a: '1',
            b: '2'
        };
        index = 0;
        answers = [
            [
                'a',
                '1'
            ],
            [
                'b',
                '2'
            ]
        ];
        shapeReflections.eachKey(obj, function (value, key) {
            var answer = answers[index++];
            QUnit.equal(value, answer[1], 'object value');
            QUnit.equal(key, answer[0], 'object key');
        });
    });
    QUnit.test('each', function () {
        shapeReflections.each({ foo: 'bar' }, function (value, key) {
            QUnit.equal(key, 'foo');
            QUnit.equal(value, 'bar');
        });
        shapeReflections.each(['bar'], function (value, index) {
            QUnit.equal(index, 0);
            QUnit.equal(value, 'bar');
        });
    });
    QUnit.test('toArray', function () {
        if (typeof document !== 'undefined') {
            var ul = document.createElement('ul');
            ul.innerHTML = '<li/><li/>';
            var arr = shapeReflections.toArray(ul.childNodes);
            QUnit.equal(arr.length, 2, 'childNodes');
            QUnit.equal(arr[0].nodeName.toLowerCase(), 'li', 'childNodes');
        }
    });
    QUnit.module('can-reflect: shape reflections: own');
    QUnit.test('hasOwnKey', function () {
        var map;
        testModifiedMap(function () {
            var o1 = {};
            map = new Map();
            map.set(o1, '1');
            QUnit.ok(shapeReflections.hasOwnKey(map, o1), 'Map');
        });
        var obj = { foo: 'bar' };
        QUnit.ok(shapeReflections.hasOwnKey(obj, 'foo'), 'obj');
        QUnit.ok(!shapeReflections.hasOwnKey(obj, 'bar'), 'obj');
    });
    QUnit.test('getOwnKeys', function () {
        var obj = Object.create(null, {
            foo: {
                value: '1',
                enumerable: true
            },
            bar: {
                value: '2',
                enumerable: false
            }
        });
        QUnit.deepEqual(shapeReflections.getOwnKeys(obj), [
            'foo',
            'bar'
        ], 'obj');
    });
    QUnit.test('getOwnKeyDescriptor', function () {
        var obj = { foo: 'bar' };
        QUnit.deepEqual(shapeReflections.getOwnKeyDescriptor(obj, 'foo'), Object.getOwnPropertyDescriptor(obj, 'foo'), 'POJO');
        var obj2 = {};
        getSetReflections.setKeyValue(obj2, canSymbol.for('can.getOwnKeyDescriptor'), function (key) {
            return {
                foo: {
                    enumerable: true,
                    type: 'thing'
                }
            }[key];
        });
        QUnit.deepEqual(shapeReflections.getOwnKeyDescriptor(obj2, 'foo'), {
            enumerable: true,
            type: 'thing'
        }, 'w/ symbol');
    });
    QUnit.test('unwrap basics', function () {
        var list = {};
        getSetReflections.setKeyValue(list, canSymbol.iterator, function () {
            return {
                i: 0,
                next: function () {
                    if (this.i === 3) {
                        return {
                            value: undefined,
                            done: true
                        };
                    }
                    this.i++;
                    return {
                        value: (this.i - 1) * 2,
                        done: false
                    };
                }
            };
        });
        getSetReflections.setKeyValue(list, canSymbol.for('can.isMoreListLikeThanMapLike'), true);
        var compute = {};
        getSetReflections.setKeyValue(compute, canSymbol.for('can.getValue'), function () {
            var map = {};
            getSetReflections.setKeyValue(map, canSymbol.for('can.getOwnEnumerableKeys'), function () {
                return [
                    'a',
                    'b',
                    'c',
                    'list'
                ];
            });
            getSetReflections.setKeyValue(map, canSymbol.for('can.getKeyValue'), function (key) {
                return key === 'list' ? list : key.toUpperCase();
            });
            return map;
        });
        var plain = shapeReflections.unwrap(compute);
        QUnit.deepEqual(plain, {
            a: 'A',
            b: 'B',
            c: 'C',
            list: [
                0,
                2,
                4
            ]
        });
    });
    QUnit.test('unwrap handles POJOs', function () {
        var a = { foo: 'bar' };
        var plain = shapeReflections.unwrap(a);
        QUnit.deepEqual(plain, a);
        QUnit.ok(a !== plain, 'returns copy');
    });
    if (typeof Map !== 'undefined') {
        QUnit.test('handles cycles', function () {
            var a = {}, b = {};
            a.b = b;
            b.a = a;
            var plain = shapeReflections.unwrap(a, Map);
            QUnit.equal(plain.b.a, plain, 'cycle intact');
            QUnit.ok(a !== plain, 'returns copy');
        });
    }
    QUnit.test('.serialize handles recursion with .unwrap', function () {
        var list = {};
        getSetReflections.setKeyValue(list, canSymbol.iterator, function () {
            return {
                i: 0,
                next: function () {
                    if (this.i === 3) {
                        return {
                            value: undefined,
                            done: true
                        };
                    }
                    this.i++;
                    return {
                        value: (this.i - 1) * 2,
                        done: false
                    };
                }
            };
        });
        getSetReflections.setKeyValue(list, canSymbol.for('can.isMoreListLikeThanMapLike'), true);
        var compute = {};
        getSetReflections.setKeyValue(compute, canSymbol.for('can.getValue'), function () {
            var map = {};
            getSetReflections.setKeyValue(map, canSymbol.for('can.getOwnEnumerableKeys'), function () {
                return [
                    'a',
                    'b',
                    'c',
                    'list'
                ];
            });
            getSetReflections.setKeyValue(map, canSymbol.for('can.getKeyValue'), function (key) {
                return key === 'list' ? list : key.toUpperCase();
            });
            return map;
        });
        var plain = shapeReflections.unwrap(compute);
        QUnit.deepEqual(plain, {
            a: 'A',
            b: 'B',
            c: 'C',
            list: [
                0,
                2,
                4
            ]
        });
    });
    QUnit.test('updateDeep basics', function () {
        var obj = {
            name: 'Justin',
            hobbies: [
                {
                    id: 1,
                    name: 'js'
                },
                {
                    id: 2,
                    name: 'foosball'
                }
            ]
        };
        var hobbies = obj.hobbies;
        var js = obj.hobbies[0];
        shapeReflections.updateDeep(obj, {
            age: 34,
            hobbies: [{
                    id: 1,
                    name: 'JS',
                    fun: true
                }]
        });
        QUnit.deepEqual(obj, {
            age: 34,
            hobbies: [{
                    id: 1,
                    name: 'JS',
                    fun: true
                }]
        });
        QUnit.equal(obj.hobbies, hobbies, 'merged hobbies');
        QUnit.equal(obj.hobbies[0], js, 'merged js');
        shapeReflections.updateDeep(obj, {
            age: 34,
            hobbies: [
                {
                    id: 1,
                    name: 'JS',
                    fun: true
                },
                {
                    id: 2,
                    name: 'foosball'
                }
            ]
        });
        QUnit.deepEqual(obj, {
            age: 34,
            hobbies: [
                {
                    id: 1,
                    name: 'JS',
                    fun: true
                },
                {
                    id: 2,
                    name: 'foosball'
                }
            ]
        }, 'added foosball');
        QUnit.equal(obj.hobbies, hobbies, 'merged hobbies');
        QUnit.equal(obj.hobbies[0], js, 'merged js');
    });
    QUnit.test('updateDeep', function () {
        var a = [];
        shapeReflections.updateDeep(a, [
            'a',
            'b'
        ]);
        QUnit.deepEqual(a, [
            'a',
            'b'
        ]);
    });
    QUnit.test('can assign undefined values', function () {
        var obj = shapeReflections.assignMap({}, { foo: undefined });
        QUnit.ok(obj.hasOwnProperty('foo'), 'has an undefined foo');
    });
    QUnit.test('assignMap', function () {
        var target = shapeReflections.assignSymbols({}, {
            'can.setKeyValue': function (key, value) {
                this[key] = value * 2;
            },
            'can.getKeyValue': function (key) {
                return this[key] !== undefined ? this[key] / 2 : undefined;
            }
        });
        target.a = 22;
        var source = shapeReflections.assignSymbols({}, {
            'can.setKeyValue': function (key, value) {
                this[key] = value * 3;
            },
            'can.getKeyValue': function (key) {
                return this[key] !== undefined ? this[key] / 3 : undefined;
            }
        });
        shapeReflections.assignMap(source, {
            a: 1,
            b: 2
        });
        QUnit.deepEqual(source, {
            a: 3,
            b: 6
        }, 'set values on source');
        shapeReflections.assignMap(target, source);
        QUnit.deepEqual(target, {
            a: 2,
            b: 4
        }, 'set values on target');
    });
    QUnit.test('getOwnEnumerableKeys with primitives', function () {
        QUnit.deepEqual(shapeReflections.getOwnEnumerableKeys(1), [], 'works with primitive');
    });
});
/*can-reflect@1.2.3#reflections/get-set/get-set-test*/
define('can-reflect@1.2.3#reflections/get-set/get-set-test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var canSymbol = require('can-symbol');
    var shapeReflections = require('../shape/shape');
    var getSetReflections = require('./get-set');
    QUnit.module('can-reflect: get-set reflections: key');
    QUnit.test('getKeyValue', function () {
        QUnit.equal(getSetReflections.getKeyValue({ foo: 'bar' }, 'foo'), 'bar', 'POJO');
        QUnit.equal(getSetReflections.getKeyValue([1], 'length'), 1, 'Array length');
        QUnit.equal(getSetReflections.getKeyValue([2], 0), 2, 'Array index');
        var obj = {};
        getSetReflections.setKeyValue(obj, canSymbol.for('can.getKeyValue'), function (key) {
            return { foo: 'bar' }[key];
        });
        QUnit.equal(getSetReflections.getKeyValue(obj, 'foo'), 'bar');
    });
    QUnit.test('get / set alias', function () {
        QUnit.equal(getSetReflections.get, getSetReflections.getKeyValue);
        QUnit.equal(getSetReflections.set, getSetReflections.setKeyValue);
    });
    QUnit.test('setKeyValue', function () {
        var obj = {};
        var mysymbol = canSymbol('some symbol');
        if (typeof mysymbol === 'object') {
            getSetReflections.setKeyValue(obj, mysymbol, 'VALUE');
            QUnit.deepEqual(Object.getOwnPropertyDescriptor(obj, mysymbol.toString()), {
                enumerable: false,
                writable: true,
                configurable: true,
                value: 'VALUE'
            });
        }
        obj = {};
        getSetReflections.setKeyValue(obj, 'prop', 'VALUE');
        QUnit.equal(obj.prop, 'VALUE');
        getSetReflections.setKeyValue(obj, canSymbol.for('can.setKeyValue'), function (prop, value) {
            QUnit.equal(prop, 'someProp', 'can.setKeyValue');
            QUnit.equal(value, 'someValue', 'can.setKeyValue');
        });
        getSetReflections.setKeyValue(obj, 'someProp', 'someValue');
    });
    QUnit.test('deleteKeyValue', function () {
        var obj = { prop: 'Value' };
        getSetReflections.deleteKeyValue(obj, 'prop');
        QUnit.equal(obj.prop, undefined, 'deleted');
    });
    QUnit.module('can-reflect: get-set reflections: value');
    QUnit.test('getValue', function () {
        [
            true,
            1,
            null,
            undefined,
            {}
        ].forEach(function (value) {
            QUnit.equal(getSetReflections.getValue(value), value, value);
        });
        var obj = { value: 0 };
        getSetReflections.setKeyValue(obj, canSymbol.for('can.getValue'), function () {
            return this.value;
        });
        QUnit.equal(getSetReflections.getValue(obj), 0);
    });
    QUnit.test('setValue', function () {
        try {
            getSetReflections.setValue({}, {});
            QUnit.ok(false, 'set POJO');
        } catch (e) {
            QUnit.ok(true, 'set POJO errors');
        }
        var obj = { value: 0 };
        getSetReflections.setKeyValue(obj, canSymbol.for('can.setValue'), function (value) {
            this.value = value;
        });
        getSetReflections.setValue(obj, 2);
        QUnit.deepEqual(obj, { value: 2 }, 'can.setValue');
    });
});
/*can-reflect@1.2.3#reflections/call/call-test*/
define('can-reflect@1.2.3#reflections/call/call-test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var canSymbol = require('can-symbol');
    var callReflections = require('./call');
    var getSetReflections = require('../get-set/get-set');
    QUnit.module('can-reflect: function reflections');
    QUnit.test('call', function () {
        var obj = {};
        var ret = callReflections.call(function (arg1, arg2) {
            QUnit.equal(this, obj, 'this');
            QUnit.equal(arg1, 1, 'arg1');
            QUnit.equal(arg2, 2, 'arg2');
            return 3;
        }, obj, 1, 2);
        QUnit.equal(ret, 3, 'return value');
        var func = {};
        getSetReflections.setKeyValue(func, canSymbol.for('can.apply'), function (context, args) {
            QUnit.equal(this, func, 'this');
            QUnit.equal(context, obj, 'context');
            QUnit.equal(args[0], 1, 'arg1');
            QUnit.equal(args[1], 2, 'arg2');
            return 3;
        });
        ret = callReflections.call(func, obj, 1, 2);
        QUnit.equal(ret, 3, 'return value');
    });
    QUnit.test('apply', function () {
        var obj = {};
        var ret = callReflections.apply(function (arg1, arg2) {
            QUnit.equal(this, obj, 'this');
            QUnit.equal(arg1, 1, 'arg1');
            QUnit.equal(arg2, 2, 'arg2');
            return 3;
        }, obj, [
            1,
            2
        ]);
        QUnit.equal(ret, 3, 'return value');
        var func = {};
        getSetReflections.setKeyValue(func, canSymbol.for('can.apply'), function (context, args) {
            QUnit.equal(this, func, 'this');
            QUnit.equal(context, obj, 'context');
            QUnit.equal(args[0], 1, 'arg1');
            QUnit.equal(args[1], 2, 'arg2');
            return 3;
        });
        ret = callReflections.apply(func, obj, [
            1,
            2
        ]);
        QUnit.equal(ret, 3, 'return value');
    });
    QUnit.test('new', function () {
        var Constructor = function (arg1, arg2) {
            QUnit.ok(this instanceof Constructor, 'this');
            QUnit.equal(arg1, 1, 'arg1');
            QUnit.equal(arg2, 2, 'arg2');
            return 3;
        };
        var instance = callReflections['new'](Constructor, 1, 2);
        QUnit.ok(instance instanceof Constructor, 'this');
        var Func = {};
        getSetReflections.setKeyValue(Func, canSymbol.for('can.new'), function (arg1, arg2) {
            QUnit.equal(this, Func, 'this');
            QUnit.equal(arg1, 1, 'arg1');
            QUnit.equal(arg2, 2, 'arg2');
            return 3;
        });
        var ret = callReflections.new(Func, 1, 2);
        QUnit.equal(ret, 3, 'return value');
    });
});
/*can-reflect@1.2.3#reflections/observe/observe-test*/
define('can-reflect@1.2.3#reflections/observe/observe-test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var canSymbol = require('can-symbol');
    var observeReflections = require('./observe');
    var getSetReflections = require('../get-set/get-set');
    QUnit.module('can-reflect: observe reflections: key');
    QUnit.test('onKeyValue / offKeyValue', function () {
        var obj = { callbacks: { foo: [] } };
        getSetReflections.setKeyValue(obj, canSymbol.for('can.onKeyValue'), function (key, callback) {
            this.callbacks[key].push(callback);
        });
        var callback = function (ev, value) {
            QUnit.equal(value, 'bar');
        };
        observeReflections.onKeyValue(obj, 'foo', callback);
        obj.callbacks.foo[0]({}, 'bar');
        getSetReflections.setKeyValue(obj, canSymbol.for('can.offKeyValue'), function (key, callback) {
            var index = this.callbacks[key].indexOf(callback);
            this.callbacks[key].splice(index, 1);
        });
        observeReflections.offKeyValue(obj, 'foo', callback);
        QUnit.equal(obj.callbacks.foo.length, 0, 'no event handlers');
    });
    QUnit.test('onKeys', function () {
        try {
            observeReflections.onKeys({}, function () {
            });
            QUnit.ok(false, 'should throw error');
        } catch (e) {
            QUnit.ok(true, 'threw error');
        }
    });
    QUnit.test('onKeysAdded / onKeysRemoved', function () {
        try {
            observeReflections.onKeysAdded({}, function () {
            });
            QUnit.ok(false, 'should throw error');
        } catch (e) {
            QUnit.ok(true, 'threw error');
        }
        try {
            observeReflections.onKeysRemoved({}, function () {
            });
            QUnit.ok(false, 'should throw error');
        } catch (e) {
            QUnit.ok(true, 'threw error');
        }
    });
    QUnit.test('getKeyDependencies', function () {
        try {
            observeReflections.getKeyDependencies({});
            QUnit.ok(false, 'should throw error');
        } catch (e) {
            QUnit.ok(true, 'threw error');
        }
    });
    QUnit.module('can-reflect: observe reflections: value');
    QUnit.test('onValue / offValue', function () {
        var obj = { callbacks: [] };
        getSetReflections.setKeyValue(obj, canSymbol.for('can.onValue'), function (callback) {
            this.callbacks.push(callback);
        });
        var callback = function (ev, value) {
            QUnit.equal(value, 'bar');
        };
        observeReflections.onValue(obj, callback);
        obj.callbacks[0]({}, 'bar');
        getSetReflections.setKeyValue(obj, canSymbol.for('can.offValue'), function (callback) {
            var index = this.callbacks.indexOf(callback);
            this.callbacks.splice(index, 1);
        });
        observeReflections.offValue(obj, callback);
        QUnit.equal(obj.callbacks.length, 0, 'no event handlers');
    });
    QUnit.test('getValueDependencies', function () {
        try {
            observeReflections.getValueDependencies({});
            QUnit.ok(false, 'should throw error');
        } catch (e) {
            QUnit.ok(true, 'threw error');
        }
    });
    QUnit.module('can-reflect: observe reflections: event');
    QUnit.test('onEvent / offEvent', function () {
        var cb = function () {
        };
        var obj = {
            addEventListener: function (arg1, arg2) {
                QUnit.equal(this, obj);
                QUnit.equal(arg2, cb);
                QUnit.equal(arg1, 'click', 'eventName');
            },
            removeEventListener: function (arg1, arg2) {
                QUnit.equal(this, obj);
                QUnit.equal(arg1, 'click', 'event name');
                QUnit.equal(arg2, cb);
            }
        };
        observeReflections.onEvent(obj, 'click', cb);
        observeReflections.offEvent(obj, 'click', cb);
    });
});
/*can-reflect@1.2.3#can-reflect-test*/
define('can-reflect@1.2.3#can-reflect-test', function (require, exports, module) {
    require('./reflections/type/type-test');
    require('./reflections/shape/shape-test');
    require('./reflections/get-set/get-set-test');
    require('./reflections/call/call-test');
    require('./reflections/observe/observe-test');
});
/*can-control@3.2.0#can-control_test*/
define('can-control@3.2.0#can-control_test', function (require, exports, module) {
    var Control = require('can-control');
    var QUnit = require('steal-qunit');
    var fragment = require('can-util/dom/fragment/');
    var domData = require('can-util/dom/data/');
    var dev = require('can-util/js/dev/');
    var domDispatch = require('can-util/dom/dispatch/');
    var className = require('can-util/dom/class-name/');
    var domMutate = require('can-util/dom/mutate/');
    var canEvent = require('can-event');
    var types = require('can-types');
    var CanMap = require('can-map');
    var DefineMap = require('can-define/map/');
    QUnit.module('can-control', {
        setup: function () {
            this.fixture = document.getElementById('qunit-fixture');
        }
    });
    test('data', function () {
        var Things = Control.extend({});
        this.fixture.appendChild(fragment('<div id=\'things\'>div<span>span</span></div>'));
        var things = document.getElementById('things');
        var c1 = new Things('#things', {});
        var c2 = new Things('#things', {});
        equal(domData.get.call(things, 'controls').length, 2, 'there are 2 items in the data array');
        c1.destroy();
        equal(domData.get.call(things, 'controls').length, 1, 'there is 1 item in the data array');
        c2.destroy();
        equal(domData.get.call(things, 'controls').length, 0, 'there are 0 items in the data array');
    });
    test('parameterized actions', function () {
        var called = false, WeirderBind = Control.extend({
                '{parameterized}': function () {
                    called = true;
                }
            }), a;
        this.fixture.appendChild(fragment('<div id=\'crazy\'></div>'));
        a = document.getElementById('crazy');
        new WeirderBind(a, { parameterized: 'sillyEvent' });
        domDispatch.call(a, 'sillyEvent');
        ok(called, 'heard the trigger');
    });
    test('windowresize', function () {
        var called = false, WindowBind = Control.extend('', {
                '{window} resize': function () {
                    called = true;
                }
            });
        this.fixture.appendChild(fragment('<div id=\'weird\'>'));
        new WindowBind('#weird');
        domDispatch.call(window, 'resize');
        ok(called, 'got window resize event');
    });
    test('on', 9, function () {
        var called = false, DelegateTest = Control.extend({
                click: function () {
                }
            }), Tester = Control.extend({
                init: function (el, ops) {
                    this.on(window, 'click', function (ev) {
                        ok(true, 'Got window click event');
                    });
                    this.on(window, 'click', 'clicked');
                    this.on('click', function () {
                        ok(true, 'Directly clicked element');
                    });
                    this.on('click', 'clicked');
                },
                clicked: function (context) {
                    ok(true, 'Controller action delegated click triggered, too');
                }
            }), div = document.createElement('div');
        this.fixture.appendChild(div);
        var rb = new Tester(div);
        this.fixture.appendChild(fragment('<div id=\'els\'><span id=\'elspan\'><a href=\'javascript://\' id=\'elsa\'>click me</a></span></div>'));
        var dt = new DelegateTest('#els');
        dt.on(document.querySelector('#els span'), 'a', 'click', function () {
            called = true;
        });
        domDispatch.call(document.querySelector('#els a'), 'click');
        ok(called, 'delegate works');
        domMutate.removeChild.call(this.fixture, document.querySelector('#els'));
        domDispatch.call(div, 'click');
        domDispatch.call(window, 'click');
        rb.destroy();
    });
    test('inherit', function () {
        var called = false, Parent = Control.extend({
                click: function () {
                    called = true;
                }
            }), Child = Parent.extend({});
        this.fixture.appendChild(fragment('<div id=\'els\'><span id=\'elspan\'><a href=\'#\' id=\'elsa\'>click me</a></span></div>'));
        new Child('#els');
        domDispatch.call(document.querySelector('#els'), 'click');
        ok(called, 'inherited the click method');
    });
    test('space makes event', 1, function () {
        var Dot = Control.extend({
            ' foo': function () {
                ok(true, 'called');
            }
        });
        this.fixture.appendChild(fragment('<div id=\'els\'><span id=\'elspan\'><a href=\'#\' id=\'elsa\'>click me</a></span></div>'));
        new Dot('#els');
        domDispatch.call(document.querySelector('#els'), 'foo');
    });
    test('custom events with hyphens work', 1, function () {
        this.fixture.appendChild(fragment('<div id=\'customEvent\'><span></span></div>'));
        var FooBar = Control.extend({
            'span custom-event': function () {
                ok(true, 'Custom event was fired.');
            }
        });
        new FooBar('#customEvent');
        domDispatch.call(document.querySelector('#customEvent span'), 'custom-event');
    });
    test('inherit defaults', function () {
        var BASE = Control.extend({ defaults: { foo: 'bar' } }, {});
        var INHERIT = BASE.extend({ defaults: { newProp: 'newVal' } }, {});
        ok(INHERIT.defaults.foo === 'bar', 'Class must inherit defaults from the parent class');
        ok(INHERIT.defaults.newProp === 'newVal', 'Class must have own defaults');
        var inst = new INHERIT(document.createElement('div'), {});
        ok(inst.options.foo === 'bar', 'Instance must inherit defaults from the parent class');
        ok(inst.options.newProp === 'newVal', 'Instance must have defaults of it`s class');
    });
    var bindable = function (b) {
        if (window.jQuery) {
            return b;
        } else {
        }
        return b;
    };
    test('on rebinding', 2, function () {
        var first = true;
        var Rebinder = Control.extend({
            '{item} foo': function (item, ev) {
                if (first) {
                    equal(item.id, 1, 'first item');
                    first = false;
                } else {
                    equal(item.id, 2, 'first item');
                }
            }
        });
        var item1 = bindable({ id: 1 }), item2 = bindable({ id: 2 }), rb = new Rebinder(document.createElement('div'), { item: item1 });
        canEvent.trigger.call(item1, 'foo');
        rb.options = { item: item2 };
        rb.on();
        canEvent.trigger.call(item2, 'foo');
    });
    test('actions provide method names', function () {
        var item1 = {};
        var item2 = {};
        var Tester = Control.extend({
            '{item1} foo': 'food',
            '{item2} bar': 'food',
            food: function (item, ev, data) {
                ok(true, 'food called');
                ok(item === item1 || item === item2, 'called with an item');
            }
        });
        new Tester(document.createElement('div'), {
            item1: item1,
            item2: item2
        });
        canEvent.trigger.call(item1, 'foo');
        canEvent.trigger.call(item2, 'bar');
    });
    test('Don\'t bind if there are undefined values in templates', function () {
        var C = Control.extend({}, {
            '{noExistStuff} proc': function () {
            }
        });
        var c = new C(document.createElement('div'));
        equal(c._bindings.user.length, 1, 'There is only one binding');
        var C2 = Control.extend({
            '{noExistStuff} click': function () {
                ok(false, 'should not fall through to click handler');
            }
        });
        var div = document.createElement('div');
        new C2(div, {});
        canEvent.trigger.call(div, 'click');
    });
    test('Multiple calls to destroy', 2, function () {
        var C = Control.extend({
                destroy: function () {
                    ok(true);
                    Control.prototype.destroy.call(this);
                }
            }), div = document.createElement('div'), c = new C(div);
        c.destroy();
        c.destroy();
    });
    test('drag and drop events', function () {
        expect(7);
        var DragDrop = Control.extend('', {
            ' dragstart': function () {
                ok(true, 'dragstart called');
            },
            ' dragenter': function () {
                ok(true, 'dragenter called');
            },
            ' dragover': function () {
                ok(true, 'dragover called');
            },
            ' dragleave': function () {
                ok(true, 'dragleave called');
            },
            ' drag': function () {
                ok(true, 'drag called');
            },
            ' drop': function () {
                ok(true, 'drop called');
            },
            ' dragend': function () {
                ok(true, 'dragend called');
            }
        });
        this.fixture.appendChild(fragment('<div id="draggable"/>'));
        new DragDrop('#draggable');
        var draggable = document.getElementById('draggable');
        domDispatch.call(draggable, 'dragstart');
        domDispatch.call(draggable, 'dragenter');
        domDispatch.call(draggable, 'dragover');
        domDispatch.call(draggable, 'dragleave');
        domDispatch.call(draggable, 'drag');
        domDispatch.call(draggable, 'drop');
        domDispatch.call(draggable, 'dragend');
    });
    test('beforeremove event', function () {
        expect(1);
        var Foo = Control.extend('', {
            'beforeremove': function () {
                ok(true, 'beforeremove called');
            }
        });
        var el = fragment('<div id="foo"/>');
        new Foo(el);
        domDispatch.call(el, 'beforeremove');
    });
    if (System.env.indexOf('production') < 0) {
        test('Control is logging information in dev mode', function () {
            expect(2);
            var oldlog = dev.log;
            var oldwarn = dev.warn;
            dev.log = function (text) {
                equal(text, 'can/control/control.js: No property found for handling {dummy} change', 'Text logged as expected');
            };
            var C = Control.extend({
                '{dummy} change': function () {
                }
            });
            var instance = new C(document.createElement('div'));
            dev.warn = function (text) {
                equal(text, 'can/control/control.js: Control already destroyed');
            };
            instance.destroy();
            instance.destroy();
            dev.warn = oldwarn;
            dev.log = oldlog;
        });
    }
    test('Uses types.wrapElement', function () {
        expect(3);
        var $ = function (element) {
            this.element = element;
        };
        var wrapElement = types.wrapElement;
        var unwrapElement = types.unwrapElement;
        types.wrapElement = function (element) {
            return new $(element);
        };
        types.unwrapElement = function (object) {
            return object.element;
        };
        var MyControl = Control.extend({
            init: function (element) {
                ok(element instanceof $, 'element is wrapped');
                ok(this.element instanceof $, 'this.element is wrapped');
            },
            'click': function (element) {
                types.wrapElement = wrapElement;
                types.unwrapElement = unwrapElement;
                ok(element instanceof $);
            }
        });
        var el = document.createElement('div');
        el.innerHTML = 'Click Me!';
        new MyControl(el);
        canEvent.trigger.call(el, 'click');
    });
    test('event handlers should rebind when target is replaced', function () {
        var nameChanges = 0;
        var MyControl = Control.extend({
            '{person.name} first': function () {
                nameChanges++;
            },
            name: function (name) {
                this.options.person.attr('name', name);
            }
        });
        var c = new MyControl(document.createElement('div'), { person: new CanMap({ name: { first: 'Kevin' } }) });
        c.options.person.attr('name.first', 'Tracy');
        c.name({ first: 'Kim' });
        c.options.person.attr('name.first', 'Max');
        equal(nameChanges, 2);
    });
    test('{element} event handling', function () {
        expect(3);
        stop();
        var MyControl = Control.extend({
            '{element} click': function (element) {
                if (element === this.element) {
                    ok(true, '`{element} click` should catch clicking on the element');
                } else {
                    ok(true, '`{element} click` should catch clicking on a child of the element');
                }
            },
            '{element} p click': function () {
                ok(true, '`{element} p click` works');
                start();
            }
        });
        var div = document.createElement('div');
        var p = document.createElement('p');
        div.appendChild(p);
        new MyControl(div, { foo: 'bar' });
        canEvent.trigger.call(div, 'click');
        canEvent.trigger.call(p, 'click');
    });
    test('Passing a Map as options works', function () {
        expect(2);
        stop();
        var MyControl = Control.extend({ defaults: { testEndEvent: 'mouseleave' } }, {
            '{element} {eventType}': function () {
                ok(true, 'catches handler from options');
            },
            '{element} {testEndEvent}': function () {
                ok(true, 'catches handler from defaults');
                start();
            }
        });
        var map = new CanMap({ eventType: 'click' });
        var div = document.createElement('div');
        new MyControl(div, map);
        map.attr('eventType', 'mouseenter');
        canEvent.trigger.call(div, 'mouseenter');
        canEvent.trigger.call(div, 'mouseleave');
    });
    test('Passing a DefineMap as options works', function () {
        expect(2);
        stop();
        var MyControl = Control.extend({ defaults: { testEndEvent: 'mouseleave' } }, {
            '{element} {eventType}': function () {
                ok(true, 'catches handler from options');
            },
            '{element} {testEndEvent}': function () {
                ok(true, 'catches handler from defaults');
                start();
            }
        });
        var MyMap = DefineMap.extend({
            eventType: 'string',
            testEndEvent: 'string'
        });
        var map = new MyMap();
        map.eventType = 'click';
        var div = document.createElement('div');
        new MyControl(div, map);
        map.eventType = 'mousenter';
        canEvent.trigger.call(div, 'mousenter');
        canEvent.trigger.call(div, 'mouseleave');
    });
    test('Creating an instance of a named control without passing an element', function () {
        var MyControl = Control.extend('MyControl');
        try {
            new MyControl();
        } catch (e) {
            ok(true, 'Caught an exception');
        }
    });
    test('Creating an instance of a named control passing a selector', function () {
        this.fixture.appendChild(fragment('<div id=\'my-control\'>d</div>'));
        var MyControl = Control.extend('MyControl');
        var myControlInstance = new MyControl('#my-control');
        ok(className.has.call(myControlInstance.element, 'MyControl'), 'Element has the correct class name');
    });
    test('destroy should not throw when domData is removed (#57)', function () {
        var Things = Control.extend({
            destroy: function () {
                if (this.element) {
                    domData.delete.call(this.element);
                }
                Control.prototype.destroy.call(this);
            }
        });
        this.fixture.appendChild(fragment('<div id=\'things\'>div<span>span</span></div>'));
        var things = document.getElementById('things');
        var c1 = new Things('#things', {});
        new Things('#things', {});
        equal(domData.get.call(things, 'controls').length, 2, 'there are 2 items in the data array');
        try {
            c1.destroy();
            QUnit.ok(true);
        } catch (e) {
            QUnit.ok(false, e);
        }
    });
});
/*can@3.9.0-pre.0#control/control_test*/
define('can@3.9.0-pre.0#control/control_test', function (require, exports, module) {
    require('can-control/can-control_test');
});
/*can-list@3.2.0#can-list_test*/
define('can-list@3.2.0#can-list_test', function (require, exports, module) {
    var List = require('can-list');
    var QUnit = require('steal-qunit');
    var Observation = require('can-observation');
    var Map = require('can-map');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    QUnit.module('can-list');
    test('list attr changes length', function () {
        var l = new List([
            0,
            1,
            2
        ]);
        l.attr(3, 3);
        equal(l.length, 4);
    });
    test('removeAttr on list', function () {
        var l = new List([
            0,
            1,
            2
        ]);
        l.removeAttr(1);
        equal(l.attr('length'), 2);
        deepEqual(l.attr(), [
            0,
            2
        ]);
    });
    test('list splice', function () {
        var l = new List([
                0,
                1,
                2,
                3
            ]), first = true;
        l.bind('change', function (ev, attr, how, newVals, oldVals) {
            equal(attr, '1');
            if (first) {
                equal(how, 'remove', 'removing items');
                equal(newVals, undefined, 'no new Vals');
            } else {
                deepEqual(newVals, [
                    'a',
                    'b'
                ], 'got the right newVals');
                equal(how, 'add', 'adding items');
            }
            first = false;
        });
        l.splice(1, 2, 'a', 'b');
        deepEqual(l.serialize(), [
            0,
            'a',
            'b',
            3
        ], 'serialized');
    });
    test('list pop', function () {
        var l = new List([
            0,
            1,
            2,
            3
        ]);
        l.bind('change', function (ev, attr, how, newVals, oldVals) {
            equal(attr, '3');
            equal(how, 'remove');
            equal(newVals, undefined);
            deepEqual(oldVals, [3]);
        });
        l.pop();
        deepEqual(l.serialize(), [
            0,
            1,
            2
        ]);
    });
    test('remove nested property in item of array map', function () {
        var state = new List([{ nested: true }]);
        state.bind('change', function (ev, attr, how, newVal, old) {
            equal(attr, '0.nested');
            equal(how, 'remove');
            deepEqual(old, true);
        });
        state.removeAttr('0.nested');
        equal(undefined, state.attr('0.nested'));
    });
    test('pop unbinds', function () {
        var l = new List([{ foo: 'bar' }]);
        var o = l.attr(0), count = 0;
        l.bind('change', function (ev, attr, how, newVal, oldVal) {
            count++;
            if (count === 1) {
                equal(attr, '0.foo', 'count is set');
            } else if (count === 2) {
                equal(how, 'remove');
                equal(attr, '0');
            } else {
                ok(false, 'called too many times');
            }
        });
        equal(o.attr('foo'), 'bar', 'read foo property');
        o.attr('foo', 'car');
        l.pop();
        o.attr('foo', 'bad');
    });
    test('splice unbinds', function () {
        var l = new List([{ foo: 'bar' }]);
        var o = l.attr(0), count = 0;
        l.bind('change', function (ev, attr, how, newVal, oldVal) {
            count++;
            if (count === 1) {
                equal(attr, '0.foo', 'count is set');
            } else if (count === 2) {
                equal(how, 'remove');
                equal(attr, '0');
            } else {
                ok(false, 'called too many times');
            }
        });
        equal(o.attr('foo'), 'bar');
        o.attr('foo', 'car');
        l.splice(0, 1);
        o.attr('foo', 'bad');
    });
    test('always gets right attr even after moving array items', function () {
        var l = new List([{ foo: 'bar' }]);
        var o = l.attr(0);
        l.unshift('A new Value');
        l.bind('change', function (ev, attr, how) {
            equal(attr, '1.foo');
        });
        o.attr('foo', 'led you');
    });
    test('Array accessor methods', 11, function () {
        var l = new List([
                'a',
                'b',
                'c'
            ]), sliced = l.slice(2), joined = l.join(' | '), concatenated = l.concat([
                2,
                1
            ], new List([0]));
        ok(sliced instanceof List, 'Slice is an Observable list');
        equal(sliced.length, 1, 'Sliced off two elements');
        equal(sliced[0], 'c', 'Single element as expected');
        equal(joined, 'a | b | c', 'Joined list properly');
        ok(concatenated instanceof List, 'Concatenated is an Observable list');
        deepEqual(concatenated.serialize(), [
            'a',
            'b',
            'c',
            2,
            1,
            0
        ], 'List concatenated properly');
        l.forEach(function (letter, index) {
            ok(true, 'Iteration');
            if (index === 0) {
                equal(letter, 'a', 'First letter right');
            }
            if (index === 2) {
                equal(letter, 'c', 'Last letter right');
            }
        });
    });
    test('Concatenated list items Equal original', function () {
        var l = new List([
                { firstProp: 'Some data' },
                { secondProp: 'Next data' }
            ]), concatenated = l.concat([
                { hello: 'World' },
                { foo: 'Bar' }
            ]);
        ok(l[0] === concatenated[0], 'They are Equal');
        ok(l[1] === concatenated[1], 'They are Equal');
    });
    test('Lists with maps concatenate properly', function () {
        var Person = Map.extend();
        var People = List.extend({ Map: Person }, {});
        var Genius = Person.extend();
        var Animal = Map.extend();
        var me = new Person({ name: 'John' });
        var animal = new Animal({ name: 'Tak' });
        var genius = new Genius({ name: 'Einstein' });
        var hero = { name: 'Ghandi' };
        var people = new People([]);
        var specialPeople = new People([
            genius,
            hero
        ]);
        people = people.concat([
            me,
            animal,
            specialPeople
        ], specialPeople, [
            1,
            2
        ], 3);
        ok(people.attr('length') === 8, 'List length is right');
        ok(people[0] === me, 'Map in list === vars created before concat');
        ok(people[1] instanceof Person, 'Animal got serialized to Person');
    });
    test('splice removes items in IE (#562)', function () {
        var l = new List(['a']);
        l.splice(0, 1);
        ok(!l.attr(0), 'all props are removed');
    });
    test('reverse triggers add/remove events (#851)', function () {
        expect(6);
        var l = new List([
            1,
            2,
            3
        ]);
        l.bind('change', function () {
            ok(true, 'change should be called');
        });
        l.bind('set', function () {
            ok(false, 'set should not be called');
        });
        l.bind('add', function () {
            ok(true, 'add called');
        });
        l.bind('remove', function () {
            ok(true, 'remove called');
        });
        l.bind('length', function () {
            ok(true, 'length should be called');
        });
        l.reverse();
    });
    test('filter', function () {
        var l = new List([
            {
                id: 1,
                name: 'John'
            },
            {
                id: 2,
                name: 'Mary'
            }
        ]);
        var filtered = l.filter(function (item) {
            return item.name === 'Mary';
        });
        notEqual(filtered._cid, l._cid, 'not same object');
        equal(filtered.length, 1, 'one item');
        equal(filtered[0].name, 'Mary', 'filter works');
    });
    test('removing expandos on lists', function () {
        var list = new List([
            'a',
            'b'
        ]);
        list.removeAttr('foo');
        equal(list.length, 2);
    });
    test('No Add Events if List Splice adds the same items that it is removing. (#1277, #1399)', function () {
        var list = new List([
            'a',
            'b'
        ]);
        list.bind('add', function () {
            ok(false, 'Add callback should not be called.');
        });
        list.bind('remove', function () {
            ok(false, 'Remove callback should not be called.');
        });
        var result = list.splice(0, 2, 'a', 'b');
        deepEqual(result, [
            'a',
            'b'
        ]);
    });
    test('add event always returns an array as the value (#998)', function () {
        var list = new List([]), msg;
        list.bind('add', function (ev, newElements, index) {
            deepEqual(newElements, [4], msg);
        });
        msg = 'works on push';
        list.push(4);
        list.pop();
        msg = 'works on attr()';
        list.attr(0, 4);
        list.pop();
        msg = 'works on replace()';
        list.replace([4]);
    });
    test('Setting with .attr() out of bounds of length triggers add event with leading undefineds', function () {
        var list = new List([1]);
        list.bind('add', function (ev, newElements, index) {
            deepEqual(newElements, [
                undefined,
                undefined,
                4
            ], 'Leading undefineds are included');
            equal(index, 1, 'Index takes into account the leading undefineds from a .attr()');
        });
        list.attr(3, 4);
    });
    test('No events should fire if removals happened on empty arrays', function () {
        var list = new List([]), msg;
        list.bind('remove', function (ev, removed, index) {
            ok(false, msg);
        });
        msg = 'works on pop';
        list.pop();
        msg = 'works on shift';
        list.shift();
        ok(true, 'No events were fired.');
    });
    test('setting an index out of bounds does not create an array', function () {
        expect(1);
        var l = new List();
        l.attr('1', 'foo');
        equal(l.attr('1'), 'foo');
    });
    test('splice with similar but less items works (#1606)', function () {
        var list = new List([
            'aa',
            'bb',
            'cc'
        ]);
        list.splice(0, list.length, 'aa', 'cc', 'dd');
        deepEqual(list.attr(), [
            'aa',
            'cc',
            'dd'
        ]);
        list.splice(0, list.length, 'aa', 'cc');
        deepEqual(list.attr(), [
            'aa',
            'cc'
        ]);
    });
    test('filter returns same list type (#1744)', function () {
        var ParentList = List.extend();
        var ChildList = ParentList.extend();
        var children = new ChildList([
            1,
            2,
            3
        ]);
        ok(children.filter(function () {
        }) instanceof ChildList);
    });
    test('reverse returns the same list instance (#1744)', function () {
        var ParentList = List.extend();
        var ChildList = ParentList.extend();
        var children = new ChildList([
            1,
            2,
            3
        ]);
        ok(children.reverse() === children);
    });
    test('slice and join are observable by a compute (#1884)', function () {
        expect(2);
        var list = new List([
            1,
            2,
            3
        ]);
        var sliced = new Observation(function () {
            return list.slice(0, 1);
        }, null, {
            updater: function (newVal) {
                deepEqual(newVal.attr(), [2], 'got a new List');
            }
        });
        sliced.start();
        var joined = new Observation(function () {
            return list.join(',');
        }, null, {
            updater: function (newVal) {
                equal(newVal, '2,3', 'joined is observable');
            }
        });
        joined.start();
        list.shift();
    });
    test('list is always updated with the last promise passed to replace (#2136)', function () {
        var list = new List();
        stop();
        list.replace(new Promise(function (resolve) {
            setTimeout(function () {
                resolve(['A']);
                setTimeout(function () {
                    equal(list.attr(0), 'B', 'list set to last promise\'s value');
                    start();
                }, 10);
            }, 20);
        }));
        list.replace(new Promise(function (resolve) {
            setTimeout(function () {
                resolve(['B']);
            }, 10);
        }));
    });
    test('forEach callback', function () {
        var list = new List([]), counter = 0;
        list.attr(9, 'foo');
        list.forEach(function (element, index, list) {
            counter++;
        });
        equal(counter, 1, 'Should not be invoked for uninitialized attr keys');
    });
    test('each callback', function () {
        var list = new List([]), counter = 0;
        list.attr(9, 'foo');
        list.each(function (item, index) {
            counter++;
        });
        equal(counter, 1, 'Should not be invoked for uninitialized attr keys');
    });
    test('filter with context', function () {
        var l = new List([{ id: 1 }]);
        var context = {};
        var contextWasCorrect = false;
        l.filter(function () {
            contextWasCorrect = this === context;
            return true;
        }, context);
        equal(contextWasCorrect, true, 'context was correctly passed');
    });
    test('map with context', function () {
        var l = new List([{ id: 1 }]);
        var context = {};
        var contextWasCorrect = false;
        l.map(function () {
            contextWasCorrect = this === context;
            return true;
        }, context);
        equal(contextWasCorrect, true, 'context was correctly passed');
    });
    test('works with can-reflect', 11, function () {
        var a = new Map({ foo: 4 });
        var b = new List([
            'foo',
            'bar'
        ]);
        QUnit.equal(canReflect.getKeyValue(b, '0'), 'foo', 'unbound value');
        var handler = function (newValue) {
            QUnit.equal(newValue, 'quux', 'observed new value');
        };
        QUnit.ok(!canReflect.isValueLike(b), 'isValueLike is false');
        QUnit.ok(canReflect.isMapLike(b), 'isMapLike is true');
        QUnit.ok(canReflect.isListLike(b), 'isListLike is false');
        QUnit.ok(!canReflect.keyHasDependencies(b, 'length'), 'keyHasDependencies -- false');
        b._computedAttrs['length'] = {
            compute: new Observation(function () {
                return a.attr('foo');
            }, null)
        };
        b._computedAttrs['length'].compute.start();
        QUnit.ok(canReflect.keyHasDependencies(b, 'length'), 'keyHasDependencies -- true');
        canReflect.onKeysAdded(b, handler);
        canReflect.onKeysRemoved(b, handler);
        QUnit.ok(b.__bindEvents.add, 'add handler added');
        QUnit.ok(b.__bindEvents.remove, 'remove handler added');
        b.push('quux');
        QUnit.equal(canReflect.getKeyValue(b, 'length'), '4', 'bound value');
        b.pop();
    });
    QUnit.test('can-reflect setKeyValue', function () {
        var a = new Map({ 'a': 'b' });
        canReflect.setKeyValue(a, 'a', 'c');
        QUnit.equal(a.attr('a'), 'c', 'setKeyValue');
    });
    QUnit.test('can-reflect getKeyDependencies', function () {
        var a = new Map({ foo: 4 });
        var b = new List([
            'foo',
            'bar'
        ]);
        ok(!canReflect.getKeyDependencies(b, 'length'), 'No dependencies before binding');
        b._computedAttrs.length = {
            compute: new Observation(function () {
                return a.attr('foo');
            }, null)
        };
        b._computedAttrs.length.compute.start();
        ok(canReflect.getKeyDependencies(b, 'length'), 'dependencies exist');
        ok(canReflect.getKeyDependencies(b, 'length').valueDependencies.has(b._computedAttrs.length.compute), 'dependencies returned');
    });
    QUnit.test('registered symbols', function () {
        var a = new Map({ 'a': 'a' });
        ok(a[canSymbol.for('can.isMapLike')], 'can.isMapLike');
        equal(a[canSymbol.for('can.getKeyValue')]('a'), 'a', 'can.getKeyValue');
        a[canSymbol.for('can.setKeyValue')]('a', 'b');
        equal(a.attr('a'), 'b', 'can.setKeyValue');
        function handler(val) {
            equal(val, 'c', 'can.onKeyValue');
        }
        a[canSymbol.for('can.onKeyValue')]('a', handler);
        a.attr('a', 'c');
        a[canSymbol.for('can.offKeyValue')]('a', handler);
        a.attr('a', 'd');
    });
});
/*can@3.9.0-pre.0#list/list_test*/
define('can@3.9.0-pre.0#list/list_test', function (require, exports, module) {
    require('can-list/can-list_test');
});
/*can-map@3.3.1#can-map_test*/
define('can-map@3.3.1#can-map_test', function (require, exports, module) {
    var Map = require('can-map');
    var QUnit = require('steal-qunit');
    var Observation = require('can-observation');
    var Construct = require('can-construct');
    var observeReader = require('can-stache-key');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var canCompute = require('can-compute');
    QUnit.module('can-map');
    test('Basic Map', 4, function () {
        var state = new Map({
            category: 5,
            productType: 4
        });
        state.bind('change', function (ev, attr, how, val, old) {
            equal(attr, 'category', 'correct change name');
            equal(how, 'set');
            equal(val, 6, 'correct');
            equal(old, 5, 'correct');
        });
        state.attr('category', 6);
        state.unbind('change');
    });
    test('Nested Map', 5, function () {
        var me = new Map({
            name: {
                first: 'Justin',
                last: 'Meyer'
            }
        });
        ok(me.attr('name') instanceof Map);
        me.bind('change', function (ev, attr, how, val, old) {
            equal(attr, 'name.first', 'correct change name');
            equal(how, 'set');
            equal(val, 'Brian', 'correct');
            equal(old, 'Justin', 'correct');
        });
        me.attr('name.first', 'Brian');
        me.unbind('change');
    });
    test('remove attr', function () {
        var state = new Map({
            category: 5,
            productType: 4
        });
        state.removeAttr('category');
        deepEqual(Map.keys(state), ['productType'], 'one property');
    });
    test('remove attr on key with dot', function () {
        var state = new Map({
            'key.with.dots': 12,
            productType: 4
        });
        var state2 = new Map({
            'key.with.dots': 4,
            key: { 'with': { someValue: 20 } }
        });
        state.removeAttr('key.with.dots');
        state2.removeAttr('key.with.someValue');
        deepEqual(Map.keys(state), ['productType'], 'one property');
        deepEqual(Map.keys(state2), [
            'key.with.dots',
            'key'
        ], 'two properties');
        deepEqual(Map.keys(state2.key['with']), [], 'zero properties');
    });
    test('nested event handlers are not run by changing the parent property (#280)', function () {
        var person = new Map({ name: { first: 'Justin' } });
        person.bind('name.first', function (ev, newName) {
            ok(false, 'name.first should never be called');
        });
        person.bind('name', function () {
            ok(true, 'name event triggered');
        });
        person.attr('name', { first: 'Hank' });
    });
    test('cyclical objects (#521)', function () {
        var foo = {};
        foo.foo = foo;
        var fooed = new Map(foo);
        ok(true, 'did not cause infinate recursion');
        ok(fooed.attr('foo') === fooed, 'map points to itself');
        var me = { name: 'Justin' };
        var references = {
            husband: me,
            friend: me
        };
        var ref = new Map(references);
        ok(ref.attr('husband') === ref.attr('friend'), 'multiple properties point to the same thing');
    });
    test('_cid add to original object', function () {
        var map = new Map(), obj = { 'name': 'thecountofzero' };
        map.attr('myObj', obj);
        ok(!obj._cid, '_cid not added to original object');
    });
    test('Map serialize triggers reading (#626)', function () {
        var old = Observation.add;
        var attributesRead = [];
        var readingTriggeredForKeys = false;
        Observation.add = function (object, attribute) {
            if (attribute === '__keys') {
                readingTriggeredForKeys = true;
            } else {
                attributesRead.push(attribute);
            }
        };
        var testMap = new Map({
            cats: 'meow',
            dogs: 'bark'
        });
        testMap.serialize();
        ok(attributesRead.indexOf('cats') !== -1 && attributesRead.indexOf('dogs') !== -1, 'map serialization triggered __reading on all attributes');
        ok(readingTriggeredForKeys, 'map serialization triggered __reading for __keys');
        Observation.add = old;
    });
    test('Test top level attributes', 7, function () {
        var test = new Map({
            'my.enable': false,
            'my.item': true,
            'my.count': 0,
            'my.newCount': 1,
            'my': {
                'value': true,
                'nested': { 'value': 100 }
            }
        });
        equal(test.attr('my.value'), true, 'correct');
        equal(test.attr('my.nested.value'), 100, 'correct');
        ok(test.attr('my.nested') instanceof Map);
        equal(test.attr('my.enable'), false, 'falsey (false) value accessed correctly');
        equal(test.attr('my.item'), true, 'truthey (true) value accessed correctly');
        equal(test.attr('my.count'), 0, 'falsey (0) value accessed correctly');
        equal(test.attr('my.newCount'), 1, 'falsey (1) value accessed correctly');
    });
    test('serializing cycles', function () {
        var map1 = new Map({ name: 'map1' });
        var map2 = new Map({ name: 'map2' });
        map1.attr('map2', map2);
        map2.attr('map1', map1);
        var res = map1.serialize();
        equal(res.name, 'map1');
        equal(res.map2.name, 'map2');
    });
    test('Unbinding from a map with no bindings doesn\'t throw an error (#1015)', function () {
        expect(0);
        var test = new Map({});
        try {
            test.unbind('change');
        } catch (e) {
            ok(false, 'No error should be thrown');
        }
    });
    test('Fast dispatch event still has target and type (#1082)', 4, function () {
        var data = new Map({ name: 'CanJS' });
        data.bind('change', function (ev) {
            equal(ev.type, 'change');
            equal(ev.target, data);
        });
        data.bind('name', function (ev) {
            equal(ev.type, 'name');
            equal(ev.target, data);
        });
        data.attr('name', 'David');
    });
    test('map passed to Map constructor (#1166)', function () {
        function y() {
        }
        var map = new Map({
            x: 1,
            y: y
        });
        var res = new Map(map);
        deepEqual(res.attr(), {
            x: 1,
            y: y
        }, 'has the same properties');
    });
    test('constructor passed to scope is threated as a property (#1261)', function () {
        var Constructor = Construct.extend({});
        var MyMap = Map.extend({ Todo: Constructor });
        var m = new MyMap();
        equal(m.attr('Todo'), Constructor);
    });
    test('_bindings count maintained after calling .off() on undefined property (#1490) ', function () {
        var map = new Map({ test: 1 });
        map.on('test', function () {
        });
        equal(map.__bindEvents._lifecycleBindings, 1, 'The number of bindings is correct');
        map.off('undefined_property');
        equal(map.__bindEvents._lifecycleBindings, 1, 'The number of bindings is still correct');
    });
    test('Should be able to get and set attribute named \'watch\' on Map in Firefox', function () {
        var map = new Map({});
        map.attr('watch');
        ok(true, 'can have attribute named \'watch\' on a Map instance');
    });
    test('Should be able to get and set attribute named \'unwatch\' on Map in Firefox', function () {
        var map = new Map({});
        map.attr('unwatch');
        ok(true, 'can have attribute named \'unwatch\' on a Map instance');
    });
    test('should get an empty string property value correctly', function () {
        var map = new Map({
            foo: 'foo',
            '': 'empty string'
        });
        equal(map.attr(''), 'empty string');
    });
    test('ObserveReader - can.Construct derived classes should be considered objects, not functions (#450)', function () {
        var foostructor = Map.extend({ text: 'bar' }, {}), obj = {
                next_level: {
                    thing: foostructor,
                    text: 'In the inner context'
                }
            }, read;
        foostructor.self = foostructor;
        read = observeReader.read(obj, observeReader.reads('next_level.thing.self.text'));
        equal(read.value, 'bar', 'static properties on a can.Construct-based function');
        read = observeReader.read(obj, observeReader.reads('next_level.thing.self'), { isArgument: true });
        ok(read.value === foostructor, 'arguments shouldn\'t be executed');
        foostructor.self = function () {
            return foostructor;
        };
        read = observeReader.read(obj, observeReader.reads('next_level.thing.self.text'), {});
        equal(read.value, 'bar', 'anonymous functions in the middle of a read should be executed if requested');
    });
    test('Basic Map.prototype.compute', function () {
        var state = new Map({
            category: 5,
            productType: 4
        });
        var catCompute = state.compute('category');
        var prodCompute = state.compute('productType');
        catCompute.bind('change', function (ev, val, old) {
            equal(val, 6, 'correct');
            equal(old, 5, 'correct');
        });
        state.bind('productType', function (ev, val, old) {
            equal(val, 5, 'correct');
            equal(old, 4, 'correct');
        });
        state.attr('category', 6);
        prodCompute(5);
        catCompute.unbind('change');
        state.unbind('productType');
    });
    test('Deep Map.prototype.compute', function () {
        var state = new Map({
            product: {
                category: 5,
                productType: 4
            }
        });
        var catCompute = state.compute('product.category');
        var prodCompute = state.compute('product.productType');
        catCompute.bind('change', function (ev, val, old) {
            equal(val, 6, 'correct');
            equal(old, 5, 'correct');
        });
        state.attr('product').bind('productType', function (ev, val, old) {
            equal(val, 5, 'correct');
            equal(old, 4, 'correct');
        });
        state.attr('product.category', 6);
        prodCompute(5);
        catCompute.unbind('change');
        state.unbind('productType');
    });
    test('works with can-reflect', 7, function () {
        var b = new Map({ 'foo': 'bar' });
        var c = new (Map.extend({
            'baz': canCompute(function () {
                return b.attr('foo');
            })
        }))({
            'foo': 'bar',
            thud: 'baz'
        });
        QUnit.equal(canReflect.getKeyValue(b, 'foo'), 'bar', 'unbound value');
        var handler = function (newValue) {
            QUnit.equal(newValue, 'quux', 'observed new value');
            canReflect.offKeyValue(c, 'baz', handler);
        };
        QUnit.ok(!canReflect.isValueLike(c), 'isValueLike is false');
        QUnit.ok(canReflect.isMapLike(c), 'isMapLike is true');
        QUnit.ok(!canReflect.isListLike(c), 'isListLike is false');
        canReflect.onKeyValue(c, 'baz', handler);
        canReflect.onKeyValue(c, 'thud', handler);
        b.attr('foo', 'quux');
        c.attr('thud', 'quux');
        QUnit.equal(canReflect.getKeyValue(c, 'baz'), 'quux', 'bound value');
        b.attr('foo', 'thud');
        c.attr('baz', 'jeek');
    });
    QUnit.test('can-reflect setKeyValue', function () {
        var a = new Map({ 'a': 'b' });
        canReflect.setKeyValue(a, 'a', 'c');
        QUnit.equal(a.attr('a'), 'c', 'setKeyValue');
    });
    QUnit.test('can-reflect getKeyDependencies', function () {
        var a = new Map({ 'a': 'a' });
        var b = new (Map.extend({
            'a': canCompute(function () {
                return a.attr('a');
            }),
            'b': 'b'
        }))();
        ok(canReflect.getKeyDependencies(b, 'a'), 'Dependencies on computed attr');
        ok(!canReflect.getKeyDependencies(b, 'b'), 'No dependencies on data attr');
        b.on('a', function () {
        });
        ok(canReflect.getKeyDependencies(b, 'a').valueDependencies.has(b._computedAttrs.a.compute), 'dependencies returned');
        ok(canReflect.getValueDependencies(b._computedAttrs.a.compute).valueDependencies, 'dependencies returned from compute');
    });
    QUnit.test('registered symbols', function () {
        var a = new Map({ 'a': 'a' });
        ok(a[canSymbol.for('can.isMapLike')], 'can.isMapLike');
        equal(a[canSymbol.for('can.getKeyValue')]('a'), 'a', 'can.getKeyValue');
        a[canSymbol.for('can.setKeyValue')]('a', 'b');
        equal(a.attr('a'), 'b', 'can.setKeyValue');
        function handler(val) {
            equal(this, a);
            equal(val, 'c', 'can.onKeyValue');
        }
        a[canSymbol.for('can.onKeyValue')]('a', handler);
        a.attr('a', 'c');
        a[canSymbol.for('can.offKeyValue')]('a', handler);
        a.attr('a', 'd');
    });
});
/*can@3.9.0-pre.0#map/map_test*/
define('can@3.9.0-pre.0#map/map_test', function (require, exports, module) {
    require('can-map/can-map_test');
});
/*can-map-define@3.1.1#can-map-define*/
define('can-map-define@3.1.1#can-map-define', function (require, exports, module) {
    var dev = require('can-util/js/dev/dev');
    var extend = require('can-util/js/assign/assign');
    var isPlainObject = require('can-util/js/is-plain-object/is-plain-object');
    var canEvent = require('can-event');
    var batch = require('can-event/batch/batch');
    var mapHelpers = require('can-map/map-helpers');
    var CanMap = require('can-map');
    var compute = require('can-compute');
    require('can-list');
    var define = {};
    var getPropDefineBehavior = function (behavior, attr, define) {
        var prop, defaultProp;
        if (define) {
            prop = define[attr];
            defaultProp = define['*'];
            if (prop && prop[behavior] !== undefined) {
                return prop[behavior];
            } else if (defaultProp && defaultProp[behavior] !== undefined) {
                return defaultProp[behavior];
            }
        }
    };
    mapHelpers.define = function (Map, baseDefine) {
        var definitions = Map.prototype.define;
        if (baseDefine) {
            var defines = {};
            mapHelpers.twoLevelDeepExtend(defines, baseDefine);
            mapHelpers.twoLevelDeepExtend(defines, definitions);
            extend(definitions, defines);
        }
        Map.defaultGenerators = {};
        for (var prop in definitions) {
            var type = definitions[prop].type;
            if (typeof type === 'string') {
                if (typeof define.types[type] === 'object') {
                    delete definitions[prop].type;
                    extend(definitions[prop], define.types[type]);
                }
            }
            if ('value' in definitions[prop]) {
                if (typeof definitions[prop].value === 'function') {
                    Map.defaultGenerators[prop] = definitions[prop].value;
                } else {
                    Map.defaults[prop] = definitions[prop].value;
                }
            }
            if (typeof definitions[prop].Value === 'function') {
                (function (Constructor) {
                    Map.defaultGenerators[prop] = function () {
                        return new Constructor();
                    };
                }(definitions[prop].Value));
            }
        }
    };
    var oldSetupDefaults = CanMap.prototype._setupDefaults;
    CanMap.prototype._setupDefaults = function (obj) {
        var defaults = extend({}, oldSetupDefaults.call(this)), propsCommittedToAttr = {}, Map = this.constructor, originalGet = this._get;
        this._get = function (originalProp) {
            var prop = originalProp.indexOf('.') !== -1 ? originalProp.substr(0, originalProp.indexOf('.')) : originalProp;
            if (prop in defaults && !(prop in propsCommittedToAttr)) {
                this.attr(prop, defaults[prop]);
                propsCommittedToAttr[prop] = true;
            }
            return originalGet.apply(this, arguments);
        };
        for (var prop in Map.defaultGenerators) {
            if (!obj || !(prop in obj)) {
                defaults[prop] = Map.defaultGenerators[prop].call(this);
            }
        }
        delete this._get;
        return defaults;
    };
    var proto = CanMap.prototype, oldSet = proto.__set;
    proto.__set = function (prop, value, current, success, error) {
        var self = this;
        var errorCallback = function (errors) {
                var stub = error && error.call(self, errors);
                if (stub !== false) {
                    canEvent.trigger(self, 'error', [
                        prop,
                        errors
                    ], true);
                }
                return false;
            }, setter = getPropDefineBehavior('set', prop, this.define), getter = getPropDefineBehavior('get', prop, this.define);
        if (setter) {
            batch.start();
            var setterCalled = false, setValue = setter.call(this, value, function (value) {
                    if (getter) {
                        self[prop](value);
                    } else {
                        oldSet.call(self, prop, value, current, success, errorCallback);
                    }
                    setterCalled = true;
                }, errorCallback, getter ? this._computedAttrs[prop].compute.computeInstance.lastSetValue.get() : current);
            if (getter) {
                if (setValue !== undefined && !setterCalled && setter.length >= 1) {
                    this._computedAttrs[prop].compute(setValue);
                }
                batch.stop();
                return;
            } else if (setValue === undefined && !setterCalled && setter.length > 1) {
                batch.stop();
                return;
            } else {
                if (!setterCalled) {
                    oldSet.call(self, prop, setter.length === 0 && setValue === undefined ? value : setValue, current, success, errorCallback);
                }
                batch.stop();
                return this;
            }
        } else {
            oldSet.call(self, prop, value, current, success, errorCallback);
        }
        return this;
    };
    define.types = {
        'date': function (str) {
            var type = typeof str;
            if (type === 'string') {
                str = Date.parse(str);
                return isNaN(str) ? null : new Date(str);
            } else if (type === 'number') {
                return new Date(str);
            } else {
                return str;
            }
        },
        'number': function (val) {
            if (val == null) {
                return val;
            }
            return +val;
        },
        'boolean': function (val) {
            if (val == null) {
                return val;
            }
            if (val === 'false' || val === '0' || !val) {
                return false;
            }
            return true;
        },
        'htmlbool': function (val) {
            return typeof val === 'string' || !!val;
        },
        '*': function (val) {
            return val;
        },
        'string': function (val) {
            if (val == null) {
                return val;
            }
            return '' + val;
        },
        'compute': {
            set: function (newValue, setVal, setErr, oldValue) {
                if (newValue && newValue.isComputed) {
                    return newValue;
                }
                if (oldValue && oldValue.isComputed) {
                    oldValue(newValue);
                    return oldValue;
                }
                return newValue;
            },
            get: function (value) {
                return value && value.isComputed ? value() : value;
            }
        }
    };
    var oldType = proto.__type;
    proto.__type = function (value, prop) {
        var type = getPropDefineBehavior('type', prop, this.define), Type = getPropDefineBehavior('Type', prop, this.define), newValue = value;
        if (typeof type === 'string') {
            type = define.types[type];
        }
        if (type || Type) {
            if (type) {
                newValue = type.call(this, newValue, prop);
            }
            if (Type && newValue != null && !(newValue instanceof Type)) {
                newValue = new Type(newValue);
            }
            return newValue;
        } else if (isPlainObject(newValue) && newValue.define) {
            newValue = CanMap.extend(newValue);
            newValue = new newValue();
        }
        return oldType.call(this, newValue, prop);
    };
    var oldRemove = proto.__remove;
    proto.__remove = function (prop, current) {
        var remove = getPropDefineBehavior('remove', prop, this.define), res;
        if (remove) {
            batch.start();
            res = remove.call(this, current);
            if (res === false) {
                batch.stop();
                return;
            } else {
                res = oldRemove.call(this, prop, current);
                batch.stop();
                return res;
            }
        }
        return oldRemove.call(this, prop, current);
    };
    var oldSetupComputes = proto._setupComputedProperties;
    proto._setupComputedProperties = function () {
        oldSetupComputes.apply(this, arguments);
        for (var attr in this.define) {
            var def = this.define[attr], get = def.get;
            if (get) {
                mapHelpers.addComputedAttr(this, attr, compute.async(undefined, get, this));
            }
        }
    };
    var oldSingleSerialize = proto.___serialize;
    var serializeProp = function (map, attr, val) {
        var serializer = attr === '*' ? false : getPropDefineBehavior('serialize', attr, map.define);
        if (serializer === undefined) {
            return oldSingleSerialize.call(map, attr, val);
        } else if (serializer !== false) {
            return typeof serializer === 'function' ? serializer.call(map, val, attr) : oldSingleSerialize.call(map, attr, val);
        }
    };
    proto.___serialize = function (name, val) {
        return serializeProp(this, name, val);
    };
    var oldSerialize = proto.serialize;
    proto.serialize = function (property) {
        var serialized = oldSerialize.apply(this, arguments);
        if (property) {
            return serialized;
        }
        var serializer, val;
        for (var attr in this.define) {
            if (!(attr in serialized)) {
                serializer = this.define && (this.define[attr] && this.define[attr].serialize || this.define['*'] && this.define['*'].serialize);
                if (serializer) {
                    val = serializeProp(this, attr, this.attr(attr));
                    if (val !== undefined) {
                        serialized[attr] = val;
                    }
                }
            }
        }
        return serialized;
    };
    module.exports = define;
});
/*can-map-define@3.1.1#can-map-define_test*/
define('can-map-define@3.1.1#can-map-define_test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var string = require('can-util/js/string/string');
    var CanMap = require('can-map');
    var List = require('can-list');
    var compute = require('can-compute');
    require('./can-map-define');
    QUnit.module('can/map/define');
    test('basics set', function () {
        var Defined = CanMap.extend({
            define: {
                prop: {
                    set: function (newVal) {
                        return 'foo' + newVal;
                    }
                }
            }
        });
        var def = new Defined();
        def.attr('prop', 'bar');
        equal(def.attr('prop'), 'foobar', 'setter works');
        Defined = CanMap.extend({
            define: {
                prop: {
                    set: function (newVal, setter) {
                        setter('foo' + newVal);
                    }
                }
            }
        });
        def = new Defined();
        def.attr('prop', 'bar');
        equal(def.attr('prop'), 'foobar', 'setter callback works');
    });
    test('basics remove', function () {
        var ViewModel = CanMap.extend({
            define: {
                makeId: {
                    remove: function () {
                        this.removeAttr('models');
                    }
                },
                models: {
                    remove: function () {
                        this.removeAttr('modelId');
                    }
                },
                modelId: {
                    remove: function () {
                        this.removeAttr('years');
                    }
                },
                years: {
                    remove: function () {
                        this.removeAttr('year');
                    }
                }
            }
        });
        var mmy = new ViewModel({
            makes: [{ id: 1 }],
            makeId: 1,
            models: [{ id: 2 }],
            modelId: 2,
            years: [2010],
            year: 2010
        });
        var events = [
                'year',
                'years',
                'modelId',
                'models',
                'makeId'
            ], eventCount = 0, batchNum;
        mmy.bind('change', function (ev, attr) {
            if (batchNum === undefined) {
                batchNum = ev.batchNum;
            }
            equal(attr, events[eventCount++], 'got correct attribute');
            ok(ev.batchNum && ev.batchNum === batchNum, 'batched');
        });
        mmy.removeAttr('makeId');
    });
    test('basics get', function () {
        var Person = CanMap.extend({
            define: {
                fullName: {
                    get: function () {
                        return this.attr('first') + ' ' + this.attr('last');
                    }
                }
            }
        });
        var p = new Person({
            first: 'Justin',
            last: 'Meyer'
        });
        equal(p.attr('fullName'), 'Justin Meyer', 'sync getter works');
        var Adder = CanMap.extend({
            define: {
                more: {
                    get: function (curVal, setVal) {
                        var num = this.attr('num');
                        setTimeout(function () {
                            setVal(num + 1);
                        }, 10);
                    }
                }
            }
        });
        var a = new Adder({ num: 1 }), callbackVals = [
                [
                    2,
                    undefined,
                    function () {
                        a.attr('num', 2);
                    }
                ],
                [
                    3,
                    2,
                    function () {
                        start();
                    }
                ]
            ], callbackCount = 0;
        a.bind('more', function (ev, newVal, oldVal) {
            var vals = callbackVals[callbackCount++];
            equal(newVal, vals[0], 'newVal is correct');
            equal(a.attr('more'), vals[0], 'attr value is correct');
            equal(oldVal, vals[1], 'oldVal is correct');
            setTimeout(vals[2], 10);
        });
        stop();
    });
    test('basic type', function () {
        expect(6);
        var Typer = CanMap.extend({
            define: {
                arrayWithAddedItem: {
                    type: function (value) {
                        if (value && value.push) {
                            value.push('item');
                        }
                        return value;
                    }
                },
                listWithAddedItem: {
                    type: function (value) {
                        if (value && value.push) {
                            value.push('item');
                        }
                        return value;
                    },
                    Type: List
                }
            }
        });
        var t = new Typer();
        deepEqual(CanMap.keys(t), [], 'no keys');
        var array = [];
        t.attr('arrayWithAddedItem', array);
        deepEqual(array, ['item'], 'updated array');
        equal(t.attr('arrayWithAddedItem'), array, 'leave value as array');
        t.attr('listWithAddedItem', []);
        ok(t.attr('listWithAddedItem') instanceof List, 'convert to List');
        equal(t.attr('listWithAddedItem').attr(0), 'item', 'has item in it');
        t.bind('change', function (ev, attr) {
            equal(attr, 'listWithAddedItem.1', 'got a bubbling event');
        });
        t.attr('listWithAddedItem').push('another item');
    });
    test('basic Type', function () {
        var Foo = function (name) {
            this.name = name;
        };
        Foo.prototype.getName = function () {
            return this.name;
        };
        var Typer = CanMap.extend({ define: { foo: { Type: Foo } } });
        var t = new Typer({ foo: 'Justin' });
        equal(t.attr('foo').getName(), 'Justin', 'correctly created an instance');
        var brian = new Foo('brian');
        t.attr('foo', brian);
        equal(t.attr('foo'), brian, 'same instances');
    });
    test('type converters', function () {
        var Typer = CanMap.extend({
            define: {
                date: { type: 'date' },
                string: { type: 'string' },
                number: { type: 'number' },
                'boolean': { type: 'boolean' },
                htmlbool: { type: 'htmlbool' },
                leaveAlone: { type: '*' }
            }
        });
        var obj = {};
        var t = new Typer({
            date: 1395896701516,
            string: 5,
            number: '5',
            'boolean': 'false',
            htmlbool: '',
            leaveAlone: obj
        });
        ok(t.attr('date') instanceof Date, 'converted to date');
        equal(t.attr('string'), '5', 'converted to string');
        equal(t.attr('number'), 5, 'converted to number');
        equal(t.attr('boolean'), false, 'converted to boolean');
        equal(t.attr('htmlbool'), true, 'converted to htmlbool');
        equal(t.attr('leaveAlone'), obj, 'left as object');
        t.attr({ 'number': '15' });
        ok(t.attr('number') === 15, 'converted to number');
    });
    test('basics value', function () {
        var Typer = CanMap.extend({ define: { prop: { value: 'foo' } } });
        equal(new Typer().attr('prop'), 'foo', 'value is used as default value');
        var Typer2 = CanMap.extend({
            define: {
                prop: {
                    value: function () {
                        return [];
                    },
                    type: '*'
                }
            }
        });
        var t1 = new Typer2(), t2 = new Typer2();
        ok(t1.attr('prop') !== t2.attr('prop'), 'different array instances');
        ok(Array.isArray(t1.attr('prop')), 'its an array');
    });
    test('basics Value', function () {
        var Typer = CanMap.extend({
            define: {
                prop: {
                    Value: Array,
                    type: '*'
                }
            }
        });
        var t1 = new Typer(), t2 = new Typer();
        ok(t1.attr('prop') !== t2.attr('prop'), 'different array instances');
        ok(Array.isArray(t1.attr('prop')), 'its an array');
    });
    test('setter with no arguments and returns undefined does the default behavior, the setter is for side effects only', function () {
        var Typer = CanMap.extend({
            define: {
                prop: {
                    set: function () {
                        this.attr('foo', 'bar');
                    }
                }
            }
        });
        var t = new Typer();
        t.attr('prop', false);
        deepEqual(t.attr(), {
            foo: 'bar',
            prop: false
        });
    });
    test('type happens before the set', function () {
        var MyMap = CanMap.extend({
            define: {
                prop: {
                    type: 'number',
                    set: function (newValue) {
                        equal(typeof newValue, 'number', 'got a number');
                        return newValue + 1;
                    }
                }
            }
        });
        var map = new MyMap();
        map.attr('prop', '5');
        equal(map.attr('prop'), 6, 'number');
    });
    test('getter and setter work', function () {
        expect(5);
        var Paginate = CanMap.extend({
            define: {
                page: {
                    set: function (newVal) {
                        this.attr('offset', (parseInt(newVal) - 1) * this.attr('limit'));
                    },
                    get: function () {
                        return Math.floor(this.attr('offset') / this.attr('limit')) + 1;
                    }
                }
            }
        });
        var p = new Paginate({
            limit: 10,
            offset: 20
        });
        equal(p.attr('page'), 3, 'page get right');
        p.bind('page', function (ev, newValue, oldValue) {
            equal(newValue, 2, 'got new value event');
            equal(oldValue, 3, 'got old value event');
        });
        p.attr('page', 2);
        equal(p.attr('page'), 2, 'page set right');
        equal(p.attr('offset'), 10, 'page offset set');
    });
    test('getter with initial value', function () {
        var comp = compute(1);
        var Grabber = CanMap.extend({
            define: {
                vals: {
                    type: '*',
                    Value: Array,
                    get: function (current, setVal) {
                        if (setVal) {
                            current.push(comp());
                        }
                        return current;
                    }
                }
            }
        });
        var g = new Grabber();
        equal(g.attr('vals').length, 0, 'zero items in array');
    });
    test('serialize basics', function () {
        var MyMap = CanMap.extend({
            define: {
                name: {
                    serialize: function () {
                        return;
                    }
                },
                locations: { serialize: false },
                locationIds: {
                    get: function () {
                        var ids = [];
                        this.attr('locations').each(function (location) {
                            ids.push(location.id);
                        });
                        return ids;
                    },
                    serialize: function (locationIds) {
                        return locationIds.join(',');
                    }
                },
                bared: {
                    get: function () {
                        return this.attr('name') + '+bar';
                    },
                    serialize: true
                },
                ignored: {
                    get: function () {
                        return this.attr('name') + '+ignored';
                    }
                }
            }
        });
        var map = new MyMap({ name: 'foo' });
        map.attr('locations', [
            {
                id: 1,
                name: 'Chicago'
            },
            {
                id: 2,
                name: 'LA'
            }
        ]);
        equal(map.attr('locationIds').length, 2, 'get locationIds');
        equal(map.attr('locationIds')[0], 1, 'get locationIds index 0');
        equal(map.attr('locations')[0].id, 1, 'get locations index 0');
        var serialized = map.serialize();
        equal(serialized.locations, undefined, 'locations doesn\'t serialize');
        equal(serialized.locationIds, '1,2', 'locationIds serializes');
        equal(serialized.name, undefined, 'name doesn\'t serialize');
        equal(serialized.bared, 'foo+bar', 'true adds computed props');
        equal(serialized.ignored, undefined, 'computed props are not serialized by default');
    });
    test('serialize context', function () {
        var context, serializeContext;
        var MyMap = CanMap.extend({
            define: {
                name: {
                    serialize: function (obj) {
                        context = this;
                        return obj;
                    }
                }
            },
            serialize: function () {
                serializeContext = this;
                CanMap.prototype.serialize.apply(this, arguments);
            }
        });
        var map = new MyMap();
        map.serialize();
        equal(context, map);
        equal(serializeContext, map);
    });
    test('methods contexts', function () {
        var contexts = {};
        var MyMap = CanMap.extend({
            define: {
                name: {
                    value: 'John Galt',
                    get: function (obj) {
                        contexts.get = this;
                        return obj;
                    },
                    remove: function (obj) {
                        contexts.remove = this;
                        return obj;
                    },
                    set: function (obj) {
                        contexts.set = this;
                        return obj;
                    },
                    serialize: function (obj) {
                        contexts.serialize = this;
                        return obj;
                    },
                    type: function (val) {
                        contexts.type = this;
                        return val;
                    }
                }
            }
        });
        var map = new MyMap();
        map.serialize();
        map.removeAttr('name');
        equal(contexts.get, map);
        equal(contexts.remove, map);
        equal(contexts.set, map);
        equal(contexts.serialize, map);
        equal(contexts.type, map);
    });
    test('value generator is not called if default passed', function () {
        var TestMap = CanMap.extend({
            define: {
                foo: {
                    value: function () {
                        throw '"foo"\'s value method should not be called.';
                    }
                }
            }
        });
        var tm = new TestMap({ foo: 'baz' });
        equal(tm.attr('foo'), 'baz');
    });
    test('Value generator can read other properties', function () {
        var Map = CanMap.extend({
            letters: 'ABC',
            numbers: [
                1,
                2,
                3
            ],
            define: {
                definedLetters: { value: 'DEF' },
                definedNumbers: {
                    value: [
                        4,
                        5,
                        6
                    ]
                },
                generatedLetters: {
                    value: function () {
                        return 'GHI';
                    }
                },
                generatedNumbers: {
                    value: function () {
                        return new List([
                            7,
                            8,
                            9
                        ]);
                    }
                },
                firstLetter: {
                    value: function () {
                        return this.attr('letters').substr(0, 1);
                    }
                },
                firstNumber: {
                    value: function () {
                        return this.attr('numbers.0');
                    }
                },
                middleLetter: {
                    value: function () {
                        return this.attr('definedLetters').substr(1, 1);
                    }
                },
                middleNumber: {
                    value: function () {
                        return this.attr('definedNumbers.1');
                    }
                },
                lastLetter: {
                    value: function () {
                        return this.attr('generatedLetters').substr(2, 1);
                    }
                },
                lastNumber: {
                    value: function () {
                        return this.attr('generatedNumbers.2');
                    }
                }
            }
        });
        var map = new Map();
        var prefix = 'Was able to read dependent value from ';
        equal(map.attr('firstLetter'), 'A', prefix + 'traditional CanMap style property definition');
        equal(map.attr('firstNumber'), 1, prefix + 'traditional CanMap style property definition');
        equal(map.attr('middleLetter'), 'E', prefix + 'define plugin style default property definition');
        equal(map.attr('middleNumber'), 5, prefix + 'define plugin style default property definition');
        equal(map.attr('lastLetter'), 'I', prefix + 'define plugin style generated default property definition');
        equal(map.attr('lastNumber'), 9, prefix + 'define plugin style generated default property definition');
    });
    test('default behaviors with "*" work for attributes', function () {
        expect(9);
        var DefaultMap = CanMap.extend({
            define: {
                someNumber: { value: '5' },
                '*': {
                    type: 'number',
                    serialize: function (value) {
                        return '' + value;
                    },
                    set: function (newVal) {
                        ok(true, 'set called');
                        return newVal;
                    },
                    remove: function (currentVal) {
                        ok(true, 'remove called');
                        return false;
                    }
                }
            }
        });
        var map = new DefaultMap(), serializedMap;
        equal(map.attr('someNumber'), 5, 'value of someNumber should be converted to a number');
        map.attr('number', '10');
        equal(map.attr('number'), 10, 'value of number should be converted to a number');
        map.removeAttr('number');
        equal(map.attr('number'), 10, 'number should not be removed');
        serializedMap = map.serialize();
        equal(serializedMap.number, '10', 'number serialized as string');
        equal(serializedMap.someNumber, '5', 'someNumber serialized as string');
        equal(serializedMap['*'], undefined, '"*" is not a value in serialized object');
    });
    test('models properly serialize with default behaviors', function () {
        var DefaultMap = CanMap.extend({
            define: {
                name: { value: 'Alex' },
                shirt: {
                    value: 'blue',
                    serialize: true
                },
                '*': { serialize: false }
            }
        });
        var map = new DefaultMap({
                age: 10,
                name: 'John'
            }), serializedMap = map.serialize();
        equal(serializedMap.age, undefined, 'age doesn\'t exist');
        equal(serializedMap.name, undefined, 'name doesn\'t exist');
        equal(serializedMap.shirt, 'blue', 'shirt exists');
    });
    test('nested define', function () {
        var nailedIt = 'Nailed it';
        var Example = CanMap.extend({}, { define: { name: { value: nailedIt } } });
        var NestedMap = CanMap.extend({}, {
            define: {
                isEnabled: { value: true },
                test: { Value: Example },
                examples: {
                    value: {
                        define: {
                            one: { Value: Example },
                            two: { value: { define: { deep: { Value: Example } } } }
                        }
                    }
                }
            }
        });
        var nested = new NestedMap();
        equal(nested.attr('test.name'), nailedIt);
        equal(nested.attr('examples.one.name'), nailedIt);
        equal(nested.attr('examples.two.deep.name'), nailedIt);
        ok(nested.attr('test') instanceof Example);
        ok(nested.attr('examples.one') instanceof Example);
        ok(nested.attr('examples.two.deep') instanceof Example);
    });
    test('Can make an attr alias a compute (#1470)', 9, function () {
        var computeValue = compute(1);
        var GetMap = CanMap.extend({
            define: {
                value: {
                    set: function (newValue, setVal, setErr, oldValue) {
                        if (newValue.isComputed) {
                            return newValue;
                        }
                        if (oldValue && oldValue.isComputed) {
                            oldValue(newValue);
                            return oldValue;
                        }
                        return newValue;
                    },
                    get: function (value) {
                        return value && value.isComputed ? value() : value;
                    }
                }
            }
        });
        var getMap = new GetMap();
        getMap.attr('value', computeValue);
        equal(getMap.attr('value'), 1);
        var bindCallbacks = 0;
        getMap.bind('value', function (ev, newVal, oldVal) {
            switch (bindCallbacks) {
            case 0:
                equal(newVal, 2, '0 - bind called with new val');
                equal(oldVal, 1, '0 - bind called with old val');
                break;
            case 1:
                equal(newVal, 3, '1 - bind called with new val');
                equal(oldVal, 2, '1 - bind called with old val');
                break;
            case 2:
                equal(newVal, 4, '2 - bind called with new val');
                equal(oldVal, 3, '2 - bind called with old val');
                break;
            }
            bindCallbacks++;
        });
        computeValue(2);
        getMap.attr('value', 3);
        equal(getMap.attr('value'), 3, 'read value is 3');
        equal(computeValue(), 3, 'the compute value is 3');
        var newComputeValue = compute(4);
        getMap.attr('value', newComputeValue);
    });
    test('setting a value of a property with type "compute" triggers change events', function () {
        var handler;
        var message = 'The change event passed the correct {prop} when set with {method}';
        var createChangeHandler = function (expectedOldVal, expectedNewVal, method) {
            return function (ev, newVal, oldVal) {
                var subs = {
                    prop: 'newVal',
                    method: method
                };
                equal(newVal, expectedNewVal, string.sub(message, subs));
                subs.prop = 'oldVal';
                equal(oldVal, expectedOldVal, string.sub(message, subs));
            };
        };
        var ComputableMap = CanMap.extend({ define: { computed: { type: 'compute' } } });
        var computed = compute(0);
        var m1 = new ComputableMap({ computed: computed });
        equal(m1.attr('computed'), 0, 'm1 is 1');
        handler = createChangeHandler(0, 1, '.attr(\'computed\', newVal)');
        m1.bind('computed', handler);
        m1.attr('computed', 1);
        m1.unbind('computed', handler);
        handler = createChangeHandler(1, 2, 'computed()');
        m1.bind('computed', handler);
        computed(2);
        m1.unbind('computed', handler);
    });
    test('replacing the compute on a property with type "compute"', function () {
        var compute1 = compute(0);
        var compute2 = compute(1);
        var ComputableMap = CanMap.extend({ define: { computable: { type: 'compute' } } });
        var m = new ComputableMap();
        m.attr('computable', compute1);
        equal(m.attr('computable'), 0, 'compute1 readable via .attr()');
        m.attr('computable', compute2);
        equal(m.attr('computable'), 1, 'compute2 readable via .attr()');
    });
    test('value and get (#1521)', function () {
        var MyMap = CanMap.extend({
            define: {
                data: {
                    value: function () {
                        return new List(['test']);
                    }
                },
                size: {
                    value: 1,
                    get: function (val) {
                        var list = this.attr('data');
                        var length = list.attr('length');
                        return val + length;
                    }
                }
            }
        });
        var map = new MyMap({});
        equal(map.attr('size'), 2);
    });
    test('One event on getters (#1585)', function () {
        var AppState = CanMap.extend({
            define: {
                person: {
                    get: function (lastSetValue, setAttrValue) {
                        if (lastSetValue) {
                            return lastSetValue;
                        } else if (this.attr('personId')) {
                            setAttrValue(new CanMap({
                                name: 'Jose',
                                id: 5
                            }));
                        } else {
                            return null;
                        }
                    }
                }
            }
        });
        var appState = new AppState();
        var personEvents = 0;
        appState.bind('person', function (ev, person) {
            personEvents++;
        });
        appState.attr('personId', 5);
        appState.attr('person', new CanMap({ name: 'Julia' }));
        equal(personEvents, 2);
    });
    test('Can read a defined property with a set/get method (#1648)', function () {
        var Map = CanMap.extend({
            define: {
                foo: {
                    value: '',
                    set: function (setVal) {
                        return setVal;
                    },
                    get: function (lastSetVal) {
                        return lastSetVal;
                    }
                }
            }
        });
        var map = new Map();
        equal(map.attr('foo'), '', 'Calling .attr(\'foo\') returned the correct value');
        map.attr('foo', 'baz');
        equal(map.attr('foo'), 'baz', 'Calling .attr(\'foo\') returned the correct value');
    });
    test('Can bind to a defined property with a set/get method (#1648)', 3, function () {
        var Map = CanMap.extend({
            define: {
                foo: {
                    value: '',
                    set: function (setVal) {
                        return setVal;
                    },
                    get: function (lastSetVal) {
                        return lastSetVal;
                    }
                }
            }
        });
        var map = new Map();
        map.bind('foo', function () {
            ok(true, 'Bound function is called');
        });
        equal(map.attr('foo'), '', 'Calling .attr(\'foo\') returned the correct value');
        map.attr('foo', 'baz');
        equal(map.attr('foo'), 'baz', 'Calling .attr(\'foo\') returned the correct value');
    });
    test('type converters handle null and undefined in expected ways (1693)', function () {
        var Typer = CanMap.extend({
            define: {
                date: { type: 'date' },
                string: { type: 'string' },
                number: { type: 'number' },
                'boolean': { type: 'boolean' },
                htmlbool: { type: 'htmlbool' },
                leaveAlone: { type: '*' }
            }
        });
        var t = new Typer().attr({
            date: undefined,
            string: undefined,
            number: undefined,
            'boolean': undefined,
            htmlbool: undefined,
            leaveAlone: undefined
        });
        equal(t.attr('date'), undefined, 'converted to date');
        equal(t.attr('string'), undefined, 'converted to string');
        equal(t.attr('number'), undefined, 'converted to number');
        equal(t.attr('boolean'), undefined, 'converted to boolean');
        equal(t.attr('htmlbool'), false, 'converted to htmlbool');
        equal(t.attr('leaveAlone'), undefined, 'left as object');
        t = new Typer().attr({
            date: null,
            string: null,
            number: null,
            'boolean': null,
            htmlbool: null,
            leaveAlone: null
        });
        equal(t.attr('date'), null, 'converted to date');
        equal(t.attr('string'), null, 'converted to string');
        equal(t.attr('number'), null, 'converted to number');
        equal(t.attr('boolean'), null, 'converted to boolean');
        equal(t.attr('htmlbool'), false, 'converted to htmlbool');
        equal(t.attr('leaveAlone'), null, 'left as object');
    });
    test('Initial value does not call getter', function () {
        expect(0);
        var Map = CanMap.extend({
            define: {
                count: {
                    get: function (lastVal) {
                        ok(false, 'Should not be called');
                        return lastVal;
                    }
                }
            }
        });
        new Map({ count: 100 });
    });
    test('getters produce change events', function () {
        var Map = CanMap.extend({
            define: {
                count: {
                    get: function (lastVal) {
                        return lastVal;
                    }
                }
            }
        });
        var map = new Map();
        map.bind('change', function () {
            ok(true, 'change called');
        });
        map.attr('count', 22);
    });
    test('Asynchronous virtual properties cause extra recomputes (#1915)', function () {
        stop();
        var ran = false;
        var VM = CanMap.extend({
            define: {
                foo: {
                    get: function (lastVal, setVal) {
                        setTimeout(function () {
                            if (setVal) {
                                setVal(5);
                            }
                        }, 10);
                    }
                },
                bar: {
                    get: function () {
                        var foo = this.attr('foo');
                        if (foo) {
                            if (ran) {
                                ok(false, 'Getter ran twice');
                            }
                            ran = true;
                            return foo * 2;
                        }
                    }
                }
            }
        });
        var vm = new VM();
        vm.bind('bar', function () {
        });
        setTimeout(function () {
            equal(vm.attr('bar'), 10);
            start();
        }, 200);
    });
    test('double get in a compute (#2230)', function () {
        var VM = CanMap.extend({
            define: {
                names: {
                    get: function (val, setVal) {
                        ok(setVal, 'setVal passed');
                        return 'Hi!';
                    }
                }
            }
        });
        var vm = new VM();
        var c = compute(function () {
            return vm.attr('names');
        });
        c.bind('change', function () {
        });
    });
    test('nullish values are not converted for Type', function (assert) {
        var VM = CanMap.extend({
            define: {
                map: { Type: CanMap },
                notype: {}
            }
        });
        var vm = new VM({
            num: 1,
            bool: true,
            htmlbool: 'foo',
            str: 'foo',
            date: Date.now(),
            map: {},
            notype: {}
        });
        assert.ok(vm.attr('map') instanceof CanMap, 'map is a Map');
        assert.ok(vm.attr('notype') instanceof CanMap, 'notype is a Map');
        vm.attr({
            map: null,
            notype: null
        });
        assert.equal(vm.attr('map'), null, 'map is null');
        assert.equal(vm.attr('map'), null, 'notype is null');
    });
    test('Wildcard serialize doesn\'t apply to getter properties (#4)', function () {
        var VM = CanMap.extend({
            define: {
                explicitlySerialized: {
                    get: function () {
                        return true;
                    },
                    serialize: true
                },
                implicitlySerialized: {
                    get: function () {
                        return true;
                    }
                },
                '*': { serialize: true }
            }
        });
        var vm = new VM();
        vm.bind('change', function () {
        });
        deepEqual(vm.serialize(), {
            explicitlySerialized: true,
            implicitlySerialized: true
        });
    });
    test('compute props can be set to null or undefined (#2372)', function (assert) {
        var VM = CanMap.extend({ define: { foo: { type: 'compute' } } });
        var vmNull = new VM({ foo: null });
        assert.equal(vmNull.foo, null, 'foo is null, no error thrown');
        var vmUndef = new VM({ foo: undefined });
        assert.equal(vmUndef.foo, undefined, 'foo is null, no error thrown');
    });
    test('can inherit computes from another map (#2)', 4, function () {
        var string1 = 'a string';
        var string2 = 'another string';
        var MapA = CanMap.extend({
            define: {
                propA: {
                    get: function () {
                        return string1;
                    }
                },
                propB: {
                    get: function () {
                        return string1;
                    },
                    set: function (newVal) {
                        equal(newVal, string1, 'set was called');
                    }
                }
            }
        });
        var MapB = MapA.extend({
            define: {
                propC: {
                    get: function () {
                        return string2;
                    }
                },
                propB: {
                    get: function () {
                        return string2;
                    }
                }
            }
        });
        var map = new MapB();
        equal(map.attr('propC'), string2, 'props only in the child have the correct values');
        equal(map.attr('propB'), string2, 'props in both have the child values');
        equal(map.attr('propA'), string1, 'props only in the parent have the correct values');
        map.attr('propB', string1);
    });
    test('can inherit primitive values from another map (#2)', function () {
        var string1 = 'a';
        var string2 = 'b';
        var MapA = CanMap.extend({
            define: {
                propA: { value: string1 },
                propB: { value: string1 }
            }
        });
        var MapB = MapA.extend({
            define: {
                propC: { value: string2 },
                propB: { value: string2 }
            }
        });
        var map = new MapB();
        equal(map.propC, string2, 'props only in the child have the correct values');
        equal(map.propB, string2, 'props in both have the child values');
        equal(map.propA, string1, 'props only in the parent have the correct values');
    });
    test('can inherit object values from another map (#2)', function () {
        var object1 = { a: 'a' };
        var object2 = { b: 'b' };
        var MapA = CanMap.extend({
            define: {
                propA: {
                    get: function () {
                        return object1;
                    }
                },
                propB: {
                    get: function () {
                        return object1;
                    }
                }
            }
        });
        var MapB = MapA.extend({
            define: {
                propB: {
                    get: function () {
                        return object2;
                    }
                },
                propC: {
                    get: function () {
                        return object2;
                    }
                }
            }
        });
        var map = new MapB();
        equal(map.attr('propC'), object2, 'props only in the child have the correct values');
        equal(map.attr('propB'), object2, 'props in both have the child values');
        equal(map.attr('propA'), object1, 'props only in the parent have the correct values');
    });
    test('can set properties to undefined', function () {
        var MyMap = CanMap.extend({
            define: {
                foo: {
                    set: function (newVal) {
                        return newVal;
                    }
                }
            }
        });
        var map = new MyMap();
        map.attr('foo', 'bar');
        equal(map.attr('foo'), 'bar', 'foo should be bar');
        map.attr('foo', undefined);
        equal(typeof map.attr('foo'), 'undefined', 'foo should be undefined');
    });
    test('subclass defines do not affect superclass ones', function (assert) {
        var VM = CanMap.extend({
            define: {
                foo: {
                    type: 'string',
                    value: 'bar'
                }
            }
        });
        var VM2 = VM.extend({ define: { foo: { value: 'baz' } } });
        var VM2a = VM.extend({});
        var VM2b = VM.extend({
            define: {
                foo: {
                    get: function () {
                        return 'quux';
                    }
                }
            }
        });
        var VM2c = VM.extend({
            define: {
                foo: {
                    type: function (oldVal) {
                        return oldVal + 'thud';
                    }
                }
            }
        });
        assert.equal(new VM().attr('foo'), 'bar', 'correct define on parent class object');
        assert.equal(new VM2().attr('foo'), 'baz', 'correct define on redefined child class object');
        assert.equal(new VM2a().attr('foo'), 'bar', 'correct define on non-redefined child class object');
        assert.equal(new VM2b().attr('foo'), 'quux', 'correct define on child class object with different define');
        assert.equal(new VM2c().attr('foo'), 'barthud', 'correct define on child class object with extending define');
    });
    test('value function not set on constructor defaults', function () {
        var MyMap = CanMap.extend({
            define: {
                propA: {
                    value: function () {
                        return 1;
                    }
                }
            }
        });
        var map = new MyMap();
        equal(MyMap.defaults.propA, undefined, 'Generator function does not result in property set on defaults');
        notEqual(MyMap.defaultGenerators.propA, undefined, 'Generator function set on defaultGenerators');
        equal(map.attr('propA'), 1, 'Instance value set properly');
    });
});
/*can-view-href@3.1.0#can-view-href*/
define('can-view-href@3.1.0#can-view-href', function (require, exports, module) {
    var expression = require('can-stache/src/expression');
    var viewCallbacks = require('can-view-callbacks');
    var compute = require('can-compute');
    var route = require('can-route');
    require('can-util/dom/events/removed/removed');
    var domEvents = require('can-util/dom/events/events');
    var removeCurly = function (value) {
        if (value[0] === '{' && value[value.length - 1] === '}') {
            return value.substr(1, value.length - 2);
        }
        return value;
    };
    viewCallbacks.attr('can-href', function (el, attrData) {
        var attrInfo = expression.parse('tmp(' + removeCurly(el.getAttribute('can-href')) + ')', { baseMethodType: 'Call' });
        var getHash = attrInfo.argExprs[0].value(attrData.scope, null);
        var routeHref = compute(function () {
            return route.url(getHash());
        });
        el.setAttribute('href', routeHref());
        var handler = function (ev, newVal) {
            el.setAttribute('href', newVal);
        };
        routeHref.on('change', handler);
        domEvents.addEventListener.call(el, 'removed', function () {
            routeHref.off('change', handler);
        });
    });
});
/*can-view-href@3.1.0#test/test*/
define('can-view-href@3.1.0#test/test', function (require, exports, module) {
    (function (__dirname) {
        require('can-route');
        require('steal-qunit');
        require('../can-view-href');
        var makeIframe = function (src) {
            var iframe = document.createElement('iframe');
            window.removeMyself = function () {
                delete window.removeMyself;
                delete window.isReady;
                delete window.hasError;
                document.body.removeChild(iframe);
                start();
            };
            window.hasError = function (error) {
                ok(false, error.message);
                window.removeMyself();
            };
            window.isReady = function (el, viewModel, setPrettyUrl) {
                equal(el.getAttribute('href'), '#!&page=recipe&id=5', 'should set unpretty href attribute');
                viewModel.recipe.attr('id', 7);
                equal(el.getAttribute('href'), '#!&page=recipe&id=7', 'should update href');
                setPrettyUrl();
                viewModel.recipe.attr('id', 8);
                equal(el.getAttribute('href'), '#!recipe/8', 'should set pretty href');
                viewModel.recipe.attr('id', 9);
                equal(el.getAttribute('href'), '#!recipe/9', 'should update pretty href');
                window.removeMyself();
            };
            document.body.appendChild(iframe);
            iframe.src = src;
        };
        QUnit.module('can-view-href');
        if (window.steal && __dirname !== '/') {
            asyncTest('the basics are able to work for steal', function () {
                makeIframe(__dirname + '/basics.html?' + Math.random());
            });
        }
    }('/'));
});
/*can-map-backup@3.1.0#can-map-backup*/
define('can-map-backup@3.1.0#can-map-backup', function (require, exports, module) {
    var compute = require('can-compute');
    var CanMap = require('can-map');
    var compare = require('can-set/src/compare');
    var assign = require('can-util/js/assign/assign');
    var flatProps = function (a, cur) {
        var obj = {};
        for (var prop in a) {
            if (typeof a[prop] !== 'object' || a[prop] === null || a[prop] instanceof Date) {
                obj[prop] = a[prop];
            } else {
                obj[prop] = cur.attr(prop);
            }
        }
        return obj;
    };
    var oldSetup = CanMap.prototype.setup;
    assign(CanMap.prototype, {
        setup: function () {
            this._backupStore = compute();
            return oldSetup.apply(this, arguments);
        },
        backup: function () {
            this._backupStore(this.attr());
            return this;
        },
        isDirty: function (checkAssociations) {
            var backupStore = this._backupStore();
            if (!backupStore) {
                return false;
            }
            var currentValue = this.attr();
            var aParent, bParent, parentProp;
            var compares = {};
            var options = { deep: !!checkAssociations };
            return !compare.equal(currentValue, backupStore, aParent, bParent, parentProp, compares, options);
        },
        restore: function (restoreAssociations) {
            var props = restoreAssociations ? this._backupStore() : flatProps(this._backupStore(), this);
            if (this.isDirty(restoreAssociations)) {
                this.attr(props, true);
            }
            return this;
        }
    });
    module.exports = exports = CanMap;
});
/*can-map-backup@3.1.0#can-map-backup_test*/
define('can-map-backup@3.1.0#can-map-backup_test', function (require, exports, module) {
    var compute = require('can-compute');
    var CanMap = require('can-map');
    require('can-map-backup');
    require('can-map-define');
    require('steal-qunit');
    var Recipe;
    QUnit.module('can/map/backup', {
        setup: function () {
            Recipe = CanMap.extend('Recipe');
        }
    });
    test('backing up', function () {
        var recipe = new Recipe({ name: 'cheese' });
        ok(!recipe.isDirty(), 'not backedup, but clean');
        recipe.backup();
        ok(!recipe.isDirty(), 'backedup, but clean');
        recipe.attr('name', 'blah');
        ok(recipe.isDirty(), 'dirty');
        recipe.restore();
        ok(!recipe.isDirty(), 'restored, clean');
        equal(recipe.name, 'cheese', 'name back');
    });
    test('backup / restore with associations', function () {
        var Instruction = CanMap.extend('Instruction');
        var Cookbook = CanMap.extend('Cookbook');
        var Recipe = CanMap.extend('Recipe', {
            define: {
                instructions: { Type: Instruction.List },
                cookbook: { Type: Cookbook }
            }
        }, {});
        var recipe = new Recipe({
            name: 'cheese burger',
            instructions: [
                { description: 'heat meat' },
                { description: 'add cheese' }
            ],
            cookbook: { title: 'Justin\'s Grillin Times' }
        });
        ok(!recipe.isDirty(), 'not backedup, but clean');
        recipe.backup();
        ok(!recipe.isDirty(), 'backedup, but clean');
        recipe.attr('name', 'blah');
        ok(recipe.isDirty(), 'dirty');
        recipe.restore();
        ok(!recipe.isDirty(), 'restored, clean');
        equal(recipe.name, 'cheese burger', 'name back');
        ok(!recipe.cookbook.isDirty(), 'cookbook not backedup, but clean');
        recipe.cookbook.backup();
        recipe.cookbook.attr('title', 'Brian\'s Burgers');
        ok(!recipe.isDirty(), 'recipe itself is clean');
        ok(recipe.isDirty(true), 'recipe is dirty if checking associations');
        recipe.cookbook.restore();
        ok(!recipe.isDirty(true), 'recipe is now clean with checking associations');
        equal(recipe.cookbook.title, 'Justin\'s Grillin Times', 'cookbook title back');
        recipe.cookbook.attr('title', 'Brian\'s Burgers');
        recipe.restore();
        ok(recipe.isDirty(true), 'recipe is dirty if checking associations, after a restore');
        recipe.restore(true);
        ok(!recipe.isDirty(true), 'cleaned all of recipe and its associations');
    });
    test('backup restore nested observables', function () {
        var observe = new CanMap({ nested: { test: 'property' } });
        equal(observe.attr('nested').attr('test'), 'property', 'Nested object got converted');
        observe.backup();
        observe.attr('nested').attr('test', 'changed property');
        equal(observe.attr('nested').attr('test'), 'changed property', 'Nested property changed');
        ok(observe.isDirty(true), 'Observe is dirty');
        observe.restore(true);
        equal(observe.attr('nested').attr('test'), 'property', 'Nested object got restored');
    });
    test('backup removes properties that were added (#607)', function () {
        var map = new CanMap({});
        map.backup();
        map.attr('foo', 'bar');
        ok(map.isDirty(), 'the map with an additional property is dirty');
        map.restore();
        ok(!map.attr('foo'), 'there is no foo property');
    });
    test('isDirty wrapped in a compute should trigger changes #1417', function () {
        expect(2);
        var recipe = new Recipe({ name: 'bread' });
        recipe.backup();
        var c = compute(function () {
            return recipe.isDirty();
        });
        ok(!c(), 'isDirty is false');
        c.bind('change', function () {
            ok(c(), 'isDirty is true and a change has occurred');
        });
        recipe.attr('name', 'cheese');
    });
});
/*can-util@3.9.6#namespace*/
define('can-util@3.9.6#namespace', function (require, exports, module) {
    module.exports = require('can-namespace');
});
/*can-validate-legacy@1.1.0#can-validate*/
define('can-validate-legacy@1.1.0#can-validate', function (require, exports, module) {
    var dev = require('can-util/js/dev/dev');
    var namespace = require('can-util/namespace');
    var Validate = {
        _validatorId: '',
        _validators: {},
        validator: function () {
            return this._validators[this._validatorId];
        },
        register: function (id, validator) {
            this._validatorId = id;
            this._validators[id] = validator;
        },
        isValid: function () {
            return this.validator().isValid.apply(this, arguments);
        },
        once: function () {
            return this.validator().once.apply(this, arguments);
        },
        validate: function () {
            var validateArgs = arguments;
            return this.validator().validate.apply(this, validateArgs);
        }
    };
    namespace.validate = Validate;
    module.exports = Validate;
});
/*jquery@3.2.1#dist/jquery*/
(function (global, factory) {
    'use strict';
    if (typeof module === 'object' && typeof module.exports === 'object') {
        module.exports = global.document ? factory(global, true) : function (w) {
            if (!w.document) {
                throw new Error('jQuery requires a window with a document');
            }
            return factory(w);
        };
    } else {
        factory(global);
    }
}(typeof window !== 'undefined' ? window : this, function (window, noGlobal) {
    'use strict';
    var arr = [];
    var document = window.document;
    var getProto = Object.getPrototypeOf;
    var slice = arr.slice;
    var concat = arr.concat;
    var push = arr.push;
    var indexOf = arr.indexOf;
    var class2type = {};
    var toString = class2type.toString;
    var hasOwn = class2type.hasOwnProperty;
    var fnToString = hasOwn.toString;
    var ObjectFunctionString = fnToString.call(Object);
    var support = {};
    function DOMEval(code, doc) {
        doc = doc || document;
        var script = doc.createElement('script');
        script.text = code;
        doc.head.appendChild(script).parentNode.removeChild(script);
    }
    var version = '3.2.1', jQuery = function (selector, context) {
            return new jQuery.fn.init(selector, context);
        }, rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, rmsPrefix = /^-ms-/, rdashAlpha = /-([a-z])/g, fcamelCase = function (all, letter) {
            return letter.toUpperCase();
        };
    jQuery.fn = jQuery.prototype = {
        jquery: version,
        constructor: jQuery,
        length: 0,
        toArray: function () {
            return slice.call(this);
        },
        get: function (num) {
            if (num == null) {
                return slice.call(this);
            }
            return num < 0 ? this[num + this.length] : this[num];
        },
        pushStack: function (elems) {
            var ret = jQuery.merge(this.constructor(), elems);
            ret.prevObject = this;
            return ret;
        },
        each: function (callback) {
            return jQuery.each(this, callback);
        },
        map: function (callback) {
            return this.pushStack(jQuery.map(this, function (elem, i) {
                return callback.call(elem, i, elem);
            }));
        },
        slice: function () {
            return this.pushStack(slice.apply(this, arguments));
        },
        first: function () {
            return this.eq(0);
        },
        last: function () {
            return this.eq(-1);
        },
        eq: function (i) {
            var len = this.length, j = +i + (i < 0 ? len : 0);
            return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
        },
        end: function () {
            return this.prevObject || this.constructor();
        },
        push: push,
        sort: arr.sort,
        splice: arr.splice
    };
    jQuery.extend = jQuery.fn.extend = function () {
        var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
        if (typeof target === 'boolean') {
            deep = target;
            target = arguments[i] || {};
            i++;
        }
        if (typeof target !== 'object' && !jQuery.isFunction(target)) {
            target = {};
        }
        if (i === length) {
            target = this;
            i--;
        }
        for (; i < length; i++) {
            if ((options = arguments[i]) != null) {
                for (name in options) {
                    src = target[name];
                    copy = options[name];
                    if (target === copy) {
                        continue;
                    }
                    if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
                        if (copyIsArray) {
                            copyIsArray = false;
                            clone = src && Array.isArray(src) ? src : [];
                        } else {
                            clone = src && jQuery.isPlainObject(src) ? src : {};
                        }
                        target[name] = jQuery.extend(deep, clone, copy);
                    } else if (copy !== undefined) {
                        target[name] = copy;
                    }
                }
            }
        }
        return target;
    };
    jQuery.extend({
        expando: 'jQuery' + (version + Math.random()).replace(/\D/g, ''),
        isReady: true,
        error: function (msg) {
            throw new Error(msg);
        },
        noop: function () {
        },
        isFunction: function (obj) {
            return jQuery.type(obj) === 'function';
        },
        isWindow: function (obj) {
            return obj != null && obj === obj.window;
        },
        isNumeric: function (obj) {
            var type = jQuery.type(obj);
            return (type === 'number' || type === 'string') && !isNaN(obj - parseFloat(obj));
        },
        isPlainObject: function (obj) {
            var proto, Ctor;
            if (!obj || toString.call(obj) !== '[object Object]') {
                return false;
            }
            proto = getProto(obj);
            if (!proto) {
                return true;
            }
            Ctor = hasOwn.call(proto, 'constructor') && proto.constructor;
            return typeof Ctor === 'function' && fnToString.call(Ctor) === ObjectFunctionString;
        },
        isEmptyObject: function (obj) {
            var name;
            for (name in obj) {
                return false;
            }
            return true;
        },
        type: function (obj) {
            if (obj == null) {
                return obj + '';
            }
            return typeof obj === 'object' || typeof obj === 'function' ? class2type[toString.call(obj)] || 'object' : typeof obj;
        },
        globalEval: function (code) {
            DOMEval(code);
        },
        camelCase: function (string) {
            return string.replace(rmsPrefix, 'ms-').replace(rdashAlpha, fcamelCase);
        },
        each: function (obj, callback) {
            var length, i = 0;
            if (isArrayLike(obj)) {
                length = obj.length;
                for (; i < length; i++) {
                    if (callback.call(obj[i], i, obj[i]) === false) {
                        break;
                    }
                }
            } else {
                for (i in obj) {
                    if (callback.call(obj[i], i, obj[i]) === false) {
                        break;
                    }
                }
            }
            return obj;
        },
        trim: function (text) {
            return text == null ? '' : (text + '').replace(rtrim, '');
        },
        makeArray: function (arr, results) {
            var ret = results || [];
            if (arr != null) {
                if (isArrayLike(Object(arr))) {
                    jQuery.merge(ret, typeof arr === 'string' ? [arr] : arr);
                } else {
                    push.call(ret, arr);
                }
            }
            return ret;
        },
        inArray: function (elem, arr, i) {
            return arr == null ? -1 : indexOf.call(arr, elem, i);
        },
        merge: function (first, second) {
            var len = +second.length, j = 0, i = first.length;
            for (; j < len; j++) {
                first[i++] = second[j];
            }
            first.length = i;
            return first;
        },
        grep: function (elems, callback, invert) {
            var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert;
            for (; i < length; i++) {
                callbackInverse = !callback(elems[i], i);
                if (callbackInverse !== callbackExpect) {
                    matches.push(elems[i]);
                }
            }
            return matches;
        },
        map: function (elems, callback, arg) {
            var length, value, i = 0, ret = [];
            if (isArrayLike(elems)) {
                length = elems.length;
                for (; i < length; i++) {
                    value = callback(elems[i], i, arg);
                    if (value != null) {
                        ret.push(value);
                    }
                }
            } else {
                for (i in elems) {
                    value = callback(elems[i], i, arg);
                    if (value != null) {
                        ret.push(value);
                    }
                }
            }
            return concat.apply([], ret);
        },
        guid: 1,
        proxy: function (fn, context) {
            var tmp, args, proxy;
            if (typeof context === 'string') {
                tmp = fn[context];
                context = fn;
                fn = tmp;
            }
            if (!jQuery.isFunction(fn)) {
                return undefined;
            }
            args = slice.call(arguments, 2);
            proxy = function () {
                return fn.apply(context || this, args.concat(slice.call(arguments)));
            };
            proxy.guid = fn.guid = fn.guid || jQuery.guid++;
            return proxy;
        },
        now: Date.now,
        support: support
    });
    if (typeof Symbol === 'function') {
        jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
    }
    jQuery.each('Boolean Number String Function Array Date RegExp Object Error Symbol'.split(' '), function (i, name) {
        class2type['[object ' + name + ']'] = name.toLowerCase();
    });
    function isArrayLike(obj) {
        var length = !!obj && 'length' in obj && obj.length, type = jQuery.type(obj);
        if (type === 'function' || jQuery.isWindow(obj)) {
            return false;
        }
        return type === 'array' || length === 0 || typeof length === 'number' && length > 0 && length - 1 in obj;
    }
    var Sizzle = function (window) {
        var i, support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = 'sizzle' + 1 * new Date(), preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), sortOrder = function (a, b) {
                if (a === b) {
                    hasDuplicate = true;
                }
                return 0;
            }, hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push = arr.push, slice = arr.slice, indexOf = function (list, elem) {
                var i = 0, len = list.length;
                for (; i < len; i++) {
                    if (list[i] === elem) {
                        return i;
                    }
                }
                return -1;
            }, booleans = 'checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped', whitespace = '[\\x20\\t\\r\\n\\f]', identifier = '(?:\\\\.|[\\w-]|[^\0-\\xa0])+', attributes = '\\[' + whitespace + '*(' + identifier + ')(?:' + whitespace + '*([*^$|!~]?=)' + whitespace + '*(?:\'((?:\\\\.|[^\\\\\'])*)\'|"((?:\\\\.|[^\\\\"])*)"|(' + identifier + '))|)' + whitespace + '*\\]', pseudos = ':(' + identifier + ')(?:\\((' + '(\'((?:\\\\.|[^\\\\\'])*)\'|"((?:\\\\.|[^\\\\"])*)")|' + '((?:\\\\.|[^\\\\()[\\]]|' + attributes + ')*)|' + '.*' + ')\\)|)', rwhitespace = new RegExp(whitespace + '+', 'g'), rtrim = new RegExp('^' + whitespace + '+|((?:^|[^\\\\])(?:\\\\.)*)' + whitespace + '+$', 'g'), rcomma = new RegExp('^' + whitespace + '*,' + whitespace + '*'), rcombinators = new RegExp('^' + whitespace + '*([>+~]|' + whitespace + ')' + whitespace + '*'), rattributeQuotes = new RegExp('=' + whitespace + '*([^\\]\'"]*?)' + whitespace + '*\\]', 'g'), rpseudo = new RegExp(pseudos), ridentifier = new RegExp('^' + identifier + '$'), matchExpr = {
                'ID': new RegExp('^#(' + identifier + ')'),
                'CLASS': new RegExp('^\\.(' + identifier + ')'),
                'TAG': new RegExp('^(' + identifier + '|[*])'),
                'ATTR': new RegExp('^' + attributes),
                'PSEUDO': new RegExp('^' + pseudos),
                'CHILD': new RegExp('^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(' + whitespace + '*(even|odd|(([+-]|)(\\d*)n|)' + whitespace + '*(?:([+-]|)' + whitespace + '*(\\d+)|))' + whitespace + '*\\)|)', 'i'),
                'bool': new RegExp('^(?:' + booleans + ')$', 'i'),
                'needsContext': new RegExp('^' + whitespace + '*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(' + whitespace + '*((?:-\\d)?\\d*)' + whitespace + '*\\)|)(?=[^-]|$)', 'i')
            }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, runescape = new RegExp('\\\\([\\da-f]{1,6}' + whitespace + '?|(' + whitespace + ')|.)', 'ig'), funescape = function (_, escaped, escapedWhitespace) {
                var high = '0x' + escaped - 65536;
                return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
            }, rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g, fcssescape = function (ch, asCodePoint) {
                if (asCodePoint) {
                    if (ch === '\0') {
                        return '\uFFFD';
                    }
                    return ch.slice(0, -1) + '\\' + ch.charCodeAt(ch.length - 1).toString(16) + ' ';
                }
                return '\\' + ch;
            }, unloadHandler = function () {
                setDocument();
            }, disabledAncestor = addCombinator(function (elem) {
                return elem.disabled === true && ('form' in elem || 'label' in elem);
            }, {
                dir: 'parentNode',
                next: 'legend'
            });
        try {
            push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
            arr[preferredDoc.childNodes.length].nodeType;
        } catch (e) {
            push = {
                apply: arr.length ? function (target, els) {
                    push_native.apply(target, slice.call(els));
                } : function (target, els) {
                    var j = target.length, i = 0;
                    while (target[j++] = els[i++]) {
                    }
                    target.length = j - 1;
                }
            };
        }
        function Sizzle(selector, context, results, seed) {
            var m, i, elem, nid, match, groups, newSelector, newContext = context && context.ownerDocument, nodeType = context ? context.nodeType : 9;
            results = results || [];
            if (typeof selector !== 'string' || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
                return results;
            }
            if (!seed) {
                if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
                    setDocument(context);
                }
                context = context || document;
                if (documentIsHTML) {
                    if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
                        if (m = match[1]) {
                            if (nodeType === 9) {
                                if (elem = context.getElementById(m)) {
                                    if (elem.id === m) {
                                        results.push(elem);
                                        return results;
                                    }
                                } else {
                                    return results;
                                }
                            } else {
                                if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {
                                    results.push(elem);
                                    return results;
                                }
                            }
                        } else if (match[2]) {
                            push.apply(results, context.getElementsByTagName(selector));
                            return results;
                        } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
                            push.apply(results, context.getElementsByClassName(m));
                            return results;
                        }
                    }
                    if (support.qsa && !compilerCache[selector + ' '] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                        if (nodeType !== 1) {
                            newContext = context;
                            newSelector = selector;
                        } else if (context.nodeName.toLowerCase() !== 'object') {
                            if (nid = context.getAttribute('id')) {
                                nid = nid.replace(rcssescape, fcssescape);
                            } else {
                                context.setAttribute('id', nid = expando);
                            }
                            groups = tokenize(selector);
                            i = groups.length;
                            while (i--) {
                                groups[i] = '#' + nid + ' ' + toSelector(groups[i]);
                            }
                            newSelector = groups.join(',');
                            newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                        }
                        if (newSelector) {
                            try {
                                push.apply(results, newContext.querySelectorAll(newSelector));
                                return results;
                            } catch (qsaError) {
                            } finally {
                                if (nid === expando) {
                                    context.removeAttribute('id');
                                }
                            }
                        }
                    }
                }
            }
            return select(selector.replace(rtrim, '$1'), context, results, seed);
        }
        function createCache() {
            var keys = [];
            function cache(key, value) {
                if (keys.push(key + ' ') > Expr.cacheLength) {
                    delete cache[keys.shift()];
                }
                return cache[key + ' '] = value;
            }
            return cache;
        }
        function markFunction(fn) {
            fn[expando] = true;
            return fn;
        }
        function assert(fn) {
            var el = document.createElement('fieldset');
            try {
                return !!fn(el);
            } catch (e) {
                return false;
            } finally {
                if (el.parentNode) {
                    el.parentNode.removeChild(el);
                }
                el = null;
            }
        }
        function addHandle(attrs, handler) {
            var arr = attrs.split('|'), i = arr.length;
            while (i--) {
                Expr.attrHandle[arr[i]] = handler;
            }
        }
        function siblingCheck(a, b) {
            var cur = b && a, diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex;
            if (diff) {
                return diff;
            }
            if (cur) {
                while (cur = cur.nextSibling) {
                    if (cur === b) {
                        return -1;
                    }
                }
            }
            return a ? 1 : -1;
        }
        function createInputPseudo(type) {
            return function (elem) {
                var name = elem.nodeName.toLowerCase();
                return name === 'input' && elem.type === type;
            };
        }
        function createButtonPseudo(type) {
            return function (elem) {
                var name = elem.nodeName.toLowerCase();
                return (name === 'input' || name === 'button') && elem.type === type;
            };
        }
        function createDisabledPseudo(disabled) {
            return function (elem) {
                if ('form' in elem) {
                    if (elem.parentNode && elem.disabled === false) {
                        if ('label' in elem) {
                            if ('label' in elem.parentNode) {
                                return elem.parentNode.disabled === disabled;
                            } else {
                                return elem.disabled === disabled;
                            }
                        }
                        return elem.isDisabled === disabled || elem.isDisabled !== !disabled && disabledAncestor(elem) === disabled;
                    }
                    return elem.disabled === disabled;
                } else if ('label' in elem) {
                    return elem.disabled === disabled;
                }
                return false;
            };
        }
        function createPositionalPseudo(fn) {
            return markFunction(function (argument) {
                argument = +argument;
                return markFunction(function (seed, matches) {
                    var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length;
                    while (i--) {
                        if (seed[j = matchIndexes[i]]) {
                            seed[j] = !(matches[j] = seed[j]);
                        }
                    }
                });
            });
        }
        function testContext(context) {
            return context && typeof context.getElementsByTagName !== 'undefined' && context;
        }
        support = Sizzle.support = {};
        isXML = Sizzle.isXML = function (elem) {
            var documentElement = elem && (elem.ownerDocument || elem).documentElement;
            return documentElement ? documentElement.nodeName !== 'HTML' : false;
        };
        setDocument = Sizzle.setDocument = function (node) {
            var hasCompare, subWindow, doc = node ? node.ownerDocument || node : preferredDoc;
            if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
                return document;
            }
            document = doc;
            docElem = document.documentElement;
            documentIsHTML = !isXML(document);
            if (preferredDoc !== document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {
                if (subWindow.addEventListener) {
                    subWindow.addEventListener('unload', unloadHandler, false);
                } else if (subWindow.attachEvent) {
                    subWindow.attachEvent('onunload', unloadHandler);
                }
            }
            support.attributes = assert(function (el) {
                el.className = 'i';
                return !el.getAttribute('className');
            });
            support.getElementsByTagName = assert(function (el) {
                el.appendChild(document.createComment(''));
                return !el.getElementsByTagName('*').length;
            });
            support.getElementsByClassName = rnative.test(document.getElementsByClassName);
            support.getById = assert(function (el) {
                docElem.appendChild(el).id = expando;
                return !document.getElementsByName || !document.getElementsByName(expando).length;
            });
            if (support.getById) {
                Expr.filter['ID'] = function (id) {
                    var attrId = id.replace(runescape, funescape);
                    return function (elem) {
                        return elem.getAttribute('id') === attrId;
                    };
                };
                Expr.find['ID'] = function (id, context) {
                    if (typeof context.getElementById !== 'undefined' && documentIsHTML) {
                        var elem = context.getElementById(id);
                        return elem ? [elem] : [];
                    }
                };
            } else {
                Expr.filter['ID'] = function (id) {
                    var attrId = id.replace(runescape, funescape);
                    return function (elem) {
                        var node = typeof elem.getAttributeNode !== 'undefined' && elem.getAttributeNode('id');
                        return node && node.value === attrId;
                    };
                };
                Expr.find['ID'] = function (id, context) {
                    if (typeof context.getElementById !== 'undefined' && documentIsHTML) {
                        var node, i, elems, elem = context.getElementById(id);
                        if (elem) {
                            node = elem.getAttributeNode('id');
                            if (node && node.value === id) {
                                return [elem];
                            }
                            elems = context.getElementsByName(id);
                            i = 0;
                            while (elem = elems[i++]) {
                                node = elem.getAttributeNode('id');
                                if (node && node.value === id) {
                                    return [elem];
                                }
                            }
                        }
                        return [];
                    }
                };
            }
            Expr.find['TAG'] = support.getElementsByTagName ? function (tag, context) {
                if (typeof context.getElementsByTagName !== 'undefined') {
                    return context.getElementsByTagName(tag);
                } else if (support.qsa) {
                    return context.querySelectorAll(tag);
                }
            } : function (tag, context) {
                var elem, tmp = [], i = 0, results = context.getElementsByTagName(tag);
                if (tag === '*') {
                    while (elem = results[i++]) {
                        if (elem.nodeType === 1) {
                            tmp.push(elem);
                        }
                    }
                    return tmp;
                }
                return results;
            };
            Expr.find['CLASS'] = support.getElementsByClassName && function (className, context) {
                if (typeof context.getElementsByClassName !== 'undefined' && documentIsHTML) {
                    return context.getElementsByClassName(className);
                }
            };
            rbuggyMatches = [];
            rbuggyQSA = [];
            if (support.qsa = rnative.test(document.querySelectorAll)) {
                assert(function (el) {
                    docElem.appendChild(el).innerHTML = '<a id=\'' + expando + '\'></a>' + '<select id=\'' + expando + '-\r\\\' msallowcapture=\'\'>' + '<option selected=\'\'></option></select>';
                    if (el.querySelectorAll('[msallowcapture^=\'\']').length) {
                        rbuggyQSA.push('[*^$]=' + whitespace + '*(?:\'\'|"")');
                    }
                    if (!el.querySelectorAll('[selected]').length) {
                        rbuggyQSA.push('\\[' + whitespace + '*(?:value|' + booleans + ')');
                    }
                    if (!el.querySelectorAll('[id~=' + expando + '-]').length) {
                        rbuggyQSA.push('~=');
                    }
                    if (!el.querySelectorAll(':checked').length) {
                        rbuggyQSA.push(':checked');
                    }
                    if (!el.querySelectorAll('a#' + expando + '+*').length) {
                        rbuggyQSA.push('.#.+[+~]');
                    }
                });
                assert(function (el) {
                    el.innerHTML = '<a href=\'\' disabled=\'disabled\'></a>' + '<select disabled=\'disabled\'><option/></select>';
                    var input = document.createElement('input');
                    input.setAttribute('type', 'hidden');
                    el.appendChild(input).setAttribute('name', 'D');
                    if (el.querySelectorAll('[name=d]').length) {
                        rbuggyQSA.push('name' + whitespace + '*[*^$|!~]?=');
                    }
                    if (el.querySelectorAll(':enabled').length !== 2) {
                        rbuggyQSA.push(':enabled', ':disabled');
                    }
                    docElem.appendChild(el).disabled = true;
                    if (el.querySelectorAll(':disabled').length !== 2) {
                        rbuggyQSA.push(':enabled', ':disabled');
                    }
                    el.querySelectorAll('*,:x');
                    rbuggyQSA.push(',.*:');
                });
            }
            if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
                assert(function (el) {
                    support.disconnectedMatch = matches.call(el, '*');
                    matches.call(el, '[s!=\'\']:x');
                    rbuggyMatches.push('!=', pseudos);
                });
            }
            rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join('|'));
            rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join('|'));
            hasCompare = rnative.test(docElem.compareDocumentPosition);
            contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {
                var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
                return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
            } : function (a, b) {
                if (b) {
                    while (b = b.parentNode) {
                        if (b === a) {
                            return true;
                        }
                    }
                }
                return false;
            };
            sortOrder = hasCompare ? function (a, b) {
                if (a === b) {
                    hasDuplicate = true;
                    return 0;
                }
                var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                if (compare) {
                    return compare;
                }
                compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;
                if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
                    if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
                        return -1;
                    }
                    if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
                        return 1;
                    }
                    return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
                }
                return compare & 4 ? -1 : 1;
            } : function (a, b) {
                if (a === b) {
                    hasDuplicate = true;
                    return 0;
                }
                var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [a], bp = [b];
                if (!aup || !bup) {
                    return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
                } else if (aup === bup) {
                    return siblingCheck(a, b);
                }
                cur = a;
                while (cur = cur.parentNode) {
                    ap.unshift(cur);
                }
                cur = b;
                while (cur = cur.parentNode) {
                    bp.unshift(cur);
                }
                while (ap[i] === bp[i]) {
                    i++;
                }
                return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
            };
            return document;
        };
        Sizzle.matches = function (expr, elements) {
            return Sizzle(expr, null, null, elements);
        };
        Sizzle.matchesSelector = function (elem, expr) {
            if ((elem.ownerDocument || elem) !== document) {
                setDocument(elem);
            }
            expr = expr.replace(rattributeQuotes, '=\'$1\']');
            if (support.matchesSelector && documentIsHTML && !compilerCache[expr + ' '] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
                try {
                    var ret = matches.call(elem, expr);
                    if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
                        return ret;
                    }
                } catch (e) {
                }
            }
            return Sizzle(expr, document, null, [elem]).length > 0;
        };
        Sizzle.contains = function (context, elem) {
            if ((context.ownerDocument || context) !== document) {
                setDocument(context);
            }
            return contains(context, elem);
        };
        Sizzle.attr = function (elem, name) {
            if ((elem.ownerDocument || elem) !== document) {
                setDocument(elem);
            }
            var fn = Expr.attrHandle[name.toLowerCase()], val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
            return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        };
        Sizzle.escape = function (sel) {
            return (sel + '').replace(rcssescape, fcssescape);
        };
        Sizzle.error = function (msg) {
            throw new Error('Syntax error, unrecognized expression: ' + msg);
        };
        Sizzle.uniqueSort = function (results) {
            var elem, duplicates = [], j = 0, i = 0;
            hasDuplicate = !support.detectDuplicates;
            sortInput = !support.sortStable && results.slice(0);
            results.sort(sortOrder);
            if (hasDuplicate) {
                while (elem = results[i++]) {
                    if (elem === results[i]) {
                        j = duplicates.push(i);
                    }
                }
                while (j--) {
                    results.splice(duplicates[j], 1);
                }
            }
            sortInput = null;
            return results;
        };
        getText = Sizzle.getText = function (elem) {
            var node, ret = '', i = 0, nodeType = elem.nodeType;
            if (!nodeType) {
                while (node = elem[i++]) {
                    ret += getText(node);
                }
            } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
                if (typeof elem.textContent === 'string') {
                    return elem.textContent;
                } else {
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                        ret += getText(elem);
                    }
                }
            } else if (nodeType === 3 || nodeType === 4) {
                return elem.nodeValue;
            }
            return ret;
        };
        Expr = Sizzle.selectors = {
            cacheLength: 50,
            createPseudo: markFunction,
            match: matchExpr,
            attrHandle: {},
            find: {},
            relative: {
                '>': {
                    dir: 'parentNode',
                    first: true
                },
                ' ': { dir: 'parentNode' },
                '+': {
                    dir: 'previousSibling',
                    first: true
                },
                '~': { dir: 'previousSibling' }
            },
            preFilter: {
                'ATTR': function (match) {
                    match[1] = match[1].replace(runescape, funescape);
                    match[3] = (match[3] || match[4] || match[5] || '').replace(runescape, funescape);
                    if (match[2] === '~=') {
                        match[3] = ' ' + match[3] + ' ';
                    }
                    return match.slice(0, 4);
                },
                'CHILD': function (match) {
                    match[1] = match[1].toLowerCase();
                    if (match[1].slice(0, 3) === 'nth') {
                        if (!match[3]) {
                            Sizzle.error(match[0]);
                        }
                        match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === 'even' || match[3] === 'odd'));
                        match[5] = +(match[7] + match[8] || match[3] === 'odd');
                    } else if (match[3]) {
                        Sizzle.error(match[0]);
                    }
                    return match;
                },
                'PSEUDO': function (match) {
                    var excess, unquoted = !match[6] && match[2];
                    if (matchExpr['CHILD'].test(match[0])) {
                        return null;
                    }
                    if (match[3]) {
                        match[2] = match[4] || match[5] || '';
                    } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(')', unquoted.length - excess) - unquoted.length)) {
                        match[0] = match[0].slice(0, excess);
                        match[2] = unquoted.slice(0, excess);
                    }
                    return match.slice(0, 3);
                }
            },
            filter: {
                'TAG': function (nodeNameSelector) {
                    var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                    return nodeNameSelector === '*' ? function () {
                        return true;
                    } : function (elem) {
                        return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                    };
                },
                'CLASS': function (className) {
                    var pattern = classCache[className + ' '];
                    return pattern || (pattern = new RegExp('(^|' + whitespace + ')' + className + '(' + whitespace + '|$)')) && classCache(className, function (elem) {
                        return pattern.test(typeof elem.className === 'string' && elem.className || typeof elem.getAttribute !== 'undefined' && elem.getAttribute('class') || '');
                    });
                },
                'ATTR': function (name, operator, check) {
                    return function (elem) {
                        var result = Sizzle.attr(elem, name);
                        if (result == null) {
                            return operator === '!=';
                        }
                        if (!operator) {
                            return true;
                        }
                        result += '';
                        return operator === '=' ? result === check : operator === '!=' ? result !== check : operator === '^=' ? check && result.indexOf(check) === 0 : operator === '*=' ? check && result.indexOf(check) > -1 : operator === '$=' ? check && result.slice(-check.length) === check : operator === '~=' ? (' ' + result.replace(rwhitespace, ' ') + ' ').indexOf(check) > -1 : operator === '|=' ? result === check || result.slice(0, check.length + 1) === check + '-' : false;
                    };
                },
                'CHILD': function (type, what, argument, first, last) {
                    var simple = type.slice(0, 3) !== 'nth', forward = type.slice(-4) !== 'last', ofType = what === 'of-type';
                    return first === 1 && last === 0 ? function (elem) {
                        return !!elem.parentNode;
                    } : function (elem, context, xml) {
                        var cache, uniqueCache, outerCache, node, nodeIndex, start, dir = simple !== forward ? 'nextSibling' : 'previousSibling', parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = false;
                        if (parent) {
                            if (simple) {
                                while (dir) {
                                    node = elem;
                                    while (node = node[dir]) {
                                        if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                                            return false;
                                        }
                                    }
                                    start = dir = type === 'only' && !start && 'nextSibling';
                                }
                                return true;
                            }
                            start = [forward ? parent.firstChild : parent.lastChild];
                            if (forward && useCache) {
                                node = parent;
                                outerCache = node[expando] || (node[expando] = {});
                                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                                cache = uniqueCache[type] || [];
                                nodeIndex = cache[0] === dirruns && cache[1];
                                diff = nodeIndex && cache[2];
                                node = nodeIndex && parent.childNodes[nodeIndex];
                                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                                    if (node.nodeType === 1 && ++diff && node === elem) {
                                        uniqueCache[type] = [
                                            dirruns,
                                            nodeIndex,
                                            diff
                                        ];
                                        break;
                                    }
                                }
                            } else {
                                if (useCache) {
                                    node = elem;
                                    outerCache = node[expando] || (node[expando] = {});
                                    uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                                    cache = uniqueCache[type] || [];
                                    nodeIndex = cache[0] === dirruns && cache[1];
                                    diff = nodeIndex;
                                }
                                if (diff === false) {
                                    while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                                        if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                                            if (useCache) {
                                                outerCache = node[expando] || (node[expando] = {});
                                                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                                                uniqueCache[type] = [
                                                    dirruns,
                                                    diff
                                                ];
                                            }
                                            if (node === elem) {
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                            diff -= last;
                            return diff === first || diff % first === 0 && diff / first >= 0;
                        }
                    };
                },
                'PSEUDO': function (pseudo, argument) {
                    var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error('unsupported pseudo: ' + pseudo);
                    if (fn[expando]) {
                        return fn(argument);
                    }
                    if (fn.length > 1) {
                        args = [
                            pseudo,
                            pseudo,
                            '',
                            argument
                        ];
                        return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
                            var idx, matched = fn(seed, argument), i = matched.length;
                            while (i--) {
                                idx = indexOf(seed, matched[i]);
                                seed[idx] = !(matches[idx] = matched[i]);
                            }
                        }) : function (elem) {
                            return fn(elem, 0, args);
                        };
                    }
                    return fn;
                }
            },
            pseudos: {
                'not': markFunction(function (selector) {
                    var input = [], results = [], matcher = compile(selector.replace(rtrim, '$1'));
                    return matcher[expando] ? markFunction(function (seed, matches, context, xml) {
                        var elem, unmatched = matcher(seed, null, xml, []), i = seed.length;
                        while (i--) {
                            if (elem = unmatched[i]) {
                                seed[i] = !(matches[i] = elem);
                            }
                        }
                    }) : function (elem, context, xml) {
                        input[0] = elem;
                        matcher(input, null, xml, results);
                        input[0] = null;
                        return !results.pop();
                    };
                }),
                'has': markFunction(function (selector) {
                    return function (elem) {
                        return Sizzle(selector, elem).length > 0;
                    };
                }),
                'contains': markFunction(function (text) {
                    text = text.replace(runescape, funescape);
                    return function (elem) {
                        return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
                    };
                }),
                'lang': markFunction(function (lang) {
                    if (!ridentifier.test(lang || '')) {
                        Sizzle.error('unsupported lang: ' + lang);
                    }
                    lang = lang.replace(runescape, funescape).toLowerCase();
                    return function (elem) {
                        var elemLang;
                        do {
                            if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute('xml:lang') || elem.getAttribute('lang')) {
                                elemLang = elemLang.toLowerCase();
                                return elemLang === lang || elemLang.indexOf(lang + '-') === 0;
                            }
                        } while ((elem = elem.parentNode) && elem.nodeType === 1);
                        return false;
                    };
                }),
                'target': function (elem) {
                    var hash = window.location && window.location.hash;
                    return hash && hash.slice(1) === elem.id;
                },
                'root': function (elem) {
                    return elem === docElem;
                },
                'focus': function (elem) {
                    return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                },
                'enabled': createDisabledPseudo(false),
                'disabled': createDisabledPseudo(true),
                'checked': function (elem) {
                    var nodeName = elem.nodeName.toLowerCase();
                    return nodeName === 'input' && !!elem.checked || nodeName === 'option' && !!elem.selected;
                },
                'selected': function (elem) {
                    if (elem.parentNode) {
                        elem.parentNode.selectedIndex;
                    }
                    return elem.selected === true;
                },
                'empty': function (elem) {
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                        if (elem.nodeType < 6) {
                            return false;
                        }
                    }
                    return true;
                },
                'parent': function (elem) {
                    return !Expr.pseudos['empty'](elem);
                },
                'header': function (elem) {
                    return rheader.test(elem.nodeName);
                },
                'input': function (elem) {
                    return rinputs.test(elem.nodeName);
                },
                'button': function (elem) {
                    var name = elem.nodeName.toLowerCase();
                    return name === 'input' && elem.type === 'button' || name === 'button';
                },
                'text': function (elem) {
                    var attr;
                    return elem.nodeName.toLowerCase() === 'input' && elem.type === 'text' && ((attr = elem.getAttribute('type')) == null || attr.toLowerCase() === 'text');
                },
                'first': createPositionalPseudo(function () {
                    return [0];
                }),
                'last': createPositionalPseudo(function (matchIndexes, length) {
                    return [length - 1];
                }),
                'eq': createPositionalPseudo(function (matchIndexes, length, argument) {
                    return [argument < 0 ? argument + length : argument];
                }),
                'even': createPositionalPseudo(function (matchIndexes, length) {
                    var i = 0;
                    for (; i < length; i += 2) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),
                'odd': createPositionalPseudo(function (matchIndexes, length) {
                    var i = 1;
                    for (; i < length; i += 2) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),
                'lt': createPositionalPseudo(function (matchIndexes, length, argument) {
                    var i = argument < 0 ? argument + length : argument;
                    for (; --i >= 0;) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),
                'gt': createPositionalPseudo(function (matchIndexes, length, argument) {
                    var i = argument < 0 ? argument + length : argument;
                    for (; ++i < length;) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                })
            }
        };
        Expr.pseudos['nth'] = Expr.pseudos['eq'];
        for (i in {
                radio: true,
                checkbox: true,
                file: true,
                password: true,
                image: true
            }) {
            Expr.pseudos[i] = createInputPseudo(i);
        }
        for (i in {
                submit: true,
                reset: true
            }) {
            Expr.pseudos[i] = createButtonPseudo(i);
        }
        function setFilters() {
        }
        setFilters.prototype = Expr.filters = Expr.pseudos;
        Expr.setFilters = new setFilters();
        tokenize = Sizzle.tokenize = function (selector, parseOnly) {
            var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + ' '];
            if (cached) {
                return parseOnly ? 0 : cached.slice(0);
            }
            soFar = selector;
            groups = [];
            preFilters = Expr.preFilter;
            while (soFar) {
                if (!matched || (match = rcomma.exec(soFar))) {
                    if (match) {
                        soFar = soFar.slice(match[0].length) || soFar;
                    }
                    groups.push(tokens = []);
                }
                matched = false;
                if (match = rcombinators.exec(soFar)) {
                    matched = match.shift();
                    tokens.push({
                        value: matched,
                        type: match[0].replace(rtrim, ' ')
                    });
                    soFar = soFar.slice(matched.length);
                }
                for (type in Expr.filter) {
                    if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                        matched = match.shift();
                        tokens.push({
                            value: matched,
                            type: type,
                            matches: match
                        });
                        soFar = soFar.slice(matched.length);
                    }
                }
                if (!matched) {
                    break;
                }
            }
            return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
        };
        function toSelector(tokens) {
            var i = 0, len = tokens.length, selector = '';
            for (; i < len; i++) {
                selector += tokens[i].value;
            }
            return selector;
        }
        function addCombinator(matcher, combinator, base) {
            var dir = combinator.dir, skip = combinator.next, key = skip || dir, checkNonElements = base && key === 'parentNode', doneName = done++;
            return combinator.first ? function (elem, context, xml) {
                while (elem = elem[dir]) {
                    if (elem.nodeType === 1 || checkNonElements) {
                        return matcher(elem, context, xml);
                    }
                }
                return false;
            } : function (elem, context, xml) {
                var oldCache, uniqueCache, outerCache, newCache = [
                        dirruns,
                        doneName
                    ];
                if (xml) {
                    while (elem = elem[dir]) {
                        if (elem.nodeType === 1 || checkNonElements) {
                            if (matcher(elem, context, xml)) {
                                return true;
                            }
                        }
                    }
                } else {
                    while (elem = elem[dir]) {
                        if (elem.nodeType === 1 || checkNonElements) {
                            outerCache = elem[expando] || (elem[expando] = {});
                            uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});
                            if (skip && skip === elem.nodeName.toLowerCase()) {
                                elem = elem[dir] || elem;
                            } else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                                return newCache[2] = oldCache[2];
                            } else {
                                uniqueCache[key] = newCache;
                                if (newCache[2] = matcher(elem, context, xml)) {
                                    return true;
                                }
                            }
                        }
                    }
                }
                return false;
            };
        }
        function elementMatcher(matchers) {
            return matchers.length > 1 ? function (elem, context, xml) {
                var i = matchers.length;
                while (i--) {
                    if (!matchers[i](elem, context, xml)) {
                        return false;
                    }
                }
                return true;
            } : matchers[0];
        }
        function multipleContexts(selector, contexts, results) {
            var i = 0, len = contexts.length;
            for (; i < len; i++) {
                Sizzle(selector, contexts[i], results);
            }
            return results;
        }
        function condense(unmatched, map, filter, context, xml) {
            var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = map != null;
            for (; i < len; i++) {
                if (elem = unmatched[i]) {
                    if (!filter || filter(elem, context, xml)) {
                        newUnmatched.push(elem);
                        if (mapped) {
                            map.push(i);
                        }
                    }
                }
            }
            return newUnmatched;
        }
        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
            if (postFilter && !postFilter[expando]) {
                postFilter = setMatcher(postFilter);
            }
            if (postFinder && !postFinder[expando]) {
                postFinder = setMatcher(postFinder, postSelector);
            }
            return markFunction(function (seed, results, context, xml) {
                var temp, i, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(selector || '*', context.nodeType ? [context] : context, []), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems, matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
                if (matcher) {
                    matcher(matcherIn, matcherOut, context, xml);
                }
                if (postFilter) {
                    temp = condense(matcherOut, postMap);
                    postFilter(temp, [], context, xml);
                    i = temp.length;
                    while (i--) {
                        if (elem = temp[i]) {
                            matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
                        }
                    }
                }
                if (seed) {
                    if (postFinder || preFilter) {
                        if (postFinder) {
                            temp = [];
                            i = matcherOut.length;
                            while (i--) {
                                if (elem = matcherOut[i]) {
                                    temp.push(matcherIn[i] = elem);
                                }
                            }
                            postFinder(null, matcherOut = [], temp, xml);
                        }
                        i = matcherOut.length;
                        while (i--) {
                            if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
                                seed[temp] = !(results[temp] = elem);
                            }
                        }
                    }
                } else {
                    matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
                    if (postFinder) {
                        postFinder(null, results, matcherOut, xml);
                    } else {
                        push.apply(results, matcherOut);
                    }
                }
            });
        }
        function matcherFromTokens(tokens) {
            var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[' '], i = leadingRelative ? 1 : 0, matchContext = addCombinator(function (elem) {
                    return elem === checkContext;
                }, implicitRelative, true), matchAnyContext = addCombinator(function (elem) {
                    return indexOf(checkContext, elem) > -1;
                }, implicitRelative, true), matchers = [function (elem, context, xml) {
                        var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
                        checkContext = null;
                        return ret;
                    }];
            for (; i < len; i++) {
                if (matcher = Expr.relative[tokens[i].type]) {
                    matchers = [addCombinator(elementMatcher(matchers), matcher)];
                } else {
                    matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
                    if (matcher[expando]) {
                        j = ++i;
                        for (; j < len; j++) {
                            if (Expr.relative[tokens[j].type]) {
                                break;
                            }
                        }
                        return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === ' ' ? '*' : '' })).replace(rtrim, '$1'), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
                    }
                    matchers.push(matcher);
                }
            }
            return elementMatcher(matchers);
        }
        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
            var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function (seed, context, xml, results, outermost) {
                    var elem, j, matcher, matchedCount = 0, i = '0', unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find['TAG']('*', outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
                    if (outermost) {
                        outermostContext = context === document || context || outermost;
                    }
                    for (; i !== len && (elem = elems[i]) != null; i++) {
                        if (byElement && elem) {
                            j = 0;
                            if (!context && elem.ownerDocument !== document) {
                                setDocument(elem);
                                xml = !documentIsHTML;
                            }
                            while (matcher = elementMatchers[j++]) {
                                if (matcher(elem, context || document, xml)) {
                                    results.push(elem);
                                    break;
                                }
                            }
                            if (outermost) {
                                dirruns = dirrunsUnique;
                            }
                        }
                        if (bySet) {
                            if (elem = !matcher && elem) {
                                matchedCount--;
                            }
                            if (seed) {
                                unmatched.push(elem);
                            }
                        }
                    }
                    matchedCount += i;
                    if (bySet && i !== matchedCount) {
                        j = 0;
                        while (matcher = setMatchers[j++]) {
                            matcher(unmatched, setMatched, context, xml);
                        }
                        if (seed) {
                            if (matchedCount > 0) {
                                while (i--) {
                                    if (!(unmatched[i] || setMatched[i])) {
                                        setMatched[i] = pop.call(results);
                                    }
                                }
                            }
                            setMatched = condense(setMatched);
                        }
                        push.apply(results, setMatched);
                        if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                            Sizzle.uniqueSort(results);
                        }
                    }
                    if (outermost) {
                        dirruns = dirrunsUnique;
                        outermostContext = contextBackup;
                    }
                    return unmatched;
                };
            return bySet ? markFunction(superMatcher) : superMatcher;
        }
        compile = Sizzle.compile = function (selector, match) {
            var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + ' '];
            if (!cached) {
                if (!match) {
                    match = tokenize(selector);
                }
                i = match.length;
                while (i--) {
                    cached = matcherFromTokens(match[i]);
                    if (cached[expando]) {
                        setMatchers.push(cached);
                    } else {
                        elementMatchers.push(cached);
                    }
                }
                cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
                cached.selector = selector;
            }
            return cached;
        };
        select = Sizzle.select = function (selector, context, results, seed) {
            var i, tokens, token, type, find, compiled = typeof selector === 'function' && selector, match = !seed && tokenize(selector = compiled.selector || selector);
            results = results || [];
            if (match.length === 1) {
                tokens = match[0] = match[0].slice(0);
                if (tokens.length > 2 && (token = tokens[0]).type === 'ID' && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
                    context = (Expr.find['ID'](token.matches[0].replace(runescape, funescape), context) || [])[0];
                    if (!context) {
                        return results;
                    } else if (compiled) {
                        context = context.parentNode;
                    }
                    selector = selector.slice(tokens.shift().value.length);
                }
                i = matchExpr['needsContext'].test(selector) ? 0 : tokens.length;
                while (i--) {
                    token = tokens[i];
                    if (Expr.relative[type = token.type]) {
                        break;
                    }
                    if (find = Expr.find[type]) {
                        if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
                            tokens.splice(i, 1);
                            selector = seed.length && toSelector(tokens);
                            if (!selector) {
                                push.apply(results, seed);
                                return results;
                            }
                            break;
                        }
                    }
                }
            }
            (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
            return results;
        };
        support.sortStable = expando.split('').sort(sortOrder).join('') === expando;
        support.detectDuplicates = !!hasDuplicate;
        setDocument();
        support.sortDetached = assert(function (el) {
            return el.compareDocumentPosition(document.createElement('fieldset')) & 1;
        });
        if (!assert(function (el) {
                el.innerHTML = '<a href=\'#\'></a>';
                return el.firstChild.getAttribute('href') === '#';
            })) {
            addHandle('type|href|height|width', function (elem, name, isXML) {
                if (!isXML) {
                    return elem.getAttribute(name, name.toLowerCase() === 'type' ? 1 : 2);
                }
            });
        }
        if (!support.attributes || !assert(function (el) {
                el.innerHTML = '<input/>';
                el.firstChild.setAttribute('value', '');
                return el.firstChild.getAttribute('value') === '';
            })) {
            addHandle('value', function (elem, name, isXML) {
                if (!isXML && elem.nodeName.toLowerCase() === 'input') {
                    return elem.defaultValue;
                }
            });
        }
        if (!assert(function (el) {
                return el.getAttribute('disabled') == null;
            })) {
            addHandle(booleans, function (elem, name, isXML) {
                var val;
                if (!isXML) {
                    return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
                }
            });
        }
        return Sizzle;
    }(window);
    jQuery.find = Sizzle;
    jQuery.expr = Sizzle.selectors;
    jQuery.expr[':'] = jQuery.expr.pseudos;
    jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
    jQuery.text = Sizzle.getText;
    jQuery.isXMLDoc = Sizzle.isXML;
    jQuery.contains = Sizzle.contains;
    jQuery.escapeSelector = Sizzle.escape;
    var dir = function (elem, dir, until) {
        var matched = [], truncate = until !== undefined;
        while ((elem = elem[dir]) && elem.nodeType !== 9) {
            if (elem.nodeType === 1) {
                if (truncate && jQuery(elem).is(until)) {
                    break;
                }
                matched.push(elem);
            }
        }
        return matched;
    };
    var siblings = function (n, elem) {
        var matched = [];
        for (; n; n = n.nextSibling) {
            if (n.nodeType === 1 && n !== elem) {
                matched.push(n);
            }
        }
        return matched;
    };
    var rneedsContext = jQuery.expr.match.needsContext;
    function nodeName(elem, name) {
        return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
    }
    ;
    var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
    var risSimple = /^.[^:#\[\.,]*$/;
    function winnow(elements, qualifier, not) {
        if (jQuery.isFunction(qualifier)) {
            return jQuery.grep(elements, function (elem, i) {
                return !!qualifier.call(elem, i, elem) !== not;
            });
        }
        if (qualifier.nodeType) {
            return jQuery.grep(elements, function (elem) {
                return elem === qualifier !== not;
            });
        }
        if (typeof qualifier !== 'string') {
            return jQuery.grep(elements, function (elem) {
                return indexOf.call(qualifier, elem) > -1 !== not;
            });
        }
        if (risSimple.test(qualifier)) {
            return jQuery.filter(qualifier, elements, not);
        }
        qualifier = jQuery.filter(qualifier, elements);
        return jQuery.grep(elements, function (elem) {
            return indexOf.call(qualifier, elem) > -1 !== not && elem.nodeType === 1;
        });
    }
    jQuery.filter = function (expr, elems, not) {
        var elem = elems[0];
        if (not) {
            expr = ':not(' + expr + ')';
        }
        if (elems.length === 1 && elem.nodeType === 1) {
            return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];
        }
        return jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
            return elem.nodeType === 1;
        }));
    };
    jQuery.fn.extend({
        find: function (selector) {
            var i, ret, len = this.length, self = this;
            if (typeof selector !== 'string') {
                return this.pushStack(jQuery(selector).filter(function () {
                    for (i = 0; i < len; i++) {
                        if (jQuery.contains(self[i], this)) {
                            return true;
                        }
                    }
                }));
            }
            ret = this.pushStack([]);
            for (i = 0; i < len; i++) {
                jQuery.find(selector, self[i], ret);
            }
            return len > 1 ? jQuery.uniqueSort(ret) : ret;
        },
        filter: function (selector) {
            return this.pushStack(winnow(this, selector || [], false));
        },
        not: function (selector) {
            return this.pushStack(winnow(this, selector || [], true));
        },
        is: function (selector) {
            return !!winnow(this, typeof selector === 'string' && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
        }
    });
    var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/, init = jQuery.fn.init = function (selector, context, root) {
            var match, elem;
            if (!selector) {
                return this;
            }
            root = root || rootjQuery;
            if (typeof selector === 'string') {
                if (selector[0] === '<' && selector[selector.length - 1] === '>' && selector.length >= 3) {
                    match = [
                        null,
                        selector,
                        null
                    ];
                } else {
                    match = rquickExpr.exec(selector);
                }
                if (match && (match[1] || !context)) {
                    if (match[1]) {
                        context = context instanceof jQuery ? context[0] : context;
                        jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));
                        if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                            for (match in context) {
                                if (jQuery.isFunction(this[match])) {
                                    this[match](context[match]);
                                } else {
                                    this.attr(match, context[match]);
                                }
                            }
                        }
                        return this;
                    } else {
                        elem = document.getElementById(match[2]);
                        if (elem) {
                            this[0] = elem;
                            this.length = 1;
                        }
                        return this;
                    }
                } else if (!context || context.jquery) {
                    return (context || root).find(selector);
                } else {
                    return this.constructor(context).find(selector);
                }
            } else if (selector.nodeType) {
                this[0] = selector;
                this.length = 1;
                return this;
            } else if (jQuery.isFunction(selector)) {
                return root.ready !== undefined ? root.ready(selector) : selector(jQuery);
            }
            return jQuery.makeArray(selector, this);
        };
    init.prototype = jQuery.fn;
    rootjQuery = jQuery(document);
    var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
            children: true,
            contents: true,
            next: true,
            prev: true
        };
    jQuery.fn.extend({
        has: function (target) {
            var targets = jQuery(target, this), l = targets.length;
            return this.filter(function () {
                var i = 0;
                for (; i < l; i++) {
                    if (jQuery.contains(this, targets[i])) {
                        return true;
                    }
                }
            });
        },
        closest: function (selectors, context) {
            var cur, i = 0, l = this.length, matched = [], targets = typeof selectors !== 'string' && jQuery(selectors);
            if (!rneedsContext.test(selectors)) {
                for (; i < l; i++) {
                    for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
                        if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
                            matched.push(cur);
                            break;
                        }
                    }
                }
            }
            return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
        },
        index: function (elem) {
            if (!elem) {
                return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
            }
            if (typeof elem === 'string') {
                return indexOf.call(jQuery(elem), this[0]);
            }
            return indexOf.call(this, elem.jquery ? elem[0] : elem);
        },
        add: function (selector, context) {
            return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
        },
        addBack: function (selector) {
            return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
        }
    });
    function sibling(cur, dir) {
        while ((cur = cur[dir]) && cur.nodeType !== 1) {
        }
        return cur;
    }
    jQuery.each({
        parent: function (elem) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function (elem) {
            return dir(elem, 'parentNode');
        },
        parentsUntil: function (elem, i, until) {
            return dir(elem, 'parentNode', until);
        },
        next: function (elem) {
            return sibling(elem, 'nextSibling');
        },
        prev: function (elem) {
            return sibling(elem, 'previousSibling');
        },
        nextAll: function (elem) {
            return dir(elem, 'nextSibling');
        },
        prevAll: function (elem) {
            return dir(elem, 'previousSibling');
        },
        nextUntil: function (elem, i, until) {
            return dir(elem, 'nextSibling', until);
        },
        prevUntil: function (elem, i, until) {
            return dir(elem, 'previousSibling', until);
        },
        siblings: function (elem) {
            return siblings((elem.parentNode || {}).firstChild, elem);
        },
        children: function (elem) {
            return siblings(elem.firstChild);
        },
        contents: function (elem) {
            if (nodeName(elem, 'iframe')) {
                return elem.contentDocument;
            }
            if (nodeName(elem, 'template')) {
                elem = elem.content || elem;
            }
            return jQuery.merge([], elem.childNodes);
        }
    }, function (name, fn) {
        jQuery.fn[name] = function (until, selector) {
            var matched = jQuery.map(this, fn, until);
            if (name.slice(-5) !== 'Until') {
                selector = until;
            }
            if (selector && typeof selector === 'string') {
                matched = jQuery.filter(selector, matched);
            }
            if (this.length > 1) {
                if (!guaranteedUnique[name]) {
                    jQuery.uniqueSort(matched);
                }
                if (rparentsprev.test(name)) {
                    matched.reverse();
                }
            }
            return this.pushStack(matched);
        };
    });
    var rnothtmlwhite = /[^\x20\t\r\n\f]+/g;
    function createOptions(options) {
        var object = {};
        jQuery.each(options.match(rnothtmlwhite) || [], function (_, flag) {
            object[flag] = true;
        });
        return object;
    }
    jQuery.Callbacks = function (options) {
        options = typeof options === 'string' ? createOptions(options) : jQuery.extend({}, options);
        var firing, memory, fired, locked, list = [], queue = [], firingIndex = -1, fire = function () {
                locked = locked || options.once;
                fired = firing = true;
                for (; queue.length; firingIndex = -1) {
                    memory = queue.shift();
                    while (++firingIndex < list.length) {
                        if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
                            firingIndex = list.length;
                            memory = false;
                        }
                    }
                }
                if (!options.memory) {
                    memory = false;
                }
                firing = false;
                if (locked) {
                    if (memory) {
                        list = [];
                    } else {
                        list = '';
                    }
                }
            }, self = {
                add: function () {
                    if (list) {
                        if (memory && !firing) {
                            firingIndex = list.length - 1;
                            queue.push(memory);
                        }
                        (function add(args) {
                            jQuery.each(args, function (_, arg) {
                                if (jQuery.isFunction(arg)) {
                                    if (!options.unique || !self.has(arg)) {
                                        list.push(arg);
                                    }
                                } else if (arg && arg.length && jQuery.type(arg) !== 'string') {
                                    add(arg);
                                }
                            });
                        }(arguments));
                        if (memory && !firing) {
                            fire();
                        }
                    }
                    return this;
                },
                remove: function () {
                    jQuery.each(arguments, function (_, arg) {
                        var index;
                        while ((index = jQuery.inArray(arg, list, index)) > -1) {
                            list.splice(index, 1);
                            if (index <= firingIndex) {
                                firingIndex--;
                            }
                        }
                    });
                    return this;
                },
                has: function (fn) {
                    return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
                },
                empty: function () {
                    if (list) {
                        list = [];
                    }
                    return this;
                },
                disable: function () {
                    locked = queue = [];
                    list = memory = '';
                    return this;
                },
                disabled: function () {
                    return !list;
                },
                lock: function () {
                    locked = queue = [];
                    if (!memory && !firing) {
                        list = memory = '';
                    }
                    return this;
                },
                locked: function () {
                    return !!locked;
                },
                fireWith: function (context, args) {
                    if (!locked) {
                        args = args || [];
                        args = [
                            context,
                            args.slice ? args.slice() : args
                        ];
                        queue.push(args);
                        if (!firing) {
                            fire();
                        }
                    }
                    return this;
                },
                fire: function () {
                    self.fireWith(this, arguments);
                    return this;
                },
                fired: function () {
                    return !!fired;
                }
            };
        return self;
    };
    function Identity(v) {
        return v;
    }
    function Thrower(ex) {
        throw ex;
    }
    function adoptValue(value, resolve, reject, noValue) {
        var method;
        try {
            if (value && jQuery.isFunction(method = value.promise)) {
                method.call(value).done(resolve).fail(reject);
            } else if (value && jQuery.isFunction(method = value.then)) {
                method.call(value, resolve, reject);
            } else {
                resolve.apply(undefined, [value].slice(noValue));
            }
        } catch (value) {
            reject.apply(undefined, [value]);
        }
    }
    jQuery.extend({
        Deferred: function (func) {
            var tuples = [
                    [
                        'notify',
                        'progress',
                        jQuery.Callbacks('memory'),
                        jQuery.Callbacks('memory'),
                        2
                    ],
                    [
                        'resolve',
                        'done',
                        jQuery.Callbacks('once memory'),
                        jQuery.Callbacks('once memory'),
                        0,
                        'resolved'
                    ],
                    [
                        'reject',
                        'fail',
                        jQuery.Callbacks('once memory'),
                        jQuery.Callbacks('once memory'),
                        1,
                        'rejected'
                    ]
                ], state = 'pending', promise = {
                    state: function () {
                        return state;
                    },
                    always: function () {
                        deferred.done(arguments).fail(arguments);
                        return this;
                    },
                    'catch': function (fn) {
                        return promise.then(null, fn);
                    },
                    pipe: function () {
                        var fns = arguments;
                        return jQuery.Deferred(function (newDefer) {
                            jQuery.each(tuples, function (i, tuple) {
                                var fn = jQuery.isFunction(fns[tuple[4]]) && fns[tuple[4]];
                                deferred[tuple[1]](function () {
                                    var returned = fn && fn.apply(this, arguments);
                                    if (returned && jQuery.isFunction(returned.promise)) {
                                        returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                                    } else {
                                        newDefer[tuple[0] + 'With'](this, fn ? [returned] : arguments);
                                    }
                                });
                            });
                            fns = null;
                        }).promise();
                    },
                    then: function (onFulfilled, onRejected, onProgress) {
                        var maxDepth = 0;
                        function resolve(depth, deferred, handler, special) {
                            return function () {
                                var that = this, args = arguments, mightThrow = function () {
                                        var returned, then;
                                        if (depth < maxDepth) {
                                            return;
                                        }
                                        returned = handler.apply(that, args);
                                        if (returned === deferred.promise()) {
                                            throw new TypeError('Thenable self-resolution');
                                        }
                                        then = returned && (typeof returned === 'object' || typeof returned === 'function') && returned.then;
                                        if (jQuery.isFunction(then)) {
                                            if (special) {
                                                then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special));
                                            } else {
                                                maxDepth++;
                                                then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith));
                                            }
                                        } else {
                                            if (handler !== Identity) {
                                                that = undefined;
                                                args = [returned];
                                            }
                                            (special || deferred.resolveWith)(that, args);
                                        }
                                    }, process = special ? mightThrow : function () {
                                        try {
                                            mightThrow();
                                        } catch (e) {
                                            if (jQuery.Deferred.exceptionHook) {
                                                jQuery.Deferred.exceptionHook(e, process.stackTrace);
                                            }
                                            if (depth + 1 >= maxDepth) {
                                                if (handler !== Thrower) {
                                                    that = undefined;
                                                    args = [e];
                                                }
                                                deferred.rejectWith(that, args);
                                            }
                                        }
                                    };
                                if (depth) {
                                    process();
                                } else {
                                    if (jQuery.Deferred.getStackHook) {
                                        process.stackTrace = jQuery.Deferred.getStackHook();
                                    }
                                    window.setTimeout(process);
                                }
                            };
                        }
                        return jQuery.Deferred(function (newDefer) {
                            tuples[0][3].add(resolve(0, newDefer, jQuery.isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith));
                            tuples[1][3].add(resolve(0, newDefer, jQuery.isFunction(onFulfilled) ? onFulfilled : Identity));
                            tuples[2][3].add(resolve(0, newDefer, jQuery.isFunction(onRejected) ? onRejected : Thrower));
                        }).promise();
                    },
                    promise: function (obj) {
                        return obj != null ? jQuery.extend(obj, promise) : promise;
                    }
                }, deferred = {};
            jQuery.each(tuples, function (i, tuple) {
                var list = tuple[2], stateString = tuple[5];
                promise[tuple[1]] = list.add;
                if (stateString) {
                    list.add(function () {
                        state = stateString;
                    }, tuples[3 - i][2].disable, tuples[0][2].lock);
                }
                list.add(tuple[3].fire);
                deferred[tuple[0]] = function () {
                    deferred[tuple[0] + 'With'](this === deferred ? undefined : this, arguments);
                    return this;
                };
                deferred[tuple[0] + 'With'] = list.fireWith;
            });
            promise.promise(deferred);
            if (func) {
                func.call(deferred, deferred);
            }
            return deferred;
        },
        when: function (singleValue) {
            var remaining = arguments.length, i = remaining, resolveContexts = Array(i), resolveValues = slice.call(arguments), master = jQuery.Deferred(), updateFunc = function (i) {
                    return function (value) {
                        resolveContexts[i] = this;
                        resolveValues[i] = arguments.length > 1 ? slice.call(arguments) : value;
                        if (!--remaining) {
                            master.resolveWith(resolveContexts, resolveValues);
                        }
                    };
                };
            if (remaining <= 1) {
                adoptValue(singleValue, master.done(updateFunc(i)).resolve, master.reject, !remaining);
                if (master.state() === 'pending' || jQuery.isFunction(resolveValues[i] && resolveValues[i].then)) {
                    return master.then();
                }
            }
            while (i--) {
                adoptValue(resolveValues[i], updateFunc(i), master.reject);
            }
            return master.promise();
        }
    });
    var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
    jQuery.Deferred.exceptionHook = function (error, stack) {
        if (window.console && window.console.warn && error && rerrorNames.test(error.name)) {
            window.console.warn('jQuery.Deferred exception: ' + error.message, error.stack, stack);
        }
    };
    jQuery.readyException = function (error) {
        window.setTimeout(function () {
            throw error;
        });
    };
    var readyList = jQuery.Deferred();
    jQuery.fn.ready = function (fn) {
        readyList.then(fn).catch(function (error) {
            jQuery.readyException(error);
        });
        return this;
    };
    jQuery.extend({
        isReady: false,
        readyWait: 1,
        ready: function (wait) {
            if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
                return;
            }
            jQuery.isReady = true;
            if (wait !== true && --jQuery.readyWait > 0) {
                return;
            }
            readyList.resolveWith(document, [jQuery]);
        }
    });
    jQuery.ready.then = readyList.then;
    function completed() {
        document.removeEventListener('DOMContentLoaded', completed);
        window.removeEventListener('load', completed);
        jQuery.ready();
    }
    if (document.readyState === 'complete' || document.readyState !== 'loading' && !document.documentElement.doScroll) {
        window.setTimeout(jQuery.ready);
    } else {
        document.addEventListener('DOMContentLoaded', completed);
        window.addEventListener('load', completed);
    }
    var access = function (elems, fn, key, value, chainable, emptyGet, raw) {
        var i = 0, len = elems.length, bulk = key == null;
        if (jQuery.type(key) === 'object') {
            chainable = true;
            for (i in key) {
                access(elems, fn, i, key[i], true, emptyGet, raw);
            }
        } else if (value !== undefined) {
            chainable = true;
            if (!jQuery.isFunction(value)) {
                raw = true;
            }
            if (bulk) {
                if (raw) {
                    fn.call(elems, value);
                    fn = null;
                } else {
                    bulk = fn;
                    fn = function (elem, key, value) {
                        return bulk.call(jQuery(elem), value);
                    };
                }
            }
            if (fn) {
                for (; i < len; i++) {
                    fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
                }
            }
        }
        if (chainable) {
            return elems;
        }
        if (bulk) {
            return fn.call(elems);
        }
        return len ? fn(elems[0], key) : emptyGet;
    };
    var acceptData = function (owner) {
        return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
    };
    function Data() {
        this.expando = jQuery.expando + Data.uid++;
    }
    Data.uid = 1;
    Data.prototype = {
        cache: function (owner) {
            var value = owner[this.expando];
            if (!value) {
                value = {};
                if (acceptData(owner)) {
                    if (owner.nodeType) {
                        owner[this.expando] = value;
                    } else {
                        Object.defineProperty(owner, this.expando, {
                            value: value,
                            configurable: true
                        });
                    }
                }
            }
            return value;
        },
        set: function (owner, data, value) {
            var prop, cache = this.cache(owner);
            if (typeof data === 'string') {
                cache[jQuery.camelCase(data)] = value;
            } else {
                for (prop in data) {
                    cache[jQuery.camelCase(prop)] = data[prop];
                }
            }
            return cache;
        },
        get: function (owner, key) {
            return key === undefined ? this.cache(owner) : owner[this.expando] && owner[this.expando][jQuery.camelCase(key)];
        },
        access: function (owner, key, value) {
            if (key === undefined || key && typeof key === 'string' && value === undefined) {
                return this.get(owner, key);
            }
            this.set(owner, key, value);
            return value !== undefined ? value : key;
        },
        remove: function (owner, key) {
            var i, cache = owner[this.expando];
            if (cache === undefined) {
                return;
            }
            if (key !== undefined) {
                if (Array.isArray(key)) {
                    key = key.map(jQuery.camelCase);
                } else {
                    key = jQuery.camelCase(key);
                    key = key in cache ? [key] : key.match(rnothtmlwhite) || [];
                }
                i = key.length;
                while (i--) {
                    delete cache[key[i]];
                }
            }
            if (key === undefined || jQuery.isEmptyObject(cache)) {
                if (owner.nodeType) {
                    owner[this.expando] = undefined;
                } else {
                    delete owner[this.expando];
                }
            }
        },
        hasData: function (owner) {
            var cache = owner[this.expando];
            return cache !== undefined && !jQuery.isEmptyObject(cache);
        }
    };
    var dataPriv = new Data();
    var dataUser = new Data();
    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /[A-Z]/g;
    function getData(data) {
        if (data === 'true') {
            return true;
        }
        if (data === 'false') {
            return false;
        }
        if (data === 'null') {
            return null;
        }
        if (data === +data + '') {
            return +data;
        }
        if (rbrace.test(data)) {
            return JSON.parse(data);
        }
        return data;
    }
    function dataAttr(elem, key, data) {
        var name;
        if (data === undefined && elem.nodeType === 1) {
            name = 'data-' + key.replace(rmultiDash, '-$&').toLowerCase();
            data = elem.getAttribute(name);
            if (typeof data === 'string') {
                try {
                    data = getData(data);
                } catch (e) {
                }
                dataUser.set(elem, key, data);
            } else {
                data = undefined;
            }
        }
        return data;
    }
    jQuery.extend({
        hasData: function (elem) {
            return dataUser.hasData(elem) || dataPriv.hasData(elem);
        },
        data: function (elem, name, data) {
            return dataUser.access(elem, name, data);
        },
        removeData: function (elem, name) {
            dataUser.remove(elem, name);
        },
        _data: function (elem, name, data) {
            return dataPriv.access(elem, name, data);
        },
        _removeData: function (elem, name) {
            dataPriv.remove(elem, name);
        }
    });
    jQuery.fn.extend({
        data: function (key, value) {
            var i, name, data, elem = this[0], attrs = elem && elem.attributes;
            if (key === undefined) {
                if (this.length) {
                    data = dataUser.get(elem);
                    if (elem.nodeType === 1 && !dataPriv.get(elem, 'hasDataAttrs')) {
                        i = attrs.length;
                        while (i--) {
                            if (attrs[i]) {
                                name = attrs[i].name;
                                if (name.indexOf('data-') === 0) {
                                    name = jQuery.camelCase(name.slice(5));
                                    dataAttr(elem, name, data[name]);
                                }
                            }
                        }
                        dataPriv.set(elem, 'hasDataAttrs', true);
                    }
                }
                return data;
            }
            if (typeof key === 'object') {
                return this.each(function () {
                    dataUser.set(this, key);
                });
            }
            return access(this, function (value) {
                var data;
                if (elem && value === undefined) {
                    data = dataUser.get(elem, key);
                    if (data !== undefined) {
                        return data;
                    }
                    data = dataAttr(elem, key);
                    if (data !== undefined) {
                        return data;
                    }
                    return;
                }
                this.each(function () {
                    dataUser.set(this, key, value);
                });
            }, null, value, arguments.length > 1, null, true);
        },
        removeData: function (key) {
            return this.each(function () {
                dataUser.remove(this, key);
            });
        }
    });
    jQuery.extend({
        queue: function (elem, type, data) {
            var queue;
            if (elem) {
                type = (type || 'fx') + 'queue';
                queue = dataPriv.get(elem, type);
                if (data) {
                    if (!queue || Array.isArray(data)) {
                        queue = dataPriv.access(elem, type, jQuery.makeArray(data));
                    } else {
                        queue.push(data);
                    }
                }
                return queue || [];
            }
        },
        dequeue: function (elem, type) {
            type = type || 'fx';
            var queue = jQuery.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem, type), next = function () {
                    jQuery.dequeue(elem, type);
                };
            if (fn === 'inprogress') {
                fn = queue.shift();
                startLength--;
            }
            if (fn) {
                if (type === 'fx') {
                    queue.unshift('inprogress');
                }
                delete hooks.stop;
                fn.call(elem, next, hooks);
            }
            if (!startLength && hooks) {
                hooks.empty.fire();
            }
        },
        _queueHooks: function (elem, type) {
            var key = type + 'queueHooks';
            return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
                empty: jQuery.Callbacks('once memory').add(function () {
                    dataPriv.remove(elem, [
                        type + 'queue',
                        key
                    ]);
                })
            });
        }
    });
    jQuery.fn.extend({
        queue: function (type, data) {
            var setter = 2;
            if (typeof type !== 'string') {
                data = type;
                type = 'fx';
                setter--;
            }
            if (arguments.length < setter) {
                return jQuery.queue(this[0], type);
            }
            return data === undefined ? this : this.each(function () {
                var queue = jQuery.queue(this, type, data);
                jQuery._queueHooks(this, type);
                if (type === 'fx' && queue[0] !== 'inprogress') {
                    jQuery.dequeue(this, type);
                }
            });
        },
        dequeue: function (type) {
            return this.each(function () {
                jQuery.dequeue(this, type);
            });
        },
        clearQueue: function (type) {
            return this.queue(type || 'fx', []);
        },
        promise: function (type, obj) {
            var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function () {
                    if (!--count) {
                        defer.resolveWith(elements, [elements]);
                    }
                };
            if (typeof type !== 'string') {
                obj = type;
                type = undefined;
            }
            type = type || 'fx';
            while (i--) {
                tmp = dataPriv.get(elements[i], type + 'queueHooks');
                if (tmp && tmp.empty) {
                    count++;
                    tmp.empty.add(resolve);
                }
            }
            resolve();
            return defer.promise(obj);
        }
    });
    var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
    var rcssNum = new RegExp('^(?:([+-])=|)(' + pnum + ')([a-z%]*)$', 'i');
    var cssExpand = [
        'Top',
        'Right',
        'Bottom',
        'Left'
    ];
    var isHiddenWithinTree = function (elem, el) {
        elem = el || elem;
        return elem.style.display === 'none' || elem.style.display === '' && jQuery.contains(elem.ownerDocument, elem) && jQuery.css(elem, 'display') === 'none';
    };
    var swap = function (elem, options, callback, args) {
        var ret, name, old = {};
        for (name in options) {
            old[name] = elem.style[name];
            elem.style[name] = options[name];
        }
        ret = callback.apply(elem, args || []);
        for (name in options) {
            elem.style[name] = old[name];
        }
        return ret;
    };
    function adjustCSS(elem, prop, valueParts, tween) {
        var adjusted, scale = 1, maxIterations = 20, currentValue = tween ? function () {
                return tween.cur();
            } : function () {
                return jQuery.css(elem, prop, '');
            }, initial = currentValue(), unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? '' : 'px'), initialInUnit = (jQuery.cssNumber[prop] || unit !== 'px' && +initial) && rcssNum.exec(jQuery.css(elem, prop));
        if (initialInUnit && initialInUnit[3] !== unit) {
            unit = unit || initialInUnit[3];
            valueParts = valueParts || [];
            initialInUnit = +initial || 1;
            do {
                scale = scale || '.5';
                initialInUnit = initialInUnit / scale;
                jQuery.style(elem, prop, initialInUnit + unit);
            } while (scale !== (scale = currentValue() / initial) && scale !== 1 && --maxIterations);
        }
        if (valueParts) {
            initialInUnit = +initialInUnit || +initial || 0;
            adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
            if (tween) {
                tween.unit = unit;
                tween.start = initialInUnit;
                tween.end = adjusted;
            }
        }
        return adjusted;
    }
    var defaultDisplayMap = {};
    function getDefaultDisplay(elem) {
        var temp, doc = elem.ownerDocument, nodeName = elem.nodeName, display = defaultDisplayMap[nodeName];
        if (display) {
            return display;
        }
        temp = doc.body.appendChild(doc.createElement(nodeName));
        display = jQuery.css(temp, 'display');
        temp.parentNode.removeChild(temp);
        if (display === 'none') {
            display = 'block';
        }
        defaultDisplayMap[nodeName] = display;
        return display;
    }
    function showHide(elements, show) {
        var display, elem, values = [], index = 0, length = elements.length;
        for (; index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
                continue;
            }
            display = elem.style.display;
            if (show) {
                if (display === 'none') {
                    values[index] = dataPriv.get(elem, 'display') || null;
                    if (!values[index]) {
                        elem.style.display = '';
                    }
                }
                if (elem.style.display === '' && isHiddenWithinTree(elem)) {
                    values[index] = getDefaultDisplay(elem);
                }
            } else {
                if (display !== 'none') {
                    values[index] = 'none';
                    dataPriv.set(elem, 'display', display);
                }
            }
        }
        for (index = 0; index < length; index++) {
            if (values[index] != null) {
                elements[index].style.display = values[index];
            }
        }
        return elements;
    }
    jQuery.fn.extend({
        show: function () {
            return showHide(this, true);
        },
        hide: function () {
            return showHide(this);
        },
        toggle: function (state) {
            if (typeof state === 'boolean') {
                return state ? this.show() : this.hide();
            }
            return this.each(function () {
                if (isHiddenWithinTree(this)) {
                    jQuery(this).show();
                } else {
                    jQuery(this).hide();
                }
            });
        }
    });
    var rcheckableType = /^(?:checkbox|radio)$/i;
    var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]+)/i;
    var rscriptType = /^$|\/(?:java|ecma)script/i;
    var wrapMap = {
        option: [
            1,
            '<select multiple=\'multiple\'>',
            '</select>'
        ],
        thead: [
            1,
            '<table>',
            '</table>'
        ],
        col: [
            2,
            '<table><colgroup>',
            '</colgroup></table>'
        ],
        tr: [
            2,
            '<table><tbody>',
            '</tbody></table>'
        ],
        td: [
            3,
            '<table><tbody><tr>',
            '</tr></tbody></table>'
        ],
        _default: [
            0,
            '',
            ''
        ]
    };
    wrapMap.optgroup = wrapMap.option;
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;
    function getAll(context, tag) {
        var ret;
        if (typeof context.getElementsByTagName !== 'undefined') {
            ret = context.getElementsByTagName(tag || '*');
        } else if (typeof context.querySelectorAll !== 'undefined') {
            ret = context.querySelectorAll(tag || '*');
        } else {
            ret = [];
        }
        if (tag === undefined || tag && nodeName(context, tag)) {
            return jQuery.merge([context], ret);
        }
        return ret;
    }
    function setGlobalEval(elems, refElements) {
        var i = 0, l = elems.length;
        for (; i < l; i++) {
            dataPriv.set(elems[i], 'globalEval', !refElements || dataPriv.get(refElements[i], 'globalEval'));
        }
    }
    var rhtml = /<|&#?\w+;/;
    function buildFragment(elems, context, scripts, selection, ignored) {
        var elem, tmp, tag, wrap, contains, j, fragment = context.createDocumentFragment(), nodes = [], i = 0, l = elems.length;
        for (; i < l; i++) {
            elem = elems[i];
            if (elem || elem === 0) {
                if (jQuery.type(elem) === 'object') {
                    jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
                } else if (!rhtml.test(elem)) {
                    nodes.push(context.createTextNode(elem));
                } else {
                    tmp = tmp || fragment.appendChild(context.createElement('div'));
                    tag = (rtagName.exec(elem) || [
                        '',
                        ''
                    ])[1].toLowerCase();
                    wrap = wrapMap[tag] || wrapMap._default;
                    tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];
                    j = wrap[0];
                    while (j--) {
                        tmp = tmp.lastChild;
                    }
                    jQuery.merge(nodes, tmp.childNodes);
                    tmp = fragment.firstChild;
                    tmp.textContent = '';
                }
            }
        }
        fragment.textContent = '';
        i = 0;
        while (elem = nodes[i++]) {
            if (selection && jQuery.inArray(elem, selection) > -1) {
                if (ignored) {
                    ignored.push(elem);
                }
                continue;
            }
            contains = jQuery.contains(elem.ownerDocument, elem);
            tmp = getAll(fragment.appendChild(elem), 'script');
            if (contains) {
                setGlobalEval(tmp);
            }
            if (scripts) {
                j = 0;
                while (elem = tmp[j++]) {
                    if (rscriptType.test(elem.type || '')) {
                        scripts.push(elem);
                    }
                }
            }
        }
        return fragment;
    }
    (function () {
        var fragment = document.createDocumentFragment(), div = fragment.appendChild(document.createElement('div')), input = document.createElement('input');
        input.setAttribute('type', 'radio');
        input.setAttribute('checked', 'checked');
        input.setAttribute('name', 't');
        div.appendChild(input);
        support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
        div.innerHTML = '<textarea>x</textarea>';
        support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
    }());
    var documentElement = document.documentElement;
    var rkeyEvent = /^key/, rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
    function returnTrue() {
        return true;
    }
    function returnFalse() {
        return false;
    }
    function safeActiveElement() {
        try {
            return document.activeElement;
        } catch (err) {
        }
    }
    function on(elem, types, selector, data, fn, one) {
        var origFn, type;
        if (typeof types === 'object') {
            if (typeof selector !== 'string') {
                data = data || selector;
                selector = undefined;
            }
            for (type in types) {
                on(elem, type, selector, data, types[type], one);
            }
            return elem;
        }
        if (data == null && fn == null) {
            fn = selector;
            data = selector = undefined;
        } else if (fn == null) {
            if (typeof selector === 'string') {
                fn = data;
                data = undefined;
            } else {
                fn = data;
                data = selector;
                selector = undefined;
            }
        }
        if (fn === false) {
            fn = returnFalse;
        } else if (!fn) {
            return elem;
        }
        if (one === 1) {
            origFn = fn;
            fn = function (event) {
                jQuery().off(event);
                return origFn.apply(this, arguments);
            };
            fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
        }
        return elem.each(function () {
            jQuery.event.add(this, types, fn, data, selector);
        });
    }
    jQuery.event = {
        global: {},
        add: function (elem, types, handler, data, selector) {
            var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get(elem);
            if (!elemData) {
                return;
            }
            if (handler.handler) {
                handleObjIn = handler;
                handler = handleObjIn.handler;
                selector = handleObjIn.selector;
            }
            if (selector) {
                jQuery.find.matchesSelector(documentElement, selector);
            }
            if (!handler.guid) {
                handler.guid = jQuery.guid++;
            }
            if (!(events = elemData.events)) {
                events = elemData.events = {};
            }
            if (!(eventHandle = elemData.handle)) {
                eventHandle = elemData.handle = function (e) {
                    return typeof jQuery !== 'undefined' && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
                };
            }
            types = (types || '').match(rnothtmlwhite) || [''];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || '').split('.').sort();
                if (!type) {
                    continue;
                }
                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                special = jQuery.event.special[type] || {};
                handleObj = jQuery.extend({
                    type: type,
                    origType: origType,
                    data: data,
                    handler: handler,
                    guid: handler.guid,
                    selector: selector,
                    needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                    namespace: namespaces.join('.')
                }, handleObjIn);
                if (!(handlers = events[type])) {
                    handlers = events[type] = [];
                    handlers.delegateCount = 0;
                    if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                        if (elem.addEventListener) {
                            elem.addEventListener(type, eventHandle);
                        }
                    }
                }
                if (special.add) {
                    special.add.call(elem, handleObj);
                    if (!handleObj.handler.guid) {
                        handleObj.handler.guid = handler.guid;
                    }
                }
                if (selector) {
                    handlers.splice(handlers.delegateCount++, 0, handleObj);
                } else {
                    handlers.push(handleObj);
                }
                jQuery.event.global[type] = true;
            }
        },
        remove: function (elem, types, handler, selector, mappedTypes) {
            var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
            if (!elemData || !(events = elemData.events)) {
                return;
            }
            types = (types || '').match(rnothtmlwhite) || [''];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || '').split('.').sort();
                if (!type) {
                    for (type in events) {
                        jQuery.event.remove(elem, type + types[t], handler, selector, true);
                    }
                    continue;
                }
                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                handlers = events[type] || [];
                tmp = tmp[2] && new RegExp('(^|\\.)' + namespaces.join('\\.(?:.*\\.|)') + '(\\.|$)');
                origCount = j = handlers.length;
                while (j--) {
                    handleObj = handlers[j];
                    if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === '**' && handleObj.selector)) {
                        handlers.splice(j, 1);
                        if (handleObj.selector) {
                            handlers.delegateCount--;
                        }
                        if (special.remove) {
                            special.remove.call(elem, handleObj);
                        }
                    }
                }
                if (origCount && !handlers.length) {
                    if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                        jQuery.removeEvent(elem, type, elemData.handle);
                    }
                    delete events[type];
                }
            }
            if (jQuery.isEmptyObject(events)) {
                dataPriv.remove(elem, 'handle events');
            }
        },
        dispatch: function (nativeEvent) {
            var event = jQuery.event.fix(nativeEvent);
            var i, j, ret, matched, handleObj, handlerQueue, args = new Array(arguments.length), handlers = (dataPriv.get(this, 'events') || {})[event.type] || [], special = jQuery.event.special[event.type] || {};
            args[0] = event;
            for (i = 1; i < arguments.length; i++) {
                args[i] = arguments[i];
            }
            event.delegateTarget = this;
            if (special.preDispatch && special.preDispatch.call(this, event) === false) {
                return;
            }
            handlerQueue = jQuery.event.handlers.call(this, event, handlers);
            i = 0;
            while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
                event.currentTarget = matched.elem;
                j = 0;
                while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
                    if (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) {
                        event.handleObj = handleObj;
                        event.data = handleObj.data;
                        ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                        if (ret !== undefined) {
                            if ((event.result = ret) === false) {
                                event.preventDefault();
                                event.stopPropagation();
                            }
                        }
                    }
                }
            }
            if (special.postDispatch) {
                special.postDispatch.call(this, event);
            }
            return event.result;
        },
        handlers: function (event, handlers) {
            var i, handleObj, sel, matchedHandlers, matchedSelectors, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
            if (delegateCount && cur.nodeType && !(event.type === 'click' && event.button >= 1)) {
                for (; cur !== this; cur = cur.parentNode || this) {
                    if (cur.nodeType === 1 && !(event.type === 'click' && cur.disabled === true)) {
                        matchedHandlers = [];
                        matchedSelectors = {};
                        for (i = 0; i < delegateCount; i++) {
                            handleObj = handlers[i];
                            sel = handleObj.selector + ' ';
                            if (matchedSelectors[sel] === undefined) {
                                matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
                            }
                            if (matchedSelectors[sel]) {
                                matchedHandlers.push(handleObj);
                            }
                        }
                        if (matchedHandlers.length) {
                            handlerQueue.push({
                                elem: cur,
                                handlers: matchedHandlers
                            });
                        }
                    }
                }
            }
            cur = this;
            if (delegateCount < handlers.length) {
                handlerQueue.push({
                    elem: cur,
                    handlers: handlers.slice(delegateCount)
                });
            }
            return handlerQueue;
        },
        addProp: function (name, hook) {
            Object.defineProperty(jQuery.Event.prototype, name, {
                enumerable: true,
                configurable: true,
                get: jQuery.isFunction(hook) ? function () {
                    if (this.originalEvent) {
                        return hook(this.originalEvent);
                    }
                } : function () {
                    if (this.originalEvent) {
                        return this.originalEvent[name];
                    }
                },
                set: function (value) {
                    Object.defineProperty(this, name, {
                        enumerable: true,
                        configurable: true,
                        writable: true,
                        value: value
                    });
                }
            });
        },
        fix: function (originalEvent) {
            return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);
        },
        special: {
            load: { noBubble: true },
            focus: {
                trigger: function () {
                    if (this !== safeActiveElement() && this.focus) {
                        this.focus();
                        return false;
                    }
                },
                delegateType: 'focusin'
            },
            blur: {
                trigger: function () {
                    if (this === safeActiveElement() && this.blur) {
                        this.blur();
                        return false;
                    }
                },
                delegateType: 'focusout'
            },
            click: {
                trigger: function () {
                    if (this.type === 'checkbox' && this.click && nodeName(this, 'input')) {
                        this.click();
                        return false;
                    }
                },
                _default: function (event) {
                    return nodeName(event.target, 'a');
                }
            },
            beforeunload: {
                postDispatch: function (event) {
                    if (event.result !== undefined && event.originalEvent) {
                        event.originalEvent.returnValue = event.result;
                    }
                }
            }
        }
    };
    jQuery.removeEvent = function (elem, type, handle) {
        if (elem.removeEventListener) {
            elem.removeEventListener(type, handle);
        }
    };
    jQuery.Event = function (src, props) {
        if (!(this instanceof jQuery.Event)) {
            return new jQuery.Event(src, props);
        }
        if (src && src.type) {
            this.originalEvent = src;
            this.type = src.type;
            this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && src.returnValue === false ? returnTrue : returnFalse;
            this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
            this.currentTarget = src.currentTarget;
            this.relatedTarget = src.relatedTarget;
        } else {
            this.type = src;
        }
        if (props) {
            jQuery.extend(this, props);
        }
        this.timeStamp = src && src.timeStamp || jQuery.now();
        this[jQuery.expando] = true;
    };
    jQuery.Event.prototype = {
        constructor: jQuery.Event,
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,
        isSimulated: false,
        preventDefault: function () {
            var e = this.originalEvent;
            this.isDefaultPrevented = returnTrue;
            if (e && !this.isSimulated) {
                e.preventDefault();
            }
        },
        stopPropagation: function () {
            var e = this.originalEvent;
            this.isPropagationStopped = returnTrue;
            if (e && !this.isSimulated) {
                e.stopPropagation();
            }
        },
        stopImmediatePropagation: function () {
            var e = this.originalEvent;
            this.isImmediatePropagationStopped = returnTrue;
            if (e && !this.isSimulated) {
                e.stopImmediatePropagation();
            }
            this.stopPropagation();
        }
    };
    jQuery.each({
        altKey: true,
        bubbles: true,
        cancelable: true,
        changedTouches: true,
        ctrlKey: true,
        detail: true,
        eventPhase: true,
        metaKey: true,
        pageX: true,
        pageY: true,
        shiftKey: true,
        view: true,
        'char': true,
        charCode: true,
        key: true,
        keyCode: true,
        button: true,
        buttons: true,
        clientX: true,
        clientY: true,
        offsetX: true,
        offsetY: true,
        pointerId: true,
        pointerType: true,
        screenX: true,
        screenY: true,
        targetTouches: true,
        toElement: true,
        touches: true,
        which: function (event) {
            var button = event.button;
            if (event.which == null && rkeyEvent.test(event.type)) {
                return event.charCode != null ? event.charCode : event.keyCode;
            }
            if (!event.which && button !== undefined && rmouseEvent.test(event.type)) {
                if (button & 1) {
                    return 1;
                }
                if (button & 2) {
                    return 3;
                }
                if (button & 4) {
                    return 2;
                }
                return 0;
            }
            return event.which;
        }
    }, jQuery.event.addProp);
    jQuery.each({
        mouseenter: 'mouseover',
        mouseleave: 'mouseout',
        pointerenter: 'pointerover',
        pointerleave: 'pointerout'
    }, function (orig, fix) {
        jQuery.event.special[orig] = {
            delegateType: fix,
            bindType: fix,
            handle: function (event) {
                var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
                if (!related || related !== target && !jQuery.contains(target, related)) {
                    event.type = handleObj.origType;
                    ret = handleObj.handler.apply(this, arguments);
                    event.type = fix;
                }
                return ret;
            }
        };
    });
    jQuery.fn.extend({
        on: function (types, selector, data, fn) {
            return on(this, types, selector, data, fn);
        },
        one: function (types, selector, data, fn) {
            return on(this, types, selector, data, fn, 1);
        },
        off: function (types, selector, fn) {
            var handleObj, type;
            if (types && types.preventDefault && types.handleObj) {
                handleObj = types.handleObj;
                jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + '.' + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
                return this;
            }
            if (typeof types === 'object') {
                for (type in types) {
                    this.off(type, selector, types[type]);
                }
                return this;
            }
            if (selector === false || typeof selector === 'function') {
                fn = selector;
                selector = undefined;
            }
            if (fn === false) {
                fn = returnFalse;
            }
            return this.each(function () {
                jQuery.event.remove(this, types, fn, selector);
            });
        }
    });
    var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi, rnoInnerhtml = /<script|<style|<link/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rscriptTypeMasked = /^true\/(.*)/, rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
    function manipulationTarget(elem, content) {
        if (nodeName(elem, 'table') && nodeName(content.nodeType !== 11 ? content : content.firstChild, 'tr')) {
            return jQuery('>tbody', elem)[0] || elem;
        }
        return elem;
    }
    function disableScript(elem) {
        elem.type = (elem.getAttribute('type') !== null) + '/' + elem.type;
        return elem;
    }
    function restoreScript(elem) {
        var match = rscriptTypeMasked.exec(elem.type);
        if (match) {
            elem.type = match[1];
        } else {
            elem.removeAttribute('type');
        }
        return elem;
    }
    function cloneCopyEvent(src, dest) {
        var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
        if (dest.nodeType !== 1) {
            return;
        }
        if (dataPriv.hasData(src)) {
            pdataOld = dataPriv.access(src);
            pdataCur = dataPriv.set(dest, pdataOld);
            events = pdataOld.events;
            if (events) {
                delete pdataCur.handle;
                pdataCur.events = {};
                for (type in events) {
                    for (i = 0, l = events[type].length; i < l; i++) {
                        jQuery.event.add(dest, type, events[type][i]);
                    }
                }
            }
        }
        if (dataUser.hasData(src)) {
            udataOld = dataUser.access(src);
            udataCur = jQuery.extend({}, udataOld);
            dataUser.set(dest, udataCur);
        }
    }
    function fixInput(src, dest) {
        var nodeName = dest.nodeName.toLowerCase();
        if (nodeName === 'input' && rcheckableType.test(src.type)) {
            dest.checked = src.checked;
        } else if (nodeName === 'input' || nodeName === 'textarea') {
            dest.defaultValue = src.defaultValue;
        }
    }
    function domManip(collection, args, callback, ignored) {
        args = concat.apply([], args);
        var fragment, first, scripts, hasScripts, node, doc, i = 0, l = collection.length, iNoClone = l - 1, value = args[0], isFunction = jQuery.isFunction(value);
        if (isFunction || l > 1 && typeof value === 'string' && !support.checkClone && rchecked.test(value)) {
            return collection.each(function (index) {
                var self = collection.eq(index);
                if (isFunction) {
                    args[0] = value.call(this, index, self.html());
                }
                domManip(self, args, callback, ignored);
            });
        }
        if (l) {
            fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
            first = fragment.firstChild;
            if (fragment.childNodes.length === 1) {
                fragment = first;
            }
            if (first || ignored) {
                scripts = jQuery.map(getAll(fragment, 'script'), disableScript);
                hasScripts = scripts.length;
                for (; i < l; i++) {
                    node = fragment;
                    if (i !== iNoClone) {
                        node = jQuery.clone(node, true, true);
                        if (hasScripts) {
                            jQuery.merge(scripts, getAll(node, 'script'));
                        }
                    }
                    callback.call(collection[i], node, i);
                }
                if (hasScripts) {
                    doc = scripts[scripts.length - 1].ownerDocument;
                    jQuery.map(scripts, restoreScript);
                    for (i = 0; i < hasScripts; i++) {
                        node = scripts[i];
                        if (rscriptType.test(node.type || '') && !dataPriv.access(node, 'globalEval') && jQuery.contains(doc, node)) {
                            if (node.src) {
                                if (jQuery._evalUrl) {
                                    jQuery._evalUrl(node.src);
                                }
                            } else {
                                DOMEval(node.textContent.replace(rcleanScript, ''), doc);
                            }
                        }
                    }
                }
            }
        }
        return collection;
    }
    function remove(elem, selector, keepData) {
        var node, nodes = selector ? jQuery.filter(selector, elem) : elem, i = 0;
        for (; (node = nodes[i]) != null; i++) {
            if (!keepData && node.nodeType === 1) {
                jQuery.cleanData(getAll(node));
            }
            if (node.parentNode) {
                if (keepData && jQuery.contains(node.ownerDocument, node)) {
                    setGlobalEval(getAll(node, 'script'));
                }
                node.parentNode.removeChild(node);
            }
        }
        return elem;
    }
    jQuery.extend({
        htmlPrefilter: function (html) {
            return html.replace(rxhtmlTag, '<$1></$2>');
        },
        clone: function (elem, dataAndEvents, deepDataAndEvents) {
            var i, l, srcElements, destElements, clone = elem.cloneNode(true), inPage = jQuery.contains(elem.ownerDocument, elem);
            if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
                destElements = getAll(clone);
                srcElements = getAll(elem);
                for (i = 0, l = srcElements.length; i < l; i++) {
                    fixInput(srcElements[i], destElements[i]);
                }
            }
            if (dataAndEvents) {
                if (deepDataAndEvents) {
                    srcElements = srcElements || getAll(elem);
                    destElements = destElements || getAll(clone);
                    for (i = 0, l = srcElements.length; i < l; i++) {
                        cloneCopyEvent(srcElements[i], destElements[i]);
                    }
                } else {
                    cloneCopyEvent(elem, clone);
                }
            }
            destElements = getAll(clone, 'script');
            if (destElements.length > 0) {
                setGlobalEval(destElements, !inPage && getAll(elem, 'script'));
            }
            return clone;
        },
        cleanData: function (elems) {
            var data, elem, type, special = jQuery.event.special, i = 0;
            for (; (elem = elems[i]) !== undefined; i++) {
                if (acceptData(elem)) {
                    if (data = elem[dataPriv.expando]) {
                        if (data.events) {
                            for (type in data.events) {
                                if (special[type]) {
                                    jQuery.event.remove(elem, type);
                                } else {
                                    jQuery.removeEvent(elem, type, data.handle);
                                }
                            }
                        }
                        elem[dataPriv.expando] = undefined;
                    }
                    if (elem[dataUser.expando]) {
                        elem[dataUser.expando] = undefined;
                    }
                }
            }
        }
    });
    jQuery.fn.extend({
        detach: function (selector) {
            return remove(this, selector, true);
        },
        remove: function (selector) {
            return remove(this, selector);
        },
        text: function (value) {
            return access(this, function (value) {
                return value === undefined ? jQuery.text(this) : this.empty().each(function () {
                    if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                        this.textContent = value;
                    }
                });
            }, null, value, arguments.length);
        },
        append: function () {
            return domManip(this, arguments, function (elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.appendChild(elem);
                }
            });
        },
        prepend: function () {
            return domManip(this, arguments, function (elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.insertBefore(elem, target.firstChild);
                }
            });
        },
        before: function () {
            return domManip(this, arguments, function (elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this);
                }
            });
        },
        after: function () {
            return domManip(this, arguments, function (elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this.nextSibling);
                }
            });
        },
        empty: function () {
            var elem, i = 0;
            for (; (elem = this[i]) != null; i++) {
                if (elem.nodeType === 1) {
                    jQuery.cleanData(getAll(elem, false));
                    elem.textContent = '';
                }
            }
            return this;
        },
        clone: function (dataAndEvents, deepDataAndEvents) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
            return this.map(function () {
                return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
            });
        },
        html: function (value) {
            return access(this, function (value) {
                var elem = this[0] || {}, i = 0, l = this.length;
                if (value === undefined && elem.nodeType === 1) {
                    return elem.innerHTML;
                }
                if (typeof value === 'string' && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || [
                        '',
                        ''
                    ])[1].toLowerCase()]) {
                    value = jQuery.htmlPrefilter(value);
                    try {
                        for (; i < l; i++) {
                            elem = this[i] || {};
                            if (elem.nodeType === 1) {
                                jQuery.cleanData(getAll(elem, false));
                                elem.innerHTML = value;
                            }
                        }
                        elem = 0;
                    } catch (e) {
                    }
                }
                if (elem) {
                    this.empty().append(value);
                }
            }, null, value, arguments.length);
        },
        replaceWith: function () {
            var ignored = [];
            return domManip(this, arguments, function (elem) {
                var parent = this.parentNode;
                if (jQuery.inArray(this, ignored) < 0) {
                    jQuery.cleanData(getAll(this));
                    if (parent) {
                        parent.replaceChild(elem, this);
                    }
                }
            }, ignored);
        }
    });
    jQuery.each({
        appendTo: 'append',
        prependTo: 'prepend',
        insertBefore: 'before',
        insertAfter: 'after',
        replaceAll: 'replaceWith'
    }, function (name, original) {
        jQuery.fn[name] = function (selector) {
            var elems, ret = [], insert = jQuery(selector), last = insert.length - 1, i = 0;
            for (; i <= last; i++) {
                elems = i === last ? this : this.clone(true);
                jQuery(insert[i])[original](elems);
                push.apply(ret, elems.get());
            }
            return this.pushStack(ret);
        };
    });
    var rmargin = /^margin/;
    var rnumnonpx = new RegExp('^(' + pnum + ')(?!px)[a-z%]+$', 'i');
    var getStyles = function (elem) {
        var view = elem.ownerDocument.defaultView;
        if (!view || !view.opener) {
            view = window;
        }
        return view.getComputedStyle(elem);
    };
    (function () {
        function computeStyleTests() {
            if (!div) {
                return;
            }
            div.style.cssText = 'box-sizing:border-box;' + 'position:relative;display:block;' + 'margin:auto;border:1px;padding:1px;' + 'top:1%;width:50%';
            div.innerHTML = '';
            documentElement.appendChild(container);
            var divStyle = window.getComputedStyle(div);
            pixelPositionVal = divStyle.top !== '1%';
            reliableMarginLeftVal = divStyle.marginLeft === '2px';
            boxSizingReliableVal = divStyle.width === '4px';
            div.style.marginRight = '50%';
            pixelMarginRightVal = divStyle.marginRight === '4px';
            documentElement.removeChild(container);
            div = null;
        }
        var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal, container = document.createElement('div'), div = document.createElement('div');
        if (!div.style) {
            return;
        }
        div.style.backgroundClip = 'content-box';
        div.cloneNode(true).style.backgroundClip = '';
        support.clearCloneStyle = div.style.backgroundClip === 'content-box';
        container.style.cssText = 'border:0;width:8px;height:0;top:0;left:-9999px;' + 'padding:0;margin-top:1px;position:absolute';
        container.appendChild(div);
        jQuery.extend(support, {
            pixelPosition: function () {
                computeStyleTests();
                return pixelPositionVal;
            },
            boxSizingReliable: function () {
                computeStyleTests();
                return boxSizingReliableVal;
            },
            pixelMarginRight: function () {
                computeStyleTests();
                return pixelMarginRightVal;
            },
            reliableMarginLeft: function () {
                computeStyleTests();
                return reliableMarginLeftVal;
            }
        });
    }());
    function curCSS(elem, name, computed) {
        var width, minWidth, maxWidth, ret, style = elem.style;
        computed = computed || getStyles(elem);
        if (computed) {
            ret = computed.getPropertyValue(name) || computed[name];
            if (ret === '' && !jQuery.contains(elem.ownerDocument, elem)) {
                ret = jQuery.style(elem, name);
            }
            if (!support.pixelMarginRight() && rnumnonpx.test(ret) && rmargin.test(name)) {
                width = style.width;
                minWidth = style.minWidth;
                maxWidth = style.maxWidth;
                style.minWidth = style.maxWidth = style.width = ret;
                ret = computed.width;
                style.width = width;
                style.minWidth = minWidth;
                style.maxWidth = maxWidth;
            }
        }
        return ret !== undefined ? ret + '' : ret;
    }
    function addGetHookIf(conditionFn, hookFn) {
        return {
            get: function () {
                if (conditionFn()) {
                    delete this.get;
                    return;
                }
                return (this.get = hookFn).apply(this, arguments);
            }
        };
    }
    var rdisplayswap = /^(none|table(?!-c[ea]).+)/, rcustomProp = /^--/, cssShow = {
            position: 'absolute',
            visibility: 'hidden',
            display: 'block'
        }, cssNormalTransform = {
            letterSpacing: '0',
            fontWeight: '400'
        }, cssPrefixes = [
            'Webkit',
            'Moz',
            'ms'
        ], emptyStyle = document.createElement('div').style;
    function vendorPropName(name) {
        if (name in emptyStyle) {
            return name;
        }
        var capName = name[0].toUpperCase() + name.slice(1), i = cssPrefixes.length;
        while (i--) {
            name = cssPrefixes[i] + capName;
            if (name in emptyStyle) {
                return name;
            }
        }
    }
    function finalPropName(name) {
        var ret = jQuery.cssProps[name];
        if (!ret) {
            ret = jQuery.cssProps[name] = vendorPropName(name) || name;
        }
        return ret;
    }
    function setPositiveNumber(elem, value, subtract) {
        var matches = rcssNum.exec(value);
        return matches ? Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || 'px') : value;
    }
    function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
        var i, val = 0;
        if (extra === (isBorderBox ? 'border' : 'content')) {
            i = 4;
        } else {
            i = name === 'width' ? 1 : 0;
        }
        for (; i < 4; i += 2) {
            if (extra === 'margin') {
                val += jQuery.css(elem, extra + cssExpand[i], true, styles);
            }
            if (isBorderBox) {
                if (extra === 'content') {
                    val -= jQuery.css(elem, 'padding' + cssExpand[i], true, styles);
                }
                if (extra !== 'margin') {
                    val -= jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles);
                }
            } else {
                val += jQuery.css(elem, 'padding' + cssExpand[i], true, styles);
                if (extra !== 'padding') {
                    val += jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles);
                }
            }
        }
        return val;
    }
    function getWidthOrHeight(elem, name, extra) {
        var valueIsBorderBox, styles = getStyles(elem), val = curCSS(elem, name, styles), isBorderBox = jQuery.css(elem, 'boxSizing', false, styles) === 'border-box';
        if (rnumnonpx.test(val)) {
            return val;
        }
        valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]);
        if (val === 'auto') {
            val = elem['offset' + name[0].toUpperCase() + name.slice(1)];
        }
        val = parseFloat(val) || 0;
        return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? 'border' : 'content'), valueIsBorderBox, styles) + 'px';
    }
    jQuery.extend({
        cssHooks: {
            opacity: {
                get: function (elem, computed) {
                    if (computed) {
                        var ret = curCSS(elem, 'opacity');
                        return ret === '' ? '1' : ret;
                    }
                }
            }
        },
        cssNumber: {
            'animationIterationCount': true,
            'columnCount': true,
            'fillOpacity': true,
            'flexGrow': true,
            'flexShrink': true,
            'fontWeight': true,
            'lineHeight': true,
            'opacity': true,
            'order': true,
            'orphans': true,
            'widows': true,
            'zIndex': true,
            'zoom': true
        },
        cssProps: { 'float': 'cssFloat' },
        style: function (elem, name, value, extra) {
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
                return;
            }
            var ret, type, hooks, origName = jQuery.camelCase(name), isCustomProp = rcustomProp.test(name), style = elem.style;
            if (!isCustomProp) {
                name = finalPropName(origName);
            }
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            if (value !== undefined) {
                type = typeof value;
                if (type === 'string' && (ret = rcssNum.exec(value)) && ret[1]) {
                    value = adjustCSS(elem, name, ret);
                    type = 'number';
                }
                if (value == null || value !== value) {
                    return;
                }
                if (type === 'number') {
                    value += ret && ret[3] || (jQuery.cssNumber[origName] ? '' : 'px');
                }
                if (!support.clearCloneStyle && value === '' && name.indexOf('background') === 0) {
                    style[name] = 'inherit';
                }
                if (!hooks || !('set' in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
                    if (isCustomProp) {
                        style.setProperty(name, value);
                    } else {
                        style[name] = value;
                    }
                }
            } else {
                if (hooks && 'get' in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
                    return ret;
                }
                return style[name];
            }
        },
        css: function (elem, name, extra, styles) {
            var val, num, hooks, origName = jQuery.camelCase(name), isCustomProp = rcustomProp.test(name);
            if (!isCustomProp) {
                name = finalPropName(origName);
            }
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            if (hooks && 'get' in hooks) {
                val = hooks.get(elem, true, extra);
            }
            if (val === undefined) {
                val = curCSS(elem, name, styles);
            }
            if (val === 'normal' && name in cssNormalTransform) {
                val = cssNormalTransform[name];
            }
            if (extra === '' || extra) {
                num = parseFloat(val);
                return extra === true || isFinite(num) ? num || 0 : val;
            }
            return val;
        }
    });
    jQuery.each([
        'height',
        'width'
    ], function (i, name) {
        jQuery.cssHooks[name] = {
            get: function (elem, computed, extra) {
                if (computed) {
                    return rdisplayswap.test(jQuery.css(elem, 'display')) && (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function () {
                        return getWidthOrHeight(elem, name, extra);
                    }) : getWidthOrHeight(elem, name, extra);
                }
            },
            set: function (elem, value, extra) {
                var matches, styles = extra && getStyles(elem), subtract = extra && augmentWidthOrHeight(elem, name, extra, jQuery.css(elem, 'boxSizing', false, styles) === 'border-box', styles);
                if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || 'px') !== 'px') {
                    elem.style[name] = value;
                    value = jQuery.css(elem, name);
                }
                return setPositiveNumber(elem, value, subtract);
            }
        };
    });
    jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function (elem, computed) {
        if (computed) {
            return (parseFloat(curCSS(elem, 'marginLeft')) || elem.getBoundingClientRect().left - swap(elem, { marginLeft: 0 }, function () {
                return elem.getBoundingClientRect().left;
            })) + 'px';
        }
    });
    jQuery.each({
        margin: '',
        padding: '',
        border: 'Width'
    }, function (prefix, suffix) {
        jQuery.cssHooks[prefix + suffix] = {
            expand: function (value) {
                var i = 0, expanded = {}, parts = typeof value === 'string' ? value.split(' ') : [value];
                for (; i < 4; i++) {
                    expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
                }
                return expanded;
            }
        };
        if (!rmargin.test(prefix)) {
            jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
        }
    });
    jQuery.fn.extend({
        css: function (name, value) {
            return access(this, function (elem, name, value) {
                var styles, len, map = {}, i = 0;
                if (Array.isArray(name)) {
                    styles = getStyles(elem);
                    len = name.length;
                    for (; i < len; i++) {
                        map[name[i]] = jQuery.css(elem, name[i], false, styles);
                    }
                    return map;
                }
                return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
            }, name, value, arguments.length > 1);
        }
    });
    function Tween(elem, options, prop, end, easing) {
        return new Tween.prototype.init(elem, options, prop, end, easing);
    }
    jQuery.Tween = Tween;
    Tween.prototype = {
        constructor: Tween,
        init: function (elem, options, prop, end, easing, unit) {
            this.elem = elem;
            this.prop = prop;
            this.easing = easing || jQuery.easing._default;
            this.options = options;
            this.start = this.now = this.cur();
            this.end = end;
            this.unit = unit || (jQuery.cssNumber[prop] ? '' : 'px');
        },
        cur: function () {
            var hooks = Tween.propHooks[this.prop];
            return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
        },
        run: function (percent) {
            var eased, hooks = Tween.propHooks[this.prop];
            if (this.options.duration) {
                this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
            } else {
                this.pos = eased = percent;
            }
            this.now = (this.end - this.start) * eased + this.start;
            if (this.options.step) {
                this.options.step.call(this.elem, this.now, this);
            }
            if (hooks && hooks.set) {
                hooks.set(this);
            } else {
                Tween.propHooks._default.set(this);
            }
            return this;
        }
    };
    Tween.prototype.init.prototype = Tween.prototype;
    Tween.propHooks = {
        _default: {
            get: function (tween) {
                var result;
                if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
                    return tween.elem[tween.prop];
                }
                result = jQuery.css(tween.elem, tween.prop, '');
                return !result || result === 'auto' ? 0 : result;
            },
            set: function (tween) {
                if (jQuery.fx.step[tween.prop]) {
                    jQuery.fx.step[tween.prop](tween);
                } else if (tween.elem.nodeType === 1 && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
                    jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
                } else {
                    tween.elem[tween.prop] = tween.now;
                }
            }
        }
    };
    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function (tween) {
            if (tween.elem.nodeType && tween.elem.parentNode) {
                tween.elem[tween.prop] = tween.now;
            }
        }
    };
    jQuery.easing = {
        linear: function (p) {
            return p;
        },
        swing: function (p) {
            return 0.5 - Math.cos(p * Math.PI) / 2;
        },
        _default: 'swing'
    };
    jQuery.fx = Tween.prototype.init;
    jQuery.fx.step = {};
    var fxNow, inProgress, rfxtypes = /^(?:toggle|show|hide)$/, rrun = /queueHooks$/;
    function schedule() {
        if (inProgress) {
            if (document.hidden === false && window.requestAnimationFrame) {
                window.requestAnimationFrame(schedule);
            } else {
                window.setTimeout(schedule, jQuery.fx.interval);
            }
            jQuery.fx.tick();
        }
    }
    function createFxNow() {
        window.setTimeout(function () {
            fxNow = undefined;
        });
        return fxNow = jQuery.now();
    }
    function genFx(type, includeWidth) {
        var which, i = 0, attrs = { height: type };
        includeWidth = includeWidth ? 1 : 0;
        for (; i < 4; i += 2 - includeWidth) {
            which = cssExpand[i];
            attrs['margin' + which] = attrs['padding' + which] = type;
        }
        if (includeWidth) {
            attrs.opacity = attrs.width = type;
        }
        return attrs;
    }
    function createTween(value, prop, animation) {
        var tween, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners['*']), index = 0, length = collection.length;
        for (; index < length; index++) {
            if (tween = collection[index].call(animation, prop, value)) {
                return tween;
            }
        }
    }
    function defaultPrefilter(elem, props, opts) {
        var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display, isBox = 'width' in props || 'height' in props, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHiddenWithinTree(elem), dataShow = dataPriv.get(elem, 'fxshow');
        if (!opts.queue) {
            hooks = jQuery._queueHooks(elem, 'fx');
            if (hooks.unqueued == null) {
                hooks.unqueued = 0;
                oldfire = hooks.empty.fire;
                hooks.empty.fire = function () {
                    if (!hooks.unqueued) {
                        oldfire();
                    }
                };
            }
            hooks.unqueued++;
            anim.always(function () {
                anim.always(function () {
                    hooks.unqueued--;
                    if (!jQuery.queue(elem, 'fx').length) {
                        hooks.empty.fire();
                    }
                });
            });
        }
        for (prop in props) {
            value = props[prop];
            if (rfxtypes.test(value)) {
                delete props[prop];
                toggle = toggle || value === 'toggle';
                if (value === (hidden ? 'hide' : 'show')) {
                    if (value === 'show' && dataShow && dataShow[prop] !== undefined) {
                        hidden = true;
                    } else {
                        continue;
                    }
                }
                orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
            }
        }
        propTween = !jQuery.isEmptyObject(props);
        if (!propTween && jQuery.isEmptyObject(orig)) {
            return;
        }
        if (isBox && elem.nodeType === 1) {
            opts.overflow = [
                style.overflow,
                style.overflowX,
                style.overflowY
            ];
            restoreDisplay = dataShow && dataShow.display;
            if (restoreDisplay == null) {
                restoreDisplay = dataPriv.get(elem, 'display');
            }
            display = jQuery.css(elem, 'display');
            if (display === 'none') {
                if (restoreDisplay) {
                    display = restoreDisplay;
                } else {
                    showHide([elem], true);
                    restoreDisplay = elem.style.display || restoreDisplay;
                    display = jQuery.css(elem, 'display');
                    showHide([elem]);
                }
            }
            if (display === 'inline' || display === 'inline-block' && restoreDisplay != null) {
                if (jQuery.css(elem, 'float') === 'none') {
                    if (!propTween) {
                        anim.done(function () {
                            style.display = restoreDisplay;
                        });
                        if (restoreDisplay == null) {
                            display = style.display;
                            restoreDisplay = display === 'none' ? '' : display;
                        }
                    }
                    style.display = 'inline-block';
                }
            }
        }
        if (opts.overflow) {
            style.overflow = 'hidden';
            anim.always(function () {
                style.overflow = opts.overflow[0];
                style.overflowX = opts.overflow[1];
                style.overflowY = opts.overflow[2];
            });
        }
        propTween = false;
        for (prop in orig) {
            if (!propTween) {
                if (dataShow) {
                    if ('hidden' in dataShow) {
                        hidden = dataShow.hidden;
                    }
                } else {
                    dataShow = dataPriv.access(elem, 'fxshow', { display: restoreDisplay });
                }
                if (toggle) {
                    dataShow.hidden = !hidden;
                }
                if (hidden) {
                    showHide([elem], true);
                }
                anim.done(function () {
                    if (!hidden) {
                        showHide([elem]);
                    }
                    dataPriv.remove(elem, 'fxshow');
                    for (prop in orig) {
                        jQuery.style(elem, prop, orig[prop]);
                    }
                });
            }
            propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
            if (!(prop in dataShow)) {
                dataShow[prop] = propTween.start;
                if (hidden) {
                    propTween.end = propTween.start;
                    propTween.start = 0;
                }
            }
        }
    }
    function propFilter(props, specialEasing) {
        var index, name, easing, value, hooks;
        for (index in props) {
            name = jQuery.camelCase(index);
            easing = specialEasing[name];
            value = props[index];
            if (Array.isArray(value)) {
                easing = value[1];
                value = props[index] = value[0];
            }
            if (index !== name) {
                props[name] = value;
                delete props[index];
            }
            hooks = jQuery.cssHooks[name];
            if (hooks && 'expand' in hooks) {
                value = hooks.expand(value);
                delete props[name];
                for (index in value) {
                    if (!(index in props)) {
                        props[index] = value[index];
                        specialEasing[index] = easing;
                    }
                }
            } else {
                specialEasing[name] = easing;
            }
        }
    }
    function Animation(elem, properties, options) {
        var result, stopped, index = 0, length = Animation.prefilters.length, deferred = jQuery.Deferred().always(function () {
                delete tick.elem;
            }), tick = function () {
                if (stopped) {
                    return false;
                }
                var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0, length = animation.tweens.length;
                for (; index < length; index++) {
                    animation.tweens[index].run(percent);
                }
                deferred.notifyWith(elem, [
                    animation,
                    percent,
                    remaining
                ]);
                if (percent < 1 && length) {
                    return remaining;
                }
                if (!length) {
                    deferred.notifyWith(elem, [
                        animation,
                        1,
                        0
                    ]);
                }
                deferred.resolveWith(elem, [animation]);
                return false;
            }, animation = deferred.promise({
                elem: elem,
                props: jQuery.extend({}, properties),
                opts: jQuery.extend(true, {
                    specialEasing: {},
                    easing: jQuery.easing._default
                }, options),
                originalProperties: properties,
                originalOptions: options,
                startTime: fxNow || createFxNow(),
                duration: options.duration,
                tweens: [],
                createTween: function (prop, end) {
                    var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
                    animation.tweens.push(tween);
                    return tween;
                },
                stop: function (gotoEnd) {
                    var index = 0, length = gotoEnd ? animation.tweens.length : 0;
                    if (stopped) {
                        return this;
                    }
                    stopped = true;
                    for (; index < length; index++) {
                        animation.tweens[index].run(1);
                    }
                    if (gotoEnd) {
                        deferred.notifyWith(elem, [
                            animation,
                            1,
                            0
                        ]);
                        deferred.resolveWith(elem, [
                            animation,
                            gotoEnd
                        ]);
                    } else {
                        deferred.rejectWith(elem, [
                            animation,
                            gotoEnd
                        ]);
                    }
                    return this;
                }
            }), props = animation.props;
        propFilter(props, animation.opts.specialEasing);
        for (; index < length; index++) {
            result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
            if (result) {
                if (jQuery.isFunction(result.stop)) {
                    jQuery._queueHooks(animation.elem, animation.opts.queue).stop = jQuery.proxy(result.stop, result);
                }
                return result;
            }
        }
        jQuery.map(props, createTween, animation);
        if (jQuery.isFunction(animation.opts.start)) {
            animation.opts.start.call(elem, animation);
        }
        animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
        jQuery.fx.timer(jQuery.extend(tick, {
            elem: elem,
            anim: animation,
            queue: animation.opts.queue
        }));
        return animation;
    }
    jQuery.Animation = jQuery.extend(Animation, {
        tweeners: {
            '*': [function (prop, value) {
                    var tween = this.createTween(prop, value);
                    adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
                    return tween;
                }]
        },
        tweener: function (props, callback) {
            if (jQuery.isFunction(props)) {
                callback = props;
                props = ['*'];
            } else {
                props = props.match(rnothtmlwhite);
            }
            var prop, index = 0, length = props.length;
            for (; index < length; index++) {
                prop = props[index];
                Animation.tweeners[prop] = Animation.tweeners[prop] || [];
                Animation.tweeners[prop].unshift(callback);
            }
        },
        prefilters: [defaultPrefilter],
        prefilter: function (callback, prepend) {
            if (prepend) {
                Animation.prefilters.unshift(callback);
            } else {
                Animation.prefilters.push(callback);
            }
        }
    });
    jQuery.speed = function (speed, easing, fn) {
        var opt = speed && typeof speed === 'object' ? jQuery.extend({}, speed) : {
            complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
            duration: speed,
            easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
        };
        if (jQuery.fx.off) {
            opt.duration = 0;
        } else {
            if (typeof opt.duration !== 'number') {
                if (opt.duration in jQuery.fx.speeds) {
                    opt.duration = jQuery.fx.speeds[opt.duration];
                } else {
                    opt.duration = jQuery.fx.speeds._default;
                }
            }
        }
        if (opt.queue == null || opt.queue === true) {
            opt.queue = 'fx';
        }
        opt.old = opt.complete;
        opt.complete = function () {
            if (jQuery.isFunction(opt.old)) {
                opt.old.call(this);
            }
            if (opt.queue) {
                jQuery.dequeue(this, opt.queue);
            }
        };
        return opt;
    };
    jQuery.fn.extend({
        fadeTo: function (speed, to, easing, callback) {
            return this.filter(isHiddenWithinTree).css('opacity', 0).show().end().animate({ opacity: to }, speed, easing, callback);
        },
        animate: function (prop, speed, easing, callback) {
            var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function () {
                    var anim = Animation(this, jQuery.extend({}, prop), optall);
                    if (empty || dataPriv.get(this, 'finish')) {
                        anim.stop(true);
                    }
                };
            doAnimation.finish = doAnimation;
            return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
        },
        stop: function (type, clearQueue, gotoEnd) {
            var stopQueue = function (hooks) {
                var stop = hooks.stop;
                delete hooks.stop;
                stop(gotoEnd);
            };
            if (typeof type !== 'string') {
                gotoEnd = clearQueue;
                clearQueue = type;
                type = undefined;
            }
            if (clearQueue && type !== false) {
                this.queue(type || 'fx', []);
            }
            return this.each(function () {
                var dequeue = true, index = type != null && type + 'queueHooks', timers = jQuery.timers, data = dataPriv.get(this);
                if (index) {
                    if (data[index] && data[index].stop) {
                        stopQueue(data[index]);
                    }
                } else {
                    for (index in data) {
                        if (data[index] && data[index].stop && rrun.test(index)) {
                            stopQueue(data[index]);
                        }
                    }
                }
                for (index = timers.length; index--;) {
                    if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                        timers[index].anim.stop(gotoEnd);
                        dequeue = false;
                        timers.splice(index, 1);
                    }
                }
                if (dequeue || !gotoEnd) {
                    jQuery.dequeue(this, type);
                }
            });
        },
        finish: function (type) {
            if (type !== false) {
                type = type || 'fx';
            }
            return this.each(function () {
                var index, data = dataPriv.get(this), queue = data[type + 'queue'], hooks = data[type + 'queueHooks'], timers = jQuery.timers, length = queue ? queue.length : 0;
                data.finish = true;
                jQuery.queue(this, type, []);
                if (hooks && hooks.stop) {
                    hooks.stop.call(this, true);
                }
                for (index = timers.length; index--;) {
                    if (timers[index].elem === this && timers[index].queue === type) {
                        timers[index].anim.stop(true);
                        timers.splice(index, 1);
                    }
                }
                for (index = 0; index < length; index++) {
                    if (queue[index] && queue[index].finish) {
                        queue[index].finish.call(this);
                    }
                }
                delete data.finish;
            });
        }
    });
    jQuery.each([
        'toggle',
        'show',
        'hide'
    ], function (i, name) {
        var cssFn = jQuery.fn[name];
        jQuery.fn[name] = function (speed, easing, callback) {
            return speed == null || typeof speed === 'boolean' ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
        };
    });
    jQuery.each({
        slideDown: genFx('show'),
        slideUp: genFx('hide'),
        slideToggle: genFx('toggle'),
        fadeIn: { opacity: 'show' },
        fadeOut: { opacity: 'hide' },
        fadeToggle: { opacity: 'toggle' }
    }, function (name, props) {
        jQuery.fn[name] = function (speed, easing, callback) {
            return this.animate(props, speed, easing, callback);
        };
    });
    jQuery.timers = [];
    jQuery.fx.tick = function () {
        var timer, i = 0, timers = jQuery.timers;
        fxNow = jQuery.now();
        for (; i < timers.length; i++) {
            timer = timers[i];
            if (!timer() && timers[i] === timer) {
                timers.splice(i--, 1);
            }
        }
        if (!timers.length) {
            jQuery.fx.stop();
        }
        fxNow = undefined;
    };
    jQuery.fx.timer = function (timer) {
        jQuery.timers.push(timer);
        jQuery.fx.start();
    };
    jQuery.fx.interval = 13;
    jQuery.fx.start = function () {
        if (inProgress) {
            return;
        }
        inProgress = true;
        schedule();
    };
    jQuery.fx.stop = function () {
        inProgress = null;
    };
    jQuery.fx.speeds = {
        slow: 600,
        fast: 200,
        _default: 400
    };
    jQuery.fn.delay = function (time, type) {
        time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
        type = type || 'fx';
        return this.queue(type, function (next, hooks) {
            var timeout = window.setTimeout(next, time);
            hooks.stop = function () {
                window.clearTimeout(timeout);
            };
        });
    };
    (function () {
        var input = document.createElement('input'), select = document.createElement('select'), opt = select.appendChild(document.createElement('option'));
        input.type = 'checkbox';
        support.checkOn = input.value !== '';
        support.optSelected = opt.selected;
        input = document.createElement('input');
        input.value = 't';
        input.type = 'radio';
        support.radioValue = input.value === 't';
    }());
    var boolHook, attrHandle = jQuery.expr.attrHandle;
    jQuery.fn.extend({
        attr: function (name, value) {
            return access(this, jQuery.attr, name, value, arguments.length > 1);
        },
        removeAttr: function (name) {
            return this.each(function () {
                jQuery.removeAttr(this, name);
            });
        }
    });
    jQuery.extend({
        attr: function (elem, name, value) {
            var ret, hooks, nType = elem.nodeType;
            if (nType === 3 || nType === 8 || nType === 2) {
                return;
            }
            if (typeof elem.getAttribute === 'undefined') {
                return jQuery.prop(elem, name, value);
            }
            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
            }
            if (value !== undefined) {
                if (value === null) {
                    jQuery.removeAttr(elem, name);
                    return;
                }
                if (hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret;
                }
                elem.setAttribute(name, value + '');
                return value;
            }
            if (hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null) {
                return ret;
            }
            ret = jQuery.find.attr(elem, name);
            return ret == null ? undefined : ret;
        },
        attrHooks: {
            type: {
                set: function (elem, value) {
                    if (!support.radioValue && value === 'radio' && nodeName(elem, 'input')) {
                        var val = elem.value;
                        elem.setAttribute('type', value);
                        if (val) {
                            elem.value = val;
                        }
                        return value;
                    }
                }
            }
        },
        removeAttr: function (elem, value) {
            var name, i = 0, attrNames = value && value.match(rnothtmlwhite);
            if (attrNames && elem.nodeType === 1) {
                while (name = attrNames[i++]) {
                    elem.removeAttribute(name);
                }
            }
        }
    });
    boolHook = {
        set: function (elem, value, name) {
            if (value === false) {
                jQuery.removeAttr(elem, name);
            } else {
                elem.setAttribute(name, name);
            }
            return name;
        }
    };
    jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
        var getter = attrHandle[name] || jQuery.find.attr;
        attrHandle[name] = function (elem, name, isXML) {
            var ret, handle, lowercaseName = name.toLowerCase();
            if (!isXML) {
                handle = attrHandle[lowercaseName];
                attrHandle[lowercaseName] = ret;
                ret = getter(elem, name, isXML) != null ? lowercaseName : null;
                attrHandle[lowercaseName] = handle;
            }
            return ret;
        };
    });
    var rfocusable = /^(?:input|select|textarea|button)$/i, rclickable = /^(?:a|area)$/i;
    jQuery.fn.extend({
        prop: function (name, value) {
            return access(this, jQuery.prop, name, value, arguments.length > 1);
        },
        removeProp: function (name) {
            return this.each(function () {
                delete this[jQuery.propFix[name] || name];
            });
        }
    });
    jQuery.extend({
        prop: function (elem, name, value) {
            var ret, hooks, nType = elem.nodeType;
            if (nType === 3 || nType === 8 || nType === 2) {
                return;
            }
            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                name = jQuery.propFix[name] || name;
                hooks = jQuery.propHooks[name];
            }
            if (value !== undefined) {
                if (hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret;
                }
                return elem[name] = value;
            }
            if (hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null) {
                return ret;
            }
            return elem[name];
        },
        propHooks: {
            tabIndex: {
                get: function (elem) {
                    var tabindex = jQuery.find.attr(elem, 'tabindex');
                    if (tabindex) {
                        return parseInt(tabindex, 10);
                    }
                    if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
                        return 0;
                    }
                    return -1;
                }
            }
        },
        propFix: {
            'for': 'htmlFor',
            'class': 'className'
        }
    });
    if (!support.optSelected) {
        jQuery.propHooks.selected = {
            get: function (elem) {
                var parent = elem.parentNode;
                if (parent && parent.parentNode) {
                    parent.parentNode.selectedIndex;
                }
                return null;
            },
            set: function (elem) {
                var parent = elem.parentNode;
                if (parent) {
                    parent.selectedIndex;
                    if (parent.parentNode) {
                        parent.parentNode.selectedIndex;
                    }
                }
            }
        };
    }
    jQuery.each([
        'tabIndex',
        'readOnly',
        'maxLength',
        'cellSpacing',
        'cellPadding',
        'rowSpan',
        'colSpan',
        'useMap',
        'frameBorder',
        'contentEditable'
    ], function () {
        jQuery.propFix[this.toLowerCase()] = this;
    });
    function stripAndCollapse(value) {
        var tokens = value.match(rnothtmlwhite) || [];
        return tokens.join(' ');
    }
    function getClass(elem) {
        return elem.getAttribute && elem.getAttribute('class') || '';
    }
    jQuery.fn.extend({
        addClass: function (value) {
            var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;
            if (jQuery.isFunction(value)) {
                return this.each(function (j) {
                    jQuery(this).addClass(value.call(this, j, getClass(this)));
                });
            }
            if (typeof value === 'string' && value) {
                classes = value.match(rnothtmlwhite) || [];
                while (elem = this[i++]) {
                    curValue = getClass(elem);
                    cur = elem.nodeType === 1 && ' ' + stripAndCollapse(curValue) + ' ';
                    if (cur) {
                        j = 0;
                        while (clazz = classes[j++]) {
                            if (cur.indexOf(' ' + clazz + ' ') < 0) {
                                cur += clazz + ' ';
                            }
                        }
                        finalValue = stripAndCollapse(cur);
                        if (curValue !== finalValue) {
                            elem.setAttribute('class', finalValue);
                        }
                    }
                }
            }
            return this;
        },
        removeClass: function (value) {
            var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;
            if (jQuery.isFunction(value)) {
                return this.each(function (j) {
                    jQuery(this).removeClass(value.call(this, j, getClass(this)));
                });
            }
            if (!arguments.length) {
                return this.attr('class', '');
            }
            if (typeof value === 'string' && value) {
                classes = value.match(rnothtmlwhite) || [];
                while (elem = this[i++]) {
                    curValue = getClass(elem);
                    cur = elem.nodeType === 1 && ' ' + stripAndCollapse(curValue) + ' ';
                    if (cur) {
                        j = 0;
                        while (clazz = classes[j++]) {
                            while (cur.indexOf(' ' + clazz + ' ') > -1) {
                                cur = cur.replace(' ' + clazz + ' ', ' ');
                            }
                        }
                        finalValue = stripAndCollapse(cur);
                        if (curValue !== finalValue) {
                            elem.setAttribute('class', finalValue);
                        }
                    }
                }
            }
            return this;
        },
        toggleClass: function (value, stateVal) {
            var type = typeof value;
            if (typeof stateVal === 'boolean' && type === 'string') {
                return stateVal ? this.addClass(value) : this.removeClass(value);
            }
            if (jQuery.isFunction(value)) {
                return this.each(function (i) {
                    jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
                });
            }
            return this.each(function () {
                var className, i, self, classNames;
                if (type === 'string') {
                    i = 0;
                    self = jQuery(this);
                    classNames = value.match(rnothtmlwhite) || [];
                    while (className = classNames[i++]) {
                        if (self.hasClass(className)) {
                            self.removeClass(className);
                        } else {
                            self.addClass(className);
                        }
                    }
                } else if (value === undefined || type === 'boolean') {
                    className = getClass(this);
                    if (className) {
                        dataPriv.set(this, '__className__', className);
                    }
                    if (this.setAttribute) {
                        this.setAttribute('class', className || value === false ? '' : dataPriv.get(this, '__className__') || '');
                    }
                }
            });
        },
        hasClass: function (selector) {
            var className, elem, i = 0;
            className = ' ' + selector + ' ';
            while (elem = this[i++]) {
                if (elem.nodeType === 1 && (' ' + stripAndCollapse(getClass(elem)) + ' ').indexOf(className) > -1) {
                    return true;
                }
            }
            return false;
        }
    });
    var rreturn = /\r/g;
    jQuery.fn.extend({
        val: function (value) {
            var hooks, ret, isFunction, elem = this[0];
            if (!arguments.length) {
                if (elem) {
                    hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
                    if (hooks && 'get' in hooks && (ret = hooks.get(elem, 'value')) !== undefined) {
                        return ret;
                    }
                    ret = elem.value;
                    if (typeof ret === 'string') {
                        return ret.replace(rreturn, '');
                    }
                    return ret == null ? '' : ret;
                }
                return;
            }
            isFunction = jQuery.isFunction(value);
            return this.each(function (i) {
                var val;
                if (this.nodeType !== 1) {
                    return;
                }
                if (isFunction) {
                    val = value.call(this, i, jQuery(this).val());
                } else {
                    val = value;
                }
                if (val == null) {
                    val = '';
                } else if (typeof val === 'number') {
                    val += '';
                } else if (Array.isArray(val)) {
                    val = jQuery.map(val, function (value) {
                        return value == null ? '' : value + '';
                    });
                }
                hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
                if (!hooks || !('set' in hooks) || hooks.set(this, val, 'value') === undefined) {
                    this.value = val;
                }
            });
        }
    });
    jQuery.extend({
        valHooks: {
            option: {
                get: function (elem) {
                    var val = jQuery.find.attr(elem, 'value');
                    return val != null ? val : stripAndCollapse(jQuery.text(elem));
                }
            },
            select: {
                get: function (elem) {
                    var value, option, i, options = elem.options, index = elem.selectedIndex, one = elem.type === 'select-one', values = one ? null : [], max = one ? index + 1 : options.length;
                    if (index < 0) {
                        i = max;
                    } else {
                        i = one ? index : 0;
                    }
                    for (; i < max; i++) {
                        option = options[i];
                        if ((option.selected || i === index) && !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, 'optgroup'))) {
                            value = jQuery(option).val();
                            if (one) {
                                return value;
                            }
                            values.push(value);
                        }
                    }
                    return values;
                },
                set: function (elem, value) {
                    var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length;
                    while (i--) {
                        option = options[i];
                        if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
                            optionSet = true;
                        }
                    }
                    if (!optionSet) {
                        elem.selectedIndex = -1;
                    }
                    return values;
                }
            }
        }
    });
    jQuery.each([
        'radio',
        'checkbox'
    ], function () {
        jQuery.valHooks[this] = {
            set: function (elem, value) {
                if (Array.isArray(value)) {
                    return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
                }
            }
        };
        if (!support.checkOn) {
            jQuery.valHooks[this].get = function (elem) {
                return elem.getAttribute('value') === null ? 'on' : elem.value;
            };
        }
    });
    var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;
    jQuery.extend(jQuery.event, {
        trigger: function (event, data, elem, onlyHandlers) {
            var i, cur, tmp, bubbleType, ontype, handle, special, eventPath = [elem || document], type = hasOwn.call(event, 'type') ? event.type : event, namespaces = hasOwn.call(event, 'namespace') ? event.namespace.split('.') : [];
            cur = tmp = elem = elem || document;
            if (elem.nodeType === 3 || elem.nodeType === 8) {
                return;
            }
            if (rfocusMorph.test(type + jQuery.event.triggered)) {
                return;
            }
            if (type.indexOf('.') > -1) {
                namespaces = type.split('.');
                type = namespaces.shift();
                namespaces.sort();
            }
            ontype = type.indexOf(':') < 0 && 'on' + type;
            event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === 'object' && event);
            event.isTrigger = onlyHandlers ? 2 : 3;
            event.namespace = namespaces.join('.');
            event.rnamespace = event.namespace ? new RegExp('(^|\\.)' + namespaces.join('\\.(?:.*\\.|)') + '(\\.|$)') : null;
            event.result = undefined;
            if (!event.target) {
                event.target = elem;
            }
            data = data == null ? [event] : jQuery.makeArray(data, [event]);
            special = jQuery.event.special[type] || {};
            if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
                return;
            }
            if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
                bubbleType = special.delegateType || type;
                if (!rfocusMorph.test(bubbleType + type)) {
                    cur = cur.parentNode;
                }
                for (; cur; cur = cur.parentNode) {
                    eventPath.push(cur);
                    tmp = cur;
                }
                if (tmp === (elem.ownerDocument || document)) {
                    eventPath.push(tmp.defaultView || tmp.parentWindow || window);
                }
            }
            i = 0;
            while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
                event.type = i > 1 ? bubbleType : special.bindType || type;
                handle = (dataPriv.get(cur, 'events') || {})[event.type] && dataPriv.get(cur, 'handle');
                if (handle) {
                    handle.apply(cur, data);
                }
                handle = ontype && cur[ontype];
                if (handle && handle.apply && acceptData(cur)) {
                    event.result = handle.apply(cur, data);
                    if (event.result === false) {
                        event.preventDefault();
                    }
                }
            }
            event.type = type;
            if (!onlyHandlers && !event.isDefaultPrevented()) {
                if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
                    if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {
                        tmp = elem[ontype];
                        if (tmp) {
                            elem[ontype] = null;
                        }
                        jQuery.event.triggered = type;
                        elem[type]();
                        jQuery.event.triggered = undefined;
                        if (tmp) {
                            elem[ontype] = tmp;
                        }
                    }
                }
            }
            return event.result;
        },
        simulate: function (type, elem, event) {
            var e = jQuery.extend(new jQuery.Event(), event, {
                type: type,
                isSimulated: true
            });
            jQuery.event.trigger(e, null, elem);
        }
    });
    jQuery.fn.extend({
        trigger: function (type, data) {
            return this.each(function () {
                jQuery.event.trigger(type, data, this);
            });
        },
        triggerHandler: function (type, data) {
            var elem = this[0];
            if (elem) {
                return jQuery.event.trigger(type, data, elem, true);
            }
        }
    });
    jQuery.each(('blur focus focusin focusout resize scroll click dblclick ' + 'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave ' + 'change select submit keydown keypress keyup contextmenu').split(' '), function (i, name) {
        jQuery.fn[name] = function (data, fn) {
            return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
        };
    });
    jQuery.fn.extend({
        hover: function (fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
        }
    });
    support.focusin = 'onfocusin' in window;
    if (!support.focusin) {
        jQuery.each({
            focus: 'focusin',
            blur: 'focusout'
        }, function (orig, fix) {
            var handler = function (event) {
                jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
            };
            jQuery.event.special[fix] = {
                setup: function () {
                    var doc = this.ownerDocument || this, attaches = dataPriv.access(doc, fix);
                    if (!attaches) {
                        doc.addEventListener(orig, handler, true);
                    }
                    dataPriv.access(doc, fix, (attaches || 0) + 1);
                },
                teardown: function () {
                    var doc = this.ownerDocument || this, attaches = dataPriv.access(doc, fix) - 1;
                    if (!attaches) {
                        doc.removeEventListener(orig, handler, true);
                        dataPriv.remove(doc, fix);
                    } else {
                        dataPriv.access(doc, fix, attaches);
                    }
                }
            };
        });
    }
    var location = window.location;
    var nonce = jQuery.now();
    var rquery = /\?/;
    jQuery.parseXML = function (data) {
        var xml;
        if (!data || typeof data !== 'string') {
            return null;
        }
        try {
            xml = new window.DOMParser().parseFromString(data, 'text/xml');
        } catch (e) {
            xml = undefined;
        }
        if (!xml || xml.getElementsByTagName('parsererror').length) {
            jQuery.error('Invalid XML: ' + data);
        }
        return xml;
    };
    var rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
    function buildParams(prefix, obj, traditional, add) {
        var name;
        if (Array.isArray(obj)) {
            jQuery.each(obj, function (i, v) {
                if (traditional || rbracket.test(prefix)) {
                    add(prefix, v);
                } else {
                    buildParams(prefix + '[' + (typeof v === 'object' && v != null ? i : '') + ']', v, traditional, add);
                }
            });
        } else if (!traditional && jQuery.type(obj) === 'object') {
            for (name in obj) {
                buildParams(prefix + '[' + name + ']', obj[name], traditional, add);
            }
        } else {
            add(prefix, obj);
        }
    }
    jQuery.param = function (a, traditional) {
        var prefix, s = [], add = function (key, valueOrFunction) {
                var value = jQuery.isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;
                s[s.length] = encodeURIComponent(key) + '=' + encodeURIComponent(value == null ? '' : value);
            };
        if (Array.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
            jQuery.each(a, function () {
                add(this.name, this.value);
            });
        } else {
            for (prefix in a) {
                buildParams(prefix, a[prefix], traditional, add);
            }
        }
        return s.join('&');
    };
    jQuery.fn.extend({
        serialize: function () {
            return jQuery.param(this.serializeArray());
        },
        serializeArray: function () {
            return this.map(function () {
                var elements = jQuery.prop(this, 'elements');
                return elements ? jQuery.makeArray(elements) : this;
            }).filter(function () {
                var type = this.type;
                return this.name && !jQuery(this).is(':disabled') && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
            }).map(function (i, elem) {
                var val = jQuery(this).val();
                if (val == null) {
                    return null;
                }
                if (Array.isArray(val)) {
                    return jQuery.map(val, function (val) {
                        return {
                            name: elem.name,
                            value: val.replace(rCRLF, '\r\n')
                        };
                    });
                }
                return {
                    name: elem.name,
                    value: val.replace(rCRLF, '\r\n')
                };
            }).get();
        }
    });
    var r20 = /%20/g, rhash = /#.*$/, rantiCache = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/gm, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, prefilters = {}, transports = {}, allTypes = '*/'.concat('*'), originAnchor = document.createElement('a');
    originAnchor.href = location.href;
    function addToPrefiltersOrTransports(structure) {
        return function (dataTypeExpression, func) {
            if (typeof dataTypeExpression !== 'string') {
                func = dataTypeExpression;
                dataTypeExpression = '*';
            }
            var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
            if (jQuery.isFunction(func)) {
                while (dataType = dataTypes[i++]) {
                    if (dataType[0] === '+') {
                        dataType = dataType.slice(1) || '*';
                        (structure[dataType] = structure[dataType] || []).unshift(func);
                    } else {
                        (structure[dataType] = structure[dataType] || []).push(func);
                    }
                }
            }
        };
    }
    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
        var inspected = {}, seekingTransport = structure === transports;
        function inspect(dataType) {
            var selected;
            inspected[dataType] = true;
            jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
                var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                if (typeof dataTypeOrTransport === 'string' && !seekingTransport && !inspected[dataTypeOrTransport]) {
                    options.dataTypes.unshift(dataTypeOrTransport);
                    inspect(dataTypeOrTransport);
                    return false;
                } else if (seekingTransport) {
                    return !(selected = dataTypeOrTransport);
                }
            });
            return selected;
        }
        return inspect(options.dataTypes[0]) || !inspected['*'] && inspect('*');
    }
    function ajaxExtend(target, src) {
        var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
        for (key in src) {
            if (src[key] !== undefined) {
                (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
            }
        }
        if (deep) {
            jQuery.extend(true, target, deep);
        }
        return target;
    }
    function ajaxHandleResponses(s, jqXHR, responses) {
        var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes;
        while (dataTypes[0] === '*') {
            dataTypes.shift();
            if (ct === undefined) {
                ct = s.mimeType || jqXHR.getResponseHeader('Content-Type');
            }
        }
        if (ct) {
            for (type in contents) {
                if (contents[type] && contents[type].test(ct)) {
                    dataTypes.unshift(type);
                    break;
                }
            }
        }
        if (dataTypes[0] in responses) {
            finalDataType = dataTypes[0];
        } else {
            for (type in responses) {
                if (!dataTypes[0] || s.converters[type + ' ' + dataTypes[0]]) {
                    finalDataType = type;
                    break;
                }
                if (!firstDataType) {
                    firstDataType = type;
                }
            }
            finalDataType = finalDataType || firstDataType;
        }
        if (finalDataType) {
            if (finalDataType !== dataTypes[0]) {
                dataTypes.unshift(finalDataType);
            }
            return responses[finalDataType];
        }
    }
    function ajaxConvert(s, response, jqXHR, isSuccess) {
        var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s.dataTypes.slice();
        if (dataTypes[1]) {
            for (conv in s.converters) {
                converters[conv.toLowerCase()] = s.converters[conv];
            }
        }
        current = dataTypes.shift();
        while (current) {
            if (s.responseFields[current]) {
                jqXHR[s.responseFields[current]] = response;
            }
            if (!prev && isSuccess && s.dataFilter) {
                response = s.dataFilter(response, s.dataType);
            }
            prev = current;
            current = dataTypes.shift();
            if (current) {
                if (current === '*') {
                    current = prev;
                } else if (prev !== '*' && prev !== current) {
                    conv = converters[prev + ' ' + current] || converters['* ' + current];
                    if (!conv) {
                        for (conv2 in converters) {
                            tmp = conv2.split(' ');
                            if (tmp[1] === current) {
                                conv = converters[prev + ' ' + tmp[0]] || converters['* ' + tmp[0]];
                                if (conv) {
                                    if (conv === true) {
                                        conv = converters[conv2];
                                    } else if (converters[conv2] !== true) {
                                        current = tmp[0];
                                        dataTypes.unshift(tmp[1]);
                                    }
                                    break;
                                }
                            }
                        }
                    }
                    if (conv !== true) {
                        if (conv && s.throws) {
                            response = conv(response);
                        } else {
                            try {
                                response = conv(response);
                            } catch (e) {
                                return {
                                    state: 'parsererror',
                                    error: conv ? e : 'No conversion from ' + prev + ' to ' + current
                                };
                            }
                        }
                    }
                }
            }
        }
        return {
            state: 'success',
            data: response
        };
    }
    jQuery.extend({
        active: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: {
            url: location.href,
            type: 'GET',
            isLocal: rlocalProtocol.test(location.protocol),
            global: true,
            processData: true,
            async: true,
            contentType: 'application/x-www-form-urlencoded; charset=UTF-8',
            accepts: {
                '*': allTypes,
                text: 'text/plain',
                html: 'text/html',
                xml: 'application/xml, text/xml',
                json: 'application/json, text/javascript'
            },
            contents: {
                xml: /\bxml\b/,
                html: /\bhtml/,
                json: /\bjson\b/
            },
            responseFields: {
                xml: 'responseXML',
                text: 'responseText',
                json: 'responseJSON'
            },
            converters: {
                '* text': String,
                'text html': true,
                'text json': JSON.parse,
                'text xml': jQuery.parseXML
            },
            flatOptions: {
                url: true,
                context: true
            }
        },
        ajaxSetup: function (target, settings) {
            return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
        },
        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),
        ajax: function (url, options) {
            if (typeof url === 'object') {
                options = url;
                url = undefined;
            }
            options = options || {};
            var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, urlAnchor, completed, fireGlobals, i, uncached, s = jQuery.ajaxSetup({}, options), callbackContext = s.context || s, globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks('once memory'), statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, strAbort = 'canceled', jqXHR = {
                    readyState: 0,
                    getResponseHeader: function (key) {
                        var match;
                        if (completed) {
                            if (!responseHeaders) {
                                responseHeaders = {};
                                while (match = rheaders.exec(responseHeadersString)) {
                                    responseHeaders[match[1].toLowerCase()] = match[2];
                                }
                            }
                            match = responseHeaders[key.toLowerCase()];
                        }
                        return match == null ? null : match;
                    },
                    getAllResponseHeaders: function () {
                        return completed ? responseHeadersString : null;
                    },
                    setRequestHeader: function (name, value) {
                        if (completed == null) {
                            name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
                            requestHeaders[name] = value;
                        }
                        return this;
                    },
                    overrideMimeType: function (type) {
                        if (completed == null) {
                            s.mimeType = type;
                        }
                        return this;
                    },
                    statusCode: function (map) {
                        var code;
                        if (map) {
                            if (completed) {
                                jqXHR.always(map[jqXHR.status]);
                            } else {
                                for (code in map) {
                                    statusCode[code] = [
                                        statusCode[code],
                                        map[code]
                                    ];
                                }
                            }
                        }
                        return this;
                    },
                    abort: function (statusText) {
                        var finalText = statusText || strAbort;
                        if (transport) {
                            transport.abort(finalText);
                        }
                        done(0, finalText);
                        return this;
                    }
                };
            deferred.promise(jqXHR);
            s.url = ((url || s.url || location.href) + '').replace(rprotocol, location.protocol + '//');
            s.type = options.method || options.type || s.method || s.type;
            s.dataTypes = (s.dataType || '*').toLowerCase().match(rnothtmlwhite) || [''];
            if (s.crossDomain == null) {
                urlAnchor = document.createElement('a');
                try {
                    urlAnchor.href = s.url;
                    urlAnchor.href = urlAnchor.href;
                    s.crossDomain = originAnchor.protocol + '//' + originAnchor.host !== urlAnchor.protocol + '//' + urlAnchor.host;
                } catch (e) {
                    s.crossDomain = true;
                }
            }
            if (s.data && s.processData && typeof s.data !== 'string') {
                s.data = jQuery.param(s.data, s.traditional);
            }
            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
            if (completed) {
                return jqXHR;
            }
            fireGlobals = jQuery.event && s.global;
            if (fireGlobals && jQuery.active++ === 0) {
                jQuery.event.trigger('ajaxStart');
            }
            s.type = s.type.toUpperCase();
            s.hasContent = !rnoContent.test(s.type);
            cacheURL = s.url.replace(rhash, '');
            if (!s.hasContent) {
                uncached = s.url.slice(cacheURL.length);
                if (s.data) {
                    cacheURL += (rquery.test(cacheURL) ? '&' : '?') + s.data;
                    delete s.data;
                }
                if (s.cache === false) {
                    cacheURL = cacheURL.replace(rantiCache, '$1');
                    uncached = (rquery.test(cacheURL) ? '&' : '?') + '_=' + nonce++ + uncached;
                }
                s.url = cacheURL + uncached;
            } else if (s.data && s.processData && (s.contentType || '').indexOf('application/x-www-form-urlencoded') === 0) {
                s.data = s.data.replace(r20, '+');
            }
            if (s.ifModified) {
                if (jQuery.lastModified[cacheURL]) {
                    jqXHR.setRequestHeader('If-Modified-Since', jQuery.lastModified[cacheURL]);
                }
                if (jQuery.etag[cacheURL]) {
                    jqXHR.setRequestHeader('If-None-Match', jQuery.etag[cacheURL]);
                }
            }
            if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
                jqXHR.setRequestHeader('Content-Type', s.contentType);
            }
            jqXHR.setRequestHeader('Accept', s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== '*' ? ', ' + allTypes + '; q=0.01' : '') : s.accepts['*']);
            for (i in s.headers) {
                jqXHR.setRequestHeader(i, s.headers[i]);
            }
            if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) {
                return jqXHR.abort();
            }
            strAbort = 'abort';
            completeDeferred.add(s.complete);
            jqXHR.done(s.success);
            jqXHR.fail(s.error);
            transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
            if (!transport) {
                done(-1, 'No Transport');
            } else {
                jqXHR.readyState = 1;
                if (fireGlobals) {
                    globalEventContext.trigger('ajaxSend', [
                        jqXHR,
                        s
                    ]);
                }
                if (completed) {
                    return jqXHR;
                }
                if (s.async && s.timeout > 0) {
                    timeoutTimer = window.setTimeout(function () {
                        jqXHR.abort('timeout');
                    }, s.timeout);
                }
                try {
                    completed = false;
                    transport.send(requestHeaders, done);
                } catch (e) {
                    if (completed) {
                        throw e;
                    }
                    done(-1, e);
                }
            }
            function done(status, nativeStatusText, responses, headers) {
                var isSuccess, success, error, response, modified, statusText = nativeStatusText;
                if (completed) {
                    return;
                }
                completed = true;
                if (timeoutTimer) {
                    window.clearTimeout(timeoutTimer);
                }
                transport = undefined;
                responseHeadersString = headers || '';
                jqXHR.readyState = status > 0 ? 4 : 0;
                isSuccess = status >= 200 && status < 300 || status === 304;
                if (responses) {
                    response = ajaxHandleResponses(s, jqXHR, responses);
                }
                response = ajaxConvert(s, response, jqXHR, isSuccess);
                if (isSuccess) {
                    if (s.ifModified) {
                        modified = jqXHR.getResponseHeader('Last-Modified');
                        if (modified) {
                            jQuery.lastModified[cacheURL] = modified;
                        }
                        modified = jqXHR.getResponseHeader('etag');
                        if (modified) {
                            jQuery.etag[cacheURL] = modified;
                        }
                    }
                    if (status === 204 || s.type === 'HEAD') {
                        statusText = 'nocontent';
                    } else if (status === 304) {
                        statusText = 'notmodified';
                    } else {
                        statusText = response.state;
                        success = response.data;
                        error = response.error;
                        isSuccess = !error;
                    }
                } else {
                    error = statusText;
                    if (status || !statusText) {
                        statusText = 'error';
                        if (status < 0) {
                            status = 0;
                        }
                    }
                }
                jqXHR.status = status;
                jqXHR.statusText = (nativeStatusText || statusText) + '';
                if (isSuccess) {
                    deferred.resolveWith(callbackContext, [
                        success,
                        statusText,
                        jqXHR
                    ]);
                } else {
                    deferred.rejectWith(callbackContext, [
                        jqXHR,
                        statusText,
                        error
                    ]);
                }
                jqXHR.statusCode(statusCode);
                statusCode = undefined;
                if (fireGlobals) {
                    globalEventContext.trigger(isSuccess ? 'ajaxSuccess' : 'ajaxError', [
                        jqXHR,
                        s,
                        isSuccess ? success : error
                    ]);
                }
                completeDeferred.fireWith(callbackContext, [
                    jqXHR,
                    statusText
                ]);
                if (fireGlobals) {
                    globalEventContext.trigger('ajaxComplete', [
                        jqXHR,
                        s
                    ]);
                    if (!--jQuery.active) {
                        jQuery.event.trigger('ajaxStop');
                    }
                }
            }
            return jqXHR;
        },
        getJSON: function (url, data, callback) {
            return jQuery.get(url, data, callback, 'json');
        },
        getScript: function (url, callback) {
            return jQuery.get(url, undefined, callback, 'script');
        }
    });
    jQuery.each([
        'get',
        'post'
    ], function (i, method) {
        jQuery[method] = function (url, data, callback, type) {
            if (jQuery.isFunction(data)) {
                type = type || callback;
                callback = data;
                data = undefined;
            }
            return jQuery.ajax(jQuery.extend({
                url: url,
                type: method,
                dataType: type,
                data: data,
                success: callback
            }, jQuery.isPlainObject(url) && url));
        };
    });
    jQuery._evalUrl = function (url) {
        return jQuery.ajax({
            url: url,
            type: 'GET',
            dataType: 'script',
            cache: true,
            async: false,
            global: false,
            'throws': true
        });
    };
    jQuery.fn.extend({
        wrapAll: function (html) {
            var wrap;
            if (this[0]) {
                if (jQuery.isFunction(html)) {
                    html = html.call(this[0]);
                }
                wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
                if (this[0].parentNode) {
                    wrap.insertBefore(this[0]);
                }
                wrap.map(function () {
                    var elem = this;
                    while (elem.firstElementChild) {
                        elem = elem.firstElementChild;
                    }
                    return elem;
                }).append(this);
            }
            return this;
        },
        wrapInner: function (html) {
            if (jQuery.isFunction(html)) {
                return this.each(function (i) {
                    jQuery(this).wrapInner(html.call(this, i));
                });
            }
            return this.each(function () {
                var self = jQuery(this), contents = self.contents();
                if (contents.length) {
                    contents.wrapAll(html);
                } else {
                    self.append(html);
                }
            });
        },
        wrap: function (html) {
            var isFunction = jQuery.isFunction(html);
            return this.each(function (i) {
                jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
            });
        },
        unwrap: function (selector) {
            this.parent(selector).not('body').each(function () {
                jQuery(this).replaceWith(this.childNodes);
            });
            return this;
        }
    });
    jQuery.expr.pseudos.hidden = function (elem) {
        return !jQuery.expr.pseudos.visible(elem);
    };
    jQuery.expr.pseudos.visible = function (elem) {
        return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
    };
    jQuery.ajaxSettings.xhr = function () {
        try {
            return new window.XMLHttpRequest();
        } catch (e) {
        }
    };
    var xhrSuccessStatus = {
            0: 200,
            1223: 204
        }, xhrSupported = jQuery.ajaxSettings.xhr();
    support.cors = !!xhrSupported && 'withCredentials' in xhrSupported;
    support.ajax = xhrSupported = !!xhrSupported;
    jQuery.ajaxTransport(function (options) {
        var callback, errorCallback;
        if (support.cors || xhrSupported && !options.crossDomain) {
            return {
                send: function (headers, complete) {
                    var i, xhr = options.xhr();
                    xhr.open(options.type, options.url, options.async, options.username, options.password);
                    if (options.xhrFields) {
                        for (i in options.xhrFields) {
                            xhr[i] = options.xhrFields[i];
                        }
                    }
                    if (options.mimeType && xhr.overrideMimeType) {
                        xhr.overrideMimeType(options.mimeType);
                    }
                    if (!options.crossDomain && !headers['X-Requested-With']) {
                        headers['X-Requested-With'] = 'XMLHttpRequest';
                    }
                    for (i in headers) {
                        xhr.setRequestHeader(i, headers[i]);
                    }
                    callback = function (type) {
                        return function () {
                            if (callback) {
                                callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;
                                if (type === 'abort') {
                                    xhr.abort();
                                } else if (type === 'error') {
                                    if (typeof xhr.status !== 'number') {
                                        complete(0, 'error');
                                    } else {
                                        complete(xhr.status, xhr.statusText);
                                    }
                                } else {
                                    complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, (xhr.responseType || 'text') !== 'text' || typeof xhr.responseText !== 'string' ? { binary: xhr.response } : { text: xhr.responseText }, xhr.getAllResponseHeaders());
                                }
                            }
                        };
                    };
                    xhr.onload = callback();
                    errorCallback = xhr.onerror = callback('error');
                    if (xhr.onabort !== undefined) {
                        xhr.onabort = errorCallback;
                    } else {
                        xhr.onreadystatechange = function () {
                            if (xhr.readyState === 4) {
                                window.setTimeout(function () {
                                    if (callback) {
                                        errorCallback();
                                    }
                                });
                            }
                        };
                    }
                    callback = callback('abort');
                    try {
                        xhr.send(options.hasContent && options.data || null);
                    } catch (e) {
                        if (callback) {
                            throw e;
                        }
                    }
                },
                abort: function () {
                    if (callback) {
                        callback();
                    }
                }
            };
        }
    });
    jQuery.ajaxPrefilter(function (s) {
        if (s.crossDomain) {
            s.contents.script = false;
        }
    });
    jQuery.ajaxSetup({
        accepts: { script: 'text/javascript, application/javascript, ' + 'application/ecmascript, application/x-ecmascript' },
        contents: { script: /\b(?:java|ecma)script\b/ },
        converters: {
            'text script': function (text) {
                jQuery.globalEval(text);
                return text;
            }
        }
    });
    jQuery.ajaxPrefilter('script', function (s) {
        if (s.cache === undefined) {
            s.cache = false;
        }
        if (s.crossDomain) {
            s.type = 'GET';
        }
    });
    jQuery.ajaxTransport('script', function (s) {
        if (s.crossDomain) {
            var script, callback;
            return {
                send: function (_, complete) {
                    script = jQuery('<script>').prop({
                        charset: s.scriptCharset,
                        src: s.url
                    }).on('load error', callback = function (evt) {
                        script.remove();
                        callback = null;
                        if (evt) {
                            complete(evt.type === 'error' ? 404 : 200, evt.type);
                        }
                    });
                    document.head.appendChild(script[0]);
                },
                abort: function () {
                    if (callback) {
                        callback();
                    }
                }
            };
        }
    });
    var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
    jQuery.ajaxSetup({
        jsonp: 'callback',
        jsonpCallback: function () {
            var callback = oldCallbacks.pop() || jQuery.expando + '_' + nonce++;
            this[callback] = true;
            return callback;
        }
    });
    jQuery.ajaxPrefilter('json jsonp', function (s, originalSettings, jqXHR) {
        var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? 'url' : typeof s.data === 'string' && (s.contentType || '').indexOf('application/x-www-form-urlencoded') === 0 && rjsonp.test(s.data) && 'data');
        if (jsonProp || s.dataTypes[0] === 'jsonp') {
            callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
            if (jsonProp) {
                s[jsonProp] = s[jsonProp].replace(rjsonp, '$1' + callbackName);
            } else if (s.jsonp !== false) {
                s.url += (rquery.test(s.url) ? '&' : '?') + s.jsonp + '=' + callbackName;
            }
            s.converters['script json'] = function () {
                if (!responseContainer) {
                    jQuery.error(callbackName + ' was not called');
                }
                return responseContainer[0];
            };
            s.dataTypes[0] = 'json';
            overwritten = window[callbackName];
            window[callbackName] = function () {
                responseContainer = arguments;
            };
            jqXHR.always(function () {
                if (overwritten === undefined) {
                    jQuery(window).removeProp(callbackName);
                } else {
                    window[callbackName] = overwritten;
                }
                if (s[callbackName]) {
                    s.jsonpCallback = originalSettings.jsonpCallback;
                    oldCallbacks.push(callbackName);
                }
                if (responseContainer && jQuery.isFunction(overwritten)) {
                    overwritten(responseContainer[0]);
                }
                responseContainer = overwritten = undefined;
            });
            return 'script';
        }
    });
    support.createHTMLDocument = function () {
        var body = document.implementation.createHTMLDocument('').body;
        body.innerHTML = '<form></form><form></form>';
        return body.childNodes.length === 2;
    }();
    jQuery.parseHTML = function (data, context, keepScripts) {
        if (typeof data !== 'string') {
            return [];
        }
        if (typeof context === 'boolean') {
            keepScripts = context;
            context = false;
        }
        var base, parsed, scripts;
        if (!context) {
            if (support.createHTMLDocument) {
                context = document.implementation.createHTMLDocument('');
                base = context.createElement('base');
                base.href = document.location.href;
                context.head.appendChild(base);
            } else {
                context = document;
            }
        }
        parsed = rsingleTag.exec(data);
        scripts = !keepScripts && [];
        if (parsed) {
            return [context.createElement(parsed[1])];
        }
        parsed = buildFragment([data], context, scripts);
        if (scripts && scripts.length) {
            jQuery(scripts).remove();
        }
        return jQuery.merge([], parsed.childNodes);
    };
    jQuery.fn.load = function (url, params, callback) {
        var selector, type, response, self = this, off = url.indexOf(' ');
        if (off > -1) {
            selector = stripAndCollapse(url.slice(off));
            url = url.slice(0, off);
        }
        if (jQuery.isFunction(params)) {
            callback = params;
            params = undefined;
        } else if (params && typeof params === 'object') {
            type = 'POST';
        }
        if (self.length > 0) {
            jQuery.ajax({
                url: url,
                type: type || 'GET',
                dataType: 'html',
                data: params
            }).done(function (responseText) {
                response = arguments;
                self.html(selector ? jQuery('<div>').append(jQuery.parseHTML(responseText)).find(selector) : responseText);
            }).always(callback && function (jqXHR, status) {
                self.each(function () {
                    callback.apply(this, response || [
                        jqXHR.responseText,
                        status,
                        jqXHR
                    ]);
                });
            });
        }
        return this;
    };
    jQuery.each([
        'ajaxStart',
        'ajaxStop',
        'ajaxComplete',
        'ajaxError',
        'ajaxSuccess',
        'ajaxSend'
    ], function (i, type) {
        jQuery.fn[type] = function (fn) {
            return this.on(type, fn);
        };
    });
    jQuery.expr.pseudos.animated = function (elem) {
        return jQuery.grep(jQuery.timers, function (fn) {
            return elem === fn.elem;
        }).length;
    };
    jQuery.offset = {
        setOffset: function (elem, options, i) {
            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, 'position'), curElem = jQuery(elem), props = {};
            if (position === 'static') {
                elem.style.position = 'relative';
            }
            curOffset = curElem.offset();
            curCSSTop = jQuery.css(elem, 'top');
            curCSSLeft = jQuery.css(elem, 'left');
            calculatePosition = (position === 'absolute' || position === 'fixed') && (curCSSTop + curCSSLeft).indexOf('auto') > -1;
            if (calculatePosition) {
                curPosition = curElem.position();
                curTop = curPosition.top;
                curLeft = curPosition.left;
            } else {
                curTop = parseFloat(curCSSTop) || 0;
                curLeft = parseFloat(curCSSLeft) || 0;
            }
            if (jQuery.isFunction(options)) {
                options = options.call(elem, i, jQuery.extend({}, curOffset));
            }
            if (options.top != null) {
                props.top = options.top - curOffset.top + curTop;
            }
            if (options.left != null) {
                props.left = options.left - curOffset.left + curLeft;
            }
            if ('using' in options) {
                options.using.call(elem, props);
            } else {
                curElem.css(props);
            }
        }
    };
    jQuery.fn.extend({
        offset: function (options) {
            if (arguments.length) {
                return options === undefined ? this : this.each(function (i) {
                    jQuery.offset.setOffset(this, options, i);
                });
            }
            var doc, docElem, rect, win, elem = this[0];
            if (!elem) {
                return;
            }
            if (!elem.getClientRects().length) {
                return {
                    top: 0,
                    left: 0
                };
            }
            rect = elem.getBoundingClientRect();
            doc = elem.ownerDocument;
            docElem = doc.documentElement;
            win = doc.defaultView;
            return {
                top: rect.top + win.pageYOffset - docElem.clientTop,
                left: rect.left + win.pageXOffset - docElem.clientLeft
            };
        },
        position: function () {
            if (!this[0]) {
                return;
            }
            var offsetParent, offset, elem = this[0], parentOffset = {
                    top: 0,
                    left: 0
                };
            if (jQuery.css(elem, 'position') === 'fixed') {
                offset = elem.getBoundingClientRect();
            } else {
                offsetParent = this.offsetParent();
                offset = this.offset();
                if (!nodeName(offsetParent[0], 'html')) {
                    parentOffset = offsetParent.offset();
                }
                parentOffset = {
                    top: parentOffset.top + jQuery.css(offsetParent[0], 'borderTopWidth', true),
                    left: parentOffset.left + jQuery.css(offsetParent[0], 'borderLeftWidth', true)
                };
            }
            return {
                top: offset.top - parentOffset.top - jQuery.css(elem, 'marginTop', true),
                left: offset.left - parentOffset.left - jQuery.css(elem, 'marginLeft', true)
            };
        },
        offsetParent: function () {
            return this.map(function () {
                var offsetParent = this.offsetParent;
                while (offsetParent && jQuery.css(offsetParent, 'position') === 'static') {
                    offsetParent = offsetParent.offsetParent;
                }
                return offsetParent || documentElement;
            });
        }
    });
    jQuery.each({
        scrollLeft: 'pageXOffset',
        scrollTop: 'pageYOffset'
    }, function (method, prop) {
        var top = 'pageYOffset' === prop;
        jQuery.fn[method] = function (val) {
            return access(this, function (elem, method, val) {
                var win;
                if (jQuery.isWindow(elem)) {
                    win = elem;
                } else if (elem.nodeType === 9) {
                    win = elem.defaultView;
                }
                if (val === undefined) {
                    return win ? win[prop] : elem[method];
                }
                if (win) {
                    win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);
                } else {
                    elem[method] = val;
                }
            }, method, val, arguments.length);
        };
    });
    jQuery.each([
        'top',
        'left'
    ], function (i, prop) {
        jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {
            if (computed) {
                computed = curCSS(elem, prop);
                return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + 'px' : computed;
            }
        });
    });
    jQuery.each({
        Height: 'height',
        Width: 'width'
    }, function (name, type) {
        jQuery.each({
            padding: 'inner' + name,
            content: type,
            '': 'outer' + name
        }, function (defaultExtra, funcName) {
            jQuery.fn[funcName] = function (margin, value) {
                var chainable = arguments.length && (defaultExtra || typeof margin !== 'boolean'), extra = defaultExtra || (margin === true || value === true ? 'margin' : 'border');
                return access(this, function (elem, type, value) {
                    var doc;
                    if (jQuery.isWindow(elem)) {
                        return funcName.indexOf('outer') === 0 ? elem['inner' + name] : elem.document.documentElement['client' + name];
                    }
                    if (elem.nodeType === 9) {
                        doc = elem.documentElement;
                        return Math.max(elem.body['scroll' + name], doc['scroll' + name], elem.body['offset' + name], doc['offset' + name], doc['client' + name]);
                    }
                    return value === undefined ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra);
                }, type, chainable ? margin : undefined, chainable);
            };
        });
    });
    jQuery.fn.extend({
        bind: function (types, data, fn) {
            return this.on(types, null, data, fn);
        },
        unbind: function (types, fn) {
            return this.off(types, null, fn);
        },
        delegate: function (selector, types, data, fn) {
            return this.on(types, selector, data, fn);
        },
        undelegate: function (selector, types, fn) {
            return arguments.length === 1 ? this.off(selector, '**') : this.off(types, selector || '**', fn);
        }
    });
    jQuery.holdReady = function (hold) {
        if (hold) {
            jQuery.readyWait++;
        } else {
            jQuery.ready(true);
        }
    };
    jQuery.isArray = Array.isArray;
    jQuery.parseJSON = JSON.parse;
    jQuery.nodeName = nodeName;
    if (typeof define === 'function' && define.amd) {
        define('jquery@3.2.1#dist/jquery', [], function () {
            return jQuery;
        });
    }
    var _jQuery = window.jQuery, _$ = window.$;
    jQuery.noConflict = function (deep) {
        if (window.$ === jQuery) {
            window.$ = _$;
        }
        if (deep && window.jQuery === jQuery) {
            window.jQuery = _jQuery;
        }
        return jQuery;
    };
    if (!noGlobal) {
        window.jQuery = window.$ = jQuery;
    }
    return jQuery;
}));
/*can-validate-legacy@1.1.0#map/validate/validate*/
define('can-validate-legacy@1.1.0#map/validate/validate', function (require, exports, module) {
    var $ = require('jquery');
    var namespace = require('can-util/namespace');
    var Map = require('can-map');
    var each = require('can-util/js/each/each');
    var isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');
    var validate = require('can-validate-legacy');
    var compute = require('can-compute');
    var proto = Map.prototype;
    var oldSet = proto.__set;
    var ErrorsObj;
    var defaultValidationOpts;
    var config = {
        errorKeyName: 'errors',
        validateOptionCacheKey: 'validateOptions'
    };
    var resolveComputes = function (itemObj, opts) {
        var processedObj = {};
        each(opts, function (item, key) {
            var actualOpts = item;
            if (typeof item === 'function') {
                actualOpts = item(itemObj.value);
            }
            processedObj[key] = actualOpts;
        });
        return processedObj;
    };
    var getPropDefineBehavior = function (behavior, attr, define) {
        var prop;
        var defaultProp;
        if (define) {
            prop = define[attr];
            defaultProp = define['*'];
            if (prop && prop[behavior] !== undefined) {
                return prop[behavior];
            } else {
                if (defaultProp && defaultProp[behavior] !== undefined) {
                    return defaultProp[behavior];
                }
            }
        }
    };
    ErrorsObj = Map.extend({}, {
        hasErrors: function () {
            return !isEmptyObject(this.attr());
        }
    });
    defaultValidationOpts = {
        mustValidate: false,
        validateOnInit: false
    };
    var getValidateFromCache = function () {
        var validateCacheKey = '__' + config.validateOptionCacheKey;
        if (!this[validateCacheKey]) {
            this[validateCacheKey] = {};
        }
        return this[validateCacheKey];
    };
    var initProperty = function (key, value) {
        var validateOpts;
        var mapValidateCache;
        var propIniting;
        mapValidateCache = getValidateFromCache.call(this);
        if (mapValidateCache[key] && !isEmptyObject(mapValidateCache[key])) {
            validateOpts = mapValidateCache[key];
            propIniting = false;
        } else {
            validateOpts = $.extend({}, getPropDefineBehavior('validate', key, this.define));
            propIniting = true;
        }
        if (typeof validateOpts !== 'undefined') {
            if (propIniting) {
                validateOpts = $.extend({}, defaultValidationOpts, validateOpts, this._processValidateOpts({
                    key: key,
                    value: value
                }, validateOpts));
                mapValidateCache[key] = validateOpts;
            }
            return true;
        }
        return false;
    };
    var oldSetup = proto.setup;
    var oldInit = proto.init;
    proto.setup = function () {
        this._initValidate = true;
        oldSetup.apply(this, arguments);
    };
    proto.init = function () {
        this._initValidation();
        this._initValidate = false;
        if (oldInit) {
            oldInit.apply(this, arguments);
        }
    };
    $.extend(Map.prototype, {
        _initValidation: function () {
            var self = this;
            var validateCache = getValidateFromCache.call(this);
            each(this.define, function (props, key) {
                if (props.validate && !validateCache[key]) {
                    initProperty.call(self, key, self[key]);
                }
            });
        },
        validate: function () {
            return this._validate();
        },
        _validate: function () {
            var validateOpts = getValidateFromCache.call(this);
            var processedOpts = {};
            var self = this;
            each(this.define, function (value, key) {
                if (value.validate) {
                    processedOpts[key] = resolveComputes({
                        key: key,
                        value: self.attr(key)
                    }, validateOpts[key]);
                }
            });
            var errors = validate.validate(this.serialize(), processedOpts);
            this.attr('errors', new ErrorsObj(errors));
            return isEmptyObject(errors);
        },
        _validateOne: function (item, opts) {
            var errors;
            var allowSet = true;
            errors = validate.once(item.value, $.extend({}, opts), item.key);
            if (errors && errors.length > 0) {
                if (!this.attr('errors')) {
                    this.attr('errors', new ErrorsObj({}));
                }
                this.attr('errors').attr(item.key, errors);
                if (opts.mustValidate === true) {
                    allowSet = false;
                }
            } else {
                if (this.attr('errors') && this.attr('errors').attr(item.key)) {
                    this.attr('errors').removeAttr(item.key);
                }
            }
            return allowSet;
        },
        _processValidateOpts: function (itemObj, opts) {
            var processedObj = {};
            var computes = [];
            var self = this;
            each(opts, function (item, key) {
                processedObj[key] = item;
                if (typeof item === 'function') {
                    var newCompute = compute($.proxy(item, self));
                    computes.push({
                        key: key,
                        compute: newCompute
                    });
                    processedObj[key] = newCompute;
                }
            });
            each(computes, function (item) {
                item.compute.bind('change', function () {
                    itemObj.value = self.attr(itemObj.key);
                    self._validateOne(itemObj, processedObj);
                });
            });
            return processedObj;
        }
    });
    proto.__set = function (prop, value, current, success, error) {
        var allowSet = true;
        var checkValidate = initProperty.call(this, prop, value);
        var validateOpts = getValidateFromCache.call(this)[prop];
        var mapIniting = this._initValidate;
        if (checkValidate !== false) {
            validateOpts = resolveComputes({
                key: prop,
                value: value
            }, validateOpts);
            if (validateOpts && !mapIniting || validateOpts && mapIniting && validateOpts.validateOnInit) {
                allowSet = this._validateOne({
                    key: prop,
                    value: value
                }, validateOpts);
            }
        }
        if (allowSet) {
            oldSet.call(this, prop, value, current, success, error);
        }
    };
});
/*validate.js@0.11.1#validate*/
(function (exports, module, define) {
    'use strict';
    var validate = function (attributes, constraints, options) {
        options = v.extend({}, v.options, options);
        var results = v.runValidations(attributes, constraints, options), attr, validator;
        for (attr in results) {
            for (validator in results[attr]) {
                if (v.isPromise(results[attr][validator])) {
                    throw new Error('Use validate.async if you want support for promises');
                }
            }
        }
        return validate.processValidationResults(results, options);
    };
    var v = validate;
    v.extend = function (obj) {
        [].slice.call(arguments, 1).forEach(function (source) {
            for (var attr in source) {
                obj[attr] = source[attr];
            }
        });
        return obj;
    };
    v.extend(validate, {
        version: {
            major: 0,
            minor: 11,
            patch: 1,
            metadata: null,
            toString: function () {
                var version = v.format('%{major}.%{minor}.%{patch}', v.version);
                if (!v.isEmpty(v.version.metadata)) {
                    version += '+' + v.version.metadata;
                }
                return version;
            }
        },
        Promise: typeof Promise !== 'undefined' ? Promise : null,
        EMPTY_STRING_REGEXP: /^\s*$/,
        runValidations: function (attributes, constraints, options) {
            var results = [], attr, validatorName, value, validators, validator, validatorOptions, error;
            if (v.isDomElement(attributes) || v.isJqueryElement(attributes)) {
                attributes = v.collectFormValues(attributes);
            }
            for (attr in constraints) {
                value = v.getDeepObjectValue(attributes, attr);
                validators = v.result(constraints[attr], value, attributes, attr, options, constraints);
                for (validatorName in validators) {
                    validator = v.validators[validatorName];
                    if (!validator) {
                        error = v.format('Unknown validator %{name}', { name: validatorName });
                        throw new Error(error);
                    }
                    validatorOptions = validators[validatorName];
                    validatorOptions = v.result(validatorOptions, value, attributes, attr, options, constraints);
                    if (!validatorOptions) {
                        continue;
                    }
                    results.push({
                        attribute: attr,
                        value: value,
                        validator: validatorName,
                        globalOptions: options,
                        attributes: attributes,
                        options: validatorOptions,
                        error: validator.call(validator, value, validatorOptions, attr, attributes, options)
                    });
                }
            }
            return results;
        },
        processValidationResults: function (errors, options) {
            errors = v.pruneEmptyErrors(errors, options);
            errors = v.expandMultipleErrors(errors, options);
            errors = v.convertErrorMessages(errors, options);
            var format = options.format || 'grouped';
            if (typeof v.formatters[format] === 'function') {
                errors = v.formatters[format](errors);
            } else {
                throw new Error(v.format('Unknown format %{format}', options));
            }
            return v.isEmpty(errors) ? undefined : errors;
        },
        async: function (attributes, constraints, options) {
            options = v.extend({}, v.async.options, options);
            var WrapErrors = options.wrapErrors || function (errors) {
                return errors;
            };
            if (options.cleanAttributes !== false) {
                attributes = v.cleanAttributes(attributes, constraints);
            }
            var results = v.runValidations(attributes, constraints, options);
            return new v.Promise(function (resolve, reject) {
                v.waitForResults(results).then(function () {
                    var errors = v.processValidationResults(results, options);
                    if (errors) {
                        reject(new WrapErrors(errors, options, attributes, constraints));
                    } else {
                        resolve(attributes);
                    }
                }, function (err) {
                    reject(err);
                });
            });
        },
        single: function (value, constraints, options) {
            options = v.extend({}, v.single.options, options, {
                format: 'flat',
                fullMessages: false
            });
            return v({ single: value }, { single: constraints }, options);
        },
        waitForResults: function (results) {
            return results.reduce(function (memo, result) {
                if (!v.isPromise(result.error)) {
                    return memo;
                }
                return memo.then(function () {
                    return result.error.then(function (error) {
                        result.error = error || null;
                    });
                });
            }, new v.Promise(function (r) {
                r();
            }));
        },
        result: function (value) {
            var args = [].slice.call(arguments, 1);
            if (typeof value === 'function') {
                value = value.apply(null, args);
            }
            return value;
        },
        isNumber: function (value) {
            return typeof value === 'number' && !isNaN(value);
        },
        isFunction: function (value) {
            return typeof value === 'function';
        },
        isInteger: function (value) {
            return v.isNumber(value) && value % 1 === 0;
        },
        isBoolean: function (value) {
            return typeof value === 'boolean';
        },
        isObject: function (obj) {
            return obj === Object(obj);
        },
        isDate: function (obj) {
            return obj instanceof Date;
        },
        isDefined: function (obj) {
            return obj !== null && obj !== undefined;
        },
        isPromise: function (p) {
            return !!p && v.isFunction(p.then);
        },
        isJqueryElement: function (o) {
            return o && v.isString(o.jquery);
        },
        isDomElement: function (o) {
            if (!o) {
                return false;
            }
            if (!o.querySelectorAll || !o.querySelector) {
                return false;
            }
            if (v.isObject(document) && o === document) {
                return true;
            }
            if (typeof HTMLElement === 'object') {
                return o instanceof HTMLElement;
            } else {
                return o && typeof o === 'object' && o !== null && o.nodeType === 1 && typeof o.nodeName === 'string';
            }
        },
        isEmpty: function (value) {
            var attr;
            if (!v.isDefined(value)) {
                return true;
            }
            if (v.isFunction(value)) {
                return false;
            }
            if (v.isString(value)) {
                return v.EMPTY_STRING_REGEXP.test(value);
            }
            if (v.isArray(value)) {
                return value.length === 0;
            }
            if (v.isDate(value)) {
                return false;
            }
            if (v.isObject(value)) {
                for (attr in value) {
                    return false;
                }
                return true;
            }
            return false;
        },
        format: v.extend(function (str, vals) {
            if (!v.isString(str)) {
                return str;
            }
            return str.replace(v.format.FORMAT_REGEXP, function (m0, m1, m2) {
                if (m1 === '%') {
                    return '%{' + m2 + '}';
                } else {
                    return String(vals[m2]);
                }
            });
        }, { FORMAT_REGEXP: /(%?)%\{([^\}]+)\}/g }),
        prettify: function (str) {
            if (v.isNumber(str)) {
                if (str * 100 % 1 === 0) {
                    return '' + str;
                } else {
                    return parseFloat(Math.round(str * 100) / 100).toFixed(2);
                }
            }
            if (v.isArray(str)) {
                return str.map(function (s) {
                    return v.prettify(s);
                }).join(', ');
            }
            if (v.isObject(str)) {
                return str.toString();
            }
            str = '' + str;
            return str.replace(/([^\s])\.([^\s])/g, '$1 $2').replace(/\\+/g, '').replace(/[_-]/g, ' ').replace(/([a-z])([A-Z])/g, function (m0, m1, m2) {
                return '' + m1 + ' ' + m2.toLowerCase();
            }).toLowerCase();
        },
        stringifyValue: function (value) {
            return v.prettify(value);
        },
        isString: function (value) {
            return typeof value === 'string';
        },
        isArray: function (value) {
            return {}.toString.call(value) === '[object Array]';
        },
        isHash: function (value) {
            return v.isObject(value) && !v.isArray(value) && !v.isFunction(value);
        },
        contains: function (obj, value) {
            if (!v.isDefined(obj)) {
                return false;
            }
            if (v.isArray(obj)) {
                return obj.indexOf(value) !== -1;
            }
            return value in obj;
        },
        unique: function (array) {
            if (!v.isArray(array)) {
                return array;
            }
            return array.filter(function (el, index, array) {
                return array.indexOf(el) == index;
            });
        },
        forEachKeyInKeypath: function (object, keypath, callback) {
            if (!v.isString(keypath)) {
                return undefined;
            }
            var key = '', i, escape = false;
            for (i = 0; i < keypath.length; ++i) {
                switch (keypath[i]) {
                case '.':
                    if (escape) {
                        escape = false;
                        key += '.';
                    } else {
                        object = callback(object, key, false);
                        key = '';
                    }
                    break;
                case '\\':
                    if (escape) {
                        escape = false;
                        key += '\\';
                    } else {
                        escape = true;
                    }
                    break;
                default:
                    escape = false;
                    key += keypath[i];
                    break;
                }
            }
            return callback(object, key, true);
        },
        getDeepObjectValue: function (obj, keypath) {
            if (!v.isObject(obj)) {
                return undefined;
            }
            return v.forEachKeyInKeypath(obj, keypath, function (obj, key) {
                if (v.isObject(obj)) {
                    return obj[key];
                }
            });
        },
        collectFormValues: function (form, options) {
            var values = {}, i, j, input, inputs, option, value;
            if (v.isJqueryElement(form)) {
                form = form[0];
            }
            if (!form) {
                return values;
            }
            options = options || {};
            inputs = form.querySelectorAll('input[name], textarea[name]');
            for (i = 0; i < inputs.length; ++i) {
                input = inputs.item(i);
                if (v.isDefined(input.getAttribute('data-ignored'))) {
                    continue;
                }
                value = v.sanitizeFormValue(input.value, options);
                if (input.type === 'number') {
                    value = value ? +value : null;
                } else if (input.type === 'checkbox') {
                    if (input.attributes.value) {
                        if (!input.checked) {
                            value = values[input.name] || null;
                        }
                    } else {
                        value = input.checked;
                    }
                } else if (input.type === 'radio') {
                    if (!input.checked) {
                        value = values[input.name] || null;
                    }
                }
                values[input.name] = value;
            }
            inputs = form.querySelectorAll('select[name]');
            for (i = 0; i < inputs.length; ++i) {
                input = inputs.item(i);
                if (input.multiple) {
                    value = [];
                    for (j in input.options) {
                        option = input.options[j];
                        if (option.selected) {
                            value.push(v.sanitizeFormValue(option.value, options));
                        }
                    }
                } else {
                    value = v.sanitizeFormValue(input.options[input.selectedIndex].value, options);
                }
                values[input.name] = value;
            }
            return values;
        },
        sanitizeFormValue: function (value, options) {
            if (options.trim && v.isString(value)) {
                value = value.trim();
            }
            if (options.nullify !== false && value === '') {
                return null;
            }
            return value;
        },
        capitalize: function (str) {
            if (!v.isString(str)) {
                return str;
            }
            return str[0].toUpperCase() + str.slice(1);
        },
        pruneEmptyErrors: function (errors) {
            return errors.filter(function (error) {
                return !v.isEmpty(error.error);
            });
        },
        expandMultipleErrors: function (errors) {
            var ret = [];
            errors.forEach(function (error) {
                if (v.isArray(error.error)) {
                    error.error.forEach(function (msg) {
                        ret.push(v.extend({}, error, { error: msg }));
                    });
                } else {
                    ret.push(error);
                }
            });
            return ret;
        },
        convertErrorMessages: function (errors, options) {
            options = options || {};
            var ret = [];
            errors.forEach(function (errorInfo) {
                var error = v.result(errorInfo.error, errorInfo.value, errorInfo.attribute, errorInfo.options, errorInfo.attributes, errorInfo.globalOptions);
                if (!v.isString(error)) {
                    ret.push(errorInfo);
                    return;
                }
                if (error[0] === '^') {
                    error = error.slice(1);
                } else if (options.fullMessages !== false) {
                    error = v.capitalize(v.prettify(errorInfo.attribute)) + ' ' + error;
                }
                error = error.replace(/\\\^/g, '^');
                error = v.format(error, { value: v.stringifyValue(errorInfo.value) });
                ret.push(v.extend({}, errorInfo, { error: error }));
            });
            return ret;
        },
        groupErrorsByAttribute: function (errors) {
            var ret = {};
            errors.forEach(function (error) {
                var list = ret[error.attribute];
                if (list) {
                    list.push(error);
                } else {
                    ret[error.attribute] = [error];
                }
            });
            return ret;
        },
        flattenErrorsToArray: function (errors) {
            return errors.map(function (error) {
                return error.error;
            }).filter(function (value, index, self) {
                return self.indexOf(value) === index;
            });
        },
        cleanAttributes: function (attributes, whitelist) {
            function whitelistCreator(obj, key, last) {
                if (v.isObject(obj[key])) {
                    return obj[key];
                }
                return obj[key] = last ? true : {};
            }
            function buildObjectWhitelist(whitelist) {
                var ow = {}, lastObject, attr;
                for (attr in whitelist) {
                    if (!whitelist[attr]) {
                        continue;
                    }
                    v.forEachKeyInKeypath(ow, attr, whitelistCreator);
                }
                return ow;
            }
            function cleanRecursive(attributes, whitelist) {
                if (!v.isObject(attributes)) {
                    return attributes;
                }
                var ret = v.extend({}, attributes), w, attribute;
                for (attribute in attributes) {
                    w = whitelist[attribute];
                    if (v.isObject(w)) {
                        ret[attribute] = cleanRecursive(ret[attribute], w);
                    } else if (!w) {
                        delete ret[attribute];
                    }
                }
                return ret;
            }
            if (!v.isObject(whitelist) || !v.isObject(attributes)) {
                return {};
            }
            whitelist = buildObjectWhitelist(whitelist);
            return cleanRecursive(attributes, whitelist);
        },
        exposeModule: function (validate, root, exports, module, define) {
            if (exports) {
                if (module && module.exports) {
                    exports = module.exports = validate;
                }
                exports.validate = validate;
            } else {
                root.validate = validate;
                if (validate.isFunction(define) && define.amd) {
                    define('validate.js@0.11.1#validate', [], function () {
                        return validate;
                    });
                }
            }
        },
        warn: function (msg) {
            if (typeof console !== 'undefined' && console.warn) {
                console.warn('[validate.js] ' + msg);
            }
        },
        error: function (msg) {
            if (typeof console !== 'undefined' && console.error) {
                console.error('[validate.js] ' + msg);
            }
        }
    });
    validate.validators = {
        presence: function (value, options) {
            options = v.extend({}, this.options, options);
            if (options.allowEmpty ? !v.isDefined(value) : v.isEmpty(value)) {
                return options.message || this.message || 'can\'t be blank';
            }
        },
        length: function (value, options, attribute) {
            if (!v.isDefined(value)) {
                return;
            }
            options = v.extend({}, this.options, options);
            var is = options.is, maximum = options.maximum, minimum = options.minimum, tokenizer = options.tokenizer || function (val) {
                    return val;
                }, err, errors = [];
            value = tokenizer(value);
            var length = value.length;
            if (!v.isNumber(length)) {
                v.error(v.format('Attribute %{attr} has a non numeric value for `length`', { attr: attribute }));
                return options.message || this.notValid || 'has an incorrect length';
            }
            if (v.isNumber(is) && length !== is) {
                err = options.wrongLength || this.wrongLength || 'is the wrong length (should be %{count} characters)';
                errors.push(v.format(err, { count: is }));
            }
            if (v.isNumber(minimum) && length < minimum) {
                err = options.tooShort || this.tooShort || 'is too short (minimum is %{count} characters)';
                errors.push(v.format(err, { count: minimum }));
            }
            if (v.isNumber(maximum) && length > maximum) {
                err = options.tooLong || this.tooLong || 'is too long (maximum is %{count} characters)';
                errors.push(v.format(err, { count: maximum }));
            }
            if (errors.length > 0) {
                return options.message || errors;
            }
        },
        numericality: function (value, options) {
            if (!v.isDefined(value)) {
                return;
            }
            options = v.extend({}, this.options, options);
            var errors = [], name, count, checks = {
                    greaterThan: function (v, c) {
                        return v > c;
                    },
                    greaterThanOrEqualTo: function (v, c) {
                        return v >= c;
                    },
                    equalTo: function (v, c) {
                        return v === c;
                    },
                    lessThan: function (v, c) {
                        return v < c;
                    },
                    lessThanOrEqualTo: function (v, c) {
                        return v <= c;
                    },
                    divisibleBy: function (v, c) {
                        return v % c === 0;
                    }
                };
            if (v.isString(value) && options.strict) {
                var pattern = '^(0|[1-9]\\d*)';
                if (!options.onlyInteger) {
                    pattern += '(\\.\\d+)?';
                }
                pattern += '$';
                if (!new RegExp(pattern).test(value)) {
                    return options.message || options.notValid || this.notValid || this.message || 'must be a valid number';
                }
            }
            if (options.noStrings !== true && v.isString(value) && !v.isEmpty(value)) {
                value = +value;
            }
            if (!v.isNumber(value)) {
                return options.message || options.notValid || this.notValid || this.message || 'is not a number';
            }
            if (options.onlyInteger && !v.isInteger(value)) {
                return options.message || options.notInteger || this.notInteger || this.message || 'must be an integer';
            }
            for (name in checks) {
                count = options[name];
                if (v.isNumber(count) && !checks[name](value, count)) {
                    var key = 'not' + v.capitalize(name);
                    var msg = options[key] || this[key] || this.message || 'must be %{type} %{count}';
                    errors.push(v.format(msg, {
                        count: count,
                        type: v.prettify(name)
                    }));
                }
            }
            if (options.odd && value % 2 !== 1) {
                errors.push(options.notOdd || this.notOdd || this.message || 'must be odd');
            }
            if (options.even && value % 2 !== 0) {
                errors.push(options.notEven || this.notEven || this.message || 'must be even');
            }
            if (errors.length) {
                return options.message || errors;
            }
        },
        datetime: v.extend(function (value, options) {
            if (!v.isFunction(this.parse) || !v.isFunction(this.format)) {
                throw new Error('Both the parse and format functions needs to be set to use the datetime/date validator');
            }
            if (!v.isDefined(value)) {
                return;
            }
            options = v.extend({}, this.options, options);
            var err, errors = [], earliest = options.earliest ? this.parse(options.earliest, options) : NaN, latest = options.latest ? this.parse(options.latest, options) : NaN;
            value = this.parse(value, options);
            if (isNaN(value) || options.dateOnly && value % 86400000 !== 0) {
                err = options.notValid || options.message || this.notValid || 'must be a valid date';
                return v.format(err, { value: arguments[0] });
            }
            if (!isNaN(earliest) && value < earliest) {
                err = options.tooEarly || options.message || this.tooEarly || 'must be no earlier than %{date}';
                err = v.format(err, {
                    value: this.format(value, options),
                    date: this.format(earliest, options)
                });
                errors.push(err);
            }
            if (!isNaN(latest) && value > latest) {
                err = options.tooLate || options.message || this.tooLate || 'must be no later than %{date}';
                err = v.format(err, {
                    date: this.format(latest, options),
                    value: this.format(value, options)
                });
                errors.push(err);
            }
            if (errors.length) {
                return v.unique(errors);
            }
        }, {
            parse: null,
            format: null
        }),
        date: function (value, options) {
            options = v.extend({}, options, { dateOnly: true });
            return v.validators.datetime.call(v.validators.datetime, value, options);
        },
        format: function (value, options) {
            if (v.isString(options) || options instanceof RegExp) {
                options = { pattern: options };
            }
            options = v.extend({}, this.options, options);
            var message = options.message || this.message || 'is invalid', pattern = options.pattern, match;
            if (!v.isDefined(value)) {
                return;
            }
            if (!v.isString(value)) {
                return message;
            }
            if (v.isString(pattern)) {
                pattern = new RegExp(options.pattern, options.flags);
            }
            match = pattern.exec(value);
            if (!match || match[0].length != value.length) {
                return message;
            }
        },
        inclusion: function (value, options) {
            if (!v.isDefined(value)) {
                return;
            }
            if (v.isArray(options)) {
                options = { within: options };
            }
            options = v.extend({}, this.options, options);
            if (v.contains(options.within, value)) {
                return;
            }
            var message = options.message || this.message || '^%{value} is not included in the list';
            return v.format(message, { value: value });
        },
        exclusion: function (value, options) {
            if (!v.isDefined(value)) {
                return;
            }
            if (v.isArray(options)) {
                options = { within: options };
            }
            options = v.extend({}, this.options, options);
            if (!v.contains(options.within, value)) {
                return;
            }
            var message = options.message || this.message || '^%{value} is restricted';
            return v.format(message, { value: value });
        },
        email: v.extend(function (value, options) {
            options = v.extend({}, this.options, options);
            var message = options.message || this.message || 'is not a valid email';
            if (!v.isDefined(value)) {
                return;
            }
            if (!v.isString(value)) {
                return message;
            }
            if (!this.PATTERN.exec(value)) {
                return message;
            }
        }, { PATTERN: /^[a-z0-9\u007F-\uffff!#$%&'*+\/=?^_`{|}~-]+(?:\.[a-z0-9\u007F-\uffff!#$%&'*+\/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z]{2,}$/i }),
        equality: function (value, options, attribute, attributes) {
            if (!v.isDefined(value)) {
                return;
            }
            if (v.isString(options)) {
                options = { attribute: options };
            }
            options = v.extend({}, this.options, options);
            var message = options.message || this.message || 'is not equal to %{attribute}';
            if (v.isEmpty(options.attribute) || !v.isString(options.attribute)) {
                throw new Error('The attribute must be a non empty string');
            }
            var otherValue = v.getDeepObjectValue(attributes, options.attribute), comparator = options.comparator || function (v1, v2) {
                    return v1 === v2;
                };
            if (!comparator(value, otherValue, options, attribute, attributes)) {
                return v.format(message, { attribute: v.prettify(options.attribute) });
            }
        },
        url: function (value, options) {
            if (!v.isDefined(value)) {
                return;
            }
            options = v.extend({}, this.options, options);
            var message = options.message || this.message || 'is not a valid url', schemes = options.schemes || this.schemes || [
                    'http',
                    'https'
                ], allowLocal = options.allowLocal || this.allowLocal || false;
            if (!v.isString(value)) {
                return message;
            }
            var regex = '^' + '(?:(?:' + schemes.join('|') + ')://)' + '(?:\\S+(?::\\S*)?@)?' + '(?:';
            var tld = '(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))';
            if (allowLocal) {
                tld += '?';
            } else {
                regex += '(?!(?:10|127)(?:\\.\\d{1,3}){3})' + '(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})' + '(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})';
            }
            regex += '(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])' + '(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}' + '(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))' + '|' + '(?:(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)' + '(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*' + tld + ')' + '(?::\\d{2,5})?' + '(?:[/?#]\\S*)?' + '$';
            var PATTERN = new RegExp(regex, 'i');
            if (!PATTERN.exec(value)) {
                return message;
            }
        }
    };
    validate.formatters = {
        detailed: function (errors) {
            return errors;
        },
        flat: v.flattenErrorsToArray,
        grouped: function (errors) {
            var attr;
            errors = v.groupErrorsByAttribute(errors);
            for (attr in errors) {
                errors[attr] = v.flattenErrorsToArray(errors[attr]);
            }
            return errors;
        },
        constraint: function (errors) {
            var attr;
            errors = v.groupErrorsByAttribute(errors);
            for (attr in errors) {
                errors[attr] = errors[attr].map(function (result) {
                    return result.validator;
                }).sort();
            }
            return errors;
        }
    };
    validate.exposeModule(validate, this, exports, module, define);
}.call(this, typeof exports !== 'undefined' ? exports : null, typeof module !== 'undefined' ? module : null, typeof define !== 'undefined' ? define : null));
/*can-validate-legacy@1.1.0#shims/validatejs*/
define('can-validate-legacy@1.1.0#shims/validatejs', function (require, exports, module) {
    var validate = require('can-validate-legacy');
    var validatejs = require('validate.js');
    var processOptions = function (opts) {
        if (typeof opts.required !== 'undefined') {
            opts.presence = opts.required;
            delete opts.required;
        }
        if (opts.hasOwnProperty('mustValidate')) {
            delete opts.mustValidate;
        }
        if (opts.hasOwnProperty('validateOnInit')) {
            delete opts.validateOnInit;
        }
        return opts;
    };
    var shim = {
        once: function (value, options, name) {
            var errors = [];
            var opts = [];
            var validationOpts = [];
            if (name) {
                opts[name] = value;
                validationOpts[name] = processOptions(options);
                errors = validatejs(opts, validationOpts);
                if (errors) {
                    errors = errors[name];
                }
            } else {
                errors = validatejs.single(value, processOptions(options));
            }
            return errors;
        },
        isValid: function (value, options) {
            var errors = validatejs.single(value, processOptions(options)) || [];
            return errors.length === 0;
        },
        validate: function (values, options) {
            var valueKeys = Object.keys(values);
            var processedOpts = {};
            for (var i = 0; i < valueKeys.length; i++) {
                var prop = valueKeys[i];
                if (options[prop]) {
                    processedOpts[prop] = processOptions(options[prop]);
                }
            }
            return validatejs(values, processedOpts);
        }
    };
    validate.register('validatejs', shim);
});
/*can-validate-legacy@1.1.0#can-validate-test*/
define('can-validate-legacy@1.1.0#can-validate-test', function (require, exports, module) {
    var namespace = require('can-util/namespace');
    var Map = require('can-map');
    var isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');
    var QUnit = require('steal-qunit');
    require('can-map-define');
    require('can-validate-legacy');
    require('can-validate-legacy/map/validate/');
    require('can-validate-legacy/shims/validatejs');
    var validatedMap;
    var secondaryMap;
    var ValidatedMap = Map.extend({
        define: {
            myNumber: {
                value: 100,
                validate: { required: true }
            },
            computedProp: {
                validate: {
                    required: function () {
                        return this.attr('isRequired');
                    }
                },
                value: ''
            },
            isRequired: {
                value: false,
                type: 'boolean'
            }
        }
    });
    QUnit.module('Map Validate Plugin');
    QUnit.test('when validateOnInit is not set, it should not run validation', function () {
        validatedMap = new ValidatedMap();
        QUnit.ok(isEmptyObject(validatedMap.errors));
    });
    QUnit.test('validations run when value is set', function () {
        validatedMap = new ValidatedMap();
        validatedMap.attr('myNumber', '');
        QUnit.equal(validatedMap.errors.myNumber.length, 1);
    });
    QUnit.test('when validate method is called, resolves computes before calling Validate method', function () {
        validatedMap = new ValidatedMap({
            isRequired: true,
            myNumber: 0
        });
        var success = false;
        try {
            validatedMap.validate();
            success = true;
        } catch (err) {
            success = err;
        }
        QUnit.ok(success);
    });
    QUnit.test('when creating multiple instances of the same map, each instance is discrete', function () {
        validatedMap = new ValidatedMap();
        validatedMap.attr('isRequired', true);
        secondaryMap = new ValidatedMap();
        secondaryMap.attr('computedProp', '');
        QUnit.equal(isEmptyObject(secondaryMap.attr('errors')), true, 'control map validates successfully');
        validatedMap.attr('computedProp', '');
        QUnit.equal(validatedMap.attr('computedProp'), '');
        QUnit.ok(typeof validatedMap.attr('errors.computedProp') !== 'undefined', 'other map validates, sets error');
    });
    var ShimValidatedMap = Map.extend({
        define: {
            myNumber: {
                value: 'test',
                validate: {
                    required: true,
                    numericality: true,
                    validateOnInit: true
                }
            },
            myString: {
                value: '12345',
                validate: {
                    required: true,
                    length: 2
                }
            }
        }
    });
    QUnit.module('Validate.js Shim', {
        setup: function () {
            validatedMap = new ShimValidatedMap({});
        }
    });
    QUnit.test('validates on init by default', function () {
        QUnit.equal(validatedMap.attr('errors').myNumber.length, 1);
    });
    QUnit.test('validates on init by default', function () {
        QUnit.equal(validatedMap.errors.myNumber.length, 1);
    });
    QUnit.test('does not validate on init, when validate on init is false', function () {
        QUnit.equal(validatedMap.errors.myString, undefined);
    });
    QUnit.test('runs validation on value', function () {
        validatedMap.attr('myString', '');
        QUnit.equal(validatedMap.errors.myString.length, 1);
    });
});
/*can-legacy-view-helpers@0.6.0#src/view*/
define('can-legacy-view-helpers@0.6.0#src/view', function (require, exports, module) {
    var isFunction = require('can-util/js/is-function/is-function'), makeArray = require('can-util/js/make-array/make-array'), deepAssign = require('can-util/js/deep-assign/deep-assign'), canFrag = require('can-util/dom/frag/frag'), each = require('can-util/js/each/each'), hookupId = 1;
    var $view = function (view, data, helpers, callback) {
        if (isFunction(helpers)) {
            callback = helpers;
            helpers = undefined;
        }
        return $view.renderAs('fragment', view, data, helpers, callback);
    };
    deepAssign($view, {
        frag: function (result, parentNode) {
            return $view.hookup($view.fragment(result), parentNode);
        },
        fragment: function (result) {
            return canFrag(result, document);
        },
        toId: function (src) {
            return src.toString().split(/\/|\./g).map(function (part) {
                if (part) {
                    return part;
                }
            }).join('_');
        },
        toStr: function (txt) {
            return txt == null ? '' : '' + txt;
        },
        hookup: function (fragment, parentNode) {
            var hookupEls = [], id, func;
            each(fragment.childNodes ? makeArray(fragment.childNodes) : fragment, function (node) {
                if (node.nodeType === 1) {
                    hookupEls.push(node);
                    hookupEls.push.apply(hookupEls, makeArray(node.getElementsByTagName('*')));
                }
            });
            each(hookupEls, function (el) {
                if (el.getAttribute && (id = el.getAttribute('data-view-id')) && (func = $view.hookups[id])) {
                    func(el, parentNode, id);
                    delete $view.hookups[id];
                    el.removeAttribute('data-view-id');
                }
            });
            return fragment;
        },
        hookups: {},
        hook: function (cb) {
            $view.hookups[++hookupId] = cb;
            return ' data-view-id=\'' + hookupId + '\'';
        },
        cached: {},
        cachedRenderers: {},
        simpleHelper: function (fn) {
            return function () {
                var realArgs = [];
                var fnArgs = arguments;
                each(fnArgs, function (val, i) {
                    if (i <= fnArgs.length) {
                        while (val && val.isComputed) {
                            val = val();
                        }
                        realArgs.push(val);
                    }
                });
                return fn.apply(this, realArgs);
            };
        }
    });
    module.exports = $view;
});
/*can-legacy-view-helpers@0.6.0#src/node_list*/
define('can-legacy-view-helpers@0.6.0#src/node_list', function (require, exports, module) {
    var makeArray = require('can-util/js/make-array/make-array');
    var CID = require('can-cid');
    var each = require('can-util/js/each/each');
    var domMutate = require('can-util/dom/mutate/mutate');
    var canExpando = true, readId, nodeLists;
    try {
        document.createTextNode('')._ = 0;
    } catch (ex) {
        canExpando = false;
    }
    var nodeMap = {}, textNodeMap = {}, expando = 'ejs_' + Math.random(), _id = 0, id = function (node, localMap) {
            var _textNodeMap = localMap || textNodeMap;
            var id = readId(node, _textNodeMap);
            if (id) {
                return id;
            } else {
                if (canExpando || node.nodeType !== 3) {
                    ++_id;
                    return node[expando] = (node.nodeName ? 'element_' : 'obj_') + _id;
                } else {
                    ++_id;
                    _textNodeMap['text_' + _id] = node;
                    return 'text_' + _id;
                }
            }
        };
    readId = function (node, textNodeMap) {
        if (canExpando || node.nodeType !== 3) {
            return node[expando];
        } else {
            for (var textNodeID in textNodeMap) {
                if (textNodeMap[textNodeID] === node) {
                    return textNodeID;
                }
            }
        }
    };
    var splice = [].splice, push = [].push, itemsInChildListTree = function (list) {
            var count = 0;
            for (var i = 0, len = list.length; i < len; i++) {
                var item = list[i];
                if (item.nodeType) {
                    count++;
                } else {
                    count += itemsInChildListTree(item);
                }
            }
            return count;
        }, replacementMap = function (replacements, idMap) {
            var map = {};
            for (var i = 0, len = replacements.length; i < len; i++) {
                var node = nodeLists.first(replacements[i]);
                map[id(node, idMap)] = replacements[i];
            }
            return map;
        }, addUnfoundAsDeepChildren = function (list, rMap, foundIds) {
            for (var repId in rMap) {
                if (!foundIds[repId]) {
                    list.newDeepChildren.push(rMap[repId]);
                }
            }
        };
    nodeLists = {
        id: id,
        update: function (nodeList, newNodes) {
            var oldNodes = nodeLists.unregisterChildren(nodeList);
            newNodes = makeArray(newNodes);
            var oldListLength = nodeList.length;
            splice.apply(nodeList, [
                0,
                oldListLength
            ].concat(newNodes));
            if (nodeList.replacements) {
                nodeLists.nestReplacements(nodeList);
                nodeList.deepChildren = nodeList.newDeepChildren;
                nodeList.newDeepChildren = [];
            } else {
                nodeLists.nestList(nodeList);
            }
            return oldNodes;
        },
        nestReplacements: function (list) {
            var index = 0, idMap = {}, rMap = replacementMap(list.replacements, idMap), rCount = list.replacements.length, foundIds = {};
            while (index < list.length && rCount) {
                var node = list[index], nodeId = readId(node, idMap), replacement = rMap[nodeId];
                if (replacement) {
                    list.splice(index, itemsInChildListTree(replacement), replacement);
                    foundIds[nodeId] = true;
                    rCount--;
                }
                index++;
            }
            if (rCount) {
                addUnfoundAsDeepChildren(list, rMap, foundIds);
            }
            list.replacements = [];
        },
        nestList: function (list) {
            var index = 0;
            while (index < list.length) {
                var node = list[index], childNodeList = nodeMap[id(node)];
                if (childNodeList) {
                    if (childNodeList !== list) {
                        list.splice(index, itemsInChildListTree(childNodeList), childNodeList);
                    }
                } else {
                    nodeMap[id(node)] = list;
                }
                index++;
            }
        },
        last: function (nodeList) {
            var last = nodeList[nodeList.length - 1];
            if (last.nodeType) {
                return last;
            } else {
                return nodeLists.last(last);
            }
        },
        first: function (nodeList) {
            var first = nodeList[0];
            if (first.nodeType) {
                return first;
            } else {
                return nodeLists.first(first);
            }
        },
        flatten: function (nodeList) {
            var items = [];
            for (var i = 0; i < nodeList.length; i++) {
                var item = nodeList[i];
                if (item.nodeType) {
                    items.push(item);
                } else {
                    items.push.apply(items, nodeLists.flatten(item));
                }
            }
            return items;
        },
        register: function (nodeList, unregistered, parent, directlyNested) {
            CID(nodeList);
            nodeList.unregistered = unregistered;
            nodeList.parentList = parent;
            nodeList.nesting = parent && typeof parent.nesting !== 'undefined' ? parent.nesting + 1 : 0;
            if (parent) {
                nodeList.deepChildren = [];
                nodeList.newDeepChildren = [];
                nodeList.replacements = [];
                if (parent !== true) {
                    if (directlyNested) {
                        parent.replacements.push(nodeList);
                    } else {
                        parent.newDeepChildren.push(nodeList);
                    }
                }
            } else {
                nodeLists.nestList(nodeList);
            }
            return nodeList;
        },
        unregisterChildren: function (nodeList) {
            var nodes = [];
            each(nodeList, function (node) {
                if (node.nodeType) {
                    if (!nodeList.replacements) {
                        delete nodeMap[id(node)];
                    }
                    nodes.push(node);
                } else {
                    push.apply(nodes, nodeLists.unregister(node, true));
                }
            });
            each(nodeList.deepChildren, function (nodeList) {
                nodeLists.unregister(nodeList, true);
            });
            return nodes;
        },
        unregister: function (nodeList, isChild) {
            var nodes = nodeLists.unregisterChildren(nodeList, true);
            if (nodeList.unregistered) {
                var unregisteredCallback = nodeList.unregistered;
                nodeList.replacements = nodeList.unregistered = null;
                if (!isChild) {
                    var deepChildren = nodeList.parentList && nodeList.parentList.deepChildren;
                    if (deepChildren) {
                        var index = deepChildren.indexOf(nodeList);
                        if (index !== -1) {
                            deepChildren.splice(index, 1);
                        }
                    }
                }
                unregisteredCallback();
            }
            return nodes;
        },
        nodeMap: nodeMap,
        after: function (oldElements, newFrag) {
            var last = oldElements[oldElements.length - 1];
            if (last.nextSibling) {
                domMutate.insertBefore.call(last.parentNode, newFrag, last.nextSibling);
            } else {
                domMutate.appendChild.call(last.parentNode, newFrag);
            }
        },
        replace: function (oldElements, newFrag) {
            var selectedValue, parentNode = oldElements[0].parentNode;
            if (parentNode.nodeName.toUpperCase() === 'SELECT' && parentNode.selectedIndex >= 0) {
                selectedValue = parentNode.value;
            }
            if (oldElements.length === 1) {
                domMutate.replaceChild.call(parentNode, newFrag, oldElements[0]);
            } else {
                nodeLists.after(oldElements, newFrag);
                nodeLists.remove(oldElements);
            }
            if (selectedValue !== undefined) {
                parentNode.value = selectedValue;
            }
        },
        remove: function (elementsToBeRemoved) {
            var parent = elementsToBeRemoved[0] && elementsToBeRemoved[0].parentNode;
            each(elementsToBeRemoved, function (child) {
                domMutate.removeChild.call(parent, child);
            });
        }
    };
    module.exports = nodeLists;
});
/*can-legacy-view-helpers@0.6.0#src/elements*/
define('can-legacy-view-helpers@0.6.0#src/elements', function (require, exports, module) {
    var nodeLists = require('./node_list');
    var doc = typeof document !== 'undefined' ? document : null;
    var elements = {
        tagToContentPropMap: {
            option: doc && 'textContent' in document.createElement('option') ? 'textContent' : 'innerText',
            textarea: 'value'
        },
        tagMap: {
            '': 'span',
            colgroup: 'col',
            table: 'tbody',
            tr: 'td',
            ol: 'li',
            ul: 'li',
            tbody: 'tr',
            thead: 'tr',
            tfoot: 'tr',
            select: 'option',
            optgroup: 'option'
        },
        reverseTagMap: {
            col: 'colgroup',
            tr: 'tbody',
            option: 'select',
            td: 'tr',
            th: 'tr',
            li: 'ul'
        },
        selfClosingTags: { col: true },
        getParentNode: function (el, defaultParentNode) {
            return defaultParentNode && el.parentNode.nodeType === 11 ? defaultParentNode : el.parentNode;
        },
        contentText: function (text) {
            if (typeof text === 'string') {
                return text;
            }
            if (!text && text !== 0) {
                return '';
            }
            return '' + text;
        },
        after: nodeLists.after,
        replace: nodeLists.replace
    };
    module.exports = elements;
});
/*can-legacy-view-helpers@0.6.0#src/live*/
define('can-legacy-view-helpers@0.6.0#src/live', function (require, exports, module) {
    var elements = require('./elements');
    var nodeLists = require('./node_list');
    var parser = require('can-view-parser');
    var diff = require('can-util/js/diff/diff');
    var view = require('./view');
    var domEvent = require('can-util/dom/events/events');
    var canFrag = require('can-util/dom/frag/frag');
    var makeArray = require('can-util/js/make-array/make-array');
    var each = require('can-util/js/each/each');
    var canCompute = require('can-compute');
    var domAttr = require('can-util/dom/attr/attr');
    var domData = require('can-util/dom/data/data');
    var domMutate = require('can-util/dom/mutate/mutate');
    var canBatch = require('can-event/batch/batch');
    require('can-util/dom/events/removed/removed');
    var newLine = /(\r|\n)+/g;
    var getValue = function (val) {
        var regexp = /^["'].*["']$/;
        val = val.replace(elements.attrReg, '').replace(newLine, '');
        return regexp.test(val) ? val.substr(1, val.length - 2) : val;
    };
    var setup = function (el, bind, unbind) {
            var data;
            var tornDown = false, teardown = function () {
                    if (!tornDown) {
                        tornDown = true;
                        unbind(data);
                        domEvent.removeEventListener.call(el, 'removed', teardown);
                    }
                    return true;
                };
            data = {
                teardownCheck: function (parent) {
                    return parent ? false : teardown();
                }
            };
            domEvent.addEventListener.call(el, 'removed', teardown);
            bind(data);
            return data;
        }, getChildNodes = function (node) {
            var childNodes = node.childNodes;
            if ('length' in childNodes) {
                return childNodes;
            } else {
                var cur = node.firstChild;
                var nodes = [];
                while (cur) {
                    nodes.push(cur);
                    cur = cur.nextSibling;
                }
                return nodes;
            }
        }, listen = function (el, compute, change) {
            return setup(el, function () {
                compute.computeInstance.bind('change', change);
            }, function (data) {
                compute.computeInstance.unbind('change', change);
                if (data.nodeList) {
                    nodeLists.unregister(data.nodeList);
                }
            });
        }, getAttributeParts = function (newVal) {
            var attrs = {}, attr;
            parser.parseAttrs(newVal, {
                attrStart: function (name) {
                    attrs[name] = '';
                    attr = name;
                },
                attrValue: function (value) {
                    attrs[attr] += value;
                },
                attrEnd: function () {
                }
            });
            return attrs;
        }, splice = [].splice, isNode = function (obj) {
            return obj && obj.nodeType;
        }, addTextNodeIfNoChildren = function (frag) {
            if (!frag.firstChild) {
                frag.appendChild(frag.ownerDocument.createTextNode(''));
            }
        }, getLiveFragment = function (itemHTML) {
            var gotText = typeof itemHTML === 'string', itemFrag = canFrag(itemHTML);
            return gotText ? view.hookup(itemFrag) : itemFrag;
        }, renderAndAddToNodeLists = function (newNodeLists, parentNodeList, render, context, args) {
            var itemNodeList = [];
            if (parentNodeList) {
                nodeLists.register(itemNodeList, null, true, true);
                itemNodeList.parentList = parentNodeList;
                itemNodeList.expression = '#each SUBEXPRESSION';
            }
            var itemHTML = render.apply(context, args.concat([itemNodeList])), itemFrag = getLiveFragment(itemHTML);
            var childNodes = makeArray(getChildNodes(itemFrag));
            if (parentNodeList) {
                nodeLists.update(itemNodeList, childNodes);
                newNodeLists.push(itemNodeList);
            } else {
                newNodeLists.push(nodeLists.register(childNodes));
            }
            return itemFrag;
        }, removeFromNodeList = function (masterNodeList, index, length) {
            var removedMappings = masterNodeList.splice(index + 1, length), itemsToRemove = [];
            each(removedMappings, function (nodeList) {
                var nodesToRemove = nodeLists.unregister(nodeList);
                [].push.apply(itemsToRemove, nodesToRemove);
            });
            return itemsToRemove;
        }, addFalseyIfEmpty = function (list, falseyRender, masterNodeList, nodeList) {
            if (falseyRender && list.length === 0) {
                var falseyNodeLists = [];
                var falseyFrag = renderAndAddToNodeLists(falseyNodeLists, nodeList, falseyRender, list, [list]);
                elements.after([masterNodeList[0]], falseyFrag);
                masterNodeList.push(falseyNodeLists[0]);
            }
        }, childMutationCallbacks = {};
    var live = {
        registerChildMutationCallback: function (tag, callback) {
            if (callback) {
                childMutationCallbacks[tag] = callback;
            } else {
                return childMutationCallbacks[tag];
            }
        },
        callChildMutationCallback: function (el) {
            var callback = el && childMutationCallbacks[el.nodeName.toLowerCase()];
            if (callback) {
                callback(el);
            }
        },
        list: function (el, compute, render, context, parentNode, nodeList, falseyRender) {
            var remove, text, list, data;
            var masterNodeList = nodeList || [el], indexMap = [], afterPreviousEvents = false, isTornDown = false, add = function (ev, items, index) {
                    if (!afterPreviousEvents) {
                        return;
                    }
                    var frag = text.ownerDocument.createDocumentFragment(), newNodeLists = [], newIndicies = [];
                    each(items, function (item, key) {
                        var itemIndex = canCompute(key + index), itemFrag = renderAndAddToNodeLists(newNodeLists, nodeList, render, context, [
                                item,
                                itemIndex
                            ]);
                        frag.appendChild(itemFrag);
                        newIndicies.push(itemIndex);
                    });
                    var masterListIndex = index + 1;
                    if (!indexMap.length) {
                        var falseyItemsToRemove = removeFromNodeList(masterNodeList, 0, masterNodeList.length - 1);
                        nodeLists.remove(falseyItemsToRemove);
                    }
                    if (!masterNodeList[masterListIndex]) {
                        elements.after(masterListIndex === 1 ? [text] : [nodeLists.last(masterNodeList[masterListIndex - 1])], frag);
                    } else {
                        var el = nodeLists.first(masterNodeList[masterListIndex]);
                        domMutate.insertBefore.call(el.parentNode, frag, el);
                    }
                    splice.apply(masterNodeList, [
                        masterListIndex,
                        0
                    ].concat(newNodeLists));
                    splice.apply(indexMap, [
                        index,
                        0
                    ].concat(newIndicies));
                    for (var i = index + newIndicies.length, len = indexMap.length; i < len; i++) {
                        indexMap[i](i);
                    }
                    if (ev.callChildMutationCallback !== false) {
                        live.callChildMutationCallback(text.parentNode);
                    }
                }, set = function (ev, newVal, index) {
                    remove({}, { length: 1 }, index, true);
                    add({}, [newVal], index);
                };
            remove = function (ev, items, index, duringTeardown, fullTeardown) {
                if (!afterPreviousEvents) {
                    return;
                }
                if (!duringTeardown && data.teardownCheck(text.parentNode)) {
                    return;
                }
                if (index < 0) {
                    index = indexMap.length + index;
                }
                var itemsToRemove = removeFromNodeList(masterNodeList, index, items.length);
                indexMap.splice(index, items.length);
                for (var i = index, len = indexMap.length; i < len; i++) {
                    indexMap[i](i);
                }
                if (!fullTeardown) {
                    addFalseyIfEmpty(list, falseyRender, masterNodeList, nodeList);
                    nodeLists.remove(itemsToRemove);
                    if (ev.callChildMutationCallback !== false) {
                        live.callChildMutationCallback(text.parentNode);
                    }
                } else {
                    nodeLists.unregister(masterNodeList);
                }
            };
            var move = function (ev, item, newIndex, currentIndex) {
                if (!afterPreviousEvents) {
                    return;
                }
                newIndex = newIndex + 1;
                currentIndex = currentIndex + 1;
                var referenceNodeList = masterNodeList[newIndex];
                var movedElements = canFrag(nodeLists.flatten(masterNodeList[currentIndex]));
                var referenceElement;
                if (currentIndex < newIndex) {
                    referenceElement = nodeLists.last(referenceNodeList).nextSibling;
                } else {
                    referenceElement = nodeLists.first(referenceNodeList);
                }
                var parentNode = masterNodeList[0].parentNode;
                parentNode.insertBefore(movedElements, referenceElement);
                var temp = masterNodeList[currentIndex];
                [].splice.apply(masterNodeList, [
                    currentIndex,
                    1
                ]);
                [].splice.apply(masterNodeList, [
                    newIndex,
                    0,
                    temp
                ]);
                newIndex = newIndex - 1;
                currentIndex = currentIndex - 1;
                var indexCompute = indexMap[currentIndex];
                [].splice.apply(indexMap, [
                    currentIndex,
                    1
                ]);
                [].splice.apply(indexMap, [
                    newIndex,
                    0,
                    indexCompute
                ]);
                var i = Math.min(currentIndex, newIndex);
                var len = indexMap.length;
                for (i, len; i < len; i++) {
                    indexMap[i](i);
                }
                if (ev.callChildMutationCallback !== false) {
                    live.callChildMutationCallback(text.parentNode);
                }
            };
            text = el.ownerDocument.createTextNode('');
            var teardownList = function (fullTeardown) {
                    if (list && list.unbind) {
                        list.unbind('add', add).unbind('set', set).unbind('remove', remove).unbind('move', move);
                    }
                    remove({ callChildMutationCallback: !!fullTeardown }, { length: masterNodeList.length - 1 }, 0, true, fullTeardown);
                }, updateList = function (ev, newList, oldList) {
                    if (isTornDown) {
                        return;
                    }
                    afterPreviousEvents = true;
                    if (newList && oldList) {
                        list = newList || [];
                        var patches = diff(oldList, newList);
                        if (oldList.unbind) {
                            oldList.unbind('add', add).unbind('set', set).unbind('remove', remove).unbind('move', move);
                        }
                        for (var i = 0, patchLen = patches.length; i < patchLen; i++) {
                            var patch = patches[i];
                            if (patch.deleteCount) {
                                remove({ callChildMutationCallback: false }, { length: patch.deleteCount }, patch.index, true);
                            }
                            if (patch.insert.length) {
                                add({ callChildMutationCallback: false }, patch.insert, patch.index);
                            }
                        }
                    } else {
                        if (oldList) {
                            teardownList();
                        }
                        list = newList || [];
                        add({ callChildMutationCallback: false }, list, 0);
                        addFalseyIfEmpty(list, falseyRender, masterNodeList, nodeList);
                    }
                    live.callChildMutationCallback(text.parentNode);
                    afterPreviousEvents = false;
                    if (list.bind) {
                        list.bind('add', add).bind('set', set).bind('remove', remove).bind('move', move);
                    }
                    canBatch.afterPreviousEvents(function () {
                        afterPreviousEvents = true;
                    });
                };
            parentNode = elements.getParentNode(el, parentNode);
            data = setup(parentNode, function () {
                if (typeof compute === 'function') {
                    compute.bind('change', updateList);
                }
            }, function () {
                if (typeof compute === 'function') {
                    compute.unbind('change', updateList);
                }
                teardownList(true);
            });
            if (!nodeList) {
                live.replace(masterNodeList, text, data.teardownCheck);
            } else {
                elements.replace(masterNodeList, text);
                nodeLists.update(masterNodeList, [text]);
                nodeList.unregistered = function () {
                    data.teardownCheck();
                    isTornDown = true;
                };
            }
            updateList({}, typeof compute === 'function' ? compute() : compute);
        },
        html: function (el, compute, parentNode, nodeList) {
            var data, nodes, makeAndPut;
            parentNode = elements.getParentNode(el, parentNode);
            data = listen(parentNode, compute, function (ev, newVal) {
                var attached = nodeLists.first(nodes).parentNode;
                if (attached) {
                    makeAndPut(newVal);
                }
                var pn = nodeLists.first(nodes).parentNode;
                data.teardownCheck(pn);
                live.callChildMutationCallback(pn);
            });
            nodes = nodeList || [el];
            makeAndPut = function (val) {
                var isFunction = typeof val === 'function', aNode = isNode(val), frag = canFrag(isFunction ? '' : val), oldNodes = makeArray(nodes);
                addTextNodeIfNoChildren(frag);
                if (!aNode && !isFunction) {
                    frag = view.hookup(frag, parentNode);
                }
                oldNodes = nodeLists.update(nodes, getChildNodes(frag));
                if (isFunction) {
                    val(frag.firstChild);
                }
                elements.replace(oldNodes, frag);
            };
            data.nodeList = nodes;
            if (!nodeList) {
                nodeLists.register(nodes, data.teardownCheck);
            } else {
                nodeList.unregistered = data.teardownCheck;
            }
            makeAndPut(compute());
        },
        replace: function (nodes, val, teardown) {
            var oldNodes = nodes.slice(0), frag = canFrag(val);
            nodeLists.register(nodes, teardown);
            if (typeof val === 'string') {
                frag = view.hookup(frag, nodes[0].parentNode);
            }
            nodeLists.update(nodes, getChildNodes(frag));
            elements.replace(oldNodes, frag);
            return nodes;
        },
        text: function (el, compute, parentNode, nodeList) {
            var parent = elements.getParentNode(el, parentNode), node;
            var data = listen(parent, compute, function (ev, newVal) {
                if (typeof node.nodeValue !== 'unknown') {
                    node.nodeValue = view.toStr(newVal);
                }
                data.teardownCheck(node.parentNode);
            });
            node = el.ownerDocument.createTextNode(view.toStr(compute()));
            if (nodeList) {
                nodeList.unregistered = data.teardownCheck;
                data.nodeList = nodeList;
                nodeLists.update(nodeList, [node]);
                elements.replace([el], node);
            } else {
                data.nodeList = live.replace([el], node, data.teardownCheck);
            }
        },
        setAttributes: function (el, newVal) {
            var attrs = getAttributeParts(newVal);
            for (var name in attrs) {
                domAttr.set(el, name, attrs[name]);
            }
        },
        attributes: function (el, compute, currentValue) {
            var oldAttrs = {};
            var setAttrs = function (newVal) {
                var newAttrs = getAttributeParts(newVal), name;
                for (name in newAttrs) {
                    var newValue = newAttrs[name], oldValue = oldAttrs[name];
                    if (newValue !== oldValue) {
                        domAttr.set(el, name, newValue);
                    }
                    delete oldAttrs[name];
                }
                for (name in oldAttrs) {
                    domAttr.remove(el, name);
                }
                oldAttrs = newAttrs;
            };
            listen(el, compute, function (ev, newVal) {
                setAttrs(newVal);
            });
            if (arguments.length >= 3) {
                oldAttrs = getAttributeParts(currentValue);
            } else {
                setAttrs(compute());
            }
        },
        attributePlaceholder: '__!!__',
        attributeReplace: /__!!__/g,
        attribute: function (el, attributeName, compute) {
            var hook;
            listen(el, compute, function () {
                domAttr.set(el, attributeName, hook.render());
            });
            var hooks;
            hooks = domData.get.call(el, 'hooks');
            if (!hooks) {
                domData.set.call(el, 'hooks', hooks = {});
            }
            var attr = String(domAttr.get(el, attributeName)), parts = attr.split(live.attributePlaceholder), goodParts = [];
            goodParts.push(parts.shift(), parts.join(live.attributePlaceholder));
            if (hooks[attributeName]) {
                hooks[attributeName].computes.push(compute);
            } else {
                hooks[attributeName] = {
                    render: function () {
                        var i = 0, newAttr = attr ? attr.replace(live.attributeReplace, function () {
                                return view.contentText(hook.computes[i++]());
                            }) : view.contentText(hook.computes[i++]());
                        return newAttr;
                    },
                    computes: [compute],
                    batchNum: undefined
                };
            }
            hook = hooks[attributeName];
            goodParts.splice(1, 0, compute());
            domAttr.set(el, attributeName, goodParts.join(''));
        },
        specialAttribute: function (el, attributeName, compute) {
            listen(el, compute, function (ev, newVal) {
                domAttr.set(el, attributeName, getValue(newVal));
            });
            domAttr.set(el, attributeName, getValue(compute()));
        },
        simpleAttribute: function (el, attributeName, compute) {
            listen(el, compute, function (ev, newVal) {
                elements.setAttr(el, attributeName, newVal);
            });
            elements.setAttr(el, attributeName, compute());
        }
    };
    live.attr = live.simpleAttribute;
    live.attrs = live.attributes;
    live.getAttributeParts = getAttributeParts;
    module.exports = live;
});
/*can-legacy-view-helpers@0.6.0#src/render*/
define('can-legacy-view-helpers@0.6.0#src/render', function (require, exports, module) {
    var view = require('./view');
    var elements = require('./elements');
    var string = require('can-util/js/string/string');
    var deepAssign = require('can-util/js/deep-assign/deep-assign');
    var canCompute = require('can-compute');
    var live = require('./live');
    var pendingHookups = [], tagChildren = function (tagName) {
            var newTag = elements.tagMap[tagName] || 'span';
            if (newTag === 'span') {
                return '@@!!@@';
            }
            return '<' + newTag + '>' + tagChildren(newTag) + '</' + newTag + '>';
        }, contentText = function (input, tag) {
            if (typeof input === 'string') {
                return input;
            }
            if (!input && input !== 0) {
                return '';
            }
            var hook = input.hookup && function (el, id) {
                input.hookup.call(input, el, id);
            } || typeof input === 'function' && input;
            if (hook) {
                if (tag) {
                    return '<' + tag + ' ' + view.hook(hook) + '></' + tag + '>';
                } else {
                    pendingHookups.push(hook);
                }
                return '';
            }
            return '' + input;
        }, contentEscape = function (txt, tag) {
            return typeof txt === 'string' || typeof txt === 'number' ? string.esc(txt) : contentText(txt, tag);
        }, withinTemplatedSectionWithinAnElement = false, emptyHandler = function () {
        };
    var lastHookups;
    deepAssign(view, {
        contentText: contentText,
        live: live,
        setupLists: function () {
            var old = view.lists, data;
            view.lists = function (list, renderer) {
                data = {
                    list: list,
                    renderer: renderer
                };
                return Math.random();
            };
            return function () {
                view.lists = old;
                return data;
            };
        },
        getHooks: function () {
            var hooks = pendingHookups.slice(0);
            lastHookups = hooks;
            pendingHookups = [];
            return hooks;
        },
        onlytxt: function (self, func) {
            return contentEscape(func.call(self));
        },
        txt: function (escape, tagName, status, self, func) {
            var tag = elements.tagMap[tagName] || 'span', setupLiveBinding = false, value, listData, compute, unbind = emptyHandler, attributeName;
            if (withinTemplatedSectionWithinAnElement) {
                value = func.call(self);
            } else {
                if (typeof status === 'string' || status === 1) {
                    withinTemplatedSectionWithinAnElement = true;
                }
                var listTeardown = view.setupLists();
                unbind = function () {
                    compute.unbind('change', emptyHandler);
                };
                compute = canCompute(func, self, false);
                compute.bind('change', emptyHandler);
                listData = listTeardown();
                value = compute();
                withinTemplatedSectionWithinAnElement = false;
                setupLiveBinding = compute.computeInstance.hasDependencies;
            }
            if (listData) {
                unbind();
                return '<' + tag + view.hook(function (el, parentNode) {
                    live.list(el, listData.list, listData.renderer, self, parentNode);
                }) + '></' + tag + '>';
            }
            if (!setupLiveBinding || typeof value === 'function') {
                unbind();
                return (withinTemplatedSectionWithinAnElement || escape === 2 || !escape ? contentText : contentEscape)(value, status === 0 && tag);
            }
            var contentProp = elements.tagToContentPropMap[tagName];
            if (status === 0 && !contentProp) {
                var selfClosing = !!elements.selfClosingTags[tag];
                return '<' + tag + view.hook(escape && typeof value !== 'object' ? function (el, parentNode) {
                    live.text(el, compute, parentNode);
                    unbind();
                } : function (el, parentNode) {
                    live.html(el, compute, parentNode);
                    unbind();
                }) + (selfClosing ? '/>' : '>' + tagChildren(tag) + '</' + tag + '>');
            } else if (status === 1) {
                pendingHookups.push(function (el) {
                    live.attributes(el, compute, compute());
                    unbind();
                });
                return compute();
            } else if (escape === 2) {
                attributeName = status;
                pendingHookups.push(function (el) {
                    live.specialAttribute(el, attributeName, compute);
                    unbind();
                });
                return compute();
            } else {
                attributeName = status === 0 ? contentProp : status;
                (status === 0 ? lastHookups : pendingHookups).push(function (el) {
                    live.attribute(el, attributeName, compute);
                    unbind();
                });
                return live.attributePlaceholder;
            }
        }
    });
    module.exports = view;
});
/*can-legacy-view-helpers@0.6.0#src/scanner*/
define('can-legacy-view-helpers@0.6.0#src/scanner', function (require, exports, module) {
    var elements = require('./elements');
    var viewCallbacks = require('can-view-callbacks');
    var deepAssign = require('can-util/js/deep-assign/deep-assign');
    var view = require('./view');
    var each = require('can-util/js/each/each');
    var newLine = /(\r|\n)+/g, notEndTag = /\//, clean = function (content) {
            return content.split('\\').join('\\\\').split('\n').join('\\n').split('"').join('\\"').split('\t').join('\\t');
        }, getTag = function (tagName, tokens, i) {
            if (tagName) {
                return tagName;
            } else {
                while (i < tokens.length) {
                    if (tokens[i] === '<' && !notEndTag.test(tokens[i + 1])) {
                        return elements.reverseTagMap[tokens[i + 1]] || 'span';
                    }
                    i++;
                }
            }
            return '';
        }, bracketNum = function (content) {
            return --content.split('{').length - --content.split('}').length;
        }, myEval = function (script) {
            eval(script);
        }, attrReg = /([^\s]+)[\s]*=[\s]*$/, startTxt = 'var ___v1ew = [];', finishTxt = 'return ___v1ew.join(\'\')', put_cmd = '___v1ew.push(\n', insert_cmd = put_cmd, htmlTag = null, quote = null, beforeQuote = null, rescan = null, getAttrName = function () {
            var matches = beforeQuote.match(attrReg);
            return matches && matches[1];
        }, _status = function () {
            return quote ? '\'' + getAttrName() + '\'' : htmlTag ? 1 : 0;
        }, _top = function (stack) {
            return stack[stack.length - 1];
        }, Scanner;
    var Scanner = function (options) {
        deepAssign(this, {
            text: {},
            tokens: []
        }, options);
        this.text.options = this.text.options || '';
        this.tokenReg = [];
        this.tokenSimple = {
            '<': '<',
            '>': '>',
            '"': '"',
            '\'': '\''
        };
        this.tokenComplex = [];
        this.tokenMap = {};
        for (var i = 0, token; token = this.tokens[i]; i++) {
            if (token[2]) {
                this.tokenReg.push(token[2]);
                this.tokenComplex.push({
                    abbr: token[1],
                    re: new RegExp(token[2]),
                    rescan: token[3]
                });
            } else {
                this.tokenReg.push(token[1]);
                this.tokenSimple[token[1]] = token[0];
            }
            this.tokenMap[token[0]] = token[1];
        }
        this.tokenReg = new RegExp('(' + this.tokenReg.slice(0).concat([
            '<',
            '>',
            '"',
            '\''
        ]).join('|') + ')', 'g');
    };
    Scanner.prototype = {
        helpers: [],
        scan: function (source, name) {
            var tokens = [], last = 0, simple = this.tokenSimple, complex = this.tokenComplex;
            source = source.replace(newLine, '\n');
            if (this.transform) {
                source = this.transform(source);
            }
            source.replace(this.tokenReg, function (whole, part) {
                var offset = arguments[arguments.length - 2];
                if (offset > last) {
                    tokens.push(source.substring(last, offset));
                }
                if (simple[whole]) {
                    tokens.push(whole);
                } else {
                    for (var i = 0, token; token = complex[i]; i++) {
                        if (token.re.test(whole)) {
                            tokens.push(token.abbr);
                            if (token.rescan) {
                                tokens.push(token.rescan(part));
                            }
                            break;
                        }
                    }
                }
                last = offset + part.length;
            });
            if (last < source.length) {
                tokens.push(source.substr(last));
            }
            var content = '', buff = [startTxt + (this.text.start || '')], put = function (content, bonus) {
                    buff.push(put_cmd, '"', clean(content), '"' + (bonus || '') + ');');
                }, endStack = [], lastToken, startTag = null, magicInTag = false, specialStates = {
                    attributeHookups: [],
                    tagHookups: [],
                    lastTagHookup: ''
                }, popTagHookup = function () {
                    specialStates.lastTagHookup = specialStates.tagHookups.pop() + specialStates.tagHookups.length;
                }, tagName = '', tagNames = [], popTagName = false, bracketCount, specialAttribute = false, i = 0, token, tmap = this.tokenMap, attrName;
            htmlTag = quote = beforeQuote = null;
            for (; (token = tokens[i++]) !== undefined;) {
                if (startTag === null) {
                    switch (token) {
                    case tmap.left:
                    case tmap.escapeLeft:
                    case tmap.returnLeft:
                        magicInTag = htmlTag && 1;
                    case tmap.commentLeft:
                        startTag = token;
                        if (content.length) {
                            put(content);
                        }
                        content = '';
                        break;
                    case tmap.escapeFull:
                        magicInTag = htmlTag && 1;
                        rescan = 1;
                        startTag = tmap.escapeLeft;
                        if (content.length) {
                            put(content);
                        }
                        rescan = tokens[i++];
                        content = rescan.content || rescan;
                        if (rescan.before) {
                            put(rescan.before);
                        }
                        tokens.splice(i, 0, tmap.right);
                        break;
                    case tmap.commentFull:
                        break;
                    case tmap.templateLeft:
                        content += tmap.left;
                        break;
                    case '<':
                        if (tokens[i].indexOf('!--') !== 0) {
                            htmlTag = 1;
                            magicInTag = 0;
                        }
                        content += token;
                        break;
                    case '>':
                        htmlTag = 0;
                        var emptyElement = content.substr(content.length - 1) === '/' || content.substr(content.length - 2) === '--', attrs = '';
                        if (specialStates.attributeHookups.length) {
                            attrs = 'attrs: [\'' + specialStates.attributeHookups.join('\',\'') + '\'], ';
                            specialStates.attributeHookups = [];
                        }
                        if (tagName + specialStates.tagHookups.length !== specialStates.lastTagHookup && tagName === _top(specialStates.tagHookups)) {
                            if (emptyElement) {
                                content = content.substr(0, content.length - 1);
                            }
                            buff.push(put_cmd, '"', clean(content), '"', ',CAN_LEGACY_HELPERS.view.pending({tagName:\'' + tagName + '\',' + attrs + 'scope: ' + (this.text.scope || 'this') + this.text.options);
                            if (emptyElement) {
                                buff.push('}));');
                                content = '/>';
                                popTagHookup();
                            } else if (tokens[i] === '<' && tokens[i + 1] === '/' + tagName) {
                                buff.push('}));');
                                content = token;
                                popTagHookup();
                            } else {
                                buff.push(',subtemplate: function(' + this.text.argNames + '){\n' + startTxt + (this.text.start || ''));
                                content = '';
                            }
                        } else if (magicInTag || !popTagName && elements.tagToContentPropMap[tagNames[tagNames.length - 1]] || attrs) {
                            var pendingPart = ',CAN_LEGACY_HELPERS.view.pending({' + attrs + 'scope: ' + (this.text.scope || 'this') + this.text.options + '}),"';
                            if (emptyElement) {
                                put(content.substr(0, content.length - 1), pendingPart + '/>"');
                            } else {
                                put(content, pendingPart + '>"');
                            }
                            content = '';
                            magicInTag = 0;
                        } else {
                            content += token;
                        }
                        if (emptyElement || popTagName) {
                            tagNames.pop();
                            tagName = tagNames[tagNames.length - 1];
                            popTagName = false;
                        }
                        specialStates.attributeHookups = [];
                        break;
                    case '\'':
                    case '"':
                        if (htmlTag) {
                            if (quote && quote === token) {
                                quote = null;
                                var attr = getAttrName();
                                if (viewCallbacks.attr(attr)) {
                                    specialStates.attributeHookups.push(attr);
                                }
                                if (specialAttribute) {
                                    content += token;
                                    put(content);
                                    buff.push(finishTxt, '}));\n');
                                    content = '';
                                    specialAttribute = false;
                                    break;
                                }
                            } else if (quote === null) {
                                quote = token;
                                beforeQuote = lastToken;
                                attrName = getAttrName();
                                if (tagName === 'img' && attrName === 'src' || attrName === 'style') {
                                    put(content.replace(attrReg, ''));
                                    content = '';
                                    specialAttribute = true;
                                    buff.push(insert_cmd, 'CAN_LEGACY_HELPERS.view.txt(2,\'' + getTag(tagName, tokens, i) + '\',' + _status() + ',this,function(){', startTxt);
                                    put(attrName + '=' + token);
                                    break;
                                }
                            }
                        }
                    default:
                        if (lastToken === '<') {
                            tagName = token.substr(0, 3) === '!--' ? '!--' : token.split(/\s/)[0];
                            var isClosingTag = false, cleanedTagName;
                            if (tagName.indexOf('/') === 0) {
                                isClosingTag = true;
                                cleanedTagName = tagName.substr(1);
                            }
                            if (isClosingTag) {
                                if (_top(tagNames) === cleanedTagName) {
                                    tagName = cleanedTagName;
                                    popTagName = true;
                                }
                                if (_top(specialStates.tagHookups) === cleanedTagName) {
                                    put(content.substr(0, content.length - 1));
                                    buff.push(finishTxt + '}}) );');
                                    content = '><';
                                    popTagHookup();
                                }
                            } else {
                                if (tagName.lastIndexOf('/') === tagName.length - 1) {
                                    tagName = tagName.substr(0, tagName.length - 1);
                                }
                                if (tagName !== '!--' && viewCallbacks.tag(tagName)) {
                                    if (tagName === 'content' && elements.tagMap[_top(tagNames)]) {
                                        token = token.replace('content', elements.tagMap[_top(tagNames)]);
                                    }
                                    specialStates.tagHookups.push(tagName);
                                }
                                tagNames.push(tagName);
                            }
                        }
                        content += token;
                        break;
                    }
                } else {
                    switch (token) {
                    case tmap.right:
                    case tmap.returnRight:
                        switch (startTag) {
                        case tmap.left:
                            bracketCount = bracketNum(content);
                            if (bracketCount === 1) {
                                buff.push(insert_cmd, 'CAN_LEGACY_HELPERS.view.txt(0,\'' + getTag(tagName, tokens, i) + '\',' + _status() + ',this,function(){', startTxt, content);
                                endStack.push({
                                    before: '',
                                    after: finishTxt + '}));\n'
                                });
                            } else {
                                last = endStack.length && bracketCount === -1 ? endStack.pop() : { after: ';' };
                                if (last.before) {
                                    buff.push(last.before);
                                }
                                buff.push(content, ';', last.after);
                            }
                            break;
                        case tmap.escapeLeft:
                        case tmap.returnLeft:
                            bracketCount = bracketNum(content);
                            if (bracketCount) {
                                endStack.push({
                                    before: finishTxt,
                                    after: '}));\n'
                                });
                            }
                            var escaped = startTag === tmap.escapeLeft ? 1 : 0, commands = {
                                    insert: insert_cmd,
                                    tagName: getTag(tagName, tokens, i),
                                    status: _status(),
                                    specialAttribute: specialAttribute
                                };
                            for (var ii = 0; ii < this.helpers.length; ii++) {
                                var helper = this.helpers[ii];
                                if (helper.name.test(content)) {
                                    content = helper.fn(content, commands);
                                    if (helper.name.source === /^>[\s]*\w*/.source) {
                                        escaped = 0;
                                    }
                                    break;
                                }
                            }
                            if (typeof content === 'object') {
                                if (content.startTxt && content.end && specialAttribute) {
                                    buff.push(insert_cmd, 'CAN_LEGACY_HELPERS.view.toStr( ', content.content, '() ) );');
                                } else {
                                    if (content.startTxt) {
                                        buff.push(insert_cmd, 'CAN_LEGACY_HELPERS.view.txt(\n' + (typeof _status() === 'string' || (content.escaped != null ? content.escaped : escaped)) + ',\n\'' + tagName + '\',\n' + _status() + ',\nthis,\n');
                                    } else if (content.startOnlyTxt) {
                                        buff.push(insert_cmd, 'CAN_LEGACY_HELPERS.view.onlytxt(this,\n');
                                    }
                                    buff.push(content.content);
                                    if (content.end) {
                                        buff.push('));');
                                    }
                                }
                            } else if (specialAttribute) {
                                buff.push(insert_cmd, content, ');');
                            } else {
                                buff.push(insert_cmd, 'CAN_LEGACY_HELPERS.view.txt(\n' + (typeof _status() === 'string' || escaped) + ',\n\'' + tagName + '\',\n' + _status() + ',\nthis,\nfunction(){ ' + (this.text.escape || '') + 'return ', content, bracketCount ? startTxt : '}));\n');
                            }
                            if (rescan && rescan.after && rescan.after.length) {
                                put(rescan.after.length);
                                rescan = null;
                            }
                            break;
                        }
                        startTag = null;
                        content = '';
                        break;
                    case tmap.templateLeft:
                        content += tmap.left;
                        break;
                    default:
                        content += token;
                        break;
                    }
                }
                lastToken = token;
            }
            if (content.length) {
                put(content);
            }
            buff.push(';');
            var template = buff.join(''), out = { out: (this.text.outStart || '') + template + ' ' + finishTxt + (this.text.outEnd || '') };
            myEval.call(out, 'this.fn = (function(' + this.text.argNames + '){' + out.out + '});\r\n//# sourceURL=' + name + '.js');
            return out;
        }
    };
    view.pending = function (viewData) {
        var hooks = view.getHooks();
        return view.hook(function (el) {
            each(hooks, function (fn) {
                fn(el);
            });
            viewData.templateType = 'legacy';
            if (viewData.tagName) {
                viewCallbacks.tagHandler(el, viewData.tagName, viewData);
            }
            each(viewData && viewData.attrs || [], function (attributeName) {
                viewData.attributeName = attributeName;
                var callback = viewCallbacks.attr(attributeName);
                if (callback) {
                    callback(el, viewData);
                }
            });
        });
    };
    view.Scanner = Scanner;
    module.exports = Scanner;
});
/*can-legacy-view-helpers@0.6.0#can-legacy-view-helpers*/
define('can-legacy-view-helpers@0.6.0#can-legacy-view-helpers', function (require, exports, module) {
    var render = require('./src/render');
    var scanner = require('./src/scanner');
    var view = require('./src/view');
    var elements = require('./src/elements');
    var live = require('./src/live');
    var nodeLists = require('./src/node_list');
    var legacyHelpers = {
        render: render,
        Scanner: scanner,
        view: view,
        elements: elements,
        live: live,
        nodeLists: nodeLists
    };
    window.CAN_LEGACY_HELPERS = legacyHelpers;
    module.exports = legacyHelpers;
});
/*can-stache-key@0.0.3#can-stache-key*/
define('can-stache-key@0.0.3#can-stache-key', function (require, exports, module) {
    var Observation = require('can-observation');
    var dev = require('can-util/js/dev/dev');
    var each = require('can-util/js/each/each');
    var canSymbol = require('can-symbol');
    var canReflect = require('can-reflect');
    var isPromiseLike = require('can-util/js/is-promise-like/is-promise-like');
    var canReflectPromise = require('can-reflect-promise');
    var getValueSymbol = canSymbol.for('can.getValue');
    var setValueSymbol = canSymbol.for('can.setValue');
    var isValueLikeSymbol = canSymbol.for('can.isValueLike');
    var observeReader;
    var isAt = function (index, reads) {
        var prevRead = reads[index - 1];
        return prevRead && prevRead.at;
    };
    var readValue = function (value, index, reads, options, state, prev) {
        var usedValueReader;
        do {
            usedValueReader = false;
            for (var i = 0, len = observeReader.valueReaders.length; i < len; i++) {
                if (observeReader.valueReaders[i].test(value, index, reads, options)) {
                    value = observeReader.valueReaders[i].read(value, index, reads, options, state, prev);
                }
            }
        } while (usedValueReader);
        return value;
    };
    var specialRead = {
        index: true,
        key: true,
        event: true,
        element: true,
        viewModel: true
    };
    var checkForObservableAndNotify = function (options, state, getObserves, value, index) {
        if (options.foundObservable && !state.foundObservable) {
            if (Observation.trapsCount()) {
                Observation.addAll(getObserves());
                options.foundObservable(value, index);
                state.foundObservable = true;
            }
        }
    };
    observeReader = {
        read: function (parent, reads, options) {
            options = options || {};
            var state = { foundObservable: false };
            var getObserves;
            if (options.foundObservable) {
                getObserves = Observation.trap();
            }
            var cur = readValue(parent, 0, reads, options, state), type, prev, readLength = reads.length, i = 0, last;
            checkForObservableAndNotify(options, state, getObserves, parent, 0);
            while (i < readLength) {
                prev = cur;
                for (var r = 0, readersLength = observeReader.propertyReaders.length; r < readersLength; r++) {
                    var reader = observeReader.propertyReaders[r];
                    if (reader.test(cur)) {
                        cur = reader.read(cur, reads[i], i, options, state);
                        break;
                    }
                }
                checkForObservableAndNotify(options, state, getObserves, prev, i);
                last = cur;
                i = i + 1;
                cur = readValue(cur, i, reads, options, state, prev);
                checkForObservableAndNotify(options, state, getObserves, prev, i - 1);
                type = typeof cur;
                if (i < reads.length && (cur === null || cur === undefined)) {
                    if (options.earlyExit) {
                        options.earlyExit(prev, i - 1, cur);
                    }
                    return {
                        value: undefined,
                        parent: prev
                    };
                }
            }
            if (cur === undefined) {
                if (options.earlyExit) {
                    options.earlyExit(prev, i - 1);
                }
            }
            return {
                value: cur,
                parent: prev
            };
        },
        get: function (parent, reads, options) {
            return observeReader.read(parent, observeReader.reads(reads), options || {}).value;
        },
        valueReadersMap: {},
        valueReaders: [
            {
                name: 'function',
                test: function (value) {
                    return value && canReflect.isFunctionLike(value) && !canReflect.isConstructorLike(value);
                },
                read: function (value, i, reads, options, state, prev) {
                    if (isAt(i, reads)) {
                        return i === reads.length ? value.bind(prev) : value;
                    } else if (options.callMethodsOnObservables && canReflect.isObservableLike(prev) && canReflect.isMapLike(prev)) {
                        return value.apply(prev, options.args || []);
                    } else if (options.isArgument && i === reads.length) {
                        return options.proxyMethods !== false ? value.bind(prev) : value;
                    }
                    return value.apply(prev, options.args || []);
                }
            },
            {
                name: 'isValueLike',
                test: function (value, i, reads, options) {
                    return value && value[getValueSymbol] && value[isValueLikeSymbol] !== false && (options.foundAt || !isAt(i, reads));
                },
                read: function (value, i, reads, options) {
                    if (options.readCompute === false && i === reads.length) {
                        return value;
                    }
                    return canReflect.getValue(value);
                },
                write: function (base, newVal) {
                    if (base[setValueSymbol]) {
                        base[setValueSymbol](newVal);
                    } else if (base.set) {
                        base.set(newVal);
                    } else {
                        base(newVal);
                    }
                }
            }
        ],
        propertyReadersMap: {},
        propertyReaders: [
            {
                name: 'map',
                test: function (value) {
                    if (isPromiseLike(value) || typeof value === 'object' && typeof value.then === 'function') {
                        canReflectPromise(value);
                    }
                    return canReflect.isObservableLike(value) && canReflect.isMapLike(value);
                },
                read: function (value, prop) {
                    var res = canReflect.getKeyValue(value, prop.key);
                    if (res !== undefined) {
                        return res;
                    } else {
                        return value[prop.key];
                    }
                },
                write: canReflect.setKeyValue
            },
            {
                name: 'object',
                test: function () {
                    return true;
                },
                read: function (value, prop, i, options) {
                    if (value == null) {
                        return undefined;
                    } else {
                        if (typeof value === 'object') {
                            if (prop.key in value) {
                                return value[prop.key];
                            } else if (prop.at && specialRead[prop.key] && '@' + prop.key in value) {
                                options.foundAt = true;
                                return value['@' + prop.key];
                            }
                        } else {
                            return value[prop.key];
                        }
                    }
                },
                write: function (base, prop, newVal) {
                    base[prop] = newVal;
                }
            }
        ],
        reads: function (keyArg) {
            var key = '' + keyArg;
            var keys = [];
            var last = 0;
            var at = false;
            if (key.charAt(0) === '@') {
                last = 1;
                at = true;
            }
            var keyToAdd = '';
            for (var i = last; i < key.length; i++) {
                var character = key.charAt(i);
                if (character === '.' || character === '@') {
                    if (key.charAt(i - 1) !== '\\') {
                        keys.push({
                            key: keyToAdd,
                            at: at
                        });
                        at = character === '@';
                        keyToAdd = '';
                    } else {
                        keyToAdd = keyToAdd.substr(0, keyToAdd.length - 1) + '.';
                    }
                } else {
                    keyToAdd += character;
                }
            }
            keys.push({
                key: keyToAdd,
                at: at
            });
            return keys;
        },
        write: function (parent, key, value, options) {
            var keys = typeof key === 'string' ? observeReader.reads(key) : key;
            var last;
            options = options || {};
            if (keys.length > 1) {
                last = keys.pop();
                parent = observeReader.read(parent, keys, options).value;
                keys.push(last);
            } else {
                last = keys[0];
            }
            if (observeReader.valueReadersMap.isValueLike.test(parent[last.key], keys.length - 1, keys, options)) {
                observeReader.valueReadersMap.isValueLike.write(parent[last.key], value, options);
            } else {
                if (observeReader.valueReadersMap.isValueLike.test(parent, keys.length - 1, keys, options)) {
                    parent = parent[getValueSymbol]();
                }
                if (observeReader.propertyReadersMap.map.test(parent)) {
                    observeReader.propertyReadersMap.map.write(parent, last.key, value, options);
                } else if (observeReader.propertyReadersMap.object.test(parent)) {
                    observeReader.propertyReadersMap.object.write(parent, last.key, value, options);
                    if (options.observation) {
                        options.observation.update();
                    }
                }
            }
        }
    };
    each(observeReader.propertyReaders, function (reader) {
        observeReader.propertyReadersMap[reader.name] = reader;
    });
    each(observeReader.valueReaders, function (reader) {
        observeReader.valueReadersMap[reader.name] = reader;
    });
    observeReader.set = observeReader.write;
    module.exports = observeReader;
});
/*can-ejs@3.1.2#can-ejs*/
define('can-ejs@3.1.2#can-ejs', function (require, exports, module) {
    var legacyHelpers = require('can-legacy-view-helpers');
    var extend = require('can-util/js/assign/assign');
    var namespace = require('can-namespace');
    var each = require('can-util/js/each/each');
    var canReflect = require('can-reflect');
    var observationReader = require('can-stache-key');
    var DOCUMENT = require('can-util/dom/document/document');
    var templateId = 0;
    var EJS = function (options) {
        if (!this || this.constructor !== EJS) {
            var ejs = new EJS(options);
            return function (data, helpers) {
                return legacyHelpers.view.frag(ejs.render(data, helpers));
            };
        }
        if (typeof options === 'function') {
            this.template = { fn: options };
            return;
        }
        if (typeof options === 'string') {
            options = {
                text: options,
                name: '' + ++templateId
            };
        }
        extend(this, options);
        this.template = this.scanner.scan(this.text, this.name);
    };
    namespace.EJS = EJS;
    EJS.prototype.render = function (object, extraHelpers) {
        object = object || {};
        return this.template.fn.call(object, object, new EJS.Helpers(object, extraHelpers || {}));
    };
    extend(EJS.prototype, {
        scanner: new legacyHelpers.Scanner({
            text: {
                outStart: 'with(_VIEW) { with (_CONTEXT) {',
                outEnd: '}}',
                argNames: '_CONTEXT,_VIEW',
                context: 'this'
            },
            tokens: [
                [
                    'templateLeft',
                    '<%%'
                ],
                [
                    'templateRight',
                    '%>'
                ],
                [
                    'returnLeft',
                    '<%=='
                ],
                [
                    'escapeLeft',
                    '<%='
                ],
                [
                    'commentLeft',
                    '<%#'
                ],
                [
                    'left',
                    '<%'
                ],
                [
                    'right',
                    '%>'
                ],
                [
                    'returnRight',
                    '%>'
                ]
            ],
            helpers: [{
                    name: /\s*\(([\$\w]+)\)\s*->([^\n]*)/,
                    fn: function (content) {
                        var quickFunc = /\s*\(([\$\w]+)\)\s*->([^\n]*)/, parts = content.match(quickFunc);
                        return '(function(__){var ' + parts[1] + '=__;' + parts[2] + '}).bind(this);';
                    }
                }],
            transform: function (source) {
                return source.replace(/<%([\s\S]+?)%>/gm, function (whole, part) {
                    var brackets = [], foundBracketPair, i;
                    part.replace(/[{}]/gm, function (bracket, offset) {
                        brackets.push([
                            bracket,
                            offset
                        ]);
                    });
                    do {
                        foundBracketPair = false;
                        for (i = brackets.length - 2; i >= 0; i--) {
                            if (brackets[i][0] === '{' && brackets[i + 1][0] === '}') {
                                brackets.splice(i, 2);
                                foundBracketPair = true;
                                break;
                            }
                        }
                    } while (foundBracketPair);
                    if (brackets.length >= 2) {
                        var result = ['<%'], bracket, last = 0;
                        for (i = 0; bracket = brackets[i]; i++) {
                            result.push(part.substring(last, last = bracket[1]));
                            if (bracket[0] === '{' && i < brackets.length - 1 || bracket[0] === '}' && i > 0) {
                                result.push(bracket[0] === '{' ? '{ %><% ' : ' %><% }');
                            } else {
                                result.push(bracket[0]);
                            }
                            ++last;
                        }
                        result.push(part.substring(last), '%>');
                        return result.join('');
                    } else {
                        return '<%' + part + '%>';
                    }
                });
            }
        })
    });
    EJS.Helpers = function (data, extras) {
        this._data = data;
        this._extras = extras;
        extend(this, extras);
    };
    EJS.Helpers.prototype = {
        list: function (list, cb) {
            if (canReflect.isObservableLike(list) && canReflect.isListLike(list)) {
                observationReader.get(list, 'length');
            }
            each(list, function (item, i) {
                cb(item, i, list);
            });
        },
        each: function (list, cb) {
            if (Array.isArray(list)) {
                this.list(list, cb);
            } else {
                legacyHelpers.view.lists(list, cb);
            }
        }
    };
    var templates = {};
    EJS.from = function (id) {
        if (!templates[id]) {
            var el = DOCUMENT().getElementById(id);
            templates[id] = EJS(el.innerHTML);
        }
        return templates[id];
    };
    module.exports = EJS;
});
/*can-ejs@3.1.2#test/can-ejs_test*/
define('can-ejs@3.1.2#test/can-ejs_test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var EJS = require('can-ejs');
    var CanMap = require('can-map');
    var legacyHelpers = require('can-legacy-view-helpers');
    var domData = require('can-util/dom/data/data');
    var CanList = require('can-list');
    var canFrag = require('can-util/dom/frag/frag');
    var canCompute = require('can-compute');
    var domMutate = require('can-util/dom/mutate/mutate');
    QUnit.module('can-ejs, rendering', {
        setup: function () {
            this.animals = [
                'sloth',
                'bear',
                'monkey'
            ];
            if (!this.animals.each) {
                this.animals.each = function (func) {
                    for (var i = 0; i < this.length; i++) {
                        func(this[i]);
                    }
                };
            }
            this.squareBrackets = '<ul><% this.animals.each(function(animal){%>' + '<li><%= animal %></li>' + '<%});%></ul>';
            this.squareBracketsNoThis = '<ul><% animals.each(function(animal){%>' + '<li><%= animal %></li>' + '<%});%></ul>';
            this.angleBracketsNoThis = '<ul><% animals.each(function(animal){%>' + '<li><%= animal %></li>' + '<%});%></ul>';
        }
    });
    var getAttr = function (el, attrName) {
        return attrName === 'class' ? el.className : el.getAttribute(attrName);
    };
    test('render with left bracket', function () {
        var compiled = new EJS({
            text: this.squareBrackets,
            type: '['
        }).render({ animals: this.animals });
        equal(compiled, '<ul><li>sloth</li><li>bear</li><li>monkey</li></ul>', 'renders with bracket');
    });
    test('render with with', function () {
        var compiled = new EJS({
            text: this.squareBracketsNoThis,
            type: '['
        }).render({ animals: this.animals });
        equal(compiled, '<ul><li>sloth</li><li>bear</li><li>monkey</li></ul>', 'renders bracket with no this');
    });
    test('default carrot', function () {
        var compiled = new EJS({ text: this.angleBracketsNoThis }).render({ animals: this.animals });
        equal(compiled, '<ul><li>sloth</li><li>bear</li><li>monkey</li></ul>');
    });
    test('render with double angle', function () {
        var text = '<%% replace_me %>' + '<ul><% animals.each(function(animal){%>' + '<li><%= animal %></li>' + '<%});%></ul>';
        var compiled = new EJS({ text: text }).render({ animals: this.animals });
        equal(compiled, '<% replace_me %><ul><li>sloth</li><li>bear</li><li>monkey</li></ul>', 'works');
    });
    test('comments', function () {
        var text = '<%# replace_me %>' + '<ul><% animals.each(function(animal){%>' + '<li><%= animal %></li>' + '<%});%></ul>';
        var compiled = new EJS({ text: text }).render({ animals: this.animals });
        equal(compiled, '<ul><li>sloth</li><li>bear</li><li>monkey</li></ul>');
    });
    test('multi line', function () {
        var text = 'a \n b \n c', result = new EJS({ text: text }).render({});
        equal(result, text);
    });
    test('multi line elements', function () {
        var text = '<img\n class="<%=myClass%>" />', result = new EJS({ text: text }).render({ myClass: 'a' });
        ok(result.indexOf('<img\n class="a"') !== -1, 'Multi-line elements render correctly.');
        legacyHelpers.view.hookups = {};
    });
    test('escapedContent', function () {
        var text = '<span><%= tags %></span><label>&amp;</label><strong><%= number %></strong><input value=\'<%= quotes %>\'/>';
        var compiled = new EJS({ text: text }).render({
            tags: 'foo < bar < car > zar > poo',
            quotes: 'I use \'quote\' fingers "a lot"',
            number: 123
        });
        var div = document.createElement('div');
        div.innerHTML = compiled;
        equal(div.getElementsByTagName('span')[0].firstChild.nodeValue, 'foo < bar < car > zar > poo');
        equal(div.getElementsByTagName('strong')[0].firstChild.nodeValue, 123);
        equal(div.getElementsByTagName('input')[0].value, 'I use \'quote\' fingers "a lot"');
        equal(div.getElementsByTagName('label')[0].innerHTML, '&amp;');
        legacyHelpers.view.hookups = {};
    });
    test('unescapedContent', function () {
        var text = '<span><%== tags %></span><div><%= tags %></div><input value=\'<%== quotes %>\'/>';
        var compiled = new EJS({ text: text }).render({
            tags: '<strong>foo</strong><strong>bar</strong>',
            quotes: 'I use \'quote\' fingers "a lot"'
        });
        var div = document.createElement('div');
        div.innerHTML = compiled;
        equal(div.getElementsByTagName('span')[0].firstChild.nodeType, 1);
        equal(div.getElementsByTagName('div')[0].firstChild.nodeValue.toLowerCase(), '<strong>foo</strong><strong>bar</strong>');
        equal(div.getElementsByTagName('span')[0].innerHTML.toLowerCase(), '<strong>foo</strong><strong>bar</strong>');
        equal(div.getElementsByTagName('input')[0].value, 'I use \'quote\' fingers "a lot"', 'escapped no matter what');
        legacyHelpers.view.hookups = {};
    });
    test('returning blocks', function () {
        var somethingHelper = function (cb) {
            return cb([
                1,
                2,
                3,
                4
            ]);
        };
        var template = '<%# Test Something Produces Items%>' + '<%== something(function(items){ %>' + ' <%== items.length%> ' + '<% items.map( function(){ %><%# Test Something Produces Items%>' + '<%==  something(function(items){ %>ItemsLength<%== items.length %><% }) %>' + '<% }) %>' + '<% }) %>' + '<% for( var i =0; i < items.length; i++) { %>for <%= items[i] %><% } %>';
        var temp = new EJS(template);
        var res = temp.render({
            something: somethingHelper,
            items: [
                'a',
                'b'
            ]
        });
        ok(/\s4\s/.test(res), 'first block called');
        equal(res.match(/ItemsLength4/g).length, 4, 'innerBlock and each');
    });
    test('easy hookup', function () {
        var div = document.createElement('div');
        var templateStr = '<div <%= (el)-> el.className = text %>>';
        var template = EJS(templateStr);
        var res = template({ text: 'yes' });
        div.appendChild(res);
        ok(div.getElementsByTagName('div')[0].className.indexOf('yes') !== -1, 'has yes');
    });
    test('multiple function hookups in a tag', function () {
        var text = '<span <%= (el)-> domData.set.call(el,\'foo\',\'bar\') %>' + ' <%= (el)-> domData.set.call(el,\'baz\',\'qux\') %>>lorem ipsum</span>', compiled = new EJS({ text: text }).render({ domData: domData }), div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(compiled));
        var span = div.getElementsByTagName('span')[0];
        equal(domData.get.call(span, 'foo'), 'bar', 'first hookup');
        equal(domData.get.call(span, 'baz'), 'qux', 'second hookup');
    });
    test('helpers', function () {
        EJS.Helpers.prototype.simpleHelper = function () {
            return 'Simple';
        };
        EJS.Helpers.prototype.elementHelper = function () {
            return function (el) {
                el.innerHTML = 'Simple';
            };
        };
        var text = '<div><%= simpleHelper() %></div>';
        var compiled = new EJS({ text: text }).render();
        equal(compiled, '<div>Simple</div>');
        text = '<div id="hookup" <%= elementHelper() %>></div>';
        compiled = new EJS({ text: text }).render();
        var qF = document.getElementById('qunit-fixture');
        qF.appendChild(legacyHelpers.view.frag(compiled));
        var hookup = document.getElementById('hookup');
        equal(hookup.innerHTML, 'Simple');
    });
    test('list helper', function () {
        var text = '<% list(todos, function(todo){ %><div><%= todo.name %></div><% }) %>';
        var todos = new CanList([{
                    id: 1,
                    name: 'Dishes'
                }]), compiled = new EJS({ text: text }).render({ todos: todos }), div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(compiled));
        equal(div.getElementsByTagName('div').length, 1, '1 item in list');
        todos.push({
            id: 2,
            name: 'Laundry'
        });
        equal(div.getElementsByTagName('div').length, 2, '2 items in list');
        todos.splice(0, 2);
        equal(div.getElementsByTagName('div').length, 0, '0 items in list');
        todos.push({
            id: 4,
            name: 'Pick up sticks'
        });
        equal(div.getElementsByTagName('div').length, 1, '1 item in list again');
    });
    test('attribute single unescaped, html single unescaped', function () {
        var text = '<div id=\'me\' class=\'<%== task.attr(\'completed\') ? \'complete\' : \'\'%>\'><%== task.attr(\'name\') %></div>';
        var task = new CanMap({ name: 'dishes' });
        var compiled = new EJS({ text: text }).render({ task: task });
        var div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(compiled));
        equal(div.getElementsByTagName('div')[0].innerHTML, 'dishes', 'html correctly dishes');
        equal(div.getElementsByTagName('div')[0].className, '', 'class empty');
        task.attr('name', 'lawn');
        equal(div.getElementsByTagName('div')[0].innerHTML, 'lawn', 'html correctly lawn');
        equal(div.getElementsByTagName('div')[0].className, '', 'class empty');
        task.attr('completed', true);
        equal(div.getElementsByTagName('div')[0].className, 'complete', 'class changed to complete');
    });
    test('select live binding', function () {
        var text = '<select><% todos.each(function(todo){ %><option><%= todo.name %></option><% }) %></select>', Todos = new CanList([{
                    id: 1,
                    name: 'Dishes'
                }]), compiled = new EJS({ text: text }).render({ todos: Todos }), div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(compiled));
        equal(div.getElementsByTagName('option').length, 1, '1 item in list');
        Todos.push({
            id: 2,
            name: 'Laundry'
        });
        equal(div.getElementsByTagName('option').length, 2, '2 items in list');
        Todos.splice(0, 2);
        equal(div.getElementsByTagName('option').length, 0, '0 items in list');
    });
    test('block live binding', function () {
        var text = '<div><% if( obs.attr(\'sex\') == \'male\' ){ %>' + '<span>Mr.</span>' + '<% } else { %>' + '<label>Ms.</label>' + '<% } %>' + '</div>';
        var obs = new CanMap({ sex: 'male' });
        var compiled = new EJS({ text: text }).render({ obs: obs });
        var div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(compiled));
        equal(div.getElementsByTagName('div')[0].firstChild.nodeName.toUpperCase(), 'SPAN', 'initial span tag');
        equal(div.getElementsByTagName('div')[0].firstChild.innerHTML, 'Mr.', 'initial span content');
        obs.attr('sex', 'female');
        equal(div.getElementsByTagName('div')[0].firstChild.nodeName.toUpperCase(), 'LABEL', 'updated label tag');
        equal(div.getElementsByTagName('div')[0].firstChild.innerHTML, 'Ms.', 'updated label content');
    });
    test('hookups in tables', function () {
        var text = '<table><tbody><% if( obs.attr(\'sex\') == \'male\' ){ %>' + '<tr><td>Mr.</td></tr>' + '<% } else { %>' + '<tr><td>Ms.</td></tr>' + '<% } %>' + '</tbody></table>';
        var obs = new CanMap({ sex: 'male' });
        var compiled = new EJS({ text: text }).render({ obs: obs });
        var div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(compiled));
        equal(div.getElementsByTagName('tbody')[0].firstChild.firstChild.nodeName, 'TD', 'initial tag');
        equal(div.getElementsByTagName('tbody')[0].firstChild.firstChild.innerHTML.replace(/(\r|\n)+/g, ''), 'Mr.', 'initial content');
        obs.attr('sex', 'female');
        equal(div.getElementsByTagName('tbody')[0].firstChild.firstChild.nodeName, 'TD', 'updated tag');
        equal(div.getElementsByTagName('tbody')[0].firstChild.firstChild.innerHTML.replace(/(\r|\n)+/g, ''), 'Ms.', 'updated content');
    });
    test('multiple tbodies in table hookup', function () {
        var text = '<table>' + '<% list(people, function(person){ %>' + '<tbody><tr><td><%= person.name %></td></tr></tbody>' + '<% }) %>' + '</table>', people = new CanList([
                { name: 'Steve' },
                { name: 'Doug' }
            ]), compiled = new EJS({ text: text }).render({ people: people }), div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(compiled));
        equal(div.getElementsByTagName('tbody').length, 2, 'two tbodies');
    });
    test('multiple hookups in a single attribute', function () {
        var text = '<div class=\'<%= obs.attr("foo") %>a<%= obs.attr("bar") %>b<%= obs.attr("baz") %>\'></div>', obs = new CanMap({
                foo: '1',
                bar: '2',
                baz: '3'
            }), compiled = new EJS({ text: text }).render({ obs: obs });
        var div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(compiled));
        var innerDiv = div.childNodes[0];
        equal(getAttr(innerDiv, 'class'), '1a2b3', 'initial render');
        obs.attr('bar', '4');
        equal(getAttr(innerDiv, 'class'), '1a4b3', 'initial render');
        obs.attr('bar', '5');
        equal(getAttr(innerDiv, 'class'), '1a5b3', 'initial render');
    });
    test('adding and removing multiple html content within a single element', function () {
        var text = '<div><%== obs.attr("a") %><%== obs.attr("b") %><%== obs.attr("c") %></div>', obs = new CanMap({
                a: 'a',
                b: 'b',
                c: 'c'
            }), compiled = new EJS({ text: text }).render({ obs: obs });
        var div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(compiled));
        equal(div.firstChild.nodeName.toUpperCase(), 'DIV', 'initial render node name');
        equal(div.firstChild.innerHTML, 'abc', 'initial render text');
        obs.attr({
            a: '',
            b: '',
            c: ''
        });
        equal(div.firstChild.nodeName.toUpperCase(), 'DIV', 'updated render node name');
        equal(div.firstChild.innerHTML, '', 'updated render text');
        obs.attr({ c: 'c' });
        equal(div.firstChild.nodeName.toUpperCase(), 'DIV', 'updated render node name');
        equal(div.firstChild.innerHTML, 'c', 'updated render text');
    });
    test('live binding and removeAttr', function () {
        var text = '<% if(obs.attr("show")) { %>' + '<p <%== obs.attr("attributes") %> class="<%= obs.attr("className")%>"><span><%= obs.attr("message") %></span></p>' + '<% } %>', obs = new CanMap({
                show: true,
                className: 'myMessage',
                attributes: 'some="myText"',
                message: 'Live long and prosper'
            }), compiled = new EJS({ text: text }).render({ obs: obs }), div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(compiled));
        var p = div.getElementsByTagName('p')[0], span = p.getElementsByTagName('span')[0];
        equal(p.getAttribute('some'), 'myText', 'initial render attr');
        equal(getAttr(p, 'class'), 'myMessage', 'initial render class');
        equal(span.innerHTML, 'Live long and prosper', 'initial render innerHTML');
        obs.removeAttr('className');
        equal(getAttr(p, 'class'), '', 'class is undefined');
        obs.attr('className', 'newClass');
        equal(getAttr(p, 'class'), 'newClass', 'class updated');
        obs.removeAttr('attributes');
        equal(p.getAttribute('some'), null, 'attribute is undefined');
        obs.attr('attributes', 'some="newText"');
        equal(p.getAttribute('some'), 'newText', 'attribute updated');
        obs.removeAttr('message');
        equal(span.innerHTML, '', 'text node value is empty');
        obs.attr('message', 'Warp drive, Mr. Sulu');
        equal(span.innerHTML, 'Warp drive, Mr. Sulu', 'text node updated');
        obs.removeAttr('show');
        equal(div.innerHTML, '', 'value in block statement is undefined');
        obs.attr('show', true);
        p = div.getElementsByTagName('p')[0];
        span = p.getElementsByTagName('span')[0];
        equal(p.getAttribute('some'), 'newText', 'value in block statement updated attr');
        equal(getAttr(p, 'class'), 'newClass', 'value in block statement updated class');
        equal(span.innerHTML, 'Warp drive, Mr. Sulu', 'value in block statement updated innerHTML');
    });
    test('hookup within a tag', function () {
        var text = '<div <%== obs.attr("foo") %> ' + '<%== obs.attr("baz") %>>lorem ipsum</div>', obs = new CanMap({
                foo: 'class="a"',
                baz: 'some=\'property\''
            }), compiled = new EJS({ text: text }).render({ obs: obs });
        var div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(compiled));
        var anchor = div.getElementsByTagName('div')[0];
        equal(getAttr(anchor, 'class'), 'a');
        equal(anchor.getAttribute('some'), 'property');
        obs.attr('foo', 'class="b"');
        equal(getAttr(anchor, 'class'), 'b');
        equal(anchor.getAttribute('some'), 'property');
        obs.attr('baz', 'some=\'new property\'');
        equal(getAttr(anchor, 'class'), 'b');
        equal(anchor.getAttribute('some'), 'new property');
        obs.attr('foo', 'class=""');
        obs.attr('baz', '');
        equal(getAttr(anchor, 'class'), '', 'anchor class blank');
        equal(anchor.getAttribute('some'), undefined, 'attribute "some" is undefined');
    });
    test('single escaped tag, removeAttr', function () {
        var text = '<div <%= obs.attr("foo") %>>lorem ipsum</div>', obs = new CanMap({ foo: 'data-bar="john doe\'s bar"' }), compiled = new EJS({ text: text }).render({ obs: obs });
        var div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(compiled));
        var anchor = div.getElementsByTagName('div')[0];
        equal(anchor.getAttribute('data-bar'), 'john doe\'s bar');
        obs.removeAttr('foo');
        equal(anchor.getAttribute('data-bar'), null);
        obs.attr('foo', 'data-bar="baz"');
        equal(anchor.getAttribute('data-bar'), 'baz');
    });
    test('html comments', function () {
        var text = '<!-- bind to changes in the todo list --> <div><%= obs.attr("foo") %></div>', obs = new CanMap({ foo: 'foo' }), compiled = new EJS({ text: text }).render({ obs: obs });
        var div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(compiled));
        equal(div.getElementsByTagName('div')[0].innerHTML, 'foo', 'Element as expected');
    });
    test('hookup and live binding', function () {
        var text = '<div class=\'<%= task.attr(\'completed\') ? \'complete\' : \'\' %>\' <%= (el)-> domData.set.call(el,\'task\',task) %>>' + '<%== task.attr(\'name\') %>' + '</div>', task = new CanMap({
                completed: false,
                className: 'someTask',
                name: 'My Name'
            }), compiled = new EJS({ text: text }).render({
                task: task,
                domData: domData
            }), div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(compiled));
        var child = div.getElementsByTagName('div')[0];
        ok(child.className.indexOf('complete') === -1, 'is incomplete');
        ok(!!domData.get.call(child, 'task'), 'has data');
        equal(child.innerHTML, 'My Name', 'has name');
        task.attr({
            completed: true,
            name: 'New Name'
        });
        ok(child.className.indexOf('complete') !== -1, 'is complete');
        equal(child.innerHTML, 'New Name', 'has new name');
    });
    test('unescape bindings change', function () {
        var l = new CanList([
            { complete: true },
            { complete: false },
            { complete: true }
        ]);
        var completed = function () {
            l.attr('length');
            var num = 0;
            l.each(function (item) {
                if (item.attr('complete')) {
                    num++;
                }
            });
            return num;
        };
        var text = '<div><%== completed() %></div>', compiled = new EJS({ text: text }).render({ completed: completed });
        var div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(compiled));
        var child = div.getElementsByTagName('div')[0];
        equal(child.innerHTML, '2', 'at first there are 2 true bindings');
        var item = new CanMap({
            complete: true,
            id: 'THIS ONE'
        });
        l.push(item);
        equal(child.innerHTML, '3', 'now there are 3 complete');
        item.attr('complete', false);
        equal(child.innerHTML, '2', 'now there are 2 complete');
        l.pop();
        item.attr('complete', true);
        equal(child.innerHTML, '2', 'there are still 2 complete');
    });
    test('escape bindings change', function () {
        var l = new CanList([
            { complete: true },
            { complete: false },
            { complete: true }
        ]);
        var completed = function () {
            l.attr('length');
            var num = 0;
            l.each(function (item) {
                if (item.attr('complete')) {
                    num++;
                }
            });
            return num;
        };
        var text = '<div><%= completed() %></div>', compiled = new EJS({ text: text }).render({ completed: completed });
        var div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(compiled));
        var child = div.getElementsByTagName('div')[0];
        equal(child.innerHTML, '2', 'at first there are 2 true bindings');
        var item = new CanMap({ complete: true });
        l.push(item);
        equal(child.innerHTML, '3', 'now there are 3 complete');
        item.attr('complete', false);
        equal(child.innerHTML, '2', 'now there are 2 complete');
    });
    test('tag bindings change', function () {
        var l = new CanList([
            { complete: true },
            { complete: false },
            { complete: true }
        ]);
        var completed = function () {
            l.attr('length');
            var num = 0;
            l.each(function (item) {
                if (item.attr('complete')) {
                    num++;
                }
            });
            return 'items=\'' + num + '\'';
        };
        var text = '<div <%= completed() %>></div>', compiled = new EJS({ text: text }).render({ completed: completed });
        var div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(compiled));
        var child = div.getElementsByTagName('div')[0];
        equal(child.getAttribute('items'), '2', 'at first there are 2 true bindings');
        var item = new CanMap({ complete: true });
        l.push(item);
        equal(child.getAttribute('items'), '3', 'now there are 3 complete');
        item.attr('complete', false);
        equal(child.getAttribute('items'), '2', 'now there are 2 complete');
    });
    test('attribute value bindings change', function () {
        var l = new CanList([
            { complete: true },
            { complete: false },
            { complete: true }
        ]);
        var completed = function () {
            l.attr('length');
            var num = 0;
            l.each(function (item) {
                if (item.attr('complete')) {
                    num++;
                }
            });
            return num;
        };
        var text = '<div items="<%= completed() %>"></div>', compiled = new EJS({ text: text }).render({ completed: completed });
        var div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(compiled));
        var child = div.getElementsByTagName('div')[0];
        equal(child.getAttribute('items'), '2', 'at first there are 2 true bindings');
        var item = new CanMap({ complete: true });
        l.push(item);
        equal(child.getAttribute('items'), '3', 'now there are 3 complete');
        item.attr('complete', false);
        equal(child.getAttribute('items'), '2', 'now there are 2 complete');
    });
    test('in tag toggling', function () {
        var text = '<div <%== obs.attr(\'val\') %>></div>';
        var obs = new CanMap({ val: 'foo="bar"' });
        var compiled = new EJS({ text: text }).render({ obs: obs });
        var div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(compiled));
        obs.attr('val', 'bar=\'foo\'');
        obs.attr('val', 'foo="bar"');
        var d2 = div.getElementsByTagName('div')[0];
        equal(d2.getAttribute('foo'), 'bar', 'bar set');
        equal(d2.getAttribute('bar'), null, 'bar set');
    });
    test('parent is right with bock', function () {
        var text = '<ul><% if(!obs.attr("items").length) { %>' + '<li>No items</li>' + '<% } else { %> <%== obs.attr("content") %>' + '<% } %></ul>', obs = new CanMap({
                content: '<li>Hello</li>',
                items: [{ name: 'Justin' }]
            }), compiled = new EJS({ text: text }).render({ obs: obs });
        var div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(compiled));
        var ul = div.getElementsByTagName('ul')[0];
        var li = div.getElementsByTagName('li')[0];
        ok(ul, 'we have a ul');
        ok(li, 'we have a li');
    });
    test('nested properties', function () {
        var text = '<div><%= obs.attr(\'name.first\')%></div>';
        var obs = new CanMap({ name: { first: 'Justin' } });
        var compiled = new EJS({ text: text }).render({ obs: obs });
        var div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(compiled));
        div = div.getElementsByTagName('div')[0];
        equal(div.innerHTML, 'Justin');
        obs.attr('name.first', 'Brian');
        equal(div.innerHTML, 'Brian');
    });
    test('tags without chidren or ending with /> do not change the state', function () {
        var text = '<table><tr><td></td><%== obs.attr(\'content\') %></tr></div>';
        var obs = new CanMap({ content: '<td>Justin</td>' });
        var compiled = new EJS({ text: text }).render({ obs: obs });
        var div = document.createElement('div');
        var html = legacyHelpers.view.frag(compiled);
        div.appendChild(html);
        equal(div.getElementsByTagName('span').length, 0, 'there are no spans');
        equal(div.getElementsByTagName('td').length, 2, 'there are 2 td');
    });
    test('trailing text', function () {
        var template = EJS('There are <%= this.attr(\'length\') %> todos');
        var div = document.createElement('div');
        div.appendChild(template(new CanList([
            {},
            {}
        ])));
        ok(/There are 2 todos/.test(div.innerHTML), 'got all text');
    });
    test('live binding select', function () {
        var text = '<select><% items.each(function(ob) { %>' + '<option value=\'<%= ob.attr(\'id\') %>\'><%= ob.attr(\'title\') %></option>' + '<% }); %></select>', items = new CanList([
                {
                    title: 'Make bugs',
                    is_done: true,
                    id: 0
                },
                {
                    title: 'Find bugs',
                    is_done: false,
                    id: 1
                },
                {
                    title: 'Fix bugs',
                    is_done: false,
                    id: 2
                }
            ]), compiled = new EJS({ text: text }).render({ items: items }), div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(compiled));
        equal(div.getElementsByTagName('option').length, 3, '3 items in list');
        var option = div.getElementsByTagName('option')[0];
        equal(option.value, '' + items[0].id, 'value attr set');
        equal(option.textContent || option.text, items[0].title, 'content of option');
        items.push({
            id: 3,
            name: 'Go to pub'
        });
        equal(div.getElementsByTagName('option').length, 4, '4 items in list');
    });
    test('live binding textarea', function () {
        var template = EJS('<textarea>Before<%= obs.attr(\'middle\') %>After</textarea>');
        var obs = new CanMap({ middle: 'yes' }), div = document.createElement('div');
        var node = template({ obs: obs });
        div.appendChild(node);
        var textarea = div.firstChild;
        equal(textarea.value, 'BeforeyesAfter');
        obs.attr('middle', 'Middle');
        equal(textarea.value, 'BeforeMiddleAfter');
    });
    test('reset on a live bound input', function () {
        var text = '<input type=\'text\' value=\'<%= person.attr(\'name\') %>\'><button type=\'reset\'>Reset</button>', person = new CanMap({ name: 'Bob' }), compiled = new EJS({ text: text }).render({ person: person }), form = document.createElement('form'), input;
        form.appendChild(legacyHelpers.view.frag(compiled));
        input = form.getElementsByTagName('input')[0];
        form.reset();
        equal(input.value, 'Bob', 'value is correct');
    });
    test('attribute unquoting', function () {
        var text = '<input type="radio" ' + '<%== facet.single ? \'name="facet-\' + facet.attr("id") + \'"\' : "" %> ' + 'value="<%= facet.single ? "facet-" + facet.attr("id") : "" %>" />', facet = new CanMap({
                id: 1,
                single: true
            }), compiled = new EJS({ text: text }).render({ facet: facet }), div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(compiled));
        equal(div.children[0].name, 'facet-1');
        equal(div.children[0].value, 'facet-1');
    });
    test('empty element hooks work correctly', function () {
        var text = '<div <%= function(e){ e.innerHTML = "1 Will show"; } %>></div>' + '<div <%= function(e){ e.innerHTML = "2 Will not show"; } %>></div>' + '3 Will not show';
        var compiled = new EJS({ text: text }).render(), div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(compiled));
        equal(div.childNodes.length, 3, 'all three elements present');
    });
    test('live binding with parent dependent tags but without parent tag present in template', function () {
        var text = [
            '<tbody>',
            '<% if( person.attr("first") ){ %>',
            '<tr><td><%= person.first %></td></tr>',
            '<% }%>',
            '<% if( person.attr("last") ){ %>',
            '<tr><td><%= person.last %></td></tr>',
            '<% } %>',
            '</tbody>'
        ];
        var person = new CanMap({
            first: 'Austin',
            last: 'McDaniel'
        });
        var compiled = new EJS({ text: text.join('\n') }).render({ person: person });
        var table = document.createElement('table');
        table.appendChild(legacyHelpers.view.frag(compiled));
        equal(table.getElementsByTagName('tr')[0].firstChild.nodeName.toUpperCase(), 'TD');
        equal(table.getElementsByTagName('tr')[0].firstChild.innerHTML, 'Austin');
        equal(table.getElementsByTagName('tr')[1].firstChild.nodeName.toUpperCase(), 'TD');
        equal(table.getElementsByTagName('tr')[1].firstChild.innerHTML, 'McDaniel');
        person.removeAttr('first');
        equal(table.getElementsByTagName('tr')[0].firstChild.nodeName.toUpperCase(), 'TD');
        equal(table.getElementsByTagName('tr')[0].firstChild.innerHTML, 'McDaniel');
        person.removeAttr('last');
        equal(table.getElementsByTagName('tr').length, 0);
        person.attr('first', 'Justin');
        equal(table.getElementsByTagName('tr')[0].firstChild.nodeName.toUpperCase(), 'TD');
        equal(table.getElementsByTagName('tr')[0].firstChild.innerHTML, 'Justin');
    });
    test('spaces between attribute name and value', function () {
        var text = '<input type="text" value = "<%= test %>" />', compiled = new EJS({ text: text }).render({ test: 'testing' }), div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(compiled));
        var input = div.getElementsByTagName('input')[0];
        equal(input.value, 'testing');
        equal(input.type, 'text');
    });
    test('live binding with computes', function () {
        var text = '<span><%= compute() %></span>', compute = canCompute(5), compiled = new EJS({ text: text }).render({ compute: compute }), div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(compiled));
        var span = div.getElementsByTagName('span');
        equal(span.length, 1);
        span = span[0];
        equal(span.innerHTML, '5');
        compute(6);
        equal(span.innerHTML, '6');
        compute('Justin');
        equal(span.innerHTML, 'Justin');
        compute(true);
        equal(span.innerHTML, 'true');
    });
    test('testing for clean tables', function () {
        var templateStr = '<table cellpadding="0" cellspacing="0" border="0" class="display">' + '<thead>' + '<tr>' + '<th> Game Name </th>' + '<th> Rating </th>' + '</tr>' + '</thead>' + '<tbody>' + '<% games.each( function(game) { %>' + '<tr class="game">' + '<td> <%= game.attr(\'name\') %></td>' + '<td> <%= game.attr(\'rating\') %></td>' + '</tr>' + '<% }) %>' + '<% games.each( function(game) { %>' + '<tr class="game">' + '<td> <%= game.attr(\'name\') %></td>' + '<td> <%= game.attr(\'rating\') %></td>' + '</tr>' + '<% }) %>' + '</tbody>' + '</table>';
        var template = EJS(templateStr);
        var games = new CanList();
        games.push({
            name: 'The Legend of Zelda',
            rating: 10
        });
        games.push({
            name: 'The Adventures of Link',
            rating: 9
        });
        games.push({
            name: 'Dragon Warrior',
            rating: 9
        });
        games.push({
            name: 'A Dude Named Daffl',
            rating: 8.5
        });
        var res = template({ games: games }), div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(res));
        ok(!/@@!!@@/.test(div.innerHTML), 'no placeholders');
    });
    test('Observe with array attributes', function () {
        var template = EJS('<ul><% list(todos, function(todo, i) { %><li><%= todos.attr(""+i) %></li><% }) %></ul><div><%= this.attr("message") %></div>');
        var div = document.createElement('div');
        var data = new CanMap({
            todos: [
                'Line #1',
                'Line #2',
                'Line #3'
            ],
            message: 'Hello',
            count: 2
        });
        div.appendChild(template(data));
        equal(div.getElementsByTagName('li')[1].innerHTML, 'Line #2', 'Check initial array');
        equal(div.getElementsByTagName('div')[0].innerHTML, 'Hello', 'Check initial message');
        data.attr('todos.1', 'Line #2 changed');
        data.attr('message', 'Hello again');
        equal(div.getElementsByTagName('li')[1].innerHTML, 'Line #2 changed', 'Check updated array');
        equal(div.getElementsByTagName('div')[0].innerHTML, 'Hello again', 'Check updated message');
    });
    test('hookup this correctly', function () {
        var obj = { from: 'cows' };
        var html = '<span <%== (el) -> domData.set.call(el, \'foo\', this.from) %>>tea</span>';
        var compiled = new EJS({ text: html }).render(obj, { domData: domData });
        var div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(compiled));
        var span = div.getElementsByTagName('span')[0];
        equal(domData.get.call(span, 'foo'), obj.from, 'object matches');
    });
    test('live binding with html comment', function () {
        var text = '<table><tr><th>Todo</th></tr><!-- do not bother with me -->' + '<% todos.each(function(todo){ %><tr><td><%= todo.name %></td></tr><% }) %></table>', Todos = new CanList([{
                    id: 1,
                    name: 'Dishes'
                }]), compiled = new EJS({ text: text }).render({ todos: Todos }), div = document.createElement('div');
        div.appendChild(legacyHelpers.view.frag(compiled));
        equal(div.getElementsByTagName('table')[0].getElementsByTagName('td').length, 1, '1 item in list');
        Todos.push({
            id: 2,
            name: 'Laundry'
        });
        equal(div.getElementsByTagName('table')[0].getElementsByTagName('td').length, 2, '2 items in list');
        Todos.splice(0, 2);
        equal(div.getElementsByTagName('table')[0].getElementsByTagName('td').length, 0, '0 items in list');
    });
    test('HTML comment with element callback', function () {
        var text = [
                '<ul>',
                '<% todos.each(function(todo) { %>',
                '<li<%= (el) -> domData.set.call(el,\'todo\',todo) %>>',
                '<!-- html comment #1 -->',
                '<%= todo.name %>',
                '<!-- html comment #2 -->',
                '</li>',
                '<% }) %>',
                '</ul>'
            ], Todos = new CanList([{
                    id: 1,
                    name: 'Dishes'
                }]), compiled = new EJS({ text: text.join('\n') }).render({
                todos: Todos,
                domData: domData
            }), div = document.createElement('div'), li, comments;
        comments = function (el) {
            var count = 0;
            for (var i = 0; i < el.childNodes.length; i++) {
                if (el.childNodes[i].nodeType === 8) {
                    ++count;
                }
            }
            return count;
        };
        div.appendChild(legacyHelpers.view.frag(compiled));
        li = div.getElementsByTagName('ul')[0].getElementsByTagName('li');
        equal(li.length, 1, '1 item in list');
        equal(comments(li[0]), 2, '2 comments in item #1');
        Todos.push({
            id: 2,
            name: 'Laundry'
        });
        equal(li.length, 2, '2 items in list');
        equal(comments(li[0]), 2, '2 comments in item #1');
        equal(comments(li[1]), 2, '2 comments in item #2');
        Todos.splice(0, 2);
        equal(li.length, 0, '0 items in list');
    });
    test('correctness of data-view-id and only in tag opening', function () {
        var text = [
                '<textarea><select><% list(this.items, function(item) { %>',
                '<option<%= (el) -> el.data(\'item\', item) %>><%= item.title %></option>',
                '<% }) %></select></textarea>'
            ], items = [
                {
                    id: 1,
                    title: 'One'
                },
                {
                    id: 2,
                    title: 'Two'
                }
            ], compiled = new EJS({ text: text.join('') }).render({ items: items }), expected = '^<textarea data-view-id=\'[0-9]+\'><select><option data-view-id=\'[0-9]+\'>One</option>' + '<option data-view-id=\'[0-9]+\'>Two</option></select></textarea>$';
        ok(compiled.search(expected) === 0, 'Rendered output is as expected');
        legacyHelpers.view.hookups = {};
    });
    test('return blocks within element tags', function () {
        var animals = new CanList([
                'sloth',
                'bear'
            ]), template = '<ul>' + '<%==lister(animals, function(animal){%>' + '<li><%=animal %></li>' + '<%})%>' + '</ul>';
        var renderer = EJS(template);
        var div = document.createElement('div');
        var frag = renderer({
            lister: function () {
                return function (el) {
                    equal(el.nodeName.toLowerCase(), 'li', 'got the LI it created');
                };
            },
            animals: animals
        });
        div.appendChild(frag);
    });
    test('Each does not redraw items', function () {
        var animals = new CanList([
                'sloth',
                'bear'
            ]), template = '<div>my<b>favorite</b>animals:' + '<%==each(animals, function(animal){%>' + '<label>Animal=</label> <span><%=animal %></span>' + '<%})%>' + '!</div>';
        var renderer = EJS(template);
        var div = document.createElement('div');
        var frag = renderer({ animals: animals });
        div.appendChild(frag);
        div.getElementsByTagName('label')[0].myexpando = 'EXPANDO-ED';
        equal(div.getElementsByTagName('label').length, 2, 'There are 2 labels');
        animals.push('turtle');
        equal(div.getElementsByTagName('label')[0].myexpando, 'EXPANDO-ED', 'same expando');
        equal(div.getElementsByTagName('span')[2].innerHTML, 'turtle', 'turtle added');
    });
    test('Each works with no elements', function () {
        var animals = new CanList([
                'sloth',
                'bear'
            ]), template = '<%==each(animals, function(animal){%>' + '<%=animal %> ' + '<%})%>';
        var renderer = EJS(template);
        var div = document.createElement('div');
        var frag = renderer({ animals: animals });
        div.appendChild(frag);
        animals.push('turtle');
        equal(div.innerHTML, 'sloth bear turtle ', 'turtle added');
    });
    test('Each does not redraw items (normal array)', function () {
        var animals = [
                'sloth',
                'bear',
                'turtle'
            ], template = '<div>my<b>favorite</b>animals:' + '<%each(animals, function(animal){%>' + '<label>Animal=</label> <span><%=animal %></span>' + '<%})%>' + '!</div>';
        var renderer = EJS(template);
        var div = document.createElement('div');
        var frag = renderer({ animals: animals });
        div.appendChild(frag);
        div.getElementsByTagName('label')[0].myexpando = 'EXPANDO-ED';
        equal(div.getElementsByTagName('label').length, 3, 'There are 2 labels');
        equal(div.getElementsByTagName('label')[0].myexpando, 'EXPANDO-ED', 'same expando');
        equal(div.getElementsByTagName('label')[0].myexpando, 'EXPANDO-ED', 'same expando');
        equal(div.getElementsByTagName('span')[2].innerHTML, 'turtle', 'turtle added');
    });
    test('list works within another branch', function () {
        var animals = new CanList([]), template = '<div>Animals:' + '<% if( animals.attr(\'length\') ){ %>~' + '<% animals.each(function(animal){%>' + '<span><%=animal %></span>' + '<%})%>' + '<% } else { %>' + 'No animals' + '<% } %>' + '!</div>';
        var renderer = EJS(template);
        var div = document.createElement('div');
        var frag = renderer({ animals: animals });
        div.appendChild(frag);
        equal(div.getElementsByTagName('div')[0].innerHTML, 'Animals:No animals!');
        animals.push('sloth');
        equal(div.getElementsByTagName('span').length, 1, 'There is 1 sloth');
        animals.pop();
        equal(div.getElementsByTagName('div')[0].innerHTML, 'Animals:No animals!');
    });
    test('each works within another branch', function () {
        var animals = new CanList([]), template = '<div>Animals:' + '<% if( animals.attr(\'length\') ){ %>~' + '<%==each(animals, function(animal){%>' + '<span><%=animal %></span>' + '<%})%>' + '<% } else { %>' + 'No animals' + '<% } %>' + '!</div>';
        var renderer = EJS(template);
        var div = document.createElement('div');
        var frag = renderer({ animals: animals });
        div.appendChild(frag);
        equal(div.getElementsByTagName('div')[0].innerHTML, 'Animals:No animals!');
        animals.push('sloth');
        equal(div.getElementsByTagName('span').length, 1, 'There is 1 sloth');
        animals.pop();
        equal(div.getElementsByTagName('div')[0].innerHTML, 'Animals:No animals!');
    });
    test('Access .length with nested dot notation', function () {
        var template = '<span id="nested"><%= this.attr("list.length") %></span>' + '<span id="unnested"><%= this.list.attr("length") %></span>', obj = new CanMap({
                list: [
                    0,
                    1,
                    2,
                    3
                ]
            }), renderer = EJS(template), div = document.createElement('div');
        div.appendChild(renderer(obj));
        ok(div.getElementsByTagName('span')[0].innerHTML === '4', 'Nested dot notation.');
        ok(div.getElementsByTagName('span')[1].innerHTML === '4', 'Not-nested dot notation.');
    });
    test('attributes in truthy section', function () {
        var template = EJS('<p <% if(attribute) {%>data-test="<%=attribute%>"<% } %>></p>');
        var data1 = { attribute: 'test-value' };
        var frag1 = template(data1);
        var div1 = document.createElement('div');
        div1.appendChild(frag1);
        equal(div1.children[0].getAttribute('data-test'), 'test-value', 'hyphenated attribute value');
        var data2 = { attribute: 'test value' };
        var frag2 = template(data2);
        var div2 = document.createElement('div');
        div2.appendChild(frag2);
        equal(div2.children[0].getAttribute('data-test'), 'test value', 'whitespace in attribute value');
    });
    test('outputting array of attributes', function () {
        var template = EJS('<p <% for(var i = 0; i < attribute.length; i++) { %><%=attribute[i].name%>="<%=attribute[i].value%>"<%}%>></p>');
        var data = {
            attribute: [
                {
                    'name': 'data-test1',
                    'value': 'value1'
                },
                {
                    'name': 'data-test2',
                    'value': 'value2'
                },
                {
                    'name': 'data-test3',
                    'value': 'value3'
                }
            ]
        };
        var frag = template(data);
        var div = document.createElement('div');
        div.appendChild(frag);
        equal(div.children[0].getAttribute('data-test1'), 'value1', 'first value');
        equal(div.children[0].getAttribute('data-test2'), 'value2', 'second value');
        equal(div.children[0].getAttribute('data-test3'), 'value3', 'third value');
    });
    test('_bindings removed when element removed', function () {
        var template = EJS('<div id="game"><% if(game.attr("league")) { %><%= game.attr("name") %><% } %></div>'), game = new CanMap({
                'name': 'Fantasy Baseball',
                'league': 'Malamonsters'
            });
        var frag = template({ game: game });
        var div = document.getElementById('qunit-fixture');
        div.appendChild(frag);
        domMutate.removeChild.call(div, div.firstChild);
        stop();
        setTimeout(function () {
            start();
            equal(game.__bindEvents._lifecycleBindings, 0, 'No bindings left');
        }, 100);
    });
});
/*can@3.9.0-pre.0#view/ejs/ejs_test*/
define('can@3.9.0-pre.0#view/ejs/ejs_test', function (require, exports, module) {
    require('can-ejs/test/can-ejs_test');
});
/*can-connect@1.5.3#connect*/
define('can-connect@1.5.3#connect', function (require, exports, module) {
    var assign = require('can-util/js/assign/assign');
    var connect = function (behaviors, options) {
        behaviors = behaviors.map(function (behavior, index) {
            var sortedIndex = -1;
            if (typeof behavior === 'string') {
                sortedIndex = connect.order.indexOf(behavior);
                behavior = behaviorsMap[behavior];
            } else if (behavior.isBehavior) {
                sortedIndex = connect.order.indexOf(behavior.behaviorName);
            } else {
                behavior = connect.behavior(behavior);
            }
            return {
                originalIndex: index,
                sortedIndex: sortedIndex,
                behavior: behavior
            };
        });
        behaviors.sort(function (b1, b2) {
            if (~b1.sortedIndex && ~b2.sortedIndex) {
                return b1.sortedIndex - b2.sortedIndex;
            }
            return b1.originalIndex - b2.originalIndex;
        });
        behaviors = behaviors.map(function (b) {
            return b.behavior;
        });
        var behavior = connect.base(connect.behavior('options', function () {
            return options;
        })());
        behaviors.forEach(function (behave) {
            behavior = behave(behavior);
        });
        if (behavior.init) {
            behavior.init();
        }
        return behavior;
    };
    connect.order = [
        'data/localstorage-cache',
        'data/url',
        'data/parse',
        'cache-requests',
        'data/combine-requests',
        'constructor',
        'constructor/store',
        'can/map',
        'can/ref',
        'fall-through-cache',
        'data/worker',
        'real-time',
        'data/callbacks-cache',
        'data/callbacks',
        'constructor/callbacks-once'
    ];
    connect.behavior = function (name, behavior) {
        if (typeof name !== 'string') {
            behavior = name;
            name = undefined;
        }
        var behaviorMixin = function (base) {
            var Behavior = function () {
            };
            Behavior.name = name;
            Behavior.prototype = base;
            var newBehavior = new Behavior();
            var res = typeof behavior === 'function' ? behavior.apply(newBehavior, arguments) : behavior;
            assign(newBehavior, res);
            newBehavior.__behaviorName = name;
            return newBehavior;
        };
        if (name) {
            behaviorMixin.behaviorName = name;
            behaviorsMap[name] = behaviorMixin;
        }
        behaviorMixin.isBehavior = true;
        return behaviorMixin;
    };
    var behaviorsMap = {};
    module.exports = connect;
});
/*can-connect@1.5.3#base/base*/
define('can-connect@1.5.3#base/base', function (require, exports, module) {
    var connect = require('can-connect/connect');
    module.exports = connect.behavior('base', function (baseConnection) {
        return {
            id: function (instance) {
                var ids = [], algebra = this.algebra;
                if (algebra && algebra.clauses && algebra.clauses.id) {
                    for (var prop in algebra.clauses.id) {
                        ids.push(instance[prop]);
                    }
                }
                if (this.idProp && !ids.length) {
                    ids.push(instance[this.idProp]);
                }
                if (!ids.length) {
                    ids.push(instance.id);
                }
                return ids.length > 1 ? ids.join('@|@') : ids[0];
            },
            idProp: baseConnection.idProp || 'id',
            listSet: function (list) {
                return list[this.listSetProp];
            },
            listSetProp: '__listSet',
            init: function () {
            }
        };
    });
});
/*can-connect@1.5.3#can-connect*/
define('can-connect@1.5.3#can-connect', function (require, exports, module) {
    var connect = require('can-connect/connect');
    var base = require('can-connect/base/base');
    var ns = require('can-namespace');
    connect.base = base;
    module.exports = ns.connect = connect;
});
/*can-fixture@1.1.0#helpers/getid*/
define('can-fixture@1.1.0#helpers/getid', function (require, exports, module) {
    module.exports = function (xhrSettings, fixtureSettings) {
        var id = xhrSettings.data.id;
        if (id === undefined && typeof xhrSettings.data === 'number') {
            id = xhrSettings.data;
        }
        if (id === undefined) {
            xhrSettings.url.replace(/\/(\d+)(\/|$|\.)/g, function (all, num) {
                id = num;
            });
        }
        if (id === undefined) {
            id = xhrSettings.url.replace(/\/(\w+)(\/|$|\.)/g, function (all, num) {
                if (num !== 'update') {
                    id = num;
                }
            });
        }
        if (id === undefined) {
            id = Math.round(Math.random() * 1000);
        }
        return id;
    };
});
/*can-fixture@1.1.0#helpers/legacyStore*/
define('can-fixture@1.1.0#helpers/legacyStore', function (require, exports, module) {
    var getId = require('./getid');
    var canSet = require('can-set');
    var isArrayLike = require('can-util/js/is-array-like/is-array-like');
    var each = require('can-util/js/each/each');
    var assign = require('can-util/js/assign/assign');
    function getStartingId(items) {
        var startingId = 0;
        each(items, function (item) {
            if (typeof item.id === 'number') {
                startingId = Math.max(startingId, item.id + 1);
            }
        });
        return startingId;
    }
    module.exports = function (count, make, filter) {
        var nextItemId;
        var getNextItemId = function () {
            return nextItemId++;
        };
        var items, findOne = function (id) {
                for (var i = 0; i < items.length; i++) {
                    if (id == items[i].id) {
                        return items[i];
                    }
                }
            }, methods = {}, types, reset;
        if (isArrayLike(count) && typeof count[0] === 'string') {
            types = count;
            count = make;
            make = filter;
            filter = arguments[3];
        } else if (typeof count === 'string') {
            types = [
                count + 's',
                count
            ];
            count = make;
            make = filter;
            filter = arguments[3];
        }
        if (typeof count === 'number') {
            nextItemId = 0;
            items = [];
            reset = function () {
                items = [];
                for (var i = 0; i < count; i++) {
                    var item = make(i, items);
                    if (!item.id) {
                        item.id = getNextItemId();
                    }
                    items.push(item);
                }
            };
        } else {
            filter = make;
            var initialItems = count;
            nextItemId = getStartingId(initialItems);
            reset = function () {
                items = initialItems.slice(0);
            };
        }
        assign(methods, {
            getListData: function (request) {
                request = request || {};
                var retArr = items.slice(0);
                request.data = request.data || {};
                each((request.data.order || []).slice(0).reverse(), function (name) {
                    var split = name.split(' ');
                    retArr = retArr.sort(function (a, b) {
                        if (split[1].toUpperCase() !== 'ASC') {
                            if (a[split[0]] < b[split[0]]) {
                                return 1;
                            } else if (a[split[0]] === b[split[0]]) {
                                return 0;
                            } else {
                                return -1;
                            }
                        } else {
                            if (a[split[0]] < b[split[0]]) {
                                return -1;
                            } else if (a[split[0]] === b[split[0]]) {
                                return 0;
                            } else {
                                return 1;
                            }
                        }
                    });
                });
                each((request.data.group || []).slice(0).reverse(), function (name) {
                    var split = name.split(' ');
                    retArr = retArr.sort(function (a, b) {
                        return a[split[0]] > b[split[0]];
                    });
                });
                var offset = parseInt(request.data.offset, 10) || 0, limit = parseInt(request.data.limit, 10) || items.length - offset, i = 0;
                for (var param in request.data) {
                    i = 0;
                    if (request.data[param] !== undefined && (param.indexOf('Id') !== -1 || param.indexOf('_id') !== -1)) {
                        while (i < retArr.length) {
                            if (request.data[param] != retArr[i][param]) {
                                retArr.splice(i, 1);
                            } else {
                                i++;
                            }
                        }
                    }
                }
                if (typeof filter === 'function') {
                    i = 0;
                    while (i < retArr.length) {
                        if (!filter(retArr[i], request)) {
                            retArr.splice(i, 1);
                        } else {
                            i++;
                        }
                    }
                } else if (typeof filter === 'object') {
                    i = 0;
                    while (i < retArr.length) {
                        var subset = canSet.subset(retArr[i], request.data, filter);
                        if (!subset) {
                            retArr.splice(i, 1);
                        } else {
                            i++;
                        }
                    }
                }
                var responseData = {
                    'count': retArr.length,
                    'data': retArr.slice(offset, offset + limit)
                };
                each([
                    'limit',
                    'offset'
                ], function (prop) {
                    if (prop in request.data) {
                        responseData[prop] = request.data[prop];
                    }
                });
                return responseData;
            },
            getData: function (request, response) {
                var item = findOne(getId(request));
                if (typeof item === 'undefined') {
                    return response(404, 'Requested resource not found');
                }
                response(item);
            },
            updateData: function (request, response) {
                var id = getId(request), item = findOne(id);
                if (typeof item === 'undefined') {
                    return response(404, 'Requested resource not found');
                }
                assign(item, request.data);
                response({ id: id }, { location: request.url || '/' + getId(request) });
            },
            destroyData: function (request, response) {
                var id = getId(request), item = findOne(id);
                if (typeof item === 'undefined') {
                    return response(404, 'Requested resource not found');
                }
                for (var i = 0; i < items.length; i++) {
                    if (items[i].id == id) {
                        items.splice(i, 1);
                        break;
                    }
                }
                return {};
            },
            createData: function (settings, response) {
                var item = typeof make === 'function' ? make(items.length, items) : {};
                assign(item, settings.data);
                if (!item.id) {
                    item.id = getNextItemId();
                }
                items.push(item);
                response({ id: item.id }, { location: settings.url + '/' + item.id });
            }
        });
        reset();
        return assign({
            findAll: methods.getListData,
            findOne: methods.getData,
            create: methods.createData,
            update: methods.updateData,
            destroy: methods.destroyData,
            getId: getId,
            find: function (settings) {
                return findOne(getId(settings));
            },
            reset: reset
        }, methods);
    };
});
/*can-connect@1.5.3#helpers/get-items*/
define('can-connect@1.5.3#helpers/get-items', function (require, exports, module) {
    var isArray = require('can-util/js/is-array/is-array');
    module.exports = function (data) {
        if (isArray(data)) {
            return data;
        } else {
            return data.data;
        }
    };
});
/*can-connect@1.5.3#helpers/sorted-set-json*/
define('can-connect@1.5.3#helpers/sorted-set-json', function (require, exports, module) {
    var forEach = [].forEach;
    var keys = Object.keys;
    module.exports = function (set) {
        if (set == null) {
            return set;
        } else {
            var sorted = {};
            forEach.call(keys(set).sort(), function (prop) {
                sorted[prop] = set[prop];
            });
            return JSON.stringify(sorted);
        }
    };
});
/*can-connect@1.5.3#helpers/overwrite*/
define('can-connect@1.5.3#helpers/overwrite', function (require, exports, module) {
    module.exports = function (d, s, id) {
        for (var prop in d) {
            if (prop !== id && !(prop in s)) {
                delete d[prop];
            }
        }
        for (prop in s) {
            d[prop] = s[prop];
        }
        return d;
    };
});
/*can-connect@1.5.3#helpers/set-add*/
define('can-connect@1.5.3#helpers/set-add', function (require, exports, module) {
    var canSet = require('can-set');
    module.exports = function (connection, setItems, items, item, algebra) {
        var index = canSet.index(setItems, items, item, algebra);
        if (index === undefined) {
            index = items.length;
        }
        var copy = items.slice(0);
        copy.splice(index, 0, item);
        return copy;
    };
});
/*can-connect@1.5.3#helpers/get-index-by-id*/
define('can-connect@1.5.3#helpers/get-index-by-id', function (require, exports, module) {
    module.exports = function (connection, props, items) {
        var id = connection.id(props);
        for (var i = 0; i < items.length; i++) {
            var connId = connection.id(items[i]);
            if (id == connId) {
                return i;
            }
        }
        return -1;
    };
});
/*can-connect@1.5.3#helpers/clone-data*/
define('can-connect@1.5.3#helpers/clone-data', function (require, exports, module) {
    var isArray = require('can-util/js/is-array/is-array');
    var deepAssign = require('can-util/js/deep-assign/deep-assign');
    module.exports = function (data) {
        return isArray(data) ? data.slice(0) : deepAssign({}, data);
    };
});
/*can-connect@1.5.3#data/memory-cache/memory-cache*/
define('can-connect@1.5.3#data/memory-cache/memory-cache', function (require, exports, module) {
    var getItems = require('can-connect/helpers/get-items');
    var connect = require('can-connect');
    var sortedSetJSON = require('can-connect/helpers/sorted-set-json');
    var canSet = require('can-set');
    var overwrite = require('can-connect/helpers/overwrite');
    var setAdd = require('can-connect/helpers/set-add');
    var indexOf = require('can-connect/helpers/get-index-by-id');
    var assign = require('can-util/js/assign/assign');
    var cloneData = require('can-connect/helpers/clone-data');
    module.exports = connect.behavior('data/memory-cache', function (baseConnection) {
        var behavior = {
            _sets: {},
            getSetData: function () {
                return this._sets;
            },
            __getListData: function (set) {
                var setsData = this.getSetData();
                var setData = setsData[sortedSetJSON(set)];
                if (setData) {
                    return setData.items;
                }
            },
            _instances: {},
            getInstance: function (id) {
                return this._instances[id];
            },
            removeSet: function (setKey, noUpdate) {
                var sets = this.getSetData();
                delete sets[setKey];
                if (noUpdate !== true) {
                    this.updateSets();
                }
            },
            updateSets: function () {
            },
            updateInstance: function (props) {
                var id = this.id(props);
                if (!(id in this._instances)) {
                    this._instances[id] = props;
                } else {
                    overwrite(this._instances[id], props, this.idProp);
                }
                return this._instances[id];
            },
            updateSet: function (setDatum, items, newSet) {
                var newSetKey = newSet ? sortedSetJSON(newSet) : setDatum.setKey;
                if (newSet) {
                    if (newSetKey !== setDatum.setKey) {
                        var sets = this.getSetData();
                        var oldSetKey = setDatum.setKey;
                        sets[newSetKey] = setDatum;
                        setDatum.setKey = newSetKey;
                        setDatum.set = assign({}, newSet);
                        this.removeSet(oldSetKey);
                    }
                }
                setDatum.items = items;
                var self = this;
                items.forEach(function (item) {
                    self.updateInstance(item);
                });
            },
            addSet: function (set, data) {
                var items = getItems(data);
                var sets = this.getSetData();
                var setKey = sortedSetJSON(set);
                sets[setKey] = {
                    setKey: setKey,
                    items: items,
                    set: assign({}, set)
                };
                var self = this;
                items.forEach(function (item) {
                    self.updateInstance(item);
                });
                this.updateSets();
            },
            _eachSet: function (cb) {
                var sets = this.getSetData();
                var self = this;
                var loop = function (setDatum, setKey) {
                    return cb.call(self, setDatum, setKey, function () {
                        return setDatum.items;
                    });
                };
                for (var setKey in sets) {
                    var setDatum = sets[setKey];
                    var result = loop(setDatum, setKey);
                    if (result !== undefined) {
                        return result;
                    }
                }
            },
            _getSets: function () {
                var sets = [], setsData = this.getSetData();
                for (var prop in setsData) {
                    sets.push(setsData[prop].set);
                }
                return sets;
            },
            getSets: function () {
                return Promise.resolve(this._getSets());
            },
            clear: function () {
                this._instances = {};
                this._sets = {};
            },
            getListData: function (set) {
                set = set || {};
                var listData = this.getListDataSync(set);
                if (listData) {
                    return Promise.resolve(listData);
                }
                return Promise.reject({
                    message: 'no data',
                    error: 404
                });
            },
            getListDataSync: function (set) {
                var sets = this._getSets();
                for (var i = 0; i < sets.length; i++) {
                    var checkSet = sets[i];
                    if (canSet.subset(set, checkSet, this.algebra)) {
                        var source = this.__getListData(checkSet);
                        var items = canSet.getSubset(set, checkSet, source, this.algebra);
                        return {
                            data: items,
                            count: source.length
                        };
                    }
                }
            },
            _getListData: function (set) {
                return this.getListDataSync(set);
            },
            updateListData: function (data, set) {
                set = set || {};
                var clonedData = cloneData(data);
                var items = getItems(clonedData);
                var sets = this.getSetData();
                var self = this;
                for (var setKey in sets) {
                    var setDatum = sets[setKey];
                    var union = canSet.union(setDatum.set, set, this.algebra);
                    if (union) {
                        var getSet = assign({}, setDatum.set);
                        return this.getListData(getSet).then(function (setData) {
                            self.updateSet(setDatum, canSet.getUnion(getSet, set, getItems(setData), items, self.algebra), union);
                        });
                    }
                }
                this.addSet(set, clonedData);
                return Promise.resolve();
            },
            getData: function (params) {
                var id = this.id(params);
                var res = this.getInstance(id);
                if (res) {
                    return Promise.resolve(res);
                } else {
                    return Promise.reject({
                        message: 'no data',
                        error: 404
                    });
                }
            },
            createData: function (props) {
                var self = this;
                var instance = this.updateInstance(props);
                this._eachSet(function (setDatum, setKey, getItems) {
                    if (canSet.has(setDatum.set, instance, this.algebra)) {
                        self.updateSet(setDatum, setAdd(self, setDatum.set, getItems(), instance, self.algebra), setDatum.set);
                    }
                });
                return Promise.resolve(assign({}, instance));
            },
            updateData: function (props) {
                var self = this;
                var instance = this.updateInstance(props);
                this._eachSet(function (setDatum, setKey, getItems) {
                    var items = getItems();
                    var index = indexOf(self, instance, items);
                    if (canSet.subset(instance, setDatum.set, this.algebra)) {
                        if (index === -1) {
                            self.updateSet(setDatum, setAdd(self, setDatum.set, getItems(), instance, self.algebra));
                        } else {
                            items.splice(index, 1, instance);
                            self.updateSet(setDatum, items);
                        }
                    } else if (index !== -1) {
                        items.splice(index, 1);
                        self.updateSet(setDatum, items);
                    }
                });
                return Promise.resolve(assign({}, instance));
            },
            destroyData: function (props) {
                var self = this;
                this._eachSet(function (setDatum, setKey, getItems) {
                    var items = getItems();
                    var index = indexOf(self, props, items);
                    if (index !== -1) {
                        items.splice(index, 1);
                        self.updateSet(setDatum, items);
                    }
                });
                var id = this.id(props);
                delete this._instances[id];
                return Promise.resolve(assign({}, props));
            }
        };
        return behavior;
    });
});
/*can-fixture@1.1.0#store*/
define('can-fixture@1.1.0#store', function (require, exports, module) {
    var canSet = require('can-set');
    var connect = require('can-connect');
    var legacyStore = require('./helpers/legacyStore');
    var each = require('can-util/js/each/each');
    var assign = require('can-util/js/assign/assign');
    var isArrayLike = require('can-util/js/is-array-like/is-array-like');
    var dataMemoryCache = require('can-connect/data/memory-cache/memory-cache');
    var firstProp = function (obj) {
        for (var prop in obj) {
            return prop;
        }
    };
    var connectToConnection = function (method) {
        return function (req, res) {
            this.connection[method](req.data).then(function (data) {
                res(data);
            }, function (err) {
                res(403, err);
            });
        };
    };
    var makeMakeItems = function (baseItems, idProp) {
        return function () {
            var items = [], maxId = 0;
            each(baseItems, function (item) {
                items.push(JSON.parse(JSON.stringify(item)));
                maxId = Math.max(item[idProp] + 1, maxId + 1) || items.length;
            });
            return {
                maxId: maxId,
                items: items
            };
        };
    };
    var Store = function (connection, makeItems, idProp) {
        this.connection = connection;
        this.makeItems = makeItems;
        this.idProp = idProp;
        this.reset();
        for (var method in Store.prototype) {
            this[method] = this[method].bind(this);
        }
    };
    assign(Store.prototype, {
        getListData: connectToConnection('getListData'),
        getData: connectToConnection('getData'),
        createData: function (req, res) {
            var idProp = this.idProp;
            req.data[idProp] = ++this.maxId;
            this.connection.createData(req.data).then(function (data) {
                var responseData = {};
                responseData[idProp] = req.data[idProp];
                res(responseData);
            }, function (err) {
                res(403, err);
            });
        },
        updateData: connectToConnection('updateData'),
        destroyData: connectToConnection('destroyData'),
        reset: function (newItems) {
            if (newItems) {
                this.makeItems = makeMakeItems(newItems, this.idProp);
            }
            var itemData = this.makeItems();
            this.maxId = itemData.maxId;
            this.connection.addSet({}, { data: itemData.items });
        },
        get: function (params) {
            var id = this.connection.id(params);
            return this.connection.getInstance(id);
        },
        getList: function (set) {
            return this.connection._getListData(set);
        }
    });
    each({
        findAll: 'getListData',
        findOne: 'getData',
        create: 'createData',
        update: 'updateData',
        destroy: 'destroyData'
    }, function (method, prop) {
        Store.prototype[prop] = function () {
            return this[method].apply(this, arguments);
        };
    });
    Store.make = function (count, make, algebra) {
        var isNew = false;
        if (count instanceof canSet.Algebra || make instanceof canSet.Algebra || algebra instanceof canSet.Algebra) {
            isNew = true;
        }
        if (!isNew) {
            return legacyStore.apply(this, arguments);
        }
        var makeItems, idProp;
        if (typeof count === 'number') {
            idProp = firstProp(algebra.clauses.id || {}) || 'id';
            makeItems = function () {
                var items = [];
                var maxId = 0;
                for (var i = 0; i < count; i++) {
                    var item = make(i, items);
                    if (!item[idProp]) {
                        item[idProp] = i;
                    }
                    maxId = Math.max(item[idProp] + 1, maxId + 1) || items.length;
                    items.push(item);
                }
                return {
                    maxId: maxId,
                    items: items
                };
            };
        } else if (isArrayLike(count)) {
            algebra = make;
            idProp = firstProp(algebra.clauses.id || {}) || 'id';
            makeItems = makeMakeItems(count, idProp);
        }
        var connection = connect([dataMemoryCache], {
            algebra: algebra,
            idProp: idProp
        });
        return new Store(connection, makeItems, idProp);
    };
    module.exports = Store;
});
/*can-fixture@1.1.0#core*/
define('can-fixture@1.1.0#core', function (require, exports, module) {
    var canSet = require('can-set');
    var sub = require('can-util/js/string/string').sub;
    var each = require('can-util/js/each/each');
    var assign = require('can-util/js/assign/assign');
    var isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');
    var canLog = require('can-util/js/log/log');
    var canDev = require('can-util/js/dev/dev');
    require('./store');
    var fixtures = [];
    exports.fixtures = fixtures;
    function isStoreLike(fixture) {
        return fixture && (fixture.getData || fixture.getListData);
    }
    var methodMapping = {
        item: {
            'GET': 'getData',
            'PUT': 'updateData',
            'DELETE': 'destroyData'
        },
        list: {
            'GET': 'getListData',
            'POST': 'createData'
        }
    };
    function getMethodAndPath(route) {
        var matches = route.match(/(GET|POST|PUT|DELETE|PATCH) (.+)/i);
        if (!matches) {
            return [
                undefined,
                route
            ];
        }
        var method = matches[1];
        var path = matches[2];
        return [
            method,
            path
        ];
    }
    function inferIdProp(url) {
        var wrappedInBraces = /\{(.*)\}/;
        var matches = url.match(wrappedInBraces);
        var isUniqueMatch = matches && matches.length === 2;
        if (isUniqueMatch) {
            return matches[1];
        }
    }
    function getItemAndListUrls(url, idProp) {
        idProp = idProp || inferIdProp(url);
        if (!idProp) {
            return [
                undefined,
                url
            ];
        }
        var itemRegex = new RegExp('\\/\\{' + idProp + '\\}.*');
        var rootIsItemUrl = itemRegex.test(url);
        var listUrl = rootIsItemUrl ? url.replace(itemRegex, '') : url;
        var itemUrl = rootIsItemUrl ? url : url.trim() + '/{' + idProp + '}';
        return [
            itemUrl,
            listUrl
        ];
    }
    function addStoreFixture(root, store) {
        var settings = {};
        var typeAndUrl = getMethodAndPath(root);
        var type = typeAndUrl[0];
        var url = typeAndUrl[1];
        var itemAndListUrls = getItemAndListUrls(url, store.idProp);
        var itemUrl = itemAndListUrls[0];
        var listUrl = itemAndListUrls[1];
        if (type) {
            var warning = ['fixture("' + root + '", fixture) must use a store method, not a store directly.'];
            if (itemUrl) {
                var itemAction = methodMapping.item[type];
                if (itemAction) {
                    settings[type + ' ' + itemUrl] = store[itemAction];
                    var itemWarning = 'Replace with fixture("' + type + ' ' + itemUrl + '", fixture.' + itemAction + ') for items.';
                    warning.push(itemWarning);
                }
            }
            var listAction = methodMapping.list[type];
            if (listAction) {
                settings[type + ' ' + listUrl] = store[listAction];
                var listWarning = 'Replace with fixture("' + type + ' ' + listUrl + '", fixture.' + listAction + ') for lists.';
                warning.push(listWarning);
            }
            var message = warning.join(' ');
            canDev.warn(message);
        } else {
            var itemMapping = methodMapping.item;
            for (var itemMethod in itemMapping) {
                var storeItemMethod = itemMapping[itemMethod];
                settings[itemMethod + ' ' + itemUrl] = store[storeItemMethod];
            }
            var listMapping = methodMapping.list;
            for (var listMethod in listMapping) {
                var storeListMethod = listMapping[listMethod];
                settings[listMethod + ' ' + listUrl] = store[storeListMethod];
            }
        }
        return settings;
    }
    function getSettingsFromString(route) {
        var typeAndUrl = getMethodAndPath(route);
        var type = typeAndUrl[0];
        var url = typeAndUrl[1];
        if (type) {
            return {
                type: type,
                url: url
            };
        }
        return { url: url };
    }
    function upsertFixture(fixtureList, settings, fixture) {
        var index = exports.index(settings, true);
        if (index > -1) {
            fixtures.splice(index, 1);
        }
        if (fixture == null) {
            return;
        }
        if (typeof fixture === 'object') {
            var data = fixture;
            fixture = function () {
                return data;
            };
        }
        settings.fixture = fixture;
        fixtures.unshift(settings);
    }
    exports.add = function (settings, fixture) {
        if (fixture === undefined) {
            each(settings, function (fixture, url) {
                exports.add(url, fixture);
            });
            return;
        }
        if (isStoreLike(fixture)) {
            settings = addStoreFixture(settings, fixture);
            exports.add(settings);
            return;
        }
        if (typeof settings === 'string') {
            settings = getSettingsFromString(settings);
        }
        upsertFixture(fixtures, settings, fixture);
    };
    var $fixture = exports.add;
    $fixture.on = true;
    $fixture.delay = 10;
    exports.callDynamicFixture = function (xhrSettings, fixtureSettings, cb) {
        xhrSettings.data = fixtureSettings.data;
        var response = function () {
            var res = exports.extractResponse.apply(xhrSettings, arguments);
            return cb.apply(this, res);
        };
        var callFixture = function () {
            var result = fixtureSettings.fixture(xhrSettings, response, xhrSettings.headers, fixtureSettings);
            if (result !== undefined) {
                response(200, result);
            }
        };
        if (!xhrSettings.async) {
            callFixture();
            return null;
        } else {
            return setTimeout(callFixture, $fixture.delay);
        }
    };
    exports.index = function (settings, exact) {
        for (var i = 0; i < fixtures.length; i++) {
            if (exports.matches(settings, fixtures[i], exact)) {
                return i;
            }
        }
        return -1;
    };
    exports.get = function (xhrSettings) {
        if (!$fixture.on) {
            return;
        }
        var index = exports.index(xhrSettings, true);
        if (index === -1) {
            index = exports.index(xhrSettings, false);
        }
        var fixtureSettings = index >= 0 ? assign({}, fixtures[index]) : undefined;
        if (fixtureSettings) {
            var url = fixtureSettings.fixture, data = exports.dataFromUrl(fixtureSettings.url, xhrSettings.url);
            if (typeof fixtureSettings.fixture === 'string') {
                if (data) {
                    url = sub(url, data);
                }
                fixtureSettings.url = url;
                fixtureSettings.data = null;
                fixtureSettings.type = 'GET';
                if (!fixtureSettings.error) {
                    fixtureSettings.error = function (xhr, error, message) {
                        throw 'fixtures.js Error ' + error + ' ' + message;
                    };
                }
            } else {
                var xhrData = assign({}, xhrSettings.data || {});
                fixtureSettings.data = assign(xhrData, data);
            }
        }
        return fixtureSettings;
    };
    exports.matches = function (settings, fixture, exact) {
        if (exact) {
            return canSet.equal(settings, fixture, {
                fixture: function () {
                    return true;
                }
            });
        } else {
            return canSet.subset(settings, fixture, exports.defaultCompare);
        }
    };
    var isEmptyOrNull = function (a, b) {
        if (a == null && isEmptyObject(b)) {
            return true;
        } else if (b == null && isEmptyObject(a)) {
            return true;
        } else {
            return canSet.equal(a, b);
        }
    };
    var isEmptyOrSubset = function (a, b) {
        if (a == null && isEmptyObject(b)) {
            return true;
        } else if (b == null && isEmptyObject(a)) {
            return true;
        } else {
            return canSet.subset(a, b);
        }
    };
    exports.defaultCompare = {
        url: function (a, b) {
            return !!exports.dataFromUrl(b, a);
        },
        fixture: function () {
            return true;
        },
        xhr: function () {
            return true;
        },
        type: function (a, b) {
            return b && a ? a.toLowerCase() === b.toLowerCase() : b === a;
        },
        method: function (a, b) {
            return b && a ? a.toLowerCase() === b.toLowerCase() : b === a;
        },
        helpers: function () {
            return true;
        },
        headers: isEmptyOrNull,
        data: isEmptyOrSubset
    };
    var replacer = /\{([^\}]+)\}/g;
    exports.dataFromUrl = function (fixtureUrl, url) {
        if (!fixtureUrl) {
            return {};
        }
        var order = [], fixtureUrlAdjusted = fixtureUrl.replace('.', '\\.').replace('?', '\\?'), res = new RegExp(fixtureUrlAdjusted.replace(replacer, function (whole, part) {
                order.push(part);
                return '([^/]+)';
            }) + '$').exec(url), data = {};
        if (!res) {
            return null;
        }
        res.shift();
        each(order, function (name) {
            data[name] = res.shift();
        });
        return data;
    };
    exports.extractResponse = function (status, response, headers, statusText) {
        if (typeof status !== 'number') {
            headers = response;
            response = status;
            status = 200;
        }
        if (typeof headers === 'string') {
            statusText = headers;
            headers = {};
        }
        return [
            status,
            response,
            headers,
            statusText
        ];
    };
});
/*can-fixture@1.1.0#xhr*/
define('can-fixture@1.1.0#xhr', function (require, exports, module) {
    (function (global) {
        var fixtureCore = require('./core');
        var deparam = require('can-deparam');
        var assign = require('can-util/js/assign/assign');
        var each = require('can-util/js/each/each');
        var canLog = require('can-util/js/log/log');
        var XHR = XMLHttpRequest, GLOBAL = typeof global !== 'undefined' ? global : window;
        var props = [
            'type',
            'url',
            'async',
            'response',
            'responseText',
            'responseType',
            'responseXML',
            'responseURL',
            'status',
            'statusText',
            'readyState'
        ];
        var events = [
            'abort',
            'error',
            'load',
            'loadend',
            'loadstart',
            'progress',
            'readystatechange'
        ];
        (function () {
            var x = new XHR();
            for (var prop in x) {
                if (prop.indexOf('on') === 0) {
                    if (events.indexOf(prop.substr(2)) === -1) {
                        events.push(prop.substr(2));
                    }
                } else if (props.indexOf(prop) === -1 && typeof x[prop] !== 'function') {
                    props.push(prop);
                }
            }
        }());
        function callEvents(xhr, ev) {
            var evs = xhr.__events[ev] || [], fn;
            for (var i = 0, len = evs.length; i < len; i++) {
                fn = evs[i];
                fn.call(xhr);
            }
        }
        GLOBAL.XMLHttpRequest = function () {
            var mockXHR = this;
            var realXHR = new XHR();
            this._xhr = realXHR;
            this._requestHeaders = {};
            this.__events = {};
            each(events, function (eventName) {
                realXHR['on' + eventName] = function () {
                    callEvents(mockXHR, eventName);
                    if (mockXHR['on' + eventName]) {
                        return mockXHR['on' + eventName].apply(mockXHR, arguments);
                    }
                };
            });
            this.onload = null;
        };
        GLOBAL.XMLHttpRequest._XHR = XHR;
        assign(XMLHttpRequest.prototype, {
            setRequestHeader: function (name, value) {
                this._requestHeaders[name] = value;
            },
            open: function (type, url, async) {
                this.type = type;
                this.url = url;
                this.async = async === false ? false : true;
            },
            getAllResponseHeaders: function () {
                return this._xhr.getAllResponseHeaders.apply(this._xhr, arguments);
            },
            addEventListener: function (ev, fn) {
                var evs = this.__events[ev] = this.__events[ev] || [];
                evs.push(fn);
            },
            removeEventListener: function (ev, fn) {
                var evs = this.__events[ev] = this.__events[ev] || [];
                var idx = evs.indexOf(fn);
                if (idx >= 0) {
                    evs.splice(idx, 1);
                }
            },
            setDisableHeaderCheck: function (val) {
                this._disableHeaderCheck = !!val;
            },
            getResponseHeader: function (key) {
                return this._xhr.getResponseHeader(key);
            },
            abort: function () {
                var xhr = this._xhr;
                if (this.timeoutId !== undefined) {
                    clearTimeout(this.timeoutId);
                    xhr.open(this.type, this.url, this.async === false ? false : true);
                    xhr.send();
                }
                return xhr.abort();
            },
            send: function (data) {
                var type = this.type.toLowerCase() || 'get';
                var xhrSettings = {
                    url: this.url,
                    data: data,
                    headers: this._requestHeaders,
                    type: type,
                    method: type,
                    async: this.async,
                    xhr: this
                };
                if (!xhrSettings.data && xhrSettings.type === 'get' || xhrSettings.type === 'delete') {
                    xhrSettings.data = deparam(xhrSettings.url.split('?')[1]);
                    xhrSettings.url = xhrSettings.url.split('?')[0];
                }
                if (typeof xhrSettings.data === 'string') {
                    try {
                        xhrSettings.data = JSON.parse(xhrSettings.data);
                    } catch (e) {
                        xhrSettings.data = deparam(xhrSettings.data);
                    }
                }
                var fixtureSettings = fixtureCore.get(xhrSettings);
                var mockXHR = this;
                if (fixtureSettings && typeof fixtureSettings.fixture === 'function') {
                    this.timeoutId = fixtureCore.callDynamicFixture(xhrSettings, fixtureSettings, function (status, body, headers, statusText) {
                        body = typeof body === 'string' ? body : JSON.stringify(body);
                        mockXHR._xhr = {
                            open: function () {
                            },
                            send: function () {
                            },
                            abort: function () {
                            },
                            getResponseHeader: function () {
                            }
                        };
                        assign(mockXHR, {
                            readyState: 4,
                            status: status
                        });
                        var success = status >= 200 && status < 300 || status === 304;
                        if (success) {
                            assign(mockXHR, {
                                statusText: statusText || 'OK',
                                responseText: body
                            });
                        } else {
                            assign(mockXHR, {
                                statusText: statusText || 'error',
                                responseText: body
                            });
                        }
                        mockXHR.getAllResponseHeaders = function () {
                            var ret = [];
                            each(headers || {}, function (value, name) {
                                Array.prototype.push.apply(ret, [
                                    name,
                                    ': ',
                                    value,
                                    '\r\n'
                                ]);
                            });
                            return ret.join('');
                        };
                        if (mockXHR.onreadystatechange) {
                            mockXHR.onreadystatechange({ target: mockXHR });
                        }
                        callEvents(mockXHR, 'progress');
                        if (mockXHR.onprogress) {
                            mockXHR.onprogress();
                        }
                        callEvents(mockXHR, 'load');
                        if (mockXHR.onload) {
                            mockXHR.onload();
                        }
                        callEvents(mockXHR, 'loadend');
                        if (mockXHR.onloadend) {
                            mockXHR.onloadend();
                        }
                    });
                    return;
                }
                var makeRequest = function () {
                    mockXHR._xhr.open(mockXHR._xhr.type, mockXHR._xhr.url, mockXHR._xhr.async);
                    if (mockXHR._requestHeaders) {
                        Object.keys(mockXHR._requestHeaders).forEach(function (key) {
                            mockXHR._xhr.setRequestHeader(key, mockXHR._requestHeaders[key]);
                        });
                    }
                    return mockXHR._xhr.send(data);
                };
                if (fixtureSettings && typeof fixtureSettings.fixture === 'number') {
                    canLog.log(xhrSettings.url + ' -> delay ' + fixtureSettings.fixture + 'ms');
                    this.timeoutId = setTimeout(makeRequest, fixtureSettings.fixture);
                    return;
                }
                if (fixtureSettings) {
                    canLog.log(xhrSettings.url + ' -> ' + fixtureSettings.url);
                    assign(mockXHR, fixtureSettings);
                }
                return makeRequest();
            }
        });
        each(props, function (prop) {
            Object.defineProperty(XMLHttpRequest.prototype, prop, {
                get: function () {
                    return this._xhr[prop];
                },
                set: function (newVal) {
                    try {
                        this._xhr[prop] = newVal;
                    } catch (e) {
                    }
                }
            });
        });
    }(function () {
        return this;
    }()));
});
/*can-fixture@1.1.0#fixture*/
define('can-fixture@1.1.0#fixture', function (require, exports, module) {
    var core = require('./core');
    var fixture = core.add;
    var Store = require('./store');
    require('./xhr');
    var assign = require('can-util/js/assign/assign');
    var ns = require('can-namespace');
    var noop = function () {
    };
    assign(fixture, {
        rand: function randomize(arr, min, max) {
            if (typeof arr === 'number') {
                if (typeof min === 'number') {
                    return arr + Math.floor(Math.random() * (min - arr + 1));
                } else {
                    return Math.floor(Math.random() * (arr + 1));
                }
            }
            var choices = arr.slice(0);
            if (min === undefined) {
                min = 1;
                max = choices.length;
            } else if (max === undefined) {
                max = min;
            }
            var result = [];
            var selectedCount = min + Math.round(randomize(max - min));
            for (var i = 0; i < selectedCount; i++) {
                var selectedIndex = randomize(choices.length - 1), selected = choices.splice(selectedIndex, 1)[0];
                result.push(selected);
            }
            return result;
        },
        xhr: function (xhr) {
            return assign({}, {
                abort: noop,
                getAllResponseHeaders: function () {
                    return '';
                },
                getResponseHeader: function () {
                    return '';
                },
                open: noop,
                overrideMimeType: noop,
                readyState: 4,
                responseText: '',
                responseXML: null,
                send: noop,
                setRequestHeader: noop,
                status: 200,
                statusText: 'OK'
            }, xhr);
        },
        store: Store.make,
        fixtures: core.fixtures
    });
    if (typeof window !== 'undefined' && typeof require.resolve !== 'function') {
        window.fixture = fixture;
    }
    module.exports = ns.fixture = fixture;
});
/*can-fixture@1.1.0#test/fixture_test*/
define('can-fixture@1.1.0#test/fixture_test', function (require, exports, module) {
    (function (__dirname) {
        var QUnit = require('steal-qunit');
        var fixture = require('can-fixture');
        var core = require('../core');
        var set = require('can-set');
        var $ = require('jquery');
        var each = require('can-util/js/each/each');
        var isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');
        var canDev = require('can-util/js/dev/dev');
        var errorCallback = function (xhr, status, error) {
            ok(false, error);
            start();
        };
        var parseHeaders = function (str) {
            var lines = str.split(/\r?\n/);
            var fields = {};
            var index;
            var line;
            var field;
            var val;
            lines.pop();
            for (var i = 0, len = lines.length; i < len; ++i) {
                line = lines[i];
                index = line.indexOf(':');
                field = line.slice(0, index).toLowerCase();
                val = line.slice(index + 1).replace(/(^\s*|\s*$)/g, '');
                fields[field] = val;
            }
            return fields;
        };
        QUnit.module('can-fixture');
        if (__dirname !== '/') {
            test('static fixtures', function () {
                stop();
                fixture('GET something', __dirname + '/fixtures/test.json');
                fixture('POST something', __dirname + '/fixtures/test.json');
                fixture('PATCH something', __dirname + '/fixtures/test.json');
                $.ajax({
                    url: 'something',
                    dataType: 'json'
                }).then(function (data) {
                    equal(data.sweet, 'ness', 'can.get works');
                    $.ajax({
                        url: 'something',
                        method: 'POST',
                        dataType: 'json'
                    }).then(function (data) {
                        equal(data.sweet, 'ness', 'can.post works');
                        $.ajax({
                            url: 'something',
                            method: 'PATCH',
                            dataType: 'json'
                        }).then(function (data) {
                            equal(data.sweet, 'ness', 'can.patch works');
                            start();
                        }, errorCallback);
                    }, errorCallback);
                }, errorCallback);
            });
        }
        if (__dirname !== '/') {
            test('static fixtures (using method signature)', function () {
                stop();
                fixture({
                    method: 'get',
                    url: 'method/{id}'
                }, __dirname + '/fixtures/method.{id}.json');
                $.ajax({
                    url: 'method/4',
                    dataType: 'json'
                }).then(function (data) {
                    equal(data.id, 4, 'Got data with proper id using method');
                    start();
                }, errorCallback);
            });
        }
        if (__dirname !== '/') {
            test('static fixtures (using type signature)', function () {
                stop();
                fixture({
                    type: 'get',
                    url: 'type/{id}'
                }, __dirname + '/fixtures/type.{id}.json');
                $.ajax({
                    url: 'type/4',
                    dataType: 'json'
                }).then(function (data) {
                    equal(data.id, 4, 'Got data with proper id using type');
                    start();
                }, errorCallback);
            });
        }
        if (__dirname !== '/') {
            test('templated static fixtures', function () {
                stop();
                fixture('GET some/{id}', __dirname + '/fixtures/stuff.{id}.json');
                $.ajax({
                    url: 'some/3',
                    dataType: 'json'
                }).then(function (data) {
                    equal(data.id, 3, 'Got data with proper id');
                    start();
                }, errorCallback);
            });
        }
        test('dynamic fixtures', function () {
            stop();
            fixture.delay = 10;
            fixture('something', function () {
                return [{ sweet: 'ness' }];
            });
            $.ajax({
                url: 'something',
                dataType: 'json'
            }).done(function (data) {
                equal(data[0].sweet, 'ness', 'can.get works');
                start();
            });
        });
        if (__dirname !== '/') {
            test('fixture function', 3, function () {
                stop();
                var url = __dirname + '/fixtures/foo.json';
                fixture(url, __dirname + '/fixtures/foobar.json');
                $.ajax({
                    url: url,
                    dataType: 'json'
                }).done(function (data) {
                    equal(data.sweet, 'ner', 'url passed works');
                    fixture(url, __dirname + '/fixtures/test.json');
                    $.ajax({
                        url: url,
                        dataType: 'json'
                    }).done(function (data) {
                        equal(data.sweet, 'ness', 'replaced');
                        fixture(url, null);
                        $.ajax({
                            url: url,
                            dataType: 'json'
                        }).done(function (data) {
                            equal(data.a, 'b', 'removed');
                            start();
                        });
                    });
                });
            });
        }
        test('fixture.store fixtures', function () {
            stop();
            var store = fixture.store('thing', 1000, function (i) {
                return {
                    id: i,
                    name: 'thing ' + i
                };
            }, function (item, settings) {
                if (settings.data.searchText) {
                    var regex = new RegExp('^' + settings.data.searchText);
                    return regex.test(item.name);
                }
            });
            fixture('things', store.findAll);
            $.ajax({
                url: 'things',
                dataType: 'json',
                data: {
                    offset: 100,
                    limit: 200,
                    order: ['name ASC'],
                    searchText: 'thing 2'
                },
                success: function (things) {
                    equal(things.data[0].name, 'thing 29', 'first item is correct');
                    equal(things.data.length, 11, 'there are 11 items');
                    start();
                }
            });
        });
        test('fixture.store fixtures should have unique IDs', function () {
            stop();
            var store = fixture.store('thing', 100, function (i) {
                return { name: 'Test ' + i };
            });
            fixture('things', store.findAll);
            $.ajax({
                url: 'things',
                dataType: 'json',
                data: {
                    offset: 0,
                    limit: 200,
                    order: ['name ASC'],
                    searchText: 'thing 2'
                },
                success: function (result) {
                    var seenIds = [];
                    var things = result.data;
                    for (var thingKey in things) {
                        var thing = things[thingKey];
                        ok(seenIds.indexOf(thing.id) === -1);
                        seenIds.push(thing.id);
                    }
                    start();
                }
            });
        });
        test('fixture.store should assign unique IDs when fixtures provide IDs', function () {
            var store = fixture.store([
                {
                    id: 0,
                    name: 'Object 0'
                },
                {
                    id: 1,
                    name: 'Object 1'
                },
                {
                    id: 2,
                    name: 'Object 2'
                }
            ]);
            fixture('POST /models', store.createData);
            function then(ajax, callback) {
                ajax.then(callback, function (error) {
                    ok(false, 'ajax failure: ' + error);
                    start();
                });
            }
            var request = $.ajax({
                url: '/models',
                dataType: 'json',
                type: 'post',
                data: { name: 'My test object' }
            });
            stop();
            then(request, function (response) {
                notEqual(response.id, 0);
                notEqual(response.id, 1);
                notEqual(response.id, 2);
                equal(response.id, 3);
                start();
            });
        });
        test('simulating an error', function () {
            fixture('/foo', function (request, response) {
                return response(401, { type: 'unauthorized' });
            });
            stop();
            $.ajax({
                url: '/foo',
                dataType: 'json'
            }).done(function () {
                ok(false, 'success called');
                start();
            }).fail(function (original, type) {
                ok(true, 'error called');
                deepEqual(JSON.parse(original.responseText), { type: 'unauthorized' }, 'Original text passed');
                start();
            });
        });
        test('rand', function () {
            var rand = fixture.rand;
            var num = rand(3);
            equal(typeof num, 'number');
            var matched = {};
            for (var i = 0; i < 100; i++) {
                num = rand(3);
                matched[num] = true;
            }
            for (i = 0; i <= 3; i++) {
                ok(matched[i], 'has ' + i);
            }
            matched = {};
            var result, choices = [
                    'a',
                    'b',
                    'c'
                ];
            for (i = 0; i < 100; i++) {
                result = rand(choices);
                matched[result.length] = true;
                matched[result[0]] = true;
            }
            for (i = 1; i <= 3; i++) {
                ok(matched[i], 'has ' + i);
                delete matched[i];
            }
            each(choices, function (choice) {
                ok(matched[choice], 'has ' + choice);
                delete matched[choice];
            });
            ok(isEmptyObject(matched), 'nothing else unexpected');
        });
        test('core.dataFromUrl', function () {
            var data = core.dataFromUrl('/thingers/{id}', '/thingers/5');
            equal(data.id, 5, 'gets data');
            data = core.dataFromUrl('/thingers/5?hi.there', '/thingers/5?hi.there');
            deepEqual(data, {}, 'gets data');
        });
        test('core.dataFromUrl with double character value', function () {
            var data = core.dataFromUrl('/days/{id}/time_slots.json', '/days/17/time_slots.json');
            equal(data.id, 17, 'gets data');
        });
        test('core.defaultCompare', function () {
            var same = set.equal({ url: '/thingers/5' }, { url: '/thingers/{id}' }, core.defaultCompare);
            ok(same, 'they are similar');
            same = set.equal({ url: '/thingers/5' }, { url: '/thingers' }, core.defaultCompare);
            ok(!same, 'they are not the same');
        });
        test('core.matches', function () {
            var same = core.matches({ url: '/thingers/5' }, { url: '/thingers/{id}' });
            ok(same, 'similar');
            same = core.matches({
                url: '/thingers/5',
                type: 'get'
            }, { url: '/thingers/{id}' });
            ok(same, 'similar with extra pops on settings');
            var exact = core.matches({
                url: '/thingers/5',
                type: 'get'
            }, { url: '/thingers/{id}' }, true);
            ok(!exact, 'not exact');
            exact = core.matches({ url: '/thingers/5' }, { url: '/thingers/5' }, true);
            ok(exact, 'exact');
        });
        test('fixture function gets id', function () {
            fixture('/thingers/{id}', function (settings) {
                return {
                    id: settings.data.id,
                    name: 'justin'
                };
            });
            stop();
            $.ajax({
                url: '/thingers/5',
                dataType: 'json',
                data: { id: 5 }
            }).done(function (data) {
                ok(data.id);
                start();
            });
        });
        if (__dirname !== '/') {
            test('replacing and removing a fixture', function () {
                var url = __dirname + '/fixtures/remove.json';
                fixture('GET ' + url, function () {
                    return { weird: 'ness!' };
                });
                stop();
                $.ajax({
                    url: url,
                    dataType: 'json'
                }).done(function (json) {
                    equal(json.weird, 'ness!', 'fixture set right');
                    fixture('GET ' + url, function () {
                        return { weird: 'ness?' };
                    });
                    $.ajax({
                        url: url,
                        dataType: 'json'
                    }).done(function (json) {
                        equal(json.weird, 'ness?', 'fixture set right');
                        fixture('GET ' + url, null);
                        $.ajax({
                            url: url,
                            dataType: 'json'
                        }).done(function (json) {
                            equal(json.weird, 'ness', 'fixture set right');
                            start();
                        });
                    });
                });
            });
        }
        test('fixture.store with can.Model', function () {
            var store = fixture.store(100, function (i) {
                return {
                    id: i,
                    name: 'Object ' + i
                };
            });
            fixture('GET /models', store.getListData);
            fixture('GET /models/{id}', store.getData);
            fixture('POST /models', store.createData);
            fixture('PUT /models/{id}', store.updateData);
            fixture('DELETE /models/{id}', store.destroyData);
            stop();
            function errorAndStart(e) {
                ok(false, 'borked' + e);
                start();
            }
            var check100Updated = function () {
                return $.ajax({
                    url: '/models/100',
                    dataType: 'json'
                }).then(function (model) {
                    equal(model.name, 'Updated test object', 'Successfully updated object');
                });
            };
            $.ajax({
                url: '/models',
                dataType: 'json'
            }).then(function (modelsData) {
                var models = modelsData.data;
                equal(models.length, 100, 'Got 100 models for findAll with no parameters');
                equal(models[95].name, 'Object 95', 'All models generated properly');
                return $.ajax({
                    url: '/models/51',
                    dataType: 'json'
                }).then(function (data) {
                    equal(data.id, 51, 'Got correct object id');
                    equal('Object 51', data.name, 'Object name generated correctly');
                    return $.ajax({
                        url: '/models',
                        dataType: 'json',
                        type: 'post',
                        data: { name: 'My test object' }
                    }).then(function (newmodel) {
                        equal(newmodel.id, 100, 'Id got incremented');
                        return $.ajax({
                            url: '/models/100',
                            dataType: 'json'
                        }).then(function (model) {
                            equal(model.id, 100, 'Loaded new object');
                            return $.ajax({
                                url: '/models/100',
                                dataType: 'json',
                                type: 'put',
                                data: { name: 'Updated test object' }
                            }).then(function (model) {
                                return check100Updated().then(function () {
                                    return $.ajax({
                                        url: '/models/100',
                                        dataType: 'json',
                                        type: 'delete'
                                    }).then(function (deleted) {
                                        start();
                                    }, errorAndStart);
                                }, errorAndStart);
                            }, errorAndStart);
                        }, errorAndStart);
                    }, errorAndStart);
                }, errorAndStart);
            }, errorAndStart);
        });
        test('fixture.store returns 404 on findOne with bad id (#803)', function () {
            var store = fixture.store(2, function (i) {
                return {
                    id: i,
                    name: 'Object ' + i
                };
            });
            fixture('GET /models/{id}', store.findOne);
            stop();
            $.ajax({
                url: '/models/3',
                dataType: 'json'
            }).then(function () {
            }, function (data) {
                equal(data.statusText, 'error', 'statusText');
                equal(data.responseText, 'Requested resource not found', 'responseText');
                start();
            });
        });
        test('fixture.store returns 404 on update with a bad id (#803)', function () {
            var store = fixture.store(5, function (i) {
                return {
                    id: i,
                    name: 'Object ' + i
                };
            });
            stop();
            fixture('POST /models/{id}', store.update);
            $.ajax({
                url: '/models/6',
                dataType: 'json',
                data: { 'jedan': 'dva' },
                type: 'POST'
            }).then(function () {
            }, function (data) {
                equal(data.statusText, 'error', 'Got an error');
                equal(data.responseText, 'Requested resource not found', 'Got correct status message');
                start();
            });
        });
        test('fixture.store returns 404 on destroy with a bad id (#803)', function () {
            var store = fixture.store(2, function (i) {
                return {
                    id: i,
                    name: 'Object ' + i
                };
            });
            stop();
            fixture('DELETE /models/{id}', store.destroy);
            $.ajax({
                url: '/models/6',
                dataType: 'json',
                type: 'DELETE'
            }).then(function () {
            }, function (data) {
                equal(data.statusText, 'error', 'Got an error');
                equal(data.responseText, 'Requested resource not found', 'Got correct status message');
                start();
            });
        });
        test('fixture.store can use id of different type (#742)', function () {
            var store = fixture.store(100, function (i) {
                return {
                    id: i,
                    parentId: i * 2,
                    name: 'Object ' + i
                };
            });
            fixture('GET /models', store.findAll);
            stop();
            $.ajax({
                url: '/models',
                dataType: 'json',
                data: { parentId: '4' }
            }).then(function (models) {
                equal(models.data.length, 1, 'Got one model');
                deepEqual(models.data[0], {
                    id: 2,
                    parentId: 4,
                    name: 'Object 2'
                });
                start();
            });
        });
        test('fixture("METHOD /path", store) should use the right method', function () {
            var store = fixture.store(100, function (i) {
                return {
                    id: i,
                    name: 'Object ' + i
                };
            });
            fixture('GET /models', store);
            stop();
            $.ajax({
                url: '/models',
                dataType: 'json'
            }).then(function (models) {
                equal(models.data.length, 100, 'Gotta catch up all!');
                start();
            });
        });
        test('fixture with response callback', 4, function () {
            fixture.delay = 10;
            fixture('responseCb', function (orig, response) {
                response({ sweet: 'ness' });
            });
            fixture('responseErrorCb', function (orig, response) {
                response(404, 'This is an error from callback');
            });
            stop();
            $.ajax({
                url: 'responseCb',
                dataType: 'json'
            }).done(function (data) {
                equal(data.sweet, 'ness', 'can.get works');
                start();
            });
            stop();
            $.ajax({
                url: 'responseErrorCb',
                dataType: 'json'
            }).fail(function (orig, error, text) {
                equal(error, 'error', 'Got error status');
                equal(orig.responseText, 'This is an error from callback', 'Got error text');
                start();
            });
            stop();
            fixture('cbWithTimeout', function (orig, response) {
                setTimeout(function () {
                    response([{ epic: 'ness' }]);
                }, 10);
            });
            $.ajax({
                url: 'cbWithTimeout',
                dataType: 'json'
            }).done(function (data) {
                equal(data[0].epic, 'ness', 'Got responsen with timeout');
                start();
            });
        });
        test('store create works with an empty array of items', function () {
            var store = fixture.store(0, function () {
                return {};
            });
            store.create({ data: {} }, function (responseData, responseHeaders) {
                equal(responseData.id, 0, 'the first id is 0');
            });
        });
        test('store creates sequential ids', function () {
            var store = fixture.store(0, function () {
                return {};
            });
            store.create({ data: {} }, function (responseData, responseHeaders) {
                equal(responseData.id, 0, 'the first id is 0');
            });
            store.create({ data: {} }, function (responseData, responseHeaders) {
                equal(responseData.id, 1, 'the second id is 1');
            });
            store.destroy({ data: { id: 0 } });
            store.create({ data: {} }, function (responseData, responseHeaders) {
                equal(responseData.id, 2, 'the third id is 2');
            });
        });
        test('fixture updates request.data with id', function () {
            expect(1);
            stop();
            fixture('foo/{id}', function (request) {
                equal(request.data.id, 5);
                start();
            });
            $.ajax({ url: 'foo/5' });
        });
        test('create a store with array and comparison object', function () {
            var store = fixture.store([
                {
                    id: 1,
                    modelId: 1,
                    year: 2013,
                    name: '2013 Mustang',
                    thumb: 'http://mustangsdaily.com/blog/wp-content/uploads/2012/07/01-2013-ford-mustang-gt-review-585x388.jpg'
                },
                {
                    id: 2,
                    modelId: 1,
                    year: 2014,
                    name: '2014 Mustang',
                    thumb: 'http://mustangsdaily.com/blog/wp-content/uploads/2013/03/2014-roush-mustang.jpg'
                },
                {
                    id: 2,
                    modelId: 2,
                    year: 2013,
                    name: '2013 Focus',
                    thumb: 'http://images.newcars.com/images/car-pictures/original/2013-Ford-Focus-Sedan-S-4dr-Sedan-Exterior.png'
                },
                {
                    id: 2,
                    modelId: 2,
                    year: 2014,
                    name: '2014 Focus',
                    thumb: 'http://ipinvite.iperceptions.com/Invitations/survey705/images_V2/top4.jpg'
                },
                {
                    id: 2,
                    modelId: 3,
                    year: 2013,
                    name: '2013 Altima',
                    thumb: 'http://www.blogcdn.com/www.autoblog.com/media/2012/04/04-2013-nissan-altima-1333416664.jpg'
                },
                {
                    id: 2,
                    modelId: 3,
                    year: 2014,
                    name: '2014 Altima',
                    thumb: 'http://www.blogcdn.com/www.autoblog.com/media/2012/04/01-2013-nissan-altima-ny.jpg'
                },
                {
                    id: 2,
                    modelId: 4,
                    year: 2013,
                    name: '2013 Leaf',
                    thumb: 'http://www.blogcdn.com/www.autoblog.com/media/2012/04/01-2013-nissan-altima-ny.jpg'
                },
                {
                    id: 2,
                    modelId: 4,
                    year: 2014,
                    name: '2014 Leaf',
                    thumb: 'http://images.thecarconnection.com/med/2013-nissan-leaf_100414473_m.jpg'
                }
            ], {
                year: function (a, b) {
                    return a == b;
                },
                modelId: function (a, b) {
                    return a == b;
                }
            });
            fixture('GET /presetStore', store.findAll);
            stop();
            $.ajax({
                url: '/presetStore',
                method: 'get',
                data: {
                    year: 2013,
                    modelId: 1
                },
                dataType: 'json'
            }).then(function (response) {
                equal(response.data[0].id, 1, 'got the first item');
                equal(response.data.length, 1, 'only got one item');
                start();
            });
        });
        test('store with objects allows .create, .update and .destroy (#1471)', 4, function () {
            var store = fixture.store([
                {
                    id: 1,
                    modelId: 1,
                    year: 2013,
                    name: '2013 Mustang',
                    thumb: 'http://mustangsdaily.com/blog/wp-content/uploads/2012/07/01-2013-ford-mustang-gt-review-585x388.jpg'
                },
                {
                    id: 2,
                    modelId: 1,
                    year: 2014,
                    name: '2014 Mustang',
                    thumb: 'http://mustangsdaily.com/blog/wp-content/uploads/2013/03/2014-roush-mustang.jpg'
                },
                {
                    id: 3,
                    modelId: 2,
                    year: 2013,
                    name: '2013 Focus',
                    thumb: 'http://images.newcars.com/images/car-pictures/original/2013-Ford-Focus-Sedan-S-4dr-Sedan-Exterior.png'
                },
                {
                    id: 4,
                    modelId: 2,
                    year: 2014,
                    name: '2014 Focus',
                    thumb: 'http://ipinvite.iperceptions.com/Invitations/survey705/images_V2/top4.jpg'
                },
                {
                    id: 5,
                    modelId: 3,
                    year: 2013,
                    name: '2013 Altima',
                    thumb: 'http://www.blogcdn.com/www.autoblog.com/media/2012/04/04-2013-nissan-altima-1333416664.jpg'
                },
                {
                    id: 6,
                    modelId: 3,
                    year: 2014,
                    name: '2014 Altima',
                    thumb: 'http://www.blogcdn.com/www.autoblog.com/media/2012/04/01-2013-nissan-altima-ny.jpg'
                },
                {
                    id: 7,
                    modelId: 4,
                    year: 2013,
                    name: '2013 Leaf',
                    thumb: 'http://www.blogcdn.com/www.autoblog.com/media/201204/01-2013-nissan-altima-ny.jpg'
                },
                {
                    id: 8,
                    modelId: 4,
                    year: 2014,
                    name: '2014 Leaf',
                    thumb: 'http://images.thecarconnection.com/med/2013-nissan-leaf_100414473_m.jpg'
                }
            ]);
            fixture('GET /cars', store.findAll);
            fixture('POST /cars', store.create);
            fixture('PUT /cars/{id}', store.update);
            fixture('DELETE /cars/{id}', store.destroy);
            var findAll = function () {
                return $.ajax({
                    url: '/cars',
                    dataType: 'json'
                });
            };
            stop();
            findAll().then(function (carsData) {
                equal(carsData.data.length, 8, 'Got all cars');
                return $.ajax({
                    url: '/cars/' + carsData.data[1].id,
                    method: 'DELETE',
                    dataType: 'json'
                });
            }).then(function () {
                return findAll();
            }).then(function (carsData) {
                equal(carsData.data.length, 7, 'One car less');
                equal(carsData.data[1].name, '2013 Focus', 'Car actually deleted');
            }).then(function () {
                return $.ajax({
                    url: '/cars',
                    method: 'post',
                    dataType: 'json',
                    data: {
                        modelId: 3,
                        year: 2015,
                        name: '2015 Altima'
                    }
                });
            }).then(function (saved) {
                return $.ajax({
                    url: '/cars/' + saved.id,
                    method: 'put',
                    dataType: 'json',
                    data: {
                        modelId: 3,
                        year: 2015,
                        name: '2015 Nissan Altima'
                    }
                });
            }).then(function (updated) {
                return findAll();
            }).then(function (cars) {
                equal(cars.data.length, 8, 'New car created');
                start();
            });
        });
        test('filtering works', function () {
            var next;
            var store = fixture.store([
                {
                    state: 'CA',
                    name: 'Casadina'
                },
                {
                    state: 'NT',
                    name: 'Alberny'
                }
            ], {});
            fixture({ 'GET /api/cities': store.findAll });
            stop();
            $.getJSON('/api/cities?state=CA').then(function (data) {
                deepEqual(data, {
                    data: [{
                            state: 'CA',
                            name: 'Casadina'
                        }],
                    count: 1
                });
                next();
            }, function (e) {
                ok(false, '' + e);
                start();
            });
            next = function () {
                var store = fixture.store([
                    {
                        _id: 1,
                        name: 'Cheese City',
                        slug: 'cheese-city',
                        address: {
                            city: 'Casadina',
                            state: 'CA'
                        }
                    },
                    {
                        _id: 2,
                        name: 'Crab Barn',
                        slug: 'crab-barn',
                        address: {
                            city: 'Alberny',
                            state: 'NT'
                        }
                    }
                ], {});
                fixture({ 'GET /restaurants': store.findAll });
                $.getJSON('/api/restaurants?address[city]=Alberny').then(function (responseData) {
                    deepEqual(responseData, {
                        count: 1,
                        data: [{
                                _id: 2,
                                name: 'Crab Barn',
                                slug: 'crab-barn',
                                address: {
                                    city: 'Alberny',
                                    state: 'NT'
                                }
                            }]
                    });
                    last();
                }, function (e) {
                    ok(false);
                    start();
                });
            };
            function last() {
                var store = fixture.store([
                    {
                        _id: 1,
                        name: 'Cheese City',
                        slug: 'cheese-city',
                        address: {
                            city: 'Casadina',
                            state: 'CA'
                        }
                    },
                    {
                        _id: 2,
                        name: 'Crab Barn',
                        slug: 'crab-barn',
                        address: {
                            city: 'Alberny',
                            state: 'NT'
                        }
                    }
                ], {
                    'address.city': function (restaurantValue, paramValue, restaurant, params) {
                        return restaurant.address.city === paramValue;
                    }
                });
                var responseData = store.findAll({ data: { 'address.city': 'Alberny' } });
                deepEqual(responseData, {
                    count: 1,
                    data: [{
                            _id: 2,
                            name: 'Crab Barn',
                            slug: 'crab-barn',
                            address: {
                                city: 'Alberny',
                                state: 'NT'
                            }
                        }]
                });
                start();
            }
        });
        QUnit.test('onreadystatechange, event is passed', function () {
            fixture('GET something', function () {
                return {};
            });
            var xhr = new XMLHttpRequest();
            xhr.open('GET', 'something');
            xhr.onreadystatechange = function (ev) {
                ok(ev.target != null, 'the event object passed to onreadystatechange');
                start();
            };
            xhr.send();
            stop();
        });
        if (__dirname !== '/') {
            asyncTest('doesn\'t break onreadystatechange (#3)', function () {
                var url = __dirname + '/fixtures/test.json';
                var xhr = new XMLHttpRequest();
                xhr.onreadystatechange = function () {
                    if (xhr.readyState === 4) {
                        ok(true, 'we made a successful request');
                        start();
                    }
                };
                xhr.open('GET', url);
                xhr.send();
            });
        }
        QUnit.module('XHR Shim');
        test('Supports onload', function () {
            var xhr = new XMLHttpRequest();
            QUnit.ok('onload' in xhr, 'shim passes onload detection');
        });
        if (__dirname !== '/') {
            asyncTest('supports addEventListener on XHR shim', function () {
                var url = __dirname + '/fixtures/test.json';
                var xhr = new XMLHttpRequest();
                xhr.addEventListener('load', function () {
                    ok(true, 'our shim supports addEventListener');
                    start();
                });
                xhr.open('GET', url);
                xhr.send();
            });
        }
        if (__dirname !== '/') {
            asyncTest('supports removeEventListener on XHR shim', function () {
                var url = __dirname + '/fixtures/test.json';
                var xhr = new XMLHttpRequest();
                var onload = function () {
                    ok(false, 'this should not be called');
                };
                xhr.addEventListener('load', onload);
                xhr.removeEventListener('load', onload);
                xhr.onload = function () {
                    setTimeout(function () {
                        ok(true, 'didn\'t call the event listener');
                        start();
                    });
                };
                xhr.open('GET', url);
                xhr.send();
            });
        }
        test('supports setDisableHeaderCheck', function () {
            var xhr = new XMLHttpRequest();
            try {
                xhr.setDisableHeaderCheck(true);
                ok(true, 'did not throw');
            } catch (e) {
                ok(false, 'do not support setDisableHeaderCheck');
            }
        });
        if (__dirname !== '/') {
            asyncTest('supports setRequestHeader', function () {
                var url = __dirname + '/fixtures/test.json';
                var xhr = new XMLHttpRequest();
                xhr.setRequestHeader('foo', 'bar');
                xhr.onreadystatechange = function () {
                    if (xhr.readyState === 4) {
                        equal(xhr._requestHeaders.foo, 'bar', 'header was set');
                        start();
                    }
                };
                xhr.open('GET', url);
                xhr.send();
            });
        }
        if (__dirname !== '/') {
            asyncTest('supports getResponseHeader', function () {
                var url = __dirname + '/fixtures/test.json';
                var xhr = new XMLHttpRequest();
                xhr.onreadystatechange = function () {
                    if (xhr.readyState === 4) {
                        var header = xhr.getResponseHeader('Content-Type');
                        ok(header.indexOf('application/json') >= 0, 'got correct header back');
                        start();
                    }
                };
                xhr.open('GET', url);
                xhr.send();
            });
        }
        asyncTest('supports getAllResponseHeaders', function () {
            fixture('GET something', function (req, res) {
                res(200, { message: 'this is the body' }, { foo: 'bar' });
            });
            var xhr = new XMLHttpRequest();
            xhr.onreadystatechange = function () {
                if (xhr.readyState === 4) {
                    var headers = xhr.getAllResponseHeaders();
                    var parsed = parseHeaders(headers);
                    ok(typeof headers === 'string', 'got headers back');
                    ok(parsed.foo === 'bar', 'got proper values');
                    start();
                }
            };
            xhr.open('GET', 'something');
            xhr.send();
        });
        asyncTest('pass data to response handler (#13)', function () {
            fixture('GET something', function (req, res) {
                res(403, { message: 'No bad guys' });
            });
            var xhr = new XMLHttpRequest();
            xhr.open('GET', 'something');
            xhr.onreadystatechange = function (ev) {
                deepEqual(JSON.parse(this.responseText), { message: 'No bad guys' }, 'correct response');
                equal(this.status, 403, 'correct status');
                start();
            };
            xhr.send();
        });
        asyncTest('pass return value for fixture', function () {
            fixture('GET something', { foo: 'bar' });
            var xhr = new XMLHttpRequest();
            xhr.open('GET', 'something');
            xhr.onreadystatechange = function (ev) {
                deepEqual(JSON.parse(this.responseText), { foo: 'bar' }, 'correct response');
                equal(this.status, 200, 'correct status');
                start();
            };
            xhr.send();
        });
        if (__dirname !== '/') {
            asyncTest('pass headers in fallthrough', function () {
                var url = __dirname + '/fixtures/foobar.json';
                var xhr = new XMLHttpRequest();
                expect(2);
                xhr.open('GET', url);
                xhr.setRequestHeader('foo', 'bar');
                xhr.onreadystatechange = function (ev) {
                    var originalXhr = ev.target;
                    if (originalXhr.readyState === 1) {
                        originalXhr.setRequestHeader = function (key, val) {
                            equal(key, 'foo');
                            equal(val, 'bar');
                        };
                    }
                    if (originalXhr.readyState === 4) {
                        start();
                    }
                };
                xhr.send();
            });
        }
        test('set.Algebra CRUD works (#12)', 5, function () {
            var algebra = new set.Algebra(new set.Translate('where', 'where'), set.props.id('_id'), set.props.sort('orderBy'), set.props.enum('type', [
                'used',
                'new',
                'certified'
            ]), set.props.rangeInclusive('start', 'end'));
            var store = fixture.store([
                {
                    _id: 1,
                    modelId: 1,
                    year: 2013,
                    name: '2013 Mustang',
                    type: 'used'
                },
                {
                    _id: 2,
                    modelId: 1,
                    year: 2014,
                    name: '2014 Mustang',
                    type: 'new'
                },
                {
                    _id: 3,
                    modelId: 2,
                    year: 2013,
                    name: '2013 Focus',
                    type: 'used'
                },
                {
                    _id: 4,
                    modelId: 2,
                    year: 2014,
                    name: '2014 Focus',
                    type: 'certified'
                },
                {
                    _id: 5,
                    modelId: 3,
                    year: 2013,
                    name: '2013 Altima',
                    type: 'used'
                },
                {
                    _id: 6,
                    modelId: 3,
                    year: 2014,
                    name: '2014 Altima',
                    type: 'certified'
                },
                {
                    _id: 7,
                    modelId: 4,
                    year: 2013,
                    name: '2013 Leaf',
                    type: 'used'
                },
                {
                    _id: 8,
                    modelId: 4,
                    year: 2014,
                    name: '2014 Leaf',
                    type: 'used'
                }
            ], algebra);
            fixture('GET /cars', store.findAll);
            fixture('POST /cars', store.create);
            fixture('PUT /cars/{_id}', store.update);
            fixture('DELETE /cars/{_id}', store.destroy);
            fixture('GET /cars/{_id}', store.findOne);
            var findAll = function () {
                return $.ajax({
                    url: '/cars',
                    dataType: 'json'
                });
            };
            stop();
            findAll().then(function (carsData) {
                equal(carsData.data.length, 8, 'Got all cars');
                return $.ajax({
                    url: '/cars/' + carsData.data[1]._id,
                    method: 'DELETE',
                    dataType: 'json'
                });
            }).then(function () {
                return findAll();
            }).then(function (carsData) {
                equal(carsData.data.length, 7, 'One car less');
                equal(carsData.data[1].name, '2013 Focus', 'Car actually deleted');
            }).then(function () {
                return $.ajax({
                    url: '/cars',
                    method: 'post',
                    dataType: 'json',
                    data: {
                        modelId: 3,
                        year: 2015,
                        name: '2015 Altima',
                        type: 'new'
                    }
                });
            }).then(function (saved) {
                return $.ajax({
                    url: '/cars/' + saved._id,
                    method: 'put',
                    dataType: 'json',
                    data: {
                        modelId: 3,
                        year: 2015,
                        name: '2015 Nissan Altima'
                    }
                });
            }).then(function (updated) {
                return findAll();
            }).then(function (cars) {
                equal(cars.data.length, 8, 'New car created');
                return $.ajax({
                    url: '/cars/5',
                    method: 'get',
                    dataType: 'json'
                });
            }).then(function (car) {
                equal(car.name, '2013 Altima', 'get a single car works');
                start();
            });
        });
        test('set.Algebra CRUD works (#12)', 5, function () {
            var algebra = new set.Algebra(new set.Translate('where', 'where'), set.props.id('_id'), set.props.sort('orderBy'), set.props.enum('type', [
                'used',
                'new',
                'certified'
            ]), set.props.rangeInclusive('start', 'end'));
            var store = fixture.store([
                {
                    _id: 1,
                    modelId: 1,
                    year: 2013,
                    name: '2013 Mustang',
                    type: 'used'
                },
                {
                    _id: 2,
                    modelId: 1,
                    year: 2014,
                    name: '2014 Mustang',
                    type: 'new'
                },
                {
                    _id: 3,
                    modelId: 2,
                    year: 2013,
                    name: '2013 Focus',
                    type: 'used'
                },
                {
                    _id: 4,
                    modelId: 2,
                    year: 2014,
                    name: '2014 Focus',
                    type: 'certified'
                },
                {
                    _id: 5,
                    modelId: 3,
                    year: 2013,
                    name: '2013 Altima',
                    type: 'used'
                },
                {
                    _id: 6,
                    modelId: 3,
                    year: 2014,
                    name: '2014 Altima',
                    type: 'certified'
                },
                {
                    _id: 7,
                    modelId: 4,
                    year: 2013,
                    name: '2013 Leaf',
                    type: 'used'
                },
                {
                    _id: 8,
                    modelId: 4,
                    year: 2014,
                    name: '2014 Leaf',
                    type: 'used'
                }
            ], algebra);
            fixture('GET /cars', store.getListData);
            fixture('POST /cars', store.createData);
            fixture('PUT /cars/{_id}', store.updateData);
            fixture('DELETE /cars/{_id}', store.destroyData);
            fixture('GET /cars/{_id}', store.getData);
            var findAll = function () {
                return $.ajax({
                    url: '/cars',
                    dataType: 'json'
                });
            };
            stop();
            findAll().then(function (carsData) {
                equal(carsData.data.length, 8, 'Got all cars');
                return $.ajax({
                    url: '/cars/' + carsData.data[1]._id,
                    method: 'DELETE',
                    dataType: 'json'
                });
            }).then(function () {
                return findAll();
            }).then(function (carsData) {
                equal(carsData.data.length, 7, 'One car less');
                equal(carsData.data[1].name, '2013 Focus', 'Car actually deleted');
            }).then(function () {
                return $.ajax({
                    url: '/cars',
                    method: 'post',
                    dataType: 'json',
                    data: {
                        modelId: 3,
                        year: 2015,
                        name: '2015 Altima',
                        type: 'new'
                    }
                });
            }).then(function (saved) {
                return $.ajax({
                    url: '/cars/' + saved._id,
                    method: 'put',
                    dataType: 'json',
                    data: {
                        modelId: 3,
                        year: 2015,
                        name: '2015 Nissan Altima'
                    }
                });
            }).then(function (updated) {
                return findAll();
            }).then(function (cars) {
                equal(cars.data.length, 8, 'New car created');
                return $.ajax({
                    url: '/cars/5',
                    method: 'get',
                    dataType: 'json'
                });
            }).then(function (car) {
                equal(car.name, '2013 Altima', 'get a single car works');
                start();
            });
        });
        asyncTest('set.Algebra clauses work', function () {
            var algebra = new set.Algebra(new set.Translate('where', 'where'), set.props.id('_id'), set.props.sort('orderBy'), set.props.enum('type', [
                'used',
                'new',
                'certified'
            ]), set.props.rangeInclusive('start', 'end'), {
                year: function (a, b) {
                    if (a === b) {
                        return true;
                    }
                    if (a && b) {
                        return +a === +b;
                    }
                    return false;
                }
            });
            var store = fixture.store([
                {
                    _id: 1,
                    modelId: 1,
                    year: 2013,
                    name: '2013 Mustang',
                    type: 'used'
                },
                {
                    _id: 2,
                    modelId: 1,
                    year: 2014,
                    name: '2014 Mustang',
                    type: 'new'
                },
                {
                    _id: 3,
                    modelId: 2,
                    year: 2013,
                    name: '2013 Focus',
                    type: 'used'
                },
                {
                    _id: 4,
                    modelId: 2,
                    year: 2014,
                    name: '2014 Focus',
                    type: 'certified'
                },
                {
                    _id: 5,
                    modelId: 3,
                    year: 2013,
                    name: '2013 Altima',
                    type: 'used'
                },
                {
                    _id: 6,
                    modelId: 3,
                    year: 2014,
                    name: '2014 Altima',
                    type: 'certified'
                },
                {
                    _id: 7,
                    modelId: 4,
                    year: 2013,
                    name: '2013 Leaf',
                    type: 'used'
                },
                {
                    _id: 8,
                    modelId: 4,
                    year: 2014,
                    name: '2014 Leaf',
                    type: 'used'
                }
            ], algebra);
            fixture('GET /cars', store.findAll);
            $.ajax({
                url: '/cars?where[year]=2013',
                dataType: 'json'
            }).then(function (carsData) {
                equal(carsData.data.length, 4, 'Where clause works with numbers');
                return $.ajax({
                    url: '/cars?where[year]=2013&orderBy=name',
                    dataType: 'json'
                });
            }).then(function (carsData) {
                var names = carsData.data.map(function (c) {
                    return c.name;
                });
                deepEqual(names, [
                    '2013 Altima',
                    '2013 Focus',
                    '2013 Leaf',
                    '2013 Mustang'
                ], 'sort works');
                return $.ajax({
                    url: '/cars?where[year]=2013&orderBy=name&start=1&end=2',
                    dataType: 'json'
                });
            }).then(function (carsData) {
                var names = carsData.data.map(function (c) {
                    return c.name;
                });
                deepEqual(names, [
                    '2013 Focus',
                    '2013 Leaf'
                ], 'pagination works');
                start();
            });
        });
        test('storeConnection reset', function () {
            var algebra = new set.Algebra(new set.Translate('where', 'where'), set.props.id('_id'));
            var store = fixture.store([
                {
                    _id: 1,
                    modelId: 1,
                    year: 2013,
                    name: '2013 Mustang',
                    type: 'used'
                },
                {
                    _id: 2,
                    modelId: 1,
                    year: 2014,
                    name: '2014 Mustang',
                    type: 'new'
                }
            ], algebra);
            fixture('GET /cars', store.getListData);
            fixture('POST /cars', store.createData);
            fixture('PUT /cars/{_id}', store.updateData);
            fixture('DELETE /cars/{_id}', store.destroyData);
            fixture('GET /cars/{_id}', store.getData);
            var findAll = function () {
                return $.ajax({
                    url: '/cars',
                    dataType: 'json'
                });
            };
            $.ajax({
                url: '/cars/1',
                method: 'DELETE',
                dataType: 'json'
            }).then(function () {
                store.reset();
                return findAll();
            }).then(function (carsData) {
                equal(carsData.data.length, 2, 'Got all cars');
                start();
            });
            stop();
        });
        function makeAlgebraTest(fixtureUrl) {
            return function () {
                var algebra = new set.Algebra(new set.Translate('where', 'where'), set.props.id('_id'), set.props.sort('orderBy'), set.props.enum('type', [
                    'used',
                    'new',
                    'certified'
                ]), set.props.rangeInclusive('start', 'end'));
                var store = fixture.store([
                    {
                        _id: 1,
                        modelId: 1,
                        year: 2013,
                        name: '2013 Mustang',
                        type: 'used'
                    },
                    {
                        _id: 2,
                        modelId: 1,
                        year: 2014,
                        name: '2014 Mustang',
                        type: 'new'
                    },
                    {
                        _id: 3,
                        modelId: 2,
                        year: 2013,
                        name: '2013 Focus',
                        type: 'used'
                    },
                    {
                        _id: 4,
                        modelId: 2,
                        year: 2014,
                        name: '2014 Focus',
                        type: 'certified'
                    },
                    {
                        _id: 5,
                        modelId: 3,
                        year: 2013,
                        name: '2013 Altima',
                        type: 'used'
                    },
                    {
                        _id: 6,
                        modelId: 3,
                        year: 2014,
                        name: '2014 Altima',
                        type: 'certified'
                    },
                    {
                        _id: 7,
                        modelId: 4,
                        year: 2013,
                        name: '2013 Leaf',
                        type: 'used'
                    },
                    {
                        _id: 8,
                        modelId: 4,
                        year: 2014,
                        name: '2014 Leaf',
                        type: 'used'
                    }
                ], algebra);
                fixture(fixtureUrl, store);
                var findAll = function () {
                    return $.ajax({
                        url: '/cars',
                        dataType: 'json'
                    });
                };
                stop();
                findAll().then(function (carsData) {
                    equal(carsData.data.length, 8, 'Got all cars');
                    return $.ajax({
                        url: '/cars/' + carsData.data[1]._id,
                        method: 'DELETE',
                        dataType: 'json'
                    });
                }).then(function () {
                    return findAll();
                }).then(function (carsData) {
                    equal(carsData.data.length, 7, 'One car less');
                    equal(carsData.data[1].name, '2013 Focus', 'Car actually deleted');
                }).then(function () {
                    return $.ajax({
                        url: '/cars',
                        method: 'post',
                        dataType: 'json',
                        data: {
                            modelId: 3,
                            year: 2015,
                            name: '2015 Altima',
                            type: 'new'
                        }
                    });
                }).then(function (saved) {
                    return $.ajax({
                        url: '/cars/' + saved._id,
                        method: 'put',
                        dataType: 'json',
                        data: {
                            modelId: 3,
                            year: 2015,
                            name: '2015 Nissan Altima'
                        }
                    });
                }).then(function (updated) {
                    return findAll();
                }).then(function (cars) {
                    equal(cars.data.length, 8, 'New car created');
                    return $.ajax({
                        url: '/cars/5',
                        method: 'get',
                        dataType: 'json'
                    });
                }).then(function (car) {
                    equal(car.name, '2013 Altima', 'get a single car works');
                    start();
                });
            };
        }
        test('set.Algebra CRUD works with easy hookup (#12)', 5, makeAlgebraTest('/cars/{_id}'));
        test('set.Algebra CRUD works with easy hookup and list-style url (#52)', 5, makeAlgebraTest('/cars'));
        test('store.getList and store.get', function () {
            var algebra = new set.Algebra(set.props.id('_id'));
            var store = fixture.store([
                {
                    _id: 1,
                    modelId: 1,
                    year: 2013,
                    name: '2013 Mustang',
                    type: 'used'
                },
                {
                    _id: 2,
                    modelId: 1,
                    year: 2014,
                    name: '2014 Mustang',
                    type: 'new'
                },
                {
                    _id: 3,
                    modelId: 2,
                    year: 2013,
                    name: '2013 Focus',
                    type: 'used'
                },
                {
                    _id: 4,
                    modelId: 2,
                    year: 2014,
                    name: '2014 Focus',
                    type: 'certified'
                },
                {
                    _id: 5,
                    modelId: 3,
                    year: 2013,
                    name: '2013 Altima',
                    type: 'used'
                },
                {
                    _id: 6,
                    modelId: 3,
                    year: 2014,
                    name: '2014 Altima',
                    type: 'certified'
                },
                {
                    _id: 7,
                    modelId: 4,
                    year: 2013,
                    name: '2013 Leaf',
                    type: 'used'
                },
                {
                    _id: 8,
                    modelId: 4,
                    year: 2014,
                    name: '2014 Leaf',
                    type: 'used'
                }
            ], algebra);
            equal(store.getList({ year: 2013 }).data.length, 4, 'filtered');
            deepEqual(store.get({ _id: 5 }).name, '2013 Altima', 'get');
        });
        asyncTest('supports addEventListener on shim using fixture', function () {
            fixture('/addEventListener', function () {
                return {};
            });
            var xhr = new XMLHttpRequest();
            xhr.addEventListener('load', function () {
                ok(true, 'our shim supports addEventListener');
                start();
            });
            xhr.open('GET', '/addEventListener');
            xhr.send();
        });
        if (__dirname !== '/') {
            test('supports sync on XHR shim (#23)', function () {
                var url = __dirname + '/fixtures/test.json';
                var xhr = new XMLHttpRequest();
                xhr.addEventListener('load', function () {
                    ok(true, 'our shim supports addEventListener');
                });
                xhr.open('GET', url, false);
                xhr.send();
            });
        }
        test('supports sync fixtures (#23)', function () {
            fixture('/sync', function () {
                return {};
            });
            var xhr = new XMLHttpRequest();
            xhr.addEventListener('load', function () {
                ok(true, 'our shim supports sync');
            });
            xhr.open('GET', '/sync', false);
            xhr.send();
        });
        if (__dirname !== '/') {
            test('supports sync redirect fixtures (#23)', function () {
                fixture('/sync_redirect', __dirname + '/fixtures/test.json');
                var xhr = new XMLHttpRequest();
                xhr.addEventListener('load', function () {
                    ok(true, 'our shim supports sync redirect');
                });
                xhr.open('GET', '/sync_redirect', false);
                xhr.send();
            });
        }
        if (__dirname !== '/') {
            asyncTest('slow mode works (#26)', function () {
                var url = __dirname + '/fixtures/test.json';
                fixture({ url: url }, 1000);
                var xhr = new XMLHttpRequest();
                var startTime = new Date();
                xhr.addEventListener('load', function () {
                    var delay = new Date() - startTime;
                    ok(delay >= 900, delay + 'ms >= 900ms');
                    fixture({ url: url }, null);
                    start();
                });
                xhr.open('GET', url);
                xhr.send();
            });
        }
        asyncTest('onload should be triggered for HTTP error responses (#36)', function () {
            fixture('/onload', function (req, res) {
                res(400);
            });
            var xhr = new XMLHttpRequest();
            xhr.addEventListener('load', function () {
                ok(true, 'onload should be invoked');
                fixture('/onload', null);
                start();
            });
            xhr.addEventListener('error', function () {
                ok(false, 'onerror should not be invoked');
                fixture('/onload', null);
                start();
            });
            xhr.open('GET', '/onload');
            xhr.send();
        });
        asyncTest('responseText & responseXML should not be set for arraybuffer types (#38)', function () {
            fixture('/onload', '/test/fixtures/foo.json');
            var oldError = window.onerror;
            window.onerror = function (msg, url, line) {
                ok(false, 'There should not be an error');
                start();
            };
            var xhr = new XMLHttpRequest();
            xhr.addEventListener('load', function () {
                fixture('/onload', null);
                window.onerror = oldError;
                ok(true, 'Got here without an error');
                start();
            });
            xhr.responseType = 'arraybuffer';
            xhr.open('GET', '/onload');
            xhr.send();
        });
        asyncTest('fixture with timeout does not run if $.ajax timeout less than delay', function () {
            var delay = fixture.delay;
            fixture.delay = 1000;
            fixture('/onload', function () {
                fixture('/onload', null);
                ok(false, 'timed out xhr did not abort');
                start();
            });
            $.ajax({
                url: '/onload',
                timeout: 50,
                error: function (xhr) {
                    fixture('/onload', null);
                    ok(true, 'Got to the error handler');
                    equal(xhr.statusText, 'timeout');
                    equal(xhr.status, '0');
                    start();
                }
            });
            fixture.delay = delay;
        });
        asyncTest('response headers are set', function () {
            fixture('GET /todos', function (request, response) {
                response(200, '{}', { foo: 'bar' });
            });
            var xhr = new XMLHttpRequest();
            xhr.addEventListener('load', function () {
                var headers = parseHeaders(xhr.getAllResponseHeaders());
                ok(headers.foo === 'bar', 'header was set');
                start();
            });
            xhr.open('GET', '/todos');
            xhr.send();
        });
        asyncTest('match values in get data', function () {
            fixture({
                method: 'GET',
                url: '/data-value',
                data: { name: 'justin' }
            }, function (request, response) {
                QUnit.ok(true, 'got it');
                return {};
            });
            var xhr = new XMLHttpRequest();
            xhr.addEventListener('load', function () {
                QUnit.start();
            });
            xhr.open('GET', '/data-value?name=justin&age=22');
            xhr.send();
        });
        asyncTest('universal match (#2000)', function () {
            fixture({}, function () {
                ok(true, 'got hit');
                return {};
            });
            var xhr = new XMLHttpRequest();
            xhr.addEventListener('load', function () {
                QUnit.start();
                fixture.fixtures.splice(0, fixture.fixtures.length);
            });
            xhr.open('GET', '/something-totally-unexpected-62');
            xhr.send();
        });
        test('set.Algebra stores provide a count (#58)', function () {
            var algebra = new set.Algebra(new set.Translate('where', 'where'), set.props.id('_id'), set.props.sort('orderBy'), set.props.enum('type', [
                'used',
                'new',
                'certified'
            ]), set.props.rangeInclusive('start', 'end'));
            var store = fixture.store([
                {
                    _id: 1,
                    modelId: 1,
                    year: 2013,
                    name: '2013 Mustang',
                    type: 'used'
                },
                {
                    _id: 2,
                    modelId: 1,
                    year: 2014,
                    name: '2014 Mustang',
                    type: 'new'
                },
                {
                    _id: 3,
                    modelId: 2,
                    year: 2013,
                    name: '2013 Focus',
                    type: 'used'
                },
                {
                    _id: 4,
                    modelId: 2,
                    year: 2014,
                    name: '2014 Focus',
                    type: 'certified'
                },
                {
                    _id: 5,
                    modelId: 3,
                    year: 2013,
                    name: '2013 Altima',
                    type: 'used'
                },
                {
                    _id: 6,
                    modelId: 3,
                    year: 2014,
                    name: '2014 Altima',
                    type: 'certified'
                },
                {
                    _id: 7,
                    modelId: 4,
                    year: 2013,
                    name: '2013 Leaf',
                    type: 'used'
                },
                {
                    _id: 8,
                    modelId: 4,
                    year: 2014,
                    name: '2014 Leaf',
                    type: 'used'
                }
            ], algebra);
            fixture('/cars/{_id}', store);
            stop();
            $.ajax({
                url: '/cars',
                dataType: 'json',
                data: {
                    start: 2,
                    end: 3
                }
            }).then(function (carsData) {
                equal(carsData.data.length, 2, 'Got 2 cars');
                equal(carsData.count, 8, 'got the count');
                QUnit.start();
            }, function () {
                QUnit.ok(false, 'borked');
                QUnit.start();
            });
        });
        if ('onabort' in XMLHttpRequest._XHR.prototype) {
            asyncTest('fixture with timeout aborts if xhr timeout less than delay', function () {
                fixture('/onload', 1000);
                var xhr = new XMLHttpRequest();
                xhr.open('GET', '/onload');
                xhr.send();
                setTimeout(function () {
                    xhr.abort();
                }, 50);
                xhr.addEventListener('abort', function () {
                    fixture('/onload', null);
                    ok(true, 'Got to the error handler');
                    equal(xhr.statusText, '');
                    equal(xhr.status, 0);
                    start();
                });
                xhr.addEventListener('load', function () {
                    fixture('/onload', null);
                    ok(false, 'timed out xhr did not abort');
                    start();
                });
            });
            asyncTest('dynamic fixture with timeout does not run if xhr timeout less than delay', function () {
                var delay = fixture.delay;
                fixture.delay = 1000;
                fixture('/onload', function () {
                    fixture('/onload', null);
                    ok(false, 'timed out xhr did not abort');
                    start();
                });
                var xhr = new XMLHttpRequest();
                xhr.open('GET', '/onload');
                setTimeout(function () {
                    xhr.abort();
                }, 50);
                xhr.send();
                xhr.addEventListener('abort', function () {
                    fixture('/onload', null);
                    ok(true, 'Got to the error handler');
                    equal(xhr.statusText, '');
                    equal(xhr.status, 0);
                    start();
                });
                fixture.delay = delay;
            });
            test('abort() sets readyState correctly', function () {
                stop();
                fixture('/foo', function () {
                    return {};
                });
                var xhr = new XMLHttpRequest();
                xhr.open('GET', '/foo');
                xhr.addEventListener('abort', function () {
                    fixture('/foo', null);
                    ok(true, 'Got to the error handler');
                    equal(xhr.status, 0);
                    equal(xhr.statusText, '');
                    setTimeout(function () {
                        equal(xhr.readyState, 0);
                        start();
                    }, 50);
                });
                xhr.send();
                xhr.abort();
            });
            test('abort() of already completed fixture', function () {
                stop();
                fixture('/foo', function () {
                    return {};
                });
                var xhr = new XMLHttpRequest();
                xhr.open('GET', '/foo');
                xhr.addEventListener('load', function () {
                    fixture('/foo', null);
                    equal(xhr.readyState, 4);
                    xhr.abort();
                    start();
                });
                xhr.send();
            });
            asyncTest('should be able to call getResponseHeader onload', function () {
                fixture('/onload', function (req, res) {
                    res(400);
                });
                var xhr = new XMLHttpRequest();
                xhr.addEventListener('load', function () {
                    fixture('/onload', null);
                    xhr.getResponseHeader('Set-Cookie');
                    ok(true, 'should not throw when calling getResponseHeader');
                    start();
                });
                xhr.open('GET', '/onload');
                xhr.send();
            });
        }
    }('/'));
});
/*can-connect@1.5.3#data/parse/parse*/
define('can-connect@1.5.3#data/parse/parse', function (require, exports, module) {
    var connect = require('can-connect');
    var each = require('can-util/js/each/each');
    var isArray = require('can-util/js/is-array/is-array');
    var getObject = require('can-util/js/get/get');
    module.exports = connect.behavior('data/parse', function (baseConnection) {
        var behavior = {
            parseListData: function (responseData) {
                if (baseConnection.parseListData) {
                    responseData = baseConnection.parseListData.apply(this, arguments);
                }
                var result;
                if (isArray(responseData)) {
                    result = { data: responseData };
                } else {
                    var prop = this.parseListProp || 'data';
                    responseData.data = getObject(responseData, prop);
                    result = responseData;
                    if (prop !== 'data') {
                        delete responseData[prop];
                    }
                    if (!isArray(result.data)) {
                        throw new Error('Could not get any raw data while converting using .parseListData');
                    }
                }
                var arr = [];
                for (var i = 0; i < result.data.length; i++) {
                    arr.push(this.parseInstanceData(result.data[i]));
                }
                result.data = arr;
                return result;
            },
            parseInstanceData: function (props) {
                if (baseConnection.parseInstanceData) {
                    props = baseConnection.parseInstanceData.apply(this, arguments) || props;
                }
                return this.parseInstanceProp ? getObject(props, this.parseInstanceProp) || props : props;
            }
        };
        each(pairs, function (parseFunction, name) {
            behavior[name] = function (params) {
                var self = this;
                return baseConnection[name].call(this, params).then(function () {
                    return self[parseFunction].apply(self, arguments);
                });
            };
        });
        return behavior;
    });
    var pairs = {
        getListData: 'parseListData',
        getData: 'parseInstanceData',
        createData: 'parseInstanceData',
        updateData: 'parseInstanceData',
        destroyData: 'parseInstanceData'
    };
});
/*can-connect@1.5.3#helpers/weak-reference-map*/
define('can-connect@1.5.3#helpers/weak-reference-map', function (require, exports, module) {
    var assign = require('can-util/js/assign/assign');
    var WeakReferenceMap = function () {
        this.set = {};
    };
    assign(WeakReferenceMap.prototype, {
        has: function (key) {
            return !!this.set[key];
        },
        addReference: function (key, item, referenceCount) {
            if (typeof key === 'undefined') {
                throw new Error('can-connect: You must provide a key to store a value in a WeakReferenceMap');
            }
            var data = this.set[key];
            if (!data) {
                data = this.set[key] = {
                    item: item,
                    referenceCount: 0,
                    key: key
                };
            }
            data.referenceCount += referenceCount || 1;
        },
        referenceCount: function (key) {
            var data = this.set[key];
            if (data) {
                return data.referenceCount;
            }
        },
        deleteReference: function (key) {
            var data = this.set[key];
            if (data) {
                data.referenceCount--;
                if (data.referenceCount === 0) {
                    delete this.set[key];
                }
            }
        },
        get: function (key) {
            var data = this.set[key];
            if (data) {
                return data.item;
            }
        },
        forEach: function (cb) {
            for (var id in this.set) {
                cb(this.set[id].item, id);
            }
        }
    });
    module.exports = WeakReferenceMap;
});
/*can-connect@1.5.3#helpers/id-merge*/
define('can-connect@1.5.3#helpers/id-merge', function (require, exports, module) {
    var map = [].map;
    module.exports = function (list, update, id, make) {
        var listIndex = 0, updateIndex = 0;
        while (listIndex < list.length && updateIndex < update.length) {
            var listItem = list[listIndex], updateItem = update[updateIndex], lID = id(listItem), uID = id(updateItem);
            if (id(listItem) === id(updateItem)) {
                listIndex++;
                updateIndex++;
                continue;
            }
            if (updateIndex + 1 < update.length && id(update[updateIndex + 1]) === lID) {
                list.splice(listIndex, 0, make(update[updateIndex]));
                listIndex++;
                updateIndex++;
                continue;
            } else if (listIndex + 1 < list.length && id(list[listIndex + 1]) === uID) {
                list.splice(listIndex, 1);
                listIndex++;
                updateIndex++;
                continue;
            } else {
                list.splice.apply(list, [
                    listIndex,
                    list.length - listIndex
                ].concat(map.call(update.slice(updateIndex), make)));
                return list;
            }
        }
        if (updateIndex === update.length && listIndex === list.length) {
            return;
        }
        list.splice.apply(list, [
            listIndex,
            list.length - listIndex
        ].concat(map.call(update.slice(updateIndex), make)));
        return;
    };
});
/*can-connect@1.5.3#constructor/constructor*/
define('can-connect@1.5.3#constructor/constructor', function (require, exports, module) {
    var isArray = require('can-util/js/is-array/is-array');
    var makeArray = require('can-util/js/make-array/make-array');
    var assign = require('can-util/js/assign/assign');
    var connect = require('can-connect');
    var WeakReferenceMap = require('can-connect/helpers/weak-reference-map');
    var overwrite = require('can-connect/helpers/overwrite');
    var idMerge = require('can-connect/helpers/id-merge');
    module.exports = connect.behavior('constructor', function (baseConnection) {
        var behavior = {
            cidStore: new WeakReferenceMap(),
            _cid: 0,
            get: function (params) {
                var self = this;
                return this.getData(params).then(function (data) {
                    return self.hydrateInstance(data);
                });
            },
            getList: function (set) {
                set = set || {};
                var self = this;
                return this.getListData(set).then(function (data) {
                    return self.hydrateList(data, set);
                });
            },
            hydrateList: function (listData, set) {
                if (isArray(listData)) {
                    listData = { data: listData };
                }
                var arr = [];
                for (var i = 0; i < listData.data.length; i++) {
                    arr.push(this.hydrateInstance(listData.data[i]));
                }
                listData.data = arr;
                if (this.list) {
                    return this.list(listData, set);
                } else {
                    var list = listData.data.slice(0);
                    list[this.listSetProp || '__listSet'] = set;
                    copyMetadata(listData, list);
                    return list;
                }
            },
            hydrateInstance: function (props) {
                if (this.instance) {
                    return this.instance(props);
                } else {
                    return assign({}, props);
                }
            },
            save: function (instance) {
                var serialized = this.serializeInstance(instance);
                var id = this.id(instance);
                var self = this;
                if (id === undefined) {
                    var cid = this._cid++;
                    this.cidStore.addReference(cid, instance);
                    return this.createData(serialized, cid).then(function (data) {
                        if (data !== undefined) {
                            self.createdInstance(instance, data);
                        }
                        self.cidStore.deleteReference(cid, instance);
                        return instance;
                    });
                } else {
                    return this.updateData(serialized).then(function (data) {
                        if (data !== undefined) {
                            self.updatedInstance(instance, data);
                        }
                        return instance;
                    });
                }
            },
            destroy: function (instance) {
                var serialized = this.serializeInstance(instance), self = this;
                return this.destroyData(serialized).then(function (data) {
                    if (data !== undefined) {
                        self.destroyedInstance(instance, data);
                    }
                    return instance;
                });
            },
            createdInstance: function (instance, props) {
                assign(instance, props);
            },
            updatedInstance: function (instance, data) {
                overwrite(instance, data, this.idProp);
            },
            updatedList: function (list, listData, set) {
                var instanceList = [];
                for (var i = 0; i < listData.data.length; i++) {
                    instanceList.push(this.hydrateInstance(listData.data[i]));
                }
                idMerge(list, instanceList, this.id.bind(this), this.hydrateInstance.bind(this));
                copyMetadata(listData, list);
            },
            destroyedInstance: function (instance, data) {
                overwrite(instance, data, this.idProp);
            },
            serializeInstance: function (instance) {
                return assign({}, instance);
            },
            serializeList: function (list) {
                var self = this;
                return makeArray(list).map(function (instance) {
                    return self.serializeInstance(instance);
                });
            },
            isNew: function (instance) {
                var id = this.id(instance);
                return !(id || id === 0);
            }
        };
        return behavior;
    });
    function copyMetadata(listData, list) {
        for (var prop in listData) {
            if (prop !== 'data') {
                if (typeof list.set === 'function') {
                    list.set(prop, listData[prop]);
                } else if (typeof list.attr === 'function') {
                    list.attr(prop, listData[prop]);
                } else {
                    list[prop] = listData[prop];
                }
            }
        }
    }
});
/*can-connect@1.5.3#helpers/weak-reference-set*/
define('can-connect@1.5.3#helpers/weak-reference-set', function (require, exports, module) {
    var assign = require('can-util/js/assign/assign');
    var WeakReferenceSet = function () {
        this.set = [];
    };
    assign(WeakReferenceSet.prototype, {
        has: function (item) {
            return this._getIndex(item) !== -1;
        },
        addReference: function (item, referenceCount) {
            var index = this._getIndex(item);
            var data = this.set[index];
            if (!data) {
                data = {
                    item: item,
                    referenceCount: 0
                };
                this.set.push(data);
            }
            data.referenceCount += referenceCount || 1;
        },
        deleteReference: function (item) {
            var index = this._getIndex(item);
            var data = this.set[index];
            if (data) {
                data.referenceCount--;
                if (data.referenceCount === 0) {
                    this.set.splice(index, 1);
                }
            }
        },
        delete: function (item) {
            var index = this._getIndex(item);
            if (index !== -1) {
                this.set.splice(index, 1);
            }
        },
        get: function (item) {
            var data = this.set[this._getIndex(item)];
            if (data) {
                return data.item;
            }
        },
        referenceCount: function (item) {
            var data = this.set[this._getIndex(item)];
            if (data) {
                return data.referenceCount;
            }
        },
        _getIndex: function (item) {
            var index;
            this.set.every(function (data, i) {
                if (data.item === item) {
                    index = i;
                    return false;
                }
            });
            return index !== undefined ? index : -1;
        },
        forEach: function (cb) {
            return this.set.forEach(cb);
        }
    });
    module.exports = WeakReferenceSet;
});
/*can-validate-interface@0.1.0#index*/
define('can-validate-interface@0.1.0#index', function (require, exports, module) {
    function makeInterfaceValidator(interfacePropArrays) {
        var props = flatten(interfacePropArrays);
        return function (base) {
            var missingProps = props.reduce(function (missing, prop) {
                return prop in base ? missing : missing.concat(prop);
            }, []);
            return missingProps.length ? {
                message: 'missing expected properties',
                related: missingProps
            } : undefined;
        };
    }
    function flatten(arrays) {
        return arrays.reduce(function (ret, val) {
            return ret.concat(val);
        }, []);
    }
    module.exports = makeInterfaceValidator;
});
/*can-connect@1.5.3#helpers/validate*/
define('can-connect@1.5.3#helpers/validate', function (require, exports, module) {
    var makeInterfaceValidator = require('can-validate-interface');
    module.exports = function (extendingBehavior, interfaces) {
        var validatedBehaviour = validateArgumentInterface(extendingBehavior, 0, interfaces, function (errors, baseBehavior) {
            throw new BehaviorInterfaceError(baseBehavior, extendingBehavior, errors);
        });
        Object.keys(extendingBehavior).forEach(function (k) {
            validatedBehaviour[k] = extendingBehavior[k];
        });
        validatedBehaviour.__interfaces = interfaces;
        return validatedBehaviour;
    };
    function validateArgumentInterface(func, argIndex, interfaces, errorHandler) {
        return function () {
            var errors = makeInterfaceValidator(interfaces)(arguments[argIndex]);
            if (errors && errorHandler) {
                errorHandler(errors, arguments[argIndex]);
            }
            return func.apply(this, arguments);
        };
    }
    function BehaviorInterfaceError(baseBehavior, extendingBehavior, missingProps) {
        var extendingName = extendingBehavior.behaviorName || 'anonymous behavior', baseName = baseBehavior.__behaviorName || 'anonymous behavior', message = 'can-connect: Extending behavior "' + extendingName + '" found base behavior "' + baseName + '" was missing required properties: ' + JSON.stringify(missingProps.related), instance = new Error(message);
        if (Object.setPrototypeOf) {
            Object.setPrototypeOf(instance, Object.getPrototypeOf(this));
        }
        return instance;
    }
    BehaviorInterfaceError.prototype = Object.create(Error.prototype, { constructor: { value: Error } });
    if (Object.setPrototypeOf) {
        Object.setPrototypeOf(BehaviorInterfaceError, Error);
    } else {
        BehaviorInterfaceError.__proto__ = Error;
    }
});
/*can-connect@1.5.3#constructor/store/store*/
define('can-connect@1.5.3#constructor/store/store', function (require, exports, module) {
    var connect = require('can-connect');
    var WeakReferenceMap = require('can-connect/helpers/weak-reference-map');
    var WeakReferenceSet = require('can-connect/helpers/weak-reference-set');
    var sortedSetJSON = require('can-connect/helpers/sorted-set-json');
    var canEvent = require('can-event');
    var assign = require('can-util/js/assign/assign');
    var pendingRequests = 0;
    var noRequestsTimer = null;
    var requests = {
        increment: function (connection) {
            pendingRequests++;
            clearTimeout(noRequestsTimer);
        },
        decrement: function (connection) {
            pendingRequests--;
            if (pendingRequests === 0) {
                noRequestsTimer = setTimeout(function () {
                    requests.dispatch('end');
                }, 10);
            }
        },
        count: function () {
            return pendingRequests;
        }
    };
    assign(requests, canEvent);
    var constructorStore = connect.behavior('constructor/store', function (baseConnection) {
        var behavior = {
            instanceStore: new WeakReferenceMap(),
            newInstanceStore: new WeakReferenceSet(),
            listStore: new WeakReferenceMap(),
            _requestInstances: {},
            _requestLists: {},
            _finishedRequest: function () {
                var id;
                requests.decrement(this);
                if (requests.count() === 0) {
                    for (id in this._requestInstances) {
                        this.instanceStore.deleteReference(id);
                    }
                    this._requestInstances = {};
                    for (id in this._requestLists) {
                        this.listStore.deleteReference(id);
                    }
                    this._requestLists = {};
                }
            },
            addInstanceReference: function (instance, id) {
                var ID = id || this.id(instance);
                if (ID === undefined) {
                    this.newInstanceStore.addReference(instance);
                } else {
                    this.instanceStore.addReference(ID, instance);
                }
            },
            createdInstance: function (instance, props) {
                baseConnection.createdInstance.apply(this, arguments);
                this.moveCreatedInstanceToInstanceStore(instance);
            },
            moveCreatedInstanceToInstanceStore: function (instance) {
                var ID = this.id(instance);
                if (this.newInstanceStore.has(instance) && ID !== undefined) {
                    var referenceCount = this.newInstanceStore.referenceCount(instance);
                    this.newInstanceStore.delete(instance);
                    this.instanceStore.addReference(ID, instance, referenceCount);
                }
            },
            addInstanceMetaData: function (instance, name, value) {
                var data = this.instanceStore.set[this.id(instance)];
                if (data) {
                    data[name] = value;
                }
            },
            getInstanceMetaData: function (instance, name) {
                var data = this.instanceStore.set[this.id(instance)];
                if (data) {
                    return data[name];
                }
            },
            deleteInstanceMetaData: function (instance, name) {
                var data = this.instanceStore.set[this.id(instance)];
                delete data[name];
            },
            deleteInstanceReference: function (instance) {
                var ID = this.id(instance);
                if (ID === undefined) {
                    this.newInstanceStore.deleteReference(instance);
                } else {
                    this.instanceStore.deleteReference(this.id(instance), instance);
                }
            },
            addListReference: function (list, set) {
                var id = sortedSetJSON(set || this.listSet(list));
                if (id) {
                    this.listStore.addReference(id, list);
                }
            },
            deleteListReference: function (list, set) {
                var id = sortedSetJSON(set || this.listSet(list));
                if (id) {
                    this.listStore.deleteReference(id, list);
                }
            },
            hydratedInstance: function (instance) {
                if (requests.count() > 0) {
                    var id = this.id(instance);
                    if (!this._requestInstances[id]) {
                        this.addInstanceReference(instance);
                        this._requestInstances[id] = instance;
                    }
                }
            },
            hydrateInstance: function (props) {
                var id = this.id(props);
                if ((id || id === 0) && this.instanceStore.has(id)) {
                    var storeInstance = this.instanceStore.get(id);
                    this.updatedInstance(storeInstance, props);
                    return storeInstance;
                }
                var instance = baseConnection.hydrateInstance.call(this, props);
                this.hydratedInstance(instance);
                return instance;
            },
            hydratedList: function (list, set) {
                if (requests.count() > 0) {
                    var id = sortedSetJSON(set || this.listSet(list));
                    if (id) {
                        if (!this._requestLists[id]) {
                            this.addListReference(list, set);
                            this._requestLists[id] = list;
                        }
                    }
                }
            },
            hydrateList: function (listData, set) {
                set = set || this.listSet(listData);
                var id = sortedSetJSON(set);
                if (id && this.listStore.has(id)) {
                    var storeList = this.listStore.get(id);
                    this.updatedList(storeList, listData, set);
                    return storeList;
                }
                var list = baseConnection.hydrateList.call(this, listData, set);
                this.hydratedList(list, set);
                return list;
            },
            getList: function (params) {
                var self = this;
                requests.increment(this);
                var promise = baseConnection.getList.call(this, params);
                promise.then(function (instances) {
                    self._finishedRequest();
                }, function () {
                    self._finishedRequest();
                });
                return promise;
            },
            get: function (params) {
                var self = this;
                requests.increment(this);
                var promise = baseConnection.get.call(this, params);
                promise.then(function (instance) {
                    self._finishedRequest();
                }, function () {
                    self._finishedRequest();
                });
                return promise;
            },
            save: function (instance) {
                var self = this;
                requests.increment(this);
                var updating = !this.isNew(instance);
                if (updating) {
                    this.addInstanceReference(instance);
                }
                var promise = baseConnection.save.call(this, instance);
                promise.then(function (instances) {
                    if (updating) {
                        self.deleteInstanceReference(instance);
                    }
                    self._finishedRequest();
                }, function () {
                    self._finishedRequest();
                });
                return promise;
            },
            destroy: function (instance) {
                var self = this;
                requests.increment(this);
                var promise = baseConnection.destroy.call(this, instance);
                promise.then(function (instance) {
                    self._finishedRequest();
                }, function () {
                    self._finishedRequest();
                });
                return promise;
            }
        };
        return behavior;
    });
    constructorStore.requests = requests;
    module.exports = constructorStore;
});
/*can-connect@1.5.3#can/map/map*/
define('can-connect@1.5.3#can/map/map', function (require, exports, module) {
    'use strict';
    var each = require('can-util/js/each/each');
    var connect = require('can-connect');
    var canBatch = require('can-event/batch/batch');
    var canEvent = require('can-event');
    var Observation = require('can-observation');
    var isPlainObject = require('can-util/js/is-plain-object/is-plain-object');
    var isArray = require('can-util/js/is-array/is-array');
    var types = require('can-types');
    var each = require('can-util/js/each/each');
    var isFunction = require('can-util/js/is-function/is-function');
    var dev = require('can-util/js/dev/dev');
    var canReflect = require('can-reflect');
    var setExpando = function (map, prop, value) {
        if ('attr' in map) {
            map[prop] = value;
        } else {
            map._data[prop] = value;
        }
    };
    var getExpando = function (map, prop) {
        if ('attr' in map) {
            return map[prop];
        } else {
            return map._data[prop];
        }
    };
    var canMapBehavior = connect.behavior('can/map', function (baseConnection) {
        var behavior = {
            init: function () {
                this.Map = this.Map || types.DefaultMap.extend({});
                this.List = this.List || types.DefaultList.extend({});
                overwrite(this, this.Map, mapOverwrites, mapStaticOverwrites);
                overwrite(this, this.List, listPrototypeOverwrites, listStaticOverwrites);
                baseConnection.init.apply(this, arguments);
            },
            id: function (instance) {
                if (!isPlainObject(instance)) {
                    var ids = [], algebra = this.algebra;
                    if (algebra && algebra.clauses && algebra.clauses.id) {
                        for (var prop in algebra.clauses.id) {
                            ids.push(readObservabe(instance, prop));
                        }
                    }
                    if (this.idProp && !ids.length) {
                        ids.push(readObservabe(instance, this.idProp));
                    }
                    if (!ids.length) {
                        ids.push(readObservabe(instance, 'id'));
                    }
                    return ids.length > 1 ? ids.join('@|@') : ids[0];
                } else {
                    return baseConnection.id(instance);
                }
            },
            serializeInstance: function (instance) {
                return instance.serialize();
            },
            serializeList: function (list) {
                return list.serialize();
            },
            instance: function (props) {
                var _Map = this.Map || types.DefaultMap;
                return new _Map(props);
            },
            list: function (listData, set) {
                var _List = this.List || this.Map && this.Map.List || types.DefaultList;
                var list = new _List(listData.data);
                each(listData, function (val, prop) {
                    if (prop !== 'data') {
                        list[list.set ? 'set' : 'attr'](prop, val);
                    }
                });
                list.__listSet = set;
                return list;
            },
            updatedList: function () {
                canBatch.start();
                var res = baseConnection.updatedList.apply(this, arguments);
                canBatch.stop();
                return res;
            },
            save: function (instance) {
                setExpando(instance, '_saving', true);
                canEvent.dispatch.call(instance, '_saving', [
                    true,
                    false
                ]);
                var done = function () {
                    setExpando(instance, '_saving', false);
                    canEvent.dispatch.call(instance, '_saving', [
                        false,
                        true
                    ]);
                };
                var base = baseConnection.save.apply(this, arguments);
                base.then(done, done);
                return base;
            },
            destroy: function (instance) {
                setExpando(instance, '_destroying', true);
                canEvent.dispatch.call(instance, '_destroying', [
                    true,
                    false
                ]);
                var done = function () {
                    setExpando(instance, '_destroying', false);
                    canEvent.dispatch.call(instance, '_destroying', [
                        false,
                        true
                    ]);
                };
                var base = baseConnection.destroy.apply(this, arguments);
                base.then(done, done);
                return base;
            }
        };
        each([
            'created',
            'updated',
            'destroyed'
        ], function (funcName) {
            behavior[funcName + 'Instance'] = function (instance, props) {
                if (props && typeof props === 'object') {
                    if (this.constructor.removeAttr) {
                        canReflect.updateDeep(instance, props);
                    } else {
                        canReflect.assignDeep(instance, props);
                    }
                }
                if (funcName === 'created' && this.moveCreatedInstanceToInstanceStore) {
                    this.moveCreatedInstanceToInstanceStore(instance);
                }
                canMapBehavior.callbackInstanceEvents(funcName, instance);
            };
        });
        return behavior;
    });
    canMapBehavior.callbackInstanceEvents = function (funcName, instance) {
        var constructor = instance.constructor;
        canEvent.dispatch.call(instance, {
            type: funcName,
            target: instance
        });
        canEvent.dispatch.call(constructor, funcName, [instance]);
    };
    var callCanReadingOnIdRead = true;
    var mapStaticOverwrites = {
        getList: function (base, connection) {
            return function (set) {
                return connection.getList(set);
            };
        },
        findAll: function (base, connection) {
            return function (set) {
                return connection.getList(set);
            };
        },
        get: function (base, connection) {
            return function (params) {
                return connection.get(params);
            };
        },
        findOne: function (base, connection) {
            return function (params) {
                return connection.get(params);
            };
        }
    };
    var mapOverwrites = {
        _eventSetup: function (base, connection) {
            return function () {
                callCanReadingOnIdRead = false;
                if (connection.addInstanceReference) {
                    connection.addInstanceReference(this);
                }
                callCanReadingOnIdRead = true;
                return base.apply(this, arguments);
            };
        },
        _eventTeardown: function (base, connection) {
            return function () {
                callCanReadingOnIdRead = false;
                if (connection.deleteInstanceReference) {
                    connection.deleteInstanceReference(this);
                }
                callCanReadingOnIdRead = true;
                return base.apply(this, arguments);
            };
        },
        ___set: function (base, connection) {
            return function (prop, val) {
                base.apply(this, arguments);
                if (prop === connection.idProp && this.__bindEvents && this.__bindEvents._lifecycleBindings) {
                    connection.addInstanceReference(this);
                }
            };
        },
        isNew: function (base, connection) {
            return function () {
                var id = connection.id(this);
                return !(id || id === 0);
            };
        },
        isSaving: function (base, connection) {
            return function () {
                Observation.add(this, '_saving');
                return !!getExpando(this, '_saving');
            };
        },
        isDestroying: function (base, connection) {
            return function () {
                Observation.add(this, '_destroying');
                return !!getExpando(this, '_destroying');
            };
        },
        save: function (base, connection) {
            return function (success, error) {
                var promise = connection.save(this);
                promise.then(success, error);
                return promise;
            };
        },
        destroy: function (base, connection) {
            return function (success, error) {
                var promise;
                if (this.isNew()) {
                    promise = Promise.resolve(this);
                    connection.destroyedInstance(this, {});
                } else {
                    promise = connection.destroy(this);
                }
                promise.then(success, error);
                return promise;
            };
        }
    };
    var listPrototypeOverwrites = {
        setup: function (base, connection) {
            return function (params) {
                if (isPlainObject(params) && !isArray(params)) {
                    this.__listSet = params;
                    base.apply(this);
                    this.replace(canReflect.isPromise(params) ? params : connection.getList(params));
                } else {
                    base.apply(this, arguments);
                }
            };
        },
        _eventSetup: function (base, connection) {
            return function () {
                if (connection.addListReference) {
                    connection.addListReference(this);
                }
                if (base) {
                    return base.apply(this, arguments);
                }
            };
        },
        _eventTeardown: function (base, connection) {
            return function () {
                if (connection.deleteListReference) {
                    connection.deleteListReference(this);
                }
                if (base) {
                    return base.apply(this, arguments);
                }
            };
        }
    };
    var listStaticOverwrites = {
        _bubbleRule: function (base, connection) {
            return function (eventName, list) {
                var bubbleRules = base(eventName, list);
                bubbleRules.push('destroyed');
                return bubbleRules;
            };
        }
    };
    var readObservabe = function (instance, prop) {
        if ('__get' in instance) {
            if (callCanReadingOnIdRead) {
                Observation.add(instance, prop);
            }
            return instance.__get(prop);
        } else {
            if (callCanReadingOnIdRead) {
                return instance[prop];
            } else {
                return Observation.ignore(function () {
                    return instance[prop];
                })();
            }
        }
    };
    var overwrite = function (connection, Constructor, prototype, statics) {
        var prop;
        for (prop in prototype) {
            Constructor.prototype[prop] = prototype[prop](Constructor.prototype[prop], connection);
        }
        if (statics) {
            for (prop in statics) {
                Constructor[prop] = statics[prop](Constructor[prop], connection);
            }
        }
    };
    module.exports = canMapBehavior;
});
/*can-connect@1.5.3#data/callbacks/callbacks*/
define('can-connect@1.5.3#data/callbacks/callbacks', function (require, exports, module) {
    var connect = require('can-connect');
    var each = require('can-util/js/each/each');
    var pairs = {
        getListData: 'gotListData',
        createData: 'createdData',
        updateData: 'updatedData',
        destroyData: 'destroyedData'
    };
    var dataCallbackBehavior = connect.behavior('data/callbacks', function (baseConnection) {
        var behavior = {};
        each(pairs, function (callbackName, name) {
            behavior[name] = function (params, cid) {
                var self = this;
                return baseConnection[name].call(this, params).then(function (data) {
                    if (self[callbackName]) {
                        return self[callbackName].call(self, data, params, cid);
                    } else {
                        return data;
                    }
                });
            };
        });
        return behavior;
    });
    module.exports = dataCallbackBehavior;
});
/*can-connect@1.5.3#real-time/real-time*/
define('can-connect@1.5.3#real-time/real-time', function (require, exports, module) {
    var connect = require('../can-connect');
    var canSet = require('can-set');
    var setAdd = require('can-connect/helpers/set-add');
    var indexOf = require('can-connect/helpers/get-index-by-id');
    var canDev = require('can-util/js/dev/dev');
    module.exports = connect.behavior('real-time', function (baseConnection) {
        var createPromise = Promise.resolve();
        return {
            createData: function () {
                var promise = baseConnection.createData.apply(this, arguments);
                var cleanPromise = promise.catch(function () {
                    return '';
                });
                createPromise = Promise.all([
                    createPromise,
                    cleanPromise
                ]);
                return promise;
            },
            createInstance: function (props) {
                var self = this;
                return new Promise(function (resolve, reject) {
                    createPromise.then(function () {
                        setTimeout(function () {
                            var id = self.id(props);
                            var instance = self.instanceStore.get(id);
                            var serialized;
                            if (instance) {
                                resolve(self.updateInstance(props));
                            } else {
                                instance = self.hydrateInstance(props);
                                serialized = self.serializeInstance(instance);
                                self.addInstanceReference(instance);
                                Promise.resolve(self.createdData(props, serialized)).then(function () {
                                    self.deleteInstanceReference(instance);
                                    resolve(instance);
                                });
                            }
                        }, 1);
                    });
                });
            },
            createdData: function (props, params, cid) {
                var instance;
                if (cid !== undefined) {
                    instance = this.cidStore.get(cid);
                } else {
                    instance = this.instanceStore.get(this.id(props));
                }
                this.addInstanceReference(instance, this.id(props));
                this.createdInstance(instance, props);
                create.call(this, this.serializeInstance(instance));
                this.deleteInstanceReference(instance);
                return undefined;
            },
            updatedData: function (props, params) {
                var instance = this.instanceStore.get(this.id(params));
                this.updatedInstance(instance, props);
                update.call(this, this.serializeInstance(instance));
                return undefined;
            },
            updateInstance: function (props) {
                var id = this.id(props);
                var instance = this.instanceStore.get(id);
                if (!instance) {
                    instance = this.hydrateInstance(props);
                }
                this.addInstanceReference(instance);
                var serialized = this.serializeInstance(instance), self = this;
                return Promise.resolve(this.updatedData(props, serialized)).then(function () {
                    self.deleteInstanceReference(instance);
                    return instance;
                });
            },
            destroyedData: function (props, params) {
                var id = this.id(params || props);
                var instance = this.instanceStore.get(id);
                if (!instance) {
                    instance = this.hydrateInstance(props);
                }
                var serialized = this.serializeInstance(instance);
                this.destroyedInstance(instance, props);
                destroy.call(this, serialized);
                return undefined;
            },
            destroyInstance: function (props) {
                var id = this.id(props);
                var instance = this.instanceStore.get(id);
                if (!instance) {
                    instance = this.hydrateInstance(props);
                }
                this.addInstanceReference(instance);
                var serialized = this.serializeInstance(instance), self = this;
                return Promise.resolve(this.destroyedData(props, serialized)).then(function () {
                    self.deleteInstanceReference(instance);
                    return instance;
                });
            }
        };
    });
    var create = function (props) {
        var self = this;
        this.listStore.forEach(function (list, id) {
            var set = JSON.parse(id);
            var index = indexOf(self, props, list);
            if (canSet.has(set, props, self.algebra)) {
                if (index === -1) {
                    var items = self.serializeList(list);
                    self.updatedList(list, { data: setAdd(self, set, items, props, self.algebra) }, set);
                } else {
                }
            }
        });
    };
    var update = function (props) {
        var self = this;
        this.listStore.forEach(function (list, id) {
            var items;
            var set = JSON.parse(id);
            var index = indexOf(self, props, list);
            if (canSet.has(set, props, self.algebra)) {
                items = self.serializeList(list);
                if (index === -1) {
                    self.updatedList(list, { data: setAdd(self, set, items, props, self.algebra) }, set);
                } else {
                    var sortedIndex = canSet.index(set, items, props, self.algebra);
                    if (sortedIndex !== undefined && sortedIndex !== index) {
                        var copy = items.slice(0);
                        if (index < sortedIndex) {
                            copy.splice(sortedIndex, 0, props);
                            copy.splice(index, 1);
                        } else {
                            copy.splice(index, 1);
                            copy.splice(sortedIndex, 0, props);
                        }
                        self.updatedList(list, { data: copy }, set);
                    }
                }
            } else if (index !== -1) {
                items = self.serializeList(list);
                items.splice(index, 1);
                self.updatedList(list, { data: items }, set);
            }
        });
    };
    var destroy = function (props) {
        var self = this;
        this.listStore.forEach(function (list, id) {
            var set = JSON.parse(id);
            var index = indexOf(self, props, list);
            if (index !== -1) {
                var items = self.serializeList(list);
                items.splice(index, 1);
                self.updatedList(list, { data: items }, set);
            }
        });
    };
});
/*can-connect@1.5.3#constructor/callbacks-once/callbacks-once*/
define('can-connect@1.5.3#constructor/callbacks-once/callbacks-once', function (require, exports, module) {
    var connect = require('can-connect');
    var sortedSetJSON = require('can-connect/helpers/sorted-set-json');
    var forEach = [].forEach;
    var callbacks = [
        'createdInstance',
        'updatedInstance',
        'destroyedInstance'
    ];
    var callbacksOnceBehavior = connect.behavior('constructor/callbacks-once', function (baseConnection) {
        var behavior = {};
        forEach.call(callbacks, function (name) {
            behavior[name] = function (instance, data) {
                var lastSerialized = this.getInstanceMetaData(instance, 'last-data-' + name);
                var serialize = sortedSetJSON(data);
                if (lastSerialized !== serialize) {
                    var result = baseConnection[name].apply(this, arguments);
                    this.addInstanceMetaData(instance, 'last-data-' + name, serialize);
                    return result;
                }
            };
        });
        return behavior;
    });
    module.exports = callbacksOnceBehavior;
});
/*ms-signalr-client@2.2.7#jquery.signalR*/
define('ms-signalr-client@2.2.7#jquery.signalR', [
    'module',
    '@loader',
    'require'
], function (module, loader, require) {
    loader.get('@@global-helpers').prepareGlobal({
        require: require,
        name: module.id,
        deps: []
    });
    var define = loader.global.define;
    var require = loader.global.require;
    var source = '/* jquery.signalR.core.js */\r\n/*global window:false */\r\n/*!\r\n * ASP.NET SignalR JavaScript Library v2.2.2-pre\r\n * http://signalr.net/\r\n *\r\n * Copyright (c) .NET Foundation. All rights reserved.\r\n * Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n *\r\n */\r\n\r\n/// <reference path="Scripts/jquery-1.6.4.js" />\r\n/// <reference path="jquery.signalR.version.js" />\r\n(function ($, window, undefined) {\r\n\r\n    var resources = {\r\n        nojQuery: "jQuery was not found. Please ensure jQuery is referenced before the SignalR client JavaScript file.",\r\n        noTransportOnInit: "No transport could be initialized successfully. Try specifying a different transport or none at all for auto initialization.",\r\n        errorOnNegotiate: "Error during negotiation request.",\r\n        stoppedWhileLoading: "The connection was stopped during page load.",\r\n        stoppedWhileNegotiating: "The connection was stopped during the negotiate request.",\r\n        errorParsingNegotiateResponse: "Error parsing negotiate response.",\r\n        errorDuringStartRequest: "Error during start request. Stopping the connection.",\r\n        stoppedDuringStartRequest: "The connection was stopped during the start request.",\r\n        errorParsingStartResponse: "Error parsing start response: \'{0}\'. Stopping the connection.",\r\n        invalidStartResponse: "Invalid start response: \'{0}\'. Stopping the connection.",\r\n        protocolIncompatible: "You are using a version of the client that isn\'t compatible with the server. Client version {0}, server version {1}.",\r\n        sendFailed: "Send failed.",\r\n        parseFailed: "Failed at parsing response: {0}",\r\n        longPollFailed: "Long polling request failed.",\r\n        eventSourceFailedToConnect: "EventSource failed to connect.",\r\n        eventSourceError: "Error raised by EventSource",\r\n        webSocketClosed: "WebSocket closed.",\r\n        pingServerFailedInvalidResponse: "Invalid ping response when pinging server: \'{0}\'.",\r\n        pingServerFailed: "Failed to ping server.",\r\n        pingServerFailedStatusCode: "Failed to ping server.  Server responded with status code {0}, stopping the connection.",\r\n        pingServerFailedParse: "Failed to parse ping server response, stopping the connection.",\r\n        noConnectionTransport: "Connection is in an invalid state, there is no transport active.",\r\n        webSocketsInvalidState: "The Web Socket transport is in an invalid state, transitioning into reconnecting.",\r\n        reconnectTimeout: "Couldn\'t reconnect within the configured timeout of {0} ms, disconnecting.",\r\n        reconnectWindowTimeout: "The client has been inactive since {0} and it has exceeded the inactivity timeout of {1} ms. Stopping the connection."\r\n    };\r\n\r\n    if (typeof ($) !== "function") {\r\n        // no jQuery!\r\n        throw new Error(resources.nojQuery);\r\n    }\r\n\r\n    var signalR,\r\n        _connection,\r\n        _pageLoaded = (window.document.readyState === "complete"),\r\n        _pageWindow = $(window),\r\n        _negotiateAbortText = "__Negotiate Aborted__",\r\n        events = {\r\n            onStart: "onStart",\r\n            onStarting: "onStarting",\r\n            onReceived: "onReceived",\r\n            onError: "onError",\r\n            onConnectionSlow: "onConnectionSlow",\r\n            onReconnecting: "onReconnecting",\r\n            onReconnect: "onReconnect",\r\n            onStateChanged: "onStateChanged",\r\n            onDisconnect: "onDisconnect"\r\n        },\r\n        ajaxDefaults = {\r\n            processData: true,\r\n            timeout: null,\r\n            async: true,\r\n            global: false,\r\n            cache: false\r\n        },\r\n        log = function (msg, logging) {\r\n            if (logging === false) {\r\n                return;\r\n            }\r\n            var m;\r\n            if (typeof (window.console) === "undefined") {\r\n                return;\r\n            }\r\n            m = "[" + new Date().toTimeString() + "] SignalR: " + msg;\r\n            if (window.console.debug) {\r\n                window.console.debug(m);\r\n            } else if (window.console.log) {\r\n                window.console.log(m);\r\n            }\r\n        },\r\n\r\n        changeState = function (connection, expectedState, newState) {\r\n            if (expectedState === connection.state) {\r\n                connection.state = newState;\r\n\r\n                $(connection).triggerHandler(events.onStateChanged, [{ oldState: expectedState, newState: newState }]);\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        },\r\n\r\n        isDisconnecting = function (connection) {\r\n            return connection.state === signalR.connectionState.disconnected;\r\n        },\r\n\r\n        supportsKeepAlive = function (connection) {\r\n            return connection._.keepAliveData.activated &&\r\n                   connection.transport.supportsKeepAlive(connection);\r\n        },\r\n\r\n        configureStopReconnectingTimeout = function (connection) {\r\n            var stopReconnectingTimeout,\r\n                onReconnectTimeout;\r\n\r\n            // Check if this connection has already been configured to stop reconnecting after a specified timeout.\r\n            // Without this check if a connection is stopped then started events will be bound multiple times.\r\n            if (!connection._.configuredStopReconnectingTimeout) {\r\n                onReconnectTimeout = function (connection) {\r\n                    var message = signalR._.format(signalR.resources.reconnectTimeout, connection.disconnectTimeout);\r\n                    connection.log(message);\r\n                    $(connection).triggerHandler(events.onError, [signalR._.error(message, /* source */ "TimeoutException")]);\r\n                    connection.stop(/* async */ false, /* notifyServer */ false);\r\n                };\r\n\r\n                connection.reconnecting(function () {\r\n                    var connection = this;\r\n\r\n                    // Guard against state changing in a previous user defined even handler\r\n                    if (connection.state === signalR.connectionState.reconnecting) {\r\n                        stopReconnectingTimeout = window.setTimeout(function () { onReconnectTimeout(connection); }, connection.disconnectTimeout);\r\n                    }\r\n                });\r\n\r\n                connection.stateChanged(function (data) {\r\n                    if (data.oldState === signalR.connectionState.reconnecting) {\r\n                        // Clear the pending reconnect timeout check\r\n                        window.clearTimeout(stopReconnectingTimeout);\r\n                    }\r\n                });\r\n\r\n                connection._.configuredStopReconnectingTimeout = true;\r\n            }\r\n        };\r\n\r\n    signalR = function (url, qs, logging) {\r\n        /// <summary>Creates a new SignalR connection for the given url</summary>\r\n        /// <param name="url" type="String">The URL of the long polling endpoint</param>\r\n        /// <param name="qs" type="Object">\r\n        ///     [Optional] Custom querystring parameters to add to the connection URL.\r\n        ///     If an object, every non-function member will be added to the querystring.\r\n        ///     If a string, it\'s added to the QS as specified.\r\n        /// </param>\r\n        /// <param name="logging" type="Boolean">\r\n        ///     [Optional] A flag indicating whether connection logging is enabled to the browser\r\n        ///     console/log. Defaults to false.\r\n        /// </param>\r\n\r\n        return new signalR.fn.init(url, qs, logging);\r\n    };\r\n\r\n    signalR._ = {\r\n        defaultContentType: "application/x-www-form-urlencoded; charset=UTF-8",\r\n\r\n        ieVersion: (function () {\r\n            var version,\r\n                matches;\r\n\r\n            if (window.navigator.appName === \'Microsoft Internet Explorer\') {\r\n                // Check if the user agent has the pattern "MSIE (one or more numbers).(one or more numbers)";\r\n                matches = /MSIE ([0-9]+\\.[0-9]+)/.exec(window.navigator.userAgent);\r\n\r\n                if (matches) {\r\n                    version = window.parseFloat(matches[1]);\r\n                }\r\n            }\r\n\r\n            // undefined value means not IE\r\n            return version;\r\n        })(),\r\n\r\n        error: function (message, source, context) {\r\n            var e = new Error(message);\r\n            e.source = source;\r\n\r\n            if (typeof context !== "undefined") {\r\n                e.context = context;\r\n            }\r\n\r\n            return e;\r\n        },\r\n\r\n        transportError: function (message, transport, source, context) {\r\n            var e = this.error(message, source, context);\r\n            e.transport = transport ? transport.name : undefined;\r\n            return e;\r\n        },\r\n\r\n        format: function () {\r\n            /// <summary>Usage: format("Hi {0}, you are {1}!", "Foo", 100) </summary>\r\n            var s = arguments[0];\r\n            for (var i = 0; i < arguments.length - 1; i++) {\r\n                s = s.replace("{" + i + "}", arguments[i + 1]);\r\n            }\r\n            return s;\r\n        },\r\n\r\n        firefoxMajorVersion: function (userAgent) {\r\n            // Firefox user agents: http://useragentstring.com/pages/Firefox/\r\n            var matches = userAgent.match(/Firefox\\/(\\d+)/);\r\n            if (!matches || !matches.length || matches.length < 2) {\r\n                return 0;\r\n            }\r\n            return parseInt(matches[1], 10 /* radix */);\r\n        },\r\n\r\n        configurePingInterval: function (connection) {\r\n            var config = connection._.config,\r\n                onFail = function (error) {\r\n                    $(connection).triggerHandler(events.onError, [error]);\r\n                };\r\n\r\n            if (config && !connection._.pingIntervalId && config.pingInterval) {\r\n                connection._.pingIntervalId = window.setInterval(function () {\r\n                    signalR.transports._logic.pingServer(connection).fail(onFail);\r\n                }, config.pingInterval);\r\n            }\r\n        }\r\n    };\r\n\r\n    signalR.events = events;\r\n\r\n    signalR.resources = resources;\r\n\r\n    signalR.ajaxDefaults = ajaxDefaults;\r\n\r\n    signalR.changeState = changeState;\r\n\r\n    signalR.isDisconnecting = isDisconnecting;\r\n\r\n    signalR.connectionState = {\r\n        connecting: 0,\r\n        connected: 1,\r\n        reconnecting: 2,\r\n        disconnected: 4\r\n    };\r\n\r\n    signalR.hub = {\r\n        start: function () {\r\n            // This will get replaced with the real hub connection start method when hubs is referenced correctly\r\n            throw new Error("SignalR: Error loading hubs. Ensure your hubs reference is correct, e.g. <script src=\'/signalr/js\'></script>.");\r\n        }\r\n    };\r\n\r\n    // .on() was added in version 1.7.0, .load() was removed in version 3.0.0 so we fallback to .load() if .on() does\r\n    // not exist to not break existing applications\r\n    if (typeof _pageWindow.on == "function") {\r\n        _pageWindow.on("load", function () { _pageLoaded = true; });\r\n    }\r\n    else {\r\n        _pageWindow.load(function () { _pageLoaded = true; });\r\n    }\r\n\r\n    function validateTransport(requestedTransport, connection) {\r\n        /// <summary>Validates the requested transport by cross checking it with the pre-defined signalR.transports</summary>\r\n        /// <param name="requestedTransport" type="Object">The designated transports that the user has specified.</param>\r\n        /// <param name="connection" type="signalR">The connection that will be using the requested transports.  Used for logging purposes.</param>\r\n        /// <returns type="Object" />\r\n\r\n        if ($.isArray(requestedTransport)) {\r\n            // Go through transport array and remove an "invalid" tranports\r\n            for (var i = requestedTransport.length - 1; i >= 0; i--) {\r\n                var transport = requestedTransport[i];\r\n                if ($.type(transport) !== "string" || !signalR.transports[transport]) {\r\n                    connection.log("Invalid transport: " + transport + ", removing it from the transports list.");\r\n                    requestedTransport.splice(i, 1);\r\n                }\r\n            }\r\n\r\n            // Verify we still have transports left, if we dont then we have invalid transports\r\n            if (requestedTransport.length === 0) {\r\n                connection.log("No transports remain within the specified transport array.");\r\n                requestedTransport = null;\r\n            }\r\n        } else if (!signalR.transports[requestedTransport] && requestedTransport !== "auto") {\r\n            connection.log("Invalid transport: " + requestedTransport.toString() + ".");\r\n            requestedTransport = null;\r\n        } else if (requestedTransport === "auto" && signalR._.ieVersion <= 8) {\r\n            // If we\'re doing an auto transport and we\'re IE8 then force longPolling, #1764\r\n            return ["longPolling"];\r\n\r\n        }\r\n\r\n        return requestedTransport;\r\n    }\r\n\r\n    function getDefaultPort(protocol) {\r\n        if (protocol === "http:") {\r\n            return 80;\r\n        } else if (protocol === "https:") {\r\n            return 443;\r\n        }\r\n    }\r\n\r\n    function addDefaultPort(protocol, url) {\r\n        // Remove ports  from url.  We have to check if there\'s a / or end of line\r\n        // following the port in order to avoid removing ports such as 8080.\r\n        if (url.match(/:\\d+$/)) {\r\n            return url;\r\n        } else {\r\n            return url + ":" + getDefaultPort(protocol);\r\n        }\r\n    }\r\n\r\n    function ConnectingMessageBuffer(connection, drainCallback) {\r\n        var that = this,\r\n            buffer = [];\r\n\r\n        that.tryBuffer = function (message) {\r\n            if (connection.state === $.signalR.connectionState.connecting) {\r\n                buffer.push(message);\r\n\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        };\r\n\r\n        that.drain = function () {\r\n            // Ensure that the connection is connected when we drain (do not want to drain while a connection is not active)\r\n            if (connection.state === $.signalR.connectionState.connected) {\r\n                while (buffer.length > 0) {\r\n                    drainCallback(buffer.shift());\r\n                }\r\n            }\r\n        };\r\n\r\n        that.clear = function () {\r\n            buffer = [];\r\n        };\r\n    }\r\n\r\n    signalR.fn = signalR.prototype = {\r\n        init: function (url, qs, logging) {\r\n            var $connection = $(this);\r\n\r\n            this.url = url;\r\n            this.qs = qs;\r\n            this.lastError = null;\r\n            this._ = {\r\n                keepAliveData: {},\r\n                connectingMessageBuffer: new ConnectingMessageBuffer(this, function (message) {\r\n                    $connection.triggerHandler(events.onReceived, [message]);\r\n                }),\r\n                lastMessageAt: new Date().getTime(),\r\n                lastActiveAt: new Date().getTime(),\r\n                beatInterval: 5000, // Default value, will only be overridden if keep alive is enabled,\r\n                beatHandle: null,\r\n                totalTransportConnectTimeout: 0 // This will be the sum of the TransportConnectTimeout sent in response to negotiate and connection.transportConnectTimeout\r\n            };\r\n            if (typeof (logging) === "boolean") {\r\n                this.logging = logging;\r\n            }\r\n        },\r\n\r\n        _parseResponse: function (response) {\r\n            var that = this;\r\n\r\n            if (!response) {\r\n                return response;\r\n            } else if (typeof response === "string") {\r\n                return that.json.parse(response);\r\n            } else {\r\n                return response;\r\n            }\r\n        },\r\n\r\n        _originalJson: window.JSON,\r\n\r\n        json: window.JSON,\r\n\r\n        isCrossDomain: function (url, against) {\r\n            /// <summary>Checks if url is cross domain</summary>\r\n            /// <param name="url" type="String">The base URL</param>\r\n            /// <param name="against" type="Object">\r\n            ///     An optional argument to compare the URL against, if not specified it will be set to window.location.\r\n            ///     If specified it must contain a protocol and a host property.\r\n            /// </param>\r\n            var link;\r\n\r\n            url = $.trim(url);\r\n\r\n            against = against || window.location;\r\n\r\n            if (url.indexOf("http") !== 0) {\r\n                return false;\r\n            }\r\n\r\n            // Create an anchor tag.\r\n            link = window.document.createElement("a");\r\n            link.href = url;\r\n\r\n            // When checking for cross domain we have to special case port 80 because the window.location will remove the\r\n            return link.protocol + addDefaultPort(link.protocol, link.host) !== against.protocol + addDefaultPort(against.protocol, against.host);\r\n        },\r\n\r\n        ajaxDataType: "text",\r\n\r\n        contentType: "application/json; charset=UTF-8",\r\n\r\n        logging: false,\r\n\r\n        state: signalR.connectionState.disconnected,\r\n\r\n        clientProtocol: "1.5",\r\n\r\n        reconnectDelay: 2000,\r\n\r\n        transportConnectTimeout: 0,\r\n\r\n        disconnectTimeout: 30000, // This should be set by the server in response to the negotiate request (30s default)\r\n\r\n        reconnectWindow: 30000, // This should be set by the server in response to the negotiate request\r\n\r\n        keepAliveWarnAt: 2 / 3, // Warn user of slow connection if we breach the X% mark of the keep alive timeout\r\n\r\n        start: function (options, callback) {\r\n            /// <summary>Starts the connection</summary>\r\n            /// <param name="options" type="Object">Options map</param>\r\n            /// <param name="callback" type="Function">A callback function to execute when the connection has started</param>\r\n            var connection = this,\r\n                config = {\r\n                    pingInterval: 300000,\r\n                    waitForPageLoad: true,\r\n                    transport: "auto",\r\n                    jsonp: false\r\n                },\r\n                initialize,\r\n                deferred = connection._deferral || $.Deferred(), // Check to see if there is a pre-existing deferral that\'s being built on, if so we want to keep using it\r\n                parser = window.document.createElement("a");\r\n\r\n            connection.lastError = null;\r\n\r\n            // Persist the deferral so that if start is called multiple times the same deferral is used.\r\n            connection._deferral = deferred;\r\n\r\n            if (!connection.json) {\r\n                // no JSON!\r\n                throw new Error("SignalR: No JSON parser found. Please ensure json2.js is referenced before the SignalR.js file if you need to support clients without native JSON parsing support, e.g. IE<8.");\r\n            }\r\n\r\n            if ($.type(options) === "function") {\r\n                // Support calling with single callback parameter\r\n                callback = options;\r\n            } else if ($.type(options) === "object") {\r\n                $.extend(config, options);\r\n                if ($.type(config.callback) === "function") {\r\n                    callback = config.callback;\r\n                }\r\n            }\r\n\r\n            config.transport = validateTransport(config.transport, connection);\r\n\r\n            // If the transport is invalid throw an error and abort start\r\n            if (!config.transport) {\r\n                throw new Error("SignalR: Invalid transport(s) specified, aborting start.");\r\n            }\r\n\r\n            connection._.config = config;\r\n\r\n            // Check to see if start is being called prior to page load\r\n            // If waitForPageLoad is true we then want to re-direct function call to the window load event\r\n            if (!_pageLoaded && config.waitForPageLoad === true) {\r\n                connection._.deferredStartHandler = function () {\r\n                    connection.start(options, callback);\r\n                };\r\n                _pageWindow.bind("load", connection._.deferredStartHandler);\r\n\r\n                return deferred.promise();\r\n            }\r\n\r\n            // If we\'re already connecting just return the same deferral as the original connection start\r\n            if (connection.state === signalR.connectionState.connecting) {\r\n                return deferred.promise();\r\n            } else if (changeState(connection,\r\n                            signalR.connectionState.disconnected,\r\n                            signalR.connectionState.connecting) === false) {\r\n                // We\'re not connecting so try and transition into connecting.\r\n                // If we fail to transition then we\'re either in connected or reconnecting.\r\n\r\n                deferred.resolve(connection);\r\n                return deferred.promise();\r\n            }\r\n\r\n            configureStopReconnectingTimeout(connection);\r\n\r\n            // Resolve the full url\r\n            parser.href = connection.url;\r\n            if (!parser.protocol || parser.protocol === ":") {\r\n                connection.protocol = window.document.location.protocol;\r\n                connection.host = parser.host || window.document.location.host;\r\n            } else {\r\n                connection.protocol = parser.protocol;\r\n                connection.host = parser.host;\r\n            }\r\n\r\n            connection.baseUrl = connection.protocol + "//" + connection.host;\r\n\r\n            // Set the websocket protocol\r\n            connection.wsProtocol = connection.protocol === "https:" ? "wss://" : "ws://";\r\n\r\n            // If jsonp with no/auto transport is specified, then set the transport to long polling\r\n            // since that is the only transport for which jsonp really makes sense.\r\n            // Some developers might actually choose to specify jsonp for same origin requests\r\n            // as demonstrated by Issue #623.\r\n            if (config.transport === "auto" && config.jsonp === true) {\r\n                config.transport = "longPolling";\r\n            }\r\n\r\n            // If the url is protocol relative, prepend the current windows protocol to the url.\r\n            if (connection.url.indexOf("//") === 0) {\r\n                connection.url = window.location.protocol + connection.url;\r\n                connection.log("Protocol relative URL detected, normalizing it to \'" + connection.url + "\'.");\r\n            }\r\n\r\n            if (this.isCrossDomain(connection.url)) {\r\n                connection.log("Auto detected cross domain url.");\r\n\r\n                if (config.transport === "auto") {\r\n                    // TODO: Support XDM with foreverFrame\r\n                    config.transport = ["webSockets", "serverSentEvents", "longPolling"];\r\n                }\r\n\r\n                if (typeof (config.withCredentials) === "undefined") {\r\n                    config.withCredentials = true;\r\n                }\r\n\r\n                // Determine if jsonp is the only choice for negotiation, ajaxSend and ajaxAbort.\r\n                // i.e. if the browser doesn\'t supports CORS\r\n                // If it is, ignore any preference to the contrary, and switch to jsonp.\r\n                if (!config.jsonp) {\r\n                    config.jsonp = !$.support.cors;\r\n\r\n                    if (config.jsonp) {\r\n                        connection.log("Using jsonp because this browser doesn\'t support CORS.");\r\n                    }\r\n                }\r\n\r\n                connection.contentType = signalR._.defaultContentType;\r\n            }\r\n\r\n            connection.withCredentials = config.withCredentials;\r\n\r\n            connection.ajaxDataType = config.jsonp ? "jsonp" : "text";\r\n\r\n            $(connection).bind(events.onStart, function (e, data) {\r\n                if ($.type(callback) === "function") {\r\n                    callback.call(connection);\r\n                }\r\n                deferred.resolve(connection);\r\n            });\r\n\r\n            connection._.initHandler = signalR.transports._logic.initHandler(connection);\r\n\r\n            initialize = function (transports, index) {\r\n                var noTransportError = signalR._.error(resources.noTransportOnInit);\r\n\r\n                index = index || 0;\r\n                if (index >= transports.length) {\r\n                    if (index === 0) {\r\n                        connection.log("No transports supported by the server were selected.");\r\n                    } else if (index === 1) {\r\n                        connection.log("No fallback transports were selected.");\r\n                    } else {\r\n                        connection.log("Fallback transports exhausted.");\r\n                    }\r\n\r\n                    // No transport initialized successfully\r\n                    $(connection).triggerHandler(events.onError, [noTransportError]);\r\n                    deferred.reject(noTransportError);\r\n                    // Stop the connection if it has connected and move it into the disconnected state\r\n                    connection.stop();\r\n                    return;\r\n                }\r\n\r\n                // The connection was aborted\r\n                if (connection.state === signalR.connectionState.disconnected) {\r\n                    return;\r\n                }\r\n\r\n                var transportName = transports[index],\r\n                    transport = signalR.transports[transportName],\r\n                    onFallback = function () {\r\n                        initialize(transports, index + 1);\r\n                    };\r\n\r\n                connection.transport = transport;\r\n\r\n                try {\r\n                    connection._.initHandler.start(transport, function () { // success\r\n                        // Firefox 11+ doesn\'t allow sync XHR withCredentials: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest#withCredentials\r\n                        var isFirefox11OrGreater = signalR._.firefoxMajorVersion(window.navigator.userAgent) >= 11,\r\n                            asyncAbort = !!connection.withCredentials && isFirefox11OrGreater;\r\n\r\n                        connection.log("The start request succeeded. Transitioning to the connected state.");\r\n\r\n                        if (supportsKeepAlive(connection)) {\r\n                            signalR.transports._logic.monitorKeepAlive(connection);\r\n                        }\r\n\r\n                        signalR.transports._logic.startHeartbeat(connection);\r\n\r\n                        // Used to ensure low activity clients maintain their authentication.\r\n                        // Must be configured once a transport has been decided to perform valid ping requests.\r\n                        signalR._.configurePingInterval(connection);\r\n\r\n                        if (!changeState(connection,\r\n                                            signalR.connectionState.connecting,\r\n                                            signalR.connectionState.connected)) {\r\n                            connection.log("WARNING! The connection was not in the connecting state.");\r\n                        }\r\n\r\n                        // Drain any incoming buffered messages (messages that came in prior to connect)\r\n                        connection._.connectingMessageBuffer.drain();\r\n\r\n                        $(connection).triggerHandler(events.onStart);\r\n\r\n                        // wire the stop handler for when the user leaves the page\r\n                        _pageWindow.bind("unload", function () {\r\n                            connection.log("Window unloading, stopping the connection.");\r\n\r\n                            connection.stop(asyncAbort);\r\n                        });\r\n\r\n                        if (isFirefox11OrGreater) {\r\n                            // Firefox does not fire cross-domain XHRs in the normal unload handler on tab close.\r\n                            // #2400\r\n                            _pageWindow.bind("beforeunload", function () {\r\n                                // If connection.stop() runs runs in beforeunload and fails, it will also fail\r\n                                // in unload unless connection.stop() runs after a timeout.\r\n                                window.setTimeout(function () {\r\n                                    connection.stop(asyncAbort);\r\n                                }, 0);\r\n                            });\r\n                        }\r\n                    }, onFallback);\r\n                }\r\n                catch (error) {\r\n                    connection.log(transport.name + " transport threw \'" + error.message + "\' when attempting to start.");\r\n                    onFallback();\r\n                }\r\n            };\r\n\r\n            var url = connection.url + "/negotiate",\r\n                onFailed = function (error, connection) {\r\n                    var err = signalR._.error(resources.errorOnNegotiate, error, connection._.negotiateRequest);\r\n\r\n                    $(connection).triggerHandler(events.onError, err);\r\n                    deferred.reject(err);\r\n                    // Stop the connection if negotiate failed\r\n                    connection.stop();\r\n                };\r\n\r\n            $(connection).triggerHandler(events.onStarting);\r\n\r\n            url = signalR.transports._logic.prepareQueryString(connection, url);\r\n\r\n            connection.log("Negotiating with \'" + url + "\'.");\r\n\r\n            // Save the ajax negotiate request object so we can abort it if stop is called while the request is in flight.\r\n            connection._.negotiateRequest = signalR.transports._logic.ajax(connection, {\r\n                url: url,\r\n                error: function (error, statusText) {\r\n                    // We don\'t want to cause any errors if we\'re aborting our own negotiate request.\r\n                    if (statusText !== _negotiateAbortText) {\r\n                        onFailed(error, connection);\r\n                    } else {\r\n                        // This rejection will noop if the deferred has already been resolved or rejected.\r\n                        deferred.reject(signalR._.error(resources.stoppedWhileNegotiating, null /* error */, connection._.negotiateRequest));\r\n                    }\r\n                },\r\n                success: function (result) {\r\n                    var res,\r\n                        keepAliveData,\r\n                        protocolError,\r\n                        transports = [],\r\n                        supportedTransports = [];\r\n\r\n                    try {\r\n                        res = connection._parseResponse(result);\r\n                    } catch (error) {\r\n                        onFailed(signalR._.error(resources.errorParsingNegotiateResponse, error), connection);\r\n                        return;\r\n                    }\r\n\r\n                    keepAliveData = connection._.keepAliveData;\r\n                    connection.appRelativeUrl = res.Url;\r\n                    connection.id = res.ConnectionId;\r\n                    connection.token = res.ConnectionToken;\r\n                    connection.webSocketServerUrl = res.WebSocketServerUrl;\r\n\r\n                    // The long poll timeout is the ConnectionTimeout plus 10 seconds\r\n                    connection._.pollTimeout = res.ConnectionTimeout * 1000 + 10000; // in ms\r\n\r\n                    // Once the server has labeled the PersistentConnection as Disconnected, we should stop attempting to reconnect\r\n                    // after res.DisconnectTimeout seconds.\r\n                    connection.disconnectTimeout = res.DisconnectTimeout * 1000; // in ms\r\n\r\n                    // Add the TransportConnectTimeout from the response to the transportConnectTimeout from the client to calculate the total timeout\r\n                    connection._.totalTransportConnectTimeout = connection.transportConnectTimeout + res.TransportConnectTimeout * 1000;\r\n\r\n                    // If we have a keep alive\r\n                    if (res.KeepAliveTimeout) {\r\n                        // Register the keep alive data as activated\r\n                        keepAliveData.activated = true;\r\n\r\n                        // Timeout to designate when to force the connection into reconnecting converted to milliseconds\r\n                        keepAliveData.timeout = res.KeepAliveTimeout * 1000;\r\n\r\n                        // Timeout to designate when to warn the developer that the connection may be dead or is not responding.\r\n                        keepAliveData.timeoutWarning = keepAliveData.timeout * connection.keepAliveWarnAt;\r\n\r\n                        // Instantiate the frequency in which we check the keep alive.  It must be short in order to not miss/pick up any changes\r\n                        connection._.beatInterval = (keepAliveData.timeout - keepAliveData.timeoutWarning) / 3;\r\n                    } else {\r\n                        keepAliveData.activated = false;\r\n                    }\r\n\r\n                    connection.reconnectWindow = connection.disconnectTimeout + (keepAliveData.timeout || 0);\r\n\r\n                    if (!res.ProtocolVersion || res.ProtocolVersion !== connection.clientProtocol) {\r\n                        protocolError = signalR._.error(signalR._.format(resources.protocolIncompatible, connection.clientProtocol, res.ProtocolVersion));\r\n                        $(connection).triggerHandler(events.onError, [protocolError]);\r\n                        deferred.reject(protocolError);\r\n\r\n                        return;\r\n                    }\r\n\r\n                    $.each(signalR.transports, function (key) {\r\n                        if ((key.indexOf("_") === 0) || (key === "webSockets" && !res.TryWebSockets)) {\r\n                            return true;\r\n                        }\r\n                        supportedTransports.push(key);\r\n                    });\r\n\r\n                    if ($.isArray(config.transport)) {\r\n                        $.each(config.transport, function (_, transport) {\r\n                            if ($.inArray(transport, supportedTransports) >= 0) {\r\n                                transports.push(transport);\r\n                            }\r\n                        });\r\n                    } else if (config.transport === "auto") {\r\n                        transports = supportedTransports;\r\n                    } else if ($.inArray(config.transport, supportedTransports) >= 0) {\r\n                        transports.push(config.transport);\r\n                    }\r\n\r\n                    initialize(transports);\r\n                }\r\n            });\r\n\r\n            return deferred.promise();\r\n        },\r\n\r\n        starting: function (callback) {\r\n            /// <summary>Adds a callback that will be invoked before anything is sent over the connection</summary>\r\n            /// <param name="callback" type="Function">A callback function to execute before the connection is fully instantiated.</param>\r\n            /// <returns type="signalR" />\r\n            var connection = this;\r\n            $(connection).bind(events.onStarting, function (e, data) {\r\n                callback.call(connection);\r\n            });\r\n            return connection;\r\n        },\r\n\r\n        send: function (data) {\r\n            /// <summary>Sends data over the connection</summary>\r\n            /// <param name="data" type="String">The data to send over the connection</param>\r\n            /// <returns type="signalR" />\r\n            var connection = this;\r\n\r\n            if (connection.state === signalR.connectionState.disconnected) {\r\n                // Connection hasn\'t been started yet\r\n                throw new Error("SignalR: Connection must be started before data can be sent. Call .start() before .send()");\r\n            }\r\n\r\n            if (connection.state === signalR.connectionState.connecting) {\r\n                // Connection hasn\'t been started yet\r\n                throw new Error("SignalR: Connection has not been fully initialized. Use .start().done() or .start().fail() to run logic after the connection has started.");\r\n            }\r\n\r\n            connection.transport.send(connection, data);\r\n            // REVIEW: Should we return deferred here?\r\n            return connection;\r\n        },\r\n\r\n        received: function (callback) {\r\n            /// <summary>Adds a callback that will be invoked after anything is received over the connection</summary>\r\n            /// <param name="callback" type="Function">A callback function to execute when any data is received on the connection</param>\r\n            /// <returns type="signalR" />\r\n            var connection = this;\r\n            $(connection).bind(events.onReceived, function (e, data) {\r\n                callback.call(connection, data);\r\n            });\r\n            return connection;\r\n        },\r\n\r\n        stateChanged: function (callback) {\r\n            /// <summary>Adds a callback that will be invoked when the connection state changes</summary>\r\n            /// <param name="callback" type="Function">A callback function to execute when the connection state changes</param>\r\n            /// <returns type="signalR" />\r\n            var connection = this;\r\n            $(connection).bind(events.onStateChanged, function (e, data) {\r\n                callback.call(connection, data);\r\n            });\r\n            return connection;\r\n        },\r\n\r\n        error: function (callback) {\r\n            /// <summary>Adds a callback that will be invoked after an error occurs with the connection</summary>\r\n            /// <param name="callback" type="Function">A callback function to execute when an error occurs on the connection</param>\r\n            /// <returns type="signalR" />\r\n            var connection = this;\r\n            $(connection).bind(events.onError, function (e, errorData, sendData) {\r\n                connection.lastError = errorData;\r\n                // In practice \'errorData\' is the SignalR built error object.\r\n                // In practice \'sendData\' is undefined for all error events except those triggered by\r\n                // \'ajaxSend\' and \'webSockets.send\'.\'sendData\' is the original send payload.\r\n                callback.call(connection, errorData, sendData);\r\n            });\r\n            return connection;\r\n        },\r\n\r\n        disconnected: function (callback) {\r\n            /// <summary>Adds a callback that will be invoked when the client disconnects</summary>\r\n            /// <param name="callback" type="Function">A callback function to execute when the connection is broken</param>\r\n            /// <returns type="signalR" />\r\n            var connection = this;\r\n            $(connection).bind(events.onDisconnect, function (e, data) {\r\n                callback.call(connection);\r\n            });\r\n            return connection;\r\n        },\r\n\r\n        connectionSlow: function (callback) {\r\n            /// <summary>Adds a callback that will be invoked when the client detects a slow connection</summary>\r\n            /// <param name="callback" type="Function">A callback function to execute when the connection is slow</param>\r\n            /// <returns type="signalR" />\r\n            var connection = this;\r\n            $(connection).bind(events.onConnectionSlow, function (e, data) {\r\n                callback.call(connection);\r\n            });\r\n\r\n            return connection;\r\n        },\r\n\r\n        reconnecting: function (callback) {\r\n            /// <summary>Adds a callback that will be invoked when the underlying transport begins reconnecting</summary>\r\n            /// <param name="callback" type="Function">A callback function to execute when the connection enters a reconnecting state</param>\r\n            /// <returns type="signalR" />\r\n            var connection = this;\r\n            $(connection).bind(events.onReconnecting, function (e, data) {\r\n                callback.call(connection);\r\n            });\r\n            return connection;\r\n        },\r\n\r\n        reconnected: function (callback) {\r\n            /// <summary>Adds a callback that will be invoked when the underlying transport reconnects</summary>\r\n            /// <param name="callback" type="Function">A callback function to execute when the connection is restored</param>\r\n            /// <returns type="signalR" />\r\n            var connection = this;\r\n            $(connection).bind(events.onReconnect, function (e, data) {\r\n                callback.call(connection);\r\n            });\r\n            return connection;\r\n        },\r\n\r\n        stop: function (async, notifyServer) {\r\n            /// <summary>Stops listening</summary>\r\n            /// <param name="async" type="Boolean">Whether or not to asynchronously abort the connection</param>\r\n            /// <param name="notifyServer" type="Boolean">Whether we want to notify the server that we are aborting the connection</param>\r\n            /// <returns type="signalR" />\r\n            var connection = this,\r\n                // Save deferral because this is always cleaned up\r\n                deferral = connection._deferral;\r\n\r\n            // Verify that we\'ve bound a load event.\r\n            if (connection._.deferredStartHandler) {\r\n                // Unbind the event.\r\n                _pageWindow.unbind("load", connection._.deferredStartHandler);\r\n            }\r\n\r\n            // Always clean up private non-timeout based state.\r\n            delete connection._.config;\r\n            delete connection._.deferredStartHandler;\r\n\r\n            // This needs to be checked despite the connection state because a connection start can be deferred until page load.\r\n            // If we\'ve deferred the start due to a page load we need to unbind the "onLoad" -> start event.\r\n            if (!_pageLoaded && (!connection._.config || connection._.config.waitForPageLoad === true)) {\r\n                connection.log("Stopping connection prior to negotiate.");\r\n\r\n                // If we have a deferral we should reject it\r\n                if (deferral) {\r\n                    deferral.reject(signalR._.error(resources.stoppedWhileLoading));\r\n                }\r\n\r\n                // Short-circuit because the start has not been fully started.\r\n                return;\r\n            }\r\n\r\n            if (connection.state === signalR.connectionState.disconnected) {\r\n                return;\r\n            }\r\n\r\n            connection.log("Stopping connection.");\r\n\r\n            // Clear this no matter what\r\n            window.clearTimeout(connection._.beatHandle);\r\n            window.clearInterval(connection._.pingIntervalId);\r\n\r\n            if (connection.transport) {\r\n                connection.transport.stop(connection);\r\n\r\n                if (notifyServer !== false) {\r\n                    connection.transport.abort(connection, async);\r\n                }\r\n\r\n                if (supportsKeepAlive(connection)) {\r\n                    signalR.transports._logic.stopMonitoringKeepAlive(connection);\r\n                }\r\n\r\n                connection.transport = null;\r\n            }\r\n\r\n            if (connection._.negotiateRequest) {\r\n                // If the negotiation request has already completed this will noop.\r\n                connection._.negotiateRequest.abort(_negotiateAbortText);\r\n                delete connection._.negotiateRequest;\r\n            }\r\n\r\n            // Ensure that initHandler.stop() is called before connection._deferral is deleted\r\n            if (connection._.initHandler) {\r\n                connection._.initHandler.stop();\r\n            }\r\n\r\n            delete connection._deferral;\r\n            delete connection.messageId;\r\n            delete connection.groupsToken;\r\n            delete connection.id;\r\n            delete connection._.pingIntervalId;\r\n            delete connection._.lastMessageAt;\r\n            delete connection._.lastActiveAt;\r\n\r\n            // Clear out our message buffer\r\n            connection._.connectingMessageBuffer.clear();\r\n            \r\n            // Clean up this event\r\n            $(connection).unbind(events.onStart);\r\n\r\n            // Trigger the disconnect event\r\n            changeState(connection, connection.state, signalR.connectionState.disconnected);\r\n            $(connection).triggerHandler(events.onDisconnect);\r\n\r\n            return connection;\r\n        },\r\n\r\n        log: function (msg) {\r\n            log(msg, this.logging);\r\n        }\r\n    };\r\n\r\n    signalR.fn.init.prototype = signalR.fn;\r\n\r\n    signalR.noConflict = function () {\r\n        /// <summary>Reinstates the original value of $.connection and returns the signalR object for manual assignment</summary>\r\n        /// <returns type="signalR" />\r\n        if ($.connection === signalR) {\r\n            $.connection = _connection;\r\n        }\r\n        return signalR;\r\n    };\r\n\r\n    if ($.connection) {\r\n        _connection = $.connection;\r\n    }\r\n\r\n    $.connection = $.signalR = signalR;\r\n\r\n}(window.jQuery, window));\r\n/* jquery.signalR.transports.common.js */\r\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\n/*global window:false */\r\n/// <reference path="jquery.signalR.core.js" />\r\n\r\n(function ($, window, undefined) {\r\n\r\n    var signalR = $.signalR,\r\n        events = $.signalR.events,\r\n        changeState = $.signalR.changeState,\r\n        startAbortText = "__Start Aborted__",\r\n        transportLogic;\r\n\r\n    signalR.transports = {};\r\n\r\n    function beat(connection) {\r\n        if (connection._.keepAliveData.monitoring) {\r\n            checkIfAlive(connection);\r\n        }\r\n\r\n        // Ensure that we successfully marked active before continuing the heartbeat.\r\n        if (transportLogic.markActive(connection)) {\r\n            connection._.beatHandle = window.setTimeout(function () {\r\n                beat(connection);\r\n            }, connection._.beatInterval);\r\n        }\r\n    }\r\n\r\n    function checkIfAlive(connection) {\r\n        var keepAliveData = connection._.keepAliveData,\r\n            timeElapsed;\r\n\r\n        // Only check if we\'re connected\r\n        if (connection.state === signalR.connectionState.connected) {\r\n            timeElapsed = new Date().getTime() - connection._.lastMessageAt;\r\n\r\n            // Check if the keep alive has completely timed out\r\n            if (timeElapsed >= keepAliveData.timeout) {\r\n                connection.log("Keep alive timed out.  Notifying transport that connection has been lost.");\r\n\r\n                // Notify transport that the connection has been lost\r\n                connection.transport.lostConnection(connection);\r\n            } else if (timeElapsed >= keepAliveData.timeoutWarning) {\r\n                // This is to assure that the user only gets a single warning\r\n                if (!keepAliveData.userNotified) {\r\n                    connection.log("Keep alive has been missed, connection may be dead/slow.");\r\n                    $(connection).triggerHandler(events.onConnectionSlow);\r\n                    keepAliveData.userNotified = true;\r\n                }\r\n            } else {\r\n                keepAliveData.userNotified = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getAjaxUrl(connection, path) {\r\n        var url = connection.url + path;\r\n\r\n        if (connection.transport) {\r\n            url += "?transport=" + connection.transport.name;\r\n        }\r\n\r\n        return transportLogic.prepareQueryString(connection, url);\r\n    }\r\n\r\n    function InitHandler(connection) {\r\n        this.connection = connection;\r\n\r\n        this.startRequested = false;\r\n        this.startCompleted = false;\r\n        this.connectionStopped = false;\r\n    }\r\n\r\n    InitHandler.prototype = {\r\n        start: function (transport, onSuccess, onFallback) {\r\n            var that = this,\r\n                connection = that.connection,\r\n                failCalled = false;\r\n\r\n            if (that.startRequested || that.connectionStopped) {\r\n                connection.log("WARNING! " + transport.name + " transport cannot be started. Initialization ongoing or completed.");\r\n                return;\r\n            }\r\n\r\n            connection.log(transport.name + " transport starting.");\r\n\r\n            transport.start(connection, function () {\r\n                if (!failCalled) {\r\n                    that.initReceived(transport, onSuccess);\r\n                }\r\n            }, function (error) {\r\n                // Don\'t allow the same transport to cause onFallback to be called twice\r\n                if (!failCalled) {\r\n                    failCalled = true;\r\n                    that.transportFailed(transport, error, onFallback);\r\n                }\r\n\r\n                // Returns true if the transport should stop;\r\n                // false if it should attempt to reconnect\r\n                return !that.startCompleted || that.connectionStopped;\r\n            });\r\n\r\n            that.transportTimeoutHandle = window.setTimeout(function () {\r\n                if (!failCalled) {\r\n                    failCalled = true;\r\n                    connection.log(transport.name + " transport timed out when trying to connect.");\r\n                    that.transportFailed(transport, undefined, onFallback);\r\n                }\r\n            }, connection._.totalTransportConnectTimeout);\r\n        },\r\n\r\n        stop: function () {\r\n            this.connectionStopped = true;\r\n            window.clearTimeout(this.transportTimeoutHandle);\r\n            signalR.transports._logic.tryAbortStartRequest(this.connection);\r\n        },\r\n\r\n        initReceived: function (transport, onSuccess) {\r\n            var that = this,\r\n                connection = that.connection;\r\n\r\n            if (that.startRequested) {\r\n                connection.log("WARNING! The client received multiple init messages.");\r\n                return;\r\n            }\r\n\r\n            if (that.connectionStopped) {\r\n                return;\r\n            }\r\n\r\n            that.startRequested = true;\r\n            window.clearTimeout(that.transportTimeoutHandle);\r\n\r\n            connection.log(transport.name + " transport connected. Initiating start request.");\r\n            signalR.transports._logic.ajaxStart(connection, function () {\r\n                that.startCompleted = true;\r\n                onSuccess();\r\n            });\r\n        },\r\n\r\n        transportFailed: function (transport, error, onFallback) {\r\n            var connection = this.connection,\r\n                deferred = connection._deferral,\r\n                wrappedError;\r\n\r\n            if (this.connectionStopped) {\r\n                return;\r\n            }\r\n\r\n            window.clearTimeout(this.transportTimeoutHandle);\r\n\r\n            if (!this.startRequested) {\r\n                transport.stop(connection);\r\n\r\n                connection.log(transport.name + " transport failed to connect. Attempting to fall back.");\r\n                onFallback();\r\n            } else if (!this.startCompleted) {\r\n                // Do not attempt to fall back if a start request is ongoing during a transport failure.\r\n                // Instead, trigger an error and stop the connection.\r\n                wrappedError = signalR._.error(signalR.resources.errorDuringStartRequest, error);\r\n\r\n                connection.log(transport.name + " transport failed during the start request. Stopping the connection.");\r\n                $(connection).triggerHandler(events.onError, [wrappedError]);\r\n                if (deferred) {\r\n                    deferred.reject(wrappedError);\r\n                }\r\n\r\n                connection.stop();\r\n            } else {\r\n                // The start request has completed, but the connection has not stopped.\r\n                // No need to do anything here. The transport should attempt its normal reconnect logic.\r\n            }\r\n        }\r\n    };\r\n\r\n    transportLogic = signalR.transports._logic = {\r\n        ajax: function (connection, options) {\r\n            return $.ajax(\r\n                $.extend(/*deep copy*/ true, {}, $.signalR.ajaxDefaults, {\r\n                    type: "GET",\r\n                    data: {},\r\n                    xhrFields: { withCredentials: connection.withCredentials },\r\n                    contentType: connection.contentType,\r\n                    dataType: connection.ajaxDataType\r\n                }, options));\r\n        },\r\n\r\n        pingServer: function (connection) {\r\n            /// <summary>Pings the server</summary>\r\n            /// <param name="connection" type="signalr">Connection associated with the server ping</param>\r\n            /// <returns type="signalR" />\r\n            var url,\r\n                xhr,\r\n                deferral = $.Deferred();\r\n\r\n            if (connection.transport) {\r\n                url = connection.url + "/ping";\r\n\r\n                url = transportLogic.addQs(url, connection.qs);\r\n\r\n                xhr = transportLogic.ajax(connection, {\r\n                    url: url,\r\n                    success: function (result) {\r\n                        var data;\r\n\r\n                        try {\r\n                            data = connection._parseResponse(result);\r\n                        }\r\n                        catch (error) {\r\n                            deferral.reject(\r\n                                signalR._.transportError(\r\n                                    signalR.resources.pingServerFailedParse,\r\n                                    connection.transport,\r\n                                    error,\r\n                                    xhr\r\n                                )\r\n                            );\r\n                            connection.stop();\r\n                            return;\r\n                        }\r\n\r\n                        if (data.Response === "pong") {\r\n                            deferral.resolve();\r\n                        }\r\n                        else {\r\n                            deferral.reject(\r\n                                signalR._.transportError(\r\n                                    signalR._.format(signalR.resources.pingServerFailedInvalidResponse, result),\r\n                                    connection.transport,\r\n                                    null /* error */,\r\n                                    xhr\r\n                                )\r\n                            );\r\n                        }\r\n                    },\r\n                    error: function (error) {\r\n                        if (error.status === 401 || error.status === 403) {\r\n                            deferral.reject(\r\n                                signalR._.transportError(\r\n                                    signalR._.format(signalR.resources.pingServerFailedStatusCode, error.status),\r\n                                    connection.transport,\r\n                                    error,\r\n                                    xhr\r\n                                )\r\n                            );\r\n                            connection.stop();\r\n                        }\r\n                        else {\r\n                            deferral.reject(\r\n                                signalR._.transportError(\r\n                                    signalR.resources.pingServerFailed,\r\n                                    connection.transport,\r\n                                    error,\r\n                                    xhr\r\n                                )\r\n                            );\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n            else {\r\n                deferral.reject(\r\n                    signalR._.transportError(\r\n                        signalR.resources.noConnectionTransport,\r\n                        connection.transport\r\n                    )\r\n                );\r\n            }\r\n\r\n            return deferral.promise();\r\n        },\r\n\r\n        prepareQueryString: function (connection, url) {\r\n            var preparedUrl;\r\n\r\n            // Use addQs to start since it handles the ?/& prefix for us\r\n            preparedUrl = transportLogic.addQs(url, "clientProtocol=" + connection.clientProtocol);\r\n\r\n            // Add the user-specified query string params if any\r\n            preparedUrl = transportLogic.addQs(preparedUrl, connection.qs);\r\n\r\n            if (connection.token) {\r\n                preparedUrl += "&connectionToken=" + window.encodeURIComponent(connection.token);\r\n            }\r\n\r\n            if (connection.data) {\r\n                preparedUrl += "&connectionData=" + window.encodeURIComponent(connection.data);\r\n            }\r\n\r\n            return preparedUrl;\r\n        },\r\n\r\n        addQs: function (url, qs) {\r\n            var appender = url.indexOf("?") !== -1 ? "&" : "?",\r\n                firstChar;\r\n\r\n            if (!qs) {\r\n                return url;\r\n            }\r\n\r\n            if (typeof (qs) === "object") {\r\n                return url + appender + $.param(qs);\r\n            }\r\n\r\n            if (typeof (qs) === "string") {\r\n                firstChar = qs.charAt(0);\r\n\r\n                if (firstChar === "?" || firstChar === "&") {\r\n                    appender = "";\r\n                }\r\n\r\n                return url + appender + qs;\r\n            }\r\n\r\n            throw new Error("Query string property must be either a string or object.");\r\n        },\r\n\r\n        // BUG #2953: The url needs to be same otherwise it will cause a memory leak\r\n        getUrl: function (connection, transport, reconnecting, poll, ajaxPost) {\r\n            /// <summary>Gets the url for making a GET based connect request</summary>\r\n            var baseUrl = transport === "webSockets" ? "" : connection.baseUrl,\r\n                url = baseUrl + connection.appRelativeUrl,\r\n                qs = "transport=" + transport;\r\n\r\n            if (!ajaxPost && connection.groupsToken) {\r\n                qs += "&groupsToken=" + window.encodeURIComponent(connection.groupsToken);\r\n            }\r\n\r\n            if (!reconnecting) {\r\n                url += "/connect";\r\n            } else {\r\n                if (poll) {\r\n                    // longPolling transport specific\r\n                    url += "/poll";\r\n                } else {\r\n                    url += "/reconnect";\r\n                }\r\n\r\n                if (!ajaxPost && connection.messageId) {\r\n                    qs += "&messageId=" + window.encodeURIComponent(connection.messageId);\r\n                }\r\n            }\r\n            url += "?" + qs;\r\n            url = transportLogic.prepareQueryString(connection, url);\r\n\r\n            if (!ajaxPost) {\r\n                url += "&tid=" + Math.floor(Math.random() * 11);\r\n            }\r\n\r\n            return url;\r\n        },\r\n\r\n        maximizePersistentResponse: function (minPersistentResponse) {\r\n            return {\r\n                MessageId: minPersistentResponse.C,\r\n                Messages: minPersistentResponse.M,\r\n                Initialized: typeof (minPersistentResponse.S) !== "undefined" ? true : false,\r\n                ShouldReconnect: typeof (minPersistentResponse.T) !== "undefined" ? true : false,\r\n                LongPollDelay: minPersistentResponse.L,\r\n                GroupsToken: minPersistentResponse.G\r\n            };\r\n        },\r\n\r\n        updateGroups: function (connection, groupsToken) {\r\n            if (groupsToken) {\r\n                connection.groupsToken = groupsToken;\r\n            }\r\n        },\r\n\r\n        stringifySend: function (connection, message) {\r\n            if (typeof (message) === "string" || typeof (message) === "undefined" || message === null) {\r\n                return message;\r\n            }\r\n            return connection.json.stringify(message);\r\n        },\r\n\r\n        ajaxSend: function (connection, data) {\r\n            var payload = transportLogic.stringifySend(connection, data),\r\n                url = getAjaxUrl(connection, "/send"),\r\n                xhr,\r\n                onFail = function (error, connection) {\r\n                    $(connection).triggerHandler(events.onError, [signalR._.transportError(signalR.resources.sendFailed, connection.transport, error, xhr), data]);\r\n                };\r\n\r\n\r\n            xhr = transportLogic.ajax(connection, {\r\n                url: url,\r\n                type: connection.ajaxDataType === "jsonp" ? "GET" : "POST",\r\n                contentType: signalR._.defaultContentType,\r\n                data: {\r\n                    data: payload\r\n                },\r\n                success: function (result) {\r\n                    var res;\r\n\r\n                    if (result) {\r\n                        try {\r\n                            res = connection._parseResponse(result);\r\n                        }\r\n                        catch (error) {\r\n                            onFail(error, connection);\r\n                            connection.stop();\r\n                            return;\r\n                        }\r\n\r\n                        transportLogic.triggerReceived(connection, res);\r\n                    }\r\n                },\r\n                error: function (error, textStatus) {\r\n                    if (textStatus === "abort" || textStatus === "parsererror") {\r\n                        // The parsererror happens for sends that don\'t return any data, and hence\r\n                        // don\'t write the jsonp callback to the response. This is harder to fix on the server\r\n                        // so just hack around it on the client for now.\r\n                        return;\r\n                    }\r\n\r\n                    onFail(error, connection);\r\n                }\r\n            });\r\n\r\n            return xhr;\r\n        },\r\n\r\n        ajaxAbort: function (connection, async) {\r\n            if (typeof (connection.transport) === "undefined") {\r\n                return;\r\n            }\r\n\r\n            // Async by default unless explicitly overidden\r\n            async = typeof async === "undefined" ? true : async;\r\n\r\n            var url = getAjaxUrl(connection, "/abort");\r\n\r\n            transportLogic.ajax(connection, {\r\n                url: url,\r\n                async: async,\r\n                timeout: 1000,\r\n                type: "POST"\r\n            });\r\n\r\n            connection.log("Fired ajax abort async = " + async + ".");\r\n        },\r\n\r\n        ajaxStart: function (connection, onSuccess) {\r\n            var rejectDeferred = function (error) {\r\n                    var deferred = connection._deferral;\r\n                    if (deferred) {\r\n                        deferred.reject(error);\r\n                    }\r\n                },\r\n                triggerStartError = function (error) {\r\n                    connection.log("The start request failed. Stopping the connection.");\r\n                    $(connection).triggerHandler(events.onError, [error]);\r\n                    rejectDeferred(error);\r\n                    connection.stop();\r\n                };\r\n\r\n            connection._.startRequest = transportLogic.ajax(connection, {\r\n                url: getAjaxUrl(connection, "/start"),\r\n                success: function (result, statusText, xhr) {\r\n                    var data;\r\n\r\n                    try {\r\n                        data = connection._parseResponse(result);\r\n                    } catch (error) {\r\n                        triggerStartError(signalR._.error(\r\n                            signalR._.format(signalR.resources.errorParsingStartResponse, result),\r\n                            error, xhr));\r\n                        return;\r\n                    }\r\n\r\n                    if (data.Response === "started") {\r\n                        onSuccess();\r\n                    } else {\r\n                        triggerStartError(signalR._.error(\r\n                            signalR._.format(signalR.resources.invalidStartResponse, result),\r\n                            null /* error */, xhr));\r\n                    }\r\n                },\r\n                error: function (xhr, statusText, error) {\r\n                    if (statusText !== startAbortText) {\r\n                        triggerStartError(signalR._.error(\r\n                            signalR.resources.errorDuringStartRequest,\r\n                            error, xhr));\r\n                    } else {\r\n                        // Stop has been called, no need to trigger the error handler\r\n                        // or stop the connection again with onStartError\r\n                        connection.log("The start request aborted because connection.stop() was called.");\r\n                        rejectDeferred(signalR._.error(\r\n                            signalR.resources.stoppedDuringStartRequest,\r\n                            null /* error */, xhr));\r\n                    }\r\n                }\r\n            });\r\n        },\r\n\r\n        tryAbortStartRequest: function (connection) {\r\n            if (connection._.startRequest) {\r\n                // If the start request has already completed this will noop.\r\n                connection._.startRequest.abort(startAbortText);\r\n                delete connection._.startRequest;\r\n            }\r\n        },\r\n\r\n        tryInitialize: function (connection, persistentResponse, onInitialized) {\r\n            if (persistentResponse.Initialized && onInitialized) {\r\n                onInitialized();\r\n            } else if (persistentResponse.Initialized) {\r\n                connection.log("WARNING! The client received an init message after reconnecting.");\r\n            }\r\n\r\n        },\r\n\r\n        triggerReceived: function (connection, data) {\r\n            if (!connection._.connectingMessageBuffer.tryBuffer(data)) {\r\n                $(connection).triggerHandler(events.onReceived, [data]);\r\n            }\r\n        },\r\n\r\n        processMessages: function (connection, minData, onInitialized) {\r\n            var data;\r\n\r\n            // Update the last message time stamp\r\n            transportLogic.markLastMessage(connection);\r\n\r\n            if (minData) {\r\n                data = transportLogic.maximizePersistentResponse(minData);\r\n\r\n                transportLogic.updateGroups(connection, data.GroupsToken);\r\n\r\n                if (data.MessageId) {\r\n                    connection.messageId = data.MessageId;\r\n                }\r\n\r\n                if (data.Messages) {\r\n                    $.each(data.Messages, function (index, message) {\r\n                        transportLogic.triggerReceived(connection, message);\r\n                    });\r\n\r\n                    transportLogic.tryInitialize(connection, data, onInitialized);\r\n                }\r\n            }\r\n        },\r\n\r\n        monitorKeepAlive: function (connection) {\r\n            var keepAliveData = connection._.keepAliveData;\r\n\r\n            // If we haven\'t initiated the keep alive timeouts then we need to\r\n            if (!keepAliveData.monitoring) {\r\n                keepAliveData.monitoring = true;\r\n\r\n                transportLogic.markLastMessage(connection);\r\n\r\n                // Save the function so we can unbind it on stop\r\n                connection._.keepAliveData.reconnectKeepAliveUpdate = function () {\r\n                    // Mark a new message so that keep alive doesn\'t time out connections\r\n                    transportLogic.markLastMessage(connection);\r\n                };\r\n\r\n                // Update Keep alive on reconnect\r\n                $(connection).bind(events.onReconnect, connection._.keepAliveData.reconnectKeepAliveUpdate);\r\n\r\n                connection.log("Now monitoring keep alive with a warning timeout of " + keepAliveData.timeoutWarning + ", keep alive timeout of " + keepAliveData.timeout + " and disconnecting timeout of " + connection.disconnectTimeout);\r\n            } else {\r\n                connection.log("Tried to monitor keep alive but it\'s already being monitored.");\r\n            }\r\n        },\r\n\r\n        stopMonitoringKeepAlive: function (connection) {\r\n            var keepAliveData = connection._.keepAliveData;\r\n\r\n            // Only attempt to stop the keep alive monitoring if its being monitored\r\n            if (keepAliveData.monitoring) {\r\n                // Stop monitoring\r\n                keepAliveData.monitoring = false;\r\n\r\n                // Remove the updateKeepAlive function from the reconnect event\r\n                $(connection).unbind(events.onReconnect, connection._.keepAliveData.reconnectKeepAliveUpdate);\r\n\r\n                // Clear all the keep alive data\r\n                connection._.keepAliveData = {};\r\n                connection.log("Stopping the monitoring of the keep alive.");\r\n            }\r\n        },\r\n\r\n        startHeartbeat: function (connection) {\r\n            connection._.lastActiveAt = new Date().getTime();\r\n            beat(connection);\r\n        },\r\n\r\n        markLastMessage: function (connection) {\r\n            connection._.lastMessageAt = new Date().getTime();\r\n        },\r\n\r\n        markActive: function (connection) {\r\n            if (transportLogic.verifyLastActive(connection)) {\r\n                connection._.lastActiveAt = new Date().getTime();\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        },\r\n\r\n        isConnectedOrReconnecting: function (connection) {\r\n            return connection.state === signalR.connectionState.connected ||\r\n                   connection.state === signalR.connectionState.reconnecting;\r\n        },\r\n\r\n        ensureReconnectingState: function (connection) {\r\n            if (changeState(connection,\r\n                        signalR.connectionState.connected,\r\n                        signalR.connectionState.reconnecting) === true) {\r\n                $(connection).triggerHandler(events.onReconnecting);\r\n            }\r\n            return connection.state === signalR.connectionState.reconnecting;\r\n        },\r\n\r\n        clearReconnectTimeout: function (connection) {\r\n            if (connection && connection._.reconnectTimeout) {\r\n                window.clearTimeout(connection._.reconnectTimeout);\r\n                delete connection._.reconnectTimeout;\r\n            }\r\n        },\r\n\r\n        verifyLastActive: function (connection) {\r\n            if (new Date().getTime() - connection._.lastActiveAt >= connection.reconnectWindow) {\r\n                var message = signalR._.format(signalR.resources.reconnectWindowTimeout, new Date(connection._.lastActiveAt), connection.reconnectWindow);\r\n                connection.log(message);\r\n                $(connection).triggerHandler(events.onError, [signalR._.error(message, /* source */ "TimeoutException")]);\r\n                connection.stop(/* async */ false, /* notifyServer */ false);\r\n                return false;\r\n            }\r\n\r\n            return true;\r\n        },\r\n\r\n        reconnect: function (connection, transportName) {\r\n            var transport = signalR.transports[transportName];\r\n\r\n            // We should only set a reconnectTimeout if we are currently connected\r\n            // and a reconnectTimeout isn\'t already set.\r\n            if (transportLogic.isConnectedOrReconnecting(connection) && !connection._.reconnectTimeout) {\r\n                // Need to verify before the setTimeout occurs because an application sleep could occur during the setTimeout duration.\r\n                if (!transportLogic.verifyLastActive(connection)) {\r\n                    return;\r\n                }\r\n\r\n                connection._.reconnectTimeout = window.setTimeout(function () {\r\n                    if (!transportLogic.verifyLastActive(connection)) {\r\n                        return;\r\n                    }\r\n\r\n                    transport.stop(connection);\r\n\r\n                    if (transportLogic.ensureReconnectingState(connection)) {\r\n                        connection.log(transportName + " reconnecting.");\r\n                        transport.start(connection);\r\n                    }\r\n                }, connection.reconnectDelay);\r\n            }\r\n        },\r\n\r\n        handleParseFailure: function (connection, result, error, onFailed, context) {\r\n            var wrappedError = signalR._.transportError(\r\n                signalR._.format(signalR.resources.parseFailed, result),\r\n                connection.transport,\r\n                error,\r\n                context);\r\n\r\n            // If we\'re in the initialization phase trigger onFailed, otherwise stop the connection.\r\n            if (onFailed && onFailed(wrappedError)) {\r\n                connection.log("Failed to parse server response while attempting to connect.");\r\n            } else {\r\n                $(connection).triggerHandler(events.onError, [wrappedError]);\r\n                connection.stop();\r\n            }\r\n        },\r\n\r\n        initHandler: function (connection) {\r\n            return new InitHandler(connection);\r\n        },\r\n\r\n        foreverFrame: {\r\n            count: 0,\r\n            connections: {}\r\n        }\r\n    };\r\n\r\n}(window.jQuery, window));\r\n/* jquery.signalR.transports.webSockets.js */\r\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\n\r\n/*global window:false */\r\n/// <reference path="jquery.signalR.transports.common.js" />\r\n\r\n(function ($, window, undefined) {\r\n\r\n    var signalR = $.signalR,\r\n        events = $.signalR.events,\r\n        changeState = $.signalR.changeState,\r\n        transportLogic = signalR.transports._logic;\r\n\r\n    signalR.transports.webSockets = {\r\n        name: "webSockets",\r\n\r\n        supportsKeepAlive: function () {\r\n            return true;\r\n        },\r\n\r\n        send: function (connection, data) {\r\n            var payload = transportLogic.stringifySend(connection, data);\r\n\r\n            try {\r\n                connection.socket.send(payload);\r\n            } catch (ex) {\r\n                $(connection).triggerHandler(events.onError,\r\n                    [signalR._.transportError(\r\n                        signalR.resources.webSocketsInvalidState,\r\n                        connection.transport,\r\n                        ex,\r\n                        connection.socket\r\n                    ),\r\n                    data]);\r\n            }\r\n        },\r\n\r\n        start: function (connection, onSuccess, onFailed) {\r\n            var url,\r\n                opened = false,\r\n                that = this,\r\n                reconnecting = !onSuccess,\r\n                $connection = $(connection);\r\n\r\n            if (!window.WebSocket) {\r\n                onFailed();\r\n                return;\r\n            }\r\n\r\n            if (!connection.socket) {\r\n                if (connection.webSocketServerUrl) {\r\n                    url = connection.webSocketServerUrl;\r\n                } else {\r\n                    url = connection.wsProtocol + connection.host;\r\n                }\r\n\r\n                url += transportLogic.getUrl(connection, this.name, reconnecting);\r\n\r\n                connection.log("Connecting to websocket endpoint \'" + url + "\'.");\r\n                connection.socket = new window.WebSocket(url);\r\n\r\n                connection.socket.onopen = function () {\r\n                    opened = true;\r\n                    connection.log("Websocket opened.");\r\n\r\n                    transportLogic.clearReconnectTimeout(connection);\r\n\r\n                    if (changeState(connection,\r\n                                    signalR.connectionState.reconnecting,\r\n                                    signalR.connectionState.connected) === true) {\r\n                        $connection.triggerHandler(events.onReconnect);\r\n                    }\r\n                };\r\n\r\n                connection.socket.onclose = function (event) {\r\n                    var error;\r\n\r\n                    // Only handle a socket close if the close is from the current socket.\r\n                    // Sometimes on disconnect the server will push down an onclose event\r\n                    // to an expired socket.\r\n\r\n                    if (this === connection.socket) {\r\n                        if (opened && typeof event.wasClean !== "undefined" && event.wasClean === false) {\r\n                            // Ideally this would use the websocket.onerror handler (rather than checking wasClean in onclose) but\r\n                            // I found in some circumstances Chrome won\'t call onerror. This implementation seems to work on all browsers.\r\n                            error = signalR._.transportError(\r\n                                signalR.resources.webSocketClosed,\r\n                                connection.transport,\r\n                                event);\r\n\r\n                            connection.log("Unclean disconnect from websocket: " + (event.reason || "[no reason given]."));\r\n                        } else {\r\n                            connection.log("Websocket closed.");\r\n                        }\r\n\r\n                        if (!onFailed || !onFailed(error)) {\r\n                            if (error) {\r\n                                $(connection).triggerHandler(events.onError, [error]);\r\n                            }\r\n\r\n                            that.reconnect(connection);\r\n                        }\r\n                    }\r\n                };\r\n\r\n                connection.socket.onmessage = function (event) {\r\n                    var data;\r\n\r\n                    try {\r\n                        data = connection._parseResponse(event.data);\r\n                    }\r\n                    catch (error) {\r\n                        transportLogic.handleParseFailure(connection, event.data, error, onFailed, event);\r\n                        return;\r\n                    }\r\n\r\n                    if (data) {\r\n                        // data.M is PersistentResponse.Messages\r\n                        if ($.isEmptyObject(data) || data.M) {\r\n                            transportLogic.processMessages(connection, data, onSuccess);\r\n                        } else {\r\n                            // For websockets we need to trigger onReceived\r\n                            // for callbacks to outgoing hub calls.\r\n                            transportLogic.triggerReceived(connection, data);\r\n                        }\r\n                    }\r\n                };\r\n            }\r\n        },\r\n\r\n        reconnect: function (connection) {\r\n            transportLogic.reconnect(connection, this.name);\r\n        },\r\n\r\n        lostConnection: function (connection) {\r\n            this.reconnect(connection);\r\n        },\r\n\r\n        stop: function (connection) {\r\n            // Don\'t trigger a reconnect after stopping\r\n            transportLogic.clearReconnectTimeout(connection);\r\n\r\n            if (connection.socket) {\r\n                connection.log("Closing the Websocket.");\r\n                connection.socket.close();\r\n                connection.socket = null;\r\n            }\r\n        },\r\n\r\n        abort: function (connection, async) {\r\n            transportLogic.ajaxAbort(connection, async);\r\n        }\r\n    };\r\n\r\n}(window.jQuery, window));\r\n/* jquery.signalR.transports.serverSentEvents.js */\r\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\n\r\n/*global window:false */\r\n/// <reference path="jquery.signalR.transports.common.js" />\r\n\r\n(function ($, window, undefined) {\r\n\r\n    var signalR = $.signalR,\r\n        events = $.signalR.events,\r\n        changeState = $.signalR.changeState,\r\n        transportLogic = signalR.transports._logic,\r\n        clearReconnectAttemptTimeout = function (connection) {\r\n            window.clearTimeout(connection._.reconnectAttemptTimeoutHandle);\r\n            delete connection._.reconnectAttemptTimeoutHandle;\r\n        };\r\n\r\n    signalR.transports.serverSentEvents = {\r\n        name: "serverSentEvents",\r\n\r\n        supportsKeepAlive: function () {\r\n            return true;\r\n        },\r\n\r\n        timeOut: 3000,\r\n\r\n        start: function (connection, onSuccess, onFailed) {\r\n            var that = this,\r\n                opened = false,\r\n                $connection = $(connection),\r\n                reconnecting = !onSuccess,\r\n                url;\r\n\r\n            if (connection.eventSource) {\r\n                connection.log("The connection already has an event source. Stopping it.");\r\n                connection.stop();\r\n            }\r\n\r\n            if (!window.EventSource) {\r\n                if (onFailed) {\r\n                    connection.log("This browser doesn\'t support SSE.");\r\n                    onFailed();\r\n                }\r\n                return;\r\n            }\r\n\r\n            url = transportLogic.getUrl(connection, this.name, reconnecting);\r\n\r\n            try {\r\n                connection.log("Attempting to connect to SSE endpoint \'" + url + "\'.");\r\n                connection.eventSource = new window.EventSource(url, { withCredentials: connection.withCredentials });\r\n            }\r\n            catch (e) {\r\n                connection.log("EventSource failed trying to connect with error " + e.Message + ".");\r\n                if (onFailed) {\r\n                    // The connection failed, call the failed callback\r\n                    onFailed();\r\n                } else {\r\n                    $connection.triggerHandler(events.onError, [signalR._.transportError(signalR.resources.eventSourceFailedToConnect, connection.transport, e)]);\r\n                    if (reconnecting) {\r\n                        // If we were reconnecting, rather than doing initial connect, then try reconnect again\r\n                        that.reconnect(connection);\r\n                    }\r\n                }\r\n                return;\r\n            }\r\n\r\n            if (reconnecting) {\r\n                connection._.reconnectAttemptTimeoutHandle = window.setTimeout(function () {\r\n                    if (opened === false) {\r\n                        // If we\'re reconnecting and the event source is attempting to connect,\r\n                        // don\'t keep retrying. This causes duplicate connections to spawn.\r\n                        if (connection.eventSource.readyState !== window.EventSource.OPEN) {\r\n                            // If we were reconnecting, rather than doing initial connect, then try reconnect again\r\n                            that.reconnect(connection);\r\n                        }\r\n                    }\r\n                },\r\n                that.timeOut);\r\n            }\r\n\r\n            connection.eventSource.addEventListener("open", function (e) {\r\n                connection.log("EventSource connected.");\r\n\r\n                clearReconnectAttemptTimeout(connection);\r\n                transportLogic.clearReconnectTimeout(connection);\r\n\r\n                if (opened === false) {\r\n                    opened = true;\r\n\r\n                    if (changeState(connection,\r\n                                         signalR.connectionState.reconnecting,\r\n                                         signalR.connectionState.connected) === true) {\r\n                        $connection.triggerHandler(events.onReconnect);\r\n                    }\r\n                }\r\n            }, false);\r\n\r\n            connection.eventSource.addEventListener("message", function (e) {\r\n                var res;\r\n\r\n                // process messages\r\n                if (e.data === "initialized") {\r\n                    return;\r\n                }\r\n\r\n                try {\r\n                    res = connection._parseResponse(e.data);\r\n                }\r\n                catch (error) {\r\n                    transportLogic.handleParseFailure(connection, e.data, error, onFailed, e);\r\n                    return;\r\n                }\r\n\r\n                transportLogic.processMessages(connection, res, onSuccess);\r\n            }, false);\r\n\r\n            connection.eventSource.addEventListener("error", function (e) {\r\n                var error = signalR._.transportError(\r\n                    signalR.resources.eventSourceError,\r\n                    connection.transport,\r\n                    e);\r\n\r\n                // Only handle an error if the error is from the current Event Source.\r\n                // Sometimes on disconnect the server will push down an error event\r\n                // to an expired Event Source.\r\n                if (this !== connection.eventSource) {\r\n                    return;\r\n                }\r\n\r\n                if (onFailed && onFailed(error)) {\r\n                    return;\r\n                }\r\n\r\n                connection.log("EventSource readyState: " + connection.eventSource.readyState + ".");\r\n\r\n                if (e.eventPhase === window.EventSource.CLOSED) {\r\n                    // We don\'t use the EventSource\'s native reconnect function as it\r\n                    // doesn\'t allow us to change the URL when reconnecting. We need\r\n                    // to change the URL to not include the /connect suffix, and pass\r\n                    // the last message id we received.\r\n                    connection.log("EventSource reconnecting due to the server connection ending.");\r\n                    that.reconnect(connection);\r\n                } else {\r\n                    // connection error\r\n                    connection.log("EventSource error.");\r\n                    $connection.triggerHandler(events.onError, [error]);\r\n                }\r\n            }, false);\r\n        },\r\n\r\n        reconnect: function (connection) {\r\n            transportLogic.reconnect(connection, this.name);\r\n        },\r\n\r\n        lostConnection: function (connection) {\r\n            this.reconnect(connection);\r\n        },\r\n\r\n        send: function (connection, data) {\r\n            transportLogic.ajaxSend(connection, data);\r\n        },\r\n\r\n        stop: function (connection) {\r\n            // Don\'t trigger a reconnect after stopping\r\n            clearReconnectAttemptTimeout(connection);\r\n            transportLogic.clearReconnectTimeout(connection);\r\n\r\n            if (connection && connection.eventSource) {\r\n                connection.log("EventSource calling close().");\r\n                connection.eventSource.close();\r\n                connection.eventSource = null;\r\n                delete connection.eventSource;\r\n            }\r\n        },\r\n\r\n        abort: function (connection, async) {\r\n            transportLogic.ajaxAbort(connection, async);\r\n        }\r\n    };\r\n\r\n}(window.jQuery, window));\r\n/* jquery.signalR.transports.foreverFrame.js */\r\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\n\r\n/*global window:false */\r\n/// <reference path="jquery.signalR.transports.common.js" />\r\n\r\n(function ($, window, undefined) {\r\n\r\n    var signalR = $.signalR,\r\n        events = $.signalR.events,\r\n        changeState = $.signalR.changeState,\r\n        transportLogic = signalR.transports._logic,\r\n        createFrame = function () {\r\n            var frame = window.document.createElement("iframe");\r\n            frame.setAttribute("style", "position:absolute;top:0;left:0;width:0;height:0;visibility:hidden;");\r\n            return frame;\r\n        },\r\n        // Used to prevent infinite loading icon spins in older versions of ie\r\n        // We build this object inside a closure so we don\'t pollute the rest of\r\n        // the foreverFrame transport with unnecessary functions/utilities.\r\n        loadPreventer = (function () {\r\n            var loadingFixIntervalId = null,\r\n                loadingFixInterval = 1000,\r\n                attachedTo = 0;\r\n\r\n            return {\r\n                prevent: function () {\r\n                    // Prevent additional iframe removal procedures from newer browsers\r\n                    if (signalR._.ieVersion <= 8) {\r\n                        // We only ever want to set the interval one time, so on the first attachedTo\r\n                        if (attachedTo === 0) {\r\n                            // Create and destroy iframe every 3 seconds to prevent loading icon, super hacky\r\n                            loadingFixIntervalId = window.setInterval(function () {\r\n                                var tempFrame = createFrame();\r\n\r\n                                window.document.body.appendChild(tempFrame);\r\n                                window.document.body.removeChild(tempFrame);\r\n\r\n                                tempFrame = null;\r\n                            }, loadingFixInterval);\r\n                        }\r\n\r\n                        attachedTo++;\r\n                    }\r\n                },\r\n                cancel: function () {\r\n                    // Only clear the interval if there\'s only one more object that the loadPreventer is attachedTo\r\n                    if (attachedTo === 1) {\r\n                        window.clearInterval(loadingFixIntervalId);\r\n                    }\r\n\r\n                    if (attachedTo > 0) {\r\n                        attachedTo--;\r\n                    }\r\n                }\r\n            };\r\n        })();\r\n\r\n    signalR.transports.foreverFrame = {\r\n        name: "foreverFrame",\r\n\r\n        supportsKeepAlive: function () {\r\n            return true;\r\n        },\r\n\r\n        // Added as a value here so we can create tests to verify functionality\r\n        iframeClearThreshold: 50,\r\n\r\n        start: function (connection, onSuccess, onFailed) {\r\n            var that = this,\r\n                frameId = (transportLogic.foreverFrame.count += 1),\r\n                url,\r\n                frame = createFrame(),\r\n                frameLoadHandler = function () {\r\n                    connection.log("Forever frame iframe finished loading and is no longer receiving messages.");\r\n                    if (!onFailed || !onFailed()) {\r\n                        that.reconnect(connection);\r\n                    }\r\n                };\r\n\r\n            if (window.EventSource) {\r\n                // If the browser supports SSE, don\'t use Forever Frame\r\n                if (onFailed) {\r\n                    connection.log("Forever Frame is not supported by SignalR on browsers with SSE support.");\r\n                    onFailed();\r\n                }\r\n                return;\r\n            }\r\n\r\n            frame.setAttribute("data-signalr-connection-id", connection.id);\r\n\r\n            // Start preventing loading icon\r\n            // This will only perform work if the loadPreventer is not attached to another connection.\r\n            loadPreventer.prevent();\r\n\r\n            // Build the url\r\n            url = transportLogic.getUrl(connection, this.name);\r\n            url += "&frameId=" + frameId;\r\n\r\n            // add frame to the document prior to setting URL to avoid caching issues.\r\n            window.document.documentElement.appendChild(frame);\r\n\r\n            connection.log("Binding to iframe\'s load event.");\r\n\r\n            if (frame.addEventListener) {\r\n                frame.addEventListener("load", frameLoadHandler, false);\r\n            } else if (frame.attachEvent) {\r\n                frame.attachEvent("onload", frameLoadHandler);\r\n            }\r\n\r\n            frame.src = url;\r\n            transportLogic.foreverFrame.connections[frameId] = connection;\r\n\r\n            connection.frame = frame;\r\n            connection.frameId = frameId;\r\n\r\n            if (onSuccess) {\r\n                connection.onSuccess = function () {\r\n                    connection.log("Iframe transport started.");\r\n                    onSuccess();\r\n                };\r\n            }\r\n        },\r\n\r\n        reconnect: function (connection) {\r\n            var that = this;\r\n\r\n            // Need to verify connection state and verify before the setTimeout occurs because an application sleep could occur during the setTimeout duration.\r\n            if (transportLogic.isConnectedOrReconnecting(connection) && transportLogic.verifyLastActive(connection)) {\r\n                window.setTimeout(function () {\r\n                    // Verify that we\'re ok to reconnect.\r\n                    if (!transportLogic.verifyLastActive(connection)) {\r\n                        return;\r\n                    }\r\n\r\n                    if (connection.frame && transportLogic.ensureReconnectingState(connection)) {\r\n                        var frame = connection.frame,\r\n                            src = transportLogic.getUrl(connection, that.name, true) + "&frameId=" + connection.frameId;\r\n                        connection.log("Updating iframe src to \'" + src + "\'.");\r\n                        frame.src = src;\r\n                    }\r\n                }, connection.reconnectDelay);\r\n            }\r\n        },\r\n\r\n        lostConnection: function (connection) {\r\n            this.reconnect(connection);\r\n        },\r\n\r\n        send: function (connection, data) {\r\n            transportLogic.ajaxSend(connection, data);\r\n        },\r\n\r\n        receive: function (connection, data) {\r\n            var cw,\r\n                body,\r\n                response;\r\n\r\n            if (connection.json !== connection._originalJson) {\r\n                // If there\'s a custom JSON parser configured then serialize the object\r\n                // using the original (browser) JSON parser and then deserialize it using\r\n                // the custom parser (connection._parseResponse does that). This is so we\r\n                // can easily send the response from the server as "raw" JSON but still\r\n                // support custom JSON deserialization in the browser.\r\n                data = connection._originalJson.stringify(data);\r\n            }\r\n\r\n            response = connection._parseResponse(data);\r\n\r\n            transportLogic.processMessages(connection, response, connection.onSuccess);\r\n\r\n            // Protect against connection stopping from a callback trigger within the processMessages above.\r\n            if (connection.state === $.signalR.connectionState.connected) {\r\n                // Delete the script & div elements\r\n                connection.frameMessageCount = (connection.frameMessageCount || 0) + 1;\r\n                if (connection.frameMessageCount > signalR.transports.foreverFrame.iframeClearThreshold) {\r\n                    connection.frameMessageCount = 0;\r\n                    cw = connection.frame.contentWindow || connection.frame.contentDocument;\r\n                    if (cw && cw.document && cw.document.body) {\r\n                        body = cw.document.body;\r\n\r\n                        // Remove all the child elements from the iframe\'s body to conserver memory\r\n                        while (body.firstChild) {\r\n                            body.removeChild(body.firstChild);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        },\r\n\r\n        stop: function (connection) {\r\n            var cw = null;\r\n\r\n            // Stop attempting to prevent loading icon\r\n            loadPreventer.cancel();\r\n\r\n            if (connection.frame) {\r\n                if (connection.frame.stop) {\r\n                    connection.frame.stop();\r\n                } else {\r\n                    try {\r\n                        cw = connection.frame.contentWindow || connection.frame.contentDocument;\r\n                        if (cw.document && cw.document.execCommand) {\r\n                            cw.document.execCommand("Stop");\r\n                        }\r\n                    }\r\n                    catch (e) {\r\n                        connection.log("Error occurred when stopping foreverFrame transport. Message = " + e.message + ".");\r\n                    }\r\n                }\r\n\r\n                // Ensure the iframe is where we left it\r\n                if (connection.frame.parentNode === window.document.documentElement) {\r\n                    window.document.documentElement.removeChild(connection.frame);\r\n                }\r\n\r\n                delete transportLogic.foreverFrame.connections[connection.frameId];\r\n                connection.frame = null;\r\n                connection.frameId = null;\r\n                delete connection.frame;\r\n                delete connection.frameId;\r\n                delete connection.onSuccess;\r\n                delete connection.frameMessageCount;\r\n                connection.log("Stopping forever frame.");\r\n            }\r\n        },\r\n\r\n        abort: function (connection, async) {\r\n            transportLogic.ajaxAbort(connection, async);\r\n        },\r\n\r\n        getConnection: function (id) {\r\n            return transportLogic.foreverFrame.connections[id];\r\n        },\r\n\r\n        started: function (connection) {\r\n            if (changeState(connection,\r\n                signalR.connectionState.reconnecting,\r\n                signalR.connectionState.connected) === true) {\r\n\r\n                $(connection).triggerHandler(events.onReconnect);\r\n            }\r\n        }\r\n    };\r\n\r\n}(window.jQuery, window));\r\n/* jquery.signalR.transports.longPolling.js */\r\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\n\r\n/*global window:false */\r\n/// <reference path="jquery.signalR.transports.common.js" />\r\n\r\n(function ($, window, undefined) {\r\n\r\n    var signalR = $.signalR,\r\n        events = $.signalR.events,\r\n        changeState = $.signalR.changeState,\r\n        isDisconnecting = $.signalR.isDisconnecting,\r\n        transportLogic = signalR.transports._logic;\r\n\r\n    signalR.transports.longPolling = {\r\n        name: "longPolling",\r\n\r\n        supportsKeepAlive: function () {\r\n            return false;\r\n        },\r\n\r\n        reconnectDelay: 3000,\r\n\r\n        start: function (connection, onSuccess, onFailed) {\r\n            /// <summary>Starts the long polling connection</summary>\r\n            /// <param name="connection" type="signalR">The SignalR connection to start</param>\r\n            var that = this,\r\n                fireConnect = function () {\r\n                    fireConnect = $.noop;\r\n\r\n                    connection.log("LongPolling connected.");\r\n\r\n                    if (onSuccess) {\r\n                        onSuccess();\r\n                    } else {\r\n                        connection.log("WARNING! The client received an init message after reconnecting.");\r\n                    }\r\n                },\r\n                tryFailConnect = function (error) {\r\n                    if (onFailed(error)) {\r\n                        connection.log("LongPolling failed to connect.");\r\n                        return true;\r\n                    }\r\n\r\n                    return false;\r\n                },\r\n                privateData = connection._,\r\n                reconnectErrors = 0,\r\n                fireReconnected = function (instance) {\r\n                    window.clearTimeout(privateData.reconnectTimeoutId);\r\n                    privateData.reconnectTimeoutId = null;\r\n\r\n                    if (changeState(instance,\r\n                                    signalR.connectionState.reconnecting,\r\n                                    signalR.connectionState.connected) === true) {\r\n                        // Successfully reconnected!\r\n                        instance.log("Raising the reconnect event");\r\n                        $(instance).triggerHandler(events.onReconnect);\r\n                    }\r\n                },\r\n                // 1 hour\r\n                maxFireReconnectedTimeout = 3600000;\r\n\r\n            if (connection.pollXhr) {\r\n                connection.log("Polling xhr requests already exists, aborting.");\r\n                connection.stop();\r\n            }\r\n\r\n            connection.messageId = null;\r\n\r\n            privateData.reconnectTimeoutId = null;\r\n\r\n            privateData.pollTimeoutId = window.setTimeout(function () {\r\n                (function poll(instance, raiseReconnect) {\r\n                    var messageId = instance.messageId,\r\n                        connect = (messageId === null),\r\n                        reconnecting = !connect,\r\n                        polling = !raiseReconnect,\r\n                        url = transportLogic.getUrl(instance, that.name, reconnecting, polling, true /* use Post for longPolling */),\r\n                        postData = {};\r\n\r\n                    if (instance.messageId) {\r\n                        postData.messageId = instance.messageId;\r\n                    }\r\n\r\n                    if (instance.groupsToken) {\r\n                        postData.groupsToken = instance.groupsToken;\r\n                    }\r\n\r\n                    // If we\'ve disconnected during the time we\'ve tried to re-instantiate the poll then stop.\r\n                    if (isDisconnecting(instance) === true) {\r\n                        return;\r\n                    }\r\n\r\n                    connection.log("Opening long polling request to \'" + url + "\'.");\r\n                    instance.pollXhr = transportLogic.ajax(connection, {\r\n                        xhrFields: {\r\n                            onprogress: function () {\r\n                                transportLogic.markLastMessage(connection);\r\n                            }\r\n                        },\r\n                        url: url,\r\n                        type: "POST",\r\n                        contentType: signalR._.defaultContentType,\r\n                        data: postData,\r\n                        timeout: connection._.pollTimeout,\r\n                        success: function (result) {\r\n                            var minData,\r\n                                delay = 0,\r\n                                data,\r\n                                shouldReconnect;\r\n\r\n                            connection.log("Long poll complete.");\r\n\r\n                            // Reset our reconnect errors so if we transition into a reconnecting state again we trigger\r\n                            // reconnected quickly\r\n                            reconnectErrors = 0;\r\n\r\n                            try {\r\n                                // Remove any keep-alives from the beginning of the result\r\n                                minData = connection._parseResponse(result);\r\n                            }\r\n                            catch (error) {\r\n                                transportLogic.handleParseFailure(instance, result, error, tryFailConnect, instance.pollXhr);\r\n                                return;\r\n                            }\r\n\r\n                            // If there\'s currently a timeout to trigger reconnect, fire it now before processing messages\r\n                            if (privateData.reconnectTimeoutId !== null) {\r\n                                fireReconnected(instance);\r\n                            }\r\n\r\n                            if (minData) {\r\n                                data = transportLogic.maximizePersistentResponse(minData);\r\n                            }\r\n\r\n                            transportLogic.processMessages(instance, minData, fireConnect);\r\n\r\n                            if (data &&\r\n                                $.type(data.LongPollDelay) === "number") {\r\n                                delay = data.LongPollDelay;\r\n                            }\r\n\r\n                            if (isDisconnecting(instance) === true) {\r\n                                return;\r\n                            }\r\n\r\n                            shouldReconnect = data && data.ShouldReconnect;\r\n                            if (shouldReconnect) {\r\n                                // Transition into the reconnecting state\r\n                                // If this fails then that means that the user transitioned the connection into a invalid state in processMessages.\r\n                                if (!transportLogic.ensureReconnectingState(instance)) {\r\n                                    return;\r\n                                }\r\n                            }\r\n\r\n                            // We never want to pass a raiseReconnect flag after a successful poll.  This is handled via the error function\r\n                            if (delay > 0) {\r\n                                privateData.pollTimeoutId = window.setTimeout(function () {\r\n                                    poll(instance, shouldReconnect);\r\n                                }, delay);\r\n                            } else {\r\n                                poll(instance, shouldReconnect);\r\n                            }\r\n                        },\r\n\r\n                        error: function (data, textStatus) {\r\n                            var error = signalR._.transportError(signalR.resources.longPollFailed, connection.transport, data, instance.pollXhr);\r\n\r\n                            // Stop trying to trigger reconnect, connection is in an error state\r\n                            // If we\'re not in the reconnect state this will noop\r\n                            window.clearTimeout(privateData.reconnectTimeoutId);\r\n                            privateData.reconnectTimeoutId = null;\r\n\r\n                            if (textStatus === "abort") {\r\n                                connection.log("Aborted xhr request.");\r\n                                return;\r\n                            }\r\n\r\n                            if (!tryFailConnect(error)) {\r\n\r\n                                // Increment our reconnect errors, we assume all errors to be reconnect errors\r\n                                // In the case that it\'s our first error this will cause Reconnect to be fired\r\n                                // after 1 second due to reconnectErrors being = 1.\r\n                                reconnectErrors++;\r\n\r\n                                if (connection.state !== signalR.connectionState.reconnecting) {\r\n                                    connection.log("An error occurred using longPolling. Status = " + textStatus + ".  Response = " + data.responseText + ".");\r\n                                    $(instance).triggerHandler(events.onError, [error]);\r\n                                }\r\n\r\n                                // We check the state here to verify that we\'re not in an invalid state prior to verifying Reconnect.\r\n                                // If we\'re not in connected or reconnecting then the next ensureReconnectingState check will fail and will return.\r\n                                // Therefore we don\'t want to change that failure code path.\r\n                                if ((connection.state === signalR.connectionState.connected ||\r\n                                    connection.state === signalR.connectionState.reconnecting) &&\r\n                                    !transportLogic.verifyLastActive(connection)) {\r\n                                    return;\r\n                                }\r\n\r\n                                // Transition into the reconnecting state\r\n                                // If this fails then that means that the user transitioned the connection into the disconnected or connecting state within the above error handler trigger.\r\n                                if (!transportLogic.ensureReconnectingState(instance)) {\r\n                                    return;\r\n                                }\r\n\r\n                                // Call poll with the raiseReconnect flag as true after the reconnect delay\r\n                                privateData.pollTimeoutId = window.setTimeout(function () {\r\n                                    poll(instance, true);\r\n                                }, that.reconnectDelay);\r\n                            }\r\n                        }\r\n                    });\r\n\r\n                    // This will only ever pass after an error has occurred via the poll ajax procedure.\r\n                    if (reconnecting && raiseReconnect === true) {\r\n                        // We wait to reconnect depending on how many times we\'ve failed to reconnect.\r\n                        // This is essentially a heuristic that will exponentially increase in wait time before\r\n                        // triggering reconnected.  This depends on the "error" handler of Poll to cancel this\r\n                        // timeout if it triggers before the Reconnected event fires.\r\n                        // The Math.min at the end is to ensure that the reconnect timeout does not overflow.\r\n                        privateData.reconnectTimeoutId = window.setTimeout(function () { fireReconnected(instance); }, Math.min(1000 * (Math.pow(2, reconnectErrors) - 1), maxFireReconnectedTimeout));\r\n                    }\r\n                }(connection));\r\n            }, 250); // Have to delay initial poll so Chrome doesn\'t show loader spinner in tab\r\n        },\r\n\r\n        lostConnection: function (connection) {\r\n            if (connection.pollXhr) {\r\n                connection.pollXhr.abort("lostConnection");\r\n            }\r\n        },\r\n\r\n        send: function (connection, data) {\r\n            transportLogic.ajaxSend(connection, data);\r\n        },\r\n\r\n        stop: function (connection) {\r\n            /// <summary>Stops the long polling connection</summary>\r\n            /// <param name="connection" type="signalR">The SignalR connection to stop</param>\r\n\r\n            window.clearTimeout(connection._.pollTimeoutId);\r\n            window.clearTimeout(connection._.reconnectTimeoutId);\r\n\r\n            delete connection._.pollTimeoutId;\r\n            delete connection._.reconnectTimeoutId;\r\n\r\n            if (connection.pollXhr) {\r\n                connection.pollXhr.abort();\r\n                connection.pollXhr = null;\r\n                delete connection.pollXhr;\r\n            }\r\n        },\r\n\r\n        abort: function (connection, async) {\r\n            transportLogic.ajaxAbort(connection, async);\r\n        }\r\n    };\r\n\r\n}(window.jQuery, window));\r\n/* jquery.signalR.hubs.js */\r\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\n/*global window:false */\r\n/// <reference path="jquery.signalR.core.js" />\r\n\r\n(function ($, window, undefined) {\r\n\r\n    var eventNamespace = ".hubProxy",\r\n        signalR = $.signalR;\r\n\r\n    function makeEventName(event) {\r\n        return event + eventNamespace;\r\n    }\r\n\r\n    // Equivalent to Array.prototype.map\r\n    function map(arr, fun, thisp) {\r\n        var i,\r\n            length = arr.length,\r\n            result = [];\r\n        for (i = 0; i < length; i += 1) {\r\n            if (arr.hasOwnProperty(i)) {\r\n                result[i] = fun.call(thisp, arr[i], i, arr);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function getArgValue(a) {\r\n        return $.isFunction(a) ? null : ($.type(a) === "undefined" ? null : a);\r\n    }\r\n\r\n    function hasMembers(obj) {\r\n        for (var key in obj) {\r\n            // If we have any properties in our callback map then we have callbacks and can exit the loop via return\r\n            if (obj.hasOwnProperty(key)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function clearInvocationCallbacks(connection, error) {\r\n        /// <param name="connection" type="hubConnection" />\r\n        var callbacks = connection._.invocationCallbacks,\r\n            callback;\r\n\r\n        if (hasMembers(callbacks)) {\r\n            connection.log("Clearing hub invocation callbacks with error: " + error + ".");\r\n        }\r\n\r\n        // Reset the callback cache now as we have a local var referencing it\r\n        connection._.invocationCallbackId = 0;\r\n        delete connection._.invocationCallbacks;\r\n        connection._.invocationCallbacks = {};\r\n\r\n        // Loop over the callbacks and invoke them.\r\n        // We do this using a local var reference and *after* we\'ve cleared the cache\r\n        // so that if a fail callback itself tries to invoke another method we don\'t\r\n        // end up with its callback in the list we\'re looping over.\r\n        for (var callbackId in callbacks) {\r\n            callback = callbacks[callbackId];\r\n            callback.method.call(callback.scope, { E: error });\r\n        }\r\n    }\r\n\r\n    // hubProxy\r\n    function hubProxy(hubConnection, hubName) {\r\n        /// <summary>\r\n        ///     Creates a new proxy object for the given hub connection that can be used to invoke\r\n        ///     methods on server hubs and handle client method invocation requests from the server.\r\n        /// </summary>\r\n        return new hubProxy.fn.init(hubConnection, hubName);\r\n    }\r\n\r\n    hubProxy.fn = hubProxy.prototype = {\r\n        init: function (connection, hubName) {\r\n            this.state = {};\r\n            this.connection = connection;\r\n            this.hubName = hubName;\r\n            this._ = {\r\n                callbackMap: {}\r\n            };\r\n        },\r\n\r\n        constructor: hubProxy,\r\n\r\n        hasSubscriptions: function () {\r\n            return hasMembers(this._.callbackMap);\r\n        },\r\n\r\n        on: function (eventName, callback) {\r\n            /// <summary>Wires up a callback to be invoked when a invocation request is received from the server hub.</summary>\r\n            /// <param name="eventName" type="String">The name of the hub event to register the callback for.</param>\r\n            /// <param name="callback" type="Function">The callback to be invoked.</param>\r\n            var that = this,\r\n                callbackMap = that._.callbackMap;\r\n\r\n            // Normalize the event name to lowercase\r\n            eventName = eventName.toLowerCase();\r\n\r\n            // If there is not an event registered for this callback yet we want to create its event space in the callback map.\r\n            if (!callbackMap[eventName]) {\r\n                callbackMap[eventName] = {};\r\n            }\r\n\r\n            // Map the callback to our encompassed function\r\n            callbackMap[eventName][callback] = function (e, data) {\r\n                callback.apply(that, data);\r\n            };\r\n\r\n            $(that).bind(makeEventName(eventName), callbackMap[eventName][callback]);\r\n\r\n            return that;\r\n        },\r\n\r\n        off: function (eventName, callback) {\r\n            /// <summary>Removes the callback invocation request from the server hub for the given event name.</summary>\r\n            /// <param name="eventName" type="String">The name of the hub event to unregister the callback for.</param>\r\n            /// <param name="callback" type="Function">The callback to be invoked.</param>\r\n            var that = this,\r\n                callbackMap = that._.callbackMap,\r\n                callbackSpace;\r\n\r\n            // Normalize the event name to lowercase\r\n            eventName = eventName.toLowerCase();\r\n\r\n            callbackSpace = callbackMap[eventName];\r\n\r\n            // Verify that there is an event space to unbind\r\n            if (callbackSpace) {\r\n                // Only unbind if there\'s an event bound with eventName and a callback with the specified callback\r\n                if (callbackSpace[callback]) {\r\n                    $(that).unbind(makeEventName(eventName), callbackSpace[callback]);\r\n\r\n                    // Remove the callback from the callback map\r\n                    delete callbackSpace[callback];\r\n\r\n                    // Check if there are any members left on the event, if not we need to destroy it.\r\n                    if (!hasMembers(callbackSpace)) {\r\n                        delete callbackMap[eventName];\r\n                    }\r\n                } else if (!callback) { // Check if we\'re removing the whole event and we didn\'t error because of an invalid callback\r\n                    $(that).unbind(makeEventName(eventName));\r\n\r\n                    delete callbackMap[eventName];\r\n                }\r\n            }\r\n\r\n            return that;\r\n        },\r\n\r\n        invoke: function (methodName) {\r\n            /// <summary>Invokes a server hub method with the given arguments.</summary>\r\n            /// <param name="methodName" type="String">The name of the server hub method.</param>\r\n\r\n            var that = this,\r\n                connection = that.connection,\r\n                args = $.makeArray(arguments).slice(1),\r\n                argValues = map(args, getArgValue),\r\n                data = { H: that.hubName, M: methodName, A: argValues, I: connection._.invocationCallbackId },\r\n                d = $.Deferred(),\r\n                callback = function (minResult) {\r\n                    var result = that._maximizeHubResponse(minResult),\r\n                        source,\r\n                        error;\r\n\r\n                    // Update the hub state\r\n                    $.extend(that.state, result.State);\r\n\r\n                    if (result.Progress) {\r\n                        if (d.notifyWith) {\r\n                            // Progress is only supported in jQuery 1.7+\r\n                            d.notifyWith(that, [result.Progress.Data]);\r\n                        } else if(!connection._.progressjQueryVersionLogged) {\r\n                            connection.log("A hub method invocation progress update was received but the version of jQuery in use (" + $.prototype.jquery + ") does not support progress updates. Upgrade to jQuery 1.7+ to receive progress notifications.");\r\n                            connection._.progressjQueryVersionLogged = true;\r\n                        }\r\n                    } else if (result.Error) {\r\n                        // Server hub method threw an exception, log it & reject the deferred\r\n                        if (result.StackTrace) {\r\n                            connection.log(result.Error + "\\n" + result.StackTrace + ".");\r\n                        }\r\n\r\n                        // result.ErrorData is only set if a HubException was thrown\r\n                        source = result.IsHubException ? "HubException" : "Exception";\r\n                        error = signalR._.error(result.Error, source);\r\n                        error.data = result.ErrorData;\r\n\r\n                        connection.log(that.hubName + "." + methodName + " failed to execute. Error: " + error.message);\r\n                        d.rejectWith(that, [error]);\r\n                    } else {\r\n                        // Server invocation succeeded, resolve the deferred\r\n                        connection.log("Invoked " + that.hubName + "." + methodName);\r\n                        d.resolveWith(that, [result.Result]);\r\n                    }\r\n                };\r\n\r\n            connection._.invocationCallbacks[connection._.invocationCallbackId.toString()] = { scope: that, method: callback };\r\n            connection._.invocationCallbackId += 1;\r\n\r\n            if (!$.isEmptyObject(that.state)) {\r\n                data.S = that.state;\r\n            }\r\n\r\n            connection.log("Invoking " + that.hubName + "." + methodName);\r\n            connection.send(data);\r\n\r\n            return d.promise();\r\n        },\r\n\r\n        _maximizeHubResponse: function (minHubResponse) {\r\n            return {\r\n                State: minHubResponse.S,\r\n                Result: minHubResponse.R,\r\n                Progress: minHubResponse.P ? {\r\n                    Id: minHubResponse.P.I,\r\n                    Data: minHubResponse.P.D\r\n                } : null,\r\n                Id: minHubResponse.I,\r\n                IsHubException: minHubResponse.H,\r\n                Error: minHubResponse.E,\r\n                StackTrace: minHubResponse.T,\r\n                ErrorData: minHubResponse.D\r\n            };\r\n        }\r\n    };\r\n\r\n    hubProxy.fn.init.prototype = hubProxy.fn;\r\n\r\n    // hubConnection\r\n    function hubConnection(url, options) {\r\n        /// <summary>Creates a new hub connection.</summary>\r\n        /// <param name="url" type="String">[Optional] The hub route url, defaults to "/signalr".</param>\r\n        /// <param name="options" type="Object">[Optional] Settings to use when creating the hubConnection.</param>\r\n        var settings = {\r\n            qs: null,\r\n            logging: false,\r\n            useDefaultPath: true\r\n        };\r\n\r\n        $.extend(settings, options);\r\n\r\n        if (!url || settings.useDefaultPath) {\r\n            url = (url || "") + "/signalr";\r\n        }\r\n        return new hubConnection.fn.init(url, settings);\r\n    }\r\n\r\n    hubConnection.fn = hubConnection.prototype = $.connection();\r\n\r\n    hubConnection.fn.init = function (url, options) {\r\n        var settings = {\r\n                qs: null,\r\n                logging: false,\r\n                useDefaultPath: true\r\n            },\r\n            connection = this;\r\n\r\n        $.extend(settings, options);\r\n\r\n        // Call the base constructor\r\n        $.signalR.fn.init.call(connection, url, settings.qs, settings.logging);\r\n\r\n        // Object to store hub proxies for this connection\r\n        connection.proxies = {};\r\n\r\n        connection._.invocationCallbackId = 0;\r\n        connection._.invocationCallbacks = {};\r\n\r\n        // Wire up the received handler\r\n        connection.received(function (minData) {\r\n            var data, proxy, dataCallbackId, callback, hubName, eventName;\r\n            if (!minData) {\r\n                return;\r\n            }\r\n\r\n            // We have to handle progress updates first in order to ensure old clients that receive\r\n            // progress updates enter the return value branch and then no-op when they can\'t find\r\n            // the callback in the map (because the minData.I value will not be a valid callback ID)\r\n            if (typeof (minData.P) !== "undefined") {\r\n                // Process progress notification\r\n                dataCallbackId = minData.P.I.toString();\r\n                callback = connection._.invocationCallbacks[dataCallbackId];\r\n                if (callback) {\r\n                    callback.method.call(callback.scope, minData);\r\n                }\r\n            } else if (typeof (minData.I) !== "undefined") {\r\n                // We received the return value from a server method invocation, look up callback by id and call it\r\n                dataCallbackId = minData.I.toString();\r\n                callback = connection._.invocationCallbacks[dataCallbackId];\r\n                if (callback) {\r\n                    // Delete the callback from the proxy\r\n                    connection._.invocationCallbacks[dataCallbackId] = null;\r\n                    delete connection._.invocationCallbacks[dataCallbackId];\r\n\r\n                    // Invoke the callback\r\n                    callback.method.call(callback.scope, minData);\r\n                }\r\n            } else {\r\n                data = this._maximizeClientHubInvocation(minData);\r\n\r\n                // We received a client invocation request, i.e. broadcast from server hub\r\n                connection.log("Triggering client hub event \'" + data.Method + "\' on hub \'" + data.Hub + "\'.");\r\n\r\n                // Normalize the names to lowercase\r\n                hubName = data.Hub.toLowerCase();\r\n                eventName = data.Method.toLowerCase();\r\n\r\n                // Trigger the local invocation event\r\n                proxy = this.proxies[hubName];\r\n\r\n                // Update the hub state\r\n                $.extend(proxy.state, data.State);\r\n                $(proxy).triggerHandler(makeEventName(eventName), [data.Args]);\r\n            }\r\n        });\r\n\r\n        connection.error(function (errData, origData) {\r\n            var callbackId, callback;\r\n\r\n            if (!origData) {\r\n                // No original data passed so this is not a send error\r\n                return;\r\n            }\r\n\r\n            callbackId = origData.I;\r\n            callback = connection._.invocationCallbacks[callbackId];\r\n\r\n            // Verify that there is a callback bound (could have been cleared)\r\n            if (callback) {\r\n                // Delete the callback\r\n                connection._.invocationCallbacks[callbackId] = null;\r\n                delete connection._.invocationCallbacks[callbackId];\r\n\r\n                // Invoke the callback with an error to reject the promise\r\n                callback.method.call(callback.scope, { E: errData });\r\n            }\r\n        });\r\n\r\n        connection.reconnecting(function () {\r\n            if (connection.transport && connection.transport.name === "webSockets") {\r\n                clearInvocationCallbacks(connection, "Connection started reconnecting before invocation result was received.");\r\n            }\r\n        });\r\n\r\n        connection.disconnected(function () {\r\n            clearInvocationCallbacks(connection, "Connection was disconnected before invocation result was received.");\r\n        });\r\n    };\r\n\r\n    hubConnection.fn._maximizeClientHubInvocation = function (minClientHubInvocation) {\r\n        return {\r\n            Hub: minClientHubInvocation.H,\r\n            Method: minClientHubInvocation.M,\r\n            Args: minClientHubInvocation.A,\r\n            State: minClientHubInvocation.S\r\n        };\r\n    };\r\n\r\n    hubConnection.fn._registerSubscribedHubs = function () {\r\n        /// <summary>\r\n        ///     Sets the starting event to loop through the known hubs and register any new hubs\r\n        ///     that have been added to the proxy.\r\n        /// </summary>\r\n        var connection = this;\r\n\r\n        if (!connection._subscribedToHubs) {\r\n            connection._subscribedToHubs = true;\r\n            connection.starting(function () {\r\n                // Set the connection\'s data object with all the hub proxies with active subscriptions.\r\n                // These proxies will receive notifications from the server.\r\n                var subscribedHubs = [];\r\n\r\n                $.each(connection.proxies, function (key) {\r\n                    if (this.hasSubscriptions()) {\r\n                        subscribedHubs.push({ name: key });\r\n                        connection.log("Client subscribed to hub \'" + key + "\'.");\r\n                    }\r\n                });\r\n\r\n                if (subscribedHubs.length === 0) {\r\n                    connection.log("No hubs have been subscribed to.  The client will not receive data from hubs.  To fix, declare at least one client side function prior to connection start for each hub you wish to subscribe to.");\r\n                }\r\n\r\n                connection.data = connection.json.stringify(subscribedHubs);\r\n            });\r\n        }\r\n    };\r\n\r\n    hubConnection.fn.createHubProxy = function (hubName) {\r\n        /// <summary>\r\n        ///     Creates a new proxy object for the given hub connection that can be used to invoke\r\n        ///     methods on server hubs and handle client method invocation requests from the server.\r\n        /// </summary>\r\n        /// <param name="hubName" type="String">\r\n        ///     The name of the hub on the server to create the proxy for.\r\n        /// </param>\r\n\r\n        // Normalize the name to lowercase\r\n        hubName = hubName.toLowerCase();\r\n\r\n        var proxy = this.proxies[hubName];\r\n        if (!proxy) {\r\n            proxy = hubProxy(this, hubName);\r\n            this.proxies[hubName] = proxy;\r\n        }\r\n\r\n        this._registerSubscribedHubs();\r\n\r\n        return proxy;\r\n    };\r\n\r\n    hubConnection.fn.init.prototype = hubConnection.fn;\r\n\r\n    $.hubConnection = hubConnection;\r\n\r\n}(window.jQuery, window));\r\n/* jquery.signalR.version.js */\r\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\n\r\n/*global window:false */\r\n/// <reference path="jquery.signalR.core.js" />\r\n(function ($, undefined) {\r\n    $.signalR.version = "2.2.2-pre";\r\n}(window.jQuery));\r\n';
    loader.global.define = undefined;
    loader.global.module = undefined;
    loader.global.exports = undefined;
    loader.__exec({
        'source': source,
        'address': module.uri
    });
    loader.global.require = require;
    loader.global.define = define;
    return loader.get('@@global-helpers').retrieveGlobal(module.id, undefined);
});
/*can-connect-signalr@0.2.0#can-connect-signalr*/
define('can-connect-signalr@0.2.0#can-connect-signalr', function (require, exports, module) {
    var connect = require('can-connect');
    var $ = require('jquery');
    require('ms-signalr-client');
    var camelCase = function (str) {
        return str[0].toLowerCase() + str.substr(1);
    };
    module.exports = connect.behavior('can-connect-signalr', function signalR(baseConnection) {
        return {
            init: function () {
                if (!this.signalR.url) {
                    throw new Error('Invalid SignalR Hub URL. URL cannot be blank.');
                }
                if (!this.signalR.name) {
                    throw new Error('Invalid SignalR Hub name. Hub name cannot be blank.');
                }
                baseConnection.init.apply(this, arguments);
                var context = this;
                this.signalR.ready = new Promise(function (resolve, reject) {
                    var signalR = context.signalR;
                    var name = signalR.name.toLowerCase();
                    signalR.connection = $.hubConnection(signalR.url);
                    signalR.proxy = signalR.connection.createHubProxy(signalR.name);
                    signalR.proxy.on(signalR.createdName || name + 'Created', function (item) {
                        context.createInstance(item);
                    });
                    signalR.proxy.on(signalR.updatedName || name + 'Updated', function (item) {
                        context.updateInstance(item);
                    });
                    signalR.proxy.on(signalR.destroyedName || name + 'Destroyed', function (item) {
                        context.destroyInstance(item);
                    });
                    signalR.connection.start().done(function () {
                        console.log('Connected: ' + signalR.connection.id);
                        resolve(signalR);
                    }).fail(reject);
                });
            },
            createData: function (props) {
                return this.signalR.ready.then(function (signalR) {
                    return signalR.proxy.invoke(signalR.createName || camelCase(signalR.name) + 'Create', props);
                });
            },
            updateData: function (props) {
                return this.signalR.ready.then(function (signalR) {
                    return signalR.proxy.invoke(signalR.updateName || camelCase(signalR.name) + 'Update', props);
                });
            },
            destroyData: function (props) {
                return this.signalR.ready.then(function (signalR) {
                    return signalR.proxy.invoke(signalR.destroyName || camelCase(signalR.name) + 'Destroy', props);
                });
            },
            getListData: function (set) {
                return this.signalR.ready.then(function (signalR) {
                    return signalR.proxy.invoke(signalR.getListDataName || camelCase(signalR.name) + 'GetListData', set);
                });
            },
            get: function (set) {
                return this.signalR.ready.then(function (signalR) {
                    return signalR.proxy.invoke(signalR.getDataName || camelCase(signalR.name) + 'GetData', set);
                });
            }
        };
    });
});
/*can-connect-signalr@0.2.0#test*/
define('can-connect-signalr@0.2.0#test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var connect = require('can-connect');
    var dataParse = require('can-connect/data/parse/parse');
    var constructor = require('can-connect/constructor/constructor');
    var constructorStore = require('can-connect/constructor/store/store');
    var canMap = require('can-connect/can/map/map');
    var dataCallbacks = require('can-connect/data/callbacks/callbacks');
    var realTime = require('can-connect/real-time/real-time');
    var constructorCallbacksOnce = require('can-connect/constructor/callbacks-once/callbacks-once');
    var DefineMap = require('can-define/map/map');
    var DefineList = require('can-define/list/list');
    var signalR = require('./can-connect-signalr');
    var $ = require('jquery');
    $.hubConnection = function () {
        return {
            id: 2228271782,
            createHubProxy: function createHubProxy() {
                return {
                    on: function on() {
                    },
                    invoke: function invoke(methodName) {
                        var promise;
                        switch (methodName) {
                        case 'messageGetListData':
                            promise = new Promise(function (resolve, reject) {
                                resolve([{ data: [testData] }]);
                            });
                            break;
                        case 'messageGetData':
                            promise = new Promise(function (resolve, reject) {
                                resolve(testData);
                            });
                            break;
                        case 'messageUpdate':
                            promise = new Promise(function (resolve, reject) {
                                testData.text = 'Hello!';
                                resolve(testData);
                            });
                            break;
                        default:
                            promise = new Promise(function (resolve, reject) {
                                resolve(testData);
                            });
                            break;
                        }
                        return promise;
                    }
                };
            },
            start: function start() {
                return {
                    done: function done(fn) {
                        fn();
                    }
                };
            }
        };
    };
    var Message = DefineMap.extend({
        text: 'string',
        id: 'number'
    });
    Message.List = DefineList.extend({ '#': Message });
    var testData = {
        'text': 'this',
        'id': 1
    };
    QUnit.module('can-connect-signalr', {
        beforeEach: function () {
            var behaviors = [
                dataParse,
                constructor,
                constructorStore,
                canMap,
                dataCallbacks,
                realTime,
                constructorCallbacksOnce,
                signalR
            ];
            Message.connection = connect(behaviors, {
                Map: Message,
                List: Message.List,
                signalR: {
                    url: 'http://test.com',
                    name: 'Message'
                }
            });
        }
    });
    QUnit.test('Plugin initializes correctly', function () {
        QUnit.equal(Message.connection.__behaviorName, 'can-connect-signalr');
    });
    QUnit.test('getList', function (assert) {
        var done = assert.async();
        Message.getList({}).then(function (messages) {
            assert.ok(messages, 'Got a response from findAll');
            assert.equal(messages instanceof Message.List, true, 'got a Message.List back');
            done();
        });
    });
    QUnit.test('get', function (assert) {
        var done = assert.async();
        Message.get().then(function (messages) {
            assert.ok(messages, 'Got a response from findOne');
            done();
        });
    });
    QUnit.test('create', function (assert) {
        var done = assert.async();
        var message = new Message({ text: 'Hi there!' });
        message.save().then(function (msg) {
            assert.ok(msg);
            done();
        });
    });
    QUnit.test('update', function (assert) {
        var done = assert.async();
        var message = new Message({ text: 'Hi there!' });
        message.save().then(function (msg) {
            msg.text = 'Hello!';
            msg.save().then(function (saveResponse) {
                assert.equal(saveResponse.text, 'Hello!', 'message text updated correctly');
                done();
            });
        });
    });
    QUnit.test('destroy', function (assert) {
        var done = assert.async();
        var message = new Message({ text: 'Hi there!' });
        message.save().then(function (msg) {
            var id = msg._id;
            msg.destroy().then(function (res) {
                assert.equal(res._id, id, 'deleted the instance');
                done();
            });
        });
    });
});
/*can-connect@1.5.3#helpers/get-id-props*/
define('can-connect@1.5.3#helpers/get-id-props', function (require, exports, module) {
    module.exports = function (connection) {
        var ids = [], algebra = connection.algebra;
        if (algebra && algebra.clauses && algebra.clauses.id) {
            for (var prop in algebra.clauses.id) {
                ids.push(prop);
            }
        }
        if (connection.idProp && !ids.length) {
            ids.push(connection.idProp);
        }
        if (!ids.length) {
            ids.push('id');
        }
        return ids;
    };
});
/*can-connect-cloneable@0.2.0#can-connect-cloneable*/
define('can-connect-cloneable@0.2.0#can-connect-cloneable', function (require, exports, module) {
    var each = require('can-util/js/each/each');
    var deepAssign = require('can-util/js/deep-assign/deep-assign');
    var assign = require('can-util/js/assign/assign');
    var getIdProps = require('can-connect/helpers/get-id-props');
    module.exports = function makeClone(Type) {
        var idProp = getIdProps(Type.connection)[0];
        var definition = {
            save: function () {
                var data = this.serialize();
                delete data._original;
                if (this._original[idProp]) {
                    data[idProp] = this._original[idProp];
                    return this._original.constructor.connection.updateData(data).then(function () {
                        Type.connection.updatedInstance(this._original, data);
                    }.bind(this));
                } else {
                    return this._original.constructor.connection.createData(data).then(function (res) {
                        Type.connection.createdInstance(this._original, deepAssign({}, data, res));
                    }.bind(this));
                }
            }
        };
        if (Type.prototype.hasOwnProperty('_define')) {
            each(Type.prototype._define.definitions, function (def, prop) {
                definition[prop] = assign(assign({}, def), {
                    get: def.get || function (lastSet) {
                        return lastSet !== undefined ? lastSet : this._original[prop];
                    },
                    serialize: def.serialize === undefined ? def.get ? false : true : def.serialize
                });
            });
            deepAssign(definition, { _original: { Type: Type } });
        } else {
            definition.define = {};
            each(Type.prototype.define, function (def, prop) {
                definition.define[prop] = assign(assign({}, def), {
                    get: def.get || function (lastSet) {
                        return lastSet !== undefined ? lastSet : this._original[prop];
                    },
                    serialize: def.serialize === undefined ? def.get ? false : true : def.serialize
                });
            });
            deepAssign(definition, { define: { _original: { Type: Type } } });
        }
        delete definition[idProp];
        var Clone = Type.extend(definition);
        Type.prototype.clone = function clone() {
            var props = {};
            props._original = this;
            return new Clone(props);
        };
    };
});
/*can-make-rest@0.1.1#can-make-rest*/
define('can-make-rest@0.1.1#can-make-rest', function (require, exports, module) {
    var each = require('can-util/js/each/each');
    var methodMapping = {
        item: {
            'GET': 'getData',
            'PUT': 'updateData',
            'DELETE': 'destroyData'
        },
        list: {
            'GET': 'getListData',
            'POST': 'createData'
        }
    };
    function inferIdProp(url) {
        var wrappedInBraces = /\{(.*)\}/;
        var matches = url.match(wrappedInBraces);
        var isUniqueMatch = matches && matches.length === 2;
        if (isUniqueMatch) {
            return matches[1];
        }
    }
    function getItemAndListUrls(url, idProp) {
        idProp = idProp || inferIdProp(url) || 'id';
        var itemRegex = new RegExp('\\/\\{' + idProp + '\\}.*');
        var rootIsItemUrl = itemRegex.test(url);
        var listUrl = rootIsItemUrl ? url.replace(itemRegex, '') : url;
        var itemUrl = rootIsItemUrl ? url : url.trim() + '/{' + idProp + '}';
        return {
            item: itemUrl,
            list: listUrl
        };
    }
    module.exports = function (url, idProp) {
        var data = {};
        each(getItemAndListUrls(url, idProp), function (url, type) {
            each(methodMapping[type], function (interfaceMethod, method) {
                data[interfaceMethod] = {
                    method: method,
                    url: url
                };
            });
        });
        return data;
    };
});
/*can-connect@1.5.3#data/url/url*/
define('can-connect@1.5.3#data/url/url', function (require, exports, module) {
    var isArray = require('can-util/js/is-array/is-array');
    var assign = require('can-util/js/assign/assign');
    var each = require('can-util/js/each/each');
    var ajax = require('can-util/dom/ajax/ajax');
    var string = require('can-util/js/string/string');
    var getIdProps = require('../../helpers/get-id-props');
    var dev = require('can-util/js/dev/dev');
    var connect = require('can-connect');
    var makeRest = require('can-make-rest');
    var defaultRest = makeRest('/resource/{id}');
    var makePromise = require('can-util/js/make-promise/make-promise');
    var urlBehavior = connect.behavior('data/url', function (baseConnection) {
        var behavior = {};
        each(defaultRest, function (defaultData, dataInterfaceName) {
            behavior[dataInterfaceName] = function (params) {
                var meta = methodMetaData[dataInterfaceName];
                if (typeof this.url === 'object') {
                    if (typeof this.url[dataInterfaceName] === 'function') {
                        return makePromise(this.url[dataInterfaceName](params));
                    } else if (this.url[dataInterfaceName]) {
                        var promise = makeAjax(this.url[dataInterfaceName], params, defaultData.method, this.ajax || ajax, findContentType(this.url, defaultData.method), meta);
                        return makePromise(promise);
                    }
                }
                var resource = typeof this.url === 'string' ? this.url : this.url.resource;
                if (resource) {
                    var idProps = getIdProps(this);
                    var resourceWithoutTrailingSlashes = resource.replace(/\/+$/, '');
                    var result = makeRest(resourceWithoutTrailingSlashes, idProps[0])[dataInterfaceName];
                    return makePromise(makeAjax(result.url, params, result.method, this.ajax || ajax, findContentType(this.url, result.method), meta));
                }
                return baseConnection[name].call(this, params);
            };
        });
        return behavior;
    });
    var methodMetaData = {
        getListData: {},
        getData: {},
        createData: {},
        updateData: {},
        destroyData: { includeData: false }
    };
    var findContentType = function (url, method) {
        if (typeof url === 'object' && url.contentType) {
            var acceptableType = url.contentType === 'application/x-www-form-urlencoded' || url.contentType === 'application/json';
            if (acceptableType) {
                return url.contentType;
            } else {
            }
        }
        return method === 'GET' ? 'application/x-www-form-urlencoded' : 'application/json';
    };
    var makeAjax = function (ajaxOb, data, type, ajax, contentType, reqOptions) {
        var params = {};
        if (typeof ajaxOb === 'string') {
            var parts = ajaxOb.split(/\s+/);
            params.url = parts.pop();
            if (parts.length) {
                params.type = parts.pop();
            }
        } else {
            assign(params, ajaxOb);
        }
        params.data = typeof data === 'object' && !isArray(data) ? assign(params.data || {}, data) : data;
        params.url = string.sub(params.url, params.data, true);
        params.contentType = contentType;
        if (reqOptions.includeData === false) {
            delete params.data;
        }
        return ajax(assign({
            type: type || 'post',
            dataType: 'json'
        }, params));
    };
    module.exports = urlBehavior;
});
/*can-connect-cloneable@0.2.0#can-connect-cloneable_test*/
define('can-connect-cloneable@0.2.0#can-connect-cloneable_test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var makeCloneable = require('can-connect-cloneable');
    var DefineMap = require('can-define/map/map');
    require('can-define/list/list');
    var CanMap = require('can-map');
    require('can-map-define');
    require('can-list');
    var fixture = require('can-fixture');
    var connect = require('can-connect');
    var ConnectDataUrl = require('can-connect/data/url/url');
    var ConnectConstructor = require('can-connect/constructor/constructor');
    var ConnectCanMap = require('can-connect/can/map/map');
    QUnit.module('can-connect-cloneable');
    QUnit.test('Initialized the plugin', function () {
        QUnit.equal(typeof makeCloneable, 'function');
    });
    QUnit.module('can-connect-cloneable with DefineMap', {
        beforeEach: function (assert) {
            fixture('POST /test', { id: 1 });
            fixture('PUT /test/1', {});
            this.runSetterAssertions = false;
            var self = this;
            this.CloneableDefineMap = DefineMap.extend({
                info: {
                    get: function () {
                        return this.name + ' is ' + this.age;
                    }
                },
                age: {
                    value: 30,
                    type: 'number',
                    set: function (age) {
                        if (self.runSetterAssertions) {
                            assert.ok(true, 'setter ran');
                        }
                        return age;
                    }
                },
                name: {},
                id: {}
            });
            var connection = connect([
                ConnectDataUrl,
                ConnectConstructor,
                ConnectCanMap
            ], {
                idProp: 'id',
                Map: this.CloneableDefineMap,
                url: '/test'
            });
            this.CloneableDefineMap.connection = connection;
            makeCloneable(this.CloneableDefineMap);
        }
    });
    QUnit.test('Initialization', function () {
        var noncloneableMap = new DefineMap({});
        var cloneableMap = new this.CloneableDefineMap({});
        var clone = cloneableMap.clone();
        QUnit.ok(!noncloneableMap.constructor.prototype.hasOwnProperty('clone'), 'base Map does not have a clone method');
        QUnit.ok(cloneableMap.constructor.prototype.hasOwnProperty('clone'), 'cloneableMap has a clone method');
        QUnit.notEqual(cloneableMap, clone, 'Clone is not the same instance');
    });
    QUnit.test('Saving an original without an ID does a create', function (assert) {
        var done = assert.async();
        var map = new this.CloneableDefineMap({ name: 'Kyle' });
        var clone = map.clone();
        clone.name = 'Justin';
        QUnit.equal(map.name, 'Kyle', 'original\'s name is still Kyle');
        QUnit.equal(clone.name, 'Justin', 'clone\'s name is now Justin');
        clone.save().then(function () {
            QUnit.equal(map.name, 'Justin', 'original\'s name changed to Justin');
            QUnit.equal(clone.name, 'Justin', 'clone\'s name is still Justin');
            QUnit.ok(!map.hasOwnProperty('_original'), 'original does not have the _original attribute');
            QUnit.equal(map.id, 1, 'original receives an ID');
            QUnit.equal(clone.id, undefined, 'clone still does not have an ID until saving');
            done();
        });
    });
    QUnit.test('Saving updates the original', function (assert) {
        var done = assert.async();
        var map = new this.CloneableDefineMap({
            name: 'Kyle',
            id: 1
        });
        var clone = map.clone();
        clone.name = 'Justin';
        QUnit.equal(map.name, 'Kyle', 'original\'s name is still Kyle');
        QUnit.equal(clone.name, 'Justin', 'clone\'s name is now Justin');
        clone.save().then(function () {
            QUnit.equal(map.name, 'Justin', 'original\'s name changed to Justin');
            QUnit.equal(clone.name, 'Justin', 'clone\'s name is still Justin');
            QUnit.ok(!map.hasOwnProperty('_original'), 'original does not have the _original attribute');
            done();
        });
    });
    QUnit.test('Property changes from the original push to the clone', function () {
        var map = new this.CloneableDefineMap({
            name: 'Kyle',
            id: 1
        });
        var clone = map.clone();
        QUnit.equal(clone.name, 'Kyle', 'clone\'s name has the value of original');
        map.name = 'Justin';
        QUnit.equal(clone.name, 'Justin', 'clone\'s name changes when original\'s name changes');
    });
    QUnit.test('Getters/Setters/type transfers to the clone', 5, function (assert) {
        this.runSetterAssertions = true;
        var map = new this.CloneableDefineMap({
            name: 'Kyle',
            id: 1
        });
        var clone = map.clone();
        assert.equal(clone.info, 'Kyle is 30');
        clone.age = '32';
        assert.ok(clone.age === 32, 'type applied');
        assert.equal(clone.info, 'Kyle is 32', 'getter applied');
    });
    QUnit.module('can-connect-cloneable with CanMap', {
        beforeEach: function (assert) {
            fixture('POST /test', { id: 1 });
            fixture('PUT /test/1', {});
            this.runSetterAssertions = false;
            var self = this;
            this.CloneableCanMap = CanMap.extend({
                define: {
                    info: {
                        get: function () {
                            return this.attr('name') + ' is ' + this.attr('age');
                        }
                    },
                    age: {
                        value: 30,
                        type: 'number',
                        set: function (age) {
                            if (self.runSetterAssertions) {
                                assert.ok(true, 'setter ran');
                            }
                            return age;
                        }
                    },
                    name: {}
                }
            });
            var connection = connect([
                ConnectDataUrl,
                ConnectConstructor,
                ConnectCanMap
            ], {
                idProp: 'id',
                Map: this.CloneableCanMap,
                url: '/test'
            });
            this.CloneableCanMap.connection = connection;
            makeCloneable(this.CloneableCanMap);
        }
    });
    QUnit.test('Initialization', function () {
        var noncloneableMap = new CanMap({});
        var cloneableMap = new this.CloneableCanMap({});
        var clone = cloneableMap.clone();
        QUnit.ok(!noncloneableMap.constructor.prototype.hasOwnProperty('clone'), 'base Map does not have a clone method');
        QUnit.ok(cloneableMap.constructor.prototype.hasOwnProperty('clone'), 'cloneableMap has a clone method');
        QUnit.notEqual(cloneableMap, clone, 'Clone is not the same instance');
    });
    QUnit.test('Cloning an original without an ID does a create', function (assert) {
        var done = assert.async();
        var map = new this.CloneableCanMap({ name: 'Kyle' });
        var clone = map.clone();
        clone.attr('name', 'Justin');
        QUnit.equal(map.attr('name'), 'Kyle', 'original\'s name is still Kyle');
        QUnit.equal(clone.attr('name'), 'Justin', 'clone\'s name is now Justin');
        clone.save().then(function () {
            QUnit.equal(map.attr('name'), 'Justin', 'original\'s name changed to Justin');
            QUnit.equal(clone.attr('name'), 'Justin', 'clone\'s name is still Justin');
            QUnit.ok(!map.hasOwnProperty('_original'), 'original does not have the _original attribute');
            QUnit.equal(map.attr('id'), 1, 'original receives an ID');
            QUnit.equal(clone.attr('id'), undefined, 'clone still does not have an ID until saving');
            done();
        });
    });
    QUnit.test('Saving updates the original', function (assert) {
        var done = assert.async();
        var map = new this.CloneableCanMap({
            name: 'Kyle',
            id: 1
        });
        var clone = map.clone();
        clone.attr('name', 'Justin');
        QUnit.equal(map.attr('name'), 'Kyle', 'original\'s name is still Kyle');
        QUnit.equal(clone.attr('name'), 'Justin', 'clone\'s name is now Justin');
        clone.save().then(function () {
            QUnit.equal(map.attr('name'), 'Justin', 'original\'s name changed to Justin');
            QUnit.equal(clone.attr('name'), 'Justin', 'clone\'s name is still Justin');
            QUnit.ok(!map.hasOwnProperty('_original'), 'original does not have the _original attribute');
            done();
        });
    });
    QUnit.test('Property changes from the original push to the clone', function () {
        var map = new this.CloneableCanMap({
            name: 'Kyle',
            id: 1
        });
        var clone = map.clone();
        QUnit.equal(clone.attr('name'), 'Kyle', 'clone\'s name has the value of original');
        map.attr('name', 'Justin');
        QUnit.equal(clone.attr('name'), 'Justin', 'clone\'s name changes when original\'s name changes');
    });
    QUnit.test('Define plugin configuration transfers to the clone', 5, function (assert) {
        this.runSetterAssertions = true;
        var map = new this.CloneableCanMap({
            name: 'Kyle',
            id: 1
        });
        var clone = map.clone();
        clone.attr('age', '32');
        assert.ok(clone.attr('age') === 32, 'type applied');
        assert.equal(clone.attr('info'), 'Kyle is 32', 'getter applied');
    });
});
/*can-connect-cloneable@0.2.0#test/test*/
define('can-connect-cloneable@0.2.0#test/test', ['../can-connect-cloneable_test'], function () {
    'use strict';
});
/*can-stream@0.3.1#can-stream*/
define('can-stream@0.3.1#can-stream', function (require, exports, module) {
    var namespace = require('can-util/namespace');
    var compute = require('can-compute');
    var makeArray = require('can-util/js/make-array/make-array');
    var assign = require('can-util/js/assign/assign');
    var toComputeFromEvent = function (observable, eventName) {
        var handler, lastSet;
        return compute(undefined, {
            on: function (updated) {
                handler = function (ev, val) {
                    lastSet = assign({ args: [].slice.call(arguments, 1) }, ev);
                    updated();
                };
                observable.on(eventName, handler);
            },
            off: function (updated) {
                observable.off(eventName, handler);
                lastSet = undefined;
            },
            get: function () {
                return lastSet;
            }
        });
    };
    var STREAM = function (canStreamInterface) {
        var canStream;
        var toStreamFromProperty = function (obs, propName) {
            return canStreamInterface.toStream(compute(obs, propName));
        };
        var toStreamFromEvent = function () {
            var obs = arguments[0];
            var eventName, propName, lastValue, internalCompute;
            if (arguments.length === 2) {
                internalCompute = toComputeFromEvent(obs, arguments[1]);
                return canStreamInterface.toStream(internalCompute);
            } else {
                propName = arguments[1];
                eventName = arguments[2];
                lastValue = obs[propName];
                var valuePropCompute = compute(obs, propName);
                var eventHandler;
                var propChangeHandler;
                internalCompute = compute(undefined, {
                    on: function (updater) {
                        eventHandler = function (ev, newVal, oldVal) {
                            lastValue = newVal;
                            updater(lastValue);
                        };
                        propChangeHandler = function (ev, newVal, oldVal) {
                            oldVal.off(eventName, eventHandler);
                            newVal.on(eventName, eventHandler);
                        };
                        valuePropCompute.on('change', propChangeHandler);
                        valuePropCompute().on(eventName, eventHandler);
                    },
                    off: function () {
                        valuePropCompute().off(eventName, eventHandler);
                        valuePropCompute.off('change', propChangeHandler);
                    },
                    get: function () {
                        return lastValue;
                    },
                    set: function (val) {
                        throw new Error('can-stream: you can\'t set this type of compute');
                    }
                });
                var stream = canStreamInterface.toStream(internalCompute);
                return stream;
            }
        };
        var toStream = function () {
            if (arguments.length === 1) {
                return canStreamInterface.toStream(arguments[0]);
            } else if (arguments.length > 1) {
                var obs = arguments[0];
                var eventNameOrPropName = arguments[1].trim();
                if (eventNameOrPropName.indexOf(' ') === -1) {
                    if (eventNameOrPropName.indexOf('.') === 0) {
                        return canStream.toStreamFromProperty(obs, eventNameOrPropName.slice(1));
                    } else {
                        return canStream.toStreamFromEvent(obs, eventNameOrPropName);
                    }
                } else {
                    var splitEventNameAndProperty = eventNameOrPropName.split(' ');
                    return canStream.toStreamFromEvent(obs, splitEventNameAndProperty[0].slice(1), splitEventNameAndProperty[1]);
                }
            }
            return undefined;
        };
        var toCompute = function (makeStream, context) {
            var args = makeArray(arguments);
            return canStreamInterface.toCompute.apply(this, args);
        };
        canStream = toStream;
        canStream.toStream = canStream;
        canStream.toStreamFromProperty = toStreamFromProperty;
        canStream.toStreamFromEvent = toStreamFromEvent;
        canStream.toCompute = toCompute;
        return canStream;
    };
    STREAM.toComputeFromEvent = toComputeFromEvent;
    module.exports = namespace.stream = STREAM;
});
/*can-stream@0.3.1#can-stream_test*/
define('can-stream@0.3.1#can-stream_test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var compute = require('can-compute');
    var DefineMap = require('can-define/map/map');
    var DefineList = require('can-define/list/list');
    var canStream = require('can-stream');
    QUnit.module('can-stream');
    test('Resolves to "toStream" function', function () {
        var c = compute(0);
        var obj;
        var streamInterface;
        var streamImplementation = {
            toStream: function (observable, propOrEvent) {
                QUnit.equal(c, observable);
                return obj = {
                    onValue: function (callback) {
                        c.on('change', function (evnt, newVal, oldVal) {
                            callback(newVal);
                        });
                        callback(c());
                    }
                };
            },
            toCompute: function (makeStream, context) {
            }
        };
        streamInterface = canStream(streamImplementation);
        var stream = streamInterface(c);
        QUnit.equal(obj, stream);
    });
    test('Compute changes can be streamed', function () {
        var c = compute(0);
        var obj;
        var canStreaming;
        var canStreamInterface = {
            toStream: function (observable, propOrEvent) {
                QUnit.equal(c, observable);
                return obj = {
                    onValue: function (callback) {
                        c.on('change', function (evnt, newVal, oldVal) {
                            callback(newVal);
                        });
                        callback(c());
                    }
                };
            },
            toCompute: function (makeStream, context) {
            }
        };
        canStreaming = canStream(canStreamInterface);
        var stream = canStreaming.toStream(c);
        QUnit.equal(obj, stream);
        var computeVal;
        stream.onValue(function (newVal) {
            computeVal = newVal;
        });
        QUnit.equal(computeVal, 0);
        c(1);
        QUnit.equal(computeVal, 1);
        c(2);
        QUnit.equal(computeVal, 2);
        c(3);
        QUnit.equal(computeVal, 3);
    });
    test('Compute streams do not bind to the compute unless activated', function () {
        var c = compute(0);
        var canStreamInterface = {
            toStream: function (observable, propOrEvent) {
                QUnit.equal(c, observable);
                var obj;
                return obj = {
                    onValue: function (callback) {
                        c.on('change', function (evnt, newVal, oldVal) {
                            callback(newVal);
                        });
                        callback(c());
                    }
                };
            },
            toCompute: function (makeStream, context) {
            }
        };
        var canStreaming = canStream(canStreamInterface);
        var stream = canStreaming.toStream(c);
        QUnit.equal(c.computeInstance.__bindEvents, undefined);
        stream.onValue(function () {
        });
        QUnit.equal(c.computeInstance.__bindEvents._lifecycleBindings, 1);
    });
    test('Stream on a property val - toStreamFromEvent', function () {
        var expected = 'bar';
        var MyMap = DefineMap.extend({ foo: { value: 'bar' } });
        var canStreamInterface = {
            toStream: function (c) {
                return {
                    onValue: function (callback) {
                        c.on('change', function () {
                            callback.apply(null, arguments);
                        });
                    }
                };
            },
            toCompute: function (makeStream, context) {
            }
        };
        var canStreaming = canStream(canStreamInterface);
        var map = new MyMap();
        var stream = canStreaming.toStream(map, '.foo');
        stream.onValue(function (ev, newVal, oldVal) {
            QUnit.equal(newVal, expected);
        });
        expected = 'foobar';
        map.foo = 'foobar';
    });
    test('Stream on a property val - toStreamFromProperty', function () {
        var expected = 'bar';
        var MyMap = DefineMap.extend({ foo: { value: 'bar' } });
        var canStreamInterface = {
            toStream: function (c) {
                return {
                    onValue: function (callback) {
                        c.on('change', function () {
                            callback.apply(null, arguments);
                        });
                    }
                };
            },
            toCompute: function (makeStream, context) {
            }
        };
        var canStreaming = canStream(canStreamInterface);
        var map = new MyMap();
        var stream = canStreaming.toStream(map, '.foo');
        stream.onValue(function (ev, val) {
            QUnit.equal(val, expected);
        });
        expected = 'foobar';
        map.foo = 'foobar';
    });
    test('Event streams fire change events', function () {
        var expected = 0;
        var MyMap = DefineMap.extend({
            fooList: {
                Type: DefineList.List,
                value: []
            }
        });
        var canStreamInterface = {
            toStream: function (c) {
                return {
                    onValue: function (callback) {
                        c.on('change', function (ev, newValue) {
                            callback.call(null, newValue);
                        });
                    }
                };
            },
            toCompute: function (makeStream, context) {
            }
        };
        var canStreaming = canStream(canStreamInterface);
        var map = new MyMap();
        var stream = canStreaming.toStream(map.fooList, 'length');
        stream.onValue(function (lengthEvent) {
            QUnit.equal(lengthEvent.type, 'length');
            QUnit.deepEqual(lengthEvent.args, expected, 'Event stream was updated with length: ' + map.fooList.length);
        });
        expected = [1];
        map.fooList.push(1);
        expected = [0];
        map.fooList.pop();
    });
    test('Event streams fire change event on a property', function () {
        var expected = 0;
        var MyMap = DefineMap.extend({
            fooList: {
                Type: DefineList.List,
                value: []
            }
        });
        var canStreamInterface = {
            toStream: function (c) {
                return {
                    onValue: function (callback) {
                        c.on('change', function () {
                            callback.apply(null, arguments);
                        });
                    }
                };
            },
            toCompute: function (makeStream, context) {
            }
        };
        var canStreaming = canStream(canStreamInterface);
        var map = new MyMap();
        var stream = canStreaming.toStream(map, '.fooList add');
        stream.onValue(function (ev, length, oldLength) {
            QUnit.equal(length, expected, 'Event stream was updated with length: ' + map.fooList.length);
        });
        expected = 1;
        map.fooList.push(1);
        expected = 0;
        map.fooList.pop();
    });
    test('Stream on a property val - toStreamFromEvent', function () {
        var MyMap = DefineMap.extend({ foo: { value: 'bar' } });
        var map = new MyMap();
        var canStreamInterface = {
            toStream: function (c) {
                return {
                    onValue: function (callback) {
                        c.on('change', function (ev, newVal) {
                            callback.call(null, newVal);
                        });
                    }
                };
            },
            toCompute: function (makeStream, context) {
            }
        };
        var canStreaming = canStream(canStreamInterface);
        var stream = canStreaming.toStream(map, 'foo');
        stream.onValue(function (fooEvent) {
            QUnit.equal(fooEvent.type, 'foo');
            QUnit.deepEqual(fooEvent.args, [
                'foobar',
                'bar'
            ]);
        });
        map.foo = 'foobar';
    });
    test('Convert an observable nested property into an event stream #2b', 2, function () {
        var MyMap = DefineMap.extend({
            foo: {
                value: function () {
                    return { bar: 1 };
                }
            }
        });
        var obs = new MyMap();
        var canStreamInterface = {
            toStream: function (c) {
                return {
                    onValue: function (callback) {
                        c.on('change', function (ev, newVal) {
                            callback.call(null, newVal);
                        });
                        callback(c());
                    }
                };
            },
            toCompute: function (makeStream, context) {
            }
        };
        var canStreaming = canStream(canStreamInterface);
        var stream = canStreaming.toStream(obs, '.foo.bar');
        var expected = 1;
        stream.onValue(function (barValue) {
            QUnit.equal(barValue, expected, 'value was ' + barValue);
        });
        expected = 2;
        obs.foo.bar = 2;
    });
    test('observable nested property event', 1, function () {
        var MyMap = DefineMap.extend({
            foo: {
                value: function () {
                    return { bar: 1 };
                }
            }
        });
        var obs = new MyMap();
        var canStreamInterface = {
            toStream: function (c) {
                var handler;
                return {
                    onValue: function (callback) {
                        handler = function () {
                            callback.apply(null, arguments);
                        };
                        c.on('change', handler);
                    },
                    offValue: function (callback) {
                        c.off('change', handler);
                    }
                };
            },
            toCompute: function (makeStream, context) {
            }
        };
        var canStreaming = canStream(canStreamInterface);
        var stream = canStreaming.toStream(obs, '.foo bar');
        var expected = 1;
        stream.onValue(function (barEvent, barValue) {
            QUnit.equal(barValue, expected, 'value was ' + barValue);
        });
        expected = 2;
        obs.foo.bar = 2;
    });
    test('Event streams fire change events on a property', function () {
        var expected = 0;
        var MyMap = DefineMap.extend({
            fooList: {
                Type: DefineList.List,
                value: []
            }
        });
        var map = new MyMap();
        var canStreamInterface = {
            toStream: function (c) {
                var handler;
                return {
                    onValue: function (callback) {
                        handler = function () {
                            callback.apply(null, arguments);
                        };
                        c.on('change', handler);
                    },
                    offValue: function (callback) {
                        c.off('change', handler);
                    }
                };
            },
            toCompute: function (makeStream, context) {
            }
        };
        var canStreaming = canStream(canStreamInterface);
        var stream = canStreaming.toStream(map, '.fooList length');
        var handler = function (ev, length, lastLength) {
            QUnit.equal(length, expected, 'Event stream was updated with length: ' + map.fooList.length);
        };
        stream.onValue(handler);
        expected = 1;
        map.fooList.push(1);
        expected = 2;
        map.fooList.push(2);
        expected = 1;
        map.fooList.pop();
        expected = 0;
        map.fooList = new DefineList([]);
        stream.offValue(handler);
    });
    test('Create a stream from a observable and event with shorthand method: toStream', function () {
        var expected = 0;
        var MyMap = DefineMap.extend({
            fooList: {
                Type: DefineList.List,
                value: []
            }
        });
        var map = new MyMap();
        var canStreamInterface = {
            toStream: function (c) {
                return {
                    onValue: function (callback) {
                        c.on('change', function () {
                            callback.apply(null, arguments);
                        });
                    }
                };
            },
            toCompute: function (makeStream, context) {
            }
        };
        var canStreaming = canStream(canStreamInterface);
        var stream = canStreaming.toStream(map.fooList, 'length');
        stream.onValue(function (ev) {
            QUnit.equal(map.fooList.length, expected, 'Event stream was updated with length: ' + map.fooList.length);
        });
        expected = 1;
        map.fooList.push(1);
        expected = 0;
        map.fooList.pop();
    });
    test('Create a stream from a observable and event on property with shorthand method: toStream', function () {
        var expected = 0;
        var MyMap = DefineMap.extend({
            fooList: {
                Type: DefineList.List,
                value: []
            }
        });
        var map = new MyMap();
        var canStreamInterface = {
            toStream: function (c) {
                return {
                    onValue: function (callback) {
                        c.on('change', function () {
                            callback.apply(null, arguments);
                        });
                    }
                };
            },
            toCompute: function (makeStream, context) {
            }
        };
        var canStreaming = canStream(canStreamInterface);
        var stream = canStreaming.toStream(map, '.fooList length');
        stream.onValue(function (ev) {
            QUnit.equal(map.fooList.length, expected, 'Event stream was updated with length: ' + map.fooList.length);
        });
        expected = 1;
        map.fooList.push(1);
        expected = 0;
        map.fooList.pop();
    });
    test('Update the list to undefined', function () {
        var expected = 0;
        var MyMap = DefineMap.extend({
            fooList: {
                Type: DefineList.List,
                value: []
            }
        });
        var map = new MyMap();
        var canStreamInterface = {
            toStream: function (c) {
                return {
                    onValue: function (callback) {
                        c.on('change', function () {
                            callback.apply(null, arguments);
                        });
                    }
                };
            },
            toCompute: function (makeStream, context) {
            }
        };
        var canStreaming = canStream(canStreamInterface);
        var stream = canStreaming.toStream(map, '.fooList.length');
        stream.onValue(function (ev, newVal) {
            QUnit.equal(newVal, expected, 'Setting fooList to null');
        });
        expected = undefined;
        map.fooList = null;
    });
    test('toStreamFromEvent passes event and other arguments', 3, function () {
        var myMap = new DefineMap({ prop: 'value' });
        var c = canStream.toComputeFromEvent(myMap, 'prop');
        c.on('change', function (ev, newVal) {
            QUnit.equal(newVal.type, 'prop');
            QUnit.deepEqual(newVal.args, [
                'VALUE',
                'value'
            ]);
        });
        QUnit.equal(c(), undefined, 'no value');
        myMap.prop = 'VALUE';
    });
});
/*kefir@3.7.2#dist/kefir*/
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define('kefir@3.7.2#dist/kefir', ['exports'], factory) : factory(global.Kefir = global.Kefir || {});
}(this, function (exports) {
    'use strict';
    function createObj(proto) {
        var F = function () {
        };
        F.prototype = proto;
        return new F();
    }
    function extend(target) {
        var length = arguments.length, i = void 0, prop = void 0;
        for (i = 1; i < length; i++) {
            for (prop in arguments[i]) {
                target[prop] = arguments[i][prop];
            }
        }
        return target;
    }
    function inherit(Child, Parent) {
        var length = arguments.length, i = void 0;
        Child.prototype = createObj(Parent.prototype);
        Child.prototype.constructor = Child;
        for (i = 2; i < length; i++) {
            extend(Child.prototype, arguments[i]);
        }
        return Child;
    }
    var NOTHING = ['<nothing>'];
    var END = 'end';
    var VALUE = 'value';
    var ERROR = 'error';
    var ANY = 'any';
    function concat(a, b) {
        var result = void 0, length = void 0, i = void 0, j = void 0;
        if (a.length === 0) {
            return b;
        }
        if (b.length === 0) {
            return a;
        }
        j = 0;
        result = new Array(a.length + b.length);
        length = a.length;
        for (i = 0; i < length; i++, j++) {
            result[j] = a[i];
        }
        length = b.length;
        for (i = 0; i < length; i++, j++) {
            result[j] = b[i];
        }
        return result;
    }
    function find(arr, value) {
        var length = arr.length, i = void 0;
        for (i = 0; i < length; i++) {
            if (arr[i] === value) {
                return i;
            }
        }
        return -1;
    }
    function findByPred(arr, pred) {
        var length = arr.length, i = void 0;
        for (i = 0; i < length; i++) {
            if (pred(arr[i])) {
                return i;
            }
        }
        return -1;
    }
    function cloneArray(input) {
        var length = input.length, result = new Array(length), i = void 0;
        for (i = 0; i < length; i++) {
            result[i] = input[i];
        }
        return result;
    }
    function remove(input, index) {
        var length = input.length, result = void 0, i = void 0, j = void 0;
        if (index >= 0 && index < length) {
            if (length === 1) {
                return [];
            } else {
                result = new Array(length - 1);
                for (i = 0, j = 0; i < length; i++) {
                    if (i !== index) {
                        result[j] = input[i];
                        j++;
                    }
                }
                return result;
            }
        } else {
            return input;
        }
    }
    function map(input, fn) {
        var length = input.length, result = new Array(length), i = void 0;
        for (i = 0; i < length; i++) {
            result[i] = fn(input[i]);
        }
        return result;
    }
    function forEach(arr, fn) {
        var length = arr.length, i = void 0;
        for (i = 0; i < length; i++) {
            fn(arr[i]);
        }
    }
    function fillArray(arr, value) {
        var length = arr.length, i = void 0;
        for (i = 0; i < length; i++) {
            arr[i] = value;
        }
    }
    function contains(arr, value) {
        return find(arr, value) !== -1;
    }
    function slide(cur, next, max) {
        var length = Math.min(max, cur.length + 1), offset = cur.length - length + 1, result = new Array(length), i = void 0;
        for (i = offset; i < length; i++) {
            result[i - offset] = cur[i];
        }
        result[length - 1] = next;
        return result;
    }
    function callSubscriber(type, fn, event) {
        if (type === ANY) {
            fn(event);
        } else if (type === event.type) {
            if (type === VALUE || type === ERROR) {
                fn(event.value);
            } else {
                fn();
            }
        }
    }
    function Dispatcher() {
        this._items = [];
        this._spies = [];
        this._inLoop = 0;
        this._removedItems = null;
    }
    extend(Dispatcher.prototype, {
        add: function (type, fn) {
            this._items = concat(this._items, [{
                    type: type,
                    fn: fn
                }]);
            return this._items.length;
        },
        remove: function (type, fn) {
            var index = findByPred(this._items, function (x) {
                return x.type === type && x.fn === fn;
            });
            if (this._inLoop !== 0 && index !== -1) {
                if (this._removedItems === null) {
                    this._removedItems = [];
                }
                this._removedItems.push(this._items[index]);
            }
            this._items = remove(this._items, index);
            return this._items.length;
        },
        addSpy: function (fn) {
            this._spies = concat(this._spies, [fn]);
            return this._spies.length;
        },
        removeSpy: function (fn) {
            this._spies = remove(this._spies, this._spies.indexOf(fn));
            return this._spies.length;
        },
        dispatch: function (event) {
            this._inLoop++;
            for (var i = 0, spies = this._spies; this._spies !== null && i < spies.length; i++) {
                spies[i](event);
            }
            for (var _i = 0, items = this._items; _i < items.length; _i++) {
                if (this._items === null) {
                    break;
                }
                if (this._removedItems !== null && contains(this._removedItems, items[_i])) {
                    continue;
                }
                callSubscriber(items[_i].type, items[_i].fn, event);
            }
            this._inLoop--;
            if (this._inLoop === 0) {
                this._removedItems = null;
            }
        },
        cleanup: function () {
            this._items = null;
            this._spies = null;
        }
    });
    function Observable() {
        this._dispatcher = new Dispatcher();
        this._active = false;
        this._alive = true;
        this._activating = false;
        this._logHandlers = null;
        this._spyHandlers = null;
    }
    extend(Observable.prototype, {
        _name: 'observable',
        _onActivation: function () {
        },
        _onDeactivation: function () {
        },
        _setActive: function (active) {
            if (this._active !== active) {
                this._active = active;
                if (active) {
                    this._activating = true;
                    this._onActivation();
                    this._activating = false;
                } else {
                    this._onDeactivation();
                }
            }
        },
        _clear: function () {
            this._setActive(false);
            this._dispatcher.cleanup();
            this._dispatcher = null;
            this._logHandlers = null;
        },
        _emit: function (type, x) {
            switch (type) {
            case VALUE:
                return this._emitValue(x);
            case ERROR:
                return this._emitError(x);
            case END:
                return this._emitEnd();
            }
        },
        _emitValue: function (value) {
            if (this._alive) {
                this._dispatcher.dispatch({
                    type: VALUE,
                    value: value
                });
            }
        },
        _emitError: function (value) {
            if (this._alive) {
                this._dispatcher.dispatch({
                    type: ERROR,
                    value: value
                });
            }
        },
        _emitEnd: function () {
            if (this._alive) {
                this._alive = false;
                this._dispatcher.dispatch({ type: END });
                this._clear();
            }
        },
        _on: function (type, fn) {
            if (this._alive) {
                this._dispatcher.add(type, fn);
                this._setActive(true);
            } else {
                callSubscriber(type, fn, { type: END });
            }
            return this;
        },
        _off: function (type, fn) {
            if (this._alive) {
                var count = this._dispatcher.remove(type, fn);
                if (count === 0) {
                    this._setActive(false);
                }
            }
            return this;
        },
        onValue: function (fn) {
            return this._on(VALUE, fn);
        },
        onError: function (fn) {
            return this._on(ERROR, fn);
        },
        onEnd: function (fn) {
            return this._on(END, fn);
        },
        onAny: function (fn) {
            return this._on(ANY, fn);
        },
        offValue: function (fn) {
            return this._off(VALUE, fn);
        },
        offError: function (fn) {
            return this._off(ERROR, fn);
        },
        offEnd: function (fn) {
            return this._off(END, fn);
        },
        offAny: function (fn) {
            return this._off(ANY, fn);
        },
        observe: function (observerOrOnValue, onError, onEnd) {
            var _this = this;
            var closed = false;
            var observer = !observerOrOnValue || typeof observerOrOnValue === 'function' ? {
                value: observerOrOnValue,
                error: onError,
                end: onEnd
            } : observerOrOnValue;
            var handler = function (event) {
                if (event.type === END) {
                    closed = true;
                }
                if (event.type === VALUE && observer.value) {
                    observer.value(event.value);
                } else if (event.type === ERROR && observer.error) {
                    observer.error(event.value);
                } else if (event.type === END && observer.end) {
                    observer.end(event.value);
                }
            };
            this.onAny(handler);
            return {
                unsubscribe: function () {
                    if (!closed) {
                        _this.offAny(handler);
                        closed = true;
                    }
                },
                get closed() {
                    return closed;
                }
            };
        },
        _ofSameType: function (A, B) {
            return A.prototype.getType() === this.getType() ? A : B;
        },
        setName: function (sourceObs, selfName) {
            this._name = selfName ? sourceObs._name + '.' + selfName : sourceObs;
            return this;
        },
        log: function () {
            var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.toString();
            var isCurrent = void 0;
            var handler = function (event) {
                var type = '<' + event.type + (isCurrent ? ':current' : '') + '>';
                if (event.type === END) {
                    console.log(name, type);
                } else {
                    console.log(name, type, event.value);
                }
            };
            if (this._alive) {
                if (!this._logHandlers) {
                    this._logHandlers = [];
                }
                this._logHandlers.push({
                    name: name,
                    handler: handler
                });
            }
            isCurrent = true;
            this.onAny(handler);
            isCurrent = false;
            return this;
        },
        offLog: function () {
            var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.toString();
            if (this._logHandlers) {
                var handlerIndex = findByPred(this._logHandlers, function (obj) {
                    return obj.name === name;
                });
                if (handlerIndex !== -1) {
                    this.offAny(this._logHandlers[handlerIndex].handler);
                    this._logHandlers.splice(handlerIndex, 1);
                }
            }
            return this;
        },
        spy: function () {
            var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.toString();
            var handler = function (event) {
                var type = '<' + event.type + '>';
                if (event.type === END) {
                    console.log(name, type);
                } else {
                    console.log(name, type, event.value);
                }
            };
            if (this._alive) {
                if (!this._spyHandlers) {
                    this._spyHandlers = [];
                }
                this._spyHandlers.push({
                    name: name,
                    handler: handler
                });
                this._dispatcher.addSpy(handler);
            }
            return this;
        },
        offSpy: function () {
            var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.toString();
            if (this._spyHandlers) {
                var handlerIndex = findByPred(this._spyHandlers, function (obj) {
                    return obj.name === name;
                });
                if (handlerIndex !== -1) {
                    this._dispatcher.removeSpy(this._spyHandlers[handlerIndex].handler);
                    this._spyHandlers.splice(handlerIndex, 1);
                }
            }
            return this;
        }
    });
    Observable.prototype.toString = function () {
        return '[' + this._name + ']';
    };
    function Stream() {
        Observable.call(this);
    }
    inherit(Stream, Observable, {
        _name: 'stream',
        getType: function () {
            return 'stream';
        }
    });
    function Property() {
        Observable.call(this);
        this._currentEvent = null;
    }
    inherit(Property, Observable, {
        _name: 'property',
        _emitValue: function (value) {
            if (this._alive) {
                this._currentEvent = {
                    type: VALUE,
                    value: value
                };
                if (!this._activating) {
                    this._dispatcher.dispatch({
                        type: VALUE,
                        value: value
                    });
                }
            }
        },
        _emitError: function (value) {
            if (this._alive) {
                this._currentEvent = {
                    type: ERROR,
                    value: value
                };
                if (!this._activating) {
                    this._dispatcher.dispatch({
                        type: ERROR,
                        value: value
                    });
                }
            }
        },
        _emitEnd: function () {
            if (this._alive) {
                this._alive = false;
                if (!this._activating) {
                    this._dispatcher.dispatch({ type: END });
                }
                this._clear();
            }
        },
        _on: function (type, fn) {
            if (this._alive) {
                this._dispatcher.add(type, fn);
                this._setActive(true);
            }
            if (this._currentEvent !== null) {
                callSubscriber(type, fn, this._currentEvent);
            }
            if (!this._alive) {
                callSubscriber(type, fn, { type: END });
            }
            return this;
        },
        getType: function () {
            return 'property';
        }
    });
    var neverS = new Stream();
    neverS._emitEnd();
    neverS._name = 'never';
    function never() {
        return neverS;
    }
    function timeBased(mixin) {
        function AnonymousStream(wait, options) {
            var _this = this;
            Stream.call(this);
            this._wait = wait;
            this._intervalId = null;
            this._$onTick = function () {
                return _this._onTick();
            };
            this._init(options);
        }
        inherit(AnonymousStream, Stream, {
            _init: function () {
            },
            _free: function () {
            },
            _onTick: function () {
            },
            _onActivation: function () {
                this._intervalId = setInterval(this._$onTick, this._wait);
            },
            _onDeactivation: function () {
                if (this._intervalId !== null) {
                    clearInterval(this._intervalId);
                    this._intervalId = null;
                }
            },
            _clear: function () {
                Stream.prototype._clear.call(this);
                this._$onTick = null;
                this._free();
            }
        }, mixin);
        return AnonymousStream;
    }
    var S = timeBased({
        _name: 'later',
        _init: function (_ref) {
            var x = _ref.x;
            this._x = x;
        },
        _free: function () {
            this._x = null;
        },
        _onTick: function () {
            this._emitValue(this._x);
            this._emitEnd();
        }
    });
    function later(wait, x) {
        return new S(wait, { x: x });
    }
    var S$1 = timeBased({
        _name: 'interval',
        _init: function (_ref) {
            var x = _ref.x;
            this._x = x;
        },
        _free: function () {
            this._x = null;
        },
        _onTick: function () {
            this._emitValue(this._x);
        }
    });
    function interval(wait, x) {
        return new S$1(wait, { x: x });
    }
    var S$2 = timeBased({
        _name: 'sequentially',
        _init: function (_ref) {
            var xs = _ref.xs;
            this._xs = cloneArray(xs);
        },
        _free: function () {
            this._xs = null;
        },
        _onTick: function () {
            if (this._xs.length === 1) {
                this._emitValue(this._xs[0]);
                this._emitEnd();
            } else {
                this._emitValue(this._xs.shift());
            }
        }
    });
    function sequentially(wait, xs) {
        return xs.length === 0 ? never() : new S$2(wait, { xs: xs });
    }
    var S$3 = timeBased({
        _name: 'fromPoll',
        _init: function (_ref) {
            var fn = _ref.fn;
            this._fn = fn;
        },
        _free: function () {
            this._fn = null;
        },
        _onTick: function () {
            var fn = this._fn;
            this._emitValue(fn());
        }
    });
    function fromPoll(wait, fn) {
        return new S$3(wait, { fn: fn });
    }
    function emitter(obs) {
        function value(x) {
            obs._emitValue(x);
            return obs._active;
        }
        function error(x) {
            obs._emitError(x);
            return obs._active;
        }
        function end() {
            obs._emitEnd();
            return obs._active;
        }
        function event(e) {
            obs._emit(e.type, e.value);
            return obs._active;
        }
        return {
            value: value,
            error: error,
            end: end,
            event: event,
            emit: value,
            emitEvent: event
        };
    }
    var S$4 = timeBased({
        _name: 'withInterval',
        _init: function (_ref) {
            var fn = _ref.fn;
            this._fn = fn;
            this._emitter = emitter(this);
        },
        _free: function () {
            this._fn = null;
            this._emitter = null;
        },
        _onTick: function () {
            var fn = this._fn;
            fn(this._emitter);
        }
    });
    function withInterval(wait, fn) {
        return new S$4(wait, { fn: fn });
    }
    function S$5(fn) {
        Stream.call(this);
        this._fn = fn;
        this._unsubscribe = null;
    }
    inherit(S$5, Stream, {
        _name: 'stream',
        _onActivation: function () {
            var fn = this._fn;
            var unsubscribe = fn(emitter(this));
            this._unsubscribe = typeof unsubscribe === 'function' ? unsubscribe : null;
            if (!this._active) {
                this._callUnsubscribe();
            }
        },
        _callUnsubscribe: function () {
            if (this._unsubscribe !== null) {
                this._unsubscribe();
                this._unsubscribe = null;
            }
        },
        _onDeactivation: function () {
            this._callUnsubscribe();
        },
        _clear: function () {
            Stream.prototype._clear.call(this);
            this._fn = null;
        }
    });
    function stream(fn) {
        return new S$5(fn);
    }
    function fromCallback(callbackConsumer) {
        var called = false;
        return stream(function (emitter) {
            if (!called) {
                callbackConsumer(function (x) {
                    emitter.emit(x);
                    emitter.end();
                });
                called = true;
            }
        }).setName('fromCallback');
    }
    function fromNodeCallback(callbackConsumer) {
        var called = false;
        return stream(function (emitter) {
            if (!called) {
                callbackConsumer(function (error, x) {
                    if (error) {
                        emitter.error(error);
                    } else {
                        emitter.emit(x);
                    }
                    emitter.end();
                });
                called = true;
            }
        }).setName('fromNodeCallback');
    }
    function spread(fn, length) {
        switch (length) {
        case 0:
            return function () {
                return fn();
            };
        case 1:
            return function (a) {
                return fn(a[0]);
            };
        case 2:
            return function (a) {
                return fn(a[0], a[1]);
            };
        case 3:
            return function (a) {
                return fn(a[0], a[1], a[2]);
            };
        case 4:
            return function (a) {
                return fn(a[0], a[1], a[2], a[3]);
            };
        default:
            return function (a) {
                return fn.apply(null, a);
            };
        }
    }
    function apply(fn, c, a) {
        var aLength = a ? a.length : 0;
        if (c == null) {
            switch (aLength) {
            case 0:
                return fn();
            case 1:
                return fn(a[0]);
            case 2:
                return fn(a[0], a[1]);
            case 3:
                return fn(a[0], a[1], a[2]);
            case 4:
                return fn(a[0], a[1], a[2], a[3]);
            default:
                return fn.apply(null, a);
            }
        } else {
            switch (aLength) {
            case 0:
                return fn.call(c);
            default:
                return fn.apply(c, a);
            }
        }
    }
    function fromSubUnsub(sub, unsub, transformer) {
        return stream(function (emitter) {
            var handler = transformer ? function () {
                emitter.emit(apply(transformer, this, arguments));
            } : function (x) {
                emitter.emit(x);
            };
            sub(handler);
            return function () {
                return unsub(handler);
            };
        }).setName('fromSubUnsub');
    }
    var pairs = [
        [
            'addEventListener',
            'removeEventListener'
        ],
        [
            'addListener',
            'removeListener'
        ],
        [
            'on',
            'off'
        ]
    ];
    function fromEvents(target, eventName, transformer) {
        var sub = void 0, unsub = void 0;
        for (var i = 0; i < pairs.length; i++) {
            if (typeof target[pairs[i][0]] === 'function' && typeof target[pairs[i][1]] === 'function') {
                sub = pairs[i][0];
                unsub = pairs[i][1];
                break;
            }
        }
        if (sub === undefined) {
            throw new Error('target don\'t support any of ' + 'addEventListener/removeEventListener, addListener/removeListener, on/off method pair');
        }
        return fromSubUnsub(function (handler) {
            return target[sub](eventName, handler);
        }, function (handler) {
            return target[unsub](eventName, handler);
        }, transformer).setName('fromEvents');
    }
    function P(value) {
        this._currentEvent = {
            type: 'value',
            value: value,
            current: true
        };
    }
    inherit(P, Property, {
        _name: 'constant',
        _active: false,
        _activating: false,
        _alive: false,
        _dispatcher: null,
        _logHandlers: null
    });
    function constant(x) {
        return new P(x);
    }
    function P$1(value) {
        this._currentEvent = {
            type: 'error',
            value: value,
            current: true
        };
    }
    inherit(P$1, Property, {
        _name: 'constantError',
        _active: false,
        _activating: false,
        _alive: false,
        _dispatcher: null,
        _logHandlers: null
    });
    function constantError(x) {
        return new P$1(x);
    }
    function createConstructor(BaseClass, name) {
        return function AnonymousObservable(source, options) {
            var _this = this;
            BaseClass.call(this);
            this._source = source;
            this._name = source._name + '.' + name;
            this._init(options);
            this._$handleAny = function (event) {
                return _this._handleAny(event);
            };
        };
    }
    function createClassMethods(BaseClass) {
        return {
            _init: function () {
            },
            _free: function () {
            },
            _handleValue: function (x) {
                this._emitValue(x);
            },
            _handleError: function (x) {
                this._emitError(x);
            },
            _handleEnd: function () {
                this._emitEnd();
            },
            _handleAny: function (event) {
                switch (event.type) {
                case VALUE:
                    return this._handleValue(event.value);
                case ERROR:
                    return this._handleError(event.value);
                case END:
                    return this._handleEnd();
                }
            },
            _onActivation: function () {
                this._source.onAny(this._$handleAny);
            },
            _onDeactivation: function () {
                this._source.offAny(this._$handleAny);
            },
            _clear: function () {
                BaseClass.prototype._clear.call(this);
                this._source = null;
                this._$handleAny = null;
                this._free();
            }
        };
    }
    function createStream(name, mixin) {
        var S = createConstructor(Stream, name);
        inherit(S, Stream, createClassMethods(Stream), mixin);
        return S;
    }
    function createProperty(name, mixin) {
        var P = createConstructor(Property, name);
        inherit(P, Property, createClassMethods(Property), mixin);
        return P;
    }
    var P$2 = createProperty('toProperty', {
        _init: function (_ref) {
            var fn = _ref.fn;
            this._getInitialCurrent = fn;
        },
        _onActivation: function () {
            if (this._getInitialCurrent !== null) {
                var getInitial = this._getInitialCurrent;
                this._emitValue(getInitial());
            }
            this._source.onAny(this._$handleAny);
        }
    });
    function toProperty(obs) {
        var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        if (fn !== null && typeof fn !== 'function') {
            throw new Error('You should call toProperty() with a function or no arguments.');
        }
        return new P$2(obs, { fn: fn });
    }
    var S$6 = createStream('changes', {
        _handleValue: function (x) {
            if (!this._activating) {
                this._emitValue(x);
            }
        },
        _handleError: function (x) {
            if (!this._activating) {
                this._emitError(x);
            }
        }
    });
    function changes(obs) {
        return new S$6(obs);
    }
    function fromPromise(promise) {
        var called = false;
        var result = stream(function (emitter) {
            if (!called) {
                var onValue = function (x) {
                    emitter.emit(x);
                    emitter.end();
                };
                var onError = function (x) {
                    emitter.error(x);
                    emitter.end();
                };
                var _promise = promise.then(onValue, onError);
                if (_promise && typeof _promise.done === 'function') {
                    _promise.done();
                }
                called = true;
            }
        });
        return toProperty(result, null).setName('fromPromise');
    }
    function getGlodalPromise() {
        if (typeof Promise === 'function') {
            return Promise;
        } else {
            throw new Error('There isn\'t default Promise, use shim or parameter');
        }
    }
    var toPromise = function (obs) {
        var Promise = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getGlodalPromise();
        var last = null;
        return new Promise(function (resolve, reject) {
            obs.onAny(function (event) {
                if (event.type === END && last !== null) {
                    (last.type === VALUE ? resolve : reject)(last.value);
                    last = null;
                } else {
                    last = event;
                }
            });
        });
    };
    var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};
    function createCommonjsModule(fn, module) {
        return module = { exports: {} }, fn(module, module.exports), module.exports;
    }
    var ponyfill = createCommonjsModule(function (module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports['default'] = symbolObservablePonyfill;
        function symbolObservablePonyfill(root) {
            var result;
            var _Symbol = root.Symbol;
            if (typeof _Symbol === 'function') {
                if (_Symbol.observable) {
                    result = _Symbol.observable;
                } else {
                    result = _Symbol('observable');
                    _Symbol.observable = result;
                }
            } else {
                result = '@@observable';
            }
            return result;
        }
    });
    var index$1 = createCommonjsModule(function (module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        var _ponyfill2 = _interopRequireDefault(ponyfill);
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { 'default': obj };
        }
        var root;
        if (typeof self !== 'undefined') {
            root = self;
        } else if (typeof window !== 'undefined') {
            root = window;
        } else if (typeof commonjsGlobal !== 'undefined') {
            root = commonjsGlobal;
        } else {
            root = module;
        }
        var result = (0, _ponyfill2['default'])(root);
        exports['default'] = result;
    });
    var index = index$1;
    var $$observable = index.default ? index.default : index;
    function fromESObservable(_observable) {
        var observable = _observable[$$observable] ? _observable[$$observable]() : _observable;
        return stream(function (emitter) {
            var unsub = observable.subscribe({
                error: function (error) {
                    emitter.error(error);
                    emitter.end();
                },
                next: function (value) {
                    emitter.emit(value);
                },
                complete: function () {
                    emitter.end();
                }
            });
            if (unsub.unsubscribe) {
                return function () {
                    unsub.unsubscribe();
                };
            } else {
                return unsub;
            }
        }).setName('fromESObservable');
    }
    function ESObservable(observable) {
        this._observable = observable.takeErrors(1);
    }
    extend(ESObservable.prototype, {
        subscribe: function (observerOrOnNext, onError, onComplete) {
            var _this = this;
            var observer = typeof observerOrOnNext === 'function' ? {
                next: observerOrOnNext,
                error: onError,
                complete: onComplete
            } : observerOrOnNext;
            var fn = function (event) {
                if (event.type === END) {
                    closed = true;
                }
                if (event.type === VALUE && observer.next) {
                    observer.next(event.value);
                } else if (event.type === ERROR && observer.error) {
                    observer.error(event.value);
                } else if (event.type === END && observer.complete) {
                    observer.complete(event.value);
                }
            };
            this._observable.onAny(fn);
            var closed = false;
            var subscription = {
                unsubscribe: function () {
                    closed = true;
                    _this._observable.offAny(fn);
                },
                get closed() {
                    return closed;
                }
            };
            return subscription;
        }
    });
    ESObservable.prototype[$$observable] = function () {
        return this;
    };
    function toESObservable() {
        return new ESObservable(this);
    }
    function collect(source, keys, values) {
        for (var prop in source) {
            if (source.hasOwnProperty(prop)) {
                keys.push(prop);
                values.push(source[prop]);
            }
        }
    }
    function defaultErrorsCombinator(errors) {
        var latestError = void 0;
        for (var i = 0; i < errors.length; i++) {
            if (errors[i] !== undefined) {
                if (latestError === undefined || latestError.index < errors[i].index) {
                    latestError = errors[i];
                }
            }
        }
        return latestError.error;
    }
    function Combine(active, passive, combinator) {
        var _this = this;
        Stream.call(this);
        this._activeCount = active.length;
        this._sources = concat(active, passive);
        this._combinator = combinator;
        this._aliveCount = 0;
        this._latestValues = new Array(this._sources.length);
        this._latestErrors = new Array(this._sources.length);
        fillArray(this._latestValues, NOTHING);
        this._emitAfterActivation = false;
        this._endAfterActivation = false;
        this._latestErrorIndex = 0;
        this._$handlers = [];
        var _loop = function (i) {
            _this._$handlers.push(function (event) {
                return _this._handleAny(i, event);
            });
        };
        for (var i = 0; i < this._sources.length; i++) {
            _loop(i);
        }
    }
    inherit(Combine, Stream, {
        _name: 'combine',
        _onActivation: function () {
            this._aliveCount = this._activeCount;
            for (var i = this._activeCount; i < this._sources.length; i++) {
                this._sources[i].onAny(this._$handlers[i]);
            }
            for (var _i = 0; _i < this._activeCount; _i++) {
                this._sources[_i].onAny(this._$handlers[_i]);
            }
            if (this._emitAfterActivation) {
                this._emitAfterActivation = false;
                this._emitIfFull();
            }
            if (this._endAfterActivation) {
                this._emitEnd();
            }
        },
        _onDeactivation: function () {
            var length = this._sources.length, i = void 0;
            for (i = 0; i < length; i++) {
                this._sources[i].offAny(this._$handlers[i]);
            }
        },
        _emitIfFull: function () {
            var hasAllValues = true;
            var hasErrors = false;
            var length = this._latestValues.length;
            var valuesCopy = new Array(length);
            var errorsCopy = new Array(length);
            for (var i = 0; i < length; i++) {
                valuesCopy[i] = this._latestValues[i];
                errorsCopy[i] = this._latestErrors[i];
                if (valuesCopy[i] === NOTHING) {
                    hasAllValues = false;
                }
                if (errorsCopy[i] !== undefined) {
                    hasErrors = true;
                }
            }
            if (hasAllValues) {
                var combinator = this._combinator;
                this._emitValue(combinator(valuesCopy));
            }
            if (hasErrors) {
                this._emitError(defaultErrorsCombinator(errorsCopy));
            }
        },
        _handleAny: function (i, event) {
            if (event.type === VALUE || event.type === ERROR) {
                if (event.type === VALUE) {
                    this._latestValues[i] = event.value;
                    this._latestErrors[i] = undefined;
                }
                if (event.type === ERROR) {
                    this._latestValues[i] = NOTHING;
                    this._latestErrors[i] = {
                        index: this._latestErrorIndex++,
                        error: event.value
                    };
                }
                if (i < this._activeCount) {
                    if (this._activating) {
                        this._emitAfterActivation = true;
                    } else {
                        this._emitIfFull();
                    }
                }
            } else {
                if (i < this._activeCount) {
                    this._aliveCount--;
                    if (this._aliveCount === 0) {
                        if (this._activating) {
                            this._endAfterActivation = true;
                        } else {
                            this._emitEnd();
                        }
                    }
                }
            }
        },
        _clear: function () {
            Stream.prototype._clear.call(this);
            this._sources = null;
            this._latestValues = null;
            this._latestErrors = null;
            this._combinator = null;
            this._$handlers = null;
        }
    });
    function combineAsArray(active) {
        var passive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
        var combinator = arguments[2];
        if (!Array.isArray(passive)) {
            throw new Error('Combine can only combine active and passive collections of the same type.');
        }
        combinator = combinator ? spread(combinator, active.length + passive.length) : function (x) {
            return x;
        };
        return active.length === 0 ? never() : new Combine(active, passive, combinator);
    }
    function combineAsObject(active) {
        var passive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var combinator = arguments[2];
        if (typeof passive !== 'object' || Array.isArray(passive)) {
            throw new Error('Combine can only combine active and passive collections of the same type.');
        }
        var keys = [], activeObservables = [], passiveObservables = [];
        collect(active, keys, activeObservables);
        collect(passive, keys, passiveObservables);
        var objectify = function (values) {
            var event = {};
            for (var i = values.length - 1; 0 <= i; i--) {
                event[keys[i]] = values[i];
            }
            return combinator ? combinator(event) : event;
        };
        return activeObservables.length === 0 ? never() : new Combine(activeObservables, passiveObservables, objectify);
    }
    function combine(active, passive, combinator) {
        if (typeof passive === 'function') {
            combinator = passive;
            passive = undefined;
        }
        return Array.isArray(active) ? combineAsArray(active, passive, combinator) : combineAsObject(active, passive, combinator);
    }
    var Observable$2 = {
        empty: function () {
            return never();
        },
        concat: function (a, b) {
            return a.merge(b);
        },
        of: function (x) {
            return constant(x);
        },
        map: function (fn, obs) {
            return obs.map(fn);
        },
        bimap: function (fnErr, fnVal, obs) {
            return obs.mapErrors(fnErr).map(fnVal);
        },
        ap: function (obsFn, obsVal) {
            return combine([
                obsFn,
                obsVal
            ], function (fn, val) {
                return fn(val);
            });
        },
        chain: function (fn, obs) {
            return obs.flatMap(fn);
        }
    };
    var staticLand = Object.freeze({ Observable: Observable$2 });
    var mixin = {
        _init: function (_ref) {
            var fn = _ref.fn;
            this._fn = fn;
        },
        _free: function () {
            this._fn = null;
        },
        _handleValue: function (x) {
            var fn = this._fn;
            this._emitValue(fn(x));
        }
    };
    var S$7 = createStream('map', mixin);
    var P$3 = createProperty('map', mixin);
    var id = function (x) {
        return x;
    };
    function map$1(obs) {
        var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id;
        return new (obs._ofSameType(S$7, P$3))(obs, { fn: fn });
    }
    var mixin$1 = {
        _init: function (_ref) {
            var fn = _ref.fn;
            this._fn = fn;
        },
        _free: function () {
            this._fn = null;
        },
        _handleValue: function (x) {
            var fn = this._fn;
            if (fn(x)) {
                this._emitValue(x);
            }
        }
    };
    var S$8 = createStream('filter', mixin$1);
    var P$4 = createProperty('filter', mixin$1);
    var id$1 = function (x) {
        return x;
    };
    function filter(obs) {
        var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$1;
        return new (obs._ofSameType(S$8, P$4))(obs, { fn: fn });
    }
    var mixin$2 = {
        _init: function (_ref) {
            var n = _ref.n;
            this._n = n;
            if (n <= 0) {
                this._emitEnd();
            }
        },
        _handleValue: function (x) {
            this._n--;
            this._emitValue(x);
            if (this._n === 0) {
                this._emitEnd();
            }
        }
    };
    var S$9 = createStream('take', mixin$2);
    var P$5 = createProperty('take', mixin$2);
    function take(obs, n) {
        return new (obs._ofSameType(S$9, P$5))(obs, { n: n });
    }
    var mixin$3 = {
        _init: function (_ref) {
            var n = _ref.n;
            this._n = n;
            if (n <= 0) {
                this._emitEnd();
            }
        },
        _handleError: function (x) {
            this._n--;
            this._emitError(x);
            if (this._n === 0) {
                this._emitEnd();
            }
        }
    };
    var S$10 = createStream('takeErrors', mixin$3);
    var P$6 = createProperty('takeErrors', mixin$3);
    function takeErrors(obs, n) {
        return new (obs._ofSameType(S$10, P$6))(obs, { n: n });
    }
    var mixin$4 = {
        _init: function (_ref) {
            var fn = _ref.fn;
            this._fn = fn;
        },
        _free: function () {
            this._fn = null;
        },
        _handleValue: function (x) {
            var fn = this._fn;
            if (fn(x)) {
                this._emitValue(x);
            } else {
                this._emitEnd();
            }
        }
    };
    var S$11 = createStream('takeWhile', mixin$4);
    var P$7 = createProperty('takeWhile', mixin$4);
    var id$2 = function (x) {
        return x;
    };
    function takeWhile(obs) {
        var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$2;
        return new (obs._ofSameType(S$11, P$7))(obs, { fn: fn });
    }
    var mixin$5 = {
        _init: function () {
            this._lastValue = NOTHING;
        },
        _free: function () {
            this._lastValue = null;
        },
        _handleValue: function (x) {
            this._lastValue = x;
        },
        _handleEnd: function () {
            if (this._lastValue !== NOTHING) {
                this._emitValue(this._lastValue);
            }
            this._emitEnd();
        }
    };
    var S$12 = createStream('last', mixin$5);
    var P$8 = createProperty('last', mixin$5);
    function last(obs) {
        return new (obs._ofSameType(S$12, P$8))(obs);
    }
    var mixin$6 = {
        _init: function (_ref) {
            var n = _ref.n;
            this._n = Math.max(0, n);
        },
        _handleValue: function (x) {
            if (this._n === 0) {
                this._emitValue(x);
            } else {
                this._n--;
            }
        }
    };
    var S$13 = createStream('skip', mixin$6);
    var P$9 = createProperty('skip', mixin$6);
    function skip(obs, n) {
        return new (obs._ofSameType(S$13, P$9))(obs, { n: n });
    }
    var mixin$7 = {
        _init: function (_ref) {
            var fn = _ref.fn;
            this._fn = fn;
        },
        _free: function () {
            this._fn = null;
        },
        _handleValue: function (x) {
            var fn = this._fn;
            if (this._fn !== null && !fn(x)) {
                this._fn = null;
            }
            if (this._fn === null) {
                this._emitValue(x);
            }
        }
    };
    var S$14 = createStream('skipWhile', mixin$7);
    var P$10 = createProperty('skipWhile', mixin$7);
    var id$3 = function (x) {
        return x;
    };
    function skipWhile(obs) {
        var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$3;
        return new (obs._ofSameType(S$14, P$10))(obs, { fn: fn });
    }
    var mixin$8 = {
        _init: function (_ref) {
            var fn = _ref.fn;
            this._fn = fn;
            this._prev = NOTHING;
        },
        _free: function () {
            this._fn = null;
            this._prev = null;
        },
        _handleValue: function (x) {
            var fn = this._fn;
            if (this._prev === NOTHING || !fn(this._prev, x)) {
                this._prev = x;
                this._emitValue(x);
            }
        }
    };
    var S$15 = createStream('skipDuplicates', mixin$8);
    var P$11 = createProperty('skipDuplicates', mixin$8);
    var eq = function (a, b) {
        return a === b;
    };
    function skipDuplicates(obs) {
        var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : eq;
        return new (obs._ofSameType(S$15, P$11))(obs, { fn: fn });
    }
    var mixin$9 = {
        _init: function (_ref) {
            var fn = _ref.fn, seed = _ref.seed;
            this._fn = fn;
            this._prev = seed;
        },
        _free: function () {
            this._prev = null;
            this._fn = null;
        },
        _handleValue: function (x) {
            if (this._prev !== NOTHING) {
                var fn = this._fn;
                this._emitValue(fn(this._prev, x));
            }
            this._prev = x;
        }
    };
    var S$16 = createStream('diff', mixin$9);
    var P$12 = createProperty('diff', mixin$9);
    function defaultFn(a, b) {
        return [
            a,
            b
        ];
    }
    function diff(obs, fn) {
        var seed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NOTHING;
        return new (obs._ofSameType(S$16, P$12))(obs, {
            fn: fn || defaultFn,
            seed: seed
        });
    }
    var P$13 = createProperty('scan', {
        _init: function (_ref) {
            var fn = _ref.fn, seed = _ref.seed;
            this._fn = fn;
            this._seed = seed;
            if (seed !== NOTHING) {
                this._emitValue(seed);
            }
        },
        _free: function () {
            this._fn = null;
            this._seed = null;
        },
        _handleValue: function (x) {
            var fn = this._fn;
            if (this._currentEvent === null || this._currentEvent.type === ERROR) {
                this._emitValue(this._seed === NOTHING ? x : fn(this._seed, x));
            } else {
                this._emitValue(fn(this._currentEvent.value, x));
            }
        }
    });
    function scan(obs, fn) {
        var seed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NOTHING;
        return new P$13(obs, {
            fn: fn,
            seed: seed
        });
    }
    var mixin$10 = {
        _init: function (_ref) {
            var fn = _ref.fn;
            this._fn = fn;
        },
        _free: function () {
            this._fn = null;
        },
        _handleValue: function (x) {
            var fn = this._fn;
            var xs = fn(x);
            for (var i = 0; i < xs.length; i++) {
                this._emitValue(xs[i]);
            }
        }
    };
    var S$17 = createStream('flatten', mixin$10);
    var id$4 = function (x) {
        return x;
    };
    function flatten(obs) {
        var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$4;
        return new S$17(obs, { fn: fn });
    }
    var END_MARKER = {};
    var mixin$11 = {
        _init: function (_ref) {
            var _this = this;
            var wait = _ref.wait;
            this._wait = Math.max(0, wait);
            this._buff = [];
            this._$shiftBuff = function () {
                var value = _this._buff.shift();
                if (value === END_MARKER) {
                    _this._emitEnd();
                } else {
                    _this._emitValue(value);
                }
            };
        },
        _free: function () {
            this._buff = null;
            this._$shiftBuff = null;
        },
        _handleValue: function (x) {
            if (this._activating) {
                this._emitValue(x);
            } else {
                this._buff.push(x);
                setTimeout(this._$shiftBuff, this._wait);
            }
        },
        _handleEnd: function () {
            if (this._activating) {
                this._emitEnd();
            } else {
                this._buff.push(END_MARKER);
                setTimeout(this._$shiftBuff, this._wait);
            }
        }
    };
    var S$18 = createStream('delay', mixin$11);
    var P$14 = createProperty('delay', mixin$11);
    function delay(obs, wait) {
        return new (obs._ofSameType(S$18, P$14))(obs, { wait: wait });
    }
    var now = Date.now ? function () {
        return Date.now();
    } : function () {
        return new Date().getTime();
    };
    var mixin$12 = {
        _init: function (_ref) {
            var _this = this;
            var wait = _ref.wait, leading = _ref.leading, trailing = _ref.trailing;
            this._wait = Math.max(0, wait);
            this._leading = leading;
            this._trailing = trailing;
            this._trailingValue = null;
            this._timeoutId = null;
            this._endLater = false;
            this._lastCallTime = 0;
            this._$trailingCall = function () {
                return _this._trailingCall();
            };
        },
        _free: function () {
            this._trailingValue = null;
            this._$trailingCall = null;
        },
        _handleValue: function (x) {
            if (this._activating) {
                this._emitValue(x);
            } else {
                var curTime = now();
                if (this._lastCallTime === 0 && !this._leading) {
                    this._lastCallTime = curTime;
                }
                var remaining = this._wait - (curTime - this._lastCallTime);
                if (remaining <= 0) {
                    this._cancelTrailing();
                    this._lastCallTime = curTime;
                    this._emitValue(x);
                } else if (this._trailing) {
                    this._cancelTrailing();
                    this._trailingValue = x;
                    this._timeoutId = setTimeout(this._$trailingCall, remaining);
                }
            }
        },
        _handleEnd: function () {
            if (this._activating) {
                this._emitEnd();
            } else {
                if (this._timeoutId) {
                    this._endLater = true;
                } else {
                    this._emitEnd();
                }
            }
        },
        _cancelTrailing: function () {
            if (this._timeoutId !== null) {
                clearTimeout(this._timeoutId);
                this._timeoutId = null;
            }
        },
        _trailingCall: function () {
            this._emitValue(this._trailingValue);
            this._timeoutId = null;
            this._trailingValue = null;
            this._lastCallTime = !this._leading ? 0 : now();
            if (this._endLater) {
                this._emitEnd();
            }
        }
    };
    var S$19 = createStream('throttle', mixin$12);
    var P$15 = createProperty('throttle', mixin$12);
    function throttle(obs, wait) {
        var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {}, _ref2$leading = _ref2.leading, leading = _ref2$leading === undefined ? true : _ref2$leading, _ref2$trailing = _ref2.trailing, trailing = _ref2$trailing === undefined ? true : _ref2$trailing;
        return new (obs._ofSameType(S$19, P$15))(obs, {
            wait: wait,
            leading: leading,
            trailing: trailing
        });
    }
    var mixin$13 = {
        _init: function (_ref) {
            var _this = this;
            var wait = _ref.wait, immediate = _ref.immediate;
            this._wait = Math.max(0, wait);
            this._immediate = immediate;
            this._lastAttempt = 0;
            this._timeoutId = null;
            this._laterValue = null;
            this._endLater = false;
            this._$later = function () {
                return _this._later();
            };
        },
        _free: function () {
            this._laterValue = null;
            this._$later = null;
        },
        _handleValue: function (x) {
            if (this._activating) {
                this._emitValue(x);
            } else {
                this._lastAttempt = now();
                if (this._immediate && !this._timeoutId) {
                    this._emitValue(x);
                }
                if (!this._timeoutId) {
                    this._timeoutId = setTimeout(this._$later, this._wait);
                }
                if (!this._immediate) {
                    this._laterValue = x;
                }
            }
        },
        _handleEnd: function () {
            if (this._activating) {
                this._emitEnd();
            } else {
                if (this._timeoutId && !this._immediate) {
                    this._endLater = true;
                } else {
                    this._emitEnd();
                }
            }
        },
        _later: function () {
            var last = now() - this._lastAttempt;
            if (last < this._wait && last >= 0) {
                this._timeoutId = setTimeout(this._$later, this._wait - last);
            } else {
                this._timeoutId = null;
                if (!this._immediate) {
                    this._emitValue(this._laterValue);
                    this._laterValue = null;
                }
                if (this._endLater) {
                    this._emitEnd();
                }
            }
        }
    };
    var S$20 = createStream('debounce', mixin$13);
    var P$16 = createProperty('debounce', mixin$13);
    function debounce(obs, wait) {
        var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {}, _ref2$immediate = _ref2.immediate, immediate = _ref2$immediate === undefined ? false : _ref2$immediate;
        return new (obs._ofSameType(S$20, P$16))(obs, {
            wait: wait,
            immediate: immediate
        });
    }
    var mixin$14 = {
        _init: function (_ref) {
            var fn = _ref.fn;
            this._fn = fn;
        },
        _free: function () {
            this._fn = null;
        },
        _handleError: function (x) {
            var fn = this._fn;
            this._emitError(fn(x));
        }
    };
    var S$21 = createStream('mapErrors', mixin$14);
    var P$17 = createProperty('mapErrors', mixin$14);
    var id$5 = function (x) {
        return x;
    };
    function mapErrors(obs) {
        var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$5;
        return new (obs._ofSameType(S$21, P$17))(obs, { fn: fn });
    }
    var mixin$15 = {
        _init: function (_ref) {
            var fn = _ref.fn;
            this._fn = fn;
        },
        _free: function () {
            this._fn = null;
        },
        _handleError: function (x) {
            var fn = this._fn;
            if (fn(x)) {
                this._emitError(x);
            }
        }
    };
    var S$22 = createStream('filterErrors', mixin$15);
    var P$18 = createProperty('filterErrors', mixin$15);
    var id$6 = function (x) {
        return x;
    };
    function filterErrors(obs) {
        var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$6;
        return new (obs._ofSameType(S$22, P$18))(obs, { fn: fn });
    }
    var mixin$16 = {
        _handleValue: function () {
        }
    };
    var S$23 = createStream('ignoreValues', mixin$16);
    var P$19 = createProperty('ignoreValues', mixin$16);
    function ignoreValues(obs) {
        return new (obs._ofSameType(S$23, P$19))(obs);
    }
    var mixin$17 = {
        _handleError: function () {
        }
    };
    var S$24 = createStream('ignoreErrors', mixin$17);
    var P$20 = createProperty('ignoreErrors', mixin$17);
    function ignoreErrors(obs) {
        return new (obs._ofSameType(S$24, P$20))(obs);
    }
    var mixin$18 = {
        _handleEnd: function () {
        }
    };
    var S$25 = createStream('ignoreEnd', mixin$18);
    var P$21 = createProperty('ignoreEnd', mixin$18);
    function ignoreEnd(obs) {
        return new (obs._ofSameType(S$25, P$21))(obs);
    }
    var mixin$19 = {
        _init: function (_ref) {
            var fn = _ref.fn;
            this._fn = fn;
        },
        _free: function () {
            this._fn = null;
        },
        _handleEnd: function () {
            var fn = this._fn;
            this._emitValue(fn());
            this._emitEnd();
        }
    };
    var S$26 = createStream('beforeEnd', mixin$19);
    var P$22 = createProperty('beforeEnd', mixin$19);
    function beforeEnd(obs, fn) {
        return new (obs._ofSameType(S$26, P$22))(obs, { fn: fn });
    }
    var mixin$20 = {
        _init: function (_ref) {
            var min = _ref.min, max = _ref.max;
            this._max = max;
            this._min = min;
            this._buff = [];
        },
        _free: function () {
            this._buff = null;
        },
        _handleValue: function (x) {
            this._buff = slide(this._buff, x, this._max);
            if (this._buff.length >= this._min) {
                this._emitValue(this._buff);
            }
        }
    };
    var S$27 = createStream('slidingWindow', mixin$20);
    var P$23 = createProperty('slidingWindow', mixin$20);
    function slidingWindow(obs, max) {
        var min = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        return new (obs._ofSameType(S$27, P$23))(obs, {
            min: min,
            max: max
        });
    }
    var mixin$21 = {
        _init: function (_ref) {
            var fn = _ref.fn, flushOnEnd = _ref.flushOnEnd;
            this._fn = fn;
            this._flushOnEnd = flushOnEnd;
            this._buff = [];
        },
        _free: function () {
            this._buff = null;
        },
        _flush: function () {
            if (this._buff !== null && this._buff.length !== 0) {
                this._emitValue(this._buff);
                this._buff = [];
            }
        },
        _handleValue: function (x) {
            this._buff.push(x);
            var fn = this._fn;
            if (!fn(x)) {
                this._flush();
            }
        },
        _handleEnd: function () {
            if (this._flushOnEnd) {
                this._flush();
            }
            this._emitEnd();
        }
    };
    var S$28 = createStream('bufferWhile', mixin$21);
    var P$24 = createProperty('bufferWhile', mixin$21);
    var id$7 = function (x) {
        return x;
    };
    function bufferWhile(obs, fn) {
        var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {}, _ref2$flushOnEnd = _ref2.flushOnEnd, flushOnEnd = _ref2$flushOnEnd === undefined ? true : _ref2$flushOnEnd;
        return new (obs._ofSameType(S$28, P$24))(obs, {
            fn: fn || id$7,
            flushOnEnd: flushOnEnd
        });
    }
    var mixin$22 = {
        _init: function (_ref) {
            var count = _ref.count, flushOnEnd = _ref.flushOnEnd;
            this._count = count;
            this._flushOnEnd = flushOnEnd;
            this._buff = [];
        },
        _free: function () {
            this._buff = null;
        },
        _flush: function () {
            if (this._buff !== null && this._buff.length !== 0) {
                this._emitValue(this._buff);
                this._buff = [];
            }
        },
        _handleValue: function (x) {
            this._buff.push(x);
            if (this._buff.length >= this._count) {
                this._flush();
            }
        },
        _handleEnd: function () {
            if (this._flushOnEnd) {
                this._flush();
            }
            this._emitEnd();
        }
    };
    var S$29 = createStream('bufferWithCount', mixin$22);
    var P$25 = createProperty('bufferWithCount', mixin$22);
    function bufferWhile$1(obs, count) {
        var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {}, _ref2$flushOnEnd = _ref2.flushOnEnd, flushOnEnd = _ref2$flushOnEnd === undefined ? true : _ref2$flushOnEnd;
        return new (obs._ofSameType(S$29, P$25))(obs, {
            count: count,
            flushOnEnd: flushOnEnd
        });
    }
    var mixin$23 = {
        _init: function (_ref) {
            var _this = this;
            var wait = _ref.wait, count = _ref.count, flushOnEnd = _ref.flushOnEnd;
            this._wait = wait;
            this._count = count;
            this._flushOnEnd = flushOnEnd;
            this._intervalId = null;
            this._$onTick = function () {
                return _this._flush();
            };
            this._buff = [];
        },
        _free: function () {
            this._$onTick = null;
            this._buff = null;
        },
        _flush: function () {
            if (this._buff !== null) {
                this._emitValue(this._buff);
                this._buff = [];
            }
        },
        _handleValue: function (x) {
            this._buff.push(x);
            if (this._buff.length >= this._count) {
                clearInterval(this._intervalId);
                this._flush();
                this._intervalId = setInterval(this._$onTick, this._wait);
            }
        },
        _handleEnd: function () {
            if (this._flushOnEnd && this._buff.length !== 0) {
                this._flush();
            }
            this._emitEnd();
        },
        _onActivation: function () {
            this._intervalId = setInterval(this._$onTick, this._wait);
            this._source.onAny(this._$handleAny);
        },
        _onDeactivation: function () {
            if (this._intervalId !== null) {
                clearInterval(this._intervalId);
                this._intervalId = null;
            }
            this._source.offAny(this._$handleAny);
        }
    };
    var S$30 = createStream('bufferWithTimeOrCount', mixin$23);
    var P$26 = createProperty('bufferWithTimeOrCount', mixin$23);
    function bufferWithTimeOrCount(obs, wait, count) {
        var _ref2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {}, _ref2$flushOnEnd = _ref2.flushOnEnd, flushOnEnd = _ref2$flushOnEnd === undefined ? true : _ref2$flushOnEnd;
        return new (obs._ofSameType(S$30, P$26))(obs, {
            wait: wait,
            count: count,
            flushOnEnd: flushOnEnd
        });
    }
    function xformForObs(obs) {
        return {
            '@@transducer/step': function (res, input) {
                obs._emitValue(input);
                return null;
            },
            '@@transducer/result': function () {
                obs._emitEnd();
                return null;
            }
        };
    }
    var mixin$24 = {
        _init: function (_ref) {
            var transducer = _ref.transducer;
            this._xform = transducer(xformForObs(this));
        },
        _free: function () {
            this._xform = null;
        },
        _handleValue: function (x) {
            if (this._xform['@@transducer/step'](null, x) !== null) {
                this._xform['@@transducer/result'](null);
            }
        },
        _handleEnd: function () {
            this._xform['@@transducer/result'](null);
        }
    };
    var S$31 = createStream('transduce', mixin$24);
    var P$27 = createProperty('transduce', mixin$24);
    function transduce(obs, transducer) {
        return new (obs._ofSameType(S$31, P$27))(obs, { transducer: transducer });
    }
    var mixin$25 = {
        _init: function (_ref) {
            var fn = _ref.fn;
            this._handler = fn;
            this._emitter = emitter(this);
        },
        _free: function () {
            this._handler = null;
            this._emitter = null;
        },
        _handleAny: function (event) {
            this._handler(this._emitter, event);
        }
    };
    var S$32 = createStream('withHandler', mixin$25);
    var P$28 = createProperty('withHandler', mixin$25);
    function withHandler(obs, fn) {
        return new (obs._ofSameType(S$32, P$28))(obs, { fn: fn });
    }
    var isArray = Array.isArray || function (xs) {
        return Object.prototype.toString.call(xs) === '[object Array]';
    };
    function Zip(sources, combinator) {
        var _this = this;
        Stream.call(this);
        this._buffers = map(sources, function (source) {
            return isArray(source) ? cloneArray(source) : [];
        });
        this._sources = map(sources, function (source) {
            return isArray(source) ? never() : source;
        });
        this._combinator = combinator ? spread(combinator, this._sources.length) : function (x) {
            return x;
        };
        this._aliveCount = 0;
        this._$handlers = [];
        var _loop = function (i) {
            _this._$handlers.push(function (event) {
                return _this._handleAny(i, event);
            });
        };
        for (var i = 0; i < this._sources.length; i++) {
            _loop(i);
        }
    }
    inherit(Zip, Stream, {
        _name: 'zip',
        _onActivation: function () {
            while (this._isFull()) {
                this._emit();
            }
            var length = this._sources.length;
            this._aliveCount = length;
            for (var i = 0; i < length && this._active; i++) {
                this._sources[i].onAny(this._$handlers[i]);
            }
        },
        _onDeactivation: function () {
            for (var i = 0; i < this._sources.length; i++) {
                this._sources[i].offAny(this._$handlers[i]);
            }
        },
        _emit: function () {
            var values = new Array(this._buffers.length);
            for (var i = 0; i < this._buffers.length; i++) {
                values[i] = this._buffers[i].shift();
            }
            var combinator = this._combinator;
            this._emitValue(combinator(values));
        },
        _isFull: function () {
            for (var i = 0; i < this._buffers.length; i++) {
                if (this._buffers[i].length === 0) {
                    return false;
                }
            }
            return true;
        },
        _handleAny: function (i, event) {
            if (event.type === VALUE) {
                this._buffers[i].push(event.value);
                if (this._isFull()) {
                    this._emit();
                }
            }
            if (event.type === ERROR) {
                this._emitError(event.value);
            }
            if (event.type === END) {
                this._aliveCount--;
                if (this._aliveCount === 0) {
                    this._emitEnd();
                }
            }
        },
        _clear: function () {
            Stream.prototype._clear.call(this);
            this._sources = null;
            this._buffers = null;
            this._combinator = null;
            this._$handlers = null;
        }
    });
    function zip(observables, combinator) {
        return observables.length === 0 ? never() : new Zip(observables, combinator);
    }
    var id$8 = function (x) {
        return x;
    };
    function AbstractPool() {
        var _this = this;
        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, _ref$queueLim = _ref.queueLim, queueLim = _ref$queueLim === undefined ? 0 : _ref$queueLim, _ref$concurLim = _ref.concurLim, concurLim = _ref$concurLim === undefined ? -1 : _ref$concurLim, _ref$drop = _ref.drop, drop = _ref$drop === undefined ? 'new' : _ref$drop;
        Stream.call(this);
        this._queueLim = queueLim < 0 ? -1 : queueLim;
        this._concurLim = concurLim < 0 ? -1 : concurLim;
        this._drop = drop;
        this._queue = [];
        this._curSources = [];
        this._$handleSubAny = function (event) {
            return _this._handleSubAny(event);
        };
        this._$endHandlers = [];
        this._currentlyAdding = null;
        if (this._concurLim === 0) {
            this._emitEnd();
        }
    }
    inherit(AbstractPool, Stream, {
        _name: 'abstractPool',
        _add: function (obj, toObs) {
            toObs = toObs || id$8;
            if (this._concurLim === -1 || this._curSources.length < this._concurLim) {
                this._addToCur(toObs(obj));
            } else {
                if (this._queueLim === -1 || this._queue.length < this._queueLim) {
                    this._addToQueue(toObs(obj));
                } else if (this._drop === 'old') {
                    this._removeOldest();
                    this._add(obj, toObs);
                }
            }
        },
        _addAll: function (obss) {
            var _this2 = this;
            forEach(obss, function (obs) {
                return _this2._add(obs);
            });
        },
        _remove: function (obs) {
            if (this._removeCur(obs) === -1) {
                this._removeQueue(obs);
            }
        },
        _addToQueue: function (obs) {
            this._queue = concat(this._queue, [obs]);
        },
        _addToCur: function (obs) {
            if (this._active) {
                if (!obs._alive) {
                    if (obs._currentEvent) {
                        this._emit(obs._currentEvent.type, obs._currentEvent.value);
                    }
                    return;
                }
                this._currentlyAdding = obs;
                obs.onAny(this._$handleSubAny);
                this._currentlyAdding = null;
                if (obs._alive) {
                    this._curSources = concat(this._curSources, [obs]);
                    if (this._active) {
                        this._subToEnd(obs);
                    }
                }
            } else {
                this._curSources = concat(this._curSources, [obs]);
            }
        },
        _subToEnd: function (obs) {
            var _this3 = this;
            var onEnd = function () {
                return _this3._removeCur(obs);
            };
            this._$endHandlers.push({
                obs: obs,
                handler: onEnd
            });
            obs.onEnd(onEnd);
        },
        _subscribe: function (obs) {
            obs.onAny(this._$handleSubAny);
            if (this._active) {
                this._subToEnd(obs);
            }
        },
        _unsubscribe: function (obs) {
            obs.offAny(this._$handleSubAny);
            var onEndI = findByPred(this._$endHandlers, function (obj) {
                return obj.obs === obs;
            });
            if (onEndI !== -1) {
                obs.offEnd(this._$endHandlers[onEndI].handler);
                this._$endHandlers.splice(onEndI, 1);
            }
        },
        _handleSubAny: function (event) {
            if (event.type === VALUE) {
                this._emitValue(event.value);
            } else if (event.type === ERROR) {
                this._emitError(event.value);
            }
        },
        _removeQueue: function (obs) {
            var index = find(this._queue, obs);
            this._queue = remove(this._queue, index);
            return index;
        },
        _removeCur: function (obs) {
            if (this._active) {
                this._unsubscribe(obs);
            }
            var index = find(this._curSources, obs);
            this._curSources = remove(this._curSources, index);
            if (index !== -1) {
                if (this._queue.length !== 0) {
                    this._pullQueue();
                } else if (this._curSources.length === 0) {
                    this._onEmpty();
                }
            }
            return index;
        },
        _removeOldest: function () {
            this._removeCur(this._curSources[0]);
        },
        _pullQueue: function () {
            if (this._queue.length !== 0) {
                this._queue = cloneArray(this._queue);
                this._addToCur(this._queue.shift());
            }
        },
        _onActivation: function () {
            for (var i = 0, sources = this._curSources; i < sources.length && this._active; i++) {
                this._subscribe(sources[i]);
            }
        },
        _onDeactivation: function () {
            for (var i = 0, sources = this._curSources; i < sources.length; i++) {
                this._unsubscribe(sources[i]);
            }
            if (this._currentlyAdding !== null) {
                this._unsubscribe(this._currentlyAdding);
            }
        },
        _isEmpty: function () {
            return this._curSources.length === 0;
        },
        _onEmpty: function () {
        },
        _clear: function () {
            Stream.prototype._clear.call(this);
            this._queue = null;
            this._curSources = null;
            this._$handleSubAny = null;
            this._$endHandlers = null;
        }
    });
    function Merge(sources) {
        AbstractPool.call(this);
        this._addAll(sources);
        this._initialised = true;
    }
    inherit(Merge, AbstractPool, {
        _name: 'merge',
        _onEmpty: function () {
            if (this._initialised) {
                this._emitEnd();
            }
        }
    });
    function merge(observables) {
        return observables.length === 0 ? never() : new Merge(observables);
    }
    function S$33(generator) {
        var _this = this;
        Stream.call(this);
        this._generator = generator;
        this._source = null;
        this._inLoop = false;
        this._iteration = 0;
        this._$handleAny = function (event) {
            return _this._handleAny(event);
        };
    }
    inherit(S$33, Stream, {
        _name: 'repeat',
        _handleAny: function (event) {
            if (event.type === END) {
                this._source = null;
                this._getSource();
            } else {
                this._emit(event.type, event.value);
            }
        },
        _getSource: function () {
            if (!this._inLoop) {
                this._inLoop = true;
                var generator = this._generator;
                while (this._source === null && this._alive && this._active) {
                    this._source = generator(this._iteration++);
                    if (this._source) {
                        this._source.onAny(this._$handleAny);
                    } else {
                        this._emitEnd();
                    }
                }
                this._inLoop = false;
            }
        },
        _onActivation: function () {
            if (this._source) {
                this._source.onAny(this._$handleAny);
            } else {
                this._getSource();
            }
        },
        _onDeactivation: function () {
            if (this._source) {
                this._source.offAny(this._$handleAny);
            }
        },
        _clear: function () {
            Stream.prototype._clear.call(this);
            this._generator = null;
            this._source = null;
            this._$handleAny = null;
        }
    });
    var repeat = function (generator) {
        return new S$33(generator);
    };
    function concat$1(observables) {
        return repeat(function (index) {
            return observables.length > index ? observables[index] : false;
        }).setName('concat');
    }
    function Pool() {
        AbstractPool.call(this);
    }
    inherit(Pool, AbstractPool, {
        _name: 'pool',
        plug: function (obs) {
            this._add(obs);
            return this;
        },
        unplug: function (obs) {
            this._remove(obs);
            return this;
        }
    });
    function FlatMap(source, fn, options) {
        var _this = this;
        AbstractPool.call(this, options);
        this._source = source;
        this._fn = fn;
        this._mainEnded = false;
        this._lastCurrent = null;
        this._$handleMain = function (event) {
            return _this._handleMain(event);
        };
    }
    inherit(FlatMap, AbstractPool, {
        _onActivation: function () {
            AbstractPool.prototype._onActivation.call(this);
            if (this._active) {
                this._source.onAny(this._$handleMain);
            }
        },
        _onDeactivation: function () {
            AbstractPool.prototype._onDeactivation.call(this);
            this._source.offAny(this._$handleMain);
            this._hadNoEvSinceDeact = true;
        },
        _handleMain: function (event) {
            if (event.type === VALUE) {
                var sameCurr = this._activating && this._hadNoEvSinceDeact && this._lastCurrent === event.value;
                if (!sameCurr) {
                    this._add(event.value, this._fn);
                }
                this._lastCurrent = event.value;
                this._hadNoEvSinceDeact = false;
            }
            if (event.type === ERROR) {
                this._emitError(event.value);
            }
            if (event.type === END) {
                if (this._isEmpty()) {
                    this._emitEnd();
                } else {
                    this._mainEnded = true;
                }
            }
        },
        _onEmpty: function () {
            if (this._mainEnded) {
                this._emitEnd();
            }
        },
        _clear: function () {
            AbstractPool.prototype._clear.call(this);
            this._source = null;
            this._lastCurrent = null;
            this._$handleMain = null;
        }
    });
    function FlatMapErrors(source, fn) {
        FlatMap.call(this, source, fn);
    }
    inherit(FlatMapErrors, FlatMap, {
        _handleMain: function (event) {
            if (event.type === ERROR) {
                var sameCurr = this._activating && this._hadNoEvSinceDeact && this._lastCurrent === event.value;
                if (!sameCurr) {
                    this._add(event.value, this._fn);
                }
                this._lastCurrent = event.value;
                this._hadNoEvSinceDeact = false;
            }
            if (event.type === VALUE) {
                this._emitValue(event.value);
            }
            if (event.type === END) {
                if (this._isEmpty()) {
                    this._emitEnd();
                } else {
                    this._mainEnded = true;
                }
            }
        }
    });
    function createConstructor$1(BaseClass, name) {
        return function AnonymousObservable(primary, secondary, options) {
            var _this = this;
            BaseClass.call(this);
            this._primary = primary;
            this._secondary = secondary;
            this._name = primary._name + '.' + name;
            this._lastSecondary = NOTHING;
            this._$handleSecondaryAny = function (event) {
                return _this._handleSecondaryAny(event);
            };
            this._$handlePrimaryAny = function (event) {
                return _this._handlePrimaryAny(event);
            };
            this._init(options);
        };
    }
    function createClassMethods$1(BaseClass) {
        return {
            _init: function () {
            },
            _free: function () {
            },
            _handlePrimaryValue: function (x) {
                this._emitValue(x);
            },
            _handlePrimaryError: function (x) {
                this._emitError(x);
            },
            _handlePrimaryEnd: function () {
                this._emitEnd();
            },
            _handleSecondaryValue: function (x) {
                this._lastSecondary = x;
            },
            _handleSecondaryError: function (x) {
                this._emitError(x);
            },
            _handleSecondaryEnd: function () {
            },
            _handlePrimaryAny: function (event) {
                switch (event.type) {
                case VALUE:
                    return this._handlePrimaryValue(event.value);
                case ERROR:
                    return this._handlePrimaryError(event.value);
                case END:
                    return this._handlePrimaryEnd(event.value);
                }
            },
            _handleSecondaryAny: function (event) {
                switch (event.type) {
                case VALUE:
                    return this._handleSecondaryValue(event.value);
                case ERROR:
                    return this._handleSecondaryError(event.value);
                case END:
                    this._handleSecondaryEnd(event.value);
                    this._removeSecondary();
                }
            },
            _removeSecondary: function () {
                if (this._secondary !== null) {
                    this._secondary.offAny(this._$handleSecondaryAny);
                    this._$handleSecondaryAny = null;
                    this._secondary = null;
                }
            },
            _onActivation: function () {
                if (this._secondary !== null) {
                    this._secondary.onAny(this._$handleSecondaryAny);
                }
                if (this._active) {
                    this._primary.onAny(this._$handlePrimaryAny);
                }
            },
            _onDeactivation: function () {
                if (this._secondary !== null) {
                    this._secondary.offAny(this._$handleSecondaryAny);
                }
                this._primary.offAny(this._$handlePrimaryAny);
            },
            _clear: function () {
                BaseClass.prototype._clear.call(this);
                this._primary = null;
                this._secondary = null;
                this._lastSecondary = null;
                this._$handleSecondaryAny = null;
                this._$handlePrimaryAny = null;
                this._free();
            }
        };
    }
    function createStream$1(name, mixin) {
        var S = createConstructor$1(Stream, name);
        inherit(S, Stream, createClassMethods$1(Stream), mixin);
        return S;
    }
    function createProperty$1(name, mixin) {
        var P = createConstructor$1(Property, name);
        inherit(P, Property, createClassMethods$1(Property), mixin);
        return P;
    }
    var mixin$26 = {
        _handlePrimaryValue: function (x) {
            if (this._lastSecondary !== NOTHING && this._lastSecondary) {
                this._emitValue(x);
            }
        },
        _handleSecondaryEnd: function () {
            if (this._lastSecondary === NOTHING || !this._lastSecondary) {
                this._emitEnd();
            }
        }
    };
    var S$34 = createStream$1('filterBy', mixin$26);
    var P$29 = createProperty$1('filterBy', mixin$26);
    function filterBy(primary, secondary) {
        return new (primary._ofSameType(S$34, P$29))(primary, secondary);
    }
    var id2 = function (_, x) {
        return x;
    };
    function sampledBy(passive, active, combinator) {
        var _combinator = combinator ? function (a, b) {
            return combinator(b, a);
        } : id2;
        return combine([active], [passive], _combinator).setName(passive, 'sampledBy');
    }
    var mixin$27 = {
        _handlePrimaryValue: function (x) {
            if (this._lastSecondary !== NOTHING) {
                this._emitValue(x);
            }
        },
        _handleSecondaryEnd: function () {
            if (this._lastSecondary === NOTHING) {
                this._emitEnd();
            }
        }
    };
    var S$35 = createStream$1('skipUntilBy', mixin$27);
    var P$30 = createProperty$1('skipUntilBy', mixin$27);
    function skipUntilBy(primary, secondary) {
        return new (primary._ofSameType(S$35, P$30))(primary, secondary);
    }
    var mixin$28 = {
        _handleSecondaryValue: function () {
            this._emitEnd();
        }
    };
    var S$36 = createStream$1('takeUntilBy', mixin$28);
    var P$31 = createProperty$1('takeUntilBy', mixin$28);
    function takeUntilBy(primary, secondary) {
        return new (primary._ofSameType(S$36, P$31))(primary, secondary);
    }
    var mixin$29 = {
        _init: function () {
            var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, _ref$flushOnEnd = _ref.flushOnEnd, flushOnEnd = _ref$flushOnEnd === undefined ? true : _ref$flushOnEnd;
            this._buff = [];
            this._flushOnEnd = flushOnEnd;
        },
        _free: function () {
            this._buff = null;
        },
        _flush: function () {
            if (this._buff !== null) {
                this._emitValue(this._buff);
                this._buff = [];
            }
        },
        _handlePrimaryEnd: function () {
            if (this._flushOnEnd) {
                this._flush();
            }
            this._emitEnd();
        },
        _onActivation: function () {
            this._primary.onAny(this._$handlePrimaryAny);
            if (this._alive && this._secondary !== null) {
                this._secondary.onAny(this._$handleSecondaryAny);
            }
        },
        _handlePrimaryValue: function (x) {
            this._buff.push(x);
        },
        _handleSecondaryValue: function () {
            this._flush();
        },
        _handleSecondaryEnd: function () {
            if (!this._flushOnEnd) {
                this._emitEnd();
            }
        }
    };
    var S$37 = createStream$1('bufferBy', mixin$29);
    var P$32 = createProperty$1('bufferBy', mixin$29);
    function bufferBy(primary, secondary, options) {
        return new (primary._ofSameType(S$37, P$32))(primary, secondary, options);
    }
    var mixin$30 = {
        _init: function () {
            var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, _ref$flushOnEnd = _ref.flushOnEnd, flushOnEnd = _ref$flushOnEnd === undefined ? true : _ref$flushOnEnd, _ref$flushOnChange = _ref.flushOnChange, flushOnChange = _ref$flushOnChange === undefined ? false : _ref$flushOnChange;
            this._buff = [];
            this._flushOnEnd = flushOnEnd;
            this._flushOnChange = flushOnChange;
        },
        _free: function () {
            this._buff = null;
        },
        _flush: function () {
            if (this._buff !== null) {
                this._emitValue(this._buff);
                this._buff = [];
            }
        },
        _handlePrimaryEnd: function () {
            if (this._flushOnEnd) {
                this._flush();
            }
            this._emitEnd();
        },
        _handlePrimaryValue: function (x) {
            this._buff.push(x);
            if (this._lastSecondary !== NOTHING && !this._lastSecondary) {
                this._flush();
            }
        },
        _handleSecondaryEnd: function () {
            if (!this._flushOnEnd && (this._lastSecondary === NOTHING || this._lastSecondary)) {
                this._emitEnd();
            }
        },
        _handleSecondaryValue: function (x) {
            if (this._flushOnChange && !x) {
                this._flush();
            }
            this._lastSecondary = x;
        }
    };
    var S$38 = createStream$1('bufferWhileBy', mixin$30);
    var P$33 = createProperty$1('bufferWhileBy', mixin$30);
    function bufferWhileBy(primary, secondary, options) {
        return new (primary._ofSameType(S$38, P$33))(primary, secondary, options);
    }
    var f = function () {
        return false;
    };
    var t = function () {
        return true;
    };
    function awaiting(a, b) {
        var result = merge([
            map$1(a, t),
            map$1(b, f)
        ]);
        result = skipDuplicates(result);
        result = toProperty(result, f);
        return result.setName(a, 'awaiting');
    }
    var mixin$31 = {
        _init: function (_ref) {
            var fn = _ref.fn;
            this._fn = fn;
        },
        _free: function () {
            this._fn = null;
        },
        _handleValue: function (x) {
            var fn = this._fn;
            var result = fn(x);
            if (result.convert) {
                this._emitError(result.error);
            } else {
                this._emitValue(x);
            }
        }
    };
    var S$39 = createStream('valuesToErrors', mixin$31);
    var P$34 = createProperty('valuesToErrors', mixin$31);
    var defFn = function (x) {
        return {
            convert: true,
            error: x
        };
    };
    function valuesToErrors(obs) {
        var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defFn;
        return new (obs._ofSameType(S$39, P$34))(obs, { fn: fn });
    }
    var mixin$32 = {
        _init: function (_ref) {
            var fn = _ref.fn;
            this._fn = fn;
        },
        _free: function () {
            this._fn = null;
        },
        _handleError: function (x) {
            var fn = this._fn;
            var result = fn(x);
            if (result.convert) {
                this._emitValue(result.value);
            } else {
                this._emitError(x);
            }
        }
    };
    var S$40 = createStream('errorsToValues', mixin$32);
    var P$35 = createProperty('errorsToValues', mixin$32);
    var defFn$1 = function (x) {
        return {
            convert: true,
            value: x
        };
    };
    function errorsToValues(obs) {
        var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defFn$1;
        return new (obs._ofSameType(S$40, P$35))(obs, { fn: fn });
    }
    var mixin$33 = {
        _handleError: function (x) {
            this._emitError(x);
            this._emitEnd();
        }
    };
    var S$41 = createStream('endOnError', mixin$33);
    var P$36 = createProperty('endOnError', mixin$33);
    function endOnError(obs) {
        return new (obs._ofSameType(S$41, P$36))(obs);
    }
    Observable.prototype.toProperty = function (fn) {
        return toProperty(this, fn);
    };
    Observable.prototype.changes = function () {
        return changes(this);
    };
    Observable.prototype.toPromise = function (Promise) {
        return toPromise(this, Promise);
    };
    Observable.prototype.toESObservable = toESObservable;
    Observable.prototype[$$observable] = toESObservable;
    Observable.prototype.map = function (fn) {
        return map$1(this, fn);
    };
    Observable.prototype.filter = function (fn) {
        return filter(this, fn);
    };
    Observable.prototype.take = function (n) {
        return take(this, n);
    };
    Observable.prototype.takeErrors = function (n) {
        return takeErrors(this, n);
    };
    Observable.prototype.takeWhile = function (fn) {
        return takeWhile(this, fn);
    };
    Observable.prototype.last = function () {
        return last(this);
    };
    Observable.prototype.skip = function (n) {
        return skip(this, n);
    };
    Observable.prototype.skipWhile = function (fn) {
        return skipWhile(this, fn);
    };
    Observable.prototype.skipDuplicates = function (fn) {
        return skipDuplicates(this, fn);
    };
    Observable.prototype.diff = function (fn, seed) {
        return diff(this, fn, seed);
    };
    Observable.prototype.scan = function (fn, seed) {
        return scan(this, fn, seed);
    };
    Observable.prototype.flatten = function (fn) {
        return flatten(this, fn);
    };
    Observable.prototype.delay = function (wait) {
        return delay(this, wait);
    };
    Observable.prototype.throttle = function (wait, options) {
        return throttle(this, wait, options);
    };
    Observable.prototype.debounce = function (wait, options) {
        return debounce(this, wait, options);
    };
    Observable.prototype.mapErrors = function (fn) {
        return mapErrors(this, fn);
    };
    Observable.prototype.filterErrors = function (fn) {
        return filterErrors(this, fn);
    };
    Observable.prototype.ignoreValues = function () {
        return ignoreValues(this);
    };
    Observable.prototype.ignoreErrors = function () {
        return ignoreErrors(this);
    };
    Observable.prototype.ignoreEnd = function () {
        return ignoreEnd(this);
    };
    Observable.prototype.beforeEnd = function (fn) {
        return beforeEnd(this, fn);
    };
    Observable.prototype.slidingWindow = function (max, min) {
        return slidingWindow(this, max, min);
    };
    Observable.prototype.bufferWhile = function (fn, options) {
        return bufferWhile(this, fn, options);
    };
    Observable.prototype.bufferWithCount = function (count, options) {
        return bufferWhile$1(this, count, options);
    };
    Observable.prototype.bufferWithTimeOrCount = function (wait, count, options) {
        return bufferWithTimeOrCount(this, wait, count, options);
    };
    Observable.prototype.transduce = function (transducer) {
        return transduce(this, transducer);
    };
    Observable.prototype.withHandler = function (fn) {
        return withHandler(this, fn);
    };
    Observable.prototype.combine = function (other, combinator) {
        return combine([
            this,
            other
        ], combinator);
    };
    Observable.prototype.zip = function (other, combinator) {
        return zip([
            this,
            other
        ], combinator);
    };
    Observable.prototype.merge = function (other) {
        return merge([
            this,
            other
        ]);
    };
    Observable.prototype.concat = function (other) {
        return concat$1([
            this,
            other
        ]);
    };
    var pool = function () {
        return new Pool();
    };
    Observable.prototype.flatMap = function (fn) {
        return new FlatMap(this, fn).setName(this, 'flatMap');
    };
    Observable.prototype.flatMapLatest = function (fn) {
        return new FlatMap(this, fn, {
            concurLim: 1,
            drop: 'old'
        }).setName(this, 'flatMapLatest');
    };
    Observable.prototype.flatMapFirst = function (fn) {
        return new FlatMap(this, fn, { concurLim: 1 }).setName(this, 'flatMapFirst');
    };
    Observable.prototype.flatMapConcat = function (fn) {
        return new FlatMap(this, fn, {
            queueLim: -1,
            concurLim: 1
        }).setName(this, 'flatMapConcat');
    };
    Observable.prototype.flatMapConcurLimit = function (fn, limit) {
        return new FlatMap(this, fn, {
            queueLim: -1,
            concurLim: limit
        }).setName(this, 'flatMapConcurLimit');
    };
    Observable.prototype.flatMapErrors = function (fn) {
        return new FlatMapErrors(this, fn).setName(this, 'flatMapErrors');
    };
    Observable.prototype.filterBy = function (other) {
        return filterBy(this, other);
    };
    Observable.prototype.sampledBy = function (other, combinator) {
        return sampledBy(this, other, combinator);
    };
    Observable.prototype.skipUntilBy = function (other) {
        return skipUntilBy(this, other);
    };
    Observable.prototype.takeUntilBy = function (other) {
        return takeUntilBy(this, other);
    };
    Observable.prototype.bufferBy = function (other, options) {
        return bufferBy(this, other, options);
    };
    Observable.prototype.bufferWhileBy = function (other, options) {
        return bufferWhileBy(this, other, options);
    };
    var DEPRECATION_WARNINGS = true;
    function dissableDeprecationWarnings() {
        DEPRECATION_WARNINGS = false;
    }
    function warn(msg) {
        if (DEPRECATION_WARNINGS && console && typeof console.warn === 'function') {
            var msg2 = '\nHere is an Error object for you containing the call stack:';
            console.warn(msg, msg2, new Error());
        }
    }
    Observable.prototype.awaiting = function (other) {
        warn('You are using deprecated .awaiting() method, see https://github.com/rpominov/kefir/issues/145');
        return awaiting(this, other);
    };
    Observable.prototype.valuesToErrors = function (fn) {
        warn('You are using deprecated .valuesToErrors() method, see https://github.com/rpominov/kefir/issues/149');
        return valuesToErrors(this, fn);
    };
    Observable.prototype.errorsToValues = function (fn) {
        warn('You are using deprecated .errorsToValues() method, see https://github.com/rpominov/kefir/issues/149');
        return errorsToValues(this, fn);
    };
    Observable.prototype.endOnError = function () {
        warn('You are using deprecated .endOnError() method, see https://github.com/rpominov/kefir/issues/150');
        return endOnError(this);
    };
    var Kefir = {
        Observable: Observable,
        Stream: Stream,
        Property: Property,
        never: never,
        later: later,
        interval: interval,
        sequentially: sequentially,
        fromPoll: fromPoll,
        withInterval: withInterval,
        fromCallback: fromCallback,
        fromNodeCallback: fromNodeCallback,
        fromEvents: fromEvents,
        stream: stream,
        constant: constant,
        constantError: constantError,
        fromPromise: fromPromise,
        fromESObservable: fromESObservable,
        combine: combine,
        zip: zip,
        merge: merge,
        concat: concat$1,
        Pool: Pool,
        pool: pool,
        repeat: repeat,
        staticLand: staticLand
    };
    Kefir.Kefir = Kefir;
    exports.dissableDeprecationWarnings = dissableDeprecationWarnings;
    exports.Kefir = Kefir;
    exports.Observable = Observable;
    exports.Stream = Stream;
    exports.Property = Property;
    exports.never = never;
    exports.later = later;
    exports.interval = interval;
    exports.sequentially = sequentially;
    exports.fromPoll = fromPoll;
    exports.withInterval = withInterval;
    exports.fromCallback = fromCallback;
    exports.fromNodeCallback = fromNodeCallback;
    exports.fromEvents = fromEvents;
    exports.stream = stream;
    exports.constant = constant;
    exports.constantError = constantError;
    exports.fromPromise = fromPromise;
    exports.fromESObservable = fromESObservable;
    exports.combine = combine;
    exports.zip = zip;
    exports.merge = merge;
    exports.concat = concat$1;
    exports.Pool = Pool;
    exports.pool = pool;
    exports.repeat = repeat;
    exports.staticLand = staticLand;
    exports['default'] = Kefir;
    Object.defineProperty(exports, '__esModule', { value: true });
}));
/*can-stream-kefir@0.3.1#can-stream-kefir*/
define('can-stream-kefir@0.3.1#can-stream-kefir', function (require, exports, module) {
    var Kefir = require('kefir');
    var compute = require('can-compute');
    var canStream = require('can-stream');
    var canStreamKefir = {};
    canStreamKefir.toStream = function (compute) {
        return Kefir.stream(function (emitter) {
            var changeHandler = function (ev, newVal) {
                emitter.emit(newVal);
            };
            compute.on('change', changeHandler);
            var currentValue = compute();
            if (currentValue !== undefined) {
                emitter.emit(currentValue);
            }
            return function () {
                compute.off('change', changeHandler);
            };
        });
    };
    canStreamKefir.toCompute = function (makeStream, context) {
        var emitter, lastValue, streamHandler, lastSetValue;
        var setterStream = Kefir.stream(function (e) {
                emitter = e;
                if (lastSetValue !== undefined) {
                    emitter.emit(lastSetValue);
                }
            }), valueStream = makeStream.call(context, setterStream);
        return compute(undefined, {
            get: function () {
                return lastValue;
            },
            set: function (val) {
                if (emitter) {
                    emitter.emit(val);
                } else {
                    lastSetValue = val;
                }
                return val;
            },
            on: function (updated) {
                streamHandler = function (val) {
                    lastValue = val;
                    updated();
                };
                valueStream.onValue(streamHandler);
            },
            off: function () {
                valueStream.offValue(streamHandler);
            }
        });
    };
    module.exports = canStream(canStreamKefir);
});
/*can-stream-kefir@0.3.1#can-stream-kefir_test*/
define('can-stream-kefir@0.3.1#can-stream-kefir_test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var canStream = require('can-stream-kefir');
    var compute = require('can-compute');
    var DefineList = require('can-define/list/list');
    QUnit.module('can-stream-kefir');
    test('Compute changes can be streamed', function () {
        var c = compute(0);
        var stream = canStream.toStream(c);
        var computeVal;
        stream.onValue(function (newVal) {
            computeVal = newVal;
        });
        QUnit.equal(computeVal, 0);
        c(1);
        QUnit.equal(computeVal, 1);
        c(2);
        QUnit.equal(computeVal, 2);
        c(3);
        QUnit.equal(computeVal, 3);
    });
    test('Compute streams do not bind to the compute unless activated', function () {
        var c = compute(0);
        var stream = canStream.toStream(c);
        QUnit.equal(c.computeInstance.__bindEvents, undefined);
        stream.onValue(function () {
        });
        QUnit.equal(c.computeInstance.__bindEvents._lifecycleBindings, 1);
    });
    test('Compute stream values can be piped into a compute', function () {
        var expected = 0;
        var c1 = compute(0);
        var c2 = compute(0);
        var resultCompute = canStream.toStream(c1).merge(canStream.toStream(c2));
        resultCompute.onValue(function (val) {
            QUnit.equal(val, expected);
        });
        expected = 1;
        c1(1);
        expected = 2;
        c2(2);
        expected = 3;
        c1(3);
    });
    test('Computed streams fire change events', function () {
        var expected = 0;
        var c1 = compute(expected);
        var c2 = compute(expected);
        var resultCompute = canStream.toStream(c1).merge(canStream.toStream(c2));
        resultCompute.onValue(function (newVal) {
            QUnit.equal(expected, newVal);
        });
        expected = 1;
        c1(expected);
        expected = 2;
        c2(expected);
        expected = 3;
        c1(expected);
    });
    test('Create a stream from a compute with shorthand method: toStream', function () {
        var expected = 0;
        var c1 = compute(0);
        var resultCompute = canStream.toStream(c1);
        resultCompute.onValue(function (val) {
            QUnit.equal(val, expected);
        });
        expected = 1;
        c1(1);
    });
    test('toCompute(streamMaker) can-define-stream#17', function () {
        var c = compute('a');
        var letterStream = canStream.toStream(c);
        var streamedCompute = canStream.toCompute(function (setStream) {
            return setStream.merge(letterStream);
        });
        streamedCompute.on('change', function (ev, newVal) {
        });
        QUnit.deepEqual(streamedCompute(), 'a');
        c(1);
        QUnit.deepEqual(streamedCompute(), 1);
        c('b');
        QUnit.deepEqual(streamedCompute(), 'b');
    });
    test('setting test', function () {
        var c = canStream.toCompute(function (setStream) {
            return setStream;
        });
        c(5);
        c.on('change', function () {
        });
        QUnit.equal(c(), 5);
    });
    test('Stream on DefineList', function () {
        var expectedLength;
        var people = new DefineList([
            {
                first: 'Justin',
                last: 'Meyer'
            },
            {
                first: 'Paula',
                last: 'Strozak'
            }
        ]);
        var stream = canStream.toStream(people, '.length');
        expectedLength = 2;
        stream.onValue(function (newLength) {
            QUnit.equal(newLength, expectedLength, 'List size changed');
        });
        expectedLength = 3;
        people.push({
            first: 'Obaid',
            last: 'Ahmed'
        });
        expectedLength = 2;
        people.pop();
    });
    test('Computes with an initial value of undefined do not emit', function () {
        var expectedLength;
        var people = new DefineList([
            {
                first: 'Justin',
                last: 'Meyer'
            },
            {
                first: 'Paula',
                last: 'Strozak'
            }
        ]);
        var stream = canStream.toStream(people, 'length');
        expectedLength = 2;
        stream.onValue(function (event) {
            QUnit.equal(event.args[0], expectedLength, 'List size changed');
        });
        expectedLength = 3;
        people.push({
            first: 'Obaid',
            last: 'Ahmed'
        });
        expectedLength = 2;
        people.pop();
    });
});
/*can-ndjson-stream@0.1.4#can-ndjson-stream*/
define('can-ndjson-stream@0.1.4#can-ndjson-stream', function (require, exports, module) {
    var namespace = require('can-namespace');
    var ndjsonStream = function (response) {
        var is_reader, cancellationRequest = false;
        return new ReadableStream({
            start: function (controller) {
                var reader = response.getReader();
                is_reader = reader;
                var decoder = new TextDecoder();
                var data_buf = '';
                reader.read().then(function processResult(result) {
                    if (result.done) {
                        if (cancellationRequest) {
                            return;
                        }
                        data_buf = data_buf.trim();
                        if (data_buf.length !== 0) {
                            try {
                                var data_l = JSON.parse(data_buf);
                                controller.enqueue(data_l);
                            } catch (e) {
                                controller.error(e);
                                return;
                            }
                        }
                        controller.close();
                        return;
                    }
                    var data = decoder.decode(result.value, { stream: true });
                    data_buf += data;
                    var lines = data_buf.split('\n');
                    for (var i = 0; i < lines.length - 1; ++i) {
                        var l = lines[i].trim();
                        if (l.length > 0) {
                            try {
                                var data_line = JSON.parse(l);
                                controller.enqueue(data_line);
                            } catch (e) {
                                controller.error(e);
                                cancellationRequest = true;
                                reader.cancel();
                                return;
                            }
                        }
                    }
                    data_buf = lines[lines.length - 1];
                    return reader.read().then(processResult);
                });
            },
            cancel: function (reason) {
                console.log('Cancel registered due to ', reason);
                cancellationRequest = true;
                is_reader.cancel();
            }
        });
    };
    module.exports = namespace.ndjsonStream = ndjsonStream;
});
/*can-ndjson-stream@0.1.4#can-ndjson-stream-test*/
define('can-ndjson-stream@0.1.4#can-ndjson-stream-test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var ndjsonStream = require('can-ndjson-stream');
    var isReadStreamSupported = true;
    try {
        new ReadableStream();
    } catch (err) {
        isReadStreamSupported = false;
    }
    var conditionalTest = isReadStreamSupported ? QUnit.test : QUnit.skip;
    var conditionalAsyncTest = isReadStreamSupported ? QUnit.asyncTest : QUnit.skip;
    function readableStreamFromString(s) {
        return new ReadableStream({
            start: function (controller) {
                var encoder = new TextEncoder();
                var pos = 0;
                var chunkSize = 1;
                function push() {
                    if (pos >= s.length) {
                        controller.close();
                        return;
                    }
                    controller.enqueue(encoder.encode(s.slice(pos, pos + chunkSize)));
                    pos += chunkSize;
                    push();
                }
                push();
            },
            cancel: function () {
            }
        });
    }
    function inputStream(objArray) {
        var jsons = objArray.map(function (obj) {
            return JSON.stringify(obj);
        });
        return readableStreamFromString(jsons.join('\n'));
    }
    QUnit.module('can-ndjson-stream');
    conditionalTest('Initialized the plugin', function () {
        QUnit.equal(typeof ndjsonStream, 'function');
    });
    conditionalAsyncTest('simple_test_from_stream', function (assert) {
        var testObject = [
            {
                'date': '2017-02-24 03:07:45',
                'user': '21109850',
                'fuel': '37',
                'ammo': '2',
                'steel': '13',
                'baux': '5',
                'seaweed': '0',
                'type': 'LOOT',
                'product': '134'
            },
            {
                'date': '2017-02-22 04:40:13',
                'user': '21109850',
                'fuel': '37',
                'ammo': '2',
                'steel': '13',
                'baux': '5',
                'seaweed': '0',
                'type': 'LOOT',
                'product': '75'
            },
            {
                'date': '2017-02-21 20:47:51',
                'user': '26464462',
                'fuel': '37',
                'ammo': '3',
                'steel': '19',
                'baux': '5',
                'seaweed': '1',
                'type': 'LOOT',
                'product': '81'
            }
        ];
        var readObjects = [];
        var todoStream = ndjsonStream(inputStream(testObject));
        function test(todosStream) {
            var reader = todosStream.getReader();
            reader.read().then(function read(result) {
                if (result.done) {
                    assert.deepEqual(readObjects, testObject, 'Two arrays should be the same in value');
                    QUnit.start();
                    return;
                }
                readObjects.push(result.value);
                reader.read().then(read);
            });
        }
        test(todoStream);
    });
    conditionalAsyncTest('maleformed json', function (assert) {
        var maleformed_string = '{"1":2}\n{sss: 2}';
        var readObjects = [];
        var todoStream = ndjsonStream(readableStreamFromString(maleformed_string));
        var reader = todoStream.getReader();
        var errorCaught = false;
        function errCheck() {
            errorCaught = true;
        }
        var allDone = reader.read().then(function read(result) {
            if (result.done) {
                return;
            }
            readObjects.push(result.value);
            return reader.read().then(read, errCheck);
        }, errCheck);
        allDone.then(function () {
            assert.strictEqual(errorCaught, true, 'maleformed json string should cause an error');
            QUnit.start();
        }, function () {
            assert.strictEqual(errorCaught, true, 'rejected: maleformed json string should cause an error');
            QUnit.start();
        });
    });
});
/*can-connect-ndjson@0.1.1#can-connect-ndjson*/
define('can-connect-ndjson@0.1.1#can-connect-ndjson', function (require, exports, module) {
    (function (global) {
        var connect = require('can-connect');
        var sortedSetJSON = require('can-connect/helpers/sorted-set-json');
        var ndJSONStream = require('can-ndjson-stream');
        var canReflect = require('can-reflect');
        var namespace = require('can-namespace');
        var connectNdjson = connect.behavior('data-ndjson', function (baseConnection) {
            try {
                new ReadableStream();
                window.fetch();
            } catch (err) {
                return {};
            }
            return {
                hydrateList: function (listData, set) {
                    set = set || this.listSet(listData);
                    var id = sortedSetJSON(set);
                    var list = baseConnection.hydrateList.call(this, listData, set);
                    if (this._getHydrateListCallbacks[id]) {
                        this._getHydrateListCallbacks[id].shift()(list);
                        if (!this._getHydrateListCallbacks[id].length) {
                            delete this._getHydrateListCallbacks[id];
                        }
                    }
                    return list;
                },
                _getHydrateListCallbacks: {},
                _getHydrateList: function (set, callback) {
                    var id = sortedSetJSON(set);
                    if (!this._getHydrateListCallbacks[id]) {
                        this._getHydrateListCallbacks[id] = [];
                    }
                    this._getHydrateListCallbacks[id].push(callback);
                },
                getListData: function (set) {
                    var fetchPromise = fetch(this.ndjson || this.url);
                    this._getHydrateList(set, function (list) {
                        function streamerr(e) {
                            canReflect.setKeyValue(list, 'isStreaming', false);
                            canReflect.setKeyValue(list, 'streamError', e);
                        }
                        fetchPromise.then(function (response) {
                            canReflect.setKeyValue(list, 'isStreaming', true);
                            return ndJSONStream(response.body);
                        }).then(function (itemStream) {
                            var reader = itemStream.getReader();
                            reader.read().then(function read(result) {
                                if (result.done) {
                                    canReflect.setKeyValue(list, 'isStreaming', false);
                                    return;
                                }
                                list.push(result.value);
                                reader.read().then(read, streamerr);
                            }, streamerr);
                        });
                    });
                    return fetchPromise.then(function () {
                        return { data: [] };
                    });
                }
            };
        });
        module.exports = namespace.connectNdjson = connectNdjson;
    }(function () {
        return this;
    }()));
});
/*can-connect-ndjson@0.1.1#test/can-connect-ndjson-test*/
define('can-connect-ndjson@0.1.1#test/can-connect-ndjson-test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var plugin = require('../can-connect-ndjson');
    var ReadableStream = window.ReadableStream;
    var connect = require('can-connect');
    var DefineList = require('can-define/list/list');
    var DefineMap = require('can-define/map/map');
    var originalFetch = window.fetch;
    var isReadStreamSupported = true;
    try {
        new ReadableStream();
    } catch (err) {
        isReadStreamSupported = false;
    }
    var conditionalTest = isReadStreamSupported ? QUnit.test : QUnit.skip;
    var conditionalAsyncTest = isReadStreamSupported ? QUnit.asyncTest : QUnit.skip;
    QUnit.module('can-connect-ndjson');
    conditionalTest('Initialized the plugin', function (assert) {
        assert.equal(typeof plugin, 'function');
    });
    conditionalTest('Replace fetch with custom version', function (assert) {
        window.fetch = function (url) {
            if (url == 'test') {
                return 'success';
            }
            return Promise.resolve().then(function () {
                return {
                    body: new ReadableStream({
                        start: function (controller) {
                            window.fetch_push = function (data) {
                                var encoder = new TextEncoder();
                                controller.enqueue(encoder.encode(data));
                            };
                            window.fetch_halt = function (reason) {
                                controller.error(reason);
                            };
                            window.fetch_close = function () {
                                controller.close();
                            };
                        }
                    })
                };
            });
        };
        assert.ok(fetch('test') == 'success', 'Fetch replaced.');
    });
    conditionalAsyncTest('Reading a multiline NDJSON', function (assert) {
        var Todo = DefineMap.extend('Todo', {
            id: 'number',
            name: 'string'
        });
        Todo.List = DefineList.extend({ '#': Todo });
        Todo.connection = connect([
            require('can-connect/data/url/url'),
            require('can-connect/constructor/constructor'),
            require('can-connect/constructor/store/store'),
            require('can-connect/can/map/map'),
            require('can-connect-ndjson')
        ], {
            Map: Todo,
            List: Todo.List,
            url: 'foo/bar',
            ndjson: 'foo/bar'
        });
        Todo.getList({}).then(function (oblist) {
            assert.ok(oblist, 'Observable list created.');
            assert.ok(oblist.isStreaming, 'Status is streaming');
            var idata = [
                '{"a":1,"b":2}\n',
                '{"c":3,"d":4}\n\n{"e',
                '":[5]}'
            ];
            var answers = [
                {
                    a: 1,
                    b: 2
                },
                {
                    c: 3,
                    d: 4
                },
                { e: [5] }
            ];
            var timeout = 0;
            var onAdd = function (event, added) {
                clearTimeout(timeout);
                assert.equal(added.length, 1, 'Added exactly 1 object');
                assert.deepEqual(added[0].get(), answers.shift(), 'Gave correct answer');
                var next = idata.shift();
                if (next) {
                    assert.ok(oblist.isStreaming, 'Status is streaming');
                    fetch_push(next);
                    if (idata.length == 0) {
                        fetch_close();
                    }
                    timeout = setTimeout(function () {
                        assert.notOk(true, 'Processing exceeds 1s');
                    }, 1000);
                } else {
                    assert.notOk(oblist.streamError, 'No error should occur');
                    assert.ok(true, 'Reached end of testing');
                    setTimeout(function () {
                        assert.notOk(oblist.isStreaming, 'Status is not streaming');
                    }, 500);
                    QUnit.start();
                }
            };
            var onRemove = function () {
                assert.notOk(true, 'Items are being removed!');
            };
            oblist.on('add', onAdd);
            oblist.on('remove', onRemove);
            fetch_push(idata.shift());
            timeout = setTimeout(function () {
                assert.notOk(true, 'Processing exceeds 1s');
            }, 1000);
        });
    });
    window.fetch = originalFetch;
});
/*can-define-stream@0.2.1#can-define-stream*/
define('can-define-stream@0.2.1#can-define-stream', function (require, exports, module) {
    var define = require('can-define');
    var assign = require('can-util/js/assign/assign');
    var each = require('can-util/js/each/each');
    module.exports = function (canStream) {
        return function (DefineMapType) {
            [
                'toStream',
                'toStreamFromProperty',
                'toStreamFromEvent'
            ].forEach(function (name) {
                DefineMapType.prototype[name] = function () {
                    return canStream[name].apply(canStream, [this].concat([].slice.call(arguments)));
                };
            });
            DefineMapType.prototype.stream = DefineMapType.prototype.toStream;
            var definitions = DefineMapType.prototype._define.definitions, dataInitializers = DefineMapType.prototype._define.dataInitializers, computedInitializers = DefineMapType.prototype._define.computedInitializers;
            each(definitions, function (definition, property) {
                var streamDefinition = definition.stream;
                if (streamDefinition) {
                    var newDefinition = assign({
                        value: function () {
                            return canStream.toCompute(streamDefinition, this);
                        }
                    }, define.types.compute);
                    define.property(DefineMapType.prototype, property, newDefinition, dataInitializers, computedInitializers);
                }
            });
        };
    };
});
/*can-define-stream@0.2.1#can-define-stream_test*/
define('can-define-stream@0.2.1#can-define-stream_test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var DefineMap = require('can-define/map/map');
    var DefineList = require('can-define/list/list');
    var defineStream = require('can-define-stream');
    var compute = require('can-compute');
    var canStream = require('can-stream');
    QUnit.module('can-define-stream');
    var id = 0;
    var canStreamInterface = {
        toStream: function (c) {
            return {
                id: ++id,
                onValue: function (callback) {
                    callback['_computeHandler' + this.id] = function (ev, newVal) {
                        callback(newVal);
                    };
                    c.on('change', callback['_computeHandler' + this.id]);
                    callback(c());
                },
                offValue: function (callback) {
                    c.off('change', callback['_computeHandler' + this.id]);
                }
            };
        },
        toCompute: function (makeStream, context) {
            var lastValue, streamHandler;
            var setCallbacks = [];
            var setterStream = {
                onValue: function (callback) {
                    setCallbacks.push(callback);
                },
                offValue: function (callback) {
                    var index = setCallbacks.indexOf(callback);
                    setCallbacks.splice(index, 1);
                }
            };
            var valueStream = makeStream.call(context, setterStream);
            return compute(undefined, {
                get: function () {
                    return lastValue;
                },
                set: function (val) {
                    setCallbacks.forEach(function (cb) {
                        cb(val);
                    });
                    return val;
                },
                on: function (updated) {
                    streamHandler = function (newVal, oldVal) {
                        lastValue = newVal;
                        updated(lastValue);
                    };
                    valueStream.onValue(streamHandler);
                },
                off: function () {
                    valueStream.offValue(streamHandler);
                }
            });
        }
    };
    var canStreaming = canStream(canStreamInterface);
    test('Stream behavior on multiple properties with merge', 8, function () {
        var expectedNewVal, expectedOldVal, caseName;
        var MyMap = DefineMap.extend('MyMap', {
            foo: 'string',
            bar: {
                type: 'string',
                value: 'bar'
            },
            baz: {
                type: 'string',
                stream: function (setStream) {
                    var mergedCompute = compute();
                    var mergeValue = function (val) {
                        mergedCompute(val);
                    };
                    this.stream('.foo').onValue(mergeValue);
                    this.stream('.bar').onValue(mergeValue);
                    setStream.onValue(mergeValue);
                    return canStreaming.toStream(mergedCompute);
                }
            }
        });
        defineStream(canStreaming)(MyMap);
        var map = new MyMap();
        map.foo = 'foo-1';
        QUnit.equal(map.baz, undefined, 'read value before binding');
        map.on('baz', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, expectedNewVal, caseName + ' newVal');
            QUnit.equal(oldVal, expectedOldVal, caseName + ' oldVal');
        });
        QUnit.equal(map.baz, 'bar', 'read value immediately after binding');
        caseName = 'setting foo';
        expectedOldVal = 'bar';
        expectedNewVal = 'foo-2';
        map.foo = 'foo-2';
        caseName = 'setting bar';
        expectedOldVal = expectedNewVal;
        expectedNewVal = 'new bar';
        map.bar = 'new bar';
        caseName = 'setting baz setter';
        expectedOldVal = expectedNewVal;
        expectedNewVal = 'new baz';
        map.baz = 'new baz';
    });
    test('Test if streams are memory safe', function () {
        var MyMap = DefineMap.extend({
            foo: 'string',
            bar: {
                type: 'string',
                value: 'bar'
            },
            baz: {
                type: 'string',
                stream: function (setStream) {
                    var fooStream = this.stream('.foo');
                    var barStream = this.stream('.bar');
                    var lastValue;
                    var UPDATER;
                    var setLastValue = function (value) {
                        lastValue = value;
                        UPDATER(value);
                    };
                    var mergedCompute = compute(undefined, {
                        on: function (updater) {
                            UPDATER = updater;
                            fooStream.onValue(setLastValue);
                            barStream.onValue(setLastValue);
                            setStream.onValue(setLastValue);
                        },
                        off: function () {
                            fooStream.offValue(setLastValue);
                            barStream.offValue(setLastValue);
                            setStream.offValue(setLastValue);
                        },
                        get: function () {
                            return lastValue;
                        }
                    });
                    return canStreaming.toStream(mergedCompute);
                }
            }
        });
        defineStream(canStreaming)(MyMap);
        var map = new MyMap();
        QUnit.equal(map.__bindEvents._lifecycleBindings, undefined, 'Should have no bindings');
        var handler = function (ev, newVal, oldVal) {
        };
        map.on('baz', handler);
        QUnit.equal(map.__bindEvents._lifecycleBindings, 3, 'Should have 3 bindings');
        map.off('baz', handler);
        QUnit.equal(map.__bindEvents._lifecycleBindings, 0, 'Should reset the bindings');
    });
    test('Stream on DefineList', function () {
        var expectedLength;
        var PeopleList = DefineList.extend({});
        var canStreamInterface = {
            toStream: function (c) {
                return {
                    onValue: function (callback) {
                        c.on('change', function () {
                            callback.apply(null, arguments);
                        });
                    }
                };
            },
            toCompute: function (makeStream, context) {
            }
        };
        var canStreaming = canStream(canStreamInterface);
        defineStream(canStreaming)(PeopleList);
        var people = new PeopleList([
            {
                first: 'Justin',
                last: 'Meyer'
            },
            {
                first: 'Paula',
                last: 'Strozak'
            }
        ]);
        var stream = people.stream('.length');
        expectedLength = 2;
        stream.onValue(function (ev, val) {
            QUnit.equal(val, expectedLength, 'List size changed');
        });
        expectedLength = 3;
        people.push({
            first: 'Obaid',
            last: 'Ahmed'
        });
        expectedLength = 2;
        people.pop();
    });
});
/*can-define-stream-kefir@0.1.0#can-define-stream-kefir*/
define('can-define-stream-kefir@0.1.0#can-define-stream-kefir', function (require, exports, module) {
    var namespace = require('can-util/namespace');
    var canDefineStream = require('can-define-stream');
    var canStreamKefir = require('can-stream-kefir');
    module.exports = namespace.defineStreamKefir = canDefineStream(canStreamKefir);
});
/*can-define-stream-kefir@0.1.0#can-define-stream-kefir_test*/
define('can-define-stream-kefir@0.1.0#can-define-stream-kefir_test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var DefineMap = require('can-define/map/map');
    var DefineList = require('can-define/list/list');
    var canDefineStreamKefir = require('can-define-stream-kefir');
    QUnit.module('can-define-stream-kefir');
    test('Stream behavior on multiple properties with merge', 8, function () {
        var expectedNewVal, expectedOldVal, caseName;
        var MyMap = DefineMap.extend({
            foo: 'string',
            bar: {
                type: 'string',
                value: 'bar'
            },
            baz: {
                type: 'string',
                stream: function (stream) {
                    var fooStream = this.stream('.foo');
                    var barStream = this.stream('.bar');
                    return stream.merge(fooStream).merge(barStream);
                }
            }
        });
        canDefineStreamKefir(MyMap);
        var map = new MyMap();
        map.foo = 'foo-1';
        QUnit.equal(map.baz, undefined, 'read value before binding');
        map.on('baz', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, expectedNewVal, caseName + ' newVal');
            QUnit.equal(oldVal, expectedOldVal, caseName + ' oldVal');
        });
        QUnit.equal(map.baz, 'bar', 'read value immediately after binding');
        caseName = 'setting foo';
        expectedOldVal = 'bar';
        expectedNewVal = 'foo-2';
        map.foo = 'foo-2';
        caseName = 'setting bar';
        expectedOldVal = expectedNewVal;
        expectedNewVal = 'new bar';
        map.bar = 'new bar';
        caseName = 'setting baz setter';
        expectedOldVal = expectedNewVal;
        expectedNewVal = 'new baz';
        map.baz = 'new baz';
    });
    test('Test if streams are memory safe', function () {
        var MyMap = DefineMap.extend({
            foo: 'string',
            bar: {
                type: 'string',
                value: 'bar'
            },
            baz: {
                type: 'string',
                stream: function (stream) {
                    var fooStream = this.stream('.foo');
                    var barStream = this.stream('.bar');
                    return stream.merge(fooStream).merge(barStream);
                }
            }
        });
        canDefineStreamKefir(MyMap);
        var map = new MyMap();
        QUnit.equal(map.__bindEvents._lifecycleBindings, undefined, 'Should have no bindings');
        var handler = function (ev, newVal, oldVal) {
            console.log('newVal', newVal);
        };
        map.on('baz', handler);
        map.foo = 'obaid';
        QUnit.equal(map.__bindEvents._lifecycleBindings, 3, 'Should have 3 bindings');
        map.off('baz', handler);
        QUnit.equal(map.__bindEvents._lifecycleBindings, 0, 'Should reset the bindings');
    });
    test('Keep track of change counts on stream', function () {
        var count;
        var Person = DefineMap.extend({
            first: 'string',
            last: 'string',
            fullName: {
                get: function () {
                    return this.first + ' ' + this.last;
                }
            },
            fullNameChangeCount: {
                stream: function (setStream) {
                    return this.stream('.fullName').scan(function (last) {
                        return last + 1;
                    }, 0);
                }
            }
        });
        canDefineStreamKefir(Person);
        var me = new Person({
            first: 'Justin',
            last: 'Meyer'
        });
        me.on('fullNameChangeCount', function (ev, newVal) {
            QUnit.equal(newVal, count, 'Count should be ' + count);
        });
        count = 2;
        me.first = 'Obaid';
        count = 3;
        me.last = 'Ahmed';
    });
    test('Update map property based on stream value', function () {
        var expected;
        var Person = DefineMap.extend({
            name: 'string',
            lastValidName: {
                stream: function () {
                    return this.stream('.name').filter(function (name) {
                        return name.indexOf(' ') >= 0;
                    });
                }
            }
        });
        canDefineStreamKefir(Person);
        var me = new Person({ name: 'James' });
        me.on('lastValidName', function (lastValid) {
            QUnit.equal(lastValid.target.name, expected, 'Updated name to ' + expected);
        });
        me.name = 'JamesAtherton';
        expected = 'James Atherton';
        me.name = 'James Atherton';
        me.name = 'JustinMeyer';
        expected = 'Justin Meyer';
        me.name = 'Justin Meyer';
    });
    test('Stream on DefineList', function () {
        var expectedLength;
        var People = DefineList.extend({});
        canDefineStreamKefir(People);
        var people = new People([
            {
                first: 'Justin',
                last: 'Meyer'
            },
            {
                first: 'Paula',
                last: 'Strozak'
            }
        ]);
        var stream = people.stream('length');
        stream.onValue(function (event) {
            QUnit.equal(event.args[0], expectedLength, 'List size changed');
        });
        expectedLength = 3;
        people.push({
            first: 'Obaid',
            last: 'Ahmed'
        });
        expectedLength = 2;
        people.pop();
    });
    test('Can instantiate define-map instances with properties that have stream definitions.', function () {
        var Locator = DefineMap.extend({
            state: 'string',
            city: {
                stream: function (setStream) {
                    return this.stream('.state').map(function () {
                        return null;
                    }).merge(setStream);
                }
            }
        });
        canDefineStreamKefir(Locator);
        var locator = new Locator({
            state: 'IL',
            city: 'Chitown'
        });
        QUnit.equal(locator.state, 'IL', 'State in tact, no errors');
        QUnit.equal(typeof locator.city, 'undefined', 'Derived value ignored until bound.');
        locator.on('city', function () {
        });
        QUnit.equal(locator.city, 'Chitown', 'can still get initial value');
        locator.state = 'FL';
        QUnit.equal(locator.city, null, 'Derived value set.');
    });
});
/*object-assign@4.1.0#index*/
define('object-assign@4.1.0#index', function (require, exports, module) {
    'use strict';
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
        if (val === null || val === undefined) {
            throw new TypeError('Object.assign cannot be called with null or undefined');
        }
        return Object(val);
    }
    function shouldUseNative() {
        try {
            if (!Object.assign) {
                return false;
            }
            var test1 = new String('abc');
            test1[5] = 'de';
            if (Object.getOwnPropertyNames(test1)[0] === '5') {
                return false;
            }
            var test2 = {};
            for (var i = 0; i < 10; i++) {
                test2['_' + String.fromCharCode(i)] = i;
            }
            var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
                return test2[n];
            });
            if (order2.join('') !== '0123456789') {
                return false;
            }
            var test3 = {};
            'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
                test3[letter] = letter;
            });
            if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
                return false;
            }
            return true;
        } catch (e) {
            return false;
        }
    }
    module.exports = shouldUseNative() ? Object.assign : function (target, source) {
        var from;
        var to = toObject(target);
        var symbols;
        for (var s = 1; s < arguments.length; s++) {
            from = Object(arguments[s]);
            for (var key in from) {
                if (hasOwnProperty.call(from, key)) {
                    to[key] = from[key];
                }
            }
            if (Object.getOwnPropertySymbols) {
                symbols = Object.getOwnPropertySymbols(from);
                for (var i = 0; i < symbols.length; i++) {
                    if (propIsEnumerable.call(from, symbols[i])) {
                        to[symbols[i]] = from[symbols[i]];
                    }
                }
            }
        }
        return to;
    };
});
/*react@15.6.1#lib/reactProdInvariant*/
define('react@15.6.1#lib/reactProdInvariant', function (require, exports, module) {
    'use strict';
    function reactProdInvariant(code) {
        var argCount = arguments.length - 1;
        var message = 'Minified React error #' + code + '; visit ' + 'http://facebook.github.io/react/docs/error-decoder.html?invariant=' + code;
        for (var argIdx = 0; argIdx < argCount; argIdx++) {
            message += '&args[]=' + encodeURIComponent(arguments[argIdx + 1]);
        }
        message += ' for the full message or use the non-minified dev environment' + ' for full errors and additional helpful warnings.';
        var error = new Error(message);
        error.name = 'Invariant Violation';
        error.framesToPop = 1;
        throw error;
    }
    module.exports = reactProdInvariant;
});
/*fbjs@0.8.12#lib/emptyFunction*/
define('fbjs@0.8.12#lib/emptyFunction', function (require, exports, module) {
    'use strict';
    function makeEmptyFunction(arg) {
        return function () {
            return arg;
        };
    }
    var emptyFunction = function emptyFunction() {
    };
    emptyFunction.thatReturns = makeEmptyFunction;
    emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
    emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
    emptyFunction.thatReturnsNull = makeEmptyFunction(null);
    emptyFunction.thatReturnsThis = function () {
        return this;
    };
    emptyFunction.thatReturnsArgument = function (arg) {
        return arg;
    };
    module.exports = emptyFunction;
});
/*fbjs@0.8.12#lib/warning*/
define('fbjs@0.8.12#lib/warning', function (require, exports, module) {
    'use strict';
    var emptyFunction = require('./emptyFunction');
    var warning = emptyFunction;
    if (process.env.NODE_ENV !== 'production') {
        (function () {
            var printWarning = function printWarning(format) {
                for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    args[_key - 1] = arguments[_key];
                }
                var argIndex = 0;
                var message = 'Warning: ' + format.replace(/%s/g, function () {
                    return args[argIndex++];
                });
                if (typeof console !== 'undefined') {
                    console.error(message);
                }
                try {
                    throw new Error(message);
                } catch (x) {
                }
            };
            warning = function warning(condition, format) {
                if (format === undefined) {
                    throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
                }
                if (format.indexOf('Failed Composite propType: ') === 0) {
                    return;
                }
                if (!condition) {
                    for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
                        args[_key2 - 2] = arguments[_key2];
                    }
                    printWarning.apply(undefined, [format].concat(args));
                }
            };
        }());
    }
    module.exports = warning;
});
/*react@15.6.1#lib/ReactNoopUpdateQueue*/
define('react@15.6.1#lib/ReactNoopUpdateQueue', function (require, exports, module) {
    'use strict';
    var warning = require('fbjs/lib/warning');
    function warnNoop(publicInstance, callerName) {
        if (process.env.NODE_ENV !== 'production') {
            var constructor = publicInstance.constructor;
            process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
        }
    }
    var ReactNoopUpdateQueue = {
        isMounted: function (publicInstance) {
            return false;
        },
        enqueueCallback: function (publicInstance, callback) {
        },
        enqueueForceUpdate: function (publicInstance) {
            warnNoop(publicInstance, 'forceUpdate');
        },
        enqueueReplaceState: function (publicInstance, completeState) {
            warnNoop(publicInstance, 'replaceState');
        },
        enqueueSetState: function (publicInstance, partialState) {
            warnNoop(publicInstance, 'setState');
        }
    };
    module.exports = ReactNoopUpdateQueue;
});
/*react@15.6.1#lib/canDefineProperty*/
define('react@15.6.1#lib/canDefineProperty', function (require, exports, module) {
    'use strict';
    var canDefineProperty = false;
    if (process.env.NODE_ENV !== 'production') {
        try {
            Object.defineProperty({}, 'x', {
                get: function () {
                }
            });
            canDefineProperty = true;
        } catch (x) {
        }
    }
    module.exports = canDefineProperty;
});
/*fbjs@0.8.12#lib/emptyObject*/
define('fbjs@0.8.12#lib/emptyObject', function (require, exports, module) {
    'use strict';
    var emptyObject = {};
    if (process.env.NODE_ENV !== 'production') {
        Object.freeze(emptyObject);
    }
    module.exports = emptyObject;
});
/*fbjs@0.8.12#lib/invariant*/
define('fbjs@0.8.12#lib/invariant', function (require, exports, module) {
    'use strict';
    var validateFormat = function validateFormat(format) {
    };
    if (process.env.NODE_ENV !== 'production') {
        validateFormat = function validateFormat(format) {
            if (format === undefined) {
                throw new Error('invariant requires an error message argument');
            }
        };
    }
    function invariant(condition, format, a, b, c, d, e, f) {
        validateFormat(format);
        if (!condition) {
            var error;
            if (format === undefined) {
                error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
            } else {
                var args = [
                    a,
                    b,
                    c,
                    d,
                    e,
                    f
                ];
                var argIndex = 0;
                error = new Error(format.replace(/%s/g, function () {
                    return args[argIndex++];
                }));
                error.name = 'Invariant Violation';
            }
            error.framesToPop = 1;
            throw error;
        }
    }
    module.exports = invariant;
});
/*react@15.6.1#lib/lowPriorityWarning*/
define('react@15.6.1#lib/lowPriorityWarning', function (require, exports, module) {
    'use strict';
    var lowPriorityWarning = function () {
    };
    if (process.env.NODE_ENV !== 'production') {
        var printWarning = function (format) {
            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
            }
            var argIndex = 0;
            var message = 'Warning: ' + format.replace(/%s/g, function () {
                return args[argIndex++];
            });
            if (typeof console !== 'undefined') {
                console.warn(message);
            }
            try {
                throw new Error(message);
            } catch (x) {
            }
        };
        lowPriorityWarning = function (condition, format) {
            if (format === undefined) {
                throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
            }
            if (!condition) {
                for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
                    args[_key2 - 2] = arguments[_key2];
                }
                printWarning.apply(undefined, [format].concat(args));
            }
        };
    }
    module.exports = lowPriorityWarning;
});
/*react@15.6.1#lib/ReactBaseClasses*/
define('react@15.6.1#lib/ReactBaseClasses', function (require, exports, module) {
    'use strict';
    var _prodInvariant = require('./reactProdInvariant'), _assign = require('object-assign');
    var ReactNoopUpdateQueue = require('./ReactNoopUpdateQueue');
    var canDefineProperty = require('./canDefineProperty');
    var emptyObject = require('fbjs/lib/emptyObject');
    var invariant = require('fbjs/lib/invariant');
    var lowPriorityWarning = require('./lowPriorityWarning');
    function ReactComponent(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
    }
    ReactComponent.prototype.isReactComponent = {};
    ReactComponent.prototype.setState = function (partialState, callback) {
        !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : _prodInvariant('85') : void 0;
        this.updater.enqueueSetState(this, partialState);
        if (callback) {
            this.updater.enqueueCallback(this, callback, 'setState');
        }
    };
    ReactComponent.prototype.forceUpdate = function (callback) {
        this.updater.enqueueForceUpdate(this);
        if (callback) {
            this.updater.enqueueCallback(this, callback, 'forceUpdate');
        }
    };
    if (process.env.NODE_ENV !== 'production') {
        var deprecatedAPIs = {
            isMounted: [
                'isMounted',
                'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'
            ],
            replaceState: [
                'replaceState',
                'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).'
            ]
        };
        var defineDeprecationWarning = function (methodName, info) {
            if (canDefineProperty) {
                Object.defineProperty(ReactComponent.prototype, methodName, {
                    get: function () {
                        lowPriorityWarning(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);
                        return undefined;
                    }
                });
            }
        };
        for (var fnName in deprecatedAPIs) {
            if (deprecatedAPIs.hasOwnProperty(fnName)) {
                defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
            }
        }
    }
    function ReactPureComponent(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
    }
    function ComponentDummy() {
    }
    ComponentDummy.prototype = ReactComponent.prototype;
    ReactPureComponent.prototype = new ComponentDummy();
    ReactPureComponent.prototype.constructor = ReactPureComponent;
    _assign(ReactPureComponent.prototype, ReactComponent.prototype);
    ReactPureComponent.prototype.isPureReactComponent = true;
    module.exports = {
        Component: ReactComponent,
        PureComponent: ReactPureComponent
    };
});
/*react@15.6.1#lib/PooledClass*/
define('react@15.6.1#lib/PooledClass', function (require, exports, module) {
    'use strict';
    var _prodInvariant = require('./reactProdInvariant');
    var invariant = require('fbjs/lib/invariant');
    var oneArgumentPooler = function (copyFieldsFrom) {
        var Klass = this;
        if (Klass.instancePool.length) {
            var instance = Klass.instancePool.pop();
            Klass.call(instance, copyFieldsFrom);
            return instance;
        } else {
            return new Klass(copyFieldsFrom);
        }
    };
    var twoArgumentPooler = function (a1, a2) {
        var Klass = this;
        if (Klass.instancePool.length) {
            var instance = Klass.instancePool.pop();
            Klass.call(instance, a1, a2);
            return instance;
        } else {
            return new Klass(a1, a2);
        }
    };
    var threeArgumentPooler = function (a1, a2, a3) {
        var Klass = this;
        if (Klass.instancePool.length) {
            var instance = Klass.instancePool.pop();
            Klass.call(instance, a1, a2, a3);
            return instance;
        } else {
            return new Klass(a1, a2, a3);
        }
    };
    var fourArgumentPooler = function (a1, a2, a3, a4) {
        var Klass = this;
        if (Klass.instancePool.length) {
            var instance = Klass.instancePool.pop();
            Klass.call(instance, a1, a2, a3, a4);
            return instance;
        } else {
            return new Klass(a1, a2, a3, a4);
        }
    };
    var standardReleaser = function (instance) {
        var Klass = this;
        !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : _prodInvariant('25') : void 0;
        instance.destructor();
        if (Klass.instancePool.length < Klass.poolSize) {
            Klass.instancePool.push(instance);
        }
    };
    var DEFAULT_POOL_SIZE = 10;
    var DEFAULT_POOLER = oneArgumentPooler;
    var addPoolingTo = function (CopyConstructor, pooler) {
        var NewKlass = CopyConstructor;
        NewKlass.instancePool = [];
        NewKlass.getPooled = pooler || DEFAULT_POOLER;
        if (!NewKlass.poolSize) {
            NewKlass.poolSize = DEFAULT_POOL_SIZE;
        }
        NewKlass.release = standardReleaser;
        return NewKlass;
    };
    var PooledClass = {
        addPoolingTo: addPoolingTo,
        oneArgumentPooler: oneArgumentPooler,
        twoArgumentPooler: twoArgumentPooler,
        threeArgumentPooler: threeArgumentPooler,
        fourArgumentPooler: fourArgumentPooler
    };
    module.exports = PooledClass;
});
/*react@15.6.1#lib/ReactCurrentOwner*/
define('react@15.6.1#lib/ReactCurrentOwner', function (require, exports, module) {
    'use strict';
    var ReactCurrentOwner = { current: null };
    module.exports = ReactCurrentOwner;
});
/*react@15.6.1#lib/ReactElementSymbol*/
define('react@15.6.1#lib/ReactElementSymbol', function (require, exports, module) {
    'use strict';
    var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 60103;
    module.exports = REACT_ELEMENT_TYPE;
});
/*react@15.6.1#lib/ReactElement*/
define('react@15.6.1#lib/ReactElement', function (require, exports, module) {
    'use strict';
    var _assign = require('object-assign');
    var ReactCurrentOwner = require('./ReactCurrentOwner');
    var warning = require('fbjs/lib/warning');
    var canDefineProperty = require('./canDefineProperty');
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var REACT_ELEMENT_TYPE = require('./ReactElementSymbol');
    var RESERVED_PROPS = {
        key: true,
        ref: true,
        __self: true,
        __source: true
    };
    var specialPropKeyWarningShown, specialPropRefWarningShown;
    function hasValidRef(config) {
        if (process.env.NODE_ENV !== 'production') {
            if (hasOwnProperty.call(config, 'ref')) {
                var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
                if (getter && getter.isReactWarning) {
                    return false;
                }
            }
        }
        return config.ref !== undefined;
    }
    function hasValidKey(config) {
        if (process.env.NODE_ENV !== 'production') {
            if (hasOwnProperty.call(config, 'key')) {
                var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
                if (getter && getter.isReactWarning) {
                    return false;
                }
            }
        }
        return config.key !== undefined;
    }
    function defineKeyPropWarningGetter(props, displayName) {
        var warnAboutAccessingKey = function () {
            if (!specialPropKeyWarningShown) {
                specialPropKeyWarningShown = true;
                process.env.NODE_ENV !== 'production' ? warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
            }
        };
        warnAboutAccessingKey.isReactWarning = true;
        Object.defineProperty(props, 'key', {
            get: warnAboutAccessingKey,
            configurable: true
        });
    }
    function defineRefPropWarningGetter(props, displayName) {
        var warnAboutAccessingRef = function () {
            if (!specialPropRefWarningShown) {
                specialPropRefWarningShown = true;
                process.env.NODE_ENV !== 'production' ? warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
            }
        };
        warnAboutAccessingRef.isReactWarning = true;
        Object.defineProperty(props, 'ref', {
            get: warnAboutAccessingRef,
            configurable: true
        });
    }
    var ReactElement = function (type, key, ref, self, source, owner, props) {
        var element = {
            $$typeof: REACT_ELEMENT_TYPE,
            type: type,
            key: key,
            ref: ref,
            props: props,
            _owner: owner
        };
        if (process.env.NODE_ENV !== 'production') {
            element._store = {};
            if (canDefineProperty) {
                Object.defineProperty(element._store, 'validated', {
                    configurable: false,
                    enumerable: false,
                    writable: true,
                    value: false
                });
                Object.defineProperty(element, '_self', {
                    configurable: false,
                    enumerable: false,
                    writable: false,
                    value: self
                });
                Object.defineProperty(element, '_source', {
                    configurable: false,
                    enumerable: false,
                    writable: false,
                    value: source
                });
            } else {
                element._store.validated = false;
                element._self = self;
                element._source = source;
            }
            if (Object.freeze) {
                Object.freeze(element.props);
                Object.freeze(element);
            }
        }
        return element;
    };
    ReactElement.createElement = function (type, config, children) {
        var propName;
        var props = {};
        var key = null;
        var ref = null;
        var self = null;
        var source = null;
        if (config != null) {
            if (hasValidRef(config)) {
                ref = config.ref;
            }
            if (hasValidKey(config)) {
                key = '' + config.key;
            }
            self = config.__self === undefined ? null : config.__self;
            source = config.__source === undefined ? null : config.__source;
            for (propName in config) {
                if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                    props[propName] = config[propName];
                }
            }
        }
        var childrenLength = arguments.length - 2;
        if (childrenLength === 1) {
            props.children = children;
        } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i = 0; i < childrenLength; i++) {
                childArray[i] = arguments[i + 2];
            }
            if (process.env.NODE_ENV !== 'production') {
                if (Object.freeze) {
                    Object.freeze(childArray);
                }
            }
            props.children = childArray;
        }
        if (type && type.defaultProps) {
            var defaultProps = type.defaultProps;
            for (propName in defaultProps) {
                if (props[propName] === undefined) {
                    props[propName] = defaultProps[propName];
                }
            }
        }
        if (process.env.NODE_ENV !== 'production') {
            if (key || ref) {
                if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {
                    var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
                    if (key) {
                        defineKeyPropWarningGetter(props, displayName);
                    }
                    if (ref) {
                        defineRefPropWarningGetter(props, displayName);
                    }
                }
            }
        }
        return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
    };
    ReactElement.createFactory = function (type) {
        var factory = ReactElement.createElement.bind(null, type);
        factory.type = type;
        return factory;
    };
    ReactElement.cloneAndReplaceKey = function (oldElement, newKey) {
        var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
        return newElement;
    };
    ReactElement.cloneElement = function (element, config, children) {
        var propName;
        var props = _assign({}, element.props);
        var key = element.key;
        var ref = element.ref;
        var self = element._self;
        var source = element._source;
        var owner = element._owner;
        if (config != null) {
            if (hasValidRef(config)) {
                ref = config.ref;
                owner = ReactCurrentOwner.current;
            }
            if (hasValidKey(config)) {
                key = '' + config.key;
            }
            var defaultProps;
            if (element.type && element.type.defaultProps) {
                defaultProps = element.type.defaultProps;
            }
            for (propName in config) {
                if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                    if (config[propName] === undefined && defaultProps !== undefined) {
                        props[propName] = defaultProps[propName];
                    } else {
                        props[propName] = config[propName];
                    }
                }
            }
        }
        var childrenLength = arguments.length - 2;
        if (childrenLength === 1) {
            props.children = children;
        } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i = 0; i < childrenLength; i++) {
                childArray[i] = arguments[i + 2];
            }
            props.children = childArray;
        }
        return ReactElement(element.type, key, ref, self, source, owner, props);
    };
    ReactElement.isValidElement = function (object) {
        return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
    };
    module.exports = ReactElement;
});
/*react@15.6.1#lib/getIteratorFn*/
define('react@15.6.1#lib/getIteratorFn', function (require, exports, module) {
    (function (global) {
        'use strict';
        var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = '@@iterator';
        function getIteratorFn(maybeIterable) {
            var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
            if (typeof iteratorFn === 'function') {
                return iteratorFn;
            }
        }
        module.exports = getIteratorFn;
    }(function () {
        return this;
    }()));
});
/*react@15.6.1#lib/KeyEscapeUtils*/
define('react@15.6.1#lib/KeyEscapeUtils', function (require, exports, module) {
    'use strict';
    function escape(key) {
        var escapeRegex = /[=:]/g;
        var escaperLookup = {
            '=': '=0',
            ':': '=2'
        };
        var escapedString = ('' + key).replace(escapeRegex, function (match) {
            return escaperLookup[match];
        });
        return '$' + escapedString;
    }
    function unescape(key) {
        var unescapeRegex = /(=0|=2)/g;
        var unescaperLookup = {
            '=0': '=',
            '=2': ':'
        };
        var keySubstring = key[0] === '.' && key[1] === '$' ? key.substring(2) : key.substring(1);
        return ('' + keySubstring).replace(unescapeRegex, function (match) {
            return unescaperLookup[match];
        });
    }
    var KeyEscapeUtils = {
        escape: escape,
        unescape: unescape
    };
    module.exports = KeyEscapeUtils;
});
/*react@15.6.1#lib/traverseAllChildren*/
define('react@15.6.1#lib/traverseAllChildren', function (require, exports, module) {
    'use strict';
    var _prodInvariant = require('./reactProdInvariant');
    var ReactCurrentOwner = require('./ReactCurrentOwner');
    var REACT_ELEMENT_TYPE = require('./ReactElementSymbol');
    var getIteratorFn = require('./getIteratorFn');
    var invariant = require('fbjs/lib/invariant');
    var KeyEscapeUtils = require('./KeyEscapeUtils');
    var warning = require('fbjs/lib/warning');
    var SEPARATOR = '.';
    var SUBSEPARATOR = ':';
    var didWarnAboutMaps = false;
    function getComponentKey(component, index) {
        if (component && typeof component === 'object' && component.key != null) {
            return KeyEscapeUtils.escape(component.key);
        }
        return index.toString(36);
    }
    function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
        var type = typeof children;
        if (type === 'undefined' || type === 'boolean') {
            children = null;
        }
        if (children === null || type === 'string' || type === 'number' || type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE) {
            callback(traverseContext, children, nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
            return 1;
        }
        var child;
        var nextName;
        var subtreeCount = 0;
        var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;
        if (Array.isArray(children)) {
            for (var i = 0; i < children.length; i++) {
                child = children[i];
                nextName = nextNamePrefix + getComponentKey(child, i);
                subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
            }
        } else {
            var iteratorFn = getIteratorFn(children);
            if (iteratorFn) {
                var iterator = iteratorFn.call(children);
                var step;
                if (iteratorFn !== children.entries) {
                    var ii = 0;
                    while (!(step = iterator.next()).done) {
                        child = step.value;
                        nextName = nextNamePrefix + getComponentKey(child, ii++);
                        subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
                    }
                } else {
                    if (process.env.NODE_ENV !== 'production') {
                        var mapsAsChildrenAddendum = '';
                        if (ReactCurrentOwner.current) {
                            var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();
                            if (mapsAsChildrenOwnerName) {
                                mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';
                            }
                        }
                        process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;
                        didWarnAboutMaps = true;
                    }
                    while (!(step = iterator.next()).done) {
                        var entry = step.value;
                        if (entry) {
                            child = entry[1];
                            nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
                            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
                        }
                    }
                }
            } else if (type === 'object') {
                var addendum = '';
                if (process.env.NODE_ENV !== 'production') {
                    addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
                    if (children._isReactElement) {
                        addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
                    }
                    if (ReactCurrentOwner.current) {
                        var name = ReactCurrentOwner.current.getName();
                        if (name) {
                            addendum += ' Check the render method of `' + name + '`.';
                        }
                    }
                }
                var childrenString = String(children);
                !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : void 0;
            }
        }
        return subtreeCount;
    }
    function traverseAllChildren(children, callback, traverseContext) {
        if (children == null) {
            return 0;
        }
        return traverseAllChildrenImpl(children, '', callback, traverseContext);
    }
    module.exports = traverseAllChildren;
});
/*react@15.6.1#lib/ReactChildren*/
define('react@15.6.1#lib/ReactChildren', function (require, exports, module) {
    'use strict';
    var PooledClass = require('./PooledClass');
    var ReactElement = require('./ReactElement');
    var emptyFunction = require('fbjs/lib/emptyFunction');
    var traverseAllChildren = require('./traverseAllChildren');
    var twoArgumentPooler = PooledClass.twoArgumentPooler;
    var fourArgumentPooler = PooledClass.fourArgumentPooler;
    var userProvidedKeyEscapeRegex = /\/+/g;
    function escapeUserProvidedKey(text) {
        return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
    }
    function ForEachBookKeeping(forEachFunction, forEachContext) {
        this.func = forEachFunction;
        this.context = forEachContext;
        this.count = 0;
    }
    ForEachBookKeeping.prototype.destructor = function () {
        this.func = null;
        this.context = null;
        this.count = 0;
    };
    PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);
    function forEachSingleChild(bookKeeping, child, name) {
        var func = bookKeeping.func, context = bookKeeping.context;
        func.call(context, child, bookKeeping.count++);
    }
    function forEachChildren(children, forEachFunc, forEachContext) {
        if (children == null) {
            return children;
        }
        var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
        traverseAllChildren(children, forEachSingleChild, traverseContext);
        ForEachBookKeeping.release(traverseContext);
    }
    function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {
        this.result = mapResult;
        this.keyPrefix = keyPrefix;
        this.func = mapFunction;
        this.context = mapContext;
        this.count = 0;
    }
    MapBookKeeping.prototype.destructor = function () {
        this.result = null;
        this.keyPrefix = null;
        this.func = null;
        this.context = null;
        this.count = 0;
    };
    PooledClass.addPoolingTo(MapBookKeeping, fourArgumentPooler);
    function mapSingleChildIntoContext(bookKeeping, child, childKey) {
        var result = bookKeeping.result, keyPrefix = bookKeeping.keyPrefix, func = bookKeeping.func, context = bookKeeping.context;
        var mappedChild = func.call(context, child, bookKeeping.count++);
        if (Array.isArray(mappedChild)) {
            mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
        } else if (mappedChild != null) {
            if (ReactElement.isValidElement(mappedChild)) {
                mappedChild = ReactElement.cloneAndReplaceKey(mappedChild, keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
            }
            result.push(mappedChild);
        }
    }
    function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
        var escapedPrefix = '';
        if (prefix != null) {
            escapedPrefix = escapeUserProvidedKey(prefix) + '/';
        }
        var traverseContext = MapBookKeeping.getPooled(array, escapedPrefix, func, context);
        traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
        MapBookKeeping.release(traverseContext);
    }
    function mapChildren(children, func, context) {
        if (children == null) {
            return children;
        }
        var result = [];
        mapIntoWithKeyPrefixInternal(children, result, null, func, context);
        return result;
    }
    function forEachSingleChildDummy(traverseContext, child, name) {
        return null;
    }
    function countChildren(children, context) {
        return traverseAllChildren(children, forEachSingleChildDummy, null);
    }
    function toArray(children) {
        var result = [];
        mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
        return result;
    }
    var ReactChildren = {
        forEach: forEachChildren,
        map: mapChildren,
        mapIntoWithKeyPrefixInternal: mapIntoWithKeyPrefixInternal,
        count: countChildren,
        toArray: toArray
    };
    module.exports = ReactChildren;
});
/*react@15.6.1#lib/ReactComponentTreeHook*/
define('react@15.6.1#lib/ReactComponentTreeHook', function (require, exports, module) {
    'use strict';
    var _prodInvariant = require('./reactProdInvariant');
    var ReactCurrentOwner = require('./ReactCurrentOwner');
    var invariant = require('fbjs/lib/invariant');
    var warning = require('fbjs/lib/warning');
    function isNative(fn) {
        var funcToString = Function.prototype.toString;
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
        try {
            var source = funcToString.call(fn);
            return reIsNative.test(source);
        } catch (err) {
            return false;
        }
    }
    var canUseCollections = typeof Array.from === 'function' && typeof Map === 'function' && isNative(Map) && Map.prototype != null && typeof Map.prototype.keys === 'function' && isNative(Map.prototype.keys) && typeof Set === 'function' && isNative(Set) && Set.prototype != null && typeof Set.prototype.keys === 'function' && isNative(Set.prototype.keys);
    var setItem;
    var getItem;
    var removeItem;
    var getItemIDs;
    var addRoot;
    var removeRoot;
    var getRootIDs;
    if (canUseCollections) {
        var itemMap = new Map();
        var rootIDSet = new Set();
        setItem = function (id, item) {
            itemMap.set(id, item);
        };
        getItem = function (id) {
            return itemMap.get(id);
        };
        removeItem = function (id) {
            itemMap['delete'](id);
        };
        getItemIDs = function () {
            return Array.from(itemMap.keys());
        };
        addRoot = function (id) {
            rootIDSet.add(id);
        };
        removeRoot = function (id) {
            rootIDSet['delete'](id);
        };
        getRootIDs = function () {
            return Array.from(rootIDSet.keys());
        };
    } else {
        var itemByKey = {};
        var rootByKey = {};
        var getKeyFromID = function (id) {
            return '.' + id;
        };
        var getIDFromKey = function (key) {
            return parseInt(key.substr(1), 10);
        };
        setItem = function (id, item) {
            var key = getKeyFromID(id);
            itemByKey[key] = item;
        };
        getItem = function (id) {
            var key = getKeyFromID(id);
            return itemByKey[key];
        };
        removeItem = function (id) {
            var key = getKeyFromID(id);
            delete itemByKey[key];
        };
        getItemIDs = function () {
            return Object.keys(itemByKey).map(getIDFromKey);
        };
        addRoot = function (id) {
            var key = getKeyFromID(id);
            rootByKey[key] = true;
        };
        removeRoot = function (id) {
            var key = getKeyFromID(id);
            delete rootByKey[key];
        };
        getRootIDs = function () {
            return Object.keys(rootByKey).map(getIDFromKey);
        };
    }
    var unmountedIDs = [];
    function purgeDeep(id) {
        var item = getItem(id);
        if (item) {
            var childIDs = item.childIDs;
            removeItem(id);
            childIDs.forEach(purgeDeep);
        }
    }
    function describeComponentFrame(name, source, ownerName) {
        return '\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
    }
    function getDisplayName(element) {
        if (element == null) {
            return '#empty';
        } else if (typeof element === 'string' || typeof element === 'number') {
            return '#text';
        } else if (typeof element.type === 'string') {
            return element.type;
        } else {
            return element.type.displayName || element.type.name || 'Unknown';
        }
    }
    function describeID(id) {
        var name = ReactComponentTreeHook.getDisplayName(id);
        var element = ReactComponentTreeHook.getElement(id);
        var ownerID = ReactComponentTreeHook.getOwnerID(id);
        var ownerName;
        if (ownerID) {
            ownerName = ReactComponentTreeHook.getDisplayName(ownerID);
        }
        process.env.NODE_ENV !== 'production' ? warning(element, 'ReactComponentTreeHook: Missing React element for debugID %s when ' + 'building stack', id) : void 0;
        return describeComponentFrame(name, element && element._source, ownerName);
    }
    var ReactComponentTreeHook = {
        onSetChildren: function (id, nextChildIDs) {
            var item = getItem(id);
            !item ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Item must have been set') : _prodInvariant('144') : void 0;
            item.childIDs = nextChildIDs;
            for (var i = 0; i < nextChildIDs.length; i++) {
                var nextChildID = nextChildIDs[i];
                var nextChild = getItem(nextChildID);
                !nextChild ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected hook events to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('140') : void 0;
                !(nextChild.childIDs != null || typeof nextChild.element !== 'object' || nextChild.element == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onSetChildren() to fire for a container child before its parent includes it in onSetChildren().') : _prodInvariant('141') : void 0;
                !nextChild.isMounted ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onMountComponent() to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('71') : void 0;
                if (nextChild.parentID == null) {
                    nextChild.parentID = id;
                }
                !(nextChild.parentID === id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onBeforeMountComponent() parent and onSetChildren() to be consistent (%s has parents %s and %s).', nextChildID, nextChild.parentID, id) : _prodInvariant('142', nextChildID, nextChild.parentID, id) : void 0;
            }
        },
        onBeforeMountComponent: function (id, element, parentID) {
            var item = {
                element: element,
                parentID: parentID,
                text: null,
                childIDs: [],
                isMounted: false,
                updateCount: 0
            };
            setItem(id, item);
        },
        onBeforeUpdateComponent: function (id, element) {
            var item = getItem(id);
            if (!item || !item.isMounted) {
                return;
            }
            item.element = element;
        },
        onMountComponent: function (id) {
            var item = getItem(id);
            !item ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Item must have been set') : _prodInvariant('144') : void 0;
            item.isMounted = true;
            var isRoot = item.parentID === 0;
            if (isRoot) {
                addRoot(id);
            }
        },
        onUpdateComponent: function (id) {
            var item = getItem(id);
            if (!item || !item.isMounted) {
                return;
            }
            item.updateCount++;
        },
        onUnmountComponent: function (id) {
            var item = getItem(id);
            if (item) {
                item.isMounted = false;
                var isRoot = item.parentID === 0;
                if (isRoot) {
                    removeRoot(id);
                }
            }
            unmountedIDs.push(id);
        },
        purgeUnmountedComponents: function () {
            if (ReactComponentTreeHook._preventPurging) {
                return;
            }
            for (var i = 0; i < unmountedIDs.length; i++) {
                var id = unmountedIDs[i];
                purgeDeep(id);
            }
            unmountedIDs.length = 0;
        },
        isMounted: function (id) {
            var item = getItem(id);
            return item ? item.isMounted : false;
        },
        getCurrentStackAddendum: function (topElement) {
            var info = '';
            if (topElement) {
                var name = getDisplayName(topElement);
                var owner = topElement._owner;
                info += describeComponentFrame(name, topElement._source, owner && owner.getName());
            }
            var currentOwner = ReactCurrentOwner.current;
            var id = currentOwner && currentOwner._debugID;
            info += ReactComponentTreeHook.getStackAddendumByID(id);
            return info;
        },
        getStackAddendumByID: function (id) {
            var info = '';
            while (id) {
                info += describeID(id);
                id = ReactComponentTreeHook.getParentID(id);
            }
            return info;
        },
        getChildIDs: function (id) {
            var item = getItem(id);
            return item ? item.childIDs : [];
        },
        getDisplayName: function (id) {
            var element = ReactComponentTreeHook.getElement(id);
            if (!element) {
                return null;
            }
            return getDisplayName(element);
        },
        getElement: function (id) {
            var item = getItem(id);
            return item ? item.element : null;
        },
        getOwnerID: function (id) {
            var element = ReactComponentTreeHook.getElement(id);
            if (!element || !element._owner) {
                return null;
            }
            return element._owner._debugID;
        },
        getParentID: function (id) {
            var item = getItem(id);
            return item ? item.parentID : null;
        },
        getSource: function (id) {
            var item = getItem(id);
            var element = item ? item.element : null;
            var source = element != null ? element._source : null;
            return source;
        },
        getText: function (id) {
            var element = ReactComponentTreeHook.getElement(id);
            if (typeof element === 'string') {
                return element;
            } else if (typeof element === 'number') {
                return '' + element;
            } else {
                return null;
            }
        },
        getUpdateCount: function (id) {
            var item = getItem(id);
            return item ? item.updateCount : 0;
        },
        getRootIDs: getRootIDs,
        getRegisteredIDs: getItemIDs,
        pushNonStandardWarningStack: function (isCreatingElement, currentSource) {
            if (typeof console.reactStack !== 'function') {
                return;
            }
            var stack = [];
            var currentOwner = ReactCurrentOwner.current;
            var id = currentOwner && currentOwner._debugID;
            try {
                if (isCreatingElement) {
                    stack.push({
                        name: id ? ReactComponentTreeHook.getDisplayName(id) : null,
                        fileName: currentSource ? currentSource.fileName : null,
                        lineNumber: currentSource ? currentSource.lineNumber : null
                    });
                }
                while (id) {
                    var element = ReactComponentTreeHook.getElement(id);
                    var parentID = ReactComponentTreeHook.getParentID(id);
                    var ownerID = ReactComponentTreeHook.getOwnerID(id);
                    var ownerName = ownerID ? ReactComponentTreeHook.getDisplayName(ownerID) : null;
                    var source = element && element._source;
                    stack.push({
                        name: ownerName,
                        fileName: source ? source.fileName : null,
                        lineNumber: source ? source.lineNumber : null
                    });
                    id = parentID;
                }
            } catch (err) {
            }
            console.reactStack(stack);
        },
        popNonStandardWarningStack: function () {
            if (typeof console.reactStackEnd !== 'function') {
                return;
            }
            console.reactStackEnd();
        }
    };
    module.exports = ReactComponentTreeHook;
});
/*react@15.6.1#lib/ReactPropTypeLocationNames*/
define('react@15.6.1#lib/ReactPropTypeLocationNames', function (require, exports, module) {
    'use strict';
    var ReactPropTypeLocationNames = {};
    if (process.env.NODE_ENV !== 'production') {
        ReactPropTypeLocationNames = {
            prop: 'prop',
            context: 'context',
            childContext: 'child context'
        };
    }
    module.exports = ReactPropTypeLocationNames;
});
/*react@15.6.1#lib/ReactPropTypesSecret*/
define('react@15.6.1#lib/ReactPropTypesSecret', function (require, exports, module) {
    'use strict';
    var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
    module.exports = ReactPropTypesSecret;
});
/*react@15.6.1#lib/checkReactTypeSpec*/
define('react@15.6.1#lib/checkReactTypeSpec', function (require, exports, module) {
    'use strict';
    var _prodInvariant = require('./reactProdInvariant');
    var ReactPropTypeLocationNames = require('./ReactPropTypeLocationNames');
    var ReactPropTypesSecret = require('./ReactPropTypesSecret');
    var invariant = require('fbjs/lib/invariant');
    var warning = require('fbjs/lib/warning');
    var ReactComponentTreeHook;
    if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
        ReactComponentTreeHook = require('./ReactComponentTreeHook');
    }
    var loggedTypeFailures = {};
    function checkReactTypeSpec(typeSpecs, values, location, componentName, element, debugID) {
        for (var typeSpecName in typeSpecs) {
            if (typeSpecs.hasOwnProperty(typeSpecName)) {
                var error;
                try {
                    !(typeof typeSpecs[typeSpecName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : _prodInvariant('84', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : void 0;
                    error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
                } catch (ex) {
                    error = ex;
                }
                process.env.NODE_ENV !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName, typeof error) : void 0;
                if (error instanceof Error && !(error.message in loggedTypeFailures)) {
                    loggedTypeFailures[error.message] = true;
                    var componentStackInfo = '';
                    if (process.env.NODE_ENV !== 'production') {
                        if (!ReactComponentTreeHook) {
                            ReactComponentTreeHook = require('./ReactComponentTreeHook');
                        }
                        if (debugID !== null) {
                            componentStackInfo = ReactComponentTreeHook.getStackAddendumByID(debugID);
                        } else if (element !== null) {
                            componentStackInfo = ReactComponentTreeHook.getCurrentStackAddendum(element);
                        }
                    }
                    process.env.NODE_ENV !== 'production' ? warning(false, 'Failed %s type: %s%s', location, error.message, componentStackInfo) : void 0;
                }
            }
        }
    }
    module.exports = checkReactTypeSpec;
});
/*react@15.6.1#lib/ReactElementValidator*/
define('react@15.6.1#lib/ReactElementValidator', function (require, exports, module) {
    'use strict';
    var ReactCurrentOwner = require('./ReactCurrentOwner');
    var ReactComponentTreeHook = require('./ReactComponentTreeHook');
    var ReactElement = require('./ReactElement');
    var checkReactTypeSpec = require('./checkReactTypeSpec');
    var canDefineProperty = require('./canDefineProperty');
    var getIteratorFn = require('./getIteratorFn');
    var warning = require('fbjs/lib/warning');
    var lowPriorityWarning = require('./lowPriorityWarning');
    function getDeclarationErrorAddendum() {
        if (ReactCurrentOwner.current) {
            var name = ReactCurrentOwner.current.getName();
            if (name) {
                return ' Check the render method of `' + name + '`.';
            }
        }
        return '';
    }
    function getSourceInfoErrorAddendum(elementProps) {
        if (elementProps !== null && elementProps !== undefined && elementProps.__source !== undefined) {
            var source = elementProps.__source;
            var fileName = source.fileName.replace(/^.*[\\\/]/, '');
            var lineNumber = source.lineNumber;
            return ' Check your code at ' + fileName + ':' + lineNumber + '.';
        }
        return '';
    }
    var ownerHasKeyUseWarning = {};
    function getCurrentComponentErrorInfo(parentType) {
        var info = getDeclarationErrorAddendum();
        if (!info) {
            var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
            if (parentName) {
                info = ' Check the top-level render call using <' + parentName + '>.';
            }
        }
        return info;
    }
    function validateExplicitKey(element, parentType) {
        if (!element._store || element._store.validated || element.key != null) {
            return;
        }
        element._store.validated = true;
        var memoizer = ownerHasKeyUseWarning.uniqueKey || (ownerHasKeyUseWarning.uniqueKey = {});
        var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
        if (memoizer[currentComponentErrorInfo]) {
            return;
        }
        memoizer[currentComponentErrorInfo] = true;
        var childOwner = '';
        if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
            childOwner = ' It was passed a child from ' + element._owner.getName() + '.';
        }
        process.env.NODE_ENV !== 'production' ? warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, ReactComponentTreeHook.getCurrentStackAddendum(element)) : void 0;
    }
    function validateChildKeys(node, parentType) {
        if (typeof node !== 'object') {
            return;
        }
        if (Array.isArray(node)) {
            for (var i = 0; i < node.length; i++) {
                var child = node[i];
                if (ReactElement.isValidElement(child)) {
                    validateExplicitKey(child, parentType);
                }
            }
        } else if (ReactElement.isValidElement(node)) {
            if (node._store) {
                node._store.validated = true;
            }
        } else if (node) {
            var iteratorFn = getIteratorFn(node);
            if (iteratorFn) {
                if (iteratorFn !== node.entries) {
                    var iterator = iteratorFn.call(node);
                    var step;
                    while (!(step = iterator.next()).done) {
                        if (ReactElement.isValidElement(step.value)) {
                            validateExplicitKey(step.value, parentType);
                        }
                    }
                }
            }
        }
    }
    function validatePropTypes(element) {
        var componentClass = element.type;
        if (typeof componentClass !== 'function') {
            return;
        }
        var name = componentClass.displayName || componentClass.name;
        if (componentClass.propTypes) {
            checkReactTypeSpec(componentClass.propTypes, element.props, 'prop', name, element, null);
        }
        if (typeof componentClass.getDefaultProps === 'function') {
            process.env.NODE_ENV !== 'production' ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : void 0;
        }
    }
    var ReactElementValidator = {
        createElement: function (type, props, children) {
            var validType = typeof type === 'string' || typeof type === 'function';
            if (!validType) {
                if (typeof type !== 'function' && typeof type !== 'string') {
                    var info = '';
                    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
                        info += ' You likely forgot to export your component from the file ' + 'it\'s defined in.';
                    }
                    var sourceInfo = getSourceInfoErrorAddendum(props);
                    if (sourceInfo) {
                        info += sourceInfo;
                    } else {
                        info += getDeclarationErrorAddendum();
                    }
                    info += ReactComponentTreeHook.getCurrentStackAddendum();
                    var currentSource = props !== null && props !== undefined && props.__source !== undefined ? props.__source : null;
                    ReactComponentTreeHook.pushNonStandardWarningStack(true, currentSource);
                    process.env.NODE_ENV !== 'production' ? warning(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', type == null ? type : typeof type, info) : void 0;
                    ReactComponentTreeHook.popNonStandardWarningStack();
                }
            }
            var element = ReactElement.createElement.apply(this, arguments);
            if (element == null) {
                return element;
            }
            if (validType) {
                for (var i = 2; i < arguments.length; i++) {
                    validateChildKeys(arguments[i], type);
                }
            }
            validatePropTypes(element);
            return element;
        },
        createFactory: function (type) {
            var validatedFactory = ReactElementValidator.createElement.bind(null, type);
            validatedFactory.type = type;
            if (process.env.NODE_ENV !== 'production') {
                if (canDefineProperty) {
                    Object.defineProperty(validatedFactory, 'type', {
                        enumerable: false,
                        get: function () {
                            lowPriorityWarning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');
                            Object.defineProperty(this, 'type', { value: type });
                            return type;
                        }
                    });
                }
            }
            return validatedFactory;
        },
        cloneElement: function (element, props, children) {
            var newElement = ReactElement.cloneElement.apply(this, arguments);
            for (var i = 2; i < arguments.length; i++) {
                validateChildKeys(arguments[i], newElement.type);
            }
            validatePropTypes(newElement);
            return newElement;
        }
    };
    module.exports = ReactElementValidator;
});
/*react@15.6.1#lib/ReactDOMFactories*/
define('react@15.6.1#lib/ReactDOMFactories', function (require, exports, module) {
    'use strict';
    var ReactElement = require('./ReactElement');
    var createDOMFactory = ReactElement.createFactory;
    if (process.env.NODE_ENV !== 'production') {
        var ReactElementValidator = require('./ReactElementValidator');
        createDOMFactory = ReactElementValidator.createFactory;
    }
    var ReactDOMFactories = {
        a: createDOMFactory('a'),
        abbr: createDOMFactory('abbr'),
        address: createDOMFactory('address'),
        area: createDOMFactory('area'),
        article: createDOMFactory('article'),
        aside: createDOMFactory('aside'),
        audio: createDOMFactory('audio'),
        b: createDOMFactory('b'),
        base: createDOMFactory('base'),
        bdi: createDOMFactory('bdi'),
        bdo: createDOMFactory('bdo'),
        big: createDOMFactory('big'),
        blockquote: createDOMFactory('blockquote'),
        body: createDOMFactory('body'),
        br: createDOMFactory('br'),
        button: createDOMFactory('button'),
        canvas: createDOMFactory('canvas'),
        caption: createDOMFactory('caption'),
        cite: createDOMFactory('cite'),
        code: createDOMFactory('code'),
        col: createDOMFactory('col'),
        colgroup: createDOMFactory('colgroup'),
        data: createDOMFactory('data'),
        datalist: createDOMFactory('datalist'),
        dd: createDOMFactory('dd'),
        del: createDOMFactory('del'),
        details: createDOMFactory('details'),
        dfn: createDOMFactory('dfn'),
        dialog: createDOMFactory('dialog'),
        div: createDOMFactory('div'),
        dl: createDOMFactory('dl'),
        dt: createDOMFactory('dt'),
        em: createDOMFactory('em'),
        embed: createDOMFactory('embed'),
        fieldset: createDOMFactory('fieldset'),
        figcaption: createDOMFactory('figcaption'),
        figure: createDOMFactory('figure'),
        footer: createDOMFactory('footer'),
        form: createDOMFactory('form'),
        h1: createDOMFactory('h1'),
        h2: createDOMFactory('h2'),
        h3: createDOMFactory('h3'),
        h4: createDOMFactory('h4'),
        h5: createDOMFactory('h5'),
        h6: createDOMFactory('h6'),
        head: createDOMFactory('head'),
        header: createDOMFactory('header'),
        hgroup: createDOMFactory('hgroup'),
        hr: createDOMFactory('hr'),
        html: createDOMFactory('html'),
        i: createDOMFactory('i'),
        iframe: createDOMFactory('iframe'),
        img: createDOMFactory('img'),
        input: createDOMFactory('input'),
        ins: createDOMFactory('ins'),
        kbd: createDOMFactory('kbd'),
        keygen: createDOMFactory('keygen'),
        label: createDOMFactory('label'),
        legend: createDOMFactory('legend'),
        li: createDOMFactory('li'),
        link: createDOMFactory('link'),
        main: createDOMFactory('main'),
        map: createDOMFactory('map'),
        mark: createDOMFactory('mark'),
        menu: createDOMFactory('menu'),
        menuitem: createDOMFactory('menuitem'),
        meta: createDOMFactory('meta'),
        meter: createDOMFactory('meter'),
        nav: createDOMFactory('nav'),
        noscript: createDOMFactory('noscript'),
        object: createDOMFactory('object'),
        ol: createDOMFactory('ol'),
        optgroup: createDOMFactory('optgroup'),
        option: createDOMFactory('option'),
        output: createDOMFactory('output'),
        p: createDOMFactory('p'),
        param: createDOMFactory('param'),
        picture: createDOMFactory('picture'),
        pre: createDOMFactory('pre'),
        progress: createDOMFactory('progress'),
        q: createDOMFactory('q'),
        rp: createDOMFactory('rp'),
        rt: createDOMFactory('rt'),
        ruby: createDOMFactory('ruby'),
        s: createDOMFactory('s'),
        samp: createDOMFactory('samp'),
        script: createDOMFactory('script'),
        section: createDOMFactory('section'),
        select: createDOMFactory('select'),
        small: createDOMFactory('small'),
        source: createDOMFactory('source'),
        span: createDOMFactory('span'),
        strong: createDOMFactory('strong'),
        style: createDOMFactory('style'),
        sub: createDOMFactory('sub'),
        summary: createDOMFactory('summary'),
        sup: createDOMFactory('sup'),
        table: createDOMFactory('table'),
        tbody: createDOMFactory('tbody'),
        td: createDOMFactory('td'),
        textarea: createDOMFactory('textarea'),
        tfoot: createDOMFactory('tfoot'),
        th: createDOMFactory('th'),
        thead: createDOMFactory('thead'),
        time: createDOMFactory('time'),
        title: createDOMFactory('title'),
        tr: createDOMFactory('tr'),
        track: createDOMFactory('track'),
        u: createDOMFactory('u'),
        ul: createDOMFactory('ul'),
        'var': createDOMFactory('var'),
        video: createDOMFactory('video'),
        wbr: createDOMFactory('wbr'),
        circle: createDOMFactory('circle'),
        clipPath: createDOMFactory('clipPath'),
        defs: createDOMFactory('defs'),
        ellipse: createDOMFactory('ellipse'),
        g: createDOMFactory('g'),
        image: createDOMFactory('image'),
        line: createDOMFactory('line'),
        linearGradient: createDOMFactory('linearGradient'),
        mask: createDOMFactory('mask'),
        path: createDOMFactory('path'),
        pattern: createDOMFactory('pattern'),
        polygon: createDOMFactory('polygon'),
        polyline: createDOMFactory('polyline'),
        radialGradient: createDOMFactory('radialGradient'),
        rect: createDOMFactory('rect'),
        stop: createDOMFactory('stop'),
        svg: createDOMFactory('svg'),
        text: createDOMFactory('text'),
        tspan: createDOMFactory('tspan')
    };
    module.exports = ReactDOMFactories;
});
/*prop-types@15.5.10#lib/ReactPropTypesSecret*/
define('prop-types@15.5.10#lib/ReactPropTypesSecret', function (require, exports, module) {
    'use strict';
    var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
    module.exports = ReactPropTypesSecret;
});
/*prop-types@15.5.10#checkPropTypes*/
define('prop-types@15.5.10#checkPropTypes', function (require, exports, module) {
    'use strict';
    if (process.env.NODE_ENV !== 'production') {
        var invariant = require('fbjs/lib/invariant');
        var warning = require('fbjs/lib/warning');
        var ReactPropTypesSecret = require('./lib/ReactPropTypesSecret');
        var loggedTypeFailures = {};
    }
    function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
        if (process.env.NODE_ENV !== 'production') {
            for (var typeSpecName in typeSpecs) {
                if (typeSpecs.hasOwnProperty(typeSpecName)) {
                    var error;
                    try {
                        invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', componentName || 'React class', location, typeSpecName);
                        error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
                    } catch (ex) {
                        error = ex;
                    }
                    warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error);
                    if (error instanceof Error && !(error.message in loggedTypeFailures)) {
                        loggedTypeFailures[error.message] = true;
                        var stack = getStack ? getStack() : '';
                        warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');
                    }
                }
            }
        }
    }
    module.exports = checkPropTypes;
});
/*prop-types@15.5.10#factoryWithTypeCheckers*/
define('prop-types@15.5.10#factoryWithTypeCheckers', function (require, exports, module) {
    (function (global) {
        'use strict';
        var emptyFunction = require('fbjs/lib/emptyFunction');
        var invariant = require('fbjs/lib/invariant');
        var warning = require('fbjs/lib/warning');
        var ReactPropTypesSecret = require('./lib/ReactPropTypesSecret');
        var checkPropTypes = require('./checkPropTypes');
        module.exports = function (isValidElement, throwOnDirectAccess) {
            var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
            var FAUX_ITERATOR_SYMBOL = '@@iterator';
            function getIteratorFn(maybeIterable) {
                var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
                if (typeof iteratorFn === 'function') {
                    return iteratorFn;
                }
            }
            var ANONYMOUS = '<<anonymous>>';
            var ReactPropTypes = {
                array: createPrimitiveTypeChecker('array'),
                bool: createPrimitiveTypeChecker('boolean'),
                func: createPrimitiveTypeChecker('function'),
                number: createPrimitiveTypeChecker('number'),
                object: createPrimitiveTypeChecker('object'),
                string: createPrimitiveTypeChecker('string'),
                symbol: createPrimitiveTypeChecker('symbol'),
                any: createAnyTypeChecker(),
                arrayOf: createArrayOfTypeChecker,
                element: createElementTypeChecker(),
                instanceOf: createInstanceTypeChecker,
                node: createNodeChecker(),
                objectOf: createObjectOfTypeChecker,
                oneOf: createEnumTypeChecker,
                oneOfType: createUnionTypeChecker,
                shape: createShapeTypeChecker
            };
            function is(x, y) {
                if (x === y) {
                    return x !== 0 || 1 / x === 1 / y;
                } else {
                    return x !== x && y !== y;
                }
            }
            function PropTypeError(message) {
                this.message = message;
                this.stack = '';
            }
            PropTypeError.prototype = Error.prototype;
            function createChainableTypeChecker(validate) {
                if (process.env.NODE_ENV !== 'production') {
                    var manualPropTypeCallCache = {};
                    var manualPropTypeWarningCount = 0;
                }
                function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
                    componentName = componentName || ANONYMOUS;
                    propFullName = propFullName || propName;
                    if (secret !== ReactPropTypesSecret) {
                        if (throwOnDirectAccess) {
                            invariant(false, 'Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use `PropTypes.checkPropTypes()` to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
                        } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
                            var cacheKey = componentName + ':' + propName;
                            if (!manualPropTypeCallCache[cacheKey] && manualPropTypeWarningCount < 3) {
                                warning(false, 'You are manually calling a React.PropTypes validation ' + 'function for the `%s` prop on `%s`. This is deprecated ' + 'and will throw in the standalone `prop-types` package. ' + 'You may be seeing this warning due to a third-party PropTypes ' + 'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.', propFullName, componentName);
                                manualPropTypeCallCache[cacheKey] = true;
                                manualPropTypeWarningCount++;
                            }
                        }
                    }
                    if (props[propName] == null) {
                        if (isRequired) {
                            if (props[propName] === null) {
                                return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
                            }
                            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
                        }
                        return null;
                    } else {
                        return validate(props, propName, componentName, location, propFullName);
                    }
                }
                var chainedCheckType = checkType.bind(null, false);
                chainedCheckType.isRequired = checkType.bind(null, true);
                return chainedCheckType;
            }
            function createPrimitiveTypeChecker(expectedType) {
                function validate(props, propName, componentName, location, propFullName, secret) {
                    var propValue = props[propName];
                    var propType = getPropType(propValue);
                    if (propType !== expectedType) {
                        var preciseType = getPreciseType(propValue);
                        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
                    }
                    return null;
                }
                return createChainableTypeChecker(validate);
            }
            function createAnyTypeChecker() {
                return createChainableTypeChecker(emptyFunction.thatReturnsNull);
            }
            function createArrayOfTypeChecker(typeChecker) {
                function validate(props, propName, componentName, location, propFullName) {
                    if (typeof typeChecker !== 'function') {
                        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
                    }
                    var propValue = props[propName];
                    if (!Array.isArray(propValue)) {
                        var propType = getPropType(propValue);
                        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
                    }
                    for (var i = 0; i < propValue.length; i++) {
                        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
                        if (error instanceof Error) {
                            return error;
                        }
                    }
                    return null;
                }
                return createChainableTypeChecker(validate);
            }
            function createElementTypeChecker() {
                function validate(props, propName, componentName, location, propFullName) {
                    var propValue = props[propName];
                    if (!isValidElement(propValue)) {
                        var propType = getPropType(propValue);
                        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
                    }
                    return null;
                }
                return createChainableTypeChecker(validate);
            }
            function createInstanceTypeChecker(expectedClass) {
                function validate(props, propName, componentName, location, propFullName) {
                    if (!(props[propName] instanceof expectedClass)) {
                        var expectedClassName = expectedClass.name || ANONYMOUS;
                        var actualClassName = getClassName(props[propName]);
                        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
                    }
                    return null;
                }
                return createChainableTypeChecker(validate);
            }
            function createEnumTypeChecker(expectedValues) {
                if (!Array.isArray(expectedValues)) {
                    process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
                    return emptyFunction.thatReturnsNull;
                }
                function validate(props, propName, componentName, location, propFullName) {
                    var propValue = props[propName];
                    for (var i = 0; i < expectedValues.length; i++) {
                        if (is(propValue, expectedValues[i])) {
                            return null;
                        }
                    }
                    var valuesString = JSON.stringify(expectedValues);
                    return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
                }
                return createChainableTypeChecker(validate);
            }
            function createObjectOfTypeChecker(typeChecker) {
                function validate(props, propName, componentName, location, propFullName) {
                    if (typeof typeChecker !== 'function') {
                        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
                    }
                    var propValue = props[propName];
                    var propType = getPropType(propValue);
                    if (propType !== 'object') {
                        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
                    }
                    for (var key in propValue) {
                        if (propValue.hasOwnProperty(key)) {
                            var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
                            if (error instanceof Error) {
                                return error;
                            }
                        }
                    }
                    return null;
                }
                return createChainableTypeChecker(validate);
            }
            function createUnionTypeChecker(arrayOfTypeCheckers) {
                if (!Array.isArray(arrayOfTypeCheckers)) {
                    process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
                    return emptyFunction.thatReturnsNull;
                }
                for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
                    var checker = arrayOfTypeCheckers[i];
                    if (typeof checker !== 'function') {
                        warning(false, 'Invalid argument supplid to oneOfType. Expected an array of check functions, but ' + 'received %s at index %s.', getPostfixForTypeWarning(checker), i);
                        return emptyFunction.thatReturnsNull;
                    }
                }
                function validate(props, propName, componentName, location, propFullName) {
                    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
                        var checker = arrayOfTypeCheckers[i];
                        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
                            return null;
                        }
                    }
                    return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
                }
                return createChainableTypeChecker(validate);
            }
            function createNodeChecker() {
                function validate(props, propName, componentName, location, propFullName) {
                    if (!isNode(props[propName])) {
                        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
                    }
                    return null;
                }
                return createChainableTypeChecker(validate);
            }
            function createShapeTypeChecker(shapeTypes) {
                function validate(props, propName, componentName, location, propFullName) {
                    var propValue = props[propName];
                    var propType = getPropType(propValue);
                    if (propType !== 'object') {
                        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
                    }
                    for (var key in shapeTypes) {
                        var checker = shapeTypes[key];
                        if (!checker) {
                            continue;
                        }
                        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
                        if (error) {
                            return error;
                        }
                    }
                    return null;
                }
                return createChainableTypeChecker(validate);
            }
            function isNode(propValue) {
                switch (typeof propValue) {
                case 'number':
                case 'string':
                case 'undefined':
                    return true;
                case 'boolean':
                    return !propValue;
                case 'object':
                    if (Array.isArray(propValue)) {
                        return propValue.every(isNode);
                    }
                    if (propValue === null || isValidElement(propValue)) {
                        return true;
                    }
                    var iteratorFn = getIteratorFn(propValue);
                    if (iteratorFn) {
                        var iterator = iteratorFn.call(propValue);
                        var step;
                        if (iteratorFn !== propValue.entries) {
                            while (!(step = iterator.next()).done) {
                                if (!isNode(step.value)) {
                                    return false;
                                }
                            }
                        } else {
                            while (!(step = iterator.next()).done) {
                                var entry = step.value;
                                if (entry) {
                                    if (!isNode(entry[1])) {
                                        return false;
                                    }
                                }
                            }
                        }
                    } else {
                        return false;
                    }
                    return true;
                default:
                    return false;
                }
            }
            function isSymbol(propType, propValue) {
                if (propType === 'symbol') {
                    return true;
                }
                if (propValue['@@toStringTag'] === 'Symbol') {
                    return true;
                }
                if (typeof Symbol === 'function' && propValue instanceof Symbol) {
                    return true;
                }
                return false;
            }
            function getPropType(propValue) {
                var propType = typeof propValue;
                if (Array.isArray(propValue)) {
                    return 'array';
                }
                if (propValue instanceof RegExp) {
                    return 'object';
                }
                if (isSymbol(propType, propValue)) {
                    return 'symbol';
                }
                return propType;
            }
            function getPreciseType(propValue) {
                if (typeof propValue === 'undefined' || propValue === null) {
                    return '' + propValue;
                }
                var propType = getPropType(propValue);
                if (propType === 'object') {
                    if (propValue instanceof Date) {
                        return 'date';
                    } else if (propValue instanceof RegExp) {
                        return 'regexp';
                    }
                }
                return propType;
            }
            function getPostfixForTypeWarning(value) {
                var type = getPreciseType(value);
                switch (type) {
                case 'array':
                case 'object':
                    return 'an ' + type;
                case 'boolean':
                case 'date':
                case 'regexp':
                    return 'a ' + type;
                default:
                    return type;
                }
            }
            function getClassName(propValue) {
                if (!propValue.constructor || !propValue.constructor.name) {
                    return ANONYMOUS;
                }
                return propValue.constructor.name;
            }
            ReactPropTypes.checkPropTypes = checkPropTypes;
            ReactPropTypes.PropTypes = ReactPropTypes;
            return ReactPropTypes;
        };
    }(function () {
        return this;
    }()));
});
/*prop-types@15.5.10#factory*/
define('prop-types@15.5.10#factory', function (require, exports, module) {
    'use strict';
    var factory = require('./factoryWithTypeCheckers');
    module.exports = function (isValidElement) {
        var throwOnDirectAccess = false;
        return factory(isValidElement, throwOnDirectAccess);
    };
});
/*react@15.6.1#lib/ReactPropTypes*/
define('react@15.6.1#lib/ReactPropTypes', function (require, exports, module) {
    'use strict';
    var _require = require('./ReactElement'), isValidElement = _require.isValidElement;
    var factory = require('prop-types/factory');
    module.exports = factory(isValidElement);
});
/*react@15.6.1#lib/ReactVersion*/
define('react@15.6.1#lib/ReactVersion', function (require, exports, module) {
    'use strict';
    module.exports = '15.6.1';
});
/*object-assign@4.1.1#index*/
define('object-assign@4.1.1#index', function (require, exports, module) {
    'use strict';
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
        if (val === null || val === undefined) {
            throw new TypeError('Object.assign cannot be called with null or undefined');
        }
        return Object(val);
    }
    function shouldUseNative() {
        try {
            if (!Object.assign) {
                return false;
            }
            var test1 = new String('abc');
            test1[5] = 'de';
            if (Object.getOwnPropertyNames(test1)[0] === '5') {
                return false;
            }
            var test2 = {};
            for (var i = 0; i < 10; i++) {
                test2['_' + String.fromCharCode(i)] = i;
            }
            var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
                return test2[n];
            });
            if (order2.join('') !== '0123456789') {
                return false;
            }
            var test3 = {};
            'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
                test3[letter] = letter;
            });
            if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
                return false;
            }
            return true;
        } catch (err) {
            return false;
        }
    }
    module.exports = shouldUseNative() ? Object.assign : function (target, source) {
        var from;
        var to = toObject(target);
        var symbols;
        for (var s = 1; s < arguments.length; s++) {
            from = Object(arguments[s]);
            for (var key in from) {
                if (hasOwnProperty.call(from, key)) {
                    to[key] = from[key];
                }
            }
            if (getOwnPropertySymbols) {
                symbols = getOwnPropertySymbols(from);
                for (var i = 0; i < symbols.length; i++) {
                    if (propIsEnumerable.call(from, symbols[i])) {
                        to[symbols[i]] = from[symbols[i]];
                    }
                }
            }
        }
        return to;
    };
});
/*create-react-class@15.6.0#factory*/
define('create-react-class@15.6.0#factory', function (require, exports, module) {
    'use strict';
    var _assign = require('object-assign');
    var emptyObject = require('fbjs/lib/emptyObject');
    var _invariant = require('fbjs/lib/invariant');
    if (process.env.NODE_ENV !== 'production') {
        var warning = require('fbjs/lib/warning');
    }
    var MIXINS_KEY = 'mixins';
    function identity(fn) {
        return fn;
    }
    var ReactPropTypeLocationNames;
    if (process.env.NODE_ENV !== 'production') {
        ReactPropTypeLocationNames = {
            prop: 'prop',
            context: 'context',
            childContext: 'child context'
        };
    } else {
        ReactPropTypeLocationNames = {};
    }
    function factory(ReactComponent, isValidElement, ReactNoopUpdateQueue) {
        var injectedMixins = [];
        var ReactClassInterface = {
            mixins: 'DEFINE_MANY',
            statics: 'DEFINE_MANY',
            propTypes: 'DEFINE_MANY',
            contextTypes: 'DEFINE_MANY',
            childContextTypes: 'DEFINE_MANY',
            getDefaultProps: 'DEFINE_MANY_MERGED',
            getInitialState: 'DEFINE_MANY_MERGED',
            getChildContext: 'DEFINE_MANY_MERGED',
            render: 'DEFINE_ONCE',
            componentWillMount: 'DEFINE_MANY',
            componentDidMount: 'DEFINE_MANY',
            componentWillReceiveProps: 'DEFINE_MANY',
            shouldComponentUpdate: 'DEFINE_ONCE',
            componentWillUpdate: 'DEFINE_MANY',
            componentDidUpdate: 'DEFINE_MANY',
            componentWillUnmount: 'DEFINE_MANY',
            updateComponent: 'OVERRIDE_BASE'
        };
        var RESERVED_SPEC_KEYS = {
            displayName: function (Constructor, displayName) {
                Constructor.displayName = displayName;
            },
            mixins: function (Constructor, mixins) {
                if (mixins) {
                    for (var i = 0; i < mixins.length; i++) {
                        mixSpecIntoComponent(Constructor, mixins[i]);
                    }
                }
            },
            childContextTypes: function (Constructor, childContextTypes) {
                if (process.env.NODE_ENV !== 'production') {
                    validateTypeDef(Constructor, childContextTypes, 'childContext');
                }
                Constructor.childContextTypes = _assign({}, Constructor.childContextTypes, childContextTypes);
            },
            contextTypes: function (Constructor, contextTypes) {
                if (process.env.NODE_ENV !== 'production') {
                    validateTypeDef(Constructor, contextTypes, 'context');
                }
                Constructor.contextTypes = _assign({}, Constructor.contextTypes, contextTypes);
            },
            getDefaultProps: function (Constructor, getDefaultProps) {
                if (Constructor.getDefaultProps) {
                    Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps);
                } else {
                    Constructor.getDefaultProps = getDefaultProps;
                }
            },
            propTypes: function (Constructor, propTypes) {
                if (process.env.NODE_ENV !== 'production') {
                    validateTypeDef(Constructor, propTypes, 'prop');
                }
                Constructor.propTypes = _assign({}, Constructor.propTypes, propTypes);
            },
            statics: function (Constructor, statics) {
                mixStaticSpecIntoComponent(Constructor, statics);
            },
            autobind: function () {
            }
        };
        function validateTypeDef(Constructor, typeDef, location) {
            for (var propName in typeDef) {
                if (typeDef.hasOwnProperty(propName)) {
                    if (process.env.NODE_ENV !== 'production') {
                        warning(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName);
                    }
                }
            }
        }
        function validateMethodOverride(isAlreadyDefined, name) {
            var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;
            if (ReactClassMixin.hasOwnProperty(name)) {
                _invariant(specPolicy === 'OVERRIDE_BASE', 'ReactClassInterface: You are attempting to override ' + '`%s` from your class specification. Ensure that your method names ' + 'do not overlap with React methods.', name);
            }
            if (isAlreadyDefined) {
                _invariant(specPolicy === 'DEFINE_MANY' || specPolicy === 'DEFINE_MANY_MERGED', 'ReactClassInterface: You are attempting to define ' + '`%s` on your component more than once. This conflict may be due ' + 'to a mixin.', name);
            }
        }
        function mixSpecIntoComponent(Constructor, spec) {
            if (!spec) {
                if (process.env.NODE_ENV !== 'production') {
                    var typeofSpec = typeof spec;
                    var isMixinValid = typeofSpec === 'object' && spec !== null;
                    if (process.env.NODE_ENV !== 'production') {
                        warning(isMixinValid, '%s: You\'re attempting to include a mixin that is either null ' + 'or not an object. Check the mixins included by the component, ' + 'as well as any mixins they include themselves. ' + 'Expected object but got %s.', Constructor.displayName || 'ReactClass', spec === null ? null : typeofSpec);
                    }
                }
                return;
            }
            _invariant(typeof spec !== 'function', 'ReactClass: You\'re attempting to ' + 'use a component class or function as a mixin. Instead, just use a ' + 'regular object.');
            _invariant(!isValidElement(spec), 'ReactClass: You\'re attempting to ' + 'use a component as a mixin. Instead, just use a regular object.');
            var proto = Constructor.prototype;
            var autoBindPairs = proto.__reactAutoBindPairs;
            if (spec.hasOwnProperty(MIXINS_KEY)) {
                RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
            }
            for (var name in spec) {
                if (!spec.hasOwnProperty(name)) {
                    continue;
                }
                if (name === MIXINS_KEY) {
                    continue;
                }
                var property = spec[name];
                var isAlreadyDefined = proto.hasOwnProperty(name);
                validateMethodOverride(isAlreadyDefined, name);
                if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
                    RESERVED_SPEC_KEYS[name](Constructor, property);
                } else {
                    var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
                    var isFunction = typeof property === 'function';
                    var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;
                    if (shouldAutoBind) {
                        autoBindPairs.push(name, property);
                        proto[name] = property;
                    } else {
                        if (isAlreadyDefined) {
                            var specPolicy = ReactClassInterface[name];
                            _invariant(isReactClassMethod && (specPolicy === 'DEFINE_MANY_MERGED' || specPolicy === 'DEFINE_MANY'), 'ReactClass: Unexpected spec policy %s for key %s ' + 'when mixing in component specs.', specPolicy, name);
                            if (specPolicy === 'DEFINE_MANY_MERGED') {
                                proto[name] = createMergedResultFunction(proto[name], property);
                            } else if (specPolicy === 'DEFINE_MANY') {
                                proto[name] = createChainedFunction(proto[name], property);
                            }
                        } else {
                            proto[name] = property;
                            if (process.env.NODE_ENV !== 'production') {
                                if (typeof property === 'function' && spec.displayName) {
                                    proto[name].displayName = spec.displayName + '_' + name;
                                }
                            }
                        }
                    }
                }
            }
        }
        function mixStaticSpecIntoComponent(Constructor, statics) {
            if (!statics) {
                return;
            }
            for (var name in statics) {
                var property = statics[name];
                if (!statics.hasOwnProperty(name)) {
                    continue;
                }
                var isReserved = name in RESERVED_SPEC_KEYS;
                _invariant(!isReserved, 'ReactClass: You are attempting to define a reserved ' + 'property, `%s`, that shouldn\'t be on the "statics" key. Define it ' + 'as an instance property instead; it will still be accessible on the ' + 'constructor.', name);
                var isInherited = name in Constructor;
                _invariant(!isInherited, 'ReactClass: You are attempting to define ' + '`%s` on your component more than once. This conflict may be ' + 'due to a mixin.', name);
                Constructor[name] = property;
            }
        }
        function mergeIntoWithNoDuplicateKeys(one, two) {
            _invariant(one && two && typeof one === 'object' && typeof two === 'object', 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.');
            for (var key in two) {
                if (two.hasOwnProperty(key)) {
                    _invariant(one[key] === undefined, 'mergeIntoWithNoDuplicateKeys(): ' + 'Tried to merge two objects with the same key: `%s`. This conflict ' + 'may be due to a mixin; in particular, this may be caused by two ' + 'getInitialState() or getDefaultProps() methods returning objects ' + 'with clashing keys.', key);
                    one[key] = two[key];
                }
            }
            return one;
        }
        function createMergedResultFunction(one, two) {
            return function mergedResult() {
                var a = one.apply(this, arguments);
                var b = two.apply(this, arguments);
                if (a == null) {
                    return b;
                } else if (b == null) {
                    return a;
                }
                var c = {};
                mergeIntoWithNoDuplicateKeys(c, a);
                mergeIntoWithNoDuplicateKeys(c, b);
                return c;
            };
        }
        function createChainedFunction(one, two) {
            return function chainedFunction() {
                one.apply(this, arguments);
                two.apply(this, arguments);
            };
        }
        function bindAutoBindMethod(component, method) {
            var boundMethod = method.bind(component);
            if (process.env.NODE_ENV !== 'production') {
                boundMethod.__reactBoundContext = component;
                boundMethod.__reactBoundMethod = method;
                boundMethod.__reactBoundArguments = null;
                var componentName = component.constructor.displayName;
                var _bind = boundMethod.bind;
                boundMethod.bind = function (newThis) {
                    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                        args[_key - 1] = arguments[_key];
                    }
                    if (newThis !== component && newThis !== null) {
                        if (process.env.NODE_ENV !== 'production') {
                            warning(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName);
                        }
                    } else if (!args.length) {
                        if (process.env.NODE_ENV !== 'production') {
                            warning(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName);
                        }
                        return boundMethod;
                    }
                    var reboundMethod = _bind.apply(boundMethod, arguments);
                    reboundMethod.__reactBoundContext = component;
                    reboundMethod.__reactBoundMethod = method;
                    reboundMethod.__reactBoundArguments = args;
                    return reboundMethod;
                };
            }
            return boundMethod;
        }
        function bindAutoBindMethods(component) {
            var pairs = component.__reactAutoBindPairs;
            for (var i = 0; i < pairs.length; i += 2) {
                var autoBindKey = pairs[i];
                var method = pairs[i + 1];
                component[autoBindKey] = bindAutoBindMethod(component, method);
            }
        }
        var IsMountedPreMixin = {
            componentDidMount: function () {
                this.__isMounted = true;
            }
        };
        var IsMountedPostMixin = {
            componentWillUnmount: function () {
                this.__isMounted = false;
            }
        };
        var ReactClassMixin = {
            replaceState: function (newState, callback) {
                this.updater.enqueueReplaceState(this, newState, callback);
            },
            isMounted: function () {
                if (process.env.NODE_ENV !== 'production') {
                    warning(this.__didWarnIsMounted, '%s: isMounted is deprecated. Instead, make sure to clean up ' + 'subscriptions and pending requests in componentWillUnmount to ' + 'prevent memory leaks.', this.constructor && this.constructor.displayName || this.name || 'Component');
                    this.__didWarnIsMounted = true;
                }
                return !!this.__isMounted;
            }
        };
        var ReactClassComponent = function () {
        };
        _assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);
        function createClass(spec) {
            var Constructor = identity(function (props, context, updater) {
                if (process.env.NODE_ENV !== 'production') {
                    warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory');
                }
                if (this.__reactAutoBindPairs.length) {
                    bindAutoBindMethods(this);
                }
                this.props = props;
                this.context = context;
                this.refs = emptyObject;
                this.updater = updater || ReactNoopUpdateQueue;
                this.state = null;
                var initialState = this.getInitialState ? this.getInitialState() : null;
                if (process.env.NODE_ENV !== 'production') {
                    if (initialState === undefined && this.getInitialState._isMockFunction) {
                        initialState = null;
                    }
                }
                _invariant(typeof initialState === 'object' && !Array.isArray(initialState), '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent');
                this.state = initialState;
            });
            Constructor.prototype = new ReactClassComponent();
            Constructor.prototype.constructor = Constructor;
            Constructor.prototype.__reactAutoBindPairs = [];
            injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));
            mixSpecIntoComponent(Constructor, IsMountedPreMixin);
            mixSpecIntoComponent(Constructor, spec);
            mixSpecIntoComponent(Constructor, IsMountedPostMixin);
            if (Constructor.getDefaultProps) {
                Constructor.defaultProps = Constructor.getDefaultProps();
            }
            if (process.env.NODE_ENV !== 'production') {
                if (Constructor.getDefaultProps) {
                    Constructor.getDefaultProps.isReactClassApproved = {};
                }
                if (Constructor.prototype.getInitialState) {
                    Constructor.prototype.getInitialState.isReactClassApproved = {};
                }
            }
            _invariant(Constructor.prototype.render, 'createClass(...): Class specification must implement a `render` method.');
            if (process.env.NODE_ENV !== 'production') {
                warning(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component');
                warning(!Constructor.prototype.componentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', spec.displayName || 'A component');
            }
            for (var methodName in ReactClassInterface) {
                if (!Constructor.prototype[methodName]) {
                    Constructor.prototype[methodName] = null;
                }
            }
            return Constructor;
        }
        return createClass;
    }
    module.exports = factory;
});
/*react@15.6.1#lib/createClass*/
define('react@15.6.1#lib/createClass', function (require, exports, module) {
    'use strict';
    var _require = require('./ReactBaseClasses'), Component = _require.Component;
    var _require2 = require('./ReactElement'), isValidElement = _require2.isValidElement;
    var ReactNoopUpdateQueue = require('./ReactNoopUpdateQueue');
    var factory = require('create-react-class/factory');
    module.exports = factory(Component, isValidElement, ReactNoopUpdateQueue);
});
/*react@15.6.1#lib/onlyChild*/
define('react@15.6.1#lib/onlyChild', function (require, exports, module) {
    'use strict';
    var _prodInvariant = require('./reactProdInvariant');
    var ReactElement = require('./ReactElement');
    var invariant = require('fbjs/lib/invariant');
    function onlyChild(children) {
        !ReactElement.isValidElement(children) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'React.Children.only expected to receive a single React element child.') : _prodInvariant('143') : void 0;
        return children;
    }
    module.exports = onlyChild;
});
/*react@15.6.1#lib/React*/
define('react@15.6.1#lib/React', function (require, exports, module) {
    'use strict';
    var _assign = require('object-assign');
    var ReactBaseClasses = require('./ReactBaseClasses');
    var ReactChildren = require('./ReactChildren');
    var ReactDOMFactories = require('./ReactDOMFactories');
    var ReactElement = require('./ReactElement');
    var ReactPropTypes = require('./ReactPropTypes');
    var ReactVersion = require('./ReactVersion');
    var createReactClass = require('./createClass');
    var onlyChild = require('./onlyChild');
    var createElement = ReactElement.createElement;
    var createFactory = ReactElement.createFactory;
    var cloneElement = ReactElement.cloneElement;
    if (process.env.NODE_ENV !== 'production') {
        var lowPriorityWarning = require('./lowPriorityWarning');
        var canDefineProperty = require('./canDefineProperty');
        var ReactElementValidator = require('./ReactElementValidator');
        var didWarnPropTypesDeprecated = false;
        createElement = ReactElementValidator.createElement;
        createFactory = ReactElementValidator.createFactory;
        cloneElement = ReactElementValidator.cloneElement;
    }
    var __spread = _assign;
    var createMixin = function (mixin) {
        return mixin;
    };
    if (process.env.NODE_ENV !== 'production') {
        var warnedForSpread = false;
        var warnedForCreateMixin = false;
        __spread = function () {
            lowPriorityWarning(warnedForSpread, 'React.__spread is deprecated and should not be used. Use ' + 'Object.assign directly or another helper function with similar ' + 'semantics. You may be seeing this warning due to your compiler. ' + 'See https://fb.me/react-spread-deprecation for more details.');
            warnedForSpread = true;
            return _assign.apply(null, arguments);
        };
        createMixin = function (mixin) {
            lowPriorityWarning(warnedForCreateMixin, 'React.createMixin is deprecated and should not be used. ' + 'In React v16.0, it will be removed. ' + 'You can use this mixin directly instead. ' + 'See https://fb.me/createmixin-was-never-implemented for more info.');
            warnedForCreateMixin = true;
            return mixin;
        };
    }
    var React = {
        Children: {
            map: ReactChildren.map,
            forEach: ReactChildren.forEach,
            count: ReactChildren.count,
            toArray: ReactChildren.toArray,
            only: onlyChild
        },
        Component: ReactBaseClasses.Component,
        PureComponent: ReactBaseClasses.PureComponent,
        createElement: createElement,
        cloneElement: cloneElement,
        isValidElement: ReactElement.isValidElement,
        PropTypes: ReactPropTypes,
        createClass: createReactClass,
        createFactory: createFactory,
        createMixin: createMixin,
        DOM: ReactDOMFactories,
        version: ReactVersion,
        __spread: __spread
    };
    if (process.env.NODE_ENV !== 'production') {
        var warnedForCreateClass = false;
        if (canDefineProperty) {
            Object.defineProperty(React, 'PropTypes', {
                get: function () {
                    lowPriorityWarning(didWarnPropTypesDeprecated, 'Accessing PropTypes via the main React package is deprecated,' + ' and will be removed in  React v16.0.' + ' Use the latest available v15.* prop-types package from npm instead.' + ' For info on usage, compatibility, migration and more, see ' + 'https://fb.me/prop-types-docs');
                    didWarnPropTypesDeprecated = true;
                    return ReactPropTypes;
                }
            });
            Object.defineProperty(React, 'createClass', {
                get: function () {
                    lowPriorityWarning(warnedForCreateClass, 'Accessing createClass via the main React package is deprecated,' + ' and will be removed in React v16.0.' + ' Use a plain JavaScript class instead. If you\'re not yet ' + 'ready to migrate, create-react-class v15.* is available ' + 'on npm as a temporary, drop-in replacement. ' + 'For more info see https://fb.me/react-create-class');
                    warnedForCreateClass = true;
                    return createReactClass;
                }
            });
        }
        React.DOM = {};
        var warnedForFactories = false;
        Object.keys(ReactDOMFactories).forEach(function (factory) {
            React.DOM[factory] = function () {
                if (!warnedForFactories) {
                    lowPriorityWarning(false, 'Accessing factories like React.DOM.%s has been deprecated ' + 'and will be removed in v16.0+. Use the ' + 'react-dom-factories package instead. ' + ' Version 1.0 provides a drop-in replacement.' + ' For more info, see https://fb.me/react-dom-factories', factory);
                    warnedForFactories = true;
                }
                return ReactDOMFactories[factory].apply(ReactDOMFactories, arguments);
            };
        });
    }
    module.exports = React;
});
/*react@15.6.1#react*/
define('react@15.6.1#react', function (require, exports, module) {
    'use strict';
    module.exports = require('./lib/React');
});
/*prop-types@15.5.10#factoryWithThrowingShims*/
define('prop-types@15.5.10#factoryWithThrowingShims', function (require, exports, module) {
    'use strict';
    var emptyFunction = require('fbjs/lib/emptyFunction');
    var invariant = require('fbjs/lib/invariant');
    var ReactPropTypesSecret = require('./lib/ReactPropTypesSecret');
    module.exports = function () {
        function shim(props, propName, componentName, location, propFullName, secret) {
            if (secret === ReactPropTypesSecret) {
                return;
            }
            invariant(false, 'Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use PropTypes.checkPropTypes() to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
        }
        ;
        shim.isRequired = shim;
        function getShim() {
            return shim;
        }
        ;
        var ReactPropTypes = {
            array: shim,
            bool: shim,
            func: shim,
            number: shim,
            object: shim,
            string: shim,
            symbol: shim,
            any: shim,
            arrayOf: getShim,
            element: shim,
            instanceOf: getShim,
            node: shim,
            objectOf: getShim,
            oneOf: getShim,
            oneOfType: getShim,
            shape: getShim
        };
        ReactPropTypes.checkPropTypes = emptyFunction;
        ReactPropTypes.PropTypes = ReactPropTypes;
        return ReactPropTypes;
    };
});
/*prop-types@15.5.10#index*/
define('prop-types@15.5.10#index', function (require, exports, module) {
    if (process.env.NODE_ENV !== 'production') {
        var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol.for && Symbol.for('react.element') || 60103;
        var isValidElement = function (object) {
            return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        };
        var throwOnDirectAccess = true;
        module.exports = require('./factoryWithTypeCheckers')(isValidElement, throwOnDirectAccess);
    } else {
        module.exports = require('./factoryWithThrowingShims')();
    }
});
/*react-dom@15.6.1#lib/reactProdInvariant*/
define('react-dom@15.6.1#lib/reactProdInvariant', function (require, exports, module) {
    'use strict';
    function reactProdInvariant(code) {
        var argCount = arguments.length - 1;
        var message = 'Minified React error #' + code + '; visit ' + 'http://facebook.github.io/react/docs/error-decoder.html?invariant=' + code;
        for (var argIdx = 0; argIdx < argCount; argIdx++) {
            message += '&args[]=' + encodeURIComponent(arguments[argIdx + 1]);
        }
        message += ' for the full message or use the non-minified dev environment' + ' for full errors and additional helpful warnings.';
        var error = new Error(message);
        error.name = 'Invariant Violation';
        error.framesToPop = 1;
        throw error;
    }
    module.exports = reactProdInvariant;
});
/*react-dom@15.6.1#lib/EventConstants*/
define('react-dom@15.6.1#lib/EventConstants', function (require, exports, module) {
    'use strict';
    var topLevelTypes = {
        topAbort: null,
        topAnimationEnd: null,
        topAnimationIteration: null,
        topAnimationStart: null,
        topBlur: null,
        topCanPlay: null,
        topCanPlayThrough: null,
        topChange: null,
        topClick: null,
        topCompositionEnd: null,
        topCompositionStart: null,
        topCompositionUpdate: null,
        topContextMenu: null,
        topCopy: null,
        topCut: null,
        topDoubleClick: null,
        topDrag: null,
        topDragEnd: null,
        topDragEnter: null,
        topDragExit: null,
        topDragLeave: null,
        topDragOver: null,
        topDragStart: null,
        topDrop: null,
        topDurationChange: null,
        topEmptied: null,
        topEncrypted: null,
        topEnded: null,
        topError: null,
        topFocus: null,
        topInput: null,
        topInvalid: null,
        topKeyDown: null,
        topKeyPress: null,
        topKeyUp: null,
        topLoad: null,
        topLoadedData: null,
        topLoadedMetadata: null,
        topLoadStart: null,
        topMouseDown: null,
        topMouseMove: null,
        topMouseOut: null,
        topMouseOver: null,
        topMouseUp: null,
        topPaste: null,
        topPause: null,
        topPlay: null,
        topPlaying: null,
        topProgress: null,
        topRateChange: null,
        topReset: null,
        topScroll: null,
        topSeeked: null,
        topSeeking: null,
        topSelectionChange: null,
        topStalled: null,
        topSubmit: null,
        topSuspend: null,
        topTextInput: null,
        topTimeUpdate: null,
        topTouchCancel: null,
        topTouchEnd: null,
        topTouchMove: null,
        topTouchStart: null,
        topTransitionEnd: null,
        topVolumeChange: null,
        topWaiting: null,
        topWheel: null
    };
    var EventConstants = { topLevelTypes: topLevelTypes };
    module.exports = EventConstants;
});
/*react-dom@15.6.1#lib/EventPluginRegistry*/
define('react-dom@15.6.1#lib/EventPluginRegistry', function (require, exports, module) {
    'use strict';
    var _prodInvariant = require('./reactProdInvariant');
    var invariant = require('fbjs/lib/invariant');
    var eventPluginOrder = null;
    var namesToPlugins = {};
    function recomputePluginOrdering() {
        if (!eventPluginOrder) {
            return;
        }
        for (var pluginName in namesToPlugins) {
            var pluginModule = namesToPlugins[pluginName];
            var pluginIndex = eventPluginOrder.indexOf(pluginName);
            !(pluginIndex > -1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.', pluginName) : _prodInvariant('96', pluginName) : void 0;
            if (EventPluginRegistry.plugins[pluginIndex]) {
                continue;
            }
            !pluginModule.extractEvents ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.', pluginName) : _prodInvariant('97', pluginName) : void 0;
            EventPluginRegistry.plugins[pluginIndex] = pluginModule;
            var publishedEvents = pluginModule.eventTypes;
            for (var eventName in publishedEvents) {
                !publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : _prodInvariant('98', eventName, pluginName) : void 0;
            }
        }
    }
    function publishEventForPlugin(dispatchConfig, pluginModule, eventName) {
        !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.', eventName) : _prodInvariant('99', eventName) : void 0;
        EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;
        var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
        if (phasedRegistrationNames) {
            for (var phaseName in phasedRegistrationNames) {
                if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
                    var phasedRegistrationName = phasedRegistrationNames[phaseName];
                    publishRegistrationName(phasedRegistrationName, pluginModule, eventName);
                }
            }
            return true;
        } else if (dispatchConfig.registrationName) {
            publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);
            return true;
        }
        return false;
    }
    function publishRegistrationName(registrationName, pluginModule, eventName) {
        !!EventPluginRegistry.registrationNameModules[registrationName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.', registrationName) : _prodInvariant('100', registrationName) : void 0;
        EventPluginRegistry.registrationNameModules[registrationName] = pluginModule;
        EventPluginRegistry.registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;
        if (process.env.NODE_ENV !== 'production') {
            var lowerCasedName = registrationName.toLowerCase();
            EventPluginRegistry.possibleRegistrationNames[lowerCasedName] = registrationName;
            if (registrationName === 'onDoubleClick') {
                EventPluginRegistry.possibleRegistrationNames.ondblclick = registrationName;
            }
        }
    }
    var EventPluginRegistry = {
        plugins: [],
        eventNameDispatchConfigs: {},
        registrationNameModules: {},
        registrationNameDependencies: {},
        possibleRegistrationNames: process.env.NODE_ENV !== 'production' ? {} : null,
        injectEventPluginOrder: function (injectedEventPluginOrder) {
            !!eventPluginOrder ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.') : _prodInvariant('101') : void 0;
            eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);
            recomputePluginOrdering();
        },
        injectEventPluginsByName: function (injectedNamesToPlugins) {
            var isOrderingDirty = false;
            for (var pluginName in injectedNamesToPlugins) {
                if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
                    continue;
                }
                var pluginModule = injectedNamesToPlugins[pluginName];
                if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {
                    !!namesToPlugins[pluginName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.', pluginName) : _prodInvariant('102', pluginName) : void 0;
                    namesToPlugins[pluginName] = pluginModule;
                    isOrderingDirty = true;
                }
            }
            if (isOrderingDirty) {
                recomputePluginOrdering();
            }
        },
        getPluginModuleForEvent: function (event) {
            var dispatchConfig = event.dispatchConfig;
            if (dispatchConfig.registrationName) {
                return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
            }
            if (dispatchConfig.phasedRegistrationNames !== undefined) {
                var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
                for (var phase in phasedRegistrationNames) {
                    if (!phasedRegistrationNames.hasOwnProperty(phase)) {
                        continue;
                    }
                    var pluginModule = EventPluginRegistry.registrationNameModules[phasedRegistrationNames[phase]];
                    if (pluginModule) {
                        return pluginModule;
                    }
                }
            }
            return null;
        },
        _resetEventPlugins: function () {
            eventPluginOrder = null;
            for (var pluginName in namesToPlugins) {
                if (namesToPlugins.hasOwnProperty(pluginName)) {
                    delete namesToPlugins[pluginName];
                }
            }
            EventPluginRegistry.plugins.length = 0;
            var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
            for (var eventName in eventNameDispatchConfigs) {
                if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
                    delete eventNameDispatchConfigs[eventName];
                }
            }
            var registrationNameModules = EventPluginRegistry.registrationNameModules;
            for (var registrationName in registrationNameModules) {
                if (registrationNameModules.hasOwnProperty(registrationName)) {
                    delete registrationNameModules[registrationName];
                }
            }
            if (process.env.NODE_ENV !== 'production') {
                var possibleRegistrationNames = EventPluginRegistry.possibleRegistrationNames;
                for (var lowerCasedName in possibleRegistrationNames) {
                    if (possibleRegistrationNames.hasOwnProperty(lowerCasedName)) {
                        delete possibleRegistrationNames[lowerCasedName];
                    }
                }
            }
        }
    };
    module.exports = EventPluginRegistry;
});
/*react-dom@15.6.1#lib/ReactErrorUtils*/
define('react-dom@15.6.1#lib/ReactErrorUtils', function (require, exports, module) {
    'use strict';
    var caughtError = null;
    function invokeGuardedCallback(name, func, a) {
        try {
            func(a);
        } catch (x) {
            if (caughtError === null) {
                caughtError = x;
            }
        }
    }
    var ReactErrorUtils = {
        invokeGuardedCallback: invokeGuardedCallback,
        invokeGuardedCallbackWithCatch: invokeGuardedCallback,
        rethrowCaughtError: function () {
            if (caughtError) {
                var error = caughtError;
                caughtError = null;
                throw error;
            }
        }
    };
    if (process.env.NODE_ENV !== 'production') {
        if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
            var fakeNode = document.createElement('react');
            ReactErrorUtils.invokeGuardedCallback = function (name, func, a) {
                var boundFunc = func.bind(null, a);
                var evtType = 'react-' + name;
                fakeNode.addEventListener(evtType, boundFunc, false);
                var evt = document.createEvent('Event');
                evt.initEvent(evtType, false, false);
                fakeNode.dispatchEvent(evt);
                fakeNode.removeEventListener(evtType, boundFunc, false);
            };
        }
    }
    module.exports = ReactErrorUtils;
});
/*react-dom@15.6.1#lib/EventPluginUtils*/
define('react-dom@15.6.1#lib/EventPluginUtils', function (require, exports, module) {
    'use strict';
    var _prodInvariant = require('./reactProdInvariant');
    var ReactErrorUtils = require('./ReactErrorUtils');
    var invariant = require('fbjs/lib/invariant');
    var warning = require('fbjs/lib/warning');
    var ComponentTree;
    var TreeTraversal;
    var injection = {
        injectComponentTree: function (Injected) {
            ComponentTree = Injected;
            if (process.env.NODE_ENV !== 'production') {
                process.env.NODE_ENV !== 'production' ? warning(Injected && Injected.getNodeFromInstance && Injected.getInstanceFromNode, 'EventPluginUtils.injection.injectComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.') : void 0;
            }
        },
        injectTreeTraversal: function (Injected) {
            TreeTraversal = Injected;
            if (process.env.NODE_ENV !== 'production') {
                process.env.NODE_ENV !== 'production' ? warning(Injected && Injected.isAncestor && Injected.getLowestCommonAncestor, 'EventPluginUtils.injection.injectTreeTraversal(...): Injected ' + 'module is missing isAncestor or getLowestCommonAncestor.') : void 0;
            }
        }
    };
    function isEndish(topLevelType) {
        return topLevelType === 'topMouseUp' || topLevelType === 'topTouchEnd' || topLevelType === 'topTouchCancel';
    }
    function isMoveish(topLevelType) {
        return topLevelType === 'topMouseMove' || topLevelType === 'topTouchMove';
    }
    function isStartish(topLevelType) {
        return topLevelType === 'topMouseDown' || topLevelType === 'topTouchStart';
    }
    var validateEventDispatches;
    if (process.env.NODE_ENV !== 'production') {
        validateEventDispatches = function (event) {
            var dispatchListeners = event._dispatchListeners;
            var dispatchInstances = event._dispatchInstances;
            var listenersIsArr = Array.isArray(dispatchListeners);
            var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;
            var instancesIsArr = Array.isArray(dispatchInstances);
            var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;
            process.env.NODE_ENV !== 'production' ? warning(instancesIsArr === listenersIsArr && instancesLen === listenersLen, 'EventPluginUtils: Invalid `event`.') : void 0;
        };
    }
    function executeDispatch(event, simulated, listener, inst) {
        var type = event.type || 'unknown-event';
        event.currentTarget = EventPluginUtils.getNodeFromInstance(inst);
        if (simulated) {
            ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event);
        } else {
            ReactErrorUtils.invokeGuardedCallback(type, listener, event);
        }
        event.currentTarget = null;
    }
    function executeDispatchesInOrder(event, simulated) {
        var dispatchListeners = event._dispatchListeners;
        var dispatchInstances = event._dispatchInstances;
        if (process.env.NODE_ENV !== 'production') {
            validateEventDispatches(event);
        }
        if (Array.isArray(dispatchListeners)) {
            for (var i = 0; i < dispatchListeners.length; i++) {
                if (event.isPropagationStopped()) {
                    break;
                }
                executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);
            }
        } else if (dispatchListeners) {
            executeDispatch(event, simulated, dispatchListeners, dispatchInstances);
        }
        event._dispatchListeners = null;
        event._dispatchInstances = null;
    }
    function executeDispatchesInOrderStopAtTrueImpl(event) {
        var dispatchListeners = event._dispatchListeners;
        var dispatchInstances = event._dispatchInstances;
        if (process.env.NODE_ENV !== 'production') {
            validateEventDispatches(event);
        }
        if (Array.isArray(dispatchListeners)) {
            for (var i = 0; i < dispatchListeners.length; i++) {
                if (event.isPropagationStopped()) {
                    break;
                }
                if (dispatchListeners[i](event, dispatchInstances[i])) {
                    return dispatchInstances[i];
                }
            }
        } else if (dispatchListeners) {
            if (dispatchListeners(event, dispatchInstances)) {
                return dispatchInstances;
            }
        }
        return null;
    }
    function executeDispatchesInOrderStopAtTrue(event) {
        var ret = executeDispatchesInOrderStopAtTrueImpl(event);
        event._dispatchInstances = null;
        event._dispatchListeners = null;
        return ret;
    }
    function executeDirectDispatch(event) {
        if (process.env.NODE_ENV !== 'production') {
            validateEventDispatches(event);
        }
        var dispatchListener = event._dispatchListeners;
        var dispatchInstance = event._dispatchInstances;
        !!Array.isArray(dispatchListener) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'executeDirectDispatch(...): Invalid `event`.') : _prodInvariant('103') : void 0;
        event.currentTarget = dispatchListener ? EventPluginUtils.getNodeFromInstance(dispatchInstance) : null;
        var res = dispatchListener ? dispatchListener(event) : null;
        event.currentTarget = null;
        event._dispatchListeners = null;
        event._dispatchInstances = null;
        return res;
    }
    function hasDispatches(event) {
        return !!event._dispatchListeners;
    }
    var EventPluginUtils = {
        isEndish: isEndish,
        isMoveish: isMoveish,
        isStartish: isStartish,
        executeDirectDispatch: executeDirectDispatch,
        executeDispatchesInOrder: executeDispatchesInOrder,
        executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
        hasDispatches: hasDispatches,
        getInstanceFromNode: function (node) {
            return ComponentTree.getInstanceFromNode(node);
        },
        getNodeFromInstance: function (node) {
            return ComponentTree.getNodeFromInstance(node);
        },
        isAncestor: function (a, b) {
            return TreeTraversal.isAncestor(a, b);
        },
        getLowestCommonAncestor: function (a, b) {
            return TreeTraversal.getLowestCommonAncestor(a, b);
        },
        getParentInstance: function (inst) {
            return TreeTraversal.getParentInstance(inst);
        },
        traverseTwoPhase: function (target, fn, arg) {
            return TreeTraversal.traverseTwoPhase(target, fn, arg);
        },
        traverseEnterLeave: function (from, to, fn, argFrom, argTo) {
            return TreeTraversal.traverseEnterLeave(from, to, fn, argFrom, argTo);
        },
        injection: injection
    };
    module.exports = EventPluginUtils;
});
/*react-dom@15.6.1#lib/accumulateInto*/
define('react-dom@15.6.1#lib/accumulateInto', function (require, exports, module) {
    'use strict';
    var _prodInvariant = require('./reactProdInvariant');
    var invariant = require('fbjs/lib/invariant');
    function accumulateInto(current, next) {
        !(next != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : _prodInvariant('30') : void 0;
        if (current == null) {
            return next;
        }
        if (Array.isArray(current)) {
            if (Array.isArray(next)) {
                current.push.apply(current, next);
                return current;
            }
            current.push(next);
            return current;
        }
        if (Array.isArray(next)) {
            return [current].concat(next);
        }
        return [
            current,
            next
        ];
    }
    module.exports = accumulateInto;
});
/*react-dom@15.6.1#lib/forEachAccumulated*/
define('react-dom@15.6.1#lib/forEachAccumulated', function (require, exports, module) {
    'use strict';
    function forEachAccumulated(arr, cb, scope) {
        if (Array.isArray(arr)) {
            arr.forEach(cb, scope);
        } else if (arr) {
            cb.call(scope, arr);
        }
    }
    module.exports = forEachAccumulated;
});
/*react-dom@15.6.1#lib/EventPluginHub*/
define('react-dom@15.6.1#lib/EventPluginHub', function (require, exports, module) {
    'use strict';
    var _prodInvariant = require('./reactProdInvariant');
    var EventPluginRegistry = require('./EventPluginRegistry');
    var EventPluginUtils = require('./EventPluginUtils');
    var ReactErrorUtils = require('./ReactErrorUtils');
    var accumulateInto = require('./accumulateInto');
    var forEachAccumulated = require('./forEachAccumulated');
    var invariant = require('fbjs/lib/invariant');
    var listenerBank = {};
    var eventQueue = null;
    var executeDispatchesAndRelease = function (event, simulated) {
        if (event) {
            EventPluginUtils.executeDispatchesInOrder(event, simulated);
            if (!event.isPersistent()) {
                event.constructor.release(event);
            }
        }
    };
    var executeDispatchesAndReleaseSimulated = function (e) {
        return executeDispatchesAndRelease(e, true);
    };
    var executeDispatchesAndReleaseTopLevel = function (e) {
        return executeDispatchesAndRelease(e, false);
    };
    var getDictionaryKey = function (inst) {
        return '.' + inst._rootNodeID;
    };
    function isInteractive(tag) {
        return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
    }
    function shouldPreventMouseEvent(name, type, props) {
        switch (name) {
        case 'onClick':
        case 'onClickCapture':
        case 'onDoubleClick':
        case 'onDoubleClickCapture':
        case 'onMouseDown':
        case 'onMouseDownCapture':
        case 'onMouseMove':
        case 'onMouseMoveCapture':
        case 'onMouseUp':
        case 'onMouseUpCapture':
            return !!(props.disabled && isInteractive(type));
        default:
            return false;
        }
    }
    var EventPluginHub = {
        injection: {
            injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,
            injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName
        },
        putListener: function (inst, registrationName, listener) {
            !(typeof listener === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener) : _prodInvariant('94', registrationName, typeof listener) : void 0;
            var key = getDictionaryKey(inst);
            var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
            bankForRegistrationName[key] = listener;
            var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
            if (PluginModule && PluginModule.didPutListener) {
                PluginModule.didPutListener(inst, registrationName, listener);
            }
        },
        getListener: function (inst, registrationName) {
            var bankForRegistrationName = listenerBank[registrationName];
            if (shouldPreventMouseEvent(registrationName, inst._currentElement.type, inst._currentElement.props)) {
                return null;
            }
            var key = getDictionaryKey(inst);
            return bankForRegistrationName && bankForRegistrationName[key];
        },
        deleteListener: function (inst, registrationName) {
            var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
            if (PluginModule && PluginModule.willDeleteListener) {
                PluginModule.willDeleteListener(inst, registrationName);
            }
            var bankForRegistrationName = listenerBank[registrationName];
            if (bankForRegistrationName) {
                var key = getDictionaryKey(inst);
                delete bankForRegistrationName[key];
            }
        },
        deleteAllListeners: function (inst) {
            var key = getDictionaryKey(inst);
            for (var registrationName in listenerBank) {
                if (!listenerBank.hasOwnProperty(registrationName)) {
                    continue;
                }
                if (!listenerBank[registrationName][key]) {
                    continue;
                }
                var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
                if (PluginModule && PluginModule.willDeleteListener) {
                    PluginModule.willDeleteListener(inst, registrationName);
                }
                delete listenerBank[registrationName][key];
            }
        },
        extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
            var events;
            var plugins = EventPluginRegistry.plugins;
            for (var i = 0; i < plugins.length; i++) {
                var possiblePlugin = plugins[i];
                if (possiblePlugin) {
                    var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
                    if (extractedEvents) {
                        events = accumulateInto(events, extractedEvents);
                    }
                }
            }
            return events;
        },
        enqueueEvents: function (events) {
            if (events) {
                eventQueue = accumulateInto(eventQueue, events);
            }
        },
        processEventQueue: function (simulated) {
            var processingEventQueue = eventQueue;
            eventQueue = null;
            if (simulated) {
                forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
            } else {
                forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
            }
            !!eventQueue ? process.env.NODE_ENV !== 'production' ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.') : _prodInvariant('95') : void 0;
            ReactErrorUtils.rethrowCaughtError();
        },
        __purge: function () {
            listenerBank = {};
        },
        __getListenerBank: function () {
            return listenerBank;
        }
    };
    module.exports = EventPluginHub;
});
/*react-dom@15.6.1#lib/EventPropagators*/
define('react-dom@15.6.1#lib/EventPropagators', function (require, exports, module) {
    'use strict';
    var EventPluginHub = require('./EventPluginHub');
    var EventPluginUtils = require('./EventPluginUtils');
    var accumulateInto = require('./accumulateInto');
    var forEachAccumulated = require('./forEachAccumulated');
    var warning = require('fbjs/lib/warning');
    var getListener = EventPluginHub.getListener;
    function listenerAtPhase(inst, event, propagationPhase) {
        var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
        return getListener(inst, registrationName);
    }
    function accumulateDirectionalDispatches(inst, phase, event) {
        if (process.env.NODE_ENV !== 'production') {
            process.env.NODE_ENV !== 'production' ? warning(inst, 'Dispatching inst must not be null') : void 0;
        }
        var listener = listenerAtPhase(inst, event, phase);
        if (listener) {
            event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
            event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
        }
    }
    function accumulateTwoPhaseDispatchesSingle(event) {
        if (event && event.dispatchConfig.phasedRegistrationNames) {
            EventPluginUtils.traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
        }
    }
    function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
        if (event && event.dispatchConfig.phasedRegistrationNames) {
            var targetInst = event._targetInst;
            var parentInst = targetInst ? EventPluginUtils.getParentInstance(targetInst) : null;
            EventPluginUtils.traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);
        }
    }
    function accumulateDispatches(inst, ignoredDirection, event) {
        if (event && event.dispatchConfig.registrationName) {
            var registrationName = event.dispatchConfig.registrationName;
            var listener = getListener(inst, registrationName);
            if (listener) {
                event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
                event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
            }
        }
    }
    function accumulateDirectDispatchesSingle(event) {
        if (event && event.dispatchConfig.registrationName) {
            accumulateDispatches(event._targetInst, null, event);
        }
    }
    function accumulateTwoPhaseDispatches(events) {
        forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
    }
    function accumulateTwoPhaseDispatchesSkipTarget(events) {
        forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
    }
    function accumulateEnterLeaveDispatches(leave, enter, from, to) {
        EventPluginUtils.traverseEnterLeave(from, to, accumulateDispatches, leave, enter);
    }
    function accumulateDirectDispatches(events) {
        forEachAccumulated(events, accumulateDirectDispatchesSingle);
    }
    var EventPropagators = {
        accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
        accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
        accumulateDirectDispatches: accumulateDirectDispatches,
        accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
    };
    module.exports = EventPropagators;
});
/*react-dom@15.6.1#lib/DOMProperty*/
define('react-dom@15.6.1#lib/DOMProperty', function (require, exports, module) {
    'use strict';
    var _prodInvariant = require('./reactProdInvariant');
    var invariant = require('fbjs/lib/invariant');
    function checkMask(value, bitmask) {
        return (value & bitmask) === bitmask;
    }
    var DOMPropertyInjection = {
        MUST_USE_PROPERTY: 1,
        HAS_BOOLEAN_VALUE: 4,
        HAS_NUMERIC_VALUE: 8,
        HAS_POSITIVE_NUMERIC_VALUE: 16 | 8,
        HAS_OVERLOADED_BOOLEAN_VALUE: 32,
        injectDOMPropertyConfig: function (domPropertyConfig) {
            var Injection = DOMPropertyInjection;
            var Properties = domPropertyConfig.Properties || {};
            var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
            var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
            var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
            var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};
            if (domPropertyConfig.isCustomAttribute) {
                DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
            }
            for (var propName in Properties) {
                !!DOMProperty.properties.hasOwnProperty(propName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'injectDOMPropertyConfig(...): You\'re trying to inject DOM property \'%s\' which has already been injected. You may be accidentally injecting the same DOM property config twice, or you may be injecting two configs that have conflicting property names.', propName) : _prodInvariant('48', propName) : void 0;
                var lowerCased = propName.toLowerCase();
                var propConfig = Properties[propName];
                var propertyInfo = {
                    attributeName: lowerCased,
                    attributeNamespace: null,
                    propertyName: propName,
                    mutationMethod: null,
                    mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
                    hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
                    hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
                    hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
                    hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE)
                };
                !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Value can be one of boolean, overloaded boolean, or numeric value, but not a combination: %s', propName) : _prodInvariant('50', propName) : void 0;
                if (process.env.NODE_ENV !== 'production') {
                    DOMProperty.getPossibleStandardName[lowerCased] = propName;
                }
                if (DOMAttributeNames.hasOwnProperty(propName)) {
                    var attributeName = DOMAttributeNames[propName];
                    propertyInfo.attributeName = attributeName;
                    if (process.env.NODE_ENV !== 'production') {
                        DOMProperty.getPossibleStandardName[attributeName] = propName;
                    }
                }
                if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
                    propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
                }
                if (DOMPropertyNames.hasOwnProperty(propName)) {
                    propertyInfo.propertyName = DOMPropertyNames[propName];
                }
                if (DOMMutationMethods.hasOwnProperty(propName)) {
                    propertyInfo.mutationMethod = DOMMutationMethods[propName];
                }
                DOMProperty.properties[propName] = propertyInfo;
            }
        }
    };
    var ATTRIBUTE_NAME_START_CHAR = ':A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';
    var DOMProperty = {
        ID_ATTRIBUTE_NAME: 'data-reactid',
        ROOT_ATTRIBUTE_NAME: 'data-reactroot',
        ATTRIBUTE_NAME_START_CHAR: ATTRIBUTE_NAME_START_CHAR,
        ATTRIBUTE_NAME_CHAR: ATTRIBUTE_NAME_START_CHAR + '\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040',
        properties: {},
        getPossibleStandardName: process.env.NODE_ENV !== 'production' ? { autofocus: 'autoFocus' } : null,
        _isCustomAttributeFunctions: [],
        isCustomAttribute: function (attributeName) {
            for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
                var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
                if (isCustomAttributeFn(attributeName)) {
                    return true;
                }
            }
            return false;
        },
        injection: DOMPropertyInjection
    };
    module.exports = DOMProperty;
});
/*react-dom@15.6.1#lib/ReactDOMComponentFlags*/
define('react-dom@15.6.1#lib/ReactDOMComponentFlags', function (require, exports, module) {
    'use strict';
    var ReactDOMComponentFlags = { hasCachedChildNodes: 1 << 0 };
    module.exports = ReactDOMComponentFlags;
});
/*react-dom@15.6.1#lib/ReactDOMComponentTree*/
define('react-dom@15.6.1#lib/ReactDOMComponentTree', function (require, exports, module) {
    'use strict';
    var _prodInvariant = require('./reactProdInvariant');
    var DOMProperty = require('./DOMProperty');
    var ReactDOMComponentFlags = require('./ReactDOMComponentFlags');
    var invariant = require('fbjs/lib/invariant');
    var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
    var Flags = ReactDOMComponentFlags;
    var internalInstanceKey = '__reactInternalInstance$' + Math.random().toString(36).slice(2);
    function shouldPrecacheNode(node, nodeID) {
        return node.nodeType === 1 && node.getAttribute(ATTR_NAME) === String(nodeID) || node.nodeType === 8 && node.nodeValue === ' react-text: ' + nodeID + ' ' || node.nodeType === 8 && node.nodeValue === ' react-empty: ' + nodeID + ' ';
    }
    function getRenderedHostOrTextFromComponent(component) {
        var rendered;
        while (rendered = component._renderedComponent) {
            component = rendered;
        }
        return component;
    }
    function precacheNode(inst, node) {
        var hostInst = getRenderedHostOrTextFromComponent(inst);
        hostInst._hostNode = node;
        node[internalInstanceKey] = hostInst;
    }
    function uncacheNode(inst) {
        var node = inst._hostNode;
        if (node) {
            delete node[internalInstanceKey];
            inst._hostNode = null;
        }
    }
    function precacheChildNodes(inst, node) {
        if (inst._flags & Flags.hasCachedChildNodes) {
            return;
        }
        var children = inst._renderedChildren;
        var childNode = node.firstChild;
        outer:
            for (var name in children) {
                if (!children.hasOwnProperty(name)) {
                    continue;
                }
                var childInst = children[name];
                var childID = getRenderedHostOrTextFromComponent(childInst)._domID;
                if (childID === 0) {
                    continue;
                }
                for (; childNode !== null; childNode = childNode.nextSibling) {
                    if (shouldPrecacheNode(childNode, childID)) {
                        precacheNode(childInst, childNode);
                        continue outer;
                    }
                }
                !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Unable to find element with ID %s.', childID) : _prodInvariant('32', childID) : void 0;
            }
        inst._flags |= Flags.hasCachedChildNodes;
    }
    function getClosestInstanceFromNode(node) {
        if (node[internalInstanceKey]) {
            return node[internalInstanceKey];
        }
        var parents = [];
        while (!node[internalInstanceKey]) {
            parents.push(node);
            if (node.parentNode) {
                node = node.parentNode;
            } else {
                return null;
            }
        }
        var closest;
        var inst;
        for (; node && (inst = node[internalInstanceKey]); node = parents.pop()) {
            closest = inst;
            if (parents.length) {
                precacheChildNodes(inst, node);
            }
        }
        return closest;
    }
    function getInstanceFromNode(node) {
        var inst = getClosestInstanceFromNode(node);
        if (inst != null && inst._hostNode === node) {
            return inst;
        } else {
            return null;
        }
    }
    function getNodeFromInstance(inst) {
        !(inst._hostNode !== undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
        if (inst._hostNode) {
            return inst._hostNode;
        }
        var parents = [];
        while (!inst._hostNode) {
            parents.push(inst);
            !inst._hostParent ? process.env.NODE_ENV !== 'production' ? invariant(false, 'React DOM tree root should always have a node reference.') : _prodInvariant('34') : void 0;
            inst = inst._hostParent;
        }
        for (; parents.length; inst = parents.pop()) {
            precacheChildNodes(inst, inst._hostNode);
        }
        return inst._hostNode;
    }
    var ReactDOMComponentTree = {
        getClosestInstanceFromNode: getClosestInstanceFromNode,
        getInstanceFromNode: getInstanceFromNode,
        getNodeFromInstance: getNodeFromInstance,
        precacheChildNodes: precacheChildNodes,
        precacheNode: precacheNode,
        uncacheNode: uncacheNode
    };
    module.exports = ReactDOMComponentTree;
});
/*react-dom@15.6.1#lib/ARIADOMPropertyConfig*/
define('react-dom@15.6.1#lib/ARIADOMPropertyConfig', function (require, exports, module) {
    'use strict';
    var ARIADOMPropertyConfig = {
        Properties: {
            'aria-current': 0,
            'aria-details': 0,
            'aria-disabled': 0,
            'aria-hidden': 0,
            'aria-invalid': 0,
            'aria-keyshortcuts': 0,
            'aria-label': 0,
            'aria-roledescription': 0,
            'aria-autocomplete': 0,
            'aria-checked': 0,
            'aria-expanded': 0,
            'aria-haspopup': 0,
            'aria-level': 0,
            'aria-modal': 0,
            'aria-multiline': 0,
            'aria-multiselectable': 0,
            'aria-orientation': 0,
            'aria-placeholder': 0,
            'aria-pressed': 0,
            'aria-readonly': 0,
            'aria-required': 0,
            'aria-selected': 0,
            'aria-sort': 0,
            'aria-valuemax': 0,
            'aria-valuemin': 0,
            'aria-valuenow': 0,
            'aria-valuetext': 0,
            'aria-atomic': 0,
            'aria-busy': 0,
            'aria-live': 0,
            'aria-relevant': 0,
            'aria-dropeffect': 0,
            'aria-grabbed': 0,
            'aria-activedescendant': 0,
            'aria-colcount': 0,
            'aria-colindex': 0,
            'aria-colspan': 0,
            'aria-controls': 0,
            'aria-describedby': 0,
            'aria-errormessage': 0,
            'aria-flowto': 0,
            'aria-labelledby': 0,
            'aria-owns': 0,
            'aria-posinset': 0,
            'aria-rowcount': 0,
            'aria-rowindex': 0,
            'aria-rowspan': 0,
            'aria-setsize': 0
        },
        DOMAttributeNames: {},
        DOMPropertyNames: {}
    };
    module.exports = ARIADOMPropertyConfig;
});
/*fbjs@0.8.12#lib/ExecutionEnvironment*/
define('fbjs@0.8.12#lib/ExecutionEnvironment', function (require, exports, module) {
    'use strict';
    var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
    var ExecutionEnvironment = {
        canUseDOM: canUseDOM,
        canUseWorkers: typeof Worker !== 'undefined',
        canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),
        canUseViewport: canUseDOM && !!window.screen,
        isInWorker: !canUseDOM
    };
    module.exports = ExecutionEnvironment;
});
/*react-dom@15.6.1#lib/PooledClass*/
define('react-dom@15.6.1#lib/PooledClass', function (require, exports, module) {
    'use strict';
    var _prodInvariant = require('./reactProdInvariant');
    var invariant = require('fbjs/lib/invariant');
    var oneArgumentPooler = function (copyFieldsFrom) {
        var Klass = this;
        if (Klass.instancePool.length) {
            var instance = Klass.instancePool.pop();
            Klass.call(instance, copyFieldsFrom);
            return instance;
        } else {
            return new Klass(copyFieldsFrom);
        }
    };
    var twoArgumentPooler = function (a1, a2) {
        var Klass = this;
        if (Klass.instancePool.length) {
            var instance = Klass.instancePool.pop();
            Klass.call(instance, a1, a2);
            return instance;
        } else {
            return new Klass(a1, a2);
        }
    };
    var threeArgumentPooler = function (a1, a2, a3) {
        var Klass = this;
        if (Klass.instancePool.length) {
            var instance = Klass.instancePool.pop();
            Klass.call(instance, a1, a2, a3);
            return instance;
        } else {
            return new Klass(a1, a2, a3);
        }
    };
    var fourArgumentPooler = function (a1, a2, a3, a4) {
        var Klass = this;
        if (Klass.instancePool.length) {
            var instance = Klass.instancePool.pop();
            Klass.call(instance, a1, a2, a3, a4);
            return instance;
        } else {
            return new Klass(a1, a2, a3, a4);
        }
    };
    var standardReleaser = function (instance) {
        var Klass = this;
        !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : _prodInvariant('25') : void 0;
        instance.destructor();
        if (Klass.instancePool.length < Klass.poolSize) {
            Klass.instancePool.push(instance);
        }
    };
    var DEFAULT_POOL_SIZE = 10;
    var DEFAULT_POOLER = oneArgumentPooler;
    var addPoolingTo = function (CopyConstructor, pooler) {
        var NewKlass = CopyConstructor;
        NewKlass.instancePool = [];
        NewKlass.getPooled = pooler || DEFAULT_POOLER;
        if (!NewKlass.poolSize) {
            NewKlass.poolSize = DEFAULT_POOL_SIZE;
        }
        NewKlass.release = standardReleaser;
        return NewKlass;
    };
    var PooledClass = {
        addPoolingTo: addPoolingTo,
        oneArgumentPooler: oneArgumentPooler,
        twoArgumentPooler: twoArgumentPooler,
        threeArgumentPooler: threeArgumentPooler,
        fourArgumentPooler: fourArgumentPooler
    };
    module.exports = PooledClass;
});
/*react-dom@15.6.1#lib/getTextContentAccessor*/
define('react-dom@15.6.1#lib/getTextContentAccessor', function (require, exports, module) {
    'use strict';
    var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
    var contentKey = null;
    function getTextContentAccessor() {
        if (!contentKey && ExecutionEnvironment.canUseDOM) {
            contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
        }
        return contentKey;
    }
    module.exports = getTextContentAccessor;
});
/*react-dom@15.6.1#lib/FallbackCompositionState*/
define('react-dom@15.6.1#lib/FallbackCompositionState', function (require, exports, module) {
    'use strict';
    var _assign = require('object-assign');
    var PooledClass = require('./PooledClass');
    var getTextContentAccessor = require('./getTextContentAccessor');
    function FallbackCompositionState(root) {
        this._root = root;
        this._startText = this.getText();
        this._fallbackText = null;
    }
    _assign(FallbackCompositionState.prototype, {
        destructor: function () {
            this._root = null;
            this._startText = null;
            this._fallbackText = null;
        },
        getText: function () {
            if ('value' in this._root) {
                return this._root.value;
            }
            return this._root[getTextContentAccessor()];
        },
        getData: function () {
            if (this._fallbackText) {
                return this._fallbackText;
            }
            var start;
            var startValue = this._startText;
            var startLength = startValue.length;
            var end;
            var endValue = this.getText();
            var endLength = endValue.length;
            for (start = 0; start < startLength; start++) {
                if (startValue[start] !== endValue[start]) {
                    break;
                }
            }
            var minEnd = startLength - start;
            for (end = 1; end <= minEnd; end++) {
                if (startValue[startLength - end] !== endValue[endLength - end]) {
                    break;
                }
            }
            var sliceTail = end > 1 ? 1 - end : undefined;
            this._fallbackText = endValue.slice(start, sliceTail);
            return this._fallbackText;
        }
    });
    PooledClass.addPoolingTo(FallbackCompositionState);
    module.exports = FallbackCompositionState;
});
/*react-dom@15.6.1#lib/SyntheticEvent*/
define('react-dom@15.6.1#lib/SyntheticEvent', function (require, exports, module) {
    'use strict';
    var _assign = require('object-assign');
    var PooledClass = require('./PooledClass');
    var emptyFunction = require('fbjs/lib/emptyFunction');
    var warning = require('fbjs/lib/warning');
    var didWarnForAddedNewProperty = false;
    var isProxySupported = typeof Proxy === 'function';
    var shouldBeReleasedProperties = [
        'dispatchConfig',
        '_targetInst',
        'nativeEvent',
        'isDefaultPrevented',
        'isPropagationStopped',
        '_dispatchListeners',
        '_dispatchInstances'
    ];
    var EventInterface = {
        type: null,
        target: null,
        currentTarget: emptyFunction.thatReturnsNull,
        eventPhase: null,
        bubbles: null,
        cancelable: null,
        timeStamp: function (event) {
            return event.timeStamp || Date.now();
        },
        defaultPrevented: null,
        isTrusted: null
    };
    function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
        if (process.env.NODE_ENV !== 'production') {
            delete this.nativeEvent;
            delete this.preventDefault;
            delete this.stopPropagation;
        }
        this.dispatchConfig = dispatchConfig;
        this._targetInst = targetInst;
        this.nativeEvent = nativeEvent;
        var Interface = this.constructor.Interface;
        for (var propName in Interface) {
            if (!Interface.hasOwnProperty(propName)) {
                continue;
            }
            if (process.env.NODE_ENV !== 'production') {
                delete this[propName];
            }
            var normalize = Interface[propName];
            if (normalize) {
                this[propName] = normalize(nativeEvent);
            } else {
                if (propName === 'target') {
                    this.target = nativeEventTarget;
                } else {
                    this[propName] = nativeEvent[propName];
                }
            }
        }
        var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
        if (defaultPrevented) {
            this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
        } else {
            this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
        }
        this.isPropagationStopped = emptyFunction.thatReturnsFalse;
        return this;
    }
    _assign(SyntheticEvent.prototype, {
        preventDefault: function () {
            this.defaultPrevented = true;
            var event = this.nativeEvent;
            if (!event) {
                return;
            }
            if (event.preventDefault) {
                event.preventDefault();
            } else if (typeof event.returnValue !== 'unknown') {
                event.returnValue = false;
            }
            this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
        },
        stopPropagation: function () {
            var event = this.nativeEvent;
            if (!event) {
                return;
            }
            if (event.stopPropagation) {
                event.stopPropagation();
            } else if (typeof event.cancelBubble !== 'unknown') {
                event.cancelBubble = true;
            }
            this.isPropagationStopped = emptyFunction.thatReturnsTrue;
        },
        persist: function () {
            this.isPersistent = emptyFunction.thatReturnsTrue;
        },
        isPersistent: emptyFunction.thatReturnsFalse,
        destructor: function () {
            var Interface = this.constructor.Interface;
            for (var propName in Interface) {
                if (process.env.NODE_ENV !== 'production') {
                    Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));
                } else {
                    this[propName] = null;
                }
            }
            for (var i = 0; i < shouldBeReleasedProperties.length; i++) {
                this[shouldBeReleasedProperties[i]] = null;
            }
            if (process.env.NODE_ENV !== 'production') {
                Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));
                Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', emptyFunction));
                Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', emptyFunction));
            }
        }
    });
    SyntheticEvent.Interface = EventInterface;
    if (process.env.NODE_ENV !== 'production') {
        if (isProxySupported) {
            SyntheticEvent = new Proxy(SyntheticEvent, {
                construct: function (target, args) {
                    return this.apply(target, Object.create(target.prototype), args);
                },
                apply: function (constructor, that, args) {
                    return new Proxy(constructor.apply(that, args), {
                        set: function (target, prop, value) {
                            if (prop !== 'isPersistent' && !target.constructor.Interface.hasOwnProperty(prop) && shouldBeReleasedProperties.indexOf(prop) === -1) {
                                process.env.NODE_ENV !== 'production' ? warning(didWarnForAddedNewProperty || target.isPersistent(), 'This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re adding a new property in the synthetic event object. ' + 'The property is never released. See ' + 'https://fb.me/react-event-pooling for more information.') : void 0;
                                didWarnForAddedNewProperty = true;
                            }
                            target[prop] = value;
                            return true;
                        }
                    });
                }
            });
        }
    }
    SyntheticEvent.augmentClass = function (Class, Interface) {
        var Super = this;
        var E = function () {
        };
        E.prototype = Super.prototype;
        var prototype = new E();
        _assign(prototype, Class.prototype);
        Class.prototype = prototype;
        Class.prototype.constructor = Class;
        Class.Interface = _assign({}, Super.Interface, Interface);
        Class.augmentClass = Super.augmentClass;
        PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
    };
    PooledClass.addPoolingTo(SyntheticEvent, PooledClass.fourArgumentPooler);
    module.exports = SyntheticEvent;
    function getPooledWarningPropertyDefinition(propName, getVal) {
        var isFunction = typeof getVal === 'function';
        return {
            configurable: true,
            set: set,
            get: get
        };
        function set(val) {
            var action = isFunction ? 'setting the method' : 'setting the property';
            warn(action, 'This is effectively a no-op');
            return val;
        }
        function get() {
            var action = isFunction ? 'accessing the method' : 'accessing the property';
            var result = isFunction ? 'This is a no-op function' : 'This is set to null';
            warn(action, result);
            return getVal;
        }
        function warn(action, result) {
            var warningCondition = false;
            process.env.NODE_ENV !== 'production' ? warning(warningCondition, 'This synthetic event is reused for performance reasons. If you\'re seeing this, ' + 'you\'re %s `%s` on a released/nullified synthetic event. %s. ' + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result) : void 0;
        }
    }
});
/*react-dom@15.6.1#lib/SyntheticCompositionEvent*/
define('react-dom@15.6.1#lib/SyntheticCompositionEvent', function (require, exports, module) {
    'use strict';
    var SyntheticEvent = require('./SyntheticEvent');
    var CompositionEventInterface = { data: null };
    function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
        return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
    }
    SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);
    module.exports = SyntheticCompositionEvent;
});
/*react-dom@15.6.1#lib/SyntheticInputEvent*/
define('react-dom@15.6.1#lib/SyntheticInputEvent', function (require, exports, module) {
    'use strict';
    var SyntheticEvent = require('./SyntheticEvent');
    var InputEventInterface = { data: null };
    function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
        return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
    }
    SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);
    module.exports = SyntheticInputEvent;
});
/*react-dom@15.6.1#lib/BeforeInputEventPlugin*/
define('react-dom@15.6.1#lib/BeforeInputEventPlugin', function (require, exports, module) {
    'use strict';
    var EventPropagators = require('./EventPropagators');
    var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
    var FallbackCompositionState = require('./FallbackCompositionState');
    var SyntheticCompositionEvent = require('./SyntheticCompositionEvent');
    var SyntheticInputEvent = require('./SyntheticInputEvent');
    var END_KEYCODES = [
        9,
        13,
        27,
        32
    ];
    var START_KEYCODE = 229;
    var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;
    var documentMode = null;
    if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
        documentMode = document.documentMode;
    }
    var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();
    var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
    function isPresto() {
        var opera = window.opera;
        return typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
    }
    var SPACEBAR_CODE = 32;
    var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
    var eventTypes = {
        beforeInput: {
            phasedRegistrationNames: {
                bubbled: 'onBeforeInput',
                captured: 'onBeforeInputCapture'
            },
            dependencies: [
                'topCompositionEnd',
                'topKeyPress',
                'topTextInput',
                'topPaste'
            ]
        },
        compositionEnd: {
            phasedRegistrationNames: {
                bubbled: 'onCompositionEnd',
                captured: 'onCompositionEndCapture'
            },
            dependencies: [
                'topBlur',
                'topCompositionEnd',
                'topKeyDown',
                'topKeyPress',
                'topKeyUp',
                'topMouseDown'
            ]
        },
        compositionStart: {
            phasedRegistrationNames: {
                bubbled: 'onCompositionStart',
                captured: 'onCompositionStartCapture'
            },
            dependencies: [
                'topBlur',
                'topCompositionStart',
                'topKeyDown',
                'topKeyPress',
                'topKeyUp',
                'topMouseDown'
            ]
        },
        compositionUpdate: {
            phasedRegistrationNames: {
                bubbled: 'onCompositionUpdate',
                captured: 'onCompositionUpdateCapture'
            },
            dependencies: [
                'topBlur',
                'topCompositionUpdate',
                'topKeyDown',
                'topKeyPress',
                'topKeyUp',
                'topMouseDown'
            ]
        }
    };
    var hasSpaceKeypress = false;
    function isKeypressCommand(nativeEvent) {
        return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && !(nativeEvent.ctrlKey && nativeEvent.altKey);
    }
    function getCompositionEventType(topLevelType) {
        switch (topLevelType) {
        case 'topCompositionStart':
            return eventTypes.compositionStart;
        case 'topCompositionEnd':
            return eventTypes.compositionEnd;
        case 'topCompositionUpdate':
            return eventTypes.compositionUpdate;
        }
    }
    function isFallbackCompositionStart(topLevelType, nativeEvent) {
        return topLevelType === 'topKeyDown' && nativeEvent.keyCode === START_KEYCODE;
    }
    function isFallbackCompositionEnd(topLevelType, nativeEvent) {
        switch (topLevelType) {
        case 'topKeyUp':
            return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
        case 'topKeyDown':
            return nativeEvent.keyCode !== START_KEYCODE;
        case 'topKeyPress':
        case 'topMouseDown':
        case 'topBlur':
            return true;
        default:
            return false;
        }
    }
    function getDataFromCustomEvent(nativeEvent) {
        var detail = nativeEvent.detail;
        if (typeof detail === 'object' && 'data' in detail) {
            return detail.data;
        }
        return null;
    }
    var currentComposition = null;
    function extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
        var eventType;
        var fallbackData;
        if (canUseCompositionEvent) {
            eventType = getCompositionEventType(topLevelType);
        } else if (!currentComposition) {
            if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
                eventType = eventTypes.compositionStart;
            }
        } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
            eventType = eventTypes.compositionEnd;
        }
        if (!eventType) {
            return null;
        }
        if (useFallbackCompositionData) {
            if (!currentComposition && eventType === eventTypes.compositionStart) {
                currentComposition = FallbackCompositionState.getPooled(nativeEventTarget);
            } else if (eventType === eventTypes.compositionEnd) {
                if (currentComposition) {
                    fallbackData = currentComposition.getData();
                }
            }
        }
        var event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);
        if (fallbackData) {
            event.data = fallbackData;
        } else {
            var customData = getDataFromCustomEvent(nativeEvent);
            if (customData !== null) {
                event.data = customData;
            }
        }
        EventPropagators.accumulateTwoPhaseDispatches(event);
        return event;
    }
    function getNativeBeforeInputChars(topLevelType, nativeEvent) {
        switch (topLevelType) {
        case 'topCompositionEnd':
            return getDataFromCustomEvent(nativeEvent);
        case 'topKeyPress':
            var which = nativeEvent.which;
            if (which !== SPACEBAR_CODE) {
                return null;
            }
            hasSpaceKeypress = true;
            return SPACEBAR_CHAR;
        case 'topTextInput':
            var chars = nativeEvent.data;
            if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
                return null;
            }
            return chars;
        default:
            return null;
        }
    }
    function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
        if (currentComposition) {
            if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent && isFallbackCompositionEnd(topLevelType, nativeEvent)) {
                var chars = currentComposition.getData();
                FallbackCompositionState.release(currentComposition);
                currentComposition = null;
                return chars;
            }
            return null;
        }
        switch (topLevelType) {
        case 'topPaste':
            return null;
        case 'topKeyPress':
            if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
                return String.fromCharCode(nativeEvent.which);
            }
            return null;
        case 'topCompositionEnd':
            return useFallbackCompositionData ? null : nativeEvent.data;
        default:
            return null;
        }
    }
    function extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
        var chars;
        if (canUseTextInputEvent) {
            chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
        } else {
            chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
        }
        if (!chars) {
            return null;
        }
        var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);
        event.data = chars;
        EventPropagators.accumulateTwoPhaseDispatches(event);
        return event;
    }
    var BeforeInputEventPlugin = {
        eventTypes: eventTypes,
        extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
            return [
                extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget),
                extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget)
            ];
        }
    };
    module.exports = BeforeInputEventPlugin;
});
/*react-dom@15.6.1#lib/CallbackQueue*/
define('react-dom@15.6.1#lib/CallbackQueue', function (require, exports, module) {
    'use strict';
    var _prodInvariant = require('./reactProdInvariant');
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError('Cannot call a class as a function');
        }
    }
    var PooledClass = require('./PooledClass');
    var invariant = require('fbjs/lib/invariant');
    var CallbackQueue = function () {
        function CallbackQueue(arg) {
            _classCallCheck(this, CallbackQueue);
            this._callbacks = null;
            this._contexts = null;
            this._arg = arg;
        }
        CallbackQueue.prototype.enqueue = function enqueue(callback, context) {
            this._callbacks = this._callbacks || [];
            this._callbacks.push(callback);
            this._contexts = this._contexts || [];
            this._contexts.push(context);
        };
        CallbackQueue.prototype.notifyAll = function notifyAll() {
            var callbacks = this._callbacks;
            var contexts = this._contexts;
            var arg = this._arg;
            if (callbacks && contexts) {
                !(callbacks.length === contexts.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Mismatched list of contexts in callback queue') : _prodInvariant('24') : void 0;
                this._callbacks = null;
                this._contexts = null;
                for (var i = 0; i < callbacks.length; i++) {
                    callbacks[i].call(contexts[i], arg);
                }
                callbacks.length = 0;
                contexts.length = 0;
            }
        };
        CallbackQueue.prototype.checkpoint = function checkpoint() {
            return this._callbacks ? this._callbacks.length : 0;
        };
        CallbackQueue.prototype.rollback = function rollback(len) {
            if (this._callbacks && this._contexts) {
                this._callbacks.length = len;
                this._contexts.length = len;
            }
        };
        CallbackQueue.prototype.reset = function reset() {
            this._callbacks = null;
            this._contexts = null;
        };
        CallbackQueue.prototype.destructor = function destructor() {
            this.reset();
        };
        return CallbackQueue;
    }();
    module.exports = PooledClass.addPoolingTo(CallbackQueue);
});
/*react-dom@15.6.1#lib/ReactFeatureFlags*/
define('react-dom@15.6.1#lib/ReactFeatureFlags', function (require, exports, module) {
    'use strict';
    var ReactFeatureFlags = { logTopLevelRenders: false };
    module.exports = ReactFeatureFlags;
});
/*react-dom@15.6.1#lib/ReactOwner*/
define('react-dom@15.6.1#lib/ReactOwner', function (require, exports, module) {
    'use strict';
    var _prodInvariant = require('./reactProdInvariant');
    var invariant = require('fbjs/lib/invariant');
    function isValidOwner(object) {
        return !!(object && typeof object.attachRef === 'function' && typeof object.detachRef === 'function');
    }
    var ReactOwner = {
        addComponentAsRefTo: function (component, ref, owner) {
            !isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'addComponentAsRefTo(...): Only a ReactOwner can have refs. You might be adding a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('119') : void 0;
            owner.attachRef(ref, component);
        },
        removeComponentAsRefFrom: function (component, ref, owner) {
            !isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. You might be removing a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('120') : void 0;
            var ownerPublicInstance = owner.getPublicInstance();
            if (ownerPublicInstance && ownerPublicInstance.refs[ref] === component.getPublicInstance()) {
                owner.detachRef(ref);
            }
        }
    };
    module.exports = ReactOwner;
});
/*react-dom@15.6.1#lib/ReactRef*/
define('react-dom@15.6.1#lib/ReactRef', function (require, exports, module) {
    'use strict';
    var ReactOwner = require('./ReactOwner');
    var ReactRef = {};
    function attachRef(ref, component, owner) {
        if (typeof ref === 'function') {
            ref(component.getPublicInstance());
        } else {
            ReactOwner.addComponentAsRefTo(component, ref, owner);
        }
    }
    function detachRef(ref, component, owner) {
        if (typeof ref === 'function') {
            ref(null);
        } else {
            ReactOwner.removeComponentAsRefFrom(component, ref, owner);
        }
    }
    ReactRef.attachRefs = function (instance, element) {
        if (element === null || typeof element !== 'object') {
            return;
        }
        var ref = element.ref;
        if (ref != null) {
            attachRef(ref, instance, element._owner);
        }
    };
    ReactRef.shouldUpdateRefs = function (prevElement, nextElement) {
        var prevRef = null;
        var prevOwner = null;
        if (prevElement !== null && typeof prevElement === 'object') {
            prevRef = prevElement.ref;
            prevOwner = prevElement._owner;
        }
        var nextRef = null;
        var nextOwner = null;
        if (nextElement !== null && typeof nextElement === 'object') {
            nextRef = nextElement.ref;
            nextOwner = nextElement._owner;
        }
        return prevRef !== nextRef || typeof nextRef === 'string' && nextOwner !== prevOwner;
    };
    ReactRef.detachRefs = function (instance, element) {
        if (element === null || typeof element !== 'object') {
            return;
        }
        var ref = element.ref;
        if (ref != null) {
            detachRef(ref, instance, element._owner);
        }
    };
    module.exports = ReactRef;
});
/*react-dom@15.6.1#lib/ReactInvalidSetStateWarningHook*/
define('react-dom@15.6.1#lib/ReactInvalidSetStateWarningHook', function (require, exports, module) {
    'use strict';
    var warning = require('fbjs/lib/warning');
    if (process.env.NODE_ENV !== 'production') {
        var processingChildContext = false;
        var warnInvalidSetState = function () {
            process.env.NODE_ENV !== 'production' ? warning(!processingChildContext, 'setState(...): Cannot call setState() inside getChildContext()') : void 0;
        };
    }
    var ReactInvalidSetStateWarningHook = {
        onBeginProcessingChildContext: function () {
            processingChildContext = true;
        },
        onEndProcessingChildContext: function () {
            processingChildContext = false;
        },
        onSetState: function () {
            warnInvalidSetState();
        }
    };
    module.exports = ReactInvalidSetStateWarningHook;
});
/*react-dom@15.6.1#lib/ReactHostOperationHistoryHook*/
define('react-dom@15.6.1#lib/ReactHostOperationHistoryHook', function (require, exports, module) {
    'use strict';
    var history = [];
    var ReactHostOperationHistoryHook = {
        onHostOperation: function (operation) {
            history.push(operation);
        },
        clearHistory: function () {
            if (ReactHostOperationHistoryHook._preventClearing) {
                return;
            }
            history = [];
        },
        getHistory: function () {
            return history;
        }
    };
    module.exports = ReactHostOperationHistoryHook;
});
/*fbjs@0.8.12#lib/performance*/
define('fbjs@0.8.12#lib/performance', function (require, exports, module) {
    'use strict';
    var ExecutionEnvironment = require('./ExecutionEnvironment');
    var performance;
    if (ExecutionEnvironment.canUseDOM) {
        performance = window.performance || window.msPerformance || window.webkitPerformance;
    }
    module.exports = performance || {};
});
/*fbjs@0.8.12#lib/performanceNow*/
define('fbjs@0.8.12#lib/performanceNow', function (require, exports, module) {
    'use strict';
    var performance = require('./performance');
    var performanceNow;
    if (performance.now) {
        performanceNow = function performanceNow() {
            return performance.now();
        };
    } else {
        performanceNow = function performanceNow() {
            return Date.now();
        };
    }
    module.exports = performanceNow;
});
/*react-dom@15.6.1#lib/ReactDebugTool*/
define('react-dom@15.6.1#lib/ReactDebugTool', function (require, exports, module) {
    'use strict';
    var ReactInvalidSetStateWarningHook = require('./ReactInvalidSetStateWarningHook');
    var ReactHostOperationHistoryHook = require('./ReactHostOperationHistoryHook');
    var ReactComponentTreeHook = require('react/lib/ReactComponentTreeHook');
    var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
    var performanceNow = require('fbjs/lib/performanceNow');
    var warning = require('fbjs/lib/warning');
    var hooks = [];
    var didHookThrowForEvent = {};
    function callHook(event, fn, context, arg1, arg2, arg3, arg4, arg5) {
        try {
            fn.call(context, arg1, arg2, arg3, arg4, arg5);
        } catch (e) {
            process.env.NODE_ENV !== 'production' ? warning(didHookThrowForEvent[event], 'Exception thrown by hook while handling %s: %s', event, e + '\n' + e.stack) : void 0;
            didHookThrowForEvent[event] = true;
        }
    }
    function emitEvent(event, arg1, arg2, arg3, arg4, arg5) {
        for (var i = 0; i < hooks.length; i++) {
            var hook = hooks[i];
            var fn = hook[event];
            if (fn) {
                callHook(event, fn, hook, arg1, arg2, arg3, arg4, arg5);
            }
        }
    }
    var isProfiling = false;
    var flushHistory = [];
    var lifeCycleTimerStack = [];
    var currentFlushNesting = 0;
    var currentFlushMeasurements = [];
    var currentFlushStartTime = 0;
    var currentTimerDebugID = null;
    var currentTimerStartTime = 0;
    var currentTimerNestedFlushDuration = 0;
    var currentTimerType = null;
    var lifeCycleTimerHasWarned = false;
    function clearHistory() {
        ReactComponentTreeHook.purgeUnmountedComponents();
        ReactHostOperationHistoryHook.clearHistory();
    }
    function getTreeSnapshot(registeredIDs) {
        return registeredIDs.reduce(function (tree, id) {
            var ownerID = ReactComponentTreeHook.getOwnerID(id);
            var parentID = ReactComponentTreeHook.getParentID(id);
            tree[id] = {
                displayName: ReactComponentTreeHook.getDisplayName(id),
                text: ReactComponentTreeHook.getText(id),
                updateCount: ReactComponentTreeHook.getUpdateCount(id),
                childIDs: ReactComponentTreeHook.getChildIDs(id),
                ownerID: ownerID || parentID && ReactComponentTreeHook.getOwnerID(parentID) || 0,
                parentID: parentID
            };
            return tree;
        }, {});
    }
    function resetMeasurements() {
        var previousStartTime = currentFlushStartTime;
        var previousMeasurements = currentFlushMeasurements;
        var previousOperations = ReactHostOperationHistoryHook.getHistory();
        if (currentFlushNesting === 0) {
            currentFlushStartTime = 0;
            currentFlushMeasurements = [];
            clearHistory();
            return;
        }
        if (previousMeasurements.length || previousOperations.length) {
            var registeredIDs = ReactComponentTreeHook.getRegisteredIDs();
            flushHistory.push({
                duration: performanceNow() - previousStartTime,
                measurements: previousMeasurements || [],
                operations: previousOperations || [],
                treeSnapshot: getTreeSnapshot(registeredIDs)
            });
        }
        clearHistory();
        currentFlushStartTime = performanceNow();
        currentFlushMeasurements = [];
    }
    function checkDebugID(debugID) {
        var allowRoot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        if (allowRoot && debugID === 0) {
            return;
        }
        if (!debugID) {
            process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDebugTool: debugID may not be empty.') : void 0;
        }
    }
    function beginLifeCycleTimer(debugID, timerType) {
        if (currentFlushNesting === 0) {
            return;
        }
        if (currentTimerType && !lifeCycleTimerHasWarned) {
            process.env.NODE_ENV !== 'production' ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'Did not expect %s timer to start while %s timer is still in ' + 'progress for %s instance.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
            lifeCycleTimerHasWarned = true;
        }
        currentTimerStartTime = performanceNow();
        currentTimerNestedFlushDuration = 0;
        currentTimerDebugID = debugID;
        currentTimerType = timerType;
    }
    function endLifeCycleTimer(debugID, timerType) {
        if (currentFlushNesting === 0) {
            return;
        }
        if (currentTimerType !== timerType && !lifeCycleTimerHasWarned) {
            process.env.NODE_ENV !== 'production' ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'We did not expect %s timer to stop while %s timer is still in ' + 'progress for %s instance. Please report this as a bug in React.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
            lifeCycleTimerHasWarned = true;
        }
        if (isProfiling) {
            currentFlushMeasurements.push({
                timerType: timerType,
                instanceID: debugID,
                duration: performanceNow() - currentTimerStartTime - currentTimerNestedFlushDuration
            });
        }
        currentTimerStartTime = 0;
        currentTimerNestedFlushDuration = 0;
        currentTimerDebugID = null;
        currentTimerType = null;
    }
    function pauseCurrentLifeCycleTimer() {
        var currentTimer = {
            startTime: currentTimerStartTime,
            nestedFlushStartTime: performanceNow(),
            debugID: currentTimerDebugID,
            timerType: currentTimerType
        };
        lifeCycleTimerStack.push(currentTimer);
        currentTimerStartTime = 0;
        currentTimerNestedFlushDuration = 0;
        currentTimerDebugID = null;
        currentTimerType = null;
    }
    function resumeCurrentLifeCycleTimer() {
        var _lifeCycleTimerStack$ = lifeCycleTimerStack.pop(), startTime = _lifeCycleTimerStack$.startTime, nestedFlushStartTime = _lifeCycleTimerStack$.nestedFlushStartTime, debugID = _lifeCycleTimerStack$.debugID, timerType = _lifeCycleTimerStack$.timerType;
        var nestedFlushDuration = performanceNow() - nestedFlushStartTime;
        currentTimerStartTime = startTime;
        currentTimerNestedFlushDuration += nestedFlushDuration;
        currentTimerDebugID = debugID;
        currentTimerType = timerType;
    }
    var lastMarkTimeStamp = 0;
    var canUsePerformanceMeasure = typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function';
    function shouldMark(debugID) {
        if (!isProfiling || !canUsePerformanceMeasure) {
            return false;
        }
        var element = ReactComponentTreeHook.getElement(debugID);
        if (element == null || typeof element !== 'object') {
            return false;
        }
        var isHostElement = typeof element.type === 'string';
        if (isHostElement) {
            return false;
        }
        return true;
    }
    function markBegin(debugID, markType) {
        if (!shouldMark(debugID)) {
            return;
        }
        var markName = debugID + '::' + markType;
        lastMarkTimeStamp = performanceNow();
        performance.mark(markName);
    }
    function markEnd(debugID, markType) {
        if (!shouldMark(debugID)) {
            return;
        }
        var markName = debugID + '::' + markType;
        var displayName = ReactComponentTreeHook.getDisplayName(debugID) || 'Unknown';
        var timeStamp = performanceNow();
        if (timeStamp - lastMarkTimeStamp > 0.1) {
            var measurementName = displayName + ' [' + markType + ']';
            performance.measure(measurementName, markName);
        }
        performance.clearMarks(markName);
        if (measurementName) {
            performance.clearMeasures(measurementName);
        }
    }
    var ReactDebugTool = {
        addHook: function (hook) {
            hooks.push(hook);
        },
        removeHook: function (hook) {
            for (var i = 0; i < hooks.length; i++) {
                if (hooks[i] === hook) {
                    hooks.splice(i, 1);
                    i--;
                }
            }
        },
        isProfiling: function () {
            return isProfiling;
        },
        beginProfiling: function () {
            if (isProfiling) {
                return;
            }
            isProfiling = true;
            flushHistory.length = 0;
            resetMeasurements();
            ReactDebugTool.addHook(ReactHostOperationHistoryHook);
        },
        endProfiling: function () {
            if (!isProfiling) {
                return;
            }
            isProfiling = false;
            resetMeasurements();
            ReactDebugTool.removeHook(ReactHostOperationHistoryHook);
        },
        getFlushHistory: function () {
            return flushHistory;
        },
        onBeginFlush: function () {
            currentFlushNesting++;
            resetMeasurements();
            pauseCurrentLifeCycleTimer();
            emitEvent('onBeginFlush');
        },
        onEndFlush: function () {
            resetMeasurements();
            currentFlushNesting--;
            resumeCurrentLifeCycleTimer();
            emitEvent('onEndFlush');
        },
        onBeginLifeCycleTimer: function (debugID, timerType) {
            checkDebugID(debugID);
            emitEvent('onBeginLifeCycleTimer', debugID, timerType);
            markBegin(debugID, timerType);
            beginLifeCycleTimer(debugID, timerType);
        },
        onEndLifeCycleTimer: function (debugID, timerType) {
            checkDebugID(debugID);
            endLifeCycleTimer(debugID, timerType);
            markEnd(debugID, timerType);
            emitEvent('onEndLifeCycleTimer', debugID, timerType);
        },
        onBeginProcessingChildContext: function () {
            emitEvent('onBeginProcessingChildContext');
        },
        onEndProcessingChildContext: function () {
            emitEvent('onEndProcessingChildContext');
        },
        onHostOperation: function (operation) {
            checkDebugID(operation.instanceID);
            emitEvent('onHostOperation', operation);
        },
        onSetState: function () {
            emitEvent('onSetState');
        },
        onSetChildren: function (debugID, childDebugIDs) {
            checkDebugID(debugID);
            childDebugIDs.forEach(checkDebugID);
            emitEvent('onSetChildren', debugID, childDebugIDs);
        },
        onBeforeMountComponent: function (debugID, element, parentDebugID) {
            checkDebugID(debugID);
            checkDebugID(parentDebugID, true);
            emitEvent('onBeforeMountComponent', debugID, element, parentDebugID);
            markBegin(debugID, 'mount');
        },
        onMountComponent: function (debugID) {
            checkDebugID(debugID);
            markEnd(debugID, 'mount');
            emitEvent('onMountComponent', debugID);
        },
        onBeforeUpdateComponent: function (debugID, element) {
            checkDebugID(debugID);
            emitEvent('onBeforeUpdateComponent', debugID, element);
            markBegin(debugID, 'update');
        },
        onUpdateComponent: function (debugID) {
            checkDebugID(debugID);
            markEnd(debugID, 'update');
            emitEvent('onUpdateComponent', debugID);
        },
        onBeforeUnmountComponent: function (debugID) {
            checkDebugID(debugID);
            emitEvent('onBeforeUnmountComponent', debugID);
            markBegin(debugID, 'unmount');
        },
        onUnmountComponent: function (debugID) {
            checkDebugID(debugID);
            markEnd(debugID, 'unmount');
            emitEvent('onUnmountComponent', debugID);
        },
        onTestEvent: function () {
            emitEvent('onTestEvent');
        }
    };
    ReactDebugTool.addDevtool = ReactDebugTool.addHook;
    ReactDebugTool.removeDevtool = ReactDebugTool.removeHook;
    ReactDebugTool.addHook(ReactInvalidSetStateWarningHook);
    ReactDebugTool.addHook(ReactComponentTreeHook);
    var url = ExecutionEnvironment.canUseDOM && window.location.href || '';
    if (/[?&]react_perf\b/.test(url)) {
        ReactDebugTool.beginProfiling();
    }
    module.exports = ReactDebugTool;
});
/*react-dom@15.6.1#lib/ReactInstrumentation*/
define('react-dom@15.6.1#lib/ReactInstrumentation', function (require, exports, module) {
    'use strict';
    var debugTool = null;
    if (process.env.NODE_ENV !== 'production') {
        var ReactDebugTool = require('./ReactDebugTool');
        debugTool = ReactDebugTool;
    }
    module.exports = { debugTool: debugTool };
});
/*react-dom@15.6.1#lib/ReactReconciler*/
define('react-dom@15.6.1#lib/ReactReconciler', function (require, exports, module) {
    'use strict';
    var ReactRef = require('./ReactRef');
    var ReactInstrumentation = require('./ReactInstrumentation');
    var warning = require('fbjs/lib/warning');
    function attachRefs() {
        ReactRef.attachRefs(this, this._currentElement);
    }
    var ReactReconciler = {
        mountComponent: function (internalInstance, transaction, hostParent, hostContainerInfo, context, parentDebugID) {
            if (process.env.NODE_ENV !== 'production') {
                if (internalInstance._debugID !== 0) {
                    ReactInstrumentation.debugTool.onBeforeMountComponent(internalInstance._debugID, internalInstance._currentElement, parentDebugID);
                }
            }
            var markup = internalInstance.mountComponent(transaction, hostParent, hostContainerInfo, context, parentDebugID);
            if (internalInstance._currentElement && internalInstance._currentElement.ref != null) {
                transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
            }
            if (process.env.NODE_ENV !== 'production') {
                if (internalInstance._debugID !== 0) {
                    ReactInstrumentation.debugTool.onMountComponent(internalInstance._debugID);
                }
            }
            return markup;
        },
        getHostNode: function (internalInstance) {
            return internalInstance.getHostNode();
        },
        unmountComponent: function (internalInstance, safely) {
            if (process.env.NODE_ENV !== 'production') {
                if (internalInstance._debugID !== 0) {
                    ReactInstrumentation.debugTool.onBeforeUnmountComponent(internalInstance._debugID);
                }
            }
            ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
            internalInstance.unmountComponent(safely);
            if (process.env.NODE_ENV !== 'production') {
                if (internalInstance._debugID !== 0) {
                    ReactInstrumentation.debugTool.onUnmountComponent(internalInstance._debugID);
                }
            }
        },
        receiveComponent: function (internalInstance, nextElement, transaction, context) {
            var prevElement = internalInstance._currentElement;
            if (nextElement === prevElement && context === internalInstance._context) {
                return;
            }
            if (process.env.NODE_ENV !== 'production') {
                if (internalInstance._debugID !== 0) {
                    ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, nextElement);
                }
            }
            var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);
            if (refsChanged) {
                ReactRef.detachRefs(internalInstance, prevElement);
            }
            internalInstance.receiveComponent(nextElement, transaction, context);
            if (refsChanged && internalInstance._currentElement && internalInstance._currentElement.ref != null) {
                transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
            }
            if (process.env.NODE_ENV !== 'production') {
                if (internalInstance._debugID !== 0) {
                    ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
                }
            }
        },
        performUpdateIfNecessary: function (internalInstance, transaction, updateBatchNumber) {
            if (internalInstance._updateBatchNumber !== updateBatchNumber) {
                process.env.NODE_ENV !== 'production' ? warning(internalInstance._updateBatchNumber == null || internalInstance._updateBatchNumber === updateBatchNumber + 1, 'performUpdateIfNecessary: Unexpected batch number (current %s, ' + 'pending %s)', updateBatchNumber, internalInstance._updateBatchNumber) : void 0;
                return;
            }
            if (process.env.NODE_ENV !== 'production') {
                if (internalInstance._debugID !== 0) {
                    ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, internalInstance._currentElement);
                }
            }
            internalInstance.performUpdateIfNecessary(transaction);
            if (process.env.NODE_ENV !== 'production') {
                if (internalInstance._debugID !== 0) {
                    ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
                }
            }
        }
    };
    module.exports = ReactReconciler;
});
/*react-dom@15.6.1#lib/Transaction*/
define('react-dom@15.6.1#lib/Transaction', function (require, exports, module) {
    'use strict';
    var _prodInvariant = require('./reactProdInvariant');
    var invariant = require('fbjs/lib/invariant');
    var OBSERVED_ERROR = {};
    var TransactionImpl = {
        reinitializeTransaction: function () {
            this.transactionWrappers = this.getTransactionWrappers();
            if (this.wrapperInitData) {
                this.wrapperInitData.length = 0;
            } else {
                this.wrapperInitData = [];
            }
            this._isInTransaction = false;
        },
        _isInTransaction: false,
        getTransactionWrappers: null,
        isInTransaction: function () {
            return !!this._isInTransaction;
        },
        perform: function (method, scope, a, b, c, d, e, f) {
            !!this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.perform(...): Cannot initialize a transaction when there is already an outstanding transaction.') : _prodInvariant('27') : void 0;
            var errorThrown;
            var ret;
            try {
                this._isInTransaction = true;
                errorThrown = true;
                this.initializeAll(0);
                ret = method.call(scope, a, b, c, d, e, f);
                errorThrown = false;
            } finally {
                try {
                    if (errorThrown) {
                        try {
                            this.closeAll(0);
                        } catch (err) {
                        }
                    } else {
                        this.closeAll(0);
                    }
                } finally {
                    this._isInTransaction = false;
                }
            }
            return ret;
        },
        initializeAll: function (startIndex) {
            var transactionWrappers = this.transactionWrappers;
            for (var i = startIndex; i < transactionWrappers.length; i++) {
                var wrapper = transactionWrappers[i];
                try {
                    this.wrapperInitData[i] = OBSERVED_ERROR;
                    this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
                } finally {
                    if (this.wrapperInitData[i] === OBSERVED_ERROR) {
                        try {
                            this.initializeAll(i + 1);
                        } catch (err) {
                        }
                    }
                }
            }
        },
        closeAll: function (startIndex) {
            !this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.closeAll(): Cannot close transaction when none are open.') : _prodInvariant('28') : void 0;
            var transactionWrappers = this.transactionWrappers;
            for (var i = startIndex; i < transactionWrappers.length; i++) {
                var wrapper = transactionWrappers[i];
                var initData = this.wrapperInitData[i];
                var errorThrown;
                try {
                    errorThrown = true;
                    if (initData !== OBSERVED_ERROR && wrapper.close) {
                        wrapper.close.call(this, initData);
                    }
                    errorThrown = false;
                } finally {
                    if (errorThrown) {
                        try {
                            this.closeAll(i + 1);
                        } catch (e) {
                        }
                    }
                }
            }
            this.wrapperInitData.length = 0;
        }
    };
    module.exports = TransactionImpl;
});
/*react-dom@15.6.1#lib/ReactUpdates*/
define('react-dom@15.6.1#lib/ReactUpdates', function (require, exports, module) {
    'use strict';
    var _prodInvariant = require('./reactProdInvariant'), _assign = require('object-assign');
    var CallbackQueue = require('./CallbackQueue');
    var PooledClass = require('./PooledClass');
    var ReactFeatureFlags = require('./ReactFeatureFlags');
    var ReactReconciler = require('./ReactReconciler');
    var Transaction = require('./Transaction');
    var invariant = require('fbjs/lib/invariant');
    var dirtyComponents = [];
    var updateBatchNumber = 0;
    var asapCallbackQueue = CallbackQueue.getPooled();
    var asapEnqueued = false;
    var batchingStrategy = null;
    function ensureInjected() {
        !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching strategy') : _prodInvariant('123') : void 0;
    }
    var NESTED_UPDATES = {
        initialize: function () {
            this.dirtyComponentsLength = dirtyComponents.length;
        },
        close: function () {
            if (this.dirtyComponentsLength !== dirtyComponents.length) {
                dirtyComponents.splice(0, this.dirtyComponentsLength);
                flushBatchedUpdates();
            } else {
                dirtyComponents.length = 0;
            }
        }
    };
    var UPDATE_QUEUEING = {
        initialize: function () {
            this.callbackQueue.reset();
        },
        close: function () {
            this.callbackQueue.notifyAll();
        }
    };
    var TRANSACTION_WRAPPERS = [
        NESTED_UPDATES,
        UPDATE_QUEUEING
    ];
    function ReactUpdatesFlushTransaction() {
        this.reinitializeTransaction();
        this.dirtyComponentsLength = null;
        this.callbackQueue = CallbackQueue.getPooled();
        this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled(true);
    }
    _assign(ReactUpdatesFlushTransaction.prototype, Transaction, {
        getTransactionWrappers: function () {
            return TRANSACTION_WRAPPERS;
        },
        destructor: function () {
            this.dirtyComponentsLength = null;
            CallbackQueue.release(this.callbackQueue);
            this.callbackQueue = null;
            ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
            this.reconcileTransaction = null;
        },
        perform: function (method, scope, a) {
            return Transaction.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);
        }
    });
    PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);
    function batchedUpdates(callback, a, b, c, d, e) {
        ensureInjected();
        return batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
    }
    function mountOrderComparator(c1, c2) {
        return c1._mountOrder - c2._mountOrder;
    }
    function runBatchedUpdates(transaction) {
        var len = transaction.dirtyComponentsLength;
        !(len === dirtyComponents.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected flush transaction\'s stored dirty-components length (%s) to match dirty-components array length (%s).', len, dirtyComponents.length) : _prodInvariant('124', len, dirtyComponents.length) : void 0;
        dirtyComponents.sort(mountOrderComparator);
        updateBatchNumber++;
        for (var i = 0; i < len; i++) {
            var component = dirtyComponents[i];
            var callbacks = component._pendingCallbacks;
            component._pendingCallbacks = null;
            var markerName;
            if (ReactFeatureFlags.logTopLevelRenders) {
                var namedComponent = component;
                if (component._currentElement.type.isReactTopLevelWrapper) {
                    namedComponent = component._renderedComponent;
                }
                markerName = 'React update: ' + namedComponent.getName();
                console.time(markerName);
            }
            ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction, updateBatchNumber);
            if (markerName) {
                console.timeEnd(markerName);
            }
            if (callbacks) {
                for (var j = 0; j < callbacks.length; j++) {
                    transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());
                }
            }
        }
    }
    var flushBatchedUpdates = function () {
        while (dirtyComponents.length || asapEnqueued) {
            if (dirtyComponents.length) {
                var transaction = ReactUpdatesFlushTransaction.getPooled();
                transaction.perform(runBatchedUpdates, null, transaction);
                ReactUpdatesFlushTransaction.release(transaction);
            }
            if (asapEnqueued) {
                asapEnqueued = false;
                var queue = asapCallbackQueue;
                asapCallbackQueue = CallbackQueue.getPooled();
                queue.notifyAll();
                CallbackQueue.release(queue);
            }
        }
    };
    function enqueueUpdate(component) {
        ensureInjected();
        if (!batchingStrategy.isBatchingUpdates) {
            batchingStrategy.batchedUpdates(enqueueUpdate, component);
            return;
        }
        dirtyComponents.push(component);
        if (component._updateBatchNumber == null) {
            component._updateBatchNumber = updateBatchNumber + 1;
        }
    }
    function asap(callback, context) {
        !batchingStrategy.isBatchingUpdates ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates.asap: Can\'t enqueue an asap callback in a context whereupdates are not being batched.') : _prodInvariant('125') : void 0;
        asapCallbackQueue.enqueue(callback, context);
        asapEnqueued = true;
    }
    var ReactUpdatesInjection = {
        injectReconcileTransaction: function (ReconcileTransaction) {
            !ReconcileTransaction ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : _prodInvariant('126') : void 0;
            ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
        },
        injectBatchingStrategy: function (_batchingStrategy) {
            !_batchingStrategy ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batching strategy') : _prodInvariant('127') : void 0;
            !(typeof _batchingStrategy.batchedUpdates === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : _prodInvariant('128') : void 0;
            !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : _prodInvariant('129') : void 0;
            batchingStrategy = _batchingStrategy;
        }
    };
    var ReactUpdates = {
        ReactReconcileTransaction: null,
        batchedUpdates: batchedUpdates,
        enqueueUpdate: enqueueUpdate,
        flushBatchedUpdates: flushBatchedUpdates,
        injection: ReactUpdatesInjection,
        asap: asap
    };
    module.exports = ReactUpdates;
});
/*react-dom@15.6.1#lib/inputValueTracking*/
define('react-dom@15.6.1#lib/inputValueTracking', function (require, exports, module) {
    'use strict';
    var ReactDOMComponentTree = require('./ReactDOMComponentTree');
    function isCheckable(elem) {
        var type = elem.type;
        var nodeName = elem.nodeName;
        return nodeName && nodeName.toLowerCase() === 'input' && (type === 'checkbox' || type === 'radio');
    }
    function getTracker(inst) {
        return inst._wrapperState.valueTracker;
    }
    function attachTracker(inst, tracker) {
        inst._wrapperState.valueTracker = tracker;
    }
    function detachTracker(inst) {
        delete inst._wrapperState.valueTracker;
    }
    function getValueFromNode(node) {
        var value;
        if (node) {
            value = isCheckable(node) ? '' + node.checked : node.value;
        }
        return value;
    }
    var inputValueTracking = {
        _getTrackerFromNode: function (node) {
            return getTracker(ReactDOMComponentTree.getInstanceFromNode(node));
        },
        track: function (inst) {
            if (getTracker(inst)) {
                return;
            }
            var node = ReactDOMComponentTree.getNodeFromInstance(inst);
            var valueField = isCheckable(node) ? 'checked' : 'value';
            var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);
            var currentValue = '' + node[valueField];
            if (node.hasOwnProperty(valueField) || typeof descriptor.get !== 'function' || typeof descriptor.set !== 'function') {
                return;
            }
            Object.defineProperty(node, valueField, {
                enumerable: descriptor.enumerable,
                configurable: true,
                get: function () {
                    return descriptor.get.call(this);
                },
                set: function (value) {
                    currentValue = '' + value;
                    descriptor.set.call(this, value);
                }
            });
            attachTracker(inst, {
                getValue: function () {
                    return currentValue;
                },
                setValue: function (value) {
                    currentValue = '' + value;
                },
                stopTracking: function () {
                    detachTracker(inst);
                    delete node[valueField];
                }
            });
        },
        updateValueIfChanged: function (inst) {
            if (!inst) {
                return false;
            }
            var tracker = getTracker(inst);
            if (!tracker) {
                inputValueTracking.track(inst);
                return true;
            }
            var lastValue = tracker.getValue();
            var nextValue = getValueFromNode(ReactDOMComponentTree.getNodeFromInstance(inst));
            if (nextValue !== lastValue) {
                tracker.setValue(nextValue);
                return true;
            }
            return false;
        },
        stopTracking: function (inst) {
            var tracker = getTracker(inst);
            if (tracker) {
                tracker.stopTracking();
            }
        }
    };
    module.exports = inputValueTracking;
});
/*react-dom@15.6.1#lib/getEventTarget*/
define('react-dom@15.6.1#lib/getEventTarget', function (require, exports, module) {
    'use strict';
    function getEventTarget(nativeEvent) {
        var target = nativeEvent.target || nativeEvent.srcElement || window;
        if (target.correspondingUseElement) {
            target = target.correspondingUseElement;
        }
        return target.nodeType === 3 ? target.parentNode : target;
    }
    module.exports = getEventTarget;
});
/*react-dom@15.6.1#lib/isEventSupported*/
define('react-dom@15.6.1#lib/isEventSupported', function (require, exports, module) {
    'use strict';
    var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
    var useHasFeature;
    if (ExecutionEnvironment.canUseDOM) {
        useHasFeature = document.implementation && document.implementation.hasFeature && document.implementation.hasFeature('', '') !== true;
    }
    function isEventSupported(eventNameSuffix, capture) {
        if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
            return false;
        }
        var eventName = 'on' + eventNameSuffix;
        var isSupported = eventName in document;
        if (!isSupported) {
            var element = document.createElement('div');
            element.setAttribute(eventName, 'return;');
            isSupported = typeof element[eventName] === 'function';
        }
        if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
            isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
        }
        return isSupported;
    }
    module.exports = isEventSupported;
});
/*react-dom@15.6.1#lib/isTextInputElement*/
define('react-dom@15.6.1#lib/isTextInputElement', function (require, exports, module) {
    'use strict';
    var supportedInputTypes = {
        color: true,
        date: true,
        datetime: true,
        'datetime-local': true,
        email: true,
        month: true,
        number: true,
        password: true,
        range: true,
        search: true,
        tel: true,
        text: true,
        time: true,
        url: true,
        week: true
    };
    function isTextInputElement(elem) {
        var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
        if (nodeName === 'input') {
            return !!supportedInputTypes[elem.type];
        }
        if (nodeName === 'textarea') {
            return true;
        }
        return false;
    }
    module.exports = isTextInputElement;
});
/*react-dom@15.6.1#lib/ChangeEventPlugin*/
define('react-dom@15.6.1#lib/ChangeEventPlugin', function (require, exports, module) {
    'use strict';
    var EventPluginHub = require('./EventPluginHub');
    var EventPropagators = require('./EventPropagators');
    var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
    var ReactDOMComponentTree = require('./ReactDOMComponentTree');
    var ReactUpdates = require('./ReactUpdates');
    var SyntheticEvent = require('./SyntheticEvent');
    var inputValueTracking = require('./inputValueTracking');
    var getEventTarget = require('./getEventTarget');
    var isEventSupported = require('./isEventSupported');
    var isTextInputElement = require('./isTextInputElement');
    var eventTypes = {
        change: {
            phasedRegistrationNames: {
                bubbled: 'onChange',
                captured: 'onChangeCapture'
            },
            dependencies: [
                'topBlur',
                'topChange',
                'topClick',
                'topFocus',
                'topInput',
                'topKeyDown',
                'topKeyUp',
                'topSelectionChange'
            ]
        }
    };
    function createAndAccumulateChangeEvent(inst, nativeEvent, target) {
        var event = SyntheticEvent.getPooled(eventTypes.change, inst, nativeEvent, target);
        event.type = 'change';
        EventPropagators.accumulateTwoPhaseDispatches(event);
        return event;
    }
    var activeElement = null;
    var activeElementInst = null;
    function shouldUseChangeEvent(elem) {
        var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
        return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
    }
    var doesChangeEventBubble = false;
    if (ExecutionEnvironment.canUseDOM) {
        doesChangeEventBubble = isEventSupported('change') && (!document.documentMode || document.documentMode > 8);
    }
    function manualDispatchChangeEvent(nativeEvent) {
        var event = createAndAccumulateChangeEvent(activeElementInst, nativeEvent, getEventTarget(nativeEvent));
        ReactUpdates.batchedUpdates(runEventInBatch, event);
    }
    function runEventInBatch(event) {
        EventPluginHub.enqueueEvents(event);
        EventPluginHub.processEventQueue(false);
    }
    function startWatchingForChangeEventIE8(target, targetInst) {
        activeElement = target;
        activeElementInst = targetInst;
        activeElement.attachEvent('onchange', manualDispatchChangeEvent);
    }
    function stopWatchingForChangeEventIE8() {
        if (!activeElement) {
            return;
        }
        activeElement.detachEvent('onchange', manualDispatchChangeEvent);
        activeElement = null;
        activeElementInst = null;
    }
    function getInstIfValueChanged(targetInst, nativeEvent) {
        var updated = inputValueTracking.updateValueIfChanged(targetInst);
        var simulated = nativeEvent.simulated === true && ChangeEventPlugin._allowSimulatedPassThrough;
        if (updated || simulated) {
            return targetInst;
        }
    }
    function getTargetInstForChangeEvent(topLevelType, targetInst) {
        if (topLevelType === 'topChange') {
            return targetInst;
        }
    }
    function handleEventsForChangeEventIE8(topLevelType, target, targetInst) {
        if (topLevelType === 'topFocus') {
            stopWatchingForChangeEventIE8();
            startWatchingForChangeEventIE8(target, targetInst);
        } else if (topLevelType === 'topBlur') {
            stopWatchingForChangeEventIE8();
        }
    }
    var isInputEventSupported = false;
    if (ExecutionEnvironment.canUseDOM) {
        isInputEventSupported = isEventSupported('input') && (!('documentMode' in document) || document.documentMode > 9);
    }
    function startWatchingForValueChange(target, targetInst) {
        activeElement = target;
        activeElementInst = targetInst;
        activeElement.attachEvent('onpropertychange', handlePropertyChange);
    }
    function stopWatchingForValueChange() {
        if (!activeElement) {
            return;
        }
        activeElement.detachEvent('onpropertychange', handlePropertyChange);
        activeElement = null;
        activeElementInst = null;
    }
    function handlePropertyChange(nativeEvent) {
        if (nativeEvent.propertyName !== 'value') {
            return;
        }
        if (getInstIfValueChanged(activeElementInst, nativeEvent)) {
            manualDispatchChangeEvent(nativeEvent);
        }
    }
    function handleEventsForInputEventPolyfill(topLevelType, target, targetInst) {
        if (topLevelType === 'topFocus') {
            stopWatchingForValueChange();
            startWatchingForValueChange(target, targetInst);
        } else if (topLevelType === 'topBlur') {
            stopWatchingForValueChange();
        }
    }
    function getTargetInstForInputEventPolyfill(topLevelType, targetInst, nativeEvent) {
        if (topLevelType === 'topSelectionChange' || topLevelType === 'topKeyUp' || topLevelType === 'topKeyDown') {
            return getInstIfValueChanged(activeElementInst, nativeEvent);
        }
    }
    function shouldUseClickEvent(elem) {
        var nodeName = elem.nodeName;
        return nodeName && nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
    }
    function getTargetInstForClickEvent(topLevelType, targetInst, nativeEvent) {
        if (topLevelType === 'topClick') {
            return getInstIfValueChanged(targetInst, nativeEvent);
        }
    }
    function getTargetInstForInputOrChangeEvent(topLevelType, targetInst, nativeEvent) {
        if (topLevelType === 'topInput' || topLevelType === 'topChange') {
            return getInstIfValueChanged(targetInst, nativeEvent);
        }
    }
    function handleControlledInputBlur(inst, node) {
        if (inst == null) {
            return;
        }
        var state = inst._wrapperState || node._wrapperState;
        if (!state || !state.controlled || node.type !== 'number') {
            return;
        }
        var value = '' + node.value;
        if (node.getAttribute('value') !== value) {
            node.setAttribute('value', value);
        }
    }
    var ChangeEventPlugin = {
        eventTypes: eventTypes,
        _allowSimulatedPassThrough: true,
        _isInputEventSupported: isInputEventSupported,
        extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
            var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;
            var getTargetInstFunc, handleEventFunc;
            if (shouldUseChangeEvent(targetNode)) {
                if (doesChangeEventBubble) {
                    getTargetInstFunc = getTargetInstForChangeEvent;
                } else {
                    handleEventFunc = handleEventsForChangeEventIE8;
                }
            } else if (isTextInputElement(targetNode)) {
                if (isInputEventSupported) {
                    getTargetInstFunc = getTargetInstForInputOrChangeEvent;
                } else {
                    getTargetInstFunc = getTargetInstForInputEventPolyfill;
                    handleEventFunc = handleEventsForInputEventPolyfill;
                }
            } else if (shouldUseClickEvent(targetNode)) {
                getTargetInstFunc = getTargetInstForClickEvent;
            }
            if (getTargetInstFunc) {
                var inst = getTargetInstFunc(topLevelType, targetInst, nativeEvent);
                if (inst) {
                    var event = createAndAccumulateChangeEvent(inst, nativeEvent, nativeEventTarget);
                    return event;
                }
            }
            if (handleEventFunc) {
                handleEventFunc(topLevelType, targetNode, targetInst);
            }
            if (topLevelType === 'topBlur') {
                handleControlledInputBlur(targetInst, targetNode);
            }
        }
    };
    module.exports = ChangeEventPlugin;
});
/*react-dom@15.6.1#lib/DefaultEventPluginOrder*/
define('react-dom@15.6.1#lib/DefaultEventPluginOrder', function (require, exports, module) {
    'use strict';
    var DefaultEventPluginOrder = [
        'ResponderEventPlugin',
        'SimpleEventPlugin',
        'TapEventPlugin',
        'EnterLeaveEventPlugin',
        'ChangeEventPlugin',
        'SelectEventPlugin',
        'BeforeInputEventPlugin'
    ];
    module.exports = DefaultEventPluginOrder;
});
/*react-dom@15.6.1#lib/SyntheticUIEvent*/
define('react-dom@15.6.1#lib/SyntheticUIEvent', function (require, exports, module) {
    'use strict';
    var SyntheticEvent = require('./SyntheticEvent');
    var getEventTarget = require('./getEventTarget');
    var UIEventInterface = {
        view: function (event) {
            if (event.view) {
                return event.view;
            }
            var target = getEventTarget(event);
            if (target.window === target) {
                return target;
            }
            var doc = target.ownerDocument;
            if (doc) {
                return doc.defaultView || doc.parentWindow;
            } else {
                return window;
            }
        },
        detail: function (event) {
            return event.detail || 0;
        }
    };
    function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
        return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
    }
    SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);
    module.exports = SyntheticUIEvent;
});
/*react-dom@15.6.1#lib/ViewportMetrics*/
define('react-dom@15.6.1#lib/ViewportMetrics', function (require, exports, module) {
    'use strict';
    var ViewportMetrics = {
        currentScrollLeft: 0,
        currentScrollTop: 0,
        refreshScrollValues: function (scrollPosition) {
            ViewportMetrics.currentScrollLeft = scrollPosition.x;
            ViewportMetrics.currentScrollTop = scrollPosition.y;
        }
    };
    module.exports = ViewportMetrics;
});
/*react-dom@15.6.1#lib/getEventModifierState*/
define('react-dom@15.6.1#lib/getEventModifierState', function (require, exports, module) {
    'use strict';
    var modifierKeyToProp = {
        Alt: 'altKey',
        Control: 'ctrlKey',
        Meta: 'metaKey',
        Shift: 'shiftKey'
    };
    function modifierStateGetter(keyArg) {
        var syntheticEvent = this;
        var nativeEvent = syntheticEvent.nativeEvent;
        if (nativeEvent.getModifierState) {
            return nativeEvent.getModifierState(keyArg);
        }
        var keyProp = modifierKeyToProp[keyArg];
        return keyProp ? !!nativeEvent[keyProp] : false;
    }
    function getEventModifierState(nativeEvent) {
        return modifierStateGetter;
    }
    module.exports = getEventModifierState;
});
/*react-dom@15.6.1#lib/SyntheticMouseEvent*/
define('react-dom@15.6.1#lib/SyntheticMouseEvent', function (require, exports, module) {
    'use strict';
    var SyntheticUIEvent = require('./SyntheticUIEvent');
    var ViewportMetrics = require('./ViewportMetrics');
    var getEventModifierState = require('./getEventModifierState');
    var MouseEventInterface = {
        screenX: null,
        screenY: null,
        clientX: null,
        clientY: null,
        ctrlKey: null,
        shiftKey: null,
        altKey: null,
        metaKey: null,
        getModifierState: getEventModifierState,
        button: function (event) {
            var button = event.button;
            if ('which' in event) {
                return button;
            }
            return button === 2 ? 2 : button === 4 ? 1 : 0;
        },
        buttons: null,
        relatedTarget: function (event) {
            return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
        },
        pageX: function (event) {
            return 'pageX' in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
        },
        pageY: function (event) {
            return 'pageY' in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
        }
    };
    function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
        return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
    }
    SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);
    module.exports = SyntheticMouseEvent;
});
/*react-dom@15.6.1#lib/EnterLeaveEventPlugin*/
define('react-dom@15.6.1#lib/EnterLeaveEventPlugin', function (require, exports, module) {
    'use strict';
    var EventPropagators = require('./EventPropagators');
    var ReactDOMComponentTree = require('./ReactDOMComponentTree');
    var SyntheticMouseEvent = require('./SyntheticMouseEvent');
    var eventTypes = {
        mouseEnter: {
            registrationName: 'onMouseEnter',
            dependencies: [
                'topMouseOut',
                'topMouseOver'
            ]
        },
        mouseLeave: {
            registrationName: 'onMouseLeave',
            dependencies: [
                'topMouseOut',
                'topMouseOver'
            ]
        }
    };
    var EnterLeaveEventPlugin = {
        eventTypes: eventTypes,
        extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
            if (topLevelType === 'topMouseOver' && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
                return null;
            }
            if (topLevelType !== 'topMouseOut' && topLevelType !== 'topMouseOver') {
                return null;
            }
            var win;
            if (nativeEventTarget.window === nativeEventTarget) {
                win = nativeEventTarget;
            } else {
                var doc = nativeEventTarget.ownerDocument;
                if (doc) {
                    win = doc.defaultView || doc.parentWindow;
                } else {
                    win = window;
                }
            }
            var from;
            var to;
            if (topLevelType === 'topMouseOut') {
                from = targetInst;
                var related = nativeEvent.relatedTarget || nativeEvent.toElement;
                to = related ? ReactDOMComponentTree.getClosestInstanceFromNode(related) : null;
            } else {
                from = null;
                to = targetInst;
            }
            if (from === to) {
                return null;
            }
            var fromNode = from == null ? win : ReactDOMComponentTree.getNodeFromInstance(from);
            var toNode = to == null ? win : ReactDOMComponentTree.getNodeFromInstance(to);
            var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, from, nativeEvent, nativeEventTarget);
            leave.type = 'mouseleave';
            leave.target = fromNode;
            leave.relatedTarget = toNode;
            var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, to, nativeEvent, nativeEventTarget);
            enter.type = 'mouseenter';
            enter.target = toNode;
            enter.relatedTarget = fromNode;
            EventPropagators.accumulateEnterLeaveDispatches(leave, enter, from, to);
            return [
                leave,
                enter
            ];
        }
    };
    module.exports = EnterLeaveEventPlugin;
});
/*react-dom@15.6.1#lib/HTMLDOMPropertyConfig*/
define('react-dom@15.6.1#lib/HTMLDOMPropertyConfig', function (require, exports, module) {
    'use strict';
    var DOMProperty = require('./DOMProperty');
    var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
    var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
    var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
    var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
    var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;
    var HTMLDOMPropertyConfig = {
        isCustomAttribute: RegExp.prototype.test.bind(new RegExp('^(data|aria)-[' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$')),
        Properties: {
            accept: 0,
            acceptCharset: 0,
            accessKey: 0,
            action: 0,
            allowFullScreen: HAS_BOOLEAN_VALUE,
            allowTransparency: 0,
            alt: 0,
            as: 0,
            async: HAS_BOOLEAN_VALUE,
            autoComplete: 0,
            autoPlay: HAS_BOOLEAN_VALUE,
            capture: HAS_BOOLEAN_VALUE,
            cellPadding: 0,
            cellSpacing: 0,
            charSet: 0,
            challenge: 0,
            checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
            cite: 0,
            classID: 0,
            className: 0,
            cols: HAS_POSITIVE_NUMERIC_VALUE,
            colSpan: 0,
            content: 0,
            contentEditable: 0,
            contextMenu: 0,
            controls: HAS_BOOLEAN_VALUE,
            coords: 0,
            crossOrigin: 0,
            data: 0,
            dateTime: 0,
            'default': HAS_BOOLEAN_VALUE,
            defer: HAS_BOOLEAN_VALUE,
            dir: 0,
            disabled: HAS_BOOLEAN_VALUE,
            download: HAS_OVERLOADED_BOOLEAN_VALUE,
            draggable: 0,
            encType: 0,
            form: 0,
            formAction: 0,
            formEncType: 0,
            formMethod: 0,
            formNoValidate: HAS_BOOLEAN_VALUE,
            formTarget: 0,
            frameBorder: 0,
            headers: 0,
            height: 0,
            hidden: HAS_BOOLEAN_VALUE,
            high: 0,
            href: 0,
            hrefLang: 0,
            htmlFor: 0,
            httpEquiv: 0,
            icon: 0,
            id: 0,
            inputMode: 0,
            integrity: 0,
            is: 0,
            keyParams: 0,
            keyType: 0,
            kind: 0,
            label: 0,
            lang: 0,
            list: 0,
            loop: HAS_BOOLEAN_VALUE,
            low: 0,
            manifest: 0,
            marginHeight: 0,
            marginWidth: 0,
            max: 0,
            maxLength: 0,
            media: 0,
            mediaGroup: 0,
            method: 0,
            min: 0,
            minLength: 0,
            multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
            muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
            name: 0,
            nonce: 0,
            noValidate: HAS_BOOLEAN_VALUE,
            open: HAS_BOOLEAN_VALUE,
            optimum: 0,
            pattern: 0,
            placeholder: 0,
            playsInline: HAS_BOOLEAN_VALUE,
            poster: 0,
            preload: 0,
            profile: 0,
            radioGroup: 0,
            readOnly: HAS_BOOLEAN_VALUE,
            referrerPolicy: 0,
            rel: 0,
            required: HAS_BOOLEAN_VALUE,
            reversed: HAS_BOOLEAN_VALUE,
            role: 0,
            rows: HAS_POSITIVE_NUMERIC_VALUE,
            rowSpan: HAS_NUMERIC_VALUE,
            sandbox: 0,
            scope: 0,
            scoped: HAS_BOOLEAN_VALUE,
            scrolling: 0,
            seamless: HAS_BOOLEAN_VALUE,
            selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
            shape: 0,
            size: HAS_POSITIVE_NUMERIC_VALUE,
            sizes: 0,
            span: HAS_POSITIVE_NUMERIC_VALUE,
            spellCheck: 0,
            src: 0,
            srcDoc: 0,
            srcLang: 0,
            srcSet: 0,
            start: HAS_NUMERIC_VALUE,
            step: 0,
            style: 0,
            summary: 0,
            tabIndex: 0,
            target: 0,
            title: 0,
            type: 0,
            useMap: 0,
            value: 0,
            width: 0,
            wmode: 0,
            wrap: 0,
            about: 0,
            datatype: 0,
            inlist: 0,
            prefix: 0,
            property: 0,
            resource: 0,
            'typeof': 0,
            vocab: 0,
            autoCapitalize: 0,
            autoCorrect: 0,
            autoSave: 0,
            color: 0,
            itemProp: 0,
            itemScope: HAS_BOOLEAN_VALUE,
            itemType: 0,
            itemID: 0,
            itemRef: 0,
            results: 0,
            security: 0,
            unselectable: 0
        },
        DOMAttributeNames: {
            acceptCharset: 'accept-charset',
            className: 'class',
            htmlFor: 'for',
            httpEquiv: 'http-equiv'
        },
        DOMPropertyNames: {},
        DOMMutationMethods: {
            value: function (node, value) {
                if (value == null) {
                    return node.removeAttribute('value');
                }
                if (node.type !== 'number' || node.hasAttribute('value') === false) {
                    node.setAttribute('value', '' + value);
                } else if (node.validity && !node.validity.badInput && node.ownerDocument.activeElement !== node) {
                    node.setAttribute('value', '' + value);
                }
            }
        }
    };
    module.exports = HTMLDOMPropertyConfig;
});
/*react-dom@15.6.1#lib/DOMNamespaces*/
define('react-dom@15.6.1#lib/DOMNamespaces', function (require, exports, module) {
    'use strict';
    var DOMNamespaces = {
        html: 'http://www.w3.org/1999/xhtml',
        mathml: 'http://www.w3.org/1998/Math/MathML',
        svg: 'http://www.w3.org/2000/svg'
    };
    module.exports = DOMNamespaces;
});
/*react-dom@15.6.1#lib/createMicrosoftUnsafeLocalFunction*/
define('react-dom@15.6.1#lib/createMicrosoftUnsafeLocalFunction', function (require, exports, module) {
    (function (global) {
        'use strict';
        var createMicrosoftUnsafeLocalFunction = function (func) {
            if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
                return function (arg0, arg1, arg2, arg3) {
                    MSApp.execUnsafeLocalFunction(function () {
                        return func(arg0, arg1, arg2, arg3);
                    });
                };
            } else {
                return func;
            }
        };
        module.exports = createMicrosoftUnsafeLocalFunction;
    }(function () {
        return this;
    }()));
});
/*react-dom@15.6.1#lib/setInnerHTML*/
define('react-dom@15.6.1#lib/setInnerHTML', function (require, exports, module) {
    'use strict';
    var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
    var DOMNamespaces = require('./DOMNamespaces');
    var WHITESPACE_TEST = /^[ \r\n\t\f]/;
    var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;
    var createMicrosoftUnsafeLocalFunction = require('./createMicrosoftUnsafeLocalFunction');
    var reusableSVGContainer;
    var setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {
        if (node.namespaceURI === DOMNamespaces.svg && !('innerHTML' in node)) {
            reusableSVGContainer = reusableSVGContainer || document.createElement('div');
            reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';
            var svgNode = reusableSVGContainer.firstChild;
            while (svgNode.firstChild) {
                node.appendChild(svgNode.firstChild);
            }
        } else {
            node.innerHTML = html;
        }
    });
    if (ExecutionEnvironment.canUseDOM) {
        var testElement = document.createElement('div');
        testElement.innerHTML = ' ';
        if (testElement.innerHTML === '') {
            setInnerHTML = function (node, html) {
                if (node.parentNode) {
                    node.parentNode.replaceChild(node, node);
                }
                if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {
                    node.innerHTML = String.fromCharCode(65279) + html;
                    var textNode = node.firstChild;
                    if (textNode.data.length === 1) {
                        node.removeChild(textNode);
                    } else {
                        textNode.deleteData(0, 1);
                    }
                } else {
                    node.innerHTML = html;
                }
            };
        }
        testElement = null;
    }
    module.exports = setInnerHTML;
});
/*react-dom@15.6.1#lib/escapeTextContentForBrowser*/
define('react-dom@15.6.1#lib/escapeTextContentForBrowser', function (require, exports, module) {
    'use strict';
    var matchHtmlRegExp = /["'&<>]/;
    function escapeHtml(string) {
        var str = '' + string;
        var match = matchHtmlRegExp.exec(str);
        if (!match) {
            return str;
        }
        var escape;
        var html = '';
        var index = 0;
        var lastIndex = 0;
        for (index = match.index; index < str.length; index++) {
            switch (str.charCodeAt(index)) {
            case 34:
                escape = '&quot;';
                break;
            case 38:
                escape = '&amp;';
                break;
            case 39:
                escape = '&#x27;';
                break;
            case 60:
                escape = '&lt;';
                break;
            case 62:
                escape = '&gt;';
                break;
            default:
                continue;
            }
            if (lastIndex !== index) {
                html += str.substring(lastIndex, index);
            }
            lastIndex = index + 1;
            html += escape;
        }
        return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
    }
    function escapeTextContentForBrowser(text) {
        if (typeof text === 'boolean' || typeof text === 'number') {
            return '' + text;
        }
        return escapeHtml(text);
    }
    module.exports = escapeTextContentForBrowser;
});
/*react-dom@15.6.1#lib/setTextContent*/
define('react-dom@15.6.1#lib/setTextContent', function (require, exports, module) {
    'use strict';
    var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
    var escapeTextContentForBrowser = require('./escapeTextContentForBrowser');
    var setInnerHTML = require('./setInnerHTML');
    var setTextContent = function (node, text) {
        if (text) {
            var firstChild = node.firstChild;
            if (firstChild && firstChild === node.lastChild && firstChild.nodeType === 3) {
                firstChild.nodeValue = text;
                return;
            }
        }
        node.textContent = text;
    };
    if (ExecutionEnvironment.canUseDOM) {
        if (!('textContent' in document.documentElement)) {
            setTextContent = function (node, text) {
                if (node.nodeType === 3) {
                    node.nodeValue = text;
                    return;
                }
                setInnerHTML(node, escapeTextContentForBrowser(text));
            };
        }
    }
    module.exports = setTextContent;
});
/*react-dom@15.6.1#lib/DOMLazyTree*/
define('react-dom@15.6.1#lib/DOMLazyTree', function (require, exports, module) {
    'use strict';
    var DOMNamespaces = require('./DOMNamespaces');
    var setInnerHTML = require('./setInnerHTML');
    var createMicrosoftUnsafeLocalFunction = require('./createMicrosoftUnsafeLocalFunction');
    var setTextContent = require('./setTextContent');
    var ELEMENT_NODE_TYPE = 1;
    var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
    var enableLazy = typeof document !== 'undefined' && typeof document.documentMode === 'number' || typeof navigator !== 'undefined' && typeof navigator.userAgent === 'string' && /\bEdge\/\d/.test(navigator.userAgent);
    function insertTreeChildren(tree) {
        if (!enableLazy) {
            return;
        }
        var node = tree.node;
        var children = tree.children;
        if (children.length) {
            for (var i = 0; i < children.length; i++) {
                insertTreeBefore(node, children[i], null);
            }
        } else if (tree.html != null) {
            setInnerHTML(node, tree.html);
        } else if (tree.text != null) {
            setTextContent(node, tree.text);
        }
    }
    var insertTreeBefore = createMicrosoftUnsafeLocalFunction(function (parentNode, tree, referenceNode) {
        if (tree.node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE || tree.node.nodeType === ELEMENT_NODE_TYPE && tree.node.nodeName.toLowerCase() === 'object' && (tree.node.namespaceURI == null || tree.node.namespaceURI === DOMNamespaces.html)) {
            insertTreeChildren(tree);
            parentNode.insertBefore(tree.node, referenceNode);
        } else {
            parentNode.insertBefore(tree.node, referenceNode);
            insertTreeChildren(tree);
        }
    });
    function replaceChildWithTree(oldNode, newTree) {
        oldNode.parentNode.replaceChild(newTree.node, oldNode);
        insertTreeChildren(newTree);
    }
    function queueChild(parentTree, childTree) {
        if (enableLazy) {
            parentTree.children.push(childTree);
        } else {
            parentTree.node.appendChild(childTree.node);
        }
    }
    function queueHTML(tree, html) {
        if (enableLazy) {
            tree.html = html;
        } else {
            setInnerHTML(tree.node, html);
        }
    }
    function queueText(tree, text) {
        if (enableLazy) {
            tree.text = text;
        } else {
            setTextContent(tree.node, text);
        }
    }
    function toString() {
        return this.node.nodeName;
    }
    function DOMLazyTree(node) {
        return {
            node: node,
            children: [],
            html: null,
            text: null,
            toString: toString
        };
    }
    DOMLazyTree.insertTreeBefore = insertTreeBefore;
    DOMLazyTree.replaceChildWithTree = replaceChildWithTree;
    DOMLazyTree.queueChild = queueChild;
    DOMLazyTree.queueHTML = queueHTML;
    DOMLazyTree.queueText = queueText;
    module.exports = DOMLazyTree;
});
/*fbjs@0.8.12#lib/createArrayFromMixed*/
define('fbjs@0.8.12#lib/createArrayFromMixed', function (require, exports, module) {
    'use strict';
    var invariant = require('./invariant');
    function toArray(obj) {
        var length = obj.length;
        !(!Array.isArray(obj) && (typeof obj === 'object' || typeof obj === 'function')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Array-like object expected') : invariant(false) : void 0;
        !(typeof length === 'number') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object needs a length property') : invariant(false) : void 0;
        !(length === 0 || length - 1 in obj) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object should have keys for indices') : invariant(false) : void 0;
        !(typeof obj.callee !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object can\'t be `arguments`. Use rest params ' + '(function(...args) {}) or Array.from() instead.') : invariant(false) : void 0;
        if (obj.hasOwnProperty) {
            try {
                return Array.prototype.slice.call(obj);
            } catch (e) {
            }
        }
        var ret = Array(length);
        for (var ii = 0; ii < length; ii++) {
            ret[ii] = obj[ii];
        }
        return ret;
    }
    function hasArrayNature(obj) {
        return !!obj && (typeof obj == 'object' || typeof obj == 'function') && 'length' in obj && !('setInterval' in obj) && typeof obj.nodeType != 'number' && (Array.isArray(obj) || 'callee' in obj || 'item' in obj);
    }
    function createArrayFromMixed(obj) {
        if (!hasArrayNature(obj)) {
            return [obj];
        } else if (Array.isArray(obj)) {
            return obj.slice();
        } else {
            return toArray(obj);
        }
    }
    module.exports = createArrayFromMixed;
});
/*fbjs@0.8.12#lib/getMarkupWrap*/
define('fbjs@0.8.12#lib/getMarkupWrap', function (require, exports, module) {
    'use strict';
    var ExecutionEnvironment = require('./ExecutionEnvironment');
    var invariant = require('./invariant');
    var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
    var shouldWrap = {};
    var selectWrap = [
        1,
        '<select multiple="true">',
        '</select>'
    ];
    var tableWrap = [
        1,
        '<table>',
        '</table>'
    ];
    var trWrap = [
        3,
        '<table><tbody><tr>',
        '</tr></tbody></table>'
    ];
    var svgWrap = [
        1,
        '<svg xmlns="http://www.w3.org/2000/svg">',
        '</svg>'
    ];
    var markupWrap = {
        '*': [
            1,
            '?<div>',
            '</div>'
        ],
        'area': [
            1,
            '<map>',
            '</map>'
        ],
        'col': [
            2,
            '<table><tbody></tbody><colgroup>',
            '</colgroup></table>'
        ],
        'legend': [
            1,
            '<fieldset>',
            '</fieldset>'
        ],
        'param': [
            1,
            '<object>',
            '</object>'
        ],
        'tr': [
            2,
            '<table><tbody>',
            '</tbody></table>'
        ],
        'optgroup': selectWrap,
        'option': selectWrap,
        'caption': tableWrap,
        'colgroup': tableWrap,
        'tbody': tableWrap,
        'tfoot': tableWrap,
        'thead': tableWrap,
        'td': trWrap,
        'th': trWrap
    };
    var svgElements = [
        'circle',
        'clipPath',
        'defs',
        'ellipse',
        'g',
        'image',
        'line',
        'linearGradient',
        'mask',
        'path',
        'pattern',
        'polygon',
        'polyline',
        'radialGradient',
        'rect',
        'stop',
        'text',
        'tspan'
    ];
    svgElements.forEach(function (nodeName) {
        markupWrap[nodeName] = svgWrap;
        shouldWrap[nodeName] = true;
    });
    function getMarkupWrap(nodeName) {
        !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Markup wrapping node not initialized') : invariant(false) : void 0;
        if (!markupWrap.hasOwnProperty(nodeName)) {
            nodeName = '*';
        }
        if (!shouldWrap.hasOwnProperty(nodeName)) {
            if (nodeName === '*') {
                dummyNode.innerHTML = '<link />';
            } else {
                dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
            }
            shouldWrap[nodeName] = !dummyNode.firstChild;
        }
        return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
    }
    module.exports = getMarkupWrap;
});
/*fbjs@0.8.12#lib/createNodesFromMarkup*/
define('fbjs@0.8.12#lib/createNodesFromMarkup', function (require, exports, module) {
    'use strict';
    var ExecutionEnvironment = require('./ExecutionEnvironment');
    var createArrayFromMixed = require('./createArrayFromMixed');
    var getMarkupWrap = require('./getMarkupWrap');
    var invariant = require('./invariant');
    var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
    var nodeNamePattern = /^\s*<(\w+)/;
    function getNodeName(markup) {
        var nodeNameMatch = markup.match(nodeNamePattern);
        return nodeNameMatch && nodeNameMatch[1].toLowerCase();
    }
    function createNodesFromMarkup(markup, handleScript) {
        var node = dummyNode;
        !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup dummy not initialized') : invariant(false) : void 0;
        var nodeName = getNodeName(markup);
        var wrap = nodeName && getMarkupWrap(nodeName);
        if (wrap) {
            node.innerHTML = wrap[1] + markup + wrap[2];
            var wrapDepth = wrap[0];
            while (wrapDepth--) {
                node = node.lastChild;
            }
        } else {
            node.innerHTML = markup;
        }
        var scripts = node.getElementsByTagName('script');
        if (scripts.length) {
            !handleScript ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup(...): Unexpected <script> element rendered.') : invariant(false) : void 0;
            createArrayFromMixed(scripts).forEach(handleScript);
        }
        var nodes = Array.from(node.childNodes);
        while (node.lastChild) {
            node.removeChild(node.lastChild);
        }
        return nodes;
    }
    module.exports = createNodesFromMarkup;
});
/*react-dom@15.6.1#lib/Danger*/
define('react-dom@15.6.1#lib/Danger', function (require, exports, module) {
    (function (global) {
        'use strict';
        var _prodInvariant = require('./reactProdInvariant');
        var DOMLazyTree = require('./DOMLazyTree');
        var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
        var createNodesFromMarkup = require('fbjs/lib/createNodesFromMarkup');
        var emptyFunction = require('fbjs/lib/emptyFunction');
        var invariant = require('fbjs/lib/invariant');
        var Danger = {
            dangerouslyReplaceNodeWithMarkup: function (oldChild, markup) {
                !ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a worker thread. Make sure `window` and `document` are available globally before requiring React when unit testing or use ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('56') : void 0;
                !markup ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : _prodInvariant('57') : void 0;
                !(oldChild.nodeName !== 'HTML') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the <html> node. This is because browser quirks make this unreliable and/or slow. If you want to render to the root you must use server rendering. See ReactDOMServer.renderToString().') : _prodInvariant('58') : void 0;
                if (typeof markup === 'string') {
                    var newChild = createNodesFromMarkup(markup, emptyFunction)[0];
                    oldChild.parentNode.replaceChild(newChild, oldChild);
                } else {
                    DOMLazyTree.replaceChildWithTree(oldChild, markup);
                }
            }
        };
        module.exports = Danger;
    }(function () {
        return this;
    }()));
});
/*react-dom@15.6.1#lib/DOMChildrenOperations*/
define('react-dom@15.6.1#lib/DOMChildrenOperations', function (require, exports, module) {
    'use strict';
    var DOMLazyTree = require('./DOMLazyTree');
    var Danger = require('./Danger');
    var ReactDOMComponentTree = require('./ReactDOMComponentTree');
    var ReactInstrumentation = require('./ReactInstrumentation');
    var createMicrosoftUnsafeLocalFunction = require('./createMicrosoftUnsafeLocalFunction');
    var setInnerHTML = require('./setInnerHTML');
    var setTextContent = require('./setTextContent');
    function getNodeAfter(parentNode, node) {
        if (Array.isArray(node)) {
            node = node[1];
        }
        return node ? node.nextSibling : parentNode.firstChild;
    }
    var insertChildAt = createMicrosoftUnsafeLocalFunction(function (parentNode, childNode, referenceNode) {
        parentNode.insertBefore(childNode, referenceNode);
    });
    function insertLazyTreeChildAt(parentNode, childTree, referenceNode) {
        DOMLazyTree.insertTreeBefore(parentNode, childTree, referenceNode);
    }
    function moveChild(parentNode, childNode, referenceNode) {
        if (Array.isArray(childNode)) {
            moveDelimitedText(parentNode, childNode[0], childNode[1], referenceNode);
        } else {
            insertChildAt(parentNode, childNode, referenceNode);
        }
    }
    function removeChild(parentNode, childNode) {
        if (Array.isArray(childNode)) {
            var closingComment = childNode[1];
            childNode = childNode[0];
            removeDelimitedText(parentNode, childNode, closingComment);
            parentNode.removeChild(closingComment);
        }
        parentNode.removeChild(childNode);
    }
    function moveDelimitedText(parentNode, openingComment, closingComment, referenceNode) {
        var node = openingComment;
        while (true) {
            var nextNode = node.nextSibling;
            insertChildAt(parentNode, node, referenceNode);
            if (node === closingComment) {
                break;
            }
            node = nextNode;
        }
    }
    function removeDelimitedText(parentNode, startNode, closingComment) {
        while (true) {
            var node = startNode.nextSibling;
            if (node === closingComment) {
                break;
            } else {
                parentNode.removeChild(node);
            }
        }
    }
    function replaceDelimitedText(openingComment, closingComment, stringText) {
        var parentNode = openingComment.parentNode;
        var nodeAfterComment = openingComment.nextSibling;
        if (nodeAfterComment === closingComment) {
            if (stringText) {
                insertChildAt(parentNode, document.createTextNode(stringText), nodeAfterComment);
            }
        } else {
            if (stringText) {
                setTextContent(nodeAfterComment, stringText);
                removeDelimitedText(parentNode, nodeAfterComment, closingComment);
            } else {
                removeDelimitedText(parentNode, openingComment, closingComment);
            }
        }
        if (process.env.NODE_ENV !== 'production') {
            ReactInstrumentation.debugTool.onHostOperation({
                instanceID: ReactDOMComponentTree.getInstanceFromNode(openingComment)._debugID,
                type: 'replace text',
                payload: stringText
            });
        }
    }
    var dangerouslyReplaceNodeWithMarkup = Danger.dangerouslyReplaceNodeWithMarkup;
    if (process.env.NODE_ENV !== 'production') {
        dangerouslyReplaceNodeWithMarkup = function (oldChild, markup, prevInstance) {
            Danger.dangerouslyReplaceNodeWithMarkup(oldChild, markup);
            if (prevInstance._debugID !== 0) {
                ReactInstrumentation.debugTool.onHostOperation({
                    instanceID: prevInstance._debugID,
                    type: 'replace with',
                    payload: markup.toString()
                });
            } else {
                var nextInstance = ReactDOMComponentTree.getInstanceFromNode(markup.node);
                if (nextInstance._debugID !== 0) {
                    ReactInstrumentation.debugTool.onHostOperation({
                        instanceID: nextInstance._debugID,
                        type: 'mount',
                        payload: markup.toString()
                    });
                }
            }
        };
    }
    var DOMChildrenOperations = {
        dangerouslyReplaceNodeWithMarkup: dangerouslyReplaceNodeWithMarkup,
        replaceDelimitedText: replaceDelimitedText,
        processUpdates: function (parentNode, updates) {
            if (process.env.NODE_ENV !== 'production') {
                var parentNodeDebugID = ReactDOMComponentTree.getInstanceFromNode(parentNode)._debugID;
            }
            for (var k = 0; k < updates.length; k++) {
                var update = updates[k];
                switch (update.type) {
                case 'INSERT_MARKUP':
                    insertLazyTreeChildAt(parentNode, update.content, getNodeAfter(parentNode, update.afterNode));
                    if (process.env.NODE_ENV !== 'production') {
                        ReactInstrumentation.debugTool.onHostOperation({
                            instanceID: parentNodeDebugID,
                            type: 'insert child',
                            payload: {
                                toIndex: update.toIndex,
                                content: update.content.toString()
                            }
                        });
                    }
                    break;
                case 'MOVE_EXISTING':
                    moveChild(parentNode, update.fromNode, getNodeAfter(parentNode, update.afterNode));
                    if (process.env.NODE_ENV !== 'production') {
                        ReactInstrumentation.debugTool.onHostOperation({
                            instanceID: parentNodeDebugID,
                            type: 'move child',
                            payload: {
                                fromIndex: update.fromIndex,
                                toIndex: update.toIndex
                            }
                        });
                    }
                    break;
                case 'SET_MARKUP':
                    setInnerHTML(parentNode, update.content);
                    if (process.env.NODE_ENV !== 'production') {
                        ReactInstrumentation.debugTool.onHostOperation({
                            instanceID: parentNodeDebugID,
                            type: 'replace children',
                            payload: update.content.toString()
                        });
                    }
                    break;
                case 'TEXT_CONTENT':
                    setTextContent(parentNode, update.content);
                    if (process.env.NODE_ENV !== 'production') {
                        ReactInstrumentation.debugTool.onHostOperation({
                            instanceID: parentNodeDebugID,
                            type: 'replace text',
                            payload: update.content.toString()
                        });
                    }
                    break;
                case 'REMOVE_NODE':
                    removeChild(parentNode, update.fromNode);
                    if (process.env.NODE_ENV !== 'production') {
                        ReactInstrumentation.debugTool.onHostOperation({
                            instanceID: parentNodeDebugID,
                            type: 'remove child',
                            payload: { fromIndex: update.fromIndex }
                        });
                    }
                    break;
                }
            }
        }
    };
    module.exports = DOMChildrenOperations;
});
/*react-dom@15.6.1#lib/ReactDOMIDOperations*/
define('react-dom@15.6.1#lib/ReactDOMIDOperations', function (require, exports, module) {
    'use strict';
    var DOMChildrenOperations = require('./DOMChildrenOperations');
    var ReactDOMComponentTree = require('./ReactDOMComponentTree');
    var ReactDOMIDOperations = {
        dangerouslyProcessChildrenUpdates: function (parentInst, updates) {
            var node = ReactDOMComponentTree.getNodeFromInstance(parentInst);
            DOMChildrenOperations.processUpdates(node, updates);
        }
    };
    module.exports = ReactDOMIDOperations;
});
/*react-dom@15.6.1#lib/ReactComponentBrowserEnvironment*/
define('react-dom@15.6.1#lib/ReactComponentBrowserEnvironment', function (require, exports, module) {
    'use strict';
    var DOMChildrenOperations = require('./DOMChildrenOperations');
    var ReactDOMIDOperations = require('./ReactDOMIDOperations');
    var ReactComponentBrowserEnvironment = {
        processChildrenUpdates: ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,
        replaceNodeWithMarkup: DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup
    };
    module.exports = ReactComponentBrowserEnvironment;
});
/*fbjs@0.8.12#lib/focusNode*/
define('fbjs@0.8.12#lib/focusNode', function (require, exports, module) {
    'use strict';
    function focusNode(node) {
        try {
            node.focus();
        } catch (e) {
        }
    }
    module.exports = focusNode;
});
/*react-dom@15.6.1#lib/AutoFocusUtils*/
define('react-dom@15.6.1#lib/AutoFocusUtils', function (require, exports, module) {
    'use strict';
    var ReactDOMComponentTree = require('./ReactDOMComponentTree');
    var focusNode = require('fbjs/lib/focusNode');
    var AutoFocusUtils = {
        focusDOMComponent: function () {
            focusNode(ReactDOMComponentTree.getNodeFromInstance(this));
        }
    };
    module.exports = AutoFocusUtils;
});
/*react-dom@15.6.1#lib/CSSProperty*/
define('react-dom@15.6.1#lib/CSSProperty', function (require, exports, module) {
    'use strict';
    var isUnitlessNumber = {
        animationIterationCount: true,
        borderImageOutset: true,
        borderImageSlice: true,
        borderImageWidth: true,
        boxFlex: true,
        boxFlexGroup: true,
        boxOrdinalGroup: true,
        columnCount: true,
        flex: true,
        flexGrow: true,
        flexPositive: true,
        flexShrink: true,
        flexNegative: true,
        flexOrder: true,
        gridRow: true,
        gridRowEnd: true,
        gridRowSpan: true,
        gridRowStart: true,
        gridColumn: true,
        gridColumnEnd: true,
        gridColumnSpan: true,
        gridColumnStart: true,
        fontWeight: true,
        lineClamp: true,
        lineHeight: true,
        opacity: true,
        order: true,
        orphans: true,
        tabSize: true,
        widows: true,
        zIndex: true,
        zoom: true,
        fillOpacity: true,
        floodOpacity: true,
        stopOpacity: true,
        strokeDasharray: true,
        strokeDashoffset: true,
        strokeMiterlimit: true,
        strokeOpacity: true,
        strokeWidth: true
    };
    function prefixKey(prefix, key) {
        return prefix + key.charAt(0).toUpperCase() + key.substring(1);
    }
    var prefixes = [
        'Webkit',
        'ms',
        'Moz',
        'O'
    ];
    Object.keys(isUnitlessNumber).forEach(function (prop) {
        prefixes.forEach(function (prefix) {
            isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
        });
    });
    var shorthandPropertyExpansions = {
        background: {
            backgroundAttachment: true,
            backgroundColor: true,
            backgroundImage: true,
            backgroundPositionX: true,
            backgroundPositionY: true,
            backgroundRepeat: true
        },
        backgroundPosition: {
            backgroundPositionX: true,
            backgroundPositionY: true
        },
        border: {
            borderWidth: true,
            borderStyle: true,
            borderColor: true
        },
        borderBottom: {
            borderBottomWidth: true,
            borderBottomStyle: true,
            borderBottomColor: true
        },
        borderLeft: {
            borderLeftWidth: true,
            borderLeftStyle: true,
            borderLeftColor: true
        },
        borderRight: {
            borderRightWidth: true,
            borderRightStyle: true,
            borderRightColor: true
        },
        borderTop: {
            borderTopWidth: true,
            borderTopStyle: true,
            borderTopColor: true
        },
        font: {
            fontStyle: true,
            fontVariant: true,
            fontWeight: true,
            fontSize: true,
            lineHeight: true,
            fontFamily: true
        },
        outline: {
            outlineWidth: true,
            outlineStyle: true,
            outlineColor: true
        }
    };
    var CSSProperty = {
        isUnitlessNumber: isUnitlessNumber,
        shorthandPropertyExpansions: shorthandPropertyExpansions
    };
    module.exports = CSSProperty;
});
/*fbjs@0.8.12#lib/camelize*/
define('fbjs@0.8.12#lib/camelize', function (require, exports, module) {
    'use strict';
    var _hyphenPattern = /-(.)/g;
    function camelize(string) {
        return string.replace(_hyphenPattern, function (_, character) {
            return character.toUpperCase();
        });
    }
    module.exports = camelize;
});
/*fbjs@0.8.12#lib/camelizeStyleName*/
define('fbjs@0.8.12#lib/camelizeStyleName', function (require, exports, module) {
    'use strict';
    var camelize = require('./camelize');
    var msPattern = /^-ms-/;
    function camelizeStyleName(string) {
        return camelize(string.replace(msPattern, 'ms-'));
    }
    module.exports = camelizeStyleName;
});
/*react-dom@15.6.1#lib/dangerousStyleValue*/
define('react-dom@15.6.1#lib/dangerousStyleValue', function (require, exports, module) {
    'use strict';
    var CSSProperty = require('./CSSProperty');
    var warning = require('fbjs/lib/warning');
    var isUnitlessNumber = CSSProperty.isUnitlessNumber;
    var styleWarnings = {};
    function dangerousStyleValue(name, value, component, isCustomProperty) {
        var isEmpty = value == null || typeof value === 'boolean' || value === '';
        if (isEmpty) {
            return '';
        }
        var isNonNumeric = isNaN(value);
        if (isCustomProperty || isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
            return '' + value;
        }
        if (typeof value === 'string') {
            if (process.env.NODE_ENV !== 'production') {
                if (component && value !== '0') {
                    var owner = component._currentElement._owner;
                    var ownerName = owner ? owner.getName() : null;
                    if (ownerName && !styleWarnings[ownerName]) {
                        styleWarnings[ownerName] = {};
                    }
                    var warned = false;
                    if (ownerName) {
                        var warnings = styleWarnings[ownerName];
                        warned = warnings[name];
                        if (!warned) {
                            warnings[name] = true;
                        }
                    }
                    if (!warned) {
                        process.env.NODE_ENV !== 'production' ? warning(false, 'a `%s` tag (owner: `%s`) was passed a numeric string value ' + 'for CSS property `%s` (value: `%s`) which will be treated ' + 'as a unitless number in a future version of React.', component._currentElement.type, ownerName || 'unknown', name, value) : void 0;
                    }
                }
            }
            value = value.trim();
        }
        return value + 'px';
    }
    module.exports = dangerousStyleValue;
});
/*fbjs@0.8.12#lib/hyphenate*/
define('fbjs@0.8.12#lib/hyphenate', function (require, exports, module) {
    'use strict';
    var _uppercasePattern = /([A-Z])/g;
    function hyphenate(string) {
        return string.replace(_uppercasePattern, '-$1').toLowerCase();
    }
    module.exports = hyphenate;
});
/*fbjs@0.8.12#lib/hyphenateStyleName*/
define('fbjs@0.8.12#lib/hyphenateStyleName', function (require, exports, module) {
    'use strict';
    var hyphenate = require('./hyphenate');
    var msPattern = /^ms-/;
    function hyphenateStyleName(string) {
        return hyphenate(string).replace(msPattern, '-ms-');
    }
    module.exports = hyphenateStyleName;
});
/*fbjs@0.8.12#lib/memoizeStringOnly*/
define('fbjs@0.8.12#lib/memoizeStringOnly', function (require, exports, module) {
    'use strict';
    function memoizeStringOnly(callback) {
        var cache = {};
        return function (string) {
            if (!cache.hasOwnProperty(string)) {
                cache[string] = callback.call(this, string);
            }
            return cache[string];
        };
    }
    module.exports = memoizeStringOnly;
});
/*react-dom@15.6.1#lib/CSSPropertyOperations*/
define('react-dom@15.6.1#lib/CSSPropertyOperations', function (require, exports, module) {
    'use strict';
    var CSSProperty = require('./CSSProperty');
    var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
    var ReactInstrumentation = require('./ReactInstrumentation');
    var camelizeStyleName = require('fbjs/lib/camelizeStyleName');
    var dangerousStyleValue = require('./dangerousStyleValue');
    var hyphenateStyleName = require('fbjs/lib/hyphenateStyleName');
    var memoizeStringOnly = require('fbjs/lib/memoizeStringOnly');
    var warning = require('fbjs/lib/warning');
    var processStyleName = memoizeStringOnly(function (styleName) {
        return hyphenateStyleName(styleName);
    });
    var hasShorthandPropertyBug = false;
    var styleFloatAccessor = 'cssFloat';
    if (ExecutionEnvironment.canUseDOM) {
        var tempStyle = document.createElement('div').style;
        try {
            tempStyle.font = '';
        } catch (e) {
            hasShorthandPropertyBug = true;
        }
        if (document.documentElement.style.cssFloat === undefined) {
            styleFloatAccessor = 'styleFloat';
        }
    }
    if (process.env.NODE_ENV !== 'production') {
        var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
        var badStyleValueWithSemicolonPattern = /;\s*$/;
        var warnedStyleNames = {};
        var warnedStyleValues = {};
        var warnedForNaNValue = false;
        var warnHyphenatedStyleName = function (name, owner) {
            if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
                return;
            }
            warnedStyleNames[name] = true;
            process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported style property %s. Did you mean %s?%s', name, camelizeStyleName(name), checkRenderMessage(owner)) : void 0;
        };
        var warnBadVendoredStyleName = function (name, owner) {
            if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
                return;
            }
            warnedStyleNames[name] = true;
            process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?%s', name, name.charAt(0).toUpperCase() + name.slice(1), checkRenderMessage(owner)) : void 0;
        };
        var warnStyleValueWithSemicolon = function (name, value, owner) {
            if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
                return;
            }
            warnedStyleValues[value] = true;
            process.env.NODE_ENV !== 'production' ? warning(false, 'Style property values shouldn\'t contain a semicolon.%s ' + 'Try "%s: %s" instead.', checkRenderMessage(owner), name, value.replace(badStyleValueWithSemicolonPattern, '')) : void 0;
        };
        var warnStyleValueIsNaN = function (name, value, owner) {
            if (warnedForNaNValue) {
                return;
            }
            warnedForNaNValue = true;
            process.env.NODE_ENV !== 'production' ? warning(false, '`NaN` is an invalid value for the `%s` css style property.%s', name, checkRenderMessage(owner)) : void 0;
        };
        var checkRenderMessage = function (owner) {
            if (owner) {
                var name = owner.getName();
                if (name) {
                    return ' Check the render method of `' + name + '`.';
                }
            }
            return '';
        };
        var warnValidStyle = function (name, value, component) {
            var owner;
            if (component) {
                owner = component._currentElement._owner;
            }
            if (name.indexOf('-') > -1) {
                warnHyphenatedStyleName(name, owner);
            } else if (badVendoredStyleNamePattern.test(name)) {
                warnBadVendoredStyleName(name, owner);
            } else if (badStyleValueWithSemicolonPattern.test(value)) {
                warnStyleValueWithSemicolon(name, value, owner);
            }
            if (typeof value === 'number' && isNaN(value)) {
                warnStyleValueIsNaN(name, value, owner);
            }
        };
    }
    var CSSPropertyOperations = {
        createMarkupForStyles: function (styles, component) {
            var serialized = '';
            for (var styleName in styles) {
                if (!styles.hasOwnProperty(styleName)) {
                    continue;
                }
                var isCustomProperty = styleName.indexOf('--') === 0;
                var styleValue = styles[styleName];
                if (process.env.NODE_ENV !== 'production') {
                    if (!isCustomProperty) {
                        warnValidStyle(styleName, styleValue, component);
                    }
                }
                if (styleValue != null) {
                    serialized += processStyleName(styleName) + ':';
                    serialized += dangerousStyleValue(styleName, styleValue, component, isCustomProperty) + ';';
                }
            }
            return serialized || null;
        },
        setValueForStyles: function (node, styles, component) {
            if (process.env.NODE_ENV !== 'production') {
                ReactInstrumentation.debugTool.onHostOperation({
                    instanceID: component._debugID,
                    type: 'update styles',
                    payload: styles
                });
            }
            var style = node.style;
            for (var styleName in styles) {
                if (!styles.hasOwnProperty(styleName)) {
                    continue;
                }
                var isCustomProperty = styleName.indexOf('--') === 0;
                if (process.env.NODE_ENV !== 'production') {
                    if (!isCustomProperty) {
                        warnValidStyle(styleName, styles[styleName], component);
                    }
                }
                var styleValue = dangerousStyleValue(styleName, styles[styleName], component, isCustomProperty);
                if (styleName === 'float' || styleName === 'cssFloat') {
                    styleName = styleFloatAccessor;
                }
                if (isCustomProperty) {
                    style.setProperty(styleName, styleValue);
                } else if (styleValue) {
                    style[styleName] = styleValue;
                } else {
                    var expansion = hasShorthandPropertyBug && CSSProperty.shorthandPropertyExpansions[styleName];
                    if (expansion) {
                        for (var individualStyleName in expansion) {
                            style[individualStyleName] = '';
                        }
                    } else {
                        style[styleName] = '';
                    }
                }
            }
        }
    };
    module.exports = CSSPropertyOperations;
});
/*react-dom@15.6.1#lib/quoteAttributeValueForBrowser*/
define('react-dom@15.6.1#lib/quoteAttributeValueForBrowser', function (require, exports, module) {
    'use strict';
    var escapeTextContentForBrowser = require('./escapeTextContentForBrowser');
    function quoteAttributeValueForBrowser(value) {
        return '"' + escapeTextContentForBrowser(value) + '"';
    }
    module.exports = quoteAttributeValueForBrowser;
});
/*react-dom@15.6.1#lib/DOMPropertyOperations*/
define('react-dom@15.6.1#lib/DOMPropertyOperations', function (require, exports, module) {
    'use strict';
    var DOMProperty = require('./DOMProperty');
    var ReactDOMComponentTree = require('./ReactDOMComponentTree');
    var ReactInstrumentation = require('./ReactInstrumentation');
    var quoteAttributeValueForBrowser = require('./quoteAttributeValueForBrowser');
    var warning = require('fbjs/lib/warning');
    var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + DOMProperty.ATTRIBUTE_NAME_START_CHAR + '][' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$');
    var illegalAttributeNameCache = {};
    var validatedAttributeNameCache = {};
    function isAttributeNameSafe(attributeName) {
        if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
            return true;
        }
        if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
            return false;
        }
        if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
            validatedAttributeNameCache[attributeName] = true;
            return true;
        }
        illegalAttributeNameCache[attributeName] = true;
        process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid attribute name: `%s`', attributeName) : void 0;
        return false;
    }
    function shouldIgnoreValue(propertyInfo, value) {
        return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
    }
    var DOMPropertyOperations = {
        createMarkupForID: function (id) {
            return DOMProperty.ID_ATTRIBUTE_NAME + '=' + quoteAttributeValueForBrowser(id);
        },
        setAttributeForID: function (node, id) {
            node.setAttribute(DOMProperty.ID_ATTRIBUTE_NAME, id);
        },
        createMarkupForRoot: function () {
            return DOMProperty.ROOT_ATTRIBUTE_NAME + '=""';
        },
        setAttributeForRoot: function (node) {
            node.setAttribute(DOMProperty.ROOT_ATTRIBUTE_NAME, '');
        },
        createMarkupForProperty: function (name, value) {
            var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
            if (propertyInfo) {
                if (shouldIgnoreValue(propertyInfo, value)) {
                    return '';
                }
                var attributeName = propertyInfo.attributeName;
                if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
                    return attributeName + '=""';
                }
                return attributeName + '=' + quoteAttributeValueForBrowser(value);
            } else if (DOMProperty.isCustomAttribute(name)) {
                if (value == null) {
                    return '';
                }
                return name + '=' + quoteAttributeValueForBrowser(value);
            }
            return null;
        },
        createMarkupForCustomAttribute: function (name, value) {
            if (!isAttributeNameSafe(name) || value == null) {
                return '';
            }
            return name + '=' + quoteAttributeValueForBrowser(value);
        },
        setValueForProperty: function (node, name, value) {
            var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
            if (propertyInfo) {
                var mutationMethod = propertyInfo.mutationMethod;
                if (mutationMethod) {
                    mutationMethod(node, value);
                } else if (shouldIgnoreValue(propertyInfo, value)) {
                    this.deleteValueForProperty(node, name);
                    return;
                } else if (propertyInfo.mustUseProperty) {
                    node[propertyInfo.propertyName] = value;
                } else {
                    var attributeName = propertyInfo.attributeName;
                    var namespace = propertyInfo.attributeNamespace;
                    if (namespace) {
                        node.setAttributeNS(namespace, attributeName, '' + value);
                    } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
                        node.setAttribute(attributeName, '');
                    } else {
                        node.setAttribute(attributeName, '' + value);
                    }
                }
            } else if (DOMProperty.isCustomAttribute(name)) {
                DOMPropertyOperations.setValueForAttribute(node, name, value);
                return;
            }
            if (process.env.NODE_ENV !== 'production') {
                var payload = {};
                payload[name] = value;
                ReactInstrumentation.debugTool.onHostOperation({
                    instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
                    type: 'update attribute',
                    payload: payload
                });
            }
        },
        setValueForAttribute: function (node, name, value) {
            if (!isAttributeNameSafe(name)) {
                return;
            }
            if (value == null) {
                node.removeAttribute(name);
            } else {
                node.setAttribute(name, '' + value);
            }
            if (process.env.NODE_ENV !== 'production') {
                var payload = {};
                payload[name] = value;
                ReactInstrumentation.debugTool.onHostOperation({
                    instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
                    type: 'update attribute',
                    payload: payload
                });
            }
        },
        deleteValueForAttribute: function (node, name) {
            node.removeAttribute(name);
            if (process.env.NODE_ENV !== 'production') {
                ReactInstrumentation.debugTool.onHostOperation({
                    instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
                    type: 'remove attribute',
                    payload: name
                });
            }
        },
        deleteValueForProperty: function (node, name) {
            var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
            if (propertyInfo) {
                var mutationMethod = propertyInfo.mutationMethod;
                if (mutationMethod) {
                    mutationMethod(node, undefined);
                } else if (propertyInfo.mustUseProperty) {
                    var propName = propertyInfo.propertyName;
                    if (propertyInfo.hasBooleanValue) {
                        node[propName] = false;
                    } else {
                        node[propName] = '';
                    }
                } else {
                    node.removeAttribute(propertyInfo.attributeName);
                }
            } else if (DOMProperty.isCustomAttribute(name)) {
                node.removeAttribute(name);
            }
            if (process.env.NODE_ENV !== 'production') {
                ReactInstrumentation.debugTool.onHostOperation({
                    instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
                    type: 'remove attribute',
                    payload: name
                });
            }
        }
    };
    module.exports = DOMPropertyOperations;
});
/*react-dom@15.6.1#lib/ReactEventEmitterMixin*/
define('react-dom@15.6.1#lib/ReactEventEmitterMixin', function (require, exports, module) {
    'use strict';
    var EventPluginHub = require('./EventPluginHub');
    function runEventQueueInBatch(events) {
        EventPluginHub.enqueueEvents(events);
        EventPluginHub.processEventQueue(false);
    }
    var ReactEventEmitterMixin = {
        handleTopLevel: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
            var events = EventPluginHub.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
            runEventQueueInBatch(events);
        }
    };
    module.exports = ReactEventEmitterMixin;
});
/*react-dom@15.6.1#lib/getVendorPrefixedEventName*/
define('react-dom@15.6.1#lib/getVendorPrefixedEventName', function (require, exports, module) {
    'use strict';
    var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
    function makePrefixMap(styleProp, eventName) {
        var prefixes = {};
        prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
        prefixes['Webkit' + styleProp] = 'webkit' + eventName;
        prefixes['Moz' + styleProp] = 'moz' + eventName;
        prefixes['ms' + styleProp] = 'MS' + eventName;
        prefixes['O' + styleProp] = 'o' + eventName.toLowerCase();
        return prefixes;
    }
    var vendorPrefixes = {
        animationend: makePrefixMap('Animation', 'AnimationEnd'),
        animationiteration: makePrefixMap('Animation', 'AnimationIteration'),
        animationstart: makePrefixMap('Animation', 'AnimationStart'),
        transitionend: makePrefixMap('Transition', 'TransitionEnd')
    };
    var prefixedEventNames = {};
    var style = {};
    if (ExecutionEnvironment.canUseDOM) {
        style = document.createElement('div').style;
        if (!('AnimationEvent' in window)) {
            delete vendorPrefixes.animationend.animation;
            delete vendorPrefixes.animationiteration.animation;
            delete vendorPrefixes.animationstart.animation;
        }
        if (!('TransitionEvent' in window)) {
            delete vendorPrefixes.transitionend.transition;
        }
    }
    function getVendorPrefixedEventName(eventName) {
        if (prefixedEventNames[eventName]) {
            return prefixedEventNames[eventName];
        } else if (!vendorPrefixes[eventName]) {
            return eventName;
        }
        var prefixMap = vendorPrefixes[eventName];
        for (var styleProp in prefixMap) {
            if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
                return prefixedEventNames[eventName] = prefixMap[styleProp];
            }
        }
        return '';
    }
    module.exports = getVendorPrefixedEventName;
});
/*react-dom@15.6.1#lib/ReactBrowserEventEmitter*/
define('react-dom@15.6.1#lib/ReactBrowserEventEmitter', function (require, exports, module) {
    'use strict';
    var _assign = require('object-assign');
    var EventPluginRegistry = require('./EventPluginRegistry');
    var ReactEventEmitterMixin = require('./ReactEventEmitterMixin');
    var ViewportMetrics = require('./ViewportMetrics');
    var getVendorPrefixedEventName = require('./getVendorPrefixedEventName');
    var isEventSupported = require('./isEventSupported');
    var hasEventPageXY;
    var alreadyListeningTo = {};
    var isMonitoringScrollValue = false;
    var reactTopListenersCounter = 0;
    var topEventMapping = {
        topAbort: 'abort',
        topAnimationEnd: getVendorPrefixedEventName('animationend') || 'animationend',
        topAnimationIteration: getVendorPrefixedEventName('animationiteration') || 'animationiteration',
        topAnimationStart: getVendorPrefixedEventName('animationstart') || 'animationstart',
        topBlur: 'blur',
        topCanPlay: 'canplay',
        topCanPlayThrough: 'canplaythrough',
        topChange: 'change',
        topClick: 'click',
        topCompositionEnd: 'compositionend',
        topCompositionStart: 'compositionstart',
        topCompositionUpdate: 'compositionupdate',
        topContextMenu: 'contextmenu',
        topCopy: 'copy',
        topCut: 'cut',
        topDoubleClick: 'dblclick',
        topDrag: 'drag',
        topDragEnd: 'dragend',
        topDragEnter: 'dragenter',
        topDragExit: 'dragexit',
        topDragLeave: 'dragleave',
        topDragOver: 'dragover',
        topDragStart: 'dragstart',
        topDrop: 'drop',
        topDurationChange: 'durationchange',
        topEmptied: 'emptied',
        topEncrypted: 'encrypted',
        topEnded: 'ended',
        topError: 'error',
        topFocus: 'focus',
        topInput: 'input',
        topKeyDown: 'keydown',
        topKeyPress: 'keypress',
        topKeyUp: 'keyup',
        topLoadedData: 'loadeddata',
        topLoadedMetadata: 'loadedmetadata',
        topLoadStart: 'loadstart',
        topMouseDown: 'mousedown',
        topMouseMove: 'mousemove',
        topMouseOut: 'mouseout',
        topMouseOver: 'mouseover',
        topMouseUp: 'mouseup',
        topPaste: 'paste',
        topPause: 'pause',
        topPlay: 'play',
        topPlaying: 'playing',
        topProgress: 'progress',
        topRateChange: 'ratechange',
        topScroll: 'scroll',
        topSeeked: 'seeked',
        topSeeking: 'seeking',
        topSelectionChange: 'selectionchange',
        topStalled: 'stalled',
        topSuspend: 'suspend',
        topTextInput: 'textInput',
        topTimeUpdate: 'timeupdate',
        topTouchCancel: 'touchcancel',
        topTouchEnd: 'touchend',
        topTouchMove: 'touchmove',
        topTouchStart: 'touchstart',
        topTransitionEnd: getVendorPrefixedEventName('transitionend') || 'transitionend',
        topVolumeChange: 'volumechange',
        topWaiting: 'waiting',
        topWheel: 'wheel'
    };
    var topListenersIDKey = '_reactListenersID' + String(Math.random()).slice(2);
    function getListeningForDocument(mountAt) {
        if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
            mountAt[topListenersIDKey] = reactTopListenersCounter++;
            alreadyListeningTo[mountAt[topListenersIDKey]] = {};
        }
        return alreadyListeningTo[mountAt[topListenersIDKey]];
    }
    var ReactBrowserEventEmitter = _assign({}, ReactEventEmitterMixin, {
        ReactEventListener: null,
        injection: {
            injectReactEventListener: function (ReactEventListener) {
                ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);
                ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
            }
        },
        setEnabled: function (enabled) {
            if (ReactBrowserEventEmitter.ReactEventListener) {
                ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
            }
        },
        isEnabled: function () {
            return !!(ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled());
        },
        listenTo: function (registrationName, contentDocumentHandle) {
            var mountAt = contentDocumentHandle;
            var isListening = getListeningForDocument(mountAt);
            var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];
            for (var i = 0; i < dependencies.length; i++) {
                var dependency = dependencies[i];
                if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
                    if (dependency === 'topWheel') {
                        if (isEventSupported('wheel')) {
                            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'wheel', mountAt);
                        } else if (isEventSupported('mousewheel')) {
                            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'mousewheel', mountAt);
                        } else {
                            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'DOMMouseScroll', mountAt);
                        }
                    } else if (dependency === 'topScroll') {
                        if (isEventSupported('scroll', true)) {
                            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topScroll', 'scroll', mountAt);
                        } else {
                            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topScroll', 'scroll', ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE);
                        }
                    } else if (dependency === 'topFocus' || dependency === 'topBlur') {
                        if (isEventSupported('focus', true)) {
                            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topFocus', 'focus', mountAt);
                            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topBlur', 'blur', mountAt);
                        } else if (isEventSupported('focusin')) {
                            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topFocus', 'focusin', mountAt);
                            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topBlur', 'focusout', mountAt);
                        }
                        isListening.topBlur = true;
                        isListening.topFocus = true;
                    } else if (topEventMapping.hasOwnProperty(dependency)) {
                        ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
                    }
                    isListening[dependency] = true;
                }
            }
        },
        trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {
            return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
        },
        trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {
            return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
        },
        supportsEventPageXY: function () {
            if (!document.createEvent) {
                return false;
            }
            var ev = document.createEvent('MouseEvent');
            return ev != null && 'pageX' in ev;
        },
        ensureScrollValueMonitoring: function () {
            if (hasEventPageXY === undefined) {
                hasEventPageXY = ReactBrowserEventEmitter.supportsEventPageXY();
            }
            if (!hasEventPageXY && !isMonitoringScrollValue) {
                var refresh = ViewportMetrics.refreshScrollValues;
                ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
                isMonitoringScrollValue = true;
            }
        }
    });
    module.exports = ReactBrowserEventEmitter;
});
/*react-dom@15.6.1#lib/ReactPropTypesSecret*/
define('react-dom@15.6.1#lib/ReactPropTypesSecret', function (require, exports, module) {
    'use strict';
    var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
    module.exports = ReactPropTypesSecret;
});
/*react-dom@15.6.1#lib/LinkedValueUtils*/
define('react-dom@15.6.1#lib/LinkedValueUtils', function (require, exports, module) {
    'use strict';
    var _prodInvariant = require('./reactProdInvariant');
    var ReactPropTypesSecret = require('./ReactPropTypesSecret');
    var propTypesFactory = require('prop-types/factory');
    var React = require('react/lib/React');
    var PropTypes = propTypesFactory(React.isValidElement);
    var invariant = require('fbjs/lib/invariant');
    var warning = require('fbjs/lib/warning');
    var hasReadOnlyValue = {
        button: true,
        checkbox: true,
        image: true,
        hidden: true,
        radio: true,
        reset: true,
        submit: true
    };
    function _assertSingleLink(inputProps) {
        !(inputProps.checkedLink == null || inputProps.valueLink == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a valueLink. If you want to use checkedLink, you probably don\'t want to use valueLink and vice versa.') : _prodInvariant('87') : void 0;
    }
    function _assertValueLink(inputProps) {
        _assertSingleLink(inputProps);
        !(inputProps.value == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a valueLink and a value or onChange event. If you want to use value or onChange, you probably don\'t want to use valueLink.') : _prodInvariant('88') : void 0;
    }
    function _assertCheckedLink(inputProps) {
        _assertSingleLink(inputProps);
        !(inputProps.checked == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a checked property or onChange event. If you want to use checked or onChange, you probably don\'t want to use checkedLink') : _prodInvariant('89') : void 0;
    }
    var propTypes = {
        value: function (props, propName, componentName) {
            if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
                return null;
            }
            return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
        },
        checked: function (props, propName, componentName) {
            if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
                return null;
            }
            return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
        },
        onChange: PropTypes.func
    };
    var loggedTypeFailures = {};
    function getDeclarationErrorAddendum(owner) {
        if (owner) {
            var name = owner.getName();
            if (name) {
                return ' Check the render method of `' + name + '`.';
            }
        }
        return '';
    }
    var LinkedValueUtils = {
        checkPropTypes: function (tagName, props, owner) {
            for (var propName in propTypes) {
                if (propTypes.hasOwnProperty(propName)) {
                    var error = propTypes[propName](props, propName, tagName, 'prop', null, ReactPropTypesSecret);
                }
                if (error instanceof Error && !(error.message in loggedTypeFailures)) {
                    loggedTypeFailures[error.message] = true;
                    var addendum = getDeclarationErrorAddendum(owner);
                    process.env.NODE_ENV !== 'production' ? warning(false, 'Failed form propType: %s%s', error.message, addendum) : void 0;
                }
            }
        },
        getValue: function (inputProps) {
            if (inputProps.valueLink) {
                _assertValueLink(inputProps);
                return inputProps.valueLink.value;
            }
            return inputProps.value;
        },
        getChecked: function (inputProps) {
            if (inputProps.checkedLink) {
                _assertCheckedLink(inputProps);
                return inputProps.checkedLink.value;
            }
            return inputProps.checked;
        },
        executeOnChange: function (inputProps, event) {
            if (inputProps.valueLink) {
                _assertValueLink(inputProps);
                return inputProps.valueLink.requestChange(event.target.value);
            } else if (inputProps.checkedLink) {
                _assertCheckedLink(inputProps);
                return inputProps.checkedLink.requestChange(event.target.checked);
            } else if (inputProps.onChange) {
                return inputProps.onChange.call(undefined, event);
            }
        }
    };
    module.exports = LinkedValueUtils;
});
/*react-dom@15.6.1#lib/ReactDOMInput*/
define('react-dom@15.6.1#lib/ReactDOMInput', function (require, exports, module) {
    (function (global) {
        'use strict';
        var _prodInvariant = require('./reactProdInvariant'), _assign = require('object-assign');
        var DOMPropertyOperations = require('./DOMPropertyOperations');
        var LinkedValueUtils = require('./LinkedValueUtils');
        var ReactDOMComponentTree = require('./ReactDOMComponentTree');
        var ReactUpdates = require('./ReactUpdates');
        var invariant = require('fbjs/lib/invariant');
        var warning = require('fbjs/lib/warning');
        var didWarnValueLink = false;
        var didWarnCheckedLink = false;
        var didWarnValueDefaultValue = false;
        var didWarnCheckedDefaultChecked = false;
        var didWarnControlledToUncontrolled = false;
        var didWarnUncontrolledToControlled = false;
        function forceUpdateIfMounted() {
            if (this._rootNodeID) {
                ReactDOMInput.updateWrapper(this);
            }
        }
        function isControlled(props) {
            var usesChecked = props.type === 'checkbox' || props.type === 'radio';
            return usesChecked ? props.checked != null : props.value != null;
        }
        var ReactDOMInput = {
            getHostProps: function (inst, props) {
                var value = LinkedValueUtils.getValue(props);
                var checked = LinkedValueUtils.getChecked(props);
                var hostProps = _assign({
                    type: undefined,
                    step: undefined,
                    min: undefined,
                    max: undefined
                }, props, {
                    defaultChecked: undefined,
                    defaultValue: undefined,
                    value: value != null ? value : inst._wrapperState.initialValue,
                    checked: checked != null ? checked : inst._wrapperState.initialChecked,
                    onChange: inst._wrapperState.onChange
                });
                return hostProps;
            },
            mountWrapper: function (inst, props) {
                if (process.env.NODE_ENV !== 'production') {
                    LinkedValueUtils.checkPropTypes('input', props, inst._currentElement._owner);
                    var owner = inst._currentElement._owner;
                    if (props.valueLink !== undefined && !didWarnValueLink) {
                        process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
                        didWarnValueLink = true;
                    }
                    if (props.checkedLink !== undefined && !didWarnCheckedLink) {
                        process.env.NODE_ENV !== 'production' ? warning(false, '`checkedLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
                        didWarnCheckedLink = true;
                    }
                    if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {
                        process.env.NODE_ENV !== 'production' ? warning(false, '%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
                        didWarnCheckedDefaultChecked = true;
                    }
                    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
                        process.env.NODE_ENV !== 'production' ? warning(false, '%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
                        didWarnValueDefaultValue = true;
                    }
                }
                var defaultValue = props.defaultValue;
                inst._wrapperState = {
                    initialChecked: props.checked != null ? props.checked : props.defaultChecked,
                    initialValue: props.value != null ? props.value : defaultValue,
                    listeners: null,
                    onChange: _handleChange.bind(inst),
                    controlled: isControlled(props)
                };
            },
            updateWrapper: function (inst) {
                var props = inst._currentElement.props;
                if (process.env.NODE_ENV !== 'production') {
                    var controlled = isControlled(props);
                    var owner = inst._currentElement._owner;
                    if (!inst._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
                        process.env.NODE_ENV !== 'production' ? warning(false, '%s is changing an uncontrolled input of type %s to be controlled. ' + 'Input elements should not switch from uncontrolled to controlled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
                        didWarnUncontrolledToControlled = true;
                    }
                    if (inst._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
                        process.env.NODE_ENV !== 'production' ? warning(false, '%s is changing a controlled input of type %s to be uncontrolled. ' + 'Input elements should not switch from controlled to uncontrolled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
                        didWarnControlledToUncontrolled = true;
                    }
                }
                var checked = props.checked;
                if (checked != null) {
                    DOMPropertyOperations.setValueForProperty(ReactDOMComponentTree.getNodeFromInstance(inst), 'checked', checked || false);
                }
                var node = ReactDOMComponentTree.getNodeFromInstance(inst);
                var value = LinkedValueUtils.getValue(props);
                if (value != null) {
                    if (value === 0 && node.value === '') {
                        node.value = '0';
                    } else if (props.type === 'number') {
                        var valueAsNumber = parseFloat(node.value, 10) || 0;
                        if (value != valueAsNumber || value == valueAsNumber && node.value != value) {
                            node.value = '' + value;
                        }
                    } else if (node.value !== '' + value) {
                        node.value = '' + value;
                    }
                } else {
                    if (props.value == null && props.defaultValue != null) {
                        if (node.defaultValue !== '' + props.defaultValue) {
                            node.defaultValue = '' + props.defaultValue;
                        }
                    }
                    if (props.checked == null && props.defaultChecked != null) {
                        node.defaultChecked = !!props.defaultChecked;
                    }
                }
            },
            postMountWrapper: function (inst) {
                var props = inst._currentElement.props;
                var node = ReactDOMComponentTree.getNodeFromInstance(inst);
                switch (props.type) {
                case 'submit':
                case 'reset':
                    break;
                case 'color':
                case 'date':
                case 'datetime':
                case 'datetime-local':
                case 'month':
                case 'time':
                case 'week':
                    node.value = '';
                    node.value = node.defaultValue;
                    break;
                default:
                    node.value = node.value;
                    break;
                }
                var name = node.name;
                if (name !== '') {
                    node.name = '';
                }
                node.defaultChecked = !node.defaultChecked;
                node.defaultChecked = !node.defaultChecked;
                if (name !== '') {
                    node.name = name;
                }
            }
        };
        function _handleChange(event) {
            var props = this._currentElement.props;
            var returnValue = LinkedValueUtils.executeOnChange(props, event);
            ReactUpdates.asap(forceUpdateIfMounted, this);
            var name = props.name;
            if (props.type === 'radio' && name != null) {
                var rootNode = ReactDOMComponentTree.getNodeFromInstance(this);
                var queryRoot = rootNode;
                while (queryRoot.parentNode) {
                    queryRoot = queryRoot.parentNode;
                }
                var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');
                for (var i = 0; i < group.length; i++) {
                    var otherNode = group[i];
                    if (otherNode === rootNode || otherNode.form !== rootNode.form) {
                        continue;
                    }
                    var otherInstance = ReactDOMComponentTree.getInstanceFromNode(otherNode);
                    !otherInstance ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.') : _prodInvariant('90') : void 0;
                    ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
                }
            }
            return returnValue;
        }
        module.exports = ReactDOMInput;
    }(function () {
        return this;
    }()));
});
/*react-dom@15.6.1#lib/ReactDOMSelect*/
define('react-dom@15.6.1#lib/ReactDOMSelect', function (require, exports, module) {
    'use strict';
    var _assign = require('object-assign');
    var LinkedValueUtils = require('./LinkedValueUtils');
    var ReactDOMComponentTree = require('./ReactDOMComponentTree');
    var ReactUpdates = require('./ReactUpdates');
    var warning = require('fbjs/lib/warning');
    var didWarnValueLink = false;
    var didWarnValueDefaultValue = false;
    function updateOptionsIfPendingUpdateAndMounted() {
        if (this._rootNodeID && this._wrapperState.pendingUpdate) {
            this._wrapperState.pendingUpdate = false;
            var props = this._currentElement.props;
            var value = LinkedValueUtils.getValue(props);
            if (value != null) {
                updateOptions(this, Boolean(props.multiple), value);
            }
        }
    }
    function getDeclarationErrorAddendum(owner) {
        if (owner) {
            var name = owner.getName();
            if (name) {
                return ' Check the render method of `' + name + '`.';
            }
        }
        return '';
    }
    var valuePropNames = [
        'value',
        'defaultValue'
    ];
    function checkSelectPropTypes(inst, props) {
        var owner = inst._currentElement._owner;
        LinkedValueUtils.checkPropTypes('select', props, owner);
        if (props.valueLink !== undefined && !didWarnValueLink) {
            process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `select` is deprecated; set `value` and `onChange` instead.') : void 0;
            didWarnValueLink = true;
        }
        for (var i = 0; i < valuePropNames.length; i++) {
            var propName = valuePropNames[i];
            if (props[propName] == null) {
                continue;
            }
            var isArray = Array.isArray(props[propName]);
            if (props.multiple && !isArray) {
                process.env.NODE_ENV !== 'production' ? warning(false, 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
            } else if (!props.multiple && isArray) {
                process.env.NODE_ENV !== 'production' ? warning(false, 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
            }
        }
    }
    function updateOptions(inst, multiple, propValue) {
        var selectedValue, i;
        var options = ReactDOMComponentTree.getNodeFromInstance(inst).options;
        if (multiple) {
            selectedValue = {};
            for (i = 0; i < propValue.length; i++) {
                selectedValue['' + propValue[i]] = true;
            }
            for (i = 0; i < options.length; i++) {
                var selected = selectedValue.hasOwnProperty(options[i].value);
                if (options[i].selected !== selected) {
                    options[i].selected = selected;
                }
            }
        } else {
            selectedValue = '' + propValue;
            for (i = 0; i < options.length; i++) {
                if (options[i].value === selectedValue) {
                    options[i].selected = true;
                    return;
                }
            }
            if (options.length) {
                options[0].selected = true;
            }
        }
    }
    var ReactDOMSelect = {
        getHostProps: function (inst, props) {
            return _assign({}, props, {
                onChange: inst._wrapperState.onChange,
                value: undefined
            });
        },
        mountWrapper: function (inst, props) {
            if (process.env.NODE_ENV !== 'production') {
                checkSelectPropTypes(inst, props);
            }
            var value = LinkedValueUtils.getValue(props);
            inst._wrapperState = {
                pendingUpdate: false,
                initialValue: value != null ? value : props.defaultValue,
                listeners: null,
                onChange: _handleChange.bind(inst),
                wasMultiple: Boolean(props.multiple)
            };
            if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
                process.env.NODE_ENV !== 'production' ? warning(false, 'Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
                didWarnValueDefaultValue = true;
            }
        },
        getSelectValueContext: function (inst) {
            return inst._wrapperState.initialValue;
        },
        postUpdateWrapper: function (inst) {
            var props = inst._currentElement.props;
            inst._wrapperState.initialValue = undefined;
            var wasMultiple = inst._wrapperState.wasMultiple;
            inst._wrapperState.wasMultiple = Boolean(props.multiple);
            var value = LinkedValueUtils.getValue(props);
            if (value != null) {
                inst._wrapperState.pendingUpdate = false;
                updateOptions(inst, Boolean(props.multiple), value);
            } else if (wasMultiple !== Boolean(props.multiple)) {
                if (props.defaultValue != null) {
                    updateOptions(inst, Boolean(props.multiple), props.defaultValue);
                } else {
                    updateOptions(inst, Boolean(props.multiple), props.multiple ? [] : '');
                }
            }
        }
    };
    function _handleChange(event) {
        var props = this._currentElement.props;
        var returnValue = LinkedValueUtils.executeOnChange(props, event);
        if (this._rootNodeID) {
            this._wrapperState.pendingUpdate = true;
        }
        ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this);
        return returnValue;
    }
    module.exports = ReactDOMSelect;
});
/*react-dom@15.6.1#lib/ReactDOMOption*/
define('react-dom@15.6.1#lib/ReactDOMOption', function (require, exports, module) {
    'use strict';
    var _assign = require('object-assign');
    var React = require('react/lib/React');
    var ReactDOMComponentTree = require('./ReactDOMComponentTree');
    var ReactDOMSelect = require('./ReactDOMSelect');
    var warning = require('fbjs/lib/warning');
    var didWarnInvalidOptionChildren = false;
    function flattenChildren(children) {
        var content = '';
        React.Children.forEach(children, function (child) {
            if (child == null) {
                return;
            }
            if (typeof child === 'string' || typeof child === 'number') {
                content += child;
            } else if (!didWarnInvalidOptionChildren) {
                didWarnInvalidOptionChildren = true;
                process.env.NODE_ENV !== 'production' ? warning(false, 'Only strings and numbers are supported as <option> children.') : void 0;
            }
        });
        return content;
    }
    var ReactDOMOption = {
        mountWrapper: function (inst, props, hostParent) {
            if (process.env.NODE_ENV !== 'production') {
                process.env.NODE_ENV !== 'production' ? warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.') : void 0;
            }
            var selectValue = null;
            if (hostParent != null) {
                var selectParent = hostParent;
                if (selectParent._tag === 'optgroup') {
                    selectParent = selectParent._hostParent;
                }
                if (selectParent != null && selectParent._tag === 'select') {
                    selectValue = ReactDOMSelect.getSelectValueContext(selectParent);
                }
            }
            var selected = null;
            if (selectValue != null) {
                var value;
                if (props.value != null) {
                    value = props.value + '';
                } else {
                    value = flattenChildren(props.children);
                }
                selected = false;
                if (Array.isArray(selectValue)) {
                    for (var i = 0; i < selectValue.length; i++) {
                        if ('' + selectValue[i] === value) {
                            selected = true;
                            break;
                        }
                    }
                } else {
                    selected = '' + selectValue === value;
                }
            }
            inst._wrapperState = { selected: selected };
        },
        postMountWrapper: function (inst) {
            var props = inst._currentElement.props;
            if (props.value != null) {
                var node = ReactDOMComponentTree.getNodeFromInstance(inst);
                node.setAttribute('value', props.value);
            }
        },
        getHostProps: function (inst, props) {
            var hostProps = _assign({
                selected: undefined,
                children: undefined
            }, props);
            if (inst._wrapperState.selected != null) {
                hostProps.selected = inst._wrapperState.selected;
            }
            var content = flattenChildren(props.children);
            if (content) {
                hostProps.children = content;
            }
            return hostProps;
        }
    };
    module.exports = ReactDOMOption;
});
/*react-dom@15.6.1#lib/ReactDOMTextarea*/
define('react-dom@15.6.1#lib/ReactDOMTextarea', function (require, exports, module) {
    'use strict';
    var _prodInvariant = require('./reactProdInvariant'), _assign = require('object-assign');
    var LinkedValueUtils = require('./LinkedValueUtils');
    var ReactDOMComponentTree = require('./ReactDOMComponentTree');
    var ReactUpdates = require('./ReactUpdates');
    var invariant = require('fbjs/lib/invariant');
    var warning = require('fbjs/lib/warning');
    var didWarnValueLink = false;
    var didWarnValDefaultVal = false;
    function forceUpdateIfMounted() {
        if (this._rootNodeID) {
            ReactDOMTextarea.updateWrapper(this);
        }
    }
    var ReactDOMTextarea = {
        getHostProps: function (inst, props) {
            !(props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : _prodInvariant('91') : void 0;
            var hostProps = _assign({}, props, {
                value: undefined,
                defaultValue: undefined,
                children: '' + inst._wrapperState.initialValue,
                onChange: inst._wrapperState.onChange
            });
            return hostProps;
        },
        mountWrapper: function (inst, props) {
            if (process.env.NODE_ENV !== 'production') {
                LinkedValueUtils.checkPropTypes('textarea', props, inst._currentElement._owner);
                if (props.valueLink !== undefined && !didWarnValueLink) {
                    process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `textarea` is deprecated; set `value` and `onChange` instead.') : void 0;
                    didWarnValueLink = true;
                }
                if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {
                    process.env.NODE_ENV !== 'production' ? warning(false, 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
                    didWarnValDefaultVal = true;
                }
            }
            var value = LinkedValueUtils.getValue(props);
            var initialValue = value;
            if (value == null) {
                var defaultValue = props.defaultValue;
                var children = props.children;
                if (children != null) {
                    if (process.env.NODE_ENV !== 'production') {
                        process.env.NODE_ENV !== 'production' ? warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.') : void 0;
                    }
                    !(defaultValue == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : _prodInvariant('92') : void 0;
                    if (Array.isArray(children)) {
                        !(children.length <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, '<textarea> can only have at most one child.') : _prodInvariant('93') : void 0;
                        children = children[0];
                    }
                    defaultValue = '' + children;
                }
                if (defaultValue == null) {
                    defaultValue = '';
                }
                initialValue = defaultValue;
            }
            inst._wrapperState = {
                initialValue: '' + initialValue,
                listeners: null,
                onChange: _handleChange.bind(inst)
            };
        },
        updateWrapper: function (inst) {
            var props = inst._currentElement.props;
            var node = ReactDOMComponentTree.getNodeFromInstance(inst);
            var value = LinkedValueUtils.getValue(props);
            if (value != null) {
                var newValue = '' + value;
                if (newValue !== node.value) {
                    node.value = newValue;
                }
                if (props.defaultValue == null) {
                    node.defaultValue = newValue;
                }
            }
            if (props.defaultValue != null) {
                node.defaultValue = props.defaultValue;
            }
        },
        postMountWrapper: function (inst) {
            var node = ReactDOMComponentTree.getNodeFromInstance(inst);
            var textContent = node.textContent;
            if (textContent === inst._wrapperState.initialValue) {
                node.value = textContent;
            }
        }
    };
    function _handleChange(event) {
        var props = this._currentElement.props;
        var returnValue = LinkedValueUtils.executeOnChange(props, event);
        ReactUpdates.asap(forceUpdateIfMounted, this);
        return returnValue;
    }
    module.exports = ReactDOMTextarea;
});
/*react-dom@15.6.1#lib/ReactComponentEnvironment*/
define('react-dom@15.6.1#lib/ReactComponentEnvironment', function (require, exports, module) {
    'use strict';
    var _prodInvariant = require('./reactProdInvariant');
    var invariant = require('fbjs/lib/invariant');
    var injected = false;
    var ReactComponentEnvironment = {
        replaceNodeWithMarkup: null,
        processChildrenUpdates: null,
        injection: {
            injectEnvironment: function (environment) {
                !!injected ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactCompositeComponent: injectEnvironment() can only be called once.') : _prodInvariant('104') : void 0;
                ReactComponentEnvironment.replaceNodeWithMarkup = environment.replaceNodeWithMarkup;
                ReactComponentEnvironment.processChildrenUpdates = environment.processChildrenUpdates;
                injected = true;
            }
        }
    };
    module.exports = ReactComponentEnvironment;
});
/*react-dom@15.6.1#lib/ReactInstanceMap*/
define('react-dom@15.6.1#lib/ReactInstanceMap', function (require, exports, module) {
    'use strict';
    var ReactInstanceMap = {
        remove: function (key) {
            key._reactInternalInstance = undefined;
        },
        get: function (key) {
            return key._reactInternalInstance;
        },
        has: function (key) {
            return key._reactInternalInstance !== undefined;
        },
        set: function (key, value) {
            key._reactInternalInstance = value;
        }
    };
    module.exports = ReactInstanceMap;
});
/*react-dom@15.6.1#lib/ReactNodeTypes*/
define('react-dom@15.6.1#lib/ReactNodeTypes', function (require, exports, module) {
    'use strict';
    var _prodInvariant = require('./reactProdInvariant');
    var React = require('react/lib/React');
    var invariant = require('fbjs/lib/invariant');
    var ReactNodeTypes = {
        HOST: 0,
        COMPOSITE: 1,
        EMPTY: 2,
        getType: function (node) {
            if (node === null || node === false) {
                return ReactNodeTypes.EMPTY;
            } else if (React.isValidElement(node)) {
                if (typeof node.type === 'function') {
                    return ReactNodeTypes.COMPOSITE;
                } else {
                    return ReactNodeTypes.HOST;
                }
            }
            !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Unexpected node: %s', node) : _prodInvariant('26', node) : void 0;
        }
    };
    module.exports = ReactNodeTypes;
});
/*react-dom@15.6.1#lib/ReactPropTypeLocationNames*/
define('react-dom@15.6.1#lib/ReactPropTypeLocationNames', function (require, exports, module) {
    'use strict';
    var ReactPropTypeLocationNames = {};
    if (process.env.NODE_ENV !== 'production') {
        ReactPropTypeLocationNames = {
            prop: 'prop',
            context: 'context',
            childContext: 'child context'
        };
    }
    module.exports = ReactPropTypeLocationNames;
});
/*react-dom@15.6.1#lib/checkReactTypeSpec*/
define('react-dom@15.6.1#lib/checkReactTypeSpec', function (require, exports, module) {
    'use strict';
    var _prodInvariant = require('./reactProdInvariant');
    var ReactPropTypeLocationNames = require('./ReactPropTypeLocationNames');
    var ReactPropTypesSecret = require('./ReactPropTypesSecret');
    var invariant = require('fbjs/lib/invariant');
    var warning = require('fbjs/lib/warning');
    var ReactComponentTreeHook;
    if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
        ReactComponentTreeHook = require('react/lib/ReactComponentTreeHook');
    }
    var loggedTypeFailures = {};
    function checkReactTypeSpec(typeSpecs, values, location, componentName, element, debugID) {
        for (var typeSpecName in typeSpecs) {
            if (typeSpecs.hasOwnProperty(typeSpecName)) {
                var error;
                try {
                    !(typeof typeSpecs[typeSpecName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : _prodInvariant('84', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : void 0;
                    error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
                } catch (ex) {
                    error = ex;
                }
                process.env.NODE_ENV !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName, typeof error) : void 0;
                if (error instanceof Error && !(error.message in loggedTypeFailures)) {
                    loggedTypeFailures[error.message] = true;
                    var componentStackInfo = '';
                    if (process.env.NODE_ENV !== 'production') {
                        if (!ReactComponentTreeHook) {
                            ReactComponentTreeHook = require('react/lib/ReactComponentTreeHook');
                        }
                        if (debugID !== null) {
                            componentStackInfo = ReactComponentTreeHook.getStackAddendumByID(debugID);
                        } else if (element !== null) {
                            componentStackInfo = ReactComponentTreeHook.getCurrentStackAddendum(element);
                        }
                    }
                    process.env.NODE_ENV !== 'production' ? warning(false, 'Failed %s type: %s%s', location, error.message, componentStackInfo) : void 0;
                }
            }
        }
    }
    module.exports = checkReactTypeSpec;
});
/*fbjs@0.8.12#lib/shallowEqual*/
define('fbjs@0.8.12#lib/shallowEqual', function (require, exports, module) {
    'use strict';
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function is(x, y) {
        if (x === y) {
            return x !== 0 || y !== 0 || 1 / x === 1 / y;
        } else {
            return x !== x && y !== y;
        }
    }
    function shallowEqual(objA, objB) {
        if (is(objA, objB)) {
            return true;
        }
        if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
            return false;
        }
        var keysA = Object.keys(objA);
        var keysB = Object.keys(objB);
        if (keysA.length !== keysB.length) {
            return false;
        }
        for (var i = 0; i < keysA.length; i++) {
            if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
                return false;
            }
        }
        return true;
    }
    module.exports = shallowEqual;
});
/*react-dom@15.6.1#lib/shouldUpdateReactComponent*/
define('react-dom@15.6.1#lib/shouldUpdateReactComponent', function (require, exports, module) {
    'use strict';
    function shouldUpdateReactComponent(prevElement, nextElement) {
        var prevEmpty = prevElement === null || prevElement === false;
        var nextEmpty = nextElement === null || nextElement === false;
        if (prevEmpty || nextEmpty) {
            return prevEmpty === nextEmpty;
        }
        var prevType = typeof prevElement;
        var nextType = typeof nextElement;
        if (prevType === 'string' || prevType === 'number') {
            return nextType === 'string' || nextType === 'number';
        } else {
            return nextType === 'object' && prevElement.type === nextElement.type && prevElement.key === nextElement.key;
        }
    }
    module.exports = shouldUpdateReactComponent;
});
/*react-dom@15.6.1#lib/ReactCompositeComponent*/
define('react-dom@15.6.1#lib/ReactCompositeComponent', function (require, exports, module) {
    'use strict';
    var _prodInvariant = require('./reactProdInvariant'), _assign = require('object-assign');
    var React = require('react/lib/React');
    var ReactComponentEnvironment = require('./ReactComponentEnvironment');
    var ReactCurrentOwner = require('react/lib/ReactCurrentOwner');
    var ReactErrorUtils = require('./ReactErrorUtils');
    var ReactInstanceMap = require('./ReactInstanceMap');
    var ReactInstrumentation = require('./ReactInstrumentation');
    var ReactNodeTypes = require('./ReactNodeTypes');
    var ReactReconciler = require('./ReactReconciler');
    if (process.env.NODE_ENV !== 'production') {
        var checkReactTypeSpec = require('./checkReactTypeSpec');
    }
    var emptyObject = require('fbjs/lib/emptyObject');
    var invariant = require('fbjs/lib/invariant');
    var shallowEqual = require('fbjs/lib/shallowEqual');
    var shouldUpdateReactComponent = require('./shouldUpdateReactComponent');
    var warning = require('fbjs/lib/warning');
    var CompositeTypes = {
        ImpureClass: 0,
        PureClass: 1,
        StatelessFunctional: 2
    };
    function StatelessComponent(Component) {
    }
    StatelessComponent.prototype.render = function () {
        var Component = ReactInstanceMap.get(this)._currentElement.type;
        var element = Component(this.props, this.context, this.updater);
        warnIfInvalidElement(Component, element);
        return element;
    };
    function warnIfInvalidElement(Component, element) {
        if (process.env.NODE_ENV !== 'production') {
            process.env.NODE_ENV !== 'production' ? warning(element === null || element === false || React.isValidElement(element), '%s(...): A valid React element (or null) must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : void 0;
            process.env.NODE_ENV !== 'production' ? warning(!Component.childContextTypes, '%s(...): childContextTypes cannot be defined on a functional component.', Component.displayName || Component.name || 'Component') : void 0;
        }
    }
    function shouldConstruct(Component) {
        return !!(Component.prototype && Component.prototype.isReactComponent);
    }
    function isPureComponent(Component) {
        return !!(Component.prototype && Component.prototype.isPureReactComponent);
    }
    function measureLifeCyclePerf(fn, debugID, timerType) {
        if (debugID === 0) {
            return fn();
        }
        ReactInstrumentation.debugTool.onBeginLifeCycleTimer(debugID, timerType);
        try {
            return fn();
        } finally {
            ReactInstrumentation.debugTool.onEndLifeCycleTimer(debugID, timerType);
        }
    }
    var nextMountID = 1;
    var ReactCompositeComponent = {
        construct: function (element) {
            this._currentElement = element;
            this._rootNodeID = 0;
            this._compositeType = null;
            this._instance = null;
            this._hostParent = null;
            this._hostContainerInfo = null;
            this._updateBatchNumber = null;
            this._pendingElement = null;
            this._pendingStateQueue = null;
            this._pendingReplaceState = false;
            this._pendingForceUpdate = false;
            this._renderedNodeType = null;
            this._renderedComponent = null;
            this._context = null;
            this._mountOrder = 0;
            this._topLevelWrapper = null;
            this._pendingCallbacks = null;
            this._calledComponentWillUnmount = false;
            if (process.env.NODE_ENV !== 'production') {
                this._warnedAboutRefsInRender = false;
            }
        },
        mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
            var _this = this;
            this._context = context;
            this._mountOrder = nextMountID++;
            this._hostParent = hostParent;
            this._hostContainerInfo = hostContainerInfo;
            var publicProps = this._currentElement.props;
            var publicContext = this._processContext(context);
            var Component = this._currentElement.type;
            var updateQueue = transaction.getUpdateQueue();
            var doConstruct = shouldConstruct(Component);
            var inst = this._constructComponent(doConstruct, publicProps, publicContext, updateQueue);
            var renderedElement;
            if (!doConstruct && (inst == null || inst.render == null)) {
                renderedElement = inst;
                warnIfInvalidElement(Component, renderedElement);
                !(inst === null || inst === false || React.isValidElement(inst)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s(...): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : _prodInvariant('105', Component.displayName || Component.name || 'Component') : void 0;
                inst = new StatelessComponent(Component);
                this._compositeType = CompositeTypes.StatelessFunctional;
            } else {
                if (isPureComponent(Component)) {
                    this._compositeType = CompositeTypes.PureClass;
                } else {
                    this._compositeType = CompositeTypes.ImpureClass;
                }
            }
            if (process.env.NODE_ENV !== 'production') {
                if (inst.render == null) {
                    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', Component.displayName || Component.name || 'Component') : void 0;
                }
                var propsMutated = inst.props !== publicProps;
                var componentName = Component.displayName || Component.name || 'Component';
                process.env.NODE_ENV !== 'production' ? warning(inst.props === undefined || !propsMutated, '%s(...): When calling super() in `%s`, make sure to pass ' + 'up the same props that your component\'s constructor was passed.', componentName, componentName) : void 0;
            }
            inst.props = publicProps;
            inst.context = publicContext;
            inst.refs = emptyObject;
            inst.updater = updateQueue;
            this._instance = inst;
            ReactInstanceMap.set(inst, this);
            if (process.env.NODE_ENV !== 'production') {
                process.env.NODE_ENV !== 'production' ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved || inst.state, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component') : void 0;
                process.env.NODE_ENV !== 'production' ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component') : void 0;
                process.env.NODE_ENV !== 'production' ? warning(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component') : void 0;
                process.env.NODE_ENV !== 'production' ? warning(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component') : void 0;
                process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component') : void 0;
                process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentDidUnmount !== 'function', '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', this.getName() || 'A component') : void 0;
                process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentWillRecieveProps !== 'function', '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', this.getName() || 'A component') : void 0;
            }
            var initialState = inst.state;
            if (initialState === undefined) {
                inst.state = initialState = null;
            }
            !(typeof initialState === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent') : _prodInvariant('106', this.getName() || 'ReactCompositeComponent') : void 0;
            this._pendingStateQueue = null;
            this._pendingReplaceState = false;
            this._pendingForceUpdate = false;
            var markup;
            if (inst.unstable_handleError) {
                markup = this.performInitialMountWithErrorHandling(renderedElement, hostParent, hostContainerInfo, transaction, context);
            } else {
                markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
            }
            if (inst.componentDidMount) {
                if (process.env.NODE_ENV !== 'production') {
                    transaction.getReactMountReady().enqueue(function () {
                        measureLifeCyclePerf(function () {
                            return inst.componentDidMount();
                        }, _this._debugID, 'componentDidMount');
                    });
                } else {
                    transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
                }
            }
            return markup;
        },
        _constructComponent: function (doConstruct, publicProps, publicContext, updateQueue) {
            if (process.env.NODE_ENV !== 'production') {
                ReactCurrentOwner.current = this;
                try {
                    return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
                } finally {
                    ReactCurrentOwner.current = null;
                }
            } else {
                return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
            }
        },
        _constructComponentWithoutOwner: function (doConstruct, publicProps, publicContext, updateQueue) {
            var Component = this._currentElement.type;
            if (doConstruct) {
                if (process.env.NODE_ENV !== 'production') {
                    return measureLifeCyclePerf(function () {
                        return new Component(publicProps, publicContext, updateQueue);
                    }, this._debugID, 'ctor');
                } else {
                    return new Component(publicProps, publicContext, updateQueue);
                }
            }
            if (process.env.NODE_ENV !== 'production') {
                return measureLifeCyclePerf(function () {
                    return Component(publicProps, publicContext, updateQueue);
                }, this._debugID, 'render');
            } else {
                return Component(publicProps, publicContext, updateQueue);
            }
        },
        performInitialMountWithErrorHandling: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
            var markup;
            var checkpoint = transaction.checkpoint();
            try {
                markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
            } catch (e) {
                transaction.rollback(checkpoint);
                this._instance.unstable_handleError(e);
                if (this._pendingStateQueue) {
                    this._instance.state = this._processPendingState(this._instance.props, this._instance.context);
                }
                checkpoint = transaction.checkpoint();
                this._renderedComponent.unmountComponent(true);
                transaction.rollback(checkpoint);
                markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
            }
            return markup;
        },
        performInitialMount: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
            var inst = this._instance;
            var debugID = 0;
            if (process.env.NODE_ENV !== 'production') {
                debugID = this._debugID;
            }
            if (inst.componentWillMount) {
                if (process.env.NODE_ENV !== 'production') {
                    measureLifeCyclePerf(function () {
                        return inst.componentWillMount();
                    }, debugID, 'componentWillMount');
                } else {
                    inst.componentWillMount();
                }
                if (this._pendingStateQueue) {
                    inst.state = this._processPendingState(inst.props, inst.context);
                }
            }
            if (renderedElement === undefined) {
                renderedElement = this._renderValidatedComponent();
            }
            var nodeType = ReactNodeTypes.getType(renderedElement);
            this._renderedNodeType = nodeType;
            var child = this._instantiateReactComponent(renderedElement, nodeType !== ReactNodeTypes.EMPTY);
            this._renderedComponent = child;
            var markup = ReactReconciler.mountComponent(child, transaction, hostParent, hostContainerInfo, this._processChildContext(context), debugID);
            if (process.env.NODE_ENV !== 'production') {
                if (debugID !== 0) {
                    var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
                    ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);
                }
            }
            return markup;
        },
        getHostNode: function () {
            return ReactReconciler.getHostNode(this._renderedComponent);
        },
        unmountComponent: function (safely) {
            if (!this._renderedComponent) {
                return;
            }
            var inst = this._instance;
            if (inst.componentWillUnmount && !inst._calledComponentWillUnmount) {
                inst._calledComponentWillUnmount = true;
                if (safely) {
                    var name = this.getName() + '.componentWillUnmount()';
                    ReactErrorUtils.invokeGuardedCallback(name, inst.componentWillUnmount.bind(inst));
                } else {
                    if (process.env.NODE_ENV !== 'production') {
                        measureLifeCyclePerf(function () {
                            return inst.componentWillUnmount();
                        }, this._debugID, 'componentWillUnmount');
                    } else {
                        inst.componentWillUnmount();
                    }
                }
            }
            if (this._renderedComponent) {
                ReactReconciler.unmountComponent(this._renderedComponent, safely);
                this._renderedNodeType = null;
                this._renderedComponent = null;
                this._instance = null;
            }
            this._pendingStateQueue = null;
            this._pendingReplaceState = false;
            this._pendingForceUpdate = false;
            this._pendingCallbacks = null;
            this._pendingElement = null;
            this._context = null;
            this._rootNodeID = 0;
            this._topLevelWrapper = null;
            ReactInstanceMap.remove(inst);
        },
        _maskContext: function (context) {
            var Component = this._currentElement.type;
            var contextTypes = Component.contextTypes;
            if (!contextTypes) {
                return emptyObject;
            }
            var maskedContext = {};
            for (var contextName in contextTypes) {
                maskedContext[contextName] = context[contextName];
            }
            return maskedContext;
        },
        _processContext: function (context) {
            var maskedContext = this._maskContext(context);
            if (process.env.NODE_ENV !== 'production') {
                var Component = this._currentElement.type;
                if (Component.contextTypes) {
                    this._checkContextTypes(Component.contextTypes, maskedContext, 'context');
                }
            }
            return maskedContext;
        },
        _processChildContext: function (currentContext) {
            var Component = this._currentElement.type;
            var inst = this._instance;
            var childContext;
            if (inst.getChildContext) {
                if (process.env.NODE_ENV !== 'production') {
                    ReactInstrumentation.debugTool.onBeginProcessingChildContext();
                    try {
                        childContext = inst.getChildContext();
                    } finally {
                        ReactInstrumentation.debugTool.onEndProcessingChildContext();
                    }
                } else {
                    childContext = inst.getChildContext();
                }
            }
            if (childContext) {
                !(typeof Component.childContextTypes === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().', this.getName() || 'ReactCompositeComponent') : _prodInvariant('107', this.getName() || 'ReactCompositeComponent') : void 0;
                if (process.env.NODE_ENV !== 'production') {
                    this._checkContextTypes(Component.childContextTypes, childContext, 'child context');
                }
                for (var name in childContext) {
                    !(name in Component.childContextTypes) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : _prodInvariant('108', this.getName() || 'ReactCompositeComponent', name) : void 0;
                }
                return _assign({}, currentContext, childContext);
            }
            return currentContext;
        },
        _checkContextTypes: function (typeSpecs, values, location) {
            if (process.env.NODE_ENV !== 'production') {
                checkReactTypeSpec(typeSpecs, values, location, this.getName(), null, this._debugID);
            }
        },
        receiveComponent: function (nextElement, transaction, nextContext) {
            var prevElement = this._currentElement;
            var prevContext = this._context;
            this._pendingElement = null;
            this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);
        },
        performUpdateIfNecessary: function (transaction) {
            if (this._pendingElement != null) {
                ReactReconciler.receiveComponent(this, this._pendingElement, transaction, this._context);
            } else if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
                this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);
            } else {
                this._updateBatchNumber = null;
            }
        },
        updateComponent: function (transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {
            var inst = this._instance;
            !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Attempted to update component `%s` that has already been unmounted (or failed to mount).', this.getName() || 'ReactCompositeComponent') : _prodInvariant('136', this.getName() || 'ReactCompositeComponent') : void 0;
            var willReceive = false;
            var nextContext;
            if (this._context === nextUnmaskedContext) {
                nextContext = inst.context;
            } else {
                nextContext = this._processContext(nextUnmaskedContext);
                willReceive = true;
            }
            var prevProps = prevParentElement.props;
            var nextProps = nextParentElement.props;
            if (prevParentElement !== nextParentElement) {
                willReceive = true;
            }
            if (willReceive && inst.componentWillReceiveProps) {
                if (process.env.NODE_ENV !== 'production') {
                    measureLifeCyclePerf(function () {
                        return inst.componentWillReceiveProps(nextProps, nextContext);
                    }, this._debugID, 'componentWillReceiveProps');
                } else {
                    inst.componentWillReceiveProps(nextProps, nextContext);
                }
            }
            var nextState = this._processPendingState(nextProps, nextContext);
            var shouldUpdate = true;
            if (!this._pendingForceUpdate) {
                if (inst.shouldComponentUpdate) {
                    if (process.env.NODE_ENV !== 'production') {
                        shouldUpdate = measureLifeCyclePerf(function () {
                            return inst.shouldComponentUpdate(nextProps, nextState, nextContext);
                        }, this._debugID, 'shouldComponentUpdate');
                    } else {
                        shouldUpdate = inst.shouldComponentUpdate(nextProps, nextState, nextContext);
                    }
                } else {
                    if (this._compositeType === CompositeTypes.PureClass) {
                        shouldUpdate = !shallowEqual(prevProps, nextProps) || !shallowEqual(inst.state, nextState);
                    }
                }
            }
            if (process.env.NODE_ENV !== 'production') {
                process.env.NODE_ENV !== 'production' ? warning(shouldUpdate !== undefined, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent') : void 0;
            }
            this._updateBatchNumber = null;
            if (shouldUpdate) {
                this._pendingForceUpdate = false;
                this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);
            } else {
                this._currentElement = nextParentElement;
                this._context = nextUnmaskedContext;
                inst.props = nextProps;
                inst.state = nextState;
                inst.context = nextContext;
            }
        },
        _processPendingState: function (props, context) {
            var inst = this._instance;
            var queue = this._pendingStateQueue;
            var replace = this._pendingReplaceState;
            this._pendingReplaceState = false;
            this._pendingStateQueue = null;
            if (!queue) {
                return inst.state;
            }
            if (replace && queue.length === 1) {
                return queue[0];
            }
            var nextState = _assign({}, replace ? queue[0] : inst.state);
            for (var i = replace ? 1 : 0; i < queue.length; i++) {
                var partial = queue[i];
                _assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
            }
            return nextState;
        },
        _performComponentUpdate: function (nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {
            var _this2 = this;
            var inst = this._instance;
            var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);
            var prevProps;
            var prevState;
            var prevContext;
            if (hasComponentDidUpdate) {
                prevProps = inst.props;
                prevState = inst.state;
                prevContext = inst.context;
            }
            if (inst.componentWillUpdate) {
                if (process.env.NODE_ENV !== 'production') {
                    measureLifeCyclePerf(function () {
                        return inst.componentWillUpdate(nextProps, nextState, nextContext);
                    }, this._debugID, 'componentWillUpdate');
                } else {
                    inst.componentWillUpdate(nextProps, nextState, nextContext);
                }
            }
            this._currentElement = nextElement;
            this._context = unmaskedContext;
            inst.props = nextProps;
            inst.state = nextState;
            inst.context = nextContext;
            this._updateRenderedComponent(transaction, unmaskedContext);
            if (hasComponentDidUpdate) {
                if (process.env.NODE_ENV !== 'production') {
                    transaction.getReactMountReady().enqueue(function () {
                        measureLifeCyclePerf(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), _this2._debugID, 'componentDidUpdate');
                    });
                } else {
                    transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);
                }
            }
        },
        _updateRenderedComponent: function (transaction, context) {
            var prevComponentInstance = this._renderedComponent;
            var prevRenderedElement = prevComponentInstance._currentElement;
            var nextRenderedElement = this._renderValidatedComponent();
            var debugID = 0;
            if (process.env.NODE_ENV !== 'production') {
                debugID = this._debugID;
            }
            if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
                ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));
            } else {
                var oldHostNode = ReactReconciler.getHostNode(prevComponentInstance);
                ReactReconciler.unmountComponent(prevComponentInstance, false);
                var nodeType = ReactNodeTypes.getType(nextRenderedElement);
                this._renderedNodeType = nodeType;
                var child = this._instantiateReactComponent(nextRenderedElement, nodeType !== ReactNodeTypes.EMPTY);
                this._renderedComponent = child;
                var nextMarkup = ReactReconciler.mountComponent(child, transaction, this._hostParent, this._hostContainerInfo, this._processChildContext(context), debugID);
                if (process.env.NODE_ENV !== 'production') {
                    if (debugID !== 0) {
                        var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
                        ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);
                    }
                }
                this._replaceNodeWithMarkup(oldHostNode, nextMarkup, prevComponentInstance);
            }
        },
        _replaceNodeWithMarkup: function (oldHostNode, nextMarkup, prevInstance) {
            ReactComponentEnvironment.replaceNodeWithMarkup(oldHostNode, nextMarkup, prevInstance);
        },
        _renderValidatedComponentWithoutOwnerOrContext: function () {
            var inst = this._instance;
            var renderedElement;
            if (process.env.NODE_ENV !== 'production') {
                renderedElement = measureLifeCyclePerf(function () {
                    return inst.render();
                }, this._debugID, 'render');
            } else {
                renderedElement = inst.render();
            }
            if (process.env.NODE_ENV !== 'production') {
                if (renderedElement === undefined && inst.render._isMockFunction) {
                    renderedElement = null;
                }
            }
            return renderedElement;
        },
        _renderValidatedComponent: function () {
            var renderedElement;
            if (process.env.NODE_ENV !== 'production' || this._compositeType !== CompositeTypes.StatelessFunctional) {
                ReactCurrentOwner.current = this;
                try {
                    renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();
                } finally {
                    ReactCurrentOwner.current = null;
                }
            } else {
                renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();
            }
            !(renderedElement === null || renderedElement === false || React.isValidElement(renderedElement)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.render(): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', this.getName() || 'ReactCompositeComponent') : _prodInvariant('109', this.getName() || 'ReactCompositeComponent') : void 0;
            return renderedElement;
        },
        attachRef: function (ref, component) {
            var inst = this.getPublicInstance();
            !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Stateless function components cannot have refs.') : _prodInvariant('110') : void 0;
            var publicComponentInstance = component.getPublicInstance();
            if (process.env.NODE_ENV !== 'production') {
                var componentName = component && component.getName ? component.getName() : 'a component';
                process.env.NODE_ENV !== 'production' ? warning(publicComponentInstance != null || component._compositeType !== CompositeTypes.StatelessFunctional, 'Stateless function components cannot be given refs ' + '(See ref "%s" in %s created by %s). ' + 'Attempts to access this ref will fail.', ref, componentName, this.getName()) : void 0;
            }
            var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
            refs[ref] = publicComponentInstance;
        },
        detachRef: function (ref) {
            var refs = this.getPublicInstance().refs;
            delete refs[ref];
        },
        getName: function () {
            var type = this._currentElement.type;
            var constructor = this._instance && this._instance.constructor;
            return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;
        },
        getPublicInstance: function () {
            var inst = this._instance;
            if (this._compositeType === CompositeTypes.StatelessFunctional) {
                return null;
            }
            return inst;
        },
        _instantiateReactComponent: null
    };
    module.exports = ReactCompositeComponent;
});
/*react-dom@15.6.1#lib/ReactEmptyComponent*/
define('react-dom@15.6.1#lib/ReactEmptyComponent', function (require, exports, module) {
    'use strict';
    var emptyComponentFactory;
    var ReactEmptyComponentInjection = {
        injectEmptyComponentFactory: function (factory) {
            emptyComponentFactory = factory;
        }
    };
    var ReactEmptyComponent = {
        create: function (instantiate) {
            return emptyComponentFactory(instantiate);
        }
    };
    ReactEmptyComponent.injection = ReactEmptyComponentInjection;
    module.exports = ReactEmptyComponent;
});
/*react-dom@15.6.1#lib/ReactHostComponent*/
define('react-dom@15.6.1#lib/ReactHostComponent', function (require, exports, module) {
    'use strict';
    var _prodInvariant = require('./reactProdInvariant');
    var invariant = require('fbjs/lib/invariant');
    var genericComponentClass = null;
    var textComponentClass = null;
    var ReactHostComponentInjection = {
        injectGenericComponentClass: function (componentClass) {
            genericComponentClass = componentClass;
        },
        injectTextComponentClass: function (componentClass) {
            textComponentClass = componentClass;
        }
    };
    function createInternalComponent(element) {
        !genericComponentClass ? process.env.NODE_ENV !== 'production' ? invariant(false, 'There is no registered component for the tag %s', element.type) : _prodInvariant('111', element.type) : void 0;
        return new genericComponentClass(element);
    }
    function createInstanceForText(text) {
        return new textComponentClass(text);
    }
    function isTextComponent(component) {
        return component instanceof textComponentClass;
    }
    var ReactHostComponent = {
        createInternalComponent: createInternalComponent,
        createInstanceForText: createInstanceForText,
        isTextComponent: isTextComponent,
        injection: ReactHostComponentInjection
    };
    module.exports = ReactHostComponent;
});
/*react@15.6.1#lib/getNextDebugID*/
define('react@15.6.1#lib/getNextDebugID', function (require, exports, module) {
    'use strict';
    var nextDebugID = 1;
    function getNextDebugID() {
        return nextDebugID++;
    }
    module.exports = getNextDebugID;
});
/*react-dom@15.6.1#lib/instantiateReactComponent*/
define('react-dom@15.6.1#lib/instantiateReactComponent', function (require, exports, module) {
    'use strict';
    var _prodInvariant = require('./reactProdInvariant'), _assign = require('object-assign');
    var ReactCompositeComponent = require('./ReactCompositeComponent');
    var ReactEmptyComponent = require('./ReactEmptyComponent');
    var ReactHostComponent = require('./ReactHostComponent');
    var getNextDebugID = require('react/lib/getNextDebugID');
    var invariant = require('fbjs/lib/invariant');
    var warning = require('fbjs/lib/warning');
    var ReactCompositeComponentWrapper = function (element) {
        this.construct(element);
    };
    function getDeclarationErrorAddendum(owner) {
        if (owner) {
            var name = owner.getName();
            if (name) {
                return ' Check the render method of `' + name + '`.';
            }
        }
        return '';
    }
    function isInternalComponentType(type) {
        return typeof type === 'function' && typeof type.prototype !== 'undefined' && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';
    }
    function instantiateReactComponent(node, shouldHaveDebugID) {
        var instance;
        if (node === null || node === false) {
            instance = ReactEmptyComponent.create(instantiateReactComponent);
        } else if (typeof node === 'object') {
            var element = node;
            var type = element.type;
            if (typeof type !== 'function' && typeof type !== 'string') {
                var info = '';
                if (process.env.NODE_ENV !== 'production') {
                    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
                        info += ' You likely forgot to export your component from the file ' + 'it\'s defined in.';
                    }
                }
                info += getDeclarationErrorAddendum(element._owner);
                !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s', type == null ? type : typeof type, info) : _prodInvariant('130', type == null ? type : typeof type, info) : void 0;
            }
            if (typeof element.type === 'string') {
                instance = ReactHostComponent.createInternalComponent(element);
            } else if (isInternalComponentType(element.type)) {
                instance = new element.type(element);
                if (!instance.getHostNode) {
                    instance.getHostNode = instance.getNativeNode;
                }
            } else {
                instance = new ReactCompositeComponentWrapper(element);
            }
        } else if (typeof node === 'string' || typeof node === 'number') {
            instance = ReactHostComponent.createInstanceForText(node);
        } else {
            !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Encountered invalid React node of type %s', typeof node) : _prodInvariant('131', typeof node) : void 0;
        }
        if (process.env.NODE_ENV !== 'production') {
            process.env.NODE_ENV !== 'production' ? warning(typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function' && typeof instance.getHostNode === 'function' && typeof instance.unmountComponent === 'function', 'Only React Components can be mounted.') : void 0;
        }
        instance._mountIndex = 0;
        instance._mountImage = null;
        if (process.env.NODE_ENV !== 'production') {
            instance._debugID = shouldHaveDebugID ? getNextDebugID() : 0;
        }
        if (process.env.NODE_ENV !== 'production') {
            if (Object.preventExtensions) {
                Object.preventExtensions(instance);
            }
        }
        return instance;
    }
    _assign(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent, { _instantiateReactComponent: instantiateReactComponent });
    module.exports = instantiateReactComponent;
});
/*react-dom@15.6.1#lib/KeyEscapeUtils*/
define('react-dom@15.6.1#lib/KeyEscapeUtils', function (require, exports, module) {
    'use strict';
    function escape(key) {
        var escapeRegex = /[=:]/g;
        var escaperLookup = {
            '=': '=0',
            ':': '=2'
        };
        var escapedString = ('' + key).replace(escapeRegex, function (match) {
            return escaperLookup[match];
        });
        return '$' + escapedString;
    }
    function unescape(key) {
        var unescapeRegex = /(=0|=2)/g;
        var unescaperLookup = {
            '=0': '=',
            '=2': ':'
        };
        var keySubstring = key[0] === '.' && key[1] === '$' ? key.substring(2) : key.substring(1);
        return ('' + keySubstring).replace(unescapeRegex, function (match) {
            return unescaperLookup[match];
        });
    }
    var KeyEscapeUtils = {
        escape: escape,
        unescape: unescape
    };
    module.exports = KeyEscapeUtils;
});
/*react-dom@15.6.1#lib/ReactElementSymbol*/
define('react-dom@15.6.1#lib/ReactElementSymbol', function (require, exports, module) {
    'use strict';
    var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 60103;
    module.exports = REACT_ELEMENT_TYPE;
});
/*react-dom@15.6.1#lib/getIteratorFn*/
define('react-dom@15.6.1#lib/getIteratorFn', function (require, exports, module) {
    (function (global) {
        'use strict';
        var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = '@@iterator';
        function getIteratorFn(maybeIterable) {
            var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
            if (typeof iteratorFn === 'function') {
                return iteratorFn;
            }
        }
        module.exports = getIteratorFn;
    }(function () {
        return this;
    }()));
});
/*react-dom@15.6.1#lib/traverseAllChildren*/
define('react-dom@15.6.1#lib/traverseAllChildren', function (require, exports, module) {
    'use strict';
    var _prodInvariant = require('./reactProdInvariant');
    var ReactCurrentOwner = require('react/lib/ReactCurrentOwner');
    var REACT_ELEMENT_TYPE = require('./ReactElementSymbol');
    var getIteratorFn = require('./getIteratorFn');
    var invariant = require('fbjs/lib/invariant');
    var KeyEscapeUtils = require('./KeyEscapeUtils');
    var warning = require('fbjs/lib/warning');
    var SEPARATOR = '.';
    var SUBSEPARATOR = ':';
    var didWarnAboutMaps = false;
    function getComponentKey(component, index) {
        if (component && typeof component === 'object' && component.key != null) {
            return KeyEscapeUtils.escape(component.key);
        }
        return index.toString(36);
    }
    function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
        var type = typeof children;
        if (type === 'undefined' || type === 'boolean') {
            children = null;
        }
        if (children === null || type === 'string' || type === 'number' || type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE) {
            callback(traverseContext, children, nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
            return 1;
        }
        var child;
        var nextName;
        var subtreeCount = 0;
        var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;
        if (Array.isArray(children)) {
            for (var i = 0; i < children.length; i++) {
                child = children[i];
                nextName = nextNamePrefix + getComponentKey(child, i);
                subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
            }
        } else {
            var iteratorFn = getIteratorFn(children);
            if (iteratorFn) {
                var iterator = iteratorFn.call(children);
                var step;
                if (iteratorFn !== children.entries) {
                    var ii = 0;
                    while (!(step = iterator.next()).done) {
                        child = step.value;
                        nextName = nextNamePrefix + getComponentKey(child, ii++);
                        subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
                    }
                } else {
                    if (process.env.NODE_ENV !== 'production') {
                        var mapsAsChildrenAddendum = '';
                        if (ReactCurrentOwner.current) {
                            var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();
                            if (mapsAsChildrenOwnerName) {
                                mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';
                            }
                        }
                        process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;
                        didWarnAboutMaps = true;
                    }
                    while (!(step = iterator.next()).done) {
                        var entry = step.value;
                        if (entry) {
                            child = entry[1];
                            nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
                            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
                        }
                    }
                }
            } else if (type === 'object') {
                var addendum = '';
                if (process.env.NODE_ENV !== 'production') {
                    addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
                    if (children._isReactElement) {
                        addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
                    }
                    if (ReactCurrentOwner.current) {
                        var name = ReactCurrentOwner.current.getName();
                        if (name) {
                            addendum += ' Check the render method of `' + name + '`.';
                        }
                    }
                }
                var childrenString = String(children);
                !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : void 0;
            }
        }
        return subtreeCount;
    }
    function traverseAllChildren(children, callback, traverseContext) {
        if (children == null) {
            return 0;
        }
        return traverseAllChildrenImpl(children, '', callback, traverseContext);
    }
    module.exports = traverseAllChildren;
});
/*react-dom@15.6.1#lib/ReactChildReconciler*/
define('react-dom@15.6.1#lib/ReactChildReconciler', function (require, exports, module) {
    'use strict';
    var ReactReconciler = require('./ReactReconciler');
    var instantiateReactComponent = require('./instantiateReactComponent');
    var KeyEscapeUtils = require('./KeyEscapeUtils');
    var shouldUpdateReactComponent = require('./shouldUpdateReactComponent');
    var traverseAllChildren = require('./traverseAllChildren');
    var warning = require('fbjs/lib/warning');
    var ReactComponentTreeHook;
    if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
        ReactComponentTreeHook = require('react/lib/ReactComponentTreeHook');
    }
    function instantiateChild(childInstances, child, name, selfDebugID) {
        var keyUnique = childInstances[name] === undefined;
        if (process.env.NODE_ENV !== 'production') {
            if (!ReactComponentTreeHook) {
                ReactComponentTreeHook = require('react/lib/ReactComponentTreeHook');
            }
            if (!keyUnique) {
                process.env.NODE_ENV !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;
            }
        }
        if (child != null && keyUnique) {
            childInstances[name] = instantiateReactComponent(child, true);
        }
    }
    var ReactChildReconciler = {
        instantiateChildren: function (nestedChildNodes, transaction, context, selfDebugID) {
            if (nestedChildNodes == null) {
                return null;
            }
            var childInstances = {};
            if (process.env.NODE_ENV !== 'production') {
                traverseAllChildren(nestedChildNodes, function (childInsts, child, name) {
                    return instantiateChild(childInsts, child, name, selfDebugID);
                }, childInstances);
            } else {
                traverseAllChildren(nestedChildNodes, instantiateChild, childInstances);
            }
            return childInstances;
        },
        updateChildren: function (prevChildren, nextChildren, mountImages, removedNodes, transaction, hostParent, hostContainerInfo, context, selfDebugID) {
            if (!nextChildren && !prevChildren) {
                return;
            }
            var name;
            var prevChild;
            for (name in nextChildren) {
                if (!nextChildren.hasOwnProperty(name)) {
                    continue;
                }
                prevChild = prevChildren && prevChildren[name];
                var prevElement = prevChild && prevChild._currentElement;
                var nextElement = nextChildren[name];
                if (prevChild != null && shouldUpdateReactComponent(prevElement, nextElement)) {
                    ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
                    nextChildren[name] = prevChild;
                } else {
                    if (prevChild) {
                        removedNodes[name] = ReactReconciler.getHostNode(prevChild);
                        ReactReconciler.unmountComponent(prevChild, false);
                    }
                    var nextChildInstance = instantiateReactComponent(nextElement, true);
                    nextChildren[name] = nextChildInstance;
                    var nextChildMountImage = ReactReconciler.mountComponent(nextChildInstance, transaction, hostParent, hostContainerInfo, context, selfDebugID);
                    mountImages.push(nextChildMountImage);
                }
            }
            for (name in prevChildren) {
                if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
                    prevChild = prevChildren[name];
                    removedNodes[name] = ReactReconciler.getHostNode(prevChild);
                    ReactReconciler.unmountComponent(prevChild, false);
                }
            }
        },
        unmountChildren: function (renderedChildren, safely) {
            for (var name in renderedChildren) {
                if (renderedChildren.hasOwnProperty(name)) {
                    var renderedChild = renderedChildren[name];
                    ReactReconciler.unmountComponent(renderedChild, safely);
                }
            }
        }
    };
    module.exports = ReactChildReconciler;
});
/*react-dom@15.6.1#lib/flattenChildren*/
define('react-dom@15.6.1#lib/flattenChildren', function (require, exports, module) {
    'use strict';
    var KeyEscapeUtils = require('./KeyEscapeUtils');
    var traverseAllChildren = require('./traverseAllChildren');
    var warning = require('fbjs/lib/warning');
    var ReactComponentTreeHook;
    if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
        ReactComponentTreeHook = require('react/lib/ReactComponentTreeHook');
    }
    function flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID) {
        if (traverseContext && typeof traverseContext === 'object') {
            var result = traverseContext;
            var keyUnique = result[name] === undefined;
            if (process.env.NODE_ENV !== 'production') {
                if (!ReactComponentTreeHook) {
                    ReactComponentTreeHook = require('react/lib/ReactComponentTreeHook');
                }
                if (!keyUnique) {
                    process.env.NODE_ENV !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;
                }
            }
            if (keyUnique && child != null) {
                result[name] = child;
            }
        }
    }
    function flattenChildren(children, selfDebugID) {
        if (children == null) {
            return children;
        }
        var result = {};
        if (process.env.NODE_ENV !== 'production') {
            traverseAllChildren(children, function (traverseContext, child, name) {
                return flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID);
            }, result);
        } else {
            traverseAllChildren(children, flattenSingleChildIntoContext, result);
        }
        return result;
    }
    module.exports = flattenChildren;
});
/*react-dom@15.6.1#lib/ReactMultiChild*/
define('react-dom@15.6.1#lib/ReactMultiChild', function (require, exports, module) {
    'use strict';
    var _prodInvariant = require('./reactProdInvariant');
    var ReactComponentEnvironment = require('./ReactComponentEnvironment');
    var ReactInstanceMap = require('./ReactInstanceMap');
    var ReactInstrumentation = require('./ReactInstrumentation');
    var ReactCurrentOwner = require('react/lib/ReactCurrentOwner');
    var ReactReconciler = require('./ReactReconciler');
    var ReactChildReconciler = require('./ReactChildReconciler');
    var emptyFunction = require('fbjs/lib/emptyFunction');
    var flattenChildren = require('./flattenChildren');
    var invariant = require('fbjs/lib/invariant');
    function makeInsertMarkup(markup, afterNode, toIndex) {
        return {
            type: 'INSERT_MARKUP',
            content: markup,
            fromIndex: null,
            fromNode: null,
            toIndex: toIndex,
            afterNode: afterNode
        };
    }
    function makeMove(child, afterNode, toIndex) {
        return {
            type: 'MOVE_EXISTING',
            content: null,
            fromIndex: child._mountIndex,
            fromNode: ReactReconciler.getHostNode(child),
            toIndex: toIndex,
            afterNode: afterNode
        };
    }
    function makeRemove(child, node) {
        return {
            type: 'REMOVE_NODE',
            content: null,
            fromIndex: child._mountIndex,
            fromNode: node,
            toIndex: null,
            afterNode: null
        };
    }
    function makeSetMarkup(markup) {
        return {
            type: 'SET_MARKUP',
            content: markup,
            fromIndex: null,
            fromNode: null,
            toIndex: null,
            afterNode: null
        };
    }
    function makeTextContent(textContent) {
        return {
            type: 'TEXT_CONTENT',
            content: textContent,
            fromIndex: null,
            fromNode: null,
            toIndex: null,
            afterNode: null
        };
    }
    function enqueue(queue, update) {
        if (update) {
            queue = queue || [];
            queue.push(update);
        }
        return queue;
    }
    function processQueue(inst, updateQueue) {
        ReactComponentEnvironment.processChildrenUpdates(inst, updateQueue);
    }
    var setChildrenForInstrumentation = emptyFunction;
    if (process.env.NODE_ENV !== 'production') {
        var getDebugID = function (inst) {
            if (!inst._debugID) {
                var internal;
                if (internal = ReactInstanceMap.get(inst)) {
                    inst = internal;
                }
            }
            return inst._debugID;
        };
        setChildrenForInstrumentation = function (children) {
            var debugID = getDebugID(this);
            if (debugID !== 0) {
                ReactInstrumentation.debugTool.onSetChildren(debugID, children ? Object.keys(children).map(function (key) {
                    return children[key]._debugID;
                }) : []);
            }
        };
    }
    var ReactMultiChild = {
        Mixin: {
            _reconcilerInstantiateChildren: function (nestedChildren, transaction, context) {
                if (process.env.NODE_ENV !== 'production') {
                    var selfDebugID = getDebugID(this);
                    if (this._currentElement) {
                        try {
                            ReactCurrentOwner.current = this._currentElement._owner;
                            return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context, selfDebugID);
                        } finally {
                            ReactCurrentOwner.current = null;
                        }
                    }
                }
                return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
            },
            _reconcilerUpdateChildren: function (prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context) {
                var nextChildren;
                var selfDebugID = 0;
                if (process.env.NODE_ENV !== 'production') {
                    selfDebugID = getDebugID(this);
                    if (this._currentElement) {
                        try {
                            ReactCurrentOwner.current = this._currentElement._owner;
                            nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
                        } finally {
                            ReactCurrentOwner.current = null;
                        }
                        ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
                        return nextChildren;
                    }
                }
                nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
                ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
                return nextChildren;
            },
            mountChildren: function (nestedChildren, transaction, context) {
                var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);
                this._renderedChildren = children;
                var mountImages = [];
                var index = 0;
                for (var name in children) {
                    if (children.hasOwnProperty(name)) {
                        var child = children[name];
                        var selfDebugID = 0;
                        if (process.env.NODE_ENV !== 'production') {
                            selfDebugID = getDebugID(this);
                        }
                        var mountImage = ReactReconciler.mountComponent(child, transaction, this, this._hostContainerInfo, context, selfDebugID);
                        child._mountIndex = index++;
                        mountImages.push(mountImage);
                    }
                }
                if (process.env.NODE_ENV !== 'production') {
                    setChildrenForInstrumentation.call(this, children);
                }
                return mountImages;
            },
            updateTextContent: function (nextContent) {
                var prevChildren = this._renderedChildren;
                ReactChildReconciler.unmountChildren(prevChildren, false);
                for (var name in prevChildren) {
                    if (prevChildren.hasOwnProperty(name)) {
                        !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
                    }
                }
                var updates = [makeTextContent(nextContent)];
                processQueue(this, updates);
            },
            updateMarkup: function (nextMarkup) {
                var prevChildren = this._renderedChildren;
                ReactChildReconciler.unmountChildren(prevChildren, false);
                for (var name in prevChildren) {
                    if (prevChildren.hasOwnProperty(name)) {
                        !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
                    }
                }
                var updates = [makeSetMarkup(nextMarkup)];
                processQueue(this, updates);
            },
            updateChildren: function (nextNestedChildrenElements, transaction, context) {
                this._updateChildren(nextNestedChildrenElements, transaction, context);
            },
            _updateChildren: function (nextNestedChildrenElements, transaction, context) {
                var prevChildren = this._renderedChildren;
                var removedNodes = {};
                var mountImages = [];
                var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context);
                if (!nextChildren && !prevChildren) {
                    return;
                }
                var updates = null;
                var name;
                var nextIndex = 0;
                var lastIndex = 0;
                var nextMountIndex = 0;
                var lastPlacedNode = null;
                for (name in nextChildren) {
                    if (!nextChildren.hasOwnProperty(name)) {
                        continue;
                    }
                    var prevChild = prevChildren && prevChildren[name];
                    var nextChild = nextChildren[name];
                    if (prevChild === nextChild) {
                        updates = enqueue(updates, this.moveChild(prevChild, lastPlacedNode, nextIndex, lastIndex));
                        lastIndex = Math.max(prevChild._mountIndex, lastIndex);
                        prevChild._mountIndex = nextIndex;
                    } else {
                        if (prevChild) {
                            lastIndex = Math.max(prevChild._mountIndex, lastIndex);
                        }
                        updates = enqueue(updates, this._mountChildAtIndex(nextChild, mountImages[nextMountIndex], lastPlacedNode, nextIndex, transaction, context));
                        nextMountIndex++;
                    }
                    nextIndex++;
                    lastPlacedNode = ReactReconciler.getHostNode(nextChild);
                }
                for (name in removedNodes) {
                    if (removedNodes.hasOwnProperty(name)) {
                        updates = enqueue(updates, this._unmountChild(prevChildren[name], removedNodes[name]));
                    }
                }
                if (updates) {
                    processQueue(this, updates);
                }
                this._renderedChildren = nextChildren;
                if (process.env.NODE_ENV !== 'production') {
                    setChildrenForInstrumentation.call(this, nextChildren);
                }
            },
            unmountChildren: function (safely) {
                var renderedChildren = this._renderedChildren;
                ReactChildReconciler.unmountChildren(renderedChildren, safely);
                this._renderedChildren = null;
            },
            moveChild: function (child, afterNode, toIndex, lastIndex) {
                if (child._mountIndex < lastIndex) {
                    return makeMove(child, afterNode, toIndex);
                }
            },
            createChild: function (child, afterNode, mountImage) {
                return makeInsertMarkup(mountImage, afterNode, child._mountIndex);
            },
            removeChild: function (child, node) {
                return makeRemove(child, node);
            },
            _mountChildAtIndex: function (child, mountImage, afterNode, index, transaction, context) {
                child._mountIndex = index;
                return this.createChild(child, afterNode, mountImage);
            },
            _unmountChild: function (child, node) {
                var update = this.removeChild(child, node);
                child._mountIndex = null;
                return update;
            }
        }
    };
    module.exports = ReactMultiChild;
});
/*react-dom@15.6.1#lib/ReactUpdateQueue*/
define('react-dom@15.6.1#lib/ReactUpdateQueue', function (require, exports, module) {
    'use strict';
    var _prodInvariant = require('./reactProdInvariant');
    var ReactCurrentOwner = require('react/lib/ReactCurrentOwner');
    var ReactInstanceMap = require('./ReactInstanceMap');
    var ReactInstrumentation = require('./ReactInstrumentation');
    var ReactUpdates = require('./ReactUpdates');
    var invariant = require('fbjs/lib/invariant');
    var warning = require('fbjs/lib/warning');
    function enqueueUpdate(internalInstance) {
        ReactUpdates.enqueueUpdate(internalInstance);
    }
    function formatUnexpectedArgument(arg) {
        var type = typeof arg;
        if (type !== 'object') {
            return type;
        }
        var displayName = arg.constructor && arg.constructor.name || type;
        var keys = Object.keys(arg);
        if (keys.length > 0 && keys.length < 20) {
            return displayName + ' (keys: ' + keys.join(', ') + ')';
        }
        return displayName;
    }
    function getInternalInstanceReadyForUpdate(publicInstance, callerName) {
        var internalInstance = ReactInstanceMap.get(publicInstance);
        if (!internalInstance) {
            if (process.env.NODE_ENV !== 'production') {
                var ctor = publicInstance.constructor;
                process.env.NODE_ENV !== 'production' ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, ctor && (ctor.displayName || ctor.name) || 'ReactClass') : void 0;
            }
            return null;
        }
        if (process.env.NODE_ENV !== 'production') {
            process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '%s(...): Cannot update during an existing state transition (such as ' + 'within `render` or another component\'s constructor). Render methods ' + 'should be a pure function of props and state; constructor ' + 'side-effects are an anti-pattern, but can be moved to ' + '`componentWillMount`.', callerName) : void 0;
        }
        return internalInstance;
    }
    var ReactUpdateQueue = {
        isMounted: function (publicInstance) {
            if (process.env.NODE_ENV !== 'production') {
                var owner = ReactCurrentOwner.current;
                if (owner !== null) {
                    process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
                    owner._warnedAboutRefsInRender = true;
                }
            }
            var internalInstance = ReactInstanceMap.get(publicInstance);
            if (internalInstance) {
                return !!internalInstance._renderedComponent;
            } else {
                return false;
            }
        },
        enqueueCallback: function (publicInstance, callback, callerName) {
            ReactUpdateQueue.validateCallback(callback, callerName);
            var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);
            if (!internalInstance) {
                return null;
            }
            if (internalInstance._pendingCallbacks) {
                internalInstance._pendingCallbacks.push(callback);
            } else {
                internalInstance._pendingCallbacks = [callback];
            }
            enqueueUpdate(internalInstance);
        },
        enqueueCallbackInternal: function (internalInstance, callback) {
            if (internalInstance._pendingCallbacks) {
                internalInstance._pendingCallbacks.push(callback);
            } else {
                internalInstance._pendingCallbacks = [callback];
            }
            enqueueUpdate(internalInstance);
        },
        enqueueForceUpdate: function (publicInstance) {
            var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');
            if (!internalInstance) {
                return;
            }
            internalInstance._pendingForceUpdate = true;
            enqueueUpdate(internalInstance);
        },
        enqueueReplaceState: function (publicInstance, completeState, callback) {
            var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');
            if (!internalInstance) {
                return;
            }
            internalInstance._pendingStateQueue = [completeState];
            internalInstance._pendingReplaceState = true;
            if (callback !== undefined && callback !== null) {
                ReactUpdateQueue.validateCallback(callback, 'replaceState');
                if (internalInstance._pendingCallbacks) {
                    internalInstance._pendingCallbacks.push(callback);
                } else {
                    internalInstance._pendingCallbacks = [callback];
                }
            }
            enqueueUpdate(internalInstance);
        },
        enqueueSetState: function (publicInstance, partialState) {
            if (process.env.NODE_ENV !== 'production') {
                ReactInstrumentation.debugTool.onSetState();
                process.env.NODE_ENV !== 'production' ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : void 0;
            }
            var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');
            if (!internalInstance) {
                return;
            }
            var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
            queue.push(partialState);
            enqueueUpdate(internalInstance);
        },
        enqueueElementInternal: function (internalInstance, nextElement, nextContext) {
            internalInstance._pendingElement = nextElement;
            internalInstance._context = nextContext;
            enqueueUpdate(internalInstance);
        },
        validateCallback: function (callback, callerName) {
            !(!callback || typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.', callerName, formatUnexpectedArgument(callback)) : _prodInvariant('122', callerName, formatUnexpectedArgument(callback)) : void 0;
        }
    };
    module.exports = ReactUpdateQueue;
});
/*react-dom@15.6.1#lib/ReactServerUpdateQueue*/
define('react-dom@15.6.1#lib/ReactServerUpdateQueue', function (require, exports, module) {
    'use strict';
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError('Cannot call a class as a function');
        }
    }
    var ReactUpdateQueue = require('./ReactUpdateQueue');
    var warning = require('fbjs/lib/warning');
    function warnNoop(publicInstance, callerName) {
        if (process.env.NODE_ENV !== 'production') {
            var constructor = publicInstance.constructor;
            process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounting component. ' + 'This usually means you called %s() outside componentWillMount() on the server. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
        }
    }
    var ReactServerUpdateQueue = function () {
        function ReactServerUpdateQueue(transaction) {
            _classCallCheck(this, ReactServerUpdateQueue);
            this.transaction = transaction;
        }
        ReactServerUpdateQueue.prototype.isMounted = function isMounted(publicInstance) {
            return false;
        };
        ReactServerUpdateQueue.prototype.enqueueCallback = function enqueueCallback(publicInstance, callback, callerName) {
            if (this.transaction.isInTransaction()) {
                ReactUpdateQueue.enqueueCallback(publicInstance, callback, callerName);
            }
        };
        ReactServerUpdateQueue.prototype.enqueueForceUpdate = function enqueueForceUpdate(publicInstance) {
            if (this.transaction.isInTransaction()) {
                ReactUpdateQueue.enqueueForceUpdate(publicInstance);
            } else {
                warnNoop(publicInstance, 'forceUpdate');
            }
        };
        ReactServerUpdateQueue.prototype.enqueueReplaceState = function enqueueReplaceState(publicInstance, completeState) {
            if (this.transaction.isInTransaction()) {
                ReactUpdateQueue.enqueueReplaceState(publicInstance, completeState);
            } else {
                warnNoop(publicInstance, 'replaceState');
            }
        };
        ReactServerUpdateQueue.prototype.enqueueSetState = function enqueueSetState(publicInstance, partialState) {
            if (this.transaction.isInTransaction()) {
                ReactUpdateQueue.enqueueSetState(publicInstance, partialState);
            } else {
                warnNoop(publicInstance, 'setState');
            }
        };
        return ReactServerUpdateQueue;
    }();
    module.exports = ReactServerUpdateQueue;
});
/*react-dom@15.6.1#lib/ReactServerRenderingTransaction*/
define('react-dom@15.6.1#lib/ReactServerRenderingTransaction', function (require, exports, module) {
    'use strict';
    var _assign = require('object-assign');
    var PooledClass = require('./PooledClass');
    var Transaction = require('./Transaction');
    var ReactInstrumentation = require('./ReactInstrumentation');
    var ReactServerUpdateQueue = require('./ReactServerUpdateQueue');
    var TRANSACTION_WRAPPERS = [];
    if (process.env.NODE_ENV !== 'production') {
        TRANSACTION_WRAPPERS.push({
            initialize: ReactInstrumentation.debugTool.onBeginFlush,
            close: ReactInstrumentation.debugTool.onEndFlush
        });
    }
    var noopCallbackQueue = {
        enqueue: function () {
        }
    };
    function ReactServerRenderingTransaction(renderToStaticMarkup) {
        this.reinitializeTransaction();
        this.renderToStaticMarkup = renderToStaticMarkup;
        this.useCreateElement = false;
        this.updateQueue = new ReactServerUpdateQueue(this);
    }
    var Mixin = {
        getTransactionWrappers: function () {
            return TRANSACTION_WRAPPERS;
        },
        getReactMountReady: function () {
            return noopCallbackQueue;
        },
        getUpdateQueue: function () {
            return this.updateQueue;
        },
        destructor: function () {
        },
        checkpoint: function () {
        },
        rollback: function () {
        }
    };
    _assign(ReactServerRenderingTransaction.prototype, Transaction, Mixin);
    PooledClass.addPoolingTo(ReactServerRenderingTransaction);
    module.exports = ReactServerRenderingTransaction;
});
/*react-dom@15.6.1#lib/validateDOMNesting*/
define('react-dom@15.6.1#lib/validateDOMNesting', function (require, exports, module) {
    'use strict';
    var _assign = require('object-assign');
    var emptyFunction = require('fbjs/lib/emptyFunction');
    var warning = require('fbjs/lib/warning');
    var validateDOMNesting = emptyFunction;
    if (process.env.NODE_ENV !== 'production') {
        var specialTags = [
            'address',
            'applet',
            'area',
            'article',
            'aside',
            'base',
            'basefont',
            'bgsound',
            'blockquote',
            'body',
            'br',
            'button',
            'caption',
            'center',
            'col',
            'colgroup',
            'dd',
            'details',
            'dir',
            'div',
            'dl',
            'dt',
            'embed',
            'fieldset',
            'figcaption',
            'figure',
            'footer',
            'form',
            'frame',
            'frameset',
            'h1',
            'h2',
            'h3',
            'h4',
            'h5',
            'h6',
            'head',
            'header',
            'hgroup',
            'hr',
            'html',
            'iframe',
            'img',
            'input',
            'isindex',
            'li',
            'link',
            'listing',
            'main',
            'marquee',
            'menu',
            'menuitem',
            'meta',
            'nav',
            'noembed',
            'noframes',
            'noscript',
            'object',
            'ol',
            'p',
            'param',
            'plaintext',
            'pre',
            'script',
            'section',
            'select',
            'source',
            'style',
            'summary',
            'table',
            'tbody',
            'td',
            'template',
            'textarea',
            'tfoot',
            'th',
            'thead',
            'title',
            'tr',
            'track',
            'ul',
            'wbr',
            'xmp'
        ];
        var inScopeTags = [
            'applet',
            'caption',
            'html',
            'table',
            'td',
            'th',
            'marquee',
            'object',
            'template',
            'foreignObject',
            'desc',
            'title'
        ];
        var buttonScopeTags = inScopeTags.concat(['button']);
        var impliedEndTags = [
            'dd',
            'dt',
            'li',
            'option',
            'optgroup',
            'p',
            'rp',
            'rt'
        ];
        var emptyAncestorInfo = {
            current: null,
            formTag: null,
            aTagInScope: null,
            buttonTagInScope: null,
            nobrTagInScope: null,
            pTagInButtonScope: null,
            listItemTagAutoclosing: null,
            dlItemTagAutoclosing: null
        };
        var updatedAncestorInfo = function (oldInfo, tag, instance) {
            var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);
            var info = {
                tag: tag,
                instance: instance
            };
            if (inScopeTags.indexOf(tag) !== -1) {
                ancestorInfo.aTagInScope = null;
                ancestorInfo.buttonTagInScope = null;
                ancestorInfo.nobrTagInScope = null;
            }
            if (buttonScopeTags.indexOf(tag) !== -1) {
                ancestorInfo.pTagInButtonScope = null;
            }
            if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
                ancestorInfo.listItemTagAutoclosing = null;
                ancestorInfo.dlItemTagAutoclosing = null;
            }
            ancestorInfo.current = info;
            if (tag === 'form') {
                ancestorInfo.formTag = info;
            }
            if (tag === 'a') {
                ancestorInfo.aTagInScope = info;
            }
            if (tag === 'button') {
                ancestorInfo.buttonTagInScope = info;
            }
            if (tag === 'nobr') {
                ancestorInfo.nobrTagInScope = info;
            }
            if (tag === 'p') {
                ancestorInfo.pTagInButtonScope = info;
            }
            if (tag === 'li') {
                ancestorInfo.listItemTagAutoclosing = info;
            }
            if (tag === 'dd' || tag === 'dt') {
                ancestorInfo.dlItemTagAutoclosing = info;
            }
            return ancestorInfo;
        };
        var isTagValidWithParent = function (tag, parentTag) {
            switch (parentTag) {
            case 'select':
                return tag === 'option' || tag === 'optgroup' || tag === '#text';
            case 'optgroup':
                return tag === 'option' || tag === '#text';
            case 'option':
                return tag === '#text';
            case 'tr':
                return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';
            case 'tbody':
            case 'thead':
            case 'tfoot':
                return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';
            case 'colgroup':
                return tag === 'col' || tag === 'template';
            case 'table':
                return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';
            case 'head':
                return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';
            case 'html':
                return tag === 'head' || tag === 'body';
            case '#document':
                return tag === 'html';
            }
            switch (tag) {
            case 'h1':
            case 'h2':
            case 'h3':
            case 'h4':
            case 'h5':
            case 'h6':
                return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';
            case 'rp':
            case 'rt':
                return impliedEndTags.indexOf(parentTag) === -1;
            case 'body':
            case 'caption':
            case 'col':
            case 'colgroup':
            case 'frame':
            case 'head':
            case 'html':
            case 'tbody':
            case 'td':
            case 'tfoot':
            case 'th':
            case 'thead':
            case 'tr':
                return parentTag == null;
            }
            return true;
        };
        var findInvalidAncestorForTag = function (tag, ancestorInfo) {
            switch (tag) {
            case 'address':
            case 'article':
            case 'aside':
            case 'blockquote':
            case 'center':
            case 'details':
            case 'dialog':
            case 'dir':
            case 'div':
            case 'dl':
            case 'fieldset':
            case 'figcaption':
            case 'figure':
            case 'footer':
            case 'header':
            case 'hgroup':
            case 'main':
            case 'menu':
            case 'nav':
            case 'ol':
            case 'p':
            case 'section':
            case 'summary':
            case 'ul':
            case 'pre':
            case 'listing':
            case 'table':
            case 'hr':
            case 'xmp':
            case 'h1':
            case 'h2':
            case 'h3':
            case 'h4':
            case 'h5':
            case 'h6':
                return ancestorInfo.pTagInButtonScope;
            case 'form':
                return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
            case 'li':
                return ancestorInfo.listItemTagAutoclosing;
            case 'dd':
            case 'dt':
                return ancestorInfo.dlItemTagAutoclosing;
            case 'button':
                return ancestorInfo.buttonTagInScope;
            case 'a':
                return ancestorInfo.aTagInScope;
            case 'nobr':
                return ancestorInfo.nobrTagInScope;
            }
            return null;
        };
        var findOwnerStack = function (instance) {
            if (!instance) {
                return [];
            }
            var stack = [];
            do {
                stack.push(instance);
            } while (instance = instance._currentElement._owner);
            stack.reverse();
            return stack;
        };
        var didWarn = {};
        validateDOMNesting = function (childTag, childText, childInstance, ancestorInfo) {
            ancestorInfo = ancestorInfo || emptyAncestorInfo;
            var parentInfo = ancestorInfo.current;
            var parentTag = parentInfo && parentInfo.tag;
            if (childText != null) {
                process.env.NODE_ENV !== 'production' ? warning(childTag == null, 'validateDOMNesting: when childText is passed, childTag should be null') : void 0;
                childTag = '#text';
            }
            var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
            var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
            var problematic = invalidParent || invalidAncestor;
            if (problematic) {
                var ancestorTag = problematic.tag;
                var ancestorInstance = problematic.instance;
                var childOwner = childInstance && childInstance._currentElement._owner;
                var ancestorOwner = ancestorInstance && ancestorInstance._currentElement._owner;
                var childOwners = findOwnerStack(childOwner);
                var ancestorOwners = findOwnerStack(ancestorOwner);
                var minStackLen = Math.min(childOwners.length, ancestorOwners.length);
                var i;
                var deepestCommon = -1;
                for (i = 0; i < minStackLen; i++) {
                    if (childOwners[i] === ancestorOwners[i]) {
                        deepestCommon = i;
                    } else {
                        break;
                    }
                }
                var UNKNOWN = '(unknown)';
                var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function (inst) {
                    return inst.getName() || UNKNOWN;
                });
                var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function (inst) {
                    return inst.getName() || UNKNOWN;
                });
                var ownerInfo = [].concat(deepestCommon !== -1 ? childOwners[deepestCommon].getName() || UNKNOWN : [], ancestorOwnerNames, ancestorTag, invalidAncestor ? ['...'] : [], childOwnerNames, childTag).join(' > ');
                var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + ownerInfo;
                if (didWarn[warnKey]) {
                    return;
                }
                didWarn[warnKey] = true;
                var tagDisplayName = childTag;
                var whitespaceInfo = '';
                if (childTag === '#text') {
                    if (/\S/.test(childText)) {
                        tagDisplayName = 'Text nodes';
                    } else {
                        tagDisplayName = 'Whitespace text nodes';
                        whitespaceInfo = ' Make sure you don\'t have any extra whitespace between tags on ' + 'each line of your source code.';
                    }
                } else {
                    tagDisplayName = '<' + childTag + '>';
                }
                if (invalidParent) {
                    var info = '';
                    if (ancestorTag === 'table' && childTag === 'tr') {
                        info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
                    }
                    process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s ' + 'See %s.%s', tagDisplayName, ancestorTag, whitespaceInfo, ownerInfo, info) : void 0;
                } else {
                    process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>. See %s.', tagDisplayName, ancestorTag, ownerInfo) : void 0;
                }
            }
        };
        validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo;
        validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {
            ancestorInfo = ancestorInfo || emptyAncestorInfo;
            var parentInfo = ancestorInfo.current;
            var parentTag = parentInfo && parentInfo.tag;
            return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
        };
    }
    module.exports = validateDOMNesting;
});
/*react-dom@15.6.1#lib/ReactDOMComponent*/
define('react-dom@15.6.1#lib/ReactDOMComponent', function (require, exports, module) {
    (function (global) {
        'use strict';
        var _prodInvariant = require('./reactProdInvariant'), _assign = require('object-assign');
        var AutoFocusUtils = require('./AutoFocusUtils');
        var CSSPropertyOperations = require('./CSSPropertyOperations');
        var DOMLazyTree = require('./DOMLazyTree');
        var DOMNamespaces = require('./DOMNamespaces');
        var DOMProperty = require('./DOMProperty');
        var DOMPropertyOperations = require('./DOMPropertyOperations');
        var EventPluginHub = require('./EventPluginHub');
        var EventPluginRegistry = require('./EventPluginRegistry');
        var ReactBrowserEventEmitter = require('./ReactBrowserEventEmitter');
        var ReactDOMComponentFlags = require('./ReactDOMComponentFlags');
        var ReactDOMComponentTree = require('./ReactDOMComponentTree');
        var ReactDOMInput = require('./ReactDOMInput');
        var ReactDOMOption = require('./ReactDOMOption');
        var ReactDOMSelect = require('./ReactDOMSelect');
        var ReactDOMTextarea = require('./ReactDOMTextarea');
        var ReactInstrumentation = require('./ReactInstrumentation');
        var ReactMultiChild = require('./ReactMultiChild');
        var ReactServerRenderingTransaction = require('./ReactServerRenderingTransaction');
        var emptyFunction = require('fbjs/lib/emptyFunction');
        var escapeTextContentForBrowser = require('./escapeTextContentForBrowser');
        var invariant = require('fbjs/lib/invariant');
        var isEventSupported = require('./isEventSupported');
        var shallowEqual = require('fbjs/lib/shallowEqual');
        var inputValueTracking = require('./inputValueTracking');
        var validateDOMNesting = require('./validateDOMNesting');
        var warning = require('fbjs/lib/warning');
        var Flags = ReactDOMComponentFlags;
        var deleteListener = EventPluginHub.deleteListener;
        var getNode = ReactDOMComponentTree.getNodeFromInstance;
        var listenTo = ReactBrowserEventEmitter.listenTo;
        var registrationNameModules = EventPluginRegistry.registrationNameModules;
        var CONTENT_TYPES = {
            string: true,
            number: true
        };
        var STYLE = 'style';
        var HTML = '__html';
        var RESERVED_PROPS = {
            children: null,
            dangerouslySetInnerHTML: null,
            suppressContentEditableWarning: null
        };
        var DOC_FRAGMENT_TYPE = 11;
        function getDeclarationErrorAddendum(internalInstance) {
            if (internalInstance) {
                var owner = internalInstance._currentElement._owner || null;
                if (owner) {
                    var name = owner.getName();
                    if (name) {
                        return ' This DOM node was rendered by `' + name + '`.';
                    }
                }
            }
            return '';
        }
        function friendlyStringify(obj) {
            if (typeof obj === 'object') {
                if (Array.isArray(obj)) {
                    return '[' + obj.map(friendlyStringify).join(', ') + ']';
                } else {
                    var pairs = [];
                    for (var key in obj) {
                        if (Object.prototype.hasOwnProperty.call(obj, key)) {
                            var keyEscaped = /^[a-z$_][\w$_]*$/i.test(key) ? key : JSON.stringify(key);
                            pairs.push(keyEscaped + ': ' + friendlyStringify(obj[key]));
                        }
                    }
                    return '{' + pairs.join(', ') + '}';
                }
            } else if (typeof obj === 'string') {
                return JSON.stringify(obj);
            } else if (typeof obj === 'function') {
                return '[function object]';
            }
            return String(obj);
        }
        var styleMutationWarning = {};
        function checkAndWarnForMutatedStyle(style1, style2, component) {
            if (style1 == null || style2 == null) {
                return;
            }
            if (shallowEqual(style1, style2)) {
                return;
            }
            var componentName = component._tag;
            var owner = component._currentElement._owner;
            var ownerName;
            if (owner) {
                ownerName = owner.getName();
            }
            var hash = ownerName + '|' + componentName;
            if (styleMutationWarning.hasOwnProperty(hash)) {
                return;
            }
            styleMutationWarning[hash] = true;
            process.env.NODE_ENV !== 'production' ? warning(false, '`%s` was passed a style object that has previously been mutated. ' + 'Mutating `style` is deprecated. Consider cloning it beforehand. Check ' + 'the `render` %s. Previous style: %s. Mutated style: %s.', componentName, owner ? 'of `' + ownerName + '`' : 'using <' + componentName + '>', friendlyStringify(style1), friendlyStringify(style2)) : void 0;
        }
        function assertValidProps(component, props) {
            if (!props) {
                return;
            }
            if (voidElementTags[component._tag]) {
                !(props.children == null && props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : _prodInvariant('137', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : void 0;
            }
            if (props.dangerouslySetInnerHTML != null) {
                !(props.children == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : _prodInvariant('60') : void 0;
                !(typeof props.dangerouslySetInnerHTML === 'object' && HTML in props.dangerouslySetInnerHTML) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.') : _prodInvariant('61') : void 0;
            }
            if (process.env.NODE_ENV !== 'production') {
                process.env.NODE_ENV !== 'production' ? warning(props.innerHTML == null, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.') : void 0;
                process.env.NODE_ENV !== 'production' ? warning(props.suppressContentEditableWarning || !props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : void 0;
                process.env.NODE_ENV !== 'production' ? warning(props.onFocusIn == null && props.onFocusOut == null, 'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.') : void 0;
            }
            !(props.style == null || typeof props.style === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \'em\'}} when using JSX.%s', getDeclarationErrorAddendum(component)) : _prodInvariant('62', getDeclarationErrorAddendum(component)) : void 0;
        }
        function enqueuePutListener(inst, registrationName, listener, transaction) {
            if (transaction instanceof ReactServerRenderingTransaction) {
                return;
            }
            if (process.env.NODE_ENV !== 'production') {
                process.env.NODE_ENV !== 'production' ? warning(registrationName !== 'onScroll' || isEventSupported('scroll', true), 'This browser doesn\'t support the `onScroll` event') : void 0;
            }
            var containerInfo = inst._hostContainerInfo;
            var isDocumentFragment = containerInfo._node && containerInfo._node.nodeType === DOC_FRAGMENT_TYPE;
            var doc = isDocumentFragment ? containerInfo._node : containerInfo._ownerDocument;
            listenTo(registrationName, doc);
            transaction.getReactMountReady().enqueue(putListener, {
                inst: inst,
                registrationName: registrationName,
                listener: listener
            });
        }
        function putListener() {
            var listenerToPut = this;
            EventPluginHub.putListener(listenerToPut.inst, listenerToPut.registrationName, listenerToPut.listener);
        }
        function inputPostMount() {
            var inst = this;
            ReactDOMInput.postMountWrapper(inst);
        }
        function textareaPostMount() {
            var inst = this;
            ReactDOMTextarea.postMountWrapper(inst);
        }
        function optionPostMount() {
            var inst = this;
            ReactDOMOption.postMountWrapper(inst);
        }
        var setAndValidateContentChildDev = emptyFunction;
        if (process.env.NODE_ENV !== 'production') {
            setAndValidateContentChildDev = function (content) {
                var hasExistingContent = this._contentDebugID != null;
                var debugID = this._debugID;
                var contentDebugID = -debugID;
                if (content == null) {
                    if (hasExistingContent) {
                        ReactInstrumentation.debugTool.onUnmountComponent(this._contentDebugID);
                    }
                    this._contentDebugID = null;
                    return;
                }
                validateDOMNesting(null, String(content), this, this._ancestorInfo);
                this._contentDebugID = contentDebugID;
                if (hasExistingContent) {
                    ReactInstrumentation.debugTool.onBeforeUpdateComponent(contentDebugID, content);
                    ReactInstrumentation.debugTool.onUpdateComponent(contentDebugID);
                } else {
                    ReactInstrumentation.debugTool.onBeforeMountComponent(contentDebugID, content, debugID);
                    ReactInstrumentation.debugTool.onMountComponent(contentDebugID);
                    ReactInstrumentation.debugTool.onSetChildren(debugID, [contentDebugID]);
                }
            };
        }
        var mediaEvents = {
            topAbort: 'abort',
            topCanPlay: 'canplay',
            topCanPlayThrough: 'canplaythrough',
            topDurationChange: 'durationchange',
            topEmptied: 'emptied',
            topEncrypted: 'encrypted',
            topEnded: 'ended',
            topError: 'error',
            topLoadedData: 'loadeddata',
            topLoadedMetadata: 'loadedmetadata',
            topLoadStart: 'loadstart',
            topPause: 'pause',
            topPlay: 'play',
            topPlaying: 'playing',
            topProgress: 'progress',
            topRateChange: 'ratechange',
            topSeeked: 'seeked',
            topSeeking: 'seeking',
            topStalled: 'stalled',
            topSuspend: 'suspend',
            topTimeUpdate: 'timeupdate',
            topVolumeChange: 'volumechange',
            topWaiting: 'waiting'
        };
        function trackInputValue() {
            inputValueTracking.track(this);
        }
        function trapBubbledEventsLocal() {
            var inst = this;
            !inst._rootNodeID ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Must be mounted to trap events') : _prodInvariant('63') : void 0;
            var node = getNode(inst);
            !node ? process.env.NODE_ENV !== 'production' ? invariant(false, 'trapBubbledEvent(...): Requires node to be rendered.') : _prodInvariant('64') : void 0;
            switch (inst._tag) {
            case 'iframe':
            case 'object':
                inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topLoad', 'load', node)];
                break;
            case 'video':
            case 'audio':
                inst._wrapperState.listeners = [];
                for (var event in mediaEvents) {
                    if (mediaEvents.hasOwnProperty(event)) {
                        inst._wrapperState.listeners.push(ReactBrowserEventEmitter.trapBubbledEvent(event, mediaEvents[event], node));
                    }
                }
                break;
            case 'source':
                inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topError', 'error', node)];
                break;
            case 'img':
                inst._wrapperState.listeners = [
                    ReactBrowserEventEmitter.trapBubbledEvent('topError', 'error', node),
                    ReactBrowserEventEmitter.trapBubbledEvent('topLoad', 'load', node)
                ];
                break;
            case 'form':
                inst._wrapperState.listeners = [
                    ReactBrowserEventEmitter.trapBubbledEvent('topReset', 'reset', node),
                    ReactBrowserEventEmitter.trapBubbledEvent('topSubmit', 'submit', node)
                ];
                break;
            case 'input':
            case 'select':
            case 'textarea':
                inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topInvalid', 'invalid', node)];
                break;
            }
        }
        function postUpdateSelectWrapper() {
            ReactDOMSelect.postUpdateWrapper(this);
        }
        var omittedCloseTags = {
            area: true,
            base: true,
            br: true,
            col: true,
            embed: true,
            hr: true,
            img: true,
            input: true,
            keygen: true,
            link: true,
            meta: true,
            param: true,
            source: true,
            track: true,
            wbr: true
        };
        var newlineEatingTags = {
            listing: true,
            pre: true,
            textarea: true
        };
        var voidElementTags = _assign({ menuitem: true }, omittedCloseTags);
        var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/;
        var validatedTagCache = {};
        var hasOwnProperty = {}.hasOwnProperty;
        function validateDangerousTag(tag) {
            if (!hasOwnProperty.call(validatedTagCache, tag)) {
                !VALID_TAG_REGEX.test(tag) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Invalid tag: %s', tag) : _prodInvariant('65', tag) : void 0;
                validatedTagCache[tag] = true;
            }
        }
        function isCustomComponent(tagName, props) {
            return tagName.indexOf('-') >= 0 || props.is != null;
        }
        var globalIdCounter = 1;
        function ReactDOMComponent(element) {
            var tag = element.type;
            validateDangerousTag(tag);
            this._currentElement = element;
            this._tag = tag.toLowerCase();
            this._namespaceURI = null;
            this._renderedChildren = null;
            this._previousStyle = null;
            this._previousStyleCopy = null;
            this._hostNode = null;
            this._hostParent = null;
            this._rootNodeID = 0;
            this._domID = 0;
            this._hostContainerInfo = null;
            this._wrapperState = null;
            this._topLevelWrapper = null;
            this._flags = 0;
            if (process.env.NODE_ENV !== 'production') {
                this._ancestorInfo = null;
                setAndValidateContentChildDev.call(this, null);
            }
        }
        ReactDOMComponent.displayName = 'ReactDOMComponent';
        ReactDOMComponent.Mixin = {
            mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
                this._rootNodeID = globalIdCounter++;
                this._domID = hostContainerInfo._idCounter++;
                this._hostParent = hostParent;
                this._hostContainerInfo = hostContainerInfo;
                var props = this._currentElement.props;
                switch (this._tag) {
                case 'audio':
                case 'form':
                case 'iframe':
                case 'img':
                case 'link':
                case 'object':
                case 'source':
                case 'video':
                    this._wrapperState = { listeners: null };
                    transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
                    break;
                case 'input':
                    ReactDOMInput.mountWrapper(this, props, hostParent);
                    props = ReactDOMInput.getHostProps(this, props);
                    transaction.getReactMountReady().enqueue(trackInputValue, this);
                    transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
                    break;
                case 'option':
                    ReactDOMOption.mountWrapper(this, props, hostParent);
                    props = ReactDOMOption.getHostProps(this, props);
                    break;
                case 'select':
                    ReactDOMSelect.mountWrapper(this, props, hostParent);
                    props = ReactDOMSelect.getHostProps(this, props);
                    transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
                    break;
                case 'textarea':
                    ReactDOMTextarea.mountWrapper(this, props, hostParent);
                    props = ReactDOMTextarea.getHostProps(this, props);
                    transaction.getReactMountReady().enqueue(trackInputValue, this);
                    transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
                    break;
                }
                assertValidProps(this, props);
                var namespaceURI;
                var parentTag;
                if (hostParent != null) {
                    namespaceURI = hostParent._namespaceURI;
                    parentTag = hostParent._tag;
                } else if (hostContainerInfo._tag) {
                    namespaceURI = hostContainerInfo._namespaceURI;
                    parentTag = hostContainerInfo._tag;
                }
                if (namespaceURI == null || namespaceURI === DOMNamespaces.svg && parentTag === 'foreignobject') {
                    namespaceURI = DOMNamespaces.html;
                }
                if (namespaceURI === DOMNamespaces.html) {
                    if (this._tag === 'svg') {
                        namespaceURI = DOMNamespaces.svg;
                    } else if (this._tag === 'math') {
                        namespaceURI = DOMNamespaces.mathml;
                    }
                }
                this._namespaceURI = namespaceURI;
                if (process.env.NODE_ENV !== 'production') {
                    var parentInfo;
                    if (hostParent != null) {
                        parentInfo = hostParent._ancestorInfo;
                    } else if (hostContainerInfo._tag) {
                        parentInfo = hostContainerInfo._ancestorInfo;
                    }
                    if (parentInfo) {
                        validateDOMNesting(this._tag, null, this, parentInfo);
                    }
                    this._ancestorInfo = validateDOMNesting.updatedAncestorInfo(parentInfo, this._tag, this);
                }
                var mountImage;
                if (transaction.useCreateElement) {
                    var ownerDocument = hostContainerInfo._ownerDocument;
                    var el;
                    if (namespaceURI === DOMNamespaces.html) {
                        if (this._tag === 'script') {
                            var div = ownerDocument.createElement('div');
                            var type = this._currentElement.type;
                            div.innerHTML = '<' + type + '></' + type + '>';
                            el = div.removeChild(div.firstChild);
                        } else if (props.is) {
                            el = ownerDocument.createElement(this._currentElement.type, props.is);
                        } else {
                            el = ownerDocument.createElement(this._currentElement.type);
                        }
                    } else {
                        el = ownerDocument.createElementNS(namespaceURI, this._currentElement.type);
                    }
                    ReactDOMComponentTree.precacheNode(this, el);
                    this._flags |= Flags.hasCachedChildNodes;
                    if (!this._hostParent) {
                        DOMPropertyOperations.setAttributeForRoot(el);
                    }
                    this._updateDOMProperties(null, props, transaction);
                    var lazyTree = DOMLazyTree(el);
                    this._createInitialChildren(transaction, props, context, lazyTree);
                    mountImage = lazyTree;
                } else {
                    var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
                    var tagContent = this._createContentMarkup(transaction, props, context);
                    if (!tagContent && omittedCloseTags[this._tag]) {
                        mountImage = tagOpen + '/>';
                    } else {
                        mountImage = tagOpen + '>' + tagContent + '</' + this._currentElement.type + '>';
                    }
                }
                switch (this._tag) {
                case 'input':
                    transaction.getReactMountReady().enqueue(inputPostMount, this);
                    if (props.autoFocus) {
                        transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
                    }
                    break;
                case 'textarea':
                    transaction.getReactMountReady().enqueue(textareaPostMount, this);
                    if (props.autoFocus) {
                        transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
                    }
                    break;
                case 'select':
                    if (props.autoFocus) {
                        transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
                    }
                    break;
                case 'button':
                    if (props.autoFocus) {
                        transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
                    }
                    break;
                case 'option':
                    transaction.getReactMountReady().enqueue(optionPostMount, this);
                    break;
                }
                return mountImage;
            },
            _createOpenTagMarkupAndPutListeners: function (transaction, props) {
                var ret = '<' + this._currentElement.type;
                for (var propKey in props) {
                    if (!props.hasOwnProperty(propKey)) {
                        continue;
                    }
                    var propValue = props[propKey];
                    if (propValue == null) {
                        continue;
                    }
                    if (registrationNameModules.hasOwnProperty(propKey)) {
                        if (propValue) {
                            enqueuePutListener(this, propKey, propValue, transaction);
                        }
                    } else {
                        if (propKey === STYLE) {
                            if (propValue) {
                                if (process.env.NODE_ENV !== 'production') {
                                    this._previousStyle = propValue;
                                }
                                propValue = this._previousStyleCopy = _assign({}, props.style);
                            }
                            propValue = CSSPropertyOperations.createMarkupForStyles(propValue, this);
                        }
                        var markup = null;
                        if (this._tag != null && isCustomComponent(this._tag, props)) {
                            if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
                                markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);
                            }
                        } else {
                            markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
                        }
                        if (markup) {
                            ret += ' ' + markup;
                        }
                    }
                }
                if (transaction.renderToStaticMarkup) {
                    return ret;
                }
                if (!this._hostParent) {
                    ret += ' ' + DOMPropertyOperations.createMarkupForRoot();
                }
                ret += ' ' + DOMPropertyOperations.createMarkupForID(this._domID);
                return ret;
            },
            _createContentMarkup: function (transaction, props, context) {
                var ret = '';
                var innerHTML = props.dangerouslySetInnerHTML;
                if (innerHTML != null) {
                    if (innerHTML.__html != null) {
                        ret = innerHTML.__html;
                    }
                } else {
                    var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
                    var childrenToUse = contentToUse != null ? null : props.children;
                    if (contentToUse != null) {
                        ret = escapeTextContentForBrowser(contentToUse);
                        if (process.env.NODE_ENV !== 'production') {
                            setAndValidateContentChildDev.call(this, contentToUse);
                        }
                    } else if (childrenToUse != null) {
                        var mountImages = this.mountChildren(childrenToUse, transaction, context);
                        ret = mountImages.join('');
                    }
                }
                if (newlineEatingTags[this._tag] && ret.charAt(0) === '\n') {
                    return '\n' + ret;
                } else {
                    return ret;
                }
            },
            _createInitialChildren: function (transaction, props, context, lazyTree) {
                var innerHTML = props.dangerouslySetInnerHTML;
                if (innerHTML != null) {
                    if (innerHTML.__html != null) {
                        DOMLazyTree.queueHTML(lazyTree, innerHTML.__html);
                    }
                } else {
                    var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
                    var childrenToUse = contentToUse != null ? null : props.children;
                    if (contentToUse != null) {
                        if (contentToUse !== '') {
                            if (process.env.NODE_ENV !== 'production') {
                                setAndValidateContentChildDev.call(this, contentToUse);
                            }
                            DOMLazyTree.queueText(lazyTree, contentToUse);
                        }
                    } else if (childrenToUse != null) {
                        var mountImages = this.mountChildren(childrenToUse, transaction, context);
                        for (var i = 0; i < mountImages.length; i++) {
                            DOMLazyTree.queueChild(lazyTree, mountImages[i]);
                        }
                    }
                }
            },
            receiveComponent: function (nextElement, transaction, context) {
                var prevElement = this._currentElement;
                this._currentElement = nextElement;
                this.updateComponent(transaction, prevElement, nextElement, context);
            },
            updateComponent: function (transaction, prevElement, nextElement, context) {
                var lastProps = prevElement.props;
                var nextProps = this._currentElement.props;
                switch (this._tag) {
                case 'input':
                    lastProps = ReactDOMInput.getHostProps(this, lastProps);
                    nextProps = ReactDOMInput.getHostProps(this, nextProps);
                    break;
                case 'option':
                    lastProps = ReactDOMOption.getHostProps(this, lastProps);
                    nextProps = ReactDOMOption.getHostProps(this, nextProps);
                    break;
                case 'select':
                    lastProps = ReactDOMSelect.getHostProps(this, lastProps);
                    nextProps = ReactDOMSelect.getHostProps(this, nextProps);
                    break;
                case 'textarea':
                    lastProps = ReactDOMTextarea.getHostProps(this, lastProps);
                    nextProps = ReactDOMTextarea.getHostProps(this, nextProps);
                    break;
                }
                assertValidProps(this, nextProps);
                this._updateDOMProperties(lastProps, nextProps, transaction);
                this._updateDOMChildren(lastProps, nextProps, transaction, context);
                switch (this._tag) {
                case 'input':
                    ReactDOMInput.updateWrapper(this);
                    break;
                case 'textarea':
                    ReactDOMTextarea.updateWrapper(this);
                    break;
                case 'select':
                    transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, this);
                    break;
                }
            },
            _updateDOMProperties: function (lastProps, nextProps, transaction) {
                var propKey;
                var styleName;
                var styleUpdates;
                for (propKey in lastProps) {
                    if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
                        continue;
                    }
                    if (propKey === STYLE) {
                        var lastStyle = this._previousStyleCopy;
                        for (styleName in lastStyle) {
                            if (lastStyle.hasOwnProperty(styleName)) {
                                styleUpdates = styleUpdates || {};
                                styleUpdates[styleName] = '';
                            }
                        }
                        this._previousStyleCopy = null;
                    } else if (registrationNameModules.hasOwnProperty(propKey)) {
                        if (lastProps[propKey]) {
                            deleteListener(this, propKey);
                        }
                    } else if (isCustomComponent(this._tag, lastProps)) {
                        if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
                            DOMPropertyOperations.deleteValueForAttribute(getNode(this), propKey);
                        }
                    } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
                        DOMPropertyOperations.deleteValueForProperty(getNode(this), propKey);
                    }
                }
                for (propKey in nextProps) {
                    var nextProp = nextProps[propKey];
                    var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps != null ? lastProps[propKey] : undefined;
                    if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
                        continue;
                    }
                    if (propKey === STYLE) {
                        if (nextProp) {
                            if (process.env.NODE_ENV !== 'production') {
                                checkAndWarnForMutatedStyle(this._previousStyleCopy, this._previousStyle, this);
                                this._previousStyle = nextProp;
                            }
                            nextProp = this._previousStyleCopy = _assign({}, nextProp);
                        } else {
                            this._previousStyleCopy = null;
                        }
                        if (lastProp) {
                            for (styleName in lastProp) {
                                if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
                                    styleUpdates = styleUpdates || {};
                                    styleUpdates[styleName] = '';
                                }
                            }
                            for (styleName in nextProp) {
                                if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
                                    styleUpdates = styleUpdates || {};
                                    styleUpdates[styleName] = nextProp[styleName];
                                }
                            }
                        } else {
                            styleUpdates = nextProp;
                        }
                    } else if (registrationNameModules.hasOwnProperty(propKey)) {
                        if (nextProp) {
                            enqueuePutListener(this, propKey, nextProp, transaction);
                        } else if (lastProp) {
                            deleteListener(this, propKey);
                        }
                    } else if (isCustomComponent(this._tag, nextProps)) {
                        if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
                            DOMPropertyOperations.setValueForAttribute(getNode(this), propKey, nextProp);
                        }
                    } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
                        var node = getNode(this);
                        if (nextProp != null) {
                            DOMPropertyOperations.setValueForProperty(node, propKey, nextProp);
                        } else {
                            DOMPropertyOperations.deleteValueForProperty(node, propKey);
                        }
                    }
                }
                if (styleUpdates) {
                    CSSPropertyOperations.setValueForStyles(getNode(this), styleUpdates, this);
                }
            },
            _updateDOMChildren: function (lastProps, nextProps, transaction, context) {
                var lastContent = CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;
                var nextContent = CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;
                var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
                var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;
                var lastChildren = lastContent != null ? null : lastProps.children;
                var nextChildren = nextContent != null ? null : nextProps.children;
                var lastHasContentOrHtml = lastContent != null || lastHtml != null;
                var nextHasContentOrHtml = nextContent != null || nextHtml != null;
                if (lastChildren != null && nextChildren == null) {
                    this.updateChildren(null, transaction, context);
                } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
                    this.updateTextContent('');
                    if (process.env.NODE_ENV !== 'production') {
                        ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
                    }
                }
                if (nextContent != null) {
                    if (lastContent !== nextContent) {
                        this.updateTextContent('' + nextContent);
                        if (process.env.NODE_ENV !== 'production') {
                            setAndValidateContentChildDev.call(this, nextContent);
                        }
                    }
                } else if (nextHtml != null) {
                    if (lastHtml !== nextHtml) {
                        this.updateMarkup('' + nextHtml);
                    }
                    if (process.env.NODE_ENV !== 'production') {
                        ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
                    }
                } else if (nextChildren != null) {
                    if (process.env.NODE_ENV !== 'production') {
                        setAndValidateContentChildDev.call(this, null);
                    }
                    this.updateChildren(nextChildren, transaction, context);
                }
            },
            getHostNode: function () {
                return getNode(this);
            },
            unmountComponent: function (safely) {
                switch (this._tag) {
                case 'audio':
                case 'form':
                case 'iframe':
                case 'img':
                case 'link':
                case 'object':
                case 'source':
                case 'video':
                    var listeners = this._wrapperState.listeners;
                    if (listeners) {
                        for (var i = 0; i < listeners.length; i++) {
                            listeners[i].remove();
                        }
                    }
                    break;
                case 'input':
                case 'textarea':
                    inputValueTracking.stopTracking(this);
                    break;
                case 'html':
                case 'head':
                case 'body':
                    !false ? process.env.NODE_ENV !== 'production' ? invariant(false, '<%s> tried to unmount. Because of cross-browser quirks it is impossible to unmount some top-level components (eg <html>, <head>, and <body>) reliably and efficiently. To fix this, have a single top-level component that never unmounts render these elements.', this._tag) : _prodInvariant('66', this._tag) : void 0;
                    break;
                }
                this.unmountChildren(safely);
                ReactDOMComponentTree.uncacheNode(this);
                EventPluginHub.deleteAllListeners(this);
                this._rootNodeID = 0;
                this._domID = 0;
                this._wrapperState = null;
                if (process.env.NODE_ENV !== 'production') {
                    setAndValidateContentChildDev.call(this, null);
                }
            },
            getPublicInstance: function () {
                return getNode(this);
            }
        };
        _assign(ReactDOMComponent.prototype, ReactDOMComponent.Mixin, ReactMultiChild.Mixin);
        module.exports = ReactDOMComponent;
    }(function () {
        return this;
    }()));
});
/*react-dom@15.6.1#lib/ReactDOMEmptyComponent*/
define('react-dom@15.6.1#lib/ReactDOMEmptyComponent', function (require, exports, module) {
    'use strict';
    var _assign = require('object-assign');
    var DOMLazyTree = require('./DOMLazyTree');
    var ReactDOMComponentTree = require('./ReactDOMComponentTree');
    var ReactDOMEmptyComponent = function (instantiate) {
        this._currentElement = null;
        this._hostNode = null;
        this._hostParent = null;
        this._hostContainerInfo = null;
        this._domID = 0;
    };
    _assign(ReactDOMEmptyComponent.prototype, {
        mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
            var domID = hostContainerInfo._idCounter++;
            this._domID = domID;
            this._hostParent = hostParent;
            this._hostContainerInfo = hostContainerInfo;
            var nodeValue = ' react-empty: ' + this._domID + ' ';
            if (transaction.useCreateElement) {
                var ownerDocument = hostContainerInfo._ownerDocument;
                var node = ownerDocument.createComment(nodeValue);
                ReactDOMComponentTree.precacheNode(this, node);
                return DOMLazyTree(node);
            } else {
                if (transaction.renderToStaticMarkup) {
                    return '';
                }
                return '<!--' + nodeValue + '-->';
            }
        },
        receiveComponent: function () {
        },
        getHostNode: function () {
            return ReactDOMComponentTree.getNodeFromInstance(this);
        },
        unmountComponent: function () {
            ReactDOMComponentTree.uncacheNode(this);
        }
    });
    module.exports = ReactDOMEmptyComponent;
});
/*react-dom@15.6.1#lib/ReactDOMTreeTraversal*/
define('react-dom@15.6.1#lib/ReactDOMTreeTraversal', function (require, exports, module) {
    'use strict';
    var _prodInvariant = require('./reactProdInvariant');
    var invariant = require('fbjs/lib/invariant');
    function getLowestCommonAncestor(instA, instB) {
        !('_hostNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
        !('_hostNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
        var depthA = 0;
        for (var tempA = instA; tempA; tempA = tempA._hostParent) {
            depthA++;
        }
        var depthB = 0;
        for (var tempB = instB; tempB; tempB = tempB._hostParent) {
            depthB++;
        }
        while (depthA - depthB > 0) {
            instA = instA._hostParent;
            depthA--;
        }
        while (depthB - depthA > 0) {
            instB = instB._hostParent;
            depthB--;
        }
        var depth = depthA;
        while (depth--) {
            if (instA === instB) {
                return instA;
            }
            instA = instA._hostParent;
            instB = instB._hostParent;
        }
        return null;
    }
    function isAncestor(instA, instB) {
        !('_hostNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;
        !('_hostNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;
        while (instB) {
            if (instB === instA) {
                return true;
            }
            instB = instB._hostParent;
        }
        return false;
    }
    function getParentInstance(inst) {
        !('_hostNode' in inst) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getParentInstance: Invalid argument.') : _prodInvariant('36') : void 0;
        return inst._hostParent;
    }
    function traverseTwoPhase(inst, fn, arg) {
        var path = [];
        while (inst) {
            path.push(inst);
            inst = inst._hostParent;
        }
        var i;
        for (i = path.length; i-- > 0;) {
            fn(path[i], 'captured', arg);
        }
        for (i = 0; i < path.length; i++) {
            fn(path[i], 'bubbled', arg);
        }
    }
    function traverseEnterLeave(from, to, fn, argFrom, argTo) {
        var common = from && to ? getLowestCommonAncestor(from, to) : null;
        var pathFrom = [];
        while (from && from !== common) {
            pathFrom.push(from);
            from = from._hostParent;
        }
        var pathTo = [];
        while (to && to !== common) {
            pathTo.push(to);
            to = to._hostParent;
        }
        var i;
        for (i = 0; i < pathFrom.length; i++) {
            fn(pathFrom[i], 'bubbled', argFrom);
        }
        for (i = pathTo.length; i-- > 0;) {
            fn(pathTo[i], 'captured', argTo);
        }
    }
    module.exports = {
        isAncestor: isAncestor,
        getLowestCommonAncestor: getLowestCommonAncestor,
        getParentInstance: getParentInstance,
        traverseTwoPhase: traverseTwoPhase,
        traverseEnterLeave: traverseEnterLeave
    };
});
/*react-dom@15.6.1#lib/ReactDOMTextComponent*/
define('react-dom@15.6.1#lib/ReactDOMTextComponent', function (require, exports, module) {
    'use strict';
    var _prodInvariant = require('./reactProdInvariant'), _assign = require('object-assign');
    var DOMChildrenOperations = require('./DOMChildrenOperations');
    var DOMLazyTree = require('./DOMLazyTree');
    var ReactDOMComponentTree = require('./ReactDOMComponentTree');
    var escapeTextContentForBrowser = require('./escapeTextContentForBrowser');
    var invariant = require('fbjs/lib/invariant');
    var validateDOMNesting = require('./validateDOMNesting');
    var ReactDOMTextComponent = function (text) {
        this._currentElement = text;
        this._stringText = '' + text;
        this._hostNode = null;
        this._hostParent = null;
        this._domID = 0;
        this._mountIndex = 0;
        this._closingComment = null;
        this._commentNodes = null;
    };
    _assign(ReactDOMTextComponent.prototype, {
        mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
            if (process.env.NODE_ENV !== 'production') {
                var parentInfo;
                if (hostParent != null) {
                    parentInfo = hostParent._ancestorInfo;
                } else if (hostContainerInfo != null) {
                    parentInfo = hostContainerInfo._ancestorInfo;
                }
                if (parentInfo) {
                    validateDOMNesting(null, this._stringText, this, parentInfo);
                }
            }
            var domID = hostContainerInfo._idCounter++;
            var openingValue = ' react-text: ' + domID + ' ';
            var closingValue = ' /react-text ';
            this._domID = domID;
            this._hostParent = hostParent;
            if (transaction.useCreateElement) {
                var ownerDocument = hostContainerInfo._ownerDocument;
                var openingComment = ownerDocument.createComment(openingValue);
                var closingComment = ownerDocument.createComment(closingValue);
                var lazyTree = DOMLazyTree(ownerDocument.createDocumentFragment());
                DOMLazyTree.queueChild(lazyTree, DOMLazyTree(openingComment));
                if (this._stringText) {
                    DOMLazyTree.queueChild(lazyTree, DOMLazyTree(ownerDocument.createTextNode(this._stringText)));
                }
                DOMLazyTree.queueChild(lazyTree, DOMLazyTree(closingComment));
                ReactDOMComponentTree.precacheNode(this, openingComment);
                this._closingComment = closingComment;
                return lazyTree;
            } else {
                var escapedText = escapeTextContentForBrowser(this._stringText);
                if (transaction.renderToStaticMarkup) {
                    return escapedText;
                }
                return '<!--' + openingValue + '-->' + escapedText + '<!--' + closingValue + '-->';
            }
        },
        receiveComponent: function (nextText, transaction) {
            if (nextText !== this._currentElement) {
                this._currentElement = nextText;
                var nextStringText = '' + nextText;
                if (nextStringText !== this._stringText) {
                    this._stringText = nextStringText;
                    var commentNodes = this.getHostNode();
                    DOMChildrenOperations.replaceDelimitedText(commentNodes[0], commentNodes[1], nextStringText);
                }
            }
        },
        getHostNode: function () {
            var hostNode = this._commentNodes;
            if (hostNode) {
                return hostNode;
            }
            if (!this._closingComment) {
                var openingComment = ReactDOMComponentTree.getNodeFromInstance(this);
                var node = openingComment.nextSibling;
                while (true) {
                    !(node != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Missing closing comment for text component %s', this._domID) : _prodInvariant('67', this._domID) : void 0;
                    if (node.nodeType === 8 && node.nodeValue === ' /react-text ') {
                        this._closingComment = node;
                        break;
                    }
                    node = node.nextSibling;
                }
            }
            hostNode = [
                this._hostNode,
                this._closingComment
            ];
            this._commentNodes = hostNode;
            return hostNode;
        },
        unmountComponent: function () {
            this._closingComment = null;
            this._commentNodes = null;
            ReactDOMComponentTree.uncacheNode(this);
        }
    });
    module.exports = ReactDOMTextComponent;
});
/*react-dom@15.6.1#lib/ReactDefaultBatchingStrategy*/
define('react-dom@15.6.1#lib/ReactDefaultBatchingStrategy', function (require, exports, module) {
    'use strict';
    var _assign = require('object-assign');
    var ReactUpdates = require('./ReactUpdates');
    var Transaction = require('./Transaction');
    var emptyFunction = require('fbjs/lib/emptyFunction');
    var RESET_BATCHED_UPDATES = {
        initialize: emptyFunction,
        close: function () {
            ReactDefaultBatchingStrategy.isBatchingUpdates = false;
        }
    };
    var FLUSH_BATCHED_UPDATES = {
        initialize: emptyFunction,
        close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
    };
    var TRANSACTION_WRAPPERS = [
        FLUSH_BATCHED_UPDATES,
        RESET_BATCHED_UPDATES
    ];
    function ReactDefaultBatchingStrategyTransaction() {
        this.reinitializeTransaction();
    }
    _assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction, {
        getTransactionWrappers: function () {
            return TRANSACTION_WRAPPERS;
        }
    });
    var transaction = new ReactDefaultBatchingStrategyTransaction();
    var ReactDefaultBatchingStrategy = {
        isBatchingUpdates: false,
        batchedUpdates: function (callback, a, b, c, d, e) {
            var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;
            ReactDefaultBatchingStrategy.isBatchingUpdates = true;
            if (alreadyBatchingUpdates) {
                return callback(a, b, c, d, e);
            } else {
                return transaction.perform(callback, null, a, b, c, d, e);
            }
        }
    };
    module.exports = ReactDefaultBatchingStrategy;
});
/*fbjs@0.8.12#lib/EventListener*/
define('fbjs@0.8.12#lib/EventListener', function (require, exports, module) {
    'use strict';
    var emptyFunction = require('./emptyFunction');
    var EventListener = {
        listen: function listen(target, eventType, callback) {
            if (target.addEventListener) {
                target.addEventListener(eventType, callback, false);
                return {
                    remove: function remove() {
                        target.removeEventListener(eventType, callback, false);
                    }
                };
            } else if (target.attachEvent) {
                target.attachEvent('on' + eventType, callback);
                return {
                    remove: function remove() {
                        target.detachEvent('on' + eventType, callback);
                    }
                };
            }
        },
        capture: function capture(target, eventType, callback) {
            if (target.addEventListener) {
                target.addEventListener(eventType, callback, true);
                return {
                    remove: function remove() {
                        target.removeEventListener(eventType, callback, true);
                    }
                };
            } else {
                if (process.env.NODE_ENV !== 'production') {
                    console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
                }
                return { remove: emptyFunction };
            }
        },
        registerDefault: function registerDefault() {
        }
    };
    module.exports = EventListener;
});
/*fbjs@0.8.12#lib/getUnboundedScrollPosition*/
define('fbjs@0.8.12#lib/getUnboundedScrollPosition', function (require, exports, module) {
    'use strict';
    function getUnboundedScrollPosition(scrollable) {
        if (scrollable.Window && scrollable instanceof scrollable.Window) {
            return {
                x: scrollable.pageXOffset || scrollable.document.documentElement.scrollLeft,
                y: scrollable.pageYOffset || scrollable.document.documentElement.scrollTop
            };
        }
        return {
            x: scrollable.scrollLeft,
            y: scrollable.scrollTop
        };
    }
    module.exports = getUnboundedScrollPosition;
});
/*react-dom@15.6.1#lib/ReactEventListener*/
define('react-dom@15.6.1#lib/ReactEventListener', function (require, exports, module) {
    'use strict';
    var _assign = require('object-assign');
    var EventListener = require('fbjs/lib/EventListener');
    var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
    var PooledClass = require('./PooledClass');
    var ReactDOMComponentTree = require('./ReactDOMComponentTree');
    var ReactUpdates = require('./ReactUpdates');
    var getEventTarget = require('./getEventTarget');
    var getUnboundedScrollPosition = require('fbjs/lib/getUnboundedScrollPosition');
    function findParent(inst) {
        while (inst._hostParent) {
            inst = inst._hostParent;
        }
        var rootNode = ReactDOMComponentTree.getNodeFromInstance(inst);
        var container = rootNode.parentNode;
        return ReactDOMComponentTree.getClosestInstanceFromNode(container);
    }
    function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
        this.topLevelType = topLevelType;
        this.nativeEvent = nativeEvent;
        this.ancestors = [];
    }
    _assign(TopLevelCallbackBookKeeping.prototype, {
        destructor: function () {
            this.topLevelType = null;
            this.nativeEvent = null;
            this.ancestors.length = 0;
        }
    });
    PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);
    function handleTopLevelImpl(bookKeeping) {
        var nativeEventTarget = getEventTarget(bookKeeping.nativeEvent);
        var targetInst = ReactDOMComponentTree.getClosestInstanceFromNode(nativeEventTarget);
        var ancestor = targetInst;
        do {
            bookKeeping.ancestors.push(ancestor);
            ancestor = ancestor && findParent(ancestor);
        } while (ancestor);
        for (var i = 0; i < bookKeeping.ancestors.length; i++) {
            targetInst = bookKeeping.ancestors[i];
            ReactEventListener._handleTopLevel(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
        }
    }
    function scrollValueMonitor(cb) {
        var scrollPosition = getUnboundedScrollPosition(window);
        cb(scrollPosition);
    }
    var ReactEventListener = {
        _enabled: true,
        _handleTopLevel: null,
        WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,
        setHandleTopLevel: function (handleTopLevel) {
            ReactEventListener._handleTopLevel = handleTopLevel;
        },
        setEnabled: function (enabled) {
            ReactEventListener._enabled = !!enabled;
        },
        isEnabled: function () {
            return ReactEventListener._enabled;
        },
        trapBubbledEvent: function (topLevelType, handlerBaseName, element) {
            if (!element) {
                return null;
            }
            return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
        },
        trapCapturedEvent: function (topLevelType, handlerBaseName, element) {
            if (!element) {
                return null;
            }
            return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
        },
        monitorScrollValue: function (refresh) {
            var callback = scrollValueMonitor.bind(null, refresh);
            EventListener.listen(window, 'scroll', callback);
        },
        dispatchEvent: function (topLevelType, nativeEvent) {
            if (!ReactEventListener._enabled) {
                return;
            }
            var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
            try {
                ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
            } finally {
                TopLevelCallbackBookKeeping.release(bookKeeping);
            }
        }
    };
    module.exports = ReactEventListener;
});
/*react-dom@15.6.1#lib/ReactInjection*/
define('react-dom@15.6.1#lib/ReactInjection', function (require, exports, module) {
    'use strict';
    var DOMProperty = require('./DOMProperty');
    var EventPluginHub = require('./EventPluginHub');
    var EventPluginUtils = require('./EventPluginUtils');
    var ReactComponentEnvironment = require('./ReactComponentEnvironment');
    var ReactEmptyComponent = require('./ReactEmptyComponent');
    var ReactBrowserEventEmitter = require('./ReactBrowserEventEmitter');
    var ReactHostComponent = require('./ReactHostComponent');
    var ReactUpdates = require('./ReactUpdates');
    var ReactInjection = {
        Component: ReactComponentEnvironment.injection,
        DOMProperty: DOMProperty.injection,
        EmptyComponent: ReactEmptyComponent.injection,
        EventPluginHub: EventPluginHub.injection,
        EventPluginUtils: EventPluginUtils.injection,
        EventEmitter: ReactBrowserEventEmitter.injection,
        HostComponent: ReactHostComponent.injection,
        Updates: ReactUpdates.injection
    };
    module.exports = ReactInjection;
});
/*react-dom@15.6.1#lib/getNodeForCharacterOffset*/
define('react-dom@15.6.1#lib/getNodeForCharacterOffset', function (require, exports, module) {
    'use strict';
    function getLeafNode(node) {
        while (node && node.firstChild) {
            node = node.firstChild;
        }
        return node;
    }
    function getSiblingNode(node) {
        while (node) {
            if (node.nextSibling) {
                return node.nextSibling;
            }
            node = node.parentNode;
        }
    }
    function getNodeForCharacterOffset(root, offset) {
        var node = getLeafNode(root);
        var nodeStart = 0;
        var nodeEnd = 0;
        while (node) {
            if (node.nodeType === 3) {
                nodeEnd = nodeStart + node.textContent.length;
                if (nodeStart <= offset && nodeEnd >= offset) {
                    return {
                        node: node,
                        offset: offset - nodeStart
                    };
                }
                nodeStart = nodeEnd;
            }
            node = getLeafNode(getSiblingNode(node));
        }
    }
    module.exports = getNodeForCharacterOffset;
});
/*react-dom@15.6.1#lib/ReactDOMSelection*/
define('react-dom@15.6.1#lib/ReactDOMSelection', function (require, exports, module) {
    'use strict';
    var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
    var getNodeForCharacterOffset = require('./getNodeForCharacterOffset');
    var getTextContentAccessor = require('./getTextContentAccessor');
    function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
        return anchorNode === focusNode && anchorOffset === focusOffset;
    }
    function getIEOffsets(node) {
        var selection = document.selection;
        var selectedRange = selection.createRange();
        var selectedLength = selectedRange.text.length;
        var fromStart = selectedRange.duplicate();
        fromStart.moveToElementText(node);
        fromStart.setEndPoint('EndToStart', selectedRange);
        var startOffset = fromStart.text.length;
        var endOffset = startOffset + selectedLength;
        return {
            start: startOffset,
            end: endOffset
        };
    }
    function getModernOffsets(node) {
        var selection = window.getSelection && window.getSelection();
        if (!selection || selection.rangeCount === 0) {
            return null;
        }
        var anchorNode = selection.anchorNode;
        var anchorOffset = selection.anchorOffset;
        var focusNode = selection.focusNode;
        var focusOffset = selection.focusOffset;
        var currentRange = selection.getRangeAt(0);
        try {
            currentRange.startContainer.nodeType;
            currentRange.endContainer.nodeType;
        } catch (e) {
            return null;
        }
        var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);
        var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;
        var tempRange = currentRange.cloneRange();
        tempRange.selectNodeContents(node);
        tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);
        var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);
        var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
        var end = start + rangeLength;
        var detectionRange = document.createRange();
        detectionRange.setStart(anchorNode, anchorOffset);
        detectionRange.setEnd(focusNode, focusOffset);
        var isBackward = detectionRange.collapsed;
        return {
            start: isBackward ? end : start,
            end: isBackward ? start : end
        };
    }
    function setIEOffsets(node, offsets) {
        var range = document.selection.createRange().duplicate();
        var start, end;
        if (offsets.end === undefined) {
            start = offsets.start;
            end = start;
        } else if (offsets.start > offsets.end) {
            start = offsets.end;
            end = offsets.start;
        } else {
            start = offsets.start;
            end = offsets.end;
        }
        range.moveToElementText(node);
        range.moveStart('character', start);
        range.setEndPoint('EndToStart', range);
        range.moveEnd('character', end - start);
        range.select();
    }
    function setModernOffsets(node, offsets) {
        if (!window.getSelection) {
            return;
        }
        var selection = window.getSelection();
        var length = node[getTextContentAccessor()].length;
        var start = Math.min(offsets.start, length);
        var end = offsets.end === undefined ? start : Math.min(offsets.end, length);
        if (!selection.extend && start > end) {
            var temp = end;
            end = start;
            start = temp;
        }
        var startMarker = getNodeForCharacterOffset(node, start);
        var endMarker = getNodeForCharacterOffset(node, end);
        if (startMarker && endMarker) {
            var range = document.createRange();
            range.setStart(startMarker.node, startMarker.offset);
            selection.removeAllRanges();
            if (start > end) {
                selection.addRange(range);
                selection.extend(endMarker.node, endMarker.offset);
            } else {
                range.setEnd(endMarker.node, endMarker.offset);
                selection.addRange(range);
            }
        }
    }
    var useIEOffsets = ExecutionEnvironment.canUseDOM && 'selection' in document && !('getSelection' in window);
    var ReactDOMSelection = {
        getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,
        setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
    };
    module.exports = ReactDOMSelection;
});
/*fbjs@0.8.12#lib/isNode*/
define('fbjs@0.8.12#lib/isNode', function (require, exports, module) {
    'use strict';
    function isNode(object) {
        var doc = object ? object.ownerDocument || object : document;
        var defaultView = doc.defaultView || window;
        return !!(object && (typeof defaultView.Node === 'function' ? object instanceof defaultView.Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
    }
    module.exports = isNode;
});
/*fbjs@0.8.12#lib/isTextNode*/
define('fbjs@0.8.12#lib/isTextNode', function (require, exports, module) {
    'use strict';
    var isNode = require('./isNode');
    function isTextNode(object) {
        return isNode(object) && object.nodeType == 3;
    }
    module.exports = isTextNode;
});
/*fbjs@0.8.12#lib/containsNode*/
define('fbjs@0.8.12#lib/containsNode', function (require, exports, module) {
    'use strict';
    var isTextNode = require('./isTextNode');
    function containsNode(outerNode, innerNode) {
        if (!outerNode || !innerNode) {
            return false;
        } else if (outerNode === innerNode) {
            return true;
        } else if (isTextNode(outerNode)) {
            return false;
        } else if (isTextNode(innerNode)) {
            return containsNode(outerNode, innerNode.parentNode);
        } else if ('contains' in outerNode) {
            return outerNode.contains(innerNode);
        } else if (outerNode.compareDocumentPosition) {
            return !!(outerNode.compareDocumentPosition(innerNode) & 16);
        } else {
            return false;
        }
    }
    module.exports = containsNode;
});
/*fbjs@0.8.12#lib/getActiveElement*/
define('fbjs@0.8.12#lib/getActiveElement', function (require, exports, module) {
    'use strict';
    function getActiveElement(doc) {
        doc = doc || (typeof document !== 'undefined' ? document : undefined);
        if (typeof doc === 'undefined') {
            return null;
        }
        try {
            return doc.activeElement || doc.body;
        } catch (e) {
            return doc.body;
        }
    }
    module.exports = getActiveElement;
});
/*react-dom@15.6.1#lib/ReactInputSelection*/
define('react-dom@15.6.1#lib/ReactInputSelection', function (require, exports, module) {
    'use strict';
    var ReactDOMSelection = require('./ReactDOMSelection');
    var containsNode = require('fbjs/lib/containsNode');
    var focusNode = require('fbjs/lib/focusNode');
    var getActiveElement = require('fbjs/lib/getActiveElement');
    function isInDocument(node) {
        return containsNode(document.documentElement, node);
    }
    var ReactInputSelection = {
        hasSelectionCapabilities: function (elem) {
            var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
            return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
        },
        getSelectionInformation: function () {
            var focusedElem = getActiveElement();
            return {
                focusedElem: focusedElem,
                selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null
            };
        },
        restoreSelection: function (priorSelectionInformation) {
            var curFocusedElem = getActiveElement();
            var priorFocusedElem = priorSelectionInformation.focusedElem;
            var priorSelectionRange = priorSelectionInformation.selectionRange;
            if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
                if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
                    ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
                }
                focusNode(priorFocusedElem);
            }
        },
        getSelection: function (input) {
            var selection;
            if ('selectionStart' in input) {
                selection = {
                    start: input.selectionStart,
                    end: input.selectionEnd
                };
            } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
                var range = document.selection.createRange();
                if (range.parentElement() === input) {
                    selection = {
                        start: -range.moveStart('character', -input.value.length),
                        end: -range.moveEnd('character', -input.value.length)
                    };
                }
            } else {
                selection = ReactDOMSelection.getOffsets(input);
            }
            return selection || {
                start: 0,
                end: 0
            };
        },
        setSelection: function (input, offsets) {
            var start = offsets.start;
            var end = offsets.end;
            if (end === undefined) {
                end = start;
            }
            if ('selectionStart' in input) {
                input.selectionStart = start;
                input.selectionEnd = Math.min(end, input.value.length);
            } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
                var range = input.createTextRange();
                range.collapse(true);
                range.moveStart('character', start);
                range.moveEnd('character', end - start);
                range.select();
            } else {
                ReactDOMSelection.setOffsets(input, offsets);
            }
        }
    };
    module.exports = ReactInputSelection;
});
/*react-dom@15.6.1#lib/ReactReconcileTransaction*/
define('react-dom@15.6.1#lib/ReactReconcileTransaction', function (require, exports, module) {
    'use strict';
    var _assign = require('object-assign');
    var CallbackQueue = require('./CallbackQueue');
    var PooledClass = require('./PooledClass');
    var ReactBrowserEventEmitter = require('./ReactBrowserEventEmitter');
    var ReactInputSelection = require('./ReactInputSelection');
    var ReactInstrumentation = require('./ReactInstrumentation');
    var Transaction = require('./Transaction');
    var ReactUpdateQueue = require('./ReactUpdateQueue');
    var SELECTION_RESTORATION = {
        initialize: ReactInputSelection.getSelectionInformation,
        close: ReactInputSelection.restoreSelection
    };
    var EVENT_SUPPRESSION = {
        initialize: function () {
            var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
            ReactBrowserEventEmitter.setEnabled(false);
            return currentlyEnabled;
        },
        close: function (previouslyEnabled) {
            ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
        }
    };
    var ON_DOM_READY_QUEUEING = {
        initialize: function () {
            this.reactMountReady.reset();
        },
        close: function () {
            this.reactMountReady.notifyAll();
        }
    };
    var TRANSACTION_WRAPPERS = [
        SELECTION_RESTORATION,
        EVENT_SUPPRESSION,
        ON_DOM_READY_QUEUEING
    ];
    if (process.env.NODE_ENV !== 'production') {
        TRANSACTION_WRAPPERS.push({
            initialize: ReactInstrumentation.debugTool.onBeginFlush,
            close: ReactInstrumentation.debugTool.onEndFlush
        });
    }
    function ReactReconcileTransaction(useCreateElement) {
        this.reinitializeTransaction();
        this.renderToStaticMarkup = false;
        this.reactMountReady = CallbackQueue.getPooled(null);
        this.useCreateElement = useCreateElement;
    }
    var Mixin = {
        getTransactionWrappers: function () {
            return TRANSACTION_WRAPPERS;
        },
        getReactMountReady: function () {
            return this.reactMountReady;
        },
        getUpdateQueue: function () {
            return ReactUpdateQueue;
        },
        checkpoint: function () {
            return this.reactMountReady.checkpoint();
        },
        rollback: function (checkpoint) {
            this.reactMountReady.rollback(checkpoint);
        },
        destructor: function () {
            CallbackQueue.release(this.reactMountReady);
            this.reactMountReady = null;
        }
    };
    _assign(ReactReconcileTransaction.prototype, Transaction, Mixin);
    PooledClass.addPoolingTo(ReactReconcileTransaction);
    module.exports = ReactReconcileTransaction;
});
/*react-dom@15.6.1#lib/SVGDOMPropertyConfig*/
define('react-dom@15.6.1#lib/SVGDOMPropertyConfig', function (require, exports, module) {
    'use strict';
    var NS = {
        xlink: 'http://www.w3.org/1999/xlink',
        xml: 'http://www.w3.org/XML/1998/namespace'
    };
    var ATTRS = {
        accentHeight: 'accent-height',
        accumulate: 0,
        additive: 0,
        alignmentBaseline: 'alignment-baseline',
        allowReorder: 'allowReorder',
        alphabetic: 0,
        amplitude: 0,
        arabicForm: 'arabic-form',
        ascent: 0,
        attributeName: 'attributeName',
        attributeType: 'attributeType',
        autoReverse: 'autoReverse',
        azimuth: 0,
        baseFrequency: 'baseFrequency',
        baseProfile: 'baseProfile',
        baselineShift: 'baseline-shift',
        bbox: 0,
        begin: 0,
        bias: 0,
        by: 0,
        calcMode: 'calcMode',
        capHeight: 'cap-height',
        clip: 0,
        clipPath: 'clip-path',
        clipRule: 'clip-rule',
        clipPathUnits: 'clipPathUnits',
        colorInterpolation: 'color-interpolation',
        colorInterpolationFilters: 'color-interpolation-filters',
        colorProfile: 'color-profile',
        colorRendering: 'color-rendering',
        contentScriptType: 'contentScriptType',
        contentStyleType: 'contentStyleType',
        cursor: 0,
        cx: 0,
        cy: 0,
        d: 0,
        decelerate: 0,
        descent: 0,
        diffuseConstant: 'diffuseConstant',
        direction: 0,
        display: 0,
        divisor: 0,
        dominantBaseline: 'dominant-baseline',
        dur: 0,
        dx: 0,
        dy: 0,
        edgeMode: 'edgeMode',
        elevation: 0,
        enableBackground: 'enable-background',
        end: 0,
        exponent: 0,
        externalResourcesRequired: 'externalResourcesRequired',
        fill: 0,
        fillOpacity: 'fill-opacity',
        fillRule: 'fill-rule',
        filter: 0,
        filterRes: 'filterRes',
        filterUnits: 'filterUnits',
        floodColor: 'flood-color',
        floodOpacity: 'flood-opacity',
        focusable: 0,
        fontFamily: 'font-family',
        fontSize: 'font-size',
        fontSizeAdjust: 'font-size-adjust',
        fontStretch: 'font-stretch',
        fontStyle: 'font-style',
        fontVariant: 'font-variant',
        fontWeight: 'font-weight',
        format: 0,
        from: 0,
        fx: 0,
        fy: 0,
        g1: 0,
        g2: 0,
        glyphName: 'glyph-name',
        glyphOrientationHorizontal: 'glyph-orientation-horizontal',
        glyphOrientationVertical: 'glyph-orientation-vertical',
        glyphRef: 'glyphRef',
        gradientTransform: 'gradientTransform',
        gradientUnits: 'gradientUnits',
        hanging: 0,
        horizAdvX: 'horiz-adv-x',
        horizOriginX: 'horiz-origin-x',
        ideographic: 0,
        imageRendering: 'image-rendering',
        'in': 0,
        in2: 0,
        intercept: 0,
        k: 0,
        k1: 0,
        k2: 0,
        k3: 0,
        k4: 0,
        kernelMatrix: 'kernelMatrix',
        kernelUnitLength: 'kernelUnitLength',
        kerning: 0,
        keyPoints: 'keyPoints',
        keySplines: 'keySplines',
        keyTimes: 'keyTimes',
        lengthAdjust: 'lengthAdjust',
        letterSpacing: 'letter-spacing',
        lightingColor: 'lighting-color',
        limitingConeAngle: 'limitingConeAngle',
        local: 0,
        markerEnd: 'marker-end',
        markerMid: 'marker-mid',
        markerStart: 'marker-start',
        markerHeight: 'markerHeight',
        markerUnits: 'markerUnits',
        markerWidth: 'markerWidth',
        mask: 0,
        maskContentUnits: 'maskContentUnits',
        maskUnits: 'maskUnits',
        mathematical: 0,
        mode: 0,
        numOctaves: 'numOctaves',
        offset: 0,
        opacity: 0,
        operator: 0,
        order: 0,
        orient: 0,
        orientation: 0,
        origin: 0,
        overflow: 0,
        overlinePosition: 'overline-position',
        overlineThickness: 'overline-thickness',
        paintOrder: 'paint-order',
        panose1: 'panose-1',
        pathLength: 'pathLength',
        patternContentUnits: 'patternContentUnits',
        patternTransform: 'patternTransform',
        patternUnits: 'patternUnits',
        pointerEvents: 'pointer-events',
        points: 0,
        pointsAtX: 'pointsAtX',
        pointsAtY: 'pointsAtY',
        pointsAtZ: 'pointsAtZ',
        preserveAlpha: 'preserveAlpha',
        preserveAspectRatio: 'preserveAspectRatio',
        primitiveUnits: 'primitiveUnits',
        r: 0,
        radius: 0,
        refX: 'refX',
        refY: 'refY',
        renderingIntent: 'rendering-intent',
        repeatCount: 'repeatCount',
        repeatDur: 'repeatDur',
        requiredExtensions: 'requiredExtensions',
        requiredFeatures: 'requiredFeatures',
        restart: 0,
        result: 0,
        rotate: 0,
        rx: 0,
        ry: 0,
        scale: 0,
        seed: 0,
        shapeRendering: 'shape-rendering',
        slope: 0,
        spacing: 0,
        specularConstant: 'specularConstant',
        specularExponent: 'specularExponent',
        speed: 0,
        spreadMethod: 'spreadMethod',
        startOffset: 'startOffset',
        stdDeviation: 'stdDeviation',
        stemh: 0,
        stemv: 0,
        stitchTiles: 'stitchTiles',
        stopColor: 'stop-color',
        stopOpacity: 'stop-opacity',
        strikethroughPosition: 'strikethrough-position',
        strikethroughThickness: 'strikethrough-thickness',
        string: 0,
        stroke: 0,
        strokeDasharray: 'stroke-dasharray',
        strokeDashoffset: 'stroke-dashoffset',
        strokeLinecap: 'stroke-linecap',
        strokeLinejoin: 'stroke-linejoin',
        strokeMiterlimit: 'stroke-miterlimit',
        strokeOpacity: 'stroke-opacity',
        strokeWidth: 'stroke-width',
        surfaceScale: 'surfaceScale',
        systemLanguage: 'systemLanguage',
        tableValues: 'tableValues',
        targetX: 'targetX',
        targetY: 'targetY',
        textAnchor: 'text-anchor',
        textDecoration: 'text-decoration',
        textRendering: 'text-rendering',
        textLength: 'textLength',
        to: 0,
        transform: 0,
        u1: 0,
        u2: 0,
        underlinePosition: 'underline-position',
        underlineThickness: 'underline-thickness',
        unicode: 0,
        unicodeBidi: 'unicode-bidi',
        unicodeRange: 'unicode-range',
        unitsPerEm: 'units-per-em',
        vAlphabetic: 'v-alphabetic',
        vHanging: 'v-hanging',
        vIdeographic: 'v-ideographic',
        vMathematical: 'v-mathematical',
        values: 0,
        vectorEffect: 'vector-effect',
        version: 0,
        vertAdvY: 'vert-adv-y',
        vertOriginX: 'vert-origin-x',
        vertOriginY: 'vert-origin-y',
        viewBox: 'viewBox',
        viewTarget: 'viewTarget',
        visibility: 0,
        widths: 0,
        wordSpacing: 'word-spacing',
        writingMode: 'writing-mode',
        x: 0,
        xHeight: 'x-height',
        x1: 0,
        x2: 0,
        xChannelSelector: 'xChannelSelector',
        xlinkActuate: 'xlink:actuate',
        xlinkArcrole: 'xlink:arcrole',
        xlinkHref: 'xlink:href',
        xlinkRole: 'xlink:role',
        xlinkShow: 'xlink:show',
        xlinkTitle: 'xlink:title',
        xlinkType: 'xlink:type',
        xmlBase: 'xml:base',
        xmlns: 0,
        xmlnsXlink: 'xmlns:xlink',
        xmlLang: 'xml:lang',
        xmlSpace: 'xml:space',
        y: 0,
        y1: 0,
        y2: 0,
        yChannelSelector: 'yChannelSelector',
        z: 0,
        zoomAndPan: 'zoomAndPan'
    };
    var SVGDOMPropertyConfig = {
        Properties: {},
        DOMAttributeNamespaces: {
            xlinkActuate: NS.xlink,
            xlinkArcrole: NS.xlink,
            xlinkHref: NS.xlink,
            xlinkRole: NS.xlink,
            xlinkShow: NS.xlink,
            xlinkTitle: NS.xlink,
            xlinkType: NS.xlink,
            xmlBase: NS.xml,
            xmlLang: NS.xml,
            xmlSpace: NS.xml
        },
        DOMAttributeNames: {}
    };
    Object.keys(ATTRS).forEach(function (key) {
        SVGDOMPropertyConfig.Properties[key] = 0;
        if (ATTRS[key]) {
            SVGDOMPropertyConfig.DOMAttributeNames[key] = ATTRS[key];
        }
    });
    module.exports = SVGDOMPropertyConfig;
});
/*react-dom@15.6.1#lib/SelectEventPlugin*/
define('react-dom@15.6.1#lib/SelectEventPlugin', function (require, exports, module) {
    'use strict';
    var EventPropagators = require('./EventPropagators');
    var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
    var ReactDOMComponentTree = require('./ReactDOMComponentTree');
    var ReactInputSelection = require('./ReactInputSelection');
    var SyntheticEvent = require('./SyntheticEvent');
    var getActiveElement = require('fbjs/lib/getActiveElement');
    var isTextInputElement = require('./isTextInputElement');
    var shallowEqual = require('fbjs/lib/shallowEqual');
    var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;
    var eventTypes = {
        select: {
            phasedRegistrationNames: {
                bubbled: 'onSelect',
                captured: 'onSelectCapture'
            },
            dependencies: [
                'topBlur',
                'topContextMenu',
                'topFocus',
                'topKeyDown',
                'topKeyUp',
                'topMouseDown',
                'topMouseUp',
                'topSelectionChange'
            ]
        }
    };
    var activeElement = null;
    var activeElementInst = null;
    var lastSelection = null;
    var mouseDown = false;
    var hasListener = false;
    function getSelection(node) {
        if ('selectionStart' in node && ReactInputSelection.hasSelectionCapabilities(node)) {
            return {
                start: node.selectionStart,
                end: node.selectionEnd
            };
        } else if (window.getSelection) {
            var selection = window.getSelection();
            return {
                anchorNode: selection.anchorNode,
                anchorOffset: selection.anchorOffset,
                focusNode: selection.focusNode,
                focusOffset: selection.focusOffset
            };
        } else if (document.selection) {
            var range = document.selection.createRange();
            return {
                parentElement: range.parentElement(),
                text: range.text,
                top: range.boundingTop,
                left: range.boundingLeft
            };
        }
    }
    function constructSelectEvent(nativeEvent, nativeEventTarget) {
        if (mouseDown || activeElement == null || activeElement !== getActiveElement()) {
            return null;
        }
        var currentSelection = getSelection(activeElement);
        if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
            lastSelection = currentSelection;
            var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementInst, nativeEvent, nativeEventTarget);
            syntheticEvent.type = 'select';
            syntheticEvent.target = activeElement;
            EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);
            return syntheticEvent;
        }
        return null;
    }
    var SelectEventPlugin = {
        eventTypes: eventTypes,
        extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
            if (!hasListener) {
                return null;
            }
            var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;
            switch (topLevelType) {
            case 'topFocus':
                if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {
                    activeElement = targetNode;
                    activeElementInst = targetInst;
                    lastSelection = null;
                }
                break;
            case 'topBlur':
                activeElement = null;
                activeElementInst = null;
                lastSelection = null;
                break;
            case 'topMouseDown':
                mouseDown = true;
                break;
            case 'topContextMenu':
            case 'topMouseUp':
                mouseDown = false;
                return constructSelectEvent(nativeEvent, nativeEventTarget);
            case 'topSelectionChange':
                if (skipSelectionChangeEvent) {
                    break;
                }
            case 'topKeyDown':
            case 'topKeyUp':
                return constructSelectEvent(nativeEvent, nativeEventTarget);
            }
            return null;
        },
        didPutListener: function (inst, registrationName, listener) {
            if (registrationName === 'onSelect') {
                hasListener = true;
            }
        }
    };
    module.exports = SelectEventPlugin;
});
/*react-dom@15.6.1#lib/SyntheticAnimationEvent*/
define('react-dom@15.6.1#lib/SyntheticAnimationEvent', function (require, exports, module) {
    'use strict';
    var SyntheticEvent = require('./SyntheticEvent');
    var AnimationEventInterface = {
        animationName: null,
        elapsedTime: null,
        pseudoElement: null
    };
    function SyntheticAnimationEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
        return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
    }
    SyntheticEvent.augmentClass(SyntheticAnimationEvent, AnimationEventInterface);
    module.exports = SyntheticAnimationEvent;
});
/*react-dom@15.6.1#lib/SyntheticClipboardEvent*/
define('react-dom@15.6.1#lib/SyntheticClipboardEvent', function (require, exports, module) {
    'use strict';
    var SyntheticEvent = require('./SyntheticEvent');
    var ClipboardEventInterface = {
        clipboardData: function (event) {
            return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
        }
    };
    function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
        return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
    }
    SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);
    module.exports = SyntheticClipboardEvent;
});
/*react-dom@15.6.1#lib/SyntheticFocusEvent*/
define('react-dom@15.6.1#lib/SyntheticFocusEvent', function (require, exports, module) {
    'use strict';
    var SyntheticUIEvent = require('./SyntheticUIEvent');
    var FocusEventInterface = { relatedTarget: null };
    function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
        return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
    }
    SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);
    module.exports = SyntheticFocusEvent;
});
/*react-dom@15.6.1#lib/getEventCharCode*/
define('react-dom@15.6.1#lib/getEventCharCode', function (require, exports, module) {
    'use strict';
    function getEventCharCode(nativeEvent) {
        var charCode;
        var keyCode = nativeEvent.keyCode;
        if ('charCode' in nativeEvent) {
            charCode = nativeEvent.charCode;
            if (charCode === 0 && keyCode === 13) {
                charCode = 13;
            }
        } else {
            charCode = keyCode;
        }
        if (charCode >= 32 || charCode === 13) {
            return charCode;
        }
        return 0;
    }
    module.exports = getEventCharCode;
});
/*react-dom@15.6.1#lib/getEventKey*/
define('react-dom@15.6.1#lib/getEventKey', function (require, exports, module) {
    'use strict';
    var getEventCharCode = require('./getEventCharCode');
    var normalizeKey = {
        Esc: 'Escape',
        Spacebar: ' ',
        Left: 'ArrowLeft',
        Up: 'ArrowUp',
        Right: 'ArrowRight',
        Down: 'ArrowDown',
        Del: 'Delete',
        Win: 'OS',
        Menu: 'ContextMenu',
        Apps: 'ContextMenu',
        Scroll: 'ScrollLock',
        MozPrintableKey: 'Unidentified'
    };
    var translateToKey = {
        8: 'Backspace',
        9: 'Tab',
        12: 'Clear',
        13: 'Enter',
        16: 'Shift',
        17: 'Control',
        18: 'Alt',
        19: 'Pause',
        20: 'CapsLock',
        27: 'Escape',
        32: ' ',
        33: 'PageUp',
        34: 'PageDown',
        35: 'End',
        36: 'Home',
        37: 'ArrowLeft',
        38: 'ArrowUp',
        39: 'ArrowRight',
        40: 'ArrowDown',
        45: 'Insert',
        46: 'Delete',
        112: 'F1',
        113: 'F2',
        114: 'F3',
        115: 'F4',
        116: 'F5',
        117: 'F6',
        118: 'F7',
        119: 'F8',
        120: 'F9',
        121: 'F10',
        122: 'F11',
        123: 'F12',
        144: 'NumLock',
        145: 'ScrollLock',
        224: 'Meta'
    };
    function getEventKey(nativeEvent) {
        if (nativeEvent.key) {
            var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
            if (key !== 'Unidentified') {
                return key;
            }
        }
        if (nativeEvent.type === 'keypress') {
            var charCode = getEventCharCode(nativeEvent);
            return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
        }
        if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
            return translateToKey[nativeEvent.keyCode] || 'Unidentified';
        }
        return '';
    }
    module.exports = getEventKey;
});
/*react-dom@15.6.1#lib/SyntheticKeyboardEvent*/
define('react-dom@15.6.1#lib/SyntheticKeyboardEvent', function (require, exports, module) {
    'use strict';
    var SyntheticUIEvent = require('./SyntheticUIEvent');
    var getEventCharCode = require('./getEventCharCode');
    var getEventKey = require('./getEventKey');
    var getEventModifierState = require('./getEventModifierState');
    var KeyboardEventInterface = {
        key: getEventKey,
        location: null,
        ctrlKey: null,
        shiftKey: null,
        altKey: null,
        metaKey: null,
        repeat: null,
        locale: null,
        getModifierState: getEventModifierState,
        charCode: function (event) {
            if (event.type === 'keypress') {
                return getEventCharCode(event);
            }
            return 0;
        },
        keyCode: function (event) {
            if (event.type === 'keydown' || event.type === 'keyup') {
                return event.keyCode;
            }
            return 0;
        },
        which: function (event) {
            if (event.type === 'keypress') {
                return getEventCharCode(event);
            }
            if (event.type === 'keydown' || event.type === 'keyup') {
                return event.keyCode;
            }
            return 0;
        }
    };
    function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
        return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
    }
    SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);
    module.exports = SyntheticKeyboardEvent;
});
/*react-dom@15.6.1#lib/SyntheticDragEvent*/
define('react-dom@15.6.1#lib/SyntheticDragEvent', function (require, exports, module) {
    'use strict';
    var SyntheticMouseEvent = require('./SyntheticMouseEvent');
    var DragEventInterface = { dataTransfer: null };
    function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
        return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
    }
    SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);
    module.exports = SyntheticDragEvent;
});
/*react-dom@15.6.1#lib/SyntheticTouchEvent*/
define('react-dom@15.6.1#lib/SyntheticTouchEvent', function (require, exports, module) {
    'use strict';
    var SyntheticUIEvent = require('./SyntheticUIEvent');
    var getEventModifierState = require('./getEventModifierState');
    var TouchEventInterface = {
        touches: null,
        targetTouches: null,
        changedTouches: null,
        altKey: null,
        metaKey: null,
        ctrlKey: null,
        shiftKey: null,
        getModifierState: getEventModifierState
    };
    function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
        return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
    }
    SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);
    module.exports = SyntheticTouchEvent;
});
/*react-dom@15.6.1#lib/SyntheticTransitionEvent*/
define('react-dom@15.6.1#lib/SyntheticTransitionEvent', function (require, exports, module) {
    'use strict';
    var SyntheticEvent = require('./SyntheticEvent');
    var TransitionEventInterface = {
        propertyName: null,
        elapsedTime: null,
        pseudoElement: null
    };
    function SyntheticTransitionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
        return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
    }
    SyntheticEvent.augmentClass(SyntheticTransitionEvent, TransitionEventInterface);
    module.exports = SyntheticTransitionEvent;
});
/*react-dom@15.6.1#lib/SyntheticWheelEvent*/
define('react-dom@15.6.1#lib/SyntheticWheelEvent', function (require, exports, module) {
    'use strict';
    var SyntheticMouseEvent = require('./SyntheticMouseEvent');
    var WheelEventInterface = {
        deltaX: function (event) {
            return 'deltaX' in event ? event.deltaX : 'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
        },
        deltaY: function (event) {
            return 'deltaY' in event ? event.deltaY : 'wheelDeltaY' in event ? -event.wheelDeltaY : 'wheelDelta' in event ? -event.wheelDelta : 0;
        },
        deltaZ: null,
        deltaMode: null
    };
    function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
        return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
    }
    SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);
    module.exports = SyntheticWheelEvent;
});
/*react-dom@15.6.1#lib/SimpleEventPlugin*/
define('react-dom@15.6.1#lib/SimpleEventPlugin', function (require, exports, module) {
    'use strict';
    var _prodInvariant = require('./reactProdInvariant');
    var EventListener = require('fbjs/lib/EventListener');
    var EventPropagators = require('./EventPropagators');
    var ReactDOMComponentTree = require('./ReactDOMComponentTree');
    var SyntheticAnimationEvent = require('./SyntheticAnimationEvent');
    var SyntheticClipboardEvent = require('./SyntheticClipboardEvent');
    var SyntheticEvent = require('./SyntheticEvent');
    var SyntheticFocusEvent = require('./SyntheticFocusEvent');
    var SyntheticKeyboardEvent = require('./SyntheticKeyboardEvent');
    var SyntheticMouseEvent = require('./SyntheticMouseEvent');
    var SyntheticDragEvent = require('./SyntheticDragEvent');
    var SyntheticTouchEvent = require('./SyntheticTouchEvent');
    var SyntheticTransitionEvent = require('./SyntheticTransitionEvent');
    var SyntheticUIEvent = require('./SyntheticUIEvent');
    var SyntheticWheelEvent = require('./SyntheticWheelEvent');
    var emptyFunction = require('fbjs/lib/emptyFunction');
    var getEventCharCode = require('./getEventCharCode');
    var invariant = require('fbjs/lib/invariant');
    var eventTypes = {};
    var topLevelEventsToDispatchConfig = {};
    [
        'abort',
        'animationEnd',
        'animationIteration',
        'animationStart',
        'blur',
        'canPlay',
        'canPlayThrough',
        'click',
        'contextMenu',
        'copy',
        'cut',
        'doubleClick',
        'drag',
        'dragEnd',
        'dragEnter',
        'dragExit',
        'dragLeave',
        'dragOver',
        'dragStart',
        'drop',
        'durationChange',
        'emptied',
        'encrypted',
        'ended',
        'error',
        'focus',
        'input',
        'invalid',
        'keyDown',
        'keyPress',
        'keyUp',
        'load',
        'loadedData',
        'loadedMetadata',
        'loadStart',
        'mouseDown',
        'mouseMove',
        'mouseOut',
        'mouseOver',
        'mouseUp',
        'paste',
        'pause',
        'play',
        'playing',
        'progress',
        'rateChange',
        'reset',
        'scroll',
        'seeked',
        'seeking',
        'stalled',
        'submit',
        'suspend',
        'timeUpdate',
        'touchCancel',
        'touchEnd',
        'touchMove',
        'touchStart',
        'transitionEnd',
        'volumeChange',
        'waiting',
        'wheel'
    ].forEach(function (event) {
        var capitalizedEvent = event[0].toUpperCase() + event.slice(1);
        var onEvent = 'on' + capitalizedEvent;
        var topEvent = 'top' + capitalizedEvent;
        var type = {
            phasedRegistrationNames: {
                bubbled: onEvent,
                captured: onEvent + 'Capture'
            },
            dependencies: [topEvent]
        };
        eventTypes[event] = type;
        topLevelEventsToDispatchConfig[topEvent] = type;
    });
    var onClickListeners = {};
    function getDictionaryKey(inst) {
        return '.' + inst._rootNodeID;
    }
    function isInteractive(tag) {
        return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
    }
    var SimpleEventPlugin = {
        eventTypes: eventTypes,
        extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
            var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
            if (!dispatchConfig) {
                return null;
            }
            var EventConstructor;
            switch (topLevelType) {
            case 'topAbort':
            case 'topCanPlay':
            case 'topCanPlayThrough':
            case 'topDurationChange':
            case 'topEmptied':
            case 'topEncrypted':
            case 'topEnded':
            case 'topError':
            case 'topInput':
            case 'topInvalid':
            case 'topLoad':
            case 'topLoadedData':
            case 'topLoadedMetadata':
            case 'topLoadStart':
            case 'topPause':
            case 'topPlay':
            case 'topPlaying':
            case 'topProgress':
            case 'topRateChange':
            case 'topReset':
            case 'topSeeked':
            case 'topSeeking':
            case 'topStalled':
            case 'topSubmit':
            case 'topSuspend':
            case 'topTimeUpdate':
            case 'topVolumeChange':
            case 'topWaiting':
                EventConstructor = SyntheticEvent;
                break;
            case 'topKeyPress':
                if (getEventCharCode(nativeEvent) === 0) {
                    return null;
                }
            case 'topKeyDown':
            case 'topKeyUp':
                EventConstructor = SyntheticKeyboardEvent;
                break;
            case 'topBlur':
            case 'topFocus':
                EventConstructor = SyntheticFocusEvent;
                break;
            case 'topClick':
                if (nativeEvent.button === 2) {
                    return null;
                }
            case 'topDoubleClick':
            case 'topMouseDown':
            case 'topMouseMove':
            case 'topMouseUp':
            case 'topMouseOut':
            case 'topMouseOver':
            case 'topContextMenu':
                EventConstructor = SyntheticMouseEvent;
                break;
            case 'topDrag':
            case 'topDragEnd':
            case 'topDragEnter':
            case 'topDragExit':
            case 'topDragLeave':
            case 'topDragOver':
            case 'topDragStart':
            case 'topDrop':
                EventConstructor = SyntheticDragEvent;
                break;
            case 'topTouchCancel':
            case 'topTouchEnd':
            case 'topTouchMove':
            case 'topTouchStart':
                EventConstructor = SyntheticTouchEvent;
                break;
            case 'topAnimationEnd':
            case 'topAnimationIteration':
            case 'topAnimationStart':
                EventConstructor = SyntheticAnimationEvent;
                break;
            case 'topTransitionEnd':
                EventConstructor = SyntheticTransitionEvent;
                break;
            case 'topScroll':
                EventConstructor = SyntheticUIEvent;
                break;
            case 'topWheel':
                EventConstructor = SyntheticWheelEvent;
                break;
            case 'topCopy':
            case 'topCut':
            case 'topPaste':
                EventConstructor = SyntheticClipboardEvent;
                break;
            }
            !EventConstructor ? process.env.NODE_ENV !== 'production' ? invariant(false, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : _prodInvariant('86', topLevelType) : void 0;
            var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);
            EventPropagators.accumulateTwoPhaseDispatches(event);
            return event;
        },
        didPutListener: function (inst, registrationName, listener) {
            if (registrationName === 'onClick' && !isInteractive(inst._tag)) {
                var key = getDictionaryKey(inst);
                var node = ReactDOMComponentTree.getNodeFromInstance(inst);
                if (!onClickListeners[key]) {
                    onClickListeners[key] = EventListener.listen(node, 'click', emptyFunction);
                }
            }
        },
        willDeleteListener: function (inst, registrationName) {
            if (registrationName === 'onClick' && !isInteractive(inst._tag)) {
                var key = getDictionaryKey(inst);
                onClickListeners[key].remove();
                delete onClickListeners[key];
            }
        }
    };
    module.exports = SimpleEventPlugin;
});
/*react-dom@15.6.1#lib/ReactDefaultInjection*/
define('react-dom@15.6.1#lib/ReactDefaultInjection', function (require, exports, module) {
    'use strict';
    var ARIADOMPropertyConfig = require('./ARIADOMPropertyConfig');
    var BeforeInputEventPlugin = require('./BeforeInputEventPlugin');
    var ChangeEventPlugin = require('./ChangeEventPlugin');
    var DefaultEventPluginOrder = require('./DefaultEventPluginOrder');
    var EnterLeaveEventPlugin = require('./EnterLeaveEventPlugin');
    var HTMLDOMPropertyConfig = require('./HTMLDOMPropertyConfig');
    var ReactComponentBrowserEnvironment = require('./ReactComponentBrowserEnvironment');
    var ReactDOMComponent = require('./ReactDOMComponent');
    var ReactDOMComponentTree = require('./ReactDOMComponentTree');
    var ReactDOMEmptyComponent = require('./ReactDOMEmptyComponent');
    var ReactDOMTreeTraversal = require('./ReactDOMTreeTraversal');
    var ReactDOMTextComponent = require('./ReactDOMTextComponent');
    var ReactDefaultBatchingStrategy = require('./ReactDefaultBatchingStrategy');
    var ReactEventListener = require('./ReactEventListener');
    var ReactInjection = require('./ReactInjection');
    var ReactReconcileTransaction = require('./ReactReconcileTransaction');
    var SVGDOMPropertyConfig = require('./SVGDOMPropertyConfig');
    var SelectEventPlugin = require('./SelectEventPlugin');
    var SimpleEventPlugin = require('./SimpleEventPlugin');
    var alreadyInjected = false;
    function inject() {
        if (alreadyInjected) {
            return;
        }
        alreadyInjected = true;
        ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);
        ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
        ReactInjection.EventPluginUtils.injectComponentTree(ReactDOMComponentTree);
        ReactInjection.EventPluginUtils.injectTreeTraversal(ReactDOMTreeTraversal);
        ReactInjection.EventPluginHub.injectEventPluginsByName({
            SimpleEventPlugin: SimpleEventPlugin,
            EnterLeaveEventPlugin: EnterLeaveEventPlugin,
            ChangeEventPlugin: ChangeEventPlugin,
            SelectEventPlugin: SelectEventPlugin,
            BeforeInputEventPlugin: BeforeInputEventPlugin
        });
        ReactInjection.HostComponent.injectGenericComponentClass(ReactDOMComponent);
        ReactInjection.HostComponent.injectTextComponentClass(ReactDOMTextComponent);
        ReactInjection.DOMProperty.injectDOMPropertyConfig(ARIADOMPropertyConfig);
        ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
        ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);
        ReactInjection.EmptyComponent.injectEmptyComponentFactory(function (instantiate) {
            return new ReactDOMEmptyComponent(instantiate);
        });
        ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction);
        ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);
        ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);
    }
    module.exports = { inject: inject };
});
/*react-dom@15.6.1#lib/ReactDOMContainerInfo*/
define('react-dom@15.6.1#lib/ReactDOMContainerInfo', function (require, exports, module) {
    'use strict';
    var validateDOMNesting = require('./validateDOMNesting');
    var DOC_NODE_TYPE = 9;
    function ReactDOMContainerInfo(topLevelWrapper, node) {
        var info = {
            _topLevelWrapper: topLevelWrapper,
            _idCounter: 1,
            _ownerDocument: node ? node.nodeType === DOC_NODE_TYPE ? node : node.ownerDocument : null,
            _node: node,
            _tag: node ? node.nodeName.toLowerCase() : null,
            _namespaceURI: node ? node.namespaceURI : null
        };
        if (process.env.NODE_ENV !== 'production') {
            info._ancestorInfo = node ? validateDOMNesting.updatedAncestorInfo(null, info._tag, null) : null;
        }
        return info;
    }
    module.exports = ReactDOMContainerInfo;
});
/*react-dom@15.6.1#lib/ReactDOMFeatureFlags*/
define('react-dom@15.6.1#lib/ReactDOMFeatureFlags', function (require, exports, module) {
    'use strict';
    var ReactDOMFeatureFlags = {
        useCreateElement: true,
        useFiber: false
    };
    module.exports = ReactDOMFeatureFlags;
});
/*react-dom@15.6.1#lib/adler32*/
define('react-dom@15.6.1#lib/adler32', function (require, exports, module) {
    'use strict';
    var MOD = 65521;
    function adler32(data) {
        var a = 1;
        var b = 0;
        var i = 0;
        var l = data.length;
        var m = l & ~3;
        while (i < m) {
            var n = Math.min(i + 4096, m);
            for (; i < n; i += 4) {
                b += (a += data.charCodeAt(i)) + (a += data.charCodeAt(i + 1)) + (a += data.charCodeAt(i + 2)) + (a += data.charCodeAt(i + 3));
            }
            a %= MOD;
            b %= MOD;
        }
        for (; i < l; i++) {
            b += a += data.charCodeAt(i);
        }
        a %= MOD;
        b %= MOD;
        return a | b << 16;
    }
    module.exports = adler32;
});
/*react-dom@15.6.1#lib/ReactMarkupChecksum*/
define('react-dom@15.6.1#lib/ReactMarkupChecksum', function (require, exports, module) {
    'use strict';
    var adler32 = require('./adler32');
    var TAG_END = /\/?>/;
    var COMMENT_START = /^<\!\-\-/;
    var ReactMarkupChecksum = {
        CHECKSUM_ATTR_NAME: 'data-react-checksum',
        addChecksumToMarkup: function (markup) {
            var checksum = adler32(markup);
            if (COMMENT_START.test(markup)) {
                return markup;
            } else {
                return markup.replace(TAG_END, ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '"$&');
            }
        },
        canReuseMarkup: function (markup, element) {
            var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
            existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
            var markupChecksum = adler32(markup);
            return markupChecksum === existingChecksum;
        }
    };
    module.exports = ReactMarkupChecksum;
});
/*react-dom@15.6.1#lib/ReactMount*/
define('react-dom@15.6.1#lib/ReactMount', function (require, exports, module) {
    'use strict';
    var _prodInvariant = require('./reactProdInvariant');
    var DOMLazyTree = require('./DOMLazyTree');
    var DOMProperty = require('./DOMProperty');
    var React = require('react/lib/React');
    var ReactBrowserEventEmitter = require('./ReactBrowserEventEmitter');
    var ReactCurrentOwner = require('react/lib/ReactCurrentOwner');
    var ReactDOMComponentTree = require('./ReactDOMComponentTree');
    var ReactDOMContainerInfo = require('./ReactDOMContainerInfo');
    var ReactDOMFeatureFlags = require('./ReactDOMFeatureFlags');
    var ReactFeatureFlags = require('./ReactFeatureFlags');
    var ReactInstanceMap = require('./ReactInstanceMap');
    var ReactInstrumentation = require('./ReactInstrumentation');
    var ReactMarkupChecksum = require('./ReactMarkupChecksum');
    var ReactReconciler = require('./ReactReconciler');
    var ReactUpdateQueue = require('./ReactUpdateQueue');
    var ReactUpdates = require('./ReactUpdates');
    var emptyObject = require('fbjs/lib/emptyObject');
    var instantiateReactComponent = require('./instantiateReactComponent');
    var invariant = require('fbjs/lib/invariant');
    var setInnerHTML = require('./setInnerHTML');
    var shouldUpdateReactComponent = require('./shouldUpdateReactComponent');
    var warning = require('fbjs/lib/warning');
    var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
    var ROOT_ATTR_NAME = DOMProperty.ROOT_ATTRIBUTE_NAME;
    var ELEMENT_NODE_TYPE = 1;
    var DOC_NODE_TYPE = 9;
    var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
    var instancesByReactRootID = {};
    function firstDifferenceIndex(string1, string2) {
        var minLen = Math.min(string1.length, string2.length);
        for (var i = 0; i < minLen; i++) {
            if (string1.charAt(i) !== string2.charAt(i)) {
                return i;
            }
        }
        return string1.length === string2.length ? -1 : minLen;
    }
    function getReactRootElementInContainer(container) {
        if (!container) {
            return null;
        }
        if (container.nodeType === DOC_NODE_TYPE) {
            return container.documentElement;
        } else {
            return container.firstChild;
        }
    }
    function internalGetID(node) {
        return node.getAttribute && node.getAttribute(ATTR_NAME) || '';
    }
    function mountComponentIntoNode(wrapperInstance, container, transaction, shouldReuseMarkup, context) {
        var markerName;
        if (ReactFeatureFlags.logTopLevelRenders) {
            var wrappedElement = wrapperInstance._currentElement.props.child;
            var type = wrappedElement.type;
            markerName = 'React mount: ' + (typeof type === 'string' ? type : type.displayName || type.name);
            console.time(markerName);
        }
        var markup = ReactReconciler.mountComponent(wrapperInstance, transaction, null, ReactDOMContainerInfo(wrapperInstance, container), context, 0);
        if (markerName) {
            console.timeEnd(markerName);
        }
        wrapperInstance._renderedComponent._topLevelWrapper = wrapperInstance;
        ReactMount._mountImageIntoNode(markup, container, wrapperInstance, shouldReuseMarkup, transaction);
    }
    function batchedMountComponentIntoNode(componentInstance, container, shouldReuseMarkup, context) {
        var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(!shouldReuseMarkup && ReactDOMFeatureFlags.useCreateElement);
        transaction.perform(mountComponentIntoNode, null, componentInstance, container, transaction, shouldReuseMarkup, context);
        ReactUpdates.ReactReconcileTransaction.release(transaction);
    }
    function unmountComponentFromNode(instance, container, safely) {
        if (process.env.NODE_ENV !== 'production') {
            ReactInstrumentation.debugTool.onBeginFlush();
        }
        ReactReconciler.unmountComponent(instance, safely);
        if (process.env.NODE_ENV !== 'production') {
            ReactInstrumentation.debugTool.onEndFlush();
        }
        if (container.nodeType === DOC_NODE_TYPE) {
            container = container.documentElement;
        }
        while (container.lastChild) {
            container.removeChild(container.lastChild);
        }
    }
    function hasNonRootReactChild(container) {
        var rootEl = getReactRootElementInContainer(container);
        if (rootEl) {
            var inst = ReactDOMComponentTree.getInstanceFromNode(rootEl);
            return !!(inst && inst._hostParent);
        }
    }
    function nodeIsRenderedByOtherInstance(container) {
        var rootEl = getReactRootElementInContainer(container);
        return !!(rootEl && isReactNode(rootEl) && !ReactDOMComponentTree.getInstanceFromNode(rootEl));
    }
    function isValidContainer(node) {
        return !!(node && (node.nodeType === ELEMENT_NODE_TYPE || node.nodeType === DOC_NODE_TYPE || node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE));
    }
    function isReactNode(node) {
        return isValidContainer(node) && (node.hasAttribute(ROOT_ATTR_NAME) || node.hasAttribute(ATTR_NAME));
    }
    function getHostRootInstanceInContainer(container) {
        var rootEl = getReactRootElementInContainer(container);
        var prevHostInstance = rootEl && ReactDOMComponentTree.getInstanceFromNode(rootEl);
        return prevHostInstance && !prevHostInstance._hostParent ? prevHostInstance : null;
    }
    function getTopLevelWrapperInContainer(container) {
        var root = getHostRootInstanceInContainer(container);
        return root ? root._hostContainerInfo._topLevelWrapper : null;
    }
    var topLevelRootCounter = 1;
    var TopLevelWrapper = function () {
        this.rootID = topLevelRootCounter++;
    };
    TopLevelWrapper.prototype.isReactComponent = {};
    if (process.env.NODE_ENV !== 'production') {
        TopLevelWrapper.displayName = 'TopLevelWrapper';
    }
    TopLevelWrapper.prototype.render = function () {
        return this.props.child;
    };
    TopLevelWrapper.isReactTopLevelWrapper = true;
    var ReactMount = {
        TopLevelWrapper: TopLevelWrapper,
        _instancesByReactRootID: instancesByReactRootID,
        scrollMonitor: function (container, renderCallback) {
            renderCallback();
        },
        _updateRootComponent: function (prevComponent, nextElement, nextContext, container, callback) {
            ReactMount.scrollMonitor(container, function () {
                ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement, nextContext);
                if (callback) {
                    ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
                }
            });
            return prevComponent;
        },
        _renderNewRootComponent: function (nextElement, container, shouldReuseMarkup, context) {
            process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;
            !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : _prodInvariant('37') : void 0;
            ReactBrowserEventEmitter.ensureScrollValueMonitoring();
            var componentInstance = instantiateReactComponent(nextElement, false);
            ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, container, shouldReuseMarkup, context);
            var wrapperID = componentInstance._instance.rootID;
            instancesByReactRootID[wrapperID] = componentInstance;
            return componentInstance;
        },
        renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
            !(parentComponent != null && ReactInstanceMap.has(parentComponent)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'parentComponent must be a valid React Component') : _prodInvariant('38') : void 0;
            return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
        },
        _renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
            ReactUpdateQueue.validateCallback(callback, 'ReactDOM.render');
            !React.isValidElement(nextElement) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOM.render(): Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing a string like \'div\', pass ' + 'React.createElement(\'div\') or <div />.' : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' : nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : _prodInvariant('39', typeof nextElement === 'string' ? ' Instead of passing a string like \'div\', pass ' + 'React.createElement(\'div\') or <div />.' : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' : nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : void 0;
            process.env.NODE_ENV !== 'production' ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : void 0;
            var nextWrappedElement = React.createElement(TopLevelWrapper, { child: nextElement });
            var nextContext;
            if (parentComponent) {
                var parentInst = ReactInstanceMap.get(parentComponent);
                nextContext = parentInst._processChildContext(parentInst._context);
            } else {
                nextContext = emptyObject;
            }
            var prevComponent = getTopLevelWrapperInContainer(container);
            if (prevComponent) {
                var prevWrappedElement = prevComponent._currentElement;
                var prevElement = prevWrappedElement.props.child;
                if (shouldUpdateReactComponent(prevElement, nextElement)) {
                    var publicInst = prevComponent._renderedComponent.getPublicInstance();
                    var updatedCallback = callback && function () {
                        callback.call(publicInst);
                    };
                    ReactMount._updateRootComponent(prevComponent, nextWrappedElement, nextContext, container, updatedCallback);
                    return publicInst;
                } else {
                    ReactMount.unmountComponentAtNode(container);
                }
            }
            var reactRootElement = getReactRootElementInContainer(container);
            var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);
            var containerHasNonRootReactChild = hasNonRootReactChild(container);
            if (process.env.NODE_ENV !== 'production') {
                process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : void 0;
                if (!containerHasReactMarkup || reactRootElement.nextSibling) {
                    var rootElementSibling = reactRootElement;
                    while (rootElementSibling) {
                        if (internalGetID(rootElementSibling)) {
                            process.env.NODE_ENV !== 'production' ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : void 0;
                            break;
                        }
                        rootElementSibling = rootElementSibling.nextSibling;
                    }
                }
            }
            var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;
            var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, nextContext)._renderedComponent.getPublicInstance();
            if (callback) {
                callback.call(component);
            }
            return component;
        },
        render: function (nextElement, container, callback) {
            return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);
        },
        unmountComponentAtNode: function (container) {
            process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;
            !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : _prodInvariant('40') : void 0;
            if (process.env.NODE_ENV !== 'production') {
                process.env.NODE_ENV !== 'production' ? warning(!nodeIsRenderedByOtherInstance(container), 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by another copy of React.') : void 0;
            }
            var prevComponent = getTopLevelWrapperInContainer(container);
            if (!prevComponent) {
                var containerHasNonRootReactChild = hasNonRootReactChild(container);
                var isContainerReactRoot = container.nodeType === 1 && container.hasAttribute(ROOT_ATTR_NAME);
                if (process.env.NODE_ENV !== 'production') {
                    process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : void 0;
                }
                return false;
            }
            delete instancesByReactRootID[prevComponent._instance.rootID];
            ReactUpdates.batchedUpdates(unmountComponentFromNode, prevComponent, container, false);
            return true;
        },
        _mountImageIntoNode: function (markup, container, instance, shouldReuseMarkup, transaction) {
            !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : _prodInvariant('41') : void 0;
            if (shouldReuseMarkup) {
                var rootElement = getReactRootElementInContainer(container);
                if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
                    ReactDOMComponentTree.precacheNode(instance, rootElement);
                    return;
                } else {
                    var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
                    rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
                    var rootMarkup = rootElement.outerHTML;
                    rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);
                    var normalizedMarkup = markup;
                    if (process.env.NODE_ENV !== 'production') {
                        var normalizer;
                        if (container.nodeType === ELEMENT_NODE_TYPE) {
                            normalizer = document.createElement('div');
                            normalizer.innerHTML = markup;
                            normalizedMarkup = normalizer.innerHTML;
                        } else {
                            normalizer = document.createElement('iframe');
                            document.body.appendChild(normalizer);
                            normalizer.contentDocument.write(markup);
                            normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;
                            document.body.removeChild(normalizer);
                        }
                    }
                    var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);
                    var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);
                    !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document using server rendering but the checksum was invalid. This usually means you rendered a different component type or props on the client from the one on the server, or your render() methods are impure. React cannot handle this case due to cross-browser quirks by rendering at the document root. You should look for environment dependent code in your components and ensure the props are the same client and server side:\n%s', difference) : _prodInvariant('42', difference) : void 0;
                    if (process.env.NODE_ENV !== 'production') {
                        process.env.NODE_ENV !== 'production' ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\n%s', difference) : void 0;
                    }
                }
            }
            !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document but you didn\'t use server rendering. We can\'t do this without using server rendering due to cross-browser quirks. See ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('43') : void 0;
            if (transaction.useCreateElement) {
                while (container.lastChild) {
                    container.removeChild(container.lastChild);
                }
                DOMLazyTree.insertTreeBefore(container, markup, null);
            } else {
                setInnerHTML(container, markup);
                ReactDOMComponentTree.precacheNode(instance, container.firstChild);
            }
            if (process.env.NODE_ENV !== 'production') {
                var hostNode = ReactDOMComponentTree.getInstanceFromNode(container.firstChild);
                if (hostNode._debugID !== 0) {
                    ReactInstrumentation.debugTool.onHostOperation({
                        instanceID: hostNode._debugID,
                        type: 'mount',
                        payload: markup.toString()
                    });
                }
            }
        }
    };
    module.exports = ReactMount;
});
/*react-dom@15.6.1#lib/ReactVersion*/
define('react-dom@15.6.1#lib/ReactVersion', function (require, exports, module) {
    'use strict';
    module.exports = '15.6.1';
});
/*react-dom@15.6.1#lib/getHostComponentFromComposite*/
define('react-dom@15.6.1#lib/getHostComponentFromComposite', function (require, exports, module) {
    'use strict';
    var ReactNodeTypes = require('./ReactNodeTypes');
    function getHostComponentFromComposite(inst) {
        var type;
        while ((type = inst._renderedNodeType) === ReactNodeTypes.COMPOSITE) {
            inst = inst._renderedComponent;
        }
        if (type === ReactNodeTypes.HOST) {
            return inst._renderedComponent;
        } else if (type === ReactNodeTypes.EMPTY) {
            return null;
        }
    }
    module.exports = getHostComponentFromComposite;
});
/*react-dom@15.6.1#lib/findDOMNode*/
define('react-dom@15.6.1#lib/findDOMNode', function (require, exports, module) {
    'use strict';
    var _prodInvariant = require('./reactProdInvariant');
    var ReactCurrentOwner = require('react/lib/ReactCurrentOwner');
    var ReactDOMComponentTree = require('./ReactDOMComponentTree');
    var ReactInstanceMap = require('./ReactInstanceMap');
    var getHostComponentFromComposite = require('./getHostComponentFromComposite');
    var invariant = require('fbjs/lib/invariant');
    var warning = require('fbjs/lib/warning');
    function findDOMNode(componentOrElement) {
        if (process.env.NODE_ENV !== 'production') {
            var owner = ReactCurrentOwner.current;
            if (owner !== null) {
                process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
                owner._warnedAboutRefsInRender = true;
            }
        }
        if (componentOrElement == null) {
            return null;
        }
        if (componentOrElement.nodeType === 1) {
            return componentOrElement;
        }
        var inst = ReactInstanceMap.get(componentOrElement);
        if (inst) {
            inst = getHostComponentFromComposite(inst);
            return inst ? ReactDOMComponentTree.getNodeFromInstance(inst) : null;
        }
        if (typeof componentOrElement.render === 'function') {
            !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findDOMNode was called on an unmounted component.') : _prodInvariant('44') : void 0;
        } else {
            !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element appears to be neither ReactComponent nor DOMNode (keys: %s)', Object.keys(componentOrElement)) : _prodInvariant('45', Object.keys(componentOrElement)) : void 0;
        }
    }
    module.exports = findDOMNode;
});
/*react-dom@15.6.1#lib/renderSubtreeIntoContainer*/
define('react-dom@15.6.1#lib/renderSubtreeIntoContainer', function (require, exports, module) {
    'use strict';
    var ReactMount = require('./ReactMount');
    module.exports = ReactMount.renderSubtreeIntoContainer;
});
/*react-dom@15.6.1#lib/ReactDOMUnknownPropertyHook*/
define('react-dom@15.6.1#lib/ReactDOMUnknownPropertyHook', function (require, exports, module) {
    'use strict';
    var DOMProperty = require('./DOMProperty');
    var EventPluginRegistry = require('./EventPluginRegistry');
    var ReactComponentTreeHook = require('react/lib/ReactComponentTreeHook');
    var warning = require('fbjs/lib/warning');
    if (process.env.NODE_ENV !== 'production') {
        var reactProps = {
            children: true,
            dangerouslySetInnerHTML: true,
            key: true,
            ref: true,
            autoFocus: true,
            defaultValue: true,
            valueLink: true,
            defaultChecked: true,
            checkedLink: true,
            innerHTML: true,
            suppressContentEditableWarning: true,
            onFocusIn: true,
            onFocusOut: true
        };
        var warnedProperties = {};
        var validateProperty = function (tagName, name, debugID) {
            if (DOMProperty.properties.hasOwnProperty(name) || DOMProperty.isCustomAttribute(name)) {
                return true;
            }
            if (reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
                return true;
            }
            if (EventPluginRegistry.registrationNameModules.hasOwnProperty(name)) {
                return true;
            }
            warnedProperties[name] = true;
            var lowerCasedName = name.toLowerCase();
            var standardName = DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;
            var registrationName = EventPluginRegistry.possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? EventPluginRegistry.possibleRegistrationNames[lowerCasedName] : null;
            if (standardName != null) {
                process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown DOM property %s. Did you mean %s?%s', name, standardName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
                return true;
            } else if (registrationName != null) {
                process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown event handler property %s. Did you mean `%s`?%s', name, registrationName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
                return true;
            } else {
                return false;
            }
        };
    }
    var warnUnknownProperties = function (debugID, element) {
        var unknownProps = [];
        for (var key in element.props) {
            var isValid = validateProperty(element.type, key, debugID);
            if (!isValid) {
                unknownProps.push(key);
            }
        }
        var unknownPropString = unknownProps.map(function (prop) {
            return '`' + prop + '`';
        }).join(', ');
        if (unknownProps.length === 1) {
            process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown prop %s on <%s> tag. Remove this prop from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
        } else if (unknownProps.length > 1) {
            process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown props %s on <%s> tag. Remove these props from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
        }
    };
    function handleElement(debugID, element) {
        if (element == null || typeof element.type !== 'string') {
            return;
        }
        if (element.type.indexOf('-') >= 0 || element.props.is) {
            return;
        }
        warnUnknownProperties(debugID, element);
    }
    var ReactDOMUnknownPropertyHook = {
        onBeforeMountComponent: function (debugID, element) {
            handleElement(debugID, element);
        },
        onBeforeUpdateComponent: function (debugID, element) {
            handleElement(debugID, element);
        }
    };
    module.exports = ReactDOMUnknownPropertyHook;
});
/*react-dom@15.6.1#lib/ReactDOMNullInputValuePropHook*/
define('react-dom@15.6.1#lib/ReactDOMNullInputValuePropHook', function (require, exports, module) {
    'use strict';
    var ReactComponentTreeHook = require('react/lib/ReactComponentTreeHook');
    var warning = require('fbjs/lib/warning');
    var didWarnValueNull = false;
    function handleElement(debugID, element) {
        if (element == null) {
            return;
        }
        if (element.type !== 'input' && element.type !== 'textarea' && element.type !== 'select') {
            return;
        }
        if (element.props != null && element.props.value === null && !didWarnValueNull) {
            process.env.NODE_ENV !== 'production' ? warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using the empty string to clear the component or `undefined` ' + 'for uncontrolled components.%s', element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
            didWarnValueNull = true;
        }
    }
    var ReactDOMNullInputValuePropHook = {
        onBeforeMountComponent: function (debugID, element) {
            handleElement(debugID, element);
        },
        onBeforeUpdateComponent: function (debugID, element) {
            handleElement(debugID, element);
        }
    };
    module.exports = ReactDOMNullInputValuePropHook;
});
/*react-dom@15.6.1#lib/ReactDOMInvalidARIAHook*/
define('react-dom@15.6.1#lib/ReactDOMInvalidARIAHook', function (require, exports, module) {
    'use strict';
    var DOMProperty = require('./DOMProperty');
    var ReactComponentTreeHook = require('react/lib/ReactComponentTreeHook');
    var warning = require('fbjs/lib/warning');
    var warnedProperties = {};
    var rARIA = new RegExp('^(aria)-[' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$');
    function validateProperty(tagName, name, debugID) {
        if (warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
            return true;
        }
        if (rARIA.test(name)) {
            var lowerCasedName = name.toLowerCase();
            var standardName = DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;
            if (standardName == null) {
                warnedProperties[name] = true;
                return false;
            }
            if (name !== standardName) {
                process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown ARIA attribute %s. Did you mean %s?%s', name, standardName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
                warnedProperties[name] = true;
                return true;
            }
        }
        return true;
    }
    function warnInvalidARIAProps(debugID, element) {
        var invalidProps = [];
        for (var key in element.props) {
            var isValid = validateProperty(element.type, key, debugID);
            if (!isValid) {
                invalidProps.push(key);
            }
        }
        var unknownPropString = invalidProps.map(function (prop) {
            return '`' + prop + '`';
        }).join(', ');
        if (invalidProps.length === 1) {
            process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid aria prop %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
        } else if (invalidProps.length > 1) {
            process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid aria props %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
        }
    }
    function handleElement(debugID, element) {
        if (element == null || typeof element.type !== 'string') {
            return;
        }
        if (element.type.indexOf('-') >= 0 || element.props.is) {
            return;
        }
        warnInvalidARIAProps(debugID, element);
    }
    var ReactDOMInvalidARIAHook = {
        onBeforeMountComponent: function (debugID, element) {
            if (process.env.NODE_ENV !== 'production') {
                handleElement(debugID, element);
            }
        },
        onBeforeUpdateComponent: function (debugID, element) {
            if (process.env.NODE_ENV !== 'production') {
                handleElement(debugID, element);
            }
        }
    };
    module.exports = ReactDOMInvalidARIAHook;
});
/*react-dom@15.6.1#lib/ReactDOM*/
define('react-dom@15.6.1#lib/ReactDOM', function (require, exports, module) {
    (function (global) {
        'use strict';
        var ReactDOMComponentTree = require('./ReactDOMComponentTree');
        var ReactDefaultInjection = require('./ReactDefaultInjection');
        var ReactMount = require('./ReactMount');
        var ReactReconciler = require('./ReactReconciler');
        var ReactUpdates = require('./ReactUpdates');
        var ReactVersion = require('./ReactVersion');
        var findDOMNode = require('./findDOMNode');
        var getHostComponentFromComposite = require('./getHostComponentFromComposite');
        var renderSubtreeIntoContainer = require('./renderSubtreeIntoContainer');
        var warning = require('fbjs/lib/warning');
        ReactDefaultInjection.inject();
        var ReactDOM = {
            findDOMNode: findDOMNode,
            render: ReactMount.render,
            unmountComponentAtNode: ReactMount.unmountComponentAtNode,
            version: ReactVersion,
            unstable_batchedUpdates: ReactUpdates.batchedUpdates,
            unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer
        };
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
                ComponentTree: {
                    getClosestInstanceFromNode: ReactDOMComponentTree.getClosestInstanceFromNode,
                    getNodeFromInstance: function (inst) {
                        if (inst._renderedComponent) {
                            inst = getHostComponentFromComposite(inst);
                        }
                        if (inst) {
                            return ReactDOMComponentTree.getNodeFromInstance(inst);
                        } else {
                            return null;
                        }
                    }
                },
                Mount: ReactMount,
                Reconciler: ReactReconciler
            });
        }
        if (process.env.NODE_ENV !== 'production') {
            var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
            if (ExecutionEnvironment.canUseDOM && window.top === window.self) {
                if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
                    if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
                        var showFileUrlMessage = window.location.protocol.indexOf('http') === -1 && navigator.userAgent.indexOf('Firefox') === -1;
                        console.debug('Download the React DevTools ' + (showFileUrlMessage ? 'and use an HTTP server (instead of a file: URL) ' : '') + 'for a better development experience: ' + 'https://fb.me/react-devtools');
                    }
                }
                var testFunc = function testFn() {
                };
                process.env.NODE_ENV !== 'production' ? warning((testFunc.name || testFunc.toString()).indexOf('testFn') !== -1, 'It looks like you\'re using a minified copy of the development build ' + 'of React. When deploying React apps to production, make sure to use ' + 'the production build which skips development warnings and is faster. ' + 'See https://fb.me/react-minification for more details.') : void 0;
                var ieCompatibilityMode = document.documentMode && document.documentMode < 8;
                process.env.NODE_ENV !== 'production' ? warning(!ieCompatibilityMode, 'Internet Explorer is running in compatibility mode; please add the ' + 'following tag to your HTML to prevent this from happening: ' + '<meta http-equiv="X-UA-Compatible" content="IE=edge" />') : void 0;
                var expectedFeatures = [
                    Array.isArray,
                    Array.prototype.every,
                    Array.prototype.forEach,
                    Array.prototype.indexOf,
                    Array.prototype.map,
                    Date.now,
                    Function.prototype.bind,
                    Object.keys,
                    String.prototype.trim
                ];
                for (var i = 0; i < expectedFeatures.length; i++) {
                    if (!expectedFeatures[i]) {
                        process.env.NODE_ENV !== 'production' ? warning(false, 'One or more ES5 shims expected by React are not available: ' + 'https://fb.me/react-warning-polyfills') : void 0;
                        break;
                    }
                }
            }
        }
        if (process.env.NODE_ENV !== 'production') {
            var ReactInstrumentation = require('./ReactInstrumentation');
            var ReactDOMUnknownPropertyHook = require('./ReactDOMUnknownPropertyHook');
            var ReactDOMNullInputValuePropHook = require('./ReactDOMNullInputValuePropHook');
            var ReactDOMInvalidARIAHook = require('./ReactDOMInvalidARIAHook');
            ReactInstrumentation.debugTool.addHook(ReactDOMUnknownPropertyHook);
            ReactInstrumentation.debugTool.addHook(ReactDOMNullInputValuePropHook);
            ReactInstrumentation.debugTool.addHook(ReactDOMInvalidARIAHook);
        }
        module.exports = ReactDOM;
    }(function () {
        return this;
    }()));
});
/*react-dom@15.6.1#lib/ReactShallowRenderer*/
define('react-dom@15.6.1#lib/ReactShallowRenderer', function (require, exports, module) {
    'use strict';
    var _prodInvariant = require('./reactProdInvariant'), _assign = require('object-assign');
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError('Cannot call a class as a function');
        }
    }
    var React = require('react/lib/React');
    var ReactCompositeComponent = require('./ReactCompositeComponent');
    var ReactDefaultBatchingStrategy = require('./ReactDefaultBatchingStrategy');
    var ReactReconciler = require('./ReactReconciler');
    var ReactReconcileTransaction = require('./ReactReconcileTransaction');
    var ReactUpdates = require('./ReactUpdates');
    var emptyObject = require('fbjs/lib/emptyObject');
    var getNextDebugID = require('react/lib/getNextDebugID');
    var invariant = require('fbjs/lib/invariant');
    function injectDefaults() {
        ReactUpdates.injection.injectReconcileTransaction(ReactReconcileTransaction);
        ReactUpdates.injection.injectBatchingStrategy(ReactDefaultBatchingStrategy);
    }
    var NoopInternalComponent = function () {
        function NoopInternalComponent(element) {
            _classCallCheck(this, NoopInternalComponent);
            this._renderedOutput = element;
            this._currentElement = element;
            if (process.env.NODE_ENV !== 'production') {
                this._debugID = getNextDebugID();
            }
        }
        NoopInternalComponent.prototype.mountComponent = function mountComponent() {
        };
        NoopInternalComponent.prototype.receiveComponent = function receiveComponent(element) {
            this._renderedOutput = element;
            this._currentElement = element;
        };
        NoopInternalComponent.prototype.unmountComponent = function unmountComponent() {
        };
        NoopInternalComponent.prototype.getHostNode = function getHostNode() {
            return undefined;
        };
        NoopInternalComponent.prototype.getPublicInstance = function getPublicInstance() {
            return null;
        };
        return NoopInternalComponent;
    }();
    var ShallowComponentWrapper = function (element) {
        if (process.env.NODE_ENV !== 'production') {
            this._debugID = getNextDebugID();
        }
        this.construct(element);
    };
    _assign(ShallowComponentWrapper.prototype, ReactCompositeComponent, {
        _constructComponent: ReactCompositeComponent._constructComponentWithoutOwner,
        _instantiateReactComponent: function (element) {
            return new NoopInternalComponent(element);
        },
        _replaceNodeWithMarkup: function () {
        },
        _renderValidatedComponent: ReactCompositeComponent._renderValidatedComponentWithoutOwnerOrContext
    });
    function _batchedRender(renderer, element, context) {
        var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(true);
        renderer._render(element, transaction, context);
        ReactUpdates.ReactReconcileTransaction.release(transaction);
    }
    var ReactShallowRenderer = function () {
        function ReactShallowRenderer() {
            _classCallCheck(this, ReactShallowRenderer);
            this._instance = null;
        }
        ReactShallowRenderer.prototype.getMountedInstance = function getMountedInstance() {
            return this._instance ? this._instance._instance : null;
        };
        ReactShallowRenderer.prototype.render = function render(element, context) {
            injectDefaults();
            !React.isValidElement(element) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactShallowRenderer render(): Invalid component element.%s', typeof element === 'function' ? ' Instead of passing a component class, make sure to instantiate ' + 'it by passing it to React.createElement.' : '') : _prodInvariant('12', typeof element === 'function' ? ' Instead of passing a component class, make sure to instantiate ' + 'it by passing it to React.createElement.' : '') : void 0;
            !(typeof element.type !== 'string') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactShallowRenderer render(): Shallow rendering works only with custom components, not primitives (%s). Instead of calling `.render(el)` and inspecting the rendered output, look at `el.props` directly instead.', element.type) : _prodInvariant('13', element.type) : void 0;
            if (!context) {
                context = emptyObject;
            }
            ReactUpdates.batchedUpdates(_batchedRender, this, element, context);
            return this.getRenderOutput();
        };
        ReactShallowRenderer.prototype.getRenderOutput = function getRenderOutput() {
            return this._instance && this._instance._renderedComponent && this._instance._renderedComponent._renderedOutput || null;
        };
        ReactShallowRenderer.prototype.unmount = function unmount() {
            if (this._instance) {
                ReactReconciler.unmountComponent(this._instance, false);
            }
        };
        ReactShallowRenderer.prototype.unstable_batchedUpdates = function unstable_batchedUpdates(callback, bookkeeping) {
            injectDefaults();
            return ReactUpdates.batchedUpdates(callback, bookkeeping);
        };
        ReactShallowRenderer.prototype._render = function _render(element, transaction, context) {
            if (this._instance) {
                ReactReconciler.receiveComponent(this._instance, element, transaction, context);
            } else {
                var instance = new ShallowComponentWrapper(element);
                ReactReconciler.mountComponent(instance, transaction, null, null, context, 0);
                this._instance = instance;
            }
        };
        return ReactShallowRenderer;
    }();
    ReactShallowRenderer.createRenderer = function () {
        return new ReactShallowRenderer();
    };
    module.exports = ReactShallowRenderer;
});
/*react-dom@15.6.1#lib/ReactTestUtils*/
define('react-dom@15.6.1#lib/ReactTestUtils', function (require, exports, module) {
    'use strict';
    var _prodInvariant = require('./reactProdInvariant'), _assign = require('object-assign');
    var EventConstants = require('./EventConstants');
    var EventPluginHub = require('./EventPluginHub');
    var EventPluginRegistry = require('./EventPluginRegistry');
    var EventPropagators = require('./EventPropagators');
    var React = require('react/lib/React');
    var ReactDOM = require('./ReactDOM');
    var ReactDOMComponentTree = require('./ReactDOMComponentTree');
    var ReactBrowserEventEmitter = require('./ReactBrowserEventEmitter');
    var ReactInstanceMap = require('./ReactInstanceMap');
    var ReactUpdates = require('./ReactUpdates');
    var SyntheticEvent = require('./SyntheticEvent');
    var ReactShallowRenderer = require('./ReactShallowRenderer');
    var findDOMNode = require('./findDOMNode');
    var invariant = require('fbjs/lib/invariant');
    var warning = require('fbjs/lib/warning');
    var topLevelTypes = EventConstants.topLevelTypes;
    function Event(suffix) {
    }
    var hasWarnedAboutCreateRenderer = false;
    function createRendererWithWarning() {
        process.env.NODE_ENV !== 'production' ? warning(hasWarnedAboutCreateRenderer, 'Shallow renderer has been moved to react-test-renderer/shallow. ' + 'Update references to remove this warning.') : void 0;
        hasWarnedAboutCreateRenderer = true;
        return new ReactShallowRenderer();
    }
    function findAllInRenderedTreeInternal(inst, test) {
        if (!inst || !inst.getPublicInstance) {
            return [];
        }
        var publicInst = inst.getPublicInstance();
        var ret = test(publicInst) ? [publicInst] : [];
        var currentElement = inst._currentElement;
        if (ReactTestUtils.isDOMComponent(publicInst)) {
            var renderedChildren = inst._renderedChildren;
            var key;
            for (key in renderedChildren) {
                if (!renderedChildren.hasOwnProperty(key)) {
                    continue;
                }
                ret = ret.concat(findAllInRenderedTreeInternal(renderedChildren[key], test));
            }
        } else if (React.isValidElement(currentElement) && typeof currentElement.type === 'function') {
            ret = ret.concat(findAllInRenderedTreeInternal(inst._renderedComponent, test));
        }
        return ret;
    }
    var ReactTestUtils = {
        renderIntoDocument: function (element) {
            var div = document.createElement('div');
            return ReactDOM.render(element, div);
        },
        isElement: function (element) {
            return React.isValidElement(element);
        },
        isElementOfType: function (inst, convenienceConstructor) {
            return React.isValidElement(inst) && inst.type === convenienceConstructor;
        },
        isDOMComponent: function (inst) {
            return !!(inst && inst.nodeType === 1 && inst.tagName);
        },
        isDOMComponentElement: function (inst) {
            return !!(inst && React.isValidElement(inst) && !!inst.tagName);
        },
        isCompositeComponent: function (inst) {
            if (ReactTestUtils.isDOMComponent(inst)) {
                return false;
            }
            return inst != null && typeof inst.render === 'function' && typeof inst.setState === 'function';
        },
        isCompositeComponentWithType: function (inst, type) {
            if (!ReactTestUtils.isCompositeComponent(inst)) {
                return false;
            }
            var internalInstance = ReactInstanceMap.get(inst);
            var constructor = internalInstance._currentElement.type;
            return constructor === type;
        },
        isCompositeComponentElement: function (inst) {
            if (!React.isValidElement(inst)) {
                return false;
            }
            var prototype = inst.type.prototype;
            return typeof prototype.render === 'function' && typeof prototype.setState === 'function';
        },
        isCompositeComponentElementWithType: function (inst, type) {
            var internalInstance = ReactInstanceMap.get(inst);
            var constructor = internalInstance._currentElement.type;
            return !!(ReactTestUtils.isCompositeComponentElement(inst) && constructor === type);
        },
        getRenderedChildOfCompositeComponent: function (inst) {
            if (!ReactTestUtils.isCompositeComponent(inst)) {
                return null;
            }
            var internalInstance = ReactInstanceMap.get(inst);
            return internalInstance._renderedComponent.getPublicInstance();
        },
        findAllInRenderedTree: function (inst, test) {
            if (!inst) {
                return [];
            }
            !ReactTestUtils.isCompositeComponent(inst) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findAllInRenderedTree(...): instance must be a composite component') : _prodInvariant('10') : void 0;
            return findAllInRenderedTreeInternal(ReactInstanceMap.get(inst), test);
        },
        scryRenderedDOMComponentsWithClass: function (root, classNames) {
            return ReactTestUtils.findAllInRenderedTree(root, function (inst) {
                if (ReactTestUtils.isDOMComponent(inst)) {
                    var className = inst.className;
                    if (typeof className !== 'string') {
                        className = inst.getAttribute('class') || '';
                    }
                    var classList = className.split(/\s+/);
                    if (!Array.isArray(classNames)) {
                        !(classNames !== undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'TestUtils.scryRenderedDOMComponentsWithClass expects a className as a second argument.') : _prodInvariant('11') : void 0;
                        classNames = classNames.split(/\s+/);
                    }
                    return classNames.every(function (name) {
                        return classList.indexOf(name) !== -1;
                    });
                }
                return false;
            });
        },
        findRenderedDOMComponentWithClass: function (root, className) {
            var all = ReactTestUtils.scryRenderedDOMComponentsWithClass(root, className);
            if (all.length !== 1) {
                throw new Error('Did not find exactly one match (found: ' + all.length + ') ' + 'for class:' + className);
            }
            return all[0];
        },
        scryRenderedDOMComponentsWithTag: function (root, tagName) {
            return ReactTestUtils.findAllInRenderedTree(root, function (inst) {
                return ReactTestUtils.isDOMComponent(inst) && inst.tagName.toUpperCase() === tagName.toUpperCase();
            });
        },
        findRenderedDOMComponentWithTag: function (root, tagName) {
            var all = ReactTestUtils.scryRenderedDOMComponentsWithTag(root, tagName);
            if (all.length !== 1) {
                throw new Error('Did not find exactly one match (found: ' + all.length + ') ' + 'for tag:' + tagName);
            }
            return all[0];
        },
        scryRenderedComponentsWithType: function (root, componentType) {
            return ReactTestUtils.findAllInRenderedTree(root, function (inst) {
                return ReactTestUtils.isCompositeComponentWithType(inst, componentType);
            });
        },
        findRenderedComponentWithType: function (root, componentType) {
            var all = ReactTestUtils.scryRenderedComponentsWithType(root, componentType);
            if (all.length !== 1) {
                throw new Error('Did not find exactly one match (found: ' + all.length + ') ' + 'for componentType:' + componentType);
            }
            return all[0];
        },
        mockComponent: function (module, mockTagName) {
            mockTagName = mockTagName || module.mockTagName || 'div';
            module.prototype.render.mockImplementation(function () {
                return React.createElement(mockTagName, null, this.props.children);
            });
            return this;
        },
        simulateNativeEventOnNode: function (topLevelType, node, fakeNativeEvent) {
            fakeNativeEvent.target = node;
            fakeNativeEvent.simulated = true;
            ReactBrowserEventEmitter.ReactEventListener.dispatchEvent(topLevelType, fakeNativeEvent);
        },
        simulateNativeEventOnDOMComponent: function (topLevelType, comp, fakeNativeEvent) {
            ReactTestUtils.simulateNativeEventOnNode(topLevelType, findDOMNode(comp), fakeNativeEvent);
        },
        nativeTouchData: function (x, y) {
            return {
                touches: [{
                        pageX: x,
                        pageY: y
                    }]
            };
        },
        createRenderer: createRendererWithWarning,
        Simulate: null,
        SimulateNative: {}
    };
    function makeSimulator(eventType) {
        return function (domComponentOrNode, eventData) {
            var node;
            !!React.isValidElement(domComponentOrNode) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'TestUtils.Simulate expects a component instance and not a ReactElement.TestUtils.Simulate will not work if you are using shallow rendering.') : _prodInvariant('14') : void 0;
            if (ReactTestUtils.isDOMComponent(domComponentOrNode)) {
                node = findDOMNode(domComponentOrNode);
            } else if (domComponentOrNode.tagName) {
                node = domComponentOrNode;
            }
            var dispatchConfig = EventPluginRegistry.eventNameDispatchConfigs[eventType];
            var fakeNativeEvent = new Event();
            fakeNativeEvent.target = node;
            fakeNativeEvent.type = eventType.toLowerCase();
            var event = new SyntheticEvent(dispatchConfig, ReactDOMComponentTree.getInstanceFromNode(node), fakeNativeEvent, node);
            event.persist();
            _assign(event, eventData);
            if (dispatchConfig.phasedRegistrationNames) {
                EventPropagators.accumulateTwoPhaseDispatches(event);
            } else {
                EventPropagators.accumulateDirectDispatches(event);
            }
            ReactUpdates.batchedUpdates(function () {
                EventPluginHub.enqueueEvents(event);
                EventPluginHub.processEventQueue(true);
            });
        };
    }
    function buildSimulators() {
        ReactTestUtils.Simulate = {};
        var eventType;
        for (eventType in EventPluginRegistry.eventNameDispatchConfigs) {
            ReactTestUtils.Simulate[eventType] = makeSimulator(eventType);
        }
    }
    var oldInjectEventPluginOrder = EventPluginHub.injection.injectEventPluginOrder;
    EventPluginHub.injection.injectEventPluginOrder = function () {
        oldInjectEventPluginOrder.apply(this, arguments);
        buildSimulators();
    };
    var oldInjectEventPlugins = EventPluginHub.injection.injectEventPluginsByName;
    EventPluginHub.injection.injectEventPluginsByName = function () {
        oldInjectEventPlugins.apply(this, arguments);
        buildSimulators();
    };
    buildSimulators();
    function makeNativeSimulator(eventType) {
        return function (domComponentOrNode, nativeEventData) {
            var fakeNativeEvent = new Event(eventType);
            _assign(fakeNativeEvent, nativeEventData);
            if (ReactTestUtils.isDOMComponent(domComponentOrNode)) {
                ReactTestUtils.simulateNativeEventOnDOMComponent(eventType, domComponentOrNode, fakeNativeEvent);
            } else if (domComponentOrNode.tagName) {
                ReactTestUtils.simulateNativeEventOnNode(eventType, domComponentOrNode, fakeNativeEvent);
            }
        };
    }
    Object.keys(topLevelTypes).forEach(function (eventType) {
        var convenienceName = eventType.indexOf('top') === 0 ? eventType.charAt(3).toLowerCase() + eventType.substr(4) : eventType;
        ReactTestUtils.SimulateNative[convenienceName] = makeNativeSimulator(eventType);
    });
    module.exports = ReactTestUtils;
});
/*react-dom@15.6.1#test-utils*/
define('react-dom@15.6.1#test-utils', function (require, exports, module) {
    'use strict';
    module.exports = require('./lib/ReactTestUtils');
});
/*react-view-model@0.5.6#observer*/
define('react-view-model@0.5.6#observer', function (require, exports, module) {
    var Observation = require('can-observation');
    var assign = require('can-util/js/assign/assign');
    function Observer() {
        var self = this;
        Observation.call(self, null, null, function () {
            return self.listener && self.listener();
        });
    }
    Observer.prototype = Object.create(Observation.prototype);
    Observer.prototype.constructor = Observer;
    assign(Observer.prototype, {
        start: function () {
            this.value = {};
        },
        startLisening: function (listener) {
            this.listener = listener || this.listener;
            this.bound = true;
            this.oldObserved = this.newObserved || {};
            this.ignore = 0;
            this.newObserved = {};
            Observation.observationStack.push(this);
        },
        stopListening: function () {
            if (Observation.observationStack[Observation.observationStack.length - 1] !== this) {
                var index = Observation.observationStack.indexOf(this);
                if (index === -1) {
                    throw new Error('Async observations stopped out of order.');
                }
                Observation.observationStack.splice(index, 1);
                Observation.observationStack.push(this);
            }
            Observation.observationStack.pop();
            this.updateBindings();
        }
    });
    module.exports = Observer;
});
/*react-view-model@0.5.6#make-enumerable*/
define('react-view-model@0.5.6#make-enumerable', function (require, exports, module) {
    var each = require('can-util/js/each/each');
    module.exports = function makeEnumerable(Type, recursive) {
        if (recursive === undefined) {
            recursive = true;
        }
        var setup = Type.prototype.setup;
        Type.prototype.setup = function () {
            var map = this;
            each(this._define.definitions, function (value, prop) {
                var parent = Object.getOwnPropertyDescriptor(map.constructor.prototype, prop);
                Object.defineProperty(map, prop, {
                    enumerable: true,
                    get: parent.get,
                    set: parent.set
                });
                if (recursive && value.Type && !isEnumerable(value.Type)) {
                    makeEnumerable(value.Type, recursive);
                }
            });
            return setup.apply(this, arguments);
        };
        Type.__isEnumerable = true;
    };
    function isEnumerable(Type) {
        return !!Type.__isEnumerable;
    }
    module.exports.isEnumerable = isEnumerable;
});
/*react-view-model@0.5.6#component*/
define('react-view-model@0.5.6#component', function (require, exports, module) {
    var React = require('react');
    var DefineMap = require('can-define/map/map');
    var assign = require('can-util/js/assign/assign');
    var Observer = require('./observer');
    var makeEnumerable = require('./make-enumerable');
    var dev = require('can-util/js/dev/dev');
    var namespace = require('can-namespace');
    if (React) {
        var Component = function Component() {
            React.Component.call(this);
            if (this.constructor.ViewModel && !makeEnumerable.isEnumerable(this.constructor.ViewModel)) {
                makeEnumerable(this.constructor.ViewModel, true);
            }
            this._observer = new Observer();
            if (typeof this.shouldComponentUpdate === 'function') {
                this._shouldComponentUpdate = this.shouldComponentUpdate;
            }
            this.shouldComponentUpdate = function () {
                return false;
            };
        };
        Component.prototype = Object.create(React.Component.prototype);
        assign(Component.prototype, {
            constructor: Component,
            componentWillReceiveProps: function (nextProps) {
                var props = {};
                for (var key in nextProps) {
                    if (!(key in this.props) || nextProps[key] !== this.props[key]) {
                        props[key] = nextProps[key];
                    }
                }
                this.viewModel.set(props);
            },
            componentWillMount: function () {
                var ViewModel = this.constructor.ViewModel || DefineMap;
                this.viewModel = new ViewModel(this.props);
                this._observer.startLisening(function () {
                    if (typeof this._shouldComponentUpdate !== 'function' || this._shouldComponentUpdate()) {
                        this.forceUpdate();
                    }
                }.bind(this));
            },
            componentDidMount: function () {
                this._observer.stopListening();
            },
            componentWillUpdate: function () {
                this._observer.startLisening();
            },
            componentDidUpdate: function () {
                this._observer.stopListening();
            },
            componentWillUnmount: function () {
                this._observer.stop();
                this.viewModel = null;
            }
        });
        module.exports = namespace.ReactViewModelComponent = Component;
    } else {
        module.exports = namespace.ReactViewModelComponent = function Component() {
            throw new Error('You must provide React before can.all.js');
        };
    }
});
/*react-view-model@0.5.6#react-view-model*/
define('react-view-model@0.5.6#react-view-model', function (require, exports, module) {
    var assign = require('can-util/js/assign/assign');
    var Component = require('./component');
    var namespace = require('can-namespace');
    module.exports = namespace.reactViewModel = function reactViewModel(displayName, ViewModel, render) {
        if (arguments.length === 1) {
            render = arguments[0];
            ViewModel = null;
            displayName = null;
        }
        if (arguments.length === 2) {
            render = arguments[1];
            if (typeof arguments[0] === 'string') {
                displayName = arguments[0];
                ViewModel = null;
            } else {
                ViewModel = arguments[0];
                displayName = null;
            }
        }
        if (!displayName) {
            displayName = (render.displayName || render.name || 'ReactVMComponent') + 'Wrapper';
        }
        function App() {
            Component.call(this);
        }
        App.ViewModel = ViewModel;
        App.displayName = displayName;
        App.prototype = Object.create(Component.prototype);
        assign(App.prototype, {
            constructor: App,
            render: function () {
                return render(this.viewModel);
            }
        });
        try {
            Object.defineProperty(App, 'name', {
                writable: false,
                enumerable: false,
                configurable: true,
                value: displayName
            });
        } catch (e) {
        }
        return App;
    };
});
/*react-view-model@0.5.6#test/test*/
define('react-view-model@0.5.6#test/test', [
    'steal-qunit',
    'react',
    'prop-types',
    'react-dom/test-utils',
    'can-define/map/map',
    'react-view-model',
    'react-view-model/component'
], function (_stealQunit, _react, _propTypes, _testUtils, _map, _reactViewModel, _component) {
    'use strict';
    var _stealQunit2 = _interopRequireDefault(_stealQunit);
    var _react2 = _interopRequireDefault(_react);
    var _propTypes2 = _interopRequireDefault(_propTypes);
    var _testUtils2 = _interopRequireDefault(_testUtils);
    var _map2 = _interopRequireDefault(_map);
    var _reactViewModel2 = _interopRequireDefault(_reactViewModel);
    var _component2 = _interopRequireDefault(_component);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError('Cannot call a class as a function');
        }
    }
    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor)
                    descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function (Constructor, protoProps, staticProps) {
            if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
                defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called');
        }
        return call && (typeof call === 'object' || typeof call === 'function') ? call : self;
    }
    function _inherits(subClass, superClass) {
        if (typeof superClass !== 'function' && superClass !== null) {
            throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass)
            Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var ReactComponent = _react2.default.Component;
    function getTextFromElement(node) {
        var txt = '';
        node = node.firstChild;
        while (node) {
            if (node.nodeType === 3) {
                txt += node.nodeValue;
            } else {
                txt += getTextFromElement(node);
            }
            node = node.nextSibling;
        }
        return txt;
    }
    var supportsFunctionName = function () {
        function foo() {
        }
        return foo.name === 'foo';
    }();
    _stealQunit2.default.module('react-view-model', function () {
        _stealQunit2.default.module('when extending Component', function () {
            var DefinedViewModel = _map2.default.extend('ViewModel', {
                foo: {
                    type: 'string',
                    value: 'foo'
                },
                bar: 'string',
                foobar: {
                    get: function get() {
                        return this.foo + this.bar;
                    }
                },
                zzz: {
                    set: function set(newVal) {
                        return newVal.toUpperCase();
                    }
                },
                interceptedCallbackCalled: 'boolean',
                interceptedCallback: {
                    type: 'function',
                    get: function get(lastSetValue) {
                        var _this = this;
                        return function () {
                            _this.interceptedCallbackCalled = true;
                            if (lastSetValue) {
                                return lastSetValue.apply(undefined, arguments);
                            }
                        };
                    }
                }
            });
            _stealQunit2.default.test('should work without a ViewModel', function (assert) {
                var TestComponent = function (_Component) {
                    _inherits(TestComponent, _Component);
                    function TestComponent() {
                        _classCallCheck(this, TestComponent);
                        return _possibleConstructorReturn(this, (TestComponent.__proto__ || Object.getPrototypeOf(TestComponent)).apply(this, arguments));
                    }
                    _createClass(TestComponent, [{
                            key: 'render',
                            value: function render() {
                                return _react2.default.createElement('div', null, this.viewModel.foobar);
                            }
                        }]);
                    return TestComponent;
                }(_component2.default);
                var testInstance = _testUtils2.default.renderIntoDocument(_react2.default.createElement(TestComponent, { foobar: 'foobar' }));
                var divComponent = _testUtils2.default.findRenderedDOMComponentWithTag(testInstance, 'div');
                assert.equal(divComponent.innerText, 'foobar');
            });
            _stealQunit2.default.test('should set viewModel to be instance of ViewModel', function (assert) {
                var TestComponent = function (_Component2) {
                    _inherits(TestComponent, _Component2);
                    function TestComponent() {
                        _classCallCheck(this, TestComponent);
                        return _possibleConstructorReturn(this, (TestComponent.__proto__ || Object.getPrototypeOf(TestComponent)).apply(this, arguments));
                    }
                    _createClass(TestComponent, [{
                            key: 'render',
                            value: function render() {
                                return _react2.default.createElement('div', null, this.viewModel.foobar);
                            }
                        }]);
                    return TestComponent;
                }(_component2.default);
                TestComponent.ViewModel = DefinedViewModel;
                var testInstance = _testUtils2.default.renderIntoDocument(_react2.default.createElement(TestComponent, null));
                assert.ok(testInstance.viewModel instanceof DefinedViewModel);
            });
            _stealQunit2.default.test('should update whenever any observable property on the viewModel instance changes', function (assert) {
                var TestComponent = function (_Component3) {
                    _inherits(TestComponent, _Component3);
                    function TestComponent() {
                        _classCallCheck(this, TestComponent);
                        return _possibleConstructorReturn(this, (TestComponent.__proto__ || Object.getPrototypeOf(TestComponent)).apply(this, arguments));
                    }
                    _createClass(TestComponent, [{
                            key: 'render',
                            value: function render() {
                                return _react2.default.createElement('div', null, this.viewModel.foobar);
                            }
                        }]);
                    return TestComponent;
                }(_component2.default);
                TestComponent.ViewModel = DefinedViewModel;
                var testInstance = _testUtils2.default.renderIntoDocument(_react2.default.createElement(TestComponent, {
                    bar: 'bar',
                    baz: 'bam'
                }));
                var divComponent = _testUtils2.default.findRenderedDOMComponentWithTag(testInstance, 'div');
                assert.equal(divComponent.innerText, 'foobar');
                testInstance.viewModel.foo = 'MMM';
                assert.equal(divComponent.innerText, 'MMMbar');
            });
            _stealQunit2.default.test('should update whenever any observable property on the viewModel instance changes (nested)', function (assert) {
                var InnerComponent = function (_ReactComponent) {
                    _inherits(InnerComponent, _ReactComponent);
                    function InnerComponent() {
                        _classCallCheck(this, InnerComponent);
                        return _possibleConstructorReturn(this, (InnerComponent.__proto__ || Object.getPrototypeOf(InnerComponent)).apply(this, arguments));
                    }
                    _createClass(InnerComponent, [{
                            key: 'render',
                            value: function render() {
                                return _react2.default.createElement('div', null, this.props.bar.bam.quux);
                            }
                        }]);
                    return InnerComponent;
                }(ReactComponent);
                InnerComponent.propTypes = { bar: _propTypes2.default.shape({ bam: _propTypes2.default.shape({ quux: _propTypes2.default.string.isRequired }).isRequired }).isRequired };
                var OutterComponent = function (_Component4) {
                    _inherits(OutterComponent, _Component4);
                    function OutterComponent() {
                        _classCallCheck(this, OutterComponent);
                        return _possibleConstructorReturn(this, (OutterComponent.__proto__ || Object.getPrototypeOf(OutterComponent)).apply(this, arguments));
                    }
                    _createClass(OutterComponent, [{
                            key: 'render',
                            value: function render() {
                                return _react2.default.createElement(InnerComponent, { bar: this.viewModel.foo.bar });
                            }
                        }]);
                    return OutterComponent;
                }(_component2.default);
                OutterComponent.ViewModel = _map2.default.extend('ViewModel', { foo: _map2.default.extend('Foo', { bar: _map2.default.extend('Bar', { bam: _map2.default.extend('Bam', { quux: 'string' }) }) }) });
                var testInstance = _testUtils2.default.renderIntoDocument(_react2.default.createElement(OutterComponent, { foo: { bar: { bam: { quux: 'hello' } } } }));
                var divComponent = _testUtils2.default.findRenderedDOMComponentWithTag(testInstance, 'div');
                assert.equal(divComponent.innerText, 'hello');
                testInstance.viewModel.foo.bar.bam.quux = 'world';
                assert.equal(divComponent.innerText, 'world');
            });
            _stealQunit2.default.test('should update the viewModel when new props are received', function (assert) {
                var TestComponent = function (_Component5) {
                    _inherits(TestComponent, _Component5);
                    function TestComponent() {
                        _classCallCheck(this, TestComponent);
                        return _possibleConstructorReturn(this, (TestComponent.__proto__ || Object.getPrototypeOf(TestComponent)).apply(this, arguments));
                    }
                    _createClass(TestComponent, [{
                            key: 'render',
                            value: function render() {
                                return _react2.default.createElement('div', null, this.viewModel.foo);
                            }
                        }]);
                    return TestComponent;
                }(_component2.default);
                TestComponent.ViewModel = DefinedViewModel;
                var WrappingComponent = function (_ReactComponent2) {
                    _inherits(WrappingComponent, _ReactComponent2);
                    function WrappingComponent() {
                        _classCallCheck(this, WrappingComponent);
                        var _this8 = _possibleConstructorReturn(this, (WrappingComponent.__proto__ || Object.getPrototypeOf(WrappingComponent)).call(this));
                        _this8.state = { foo: 'Initial Prop Value' };
                        return _this8;
                    }
                    _createClass(WrappingComponent, [
                        {
                            key: 'changeState',
                            value: function changeState() {
                                this.setState({ foo: 'New Prop Value' });
                            }
                        },
                        {
                            key: 'render',
                            value: function render() {
                                return _react2.default.createElement(TestComponent, { foo: this.state.foo });
                            }
                        }
                    ]);
                    return WrappingComponent;
                }(ReactComponent);
                var wrappingInstance = _testUtils2.default.renderIntoDocument(_react2.default.createElement(WrappingComponent, null));
                var testInstance = _testUtils2.default.scryRenderedComponentsWithType(wrappingInstance, TestComponent)[0];
                var divComponent = _testUtils2.default.findRenderedDOMComponentWithTag(testInstance, 'div');
                assert.equal(testInstance.props.foo, 'Initial Prop Value');
                assert.equal(divComponent.innerText, 'Initial Prop Value');
                wrappingInstance.changeState();
                assert.equal(testInstance.props.foo, 'New Prop Value');
                assert.equal(divComponent.innerText, 'New Prop Value');
            });
            _stealQunit2.default.test('should not overwrite the viewModel with unchanged values when new props are received', function (assert) {
                var TestComponent = function (_Component6) {
                    _inherits(TestComponent, _Component6);
                    function TestComponent() {
                        _classCallCheck(this, TestComponent);
                        return _possibleConstructorReturn(this, (TestComponent.__proto__ || Object.getPrototypeOf(TestComponent)).apply(this, arguments));
                    }
                    _createClass(TestComponent, [
                        {
                            key: 'changeState',
                            value: function changeState() {
                                this.viewModel.bar = 'bar1';
                            }
                        },
                        {
                            key: 'render',
                            value: function render() {
                                return _react2.default.createElement('div', null, this.viewModel.foobar);
                            }
                        }
                    ]);
                    return TestComponent;
                }(_component2.default);
                TestComponent.ViewModel = DefinedViewModel;
                var WrappingComponent = function (_ReactComponent3) {
                    _inherits(WrappingComponent, _ReactComponent3);
                    function WrappingComponent() {
                        _classCallCheck(this, WrappingComponent);
                        var _this10 = _possibleConstructorReturn(this, (WrappingComponent.__proto__ || Object.getPrototypeOf(WrappingComponent)).call(this));
                        _this10.state = { foo: 'foo' };
                        return _this10;
                    }
                    _createClass(WrappingComponent, [
                        {
                            key: 'changeState',
                            value: function changeState() {
                                this.setState({ foo: 'foo1' });
                            }
                        },
                        {
                            key: 'render',
                            value: function render() {
                                return _react2.default.createElement(TestComponent, {
                                    foo: this.state.foo,
                                    bar: 'bar'
                                });
                            }
                        }
                    ]);
                    return WrappingComponent;
                }(ReactComponent);
                var wrappingInstance = _testUtils2.default.renderIntoDocument(_react2.default.createElement(WrappingComponent, null));
                var testInstance = _testUtils2.default.scryRenderedComponentsWithType(wrappingInstance, TestComponent)[0];
                var divComponent = _testUtils2.default.findRenderedDOMComponentWithTag(testInstance, 'div');
                assert.equal(divComponent.innerText, 'foobar');
                testInstance.changeState();
                assert.equal(divComponent.innerText, 'foobar1');
                wrappingInstance.changeState();
                assert.equal(divComponent.innerText, 'foo1bar1');
            });
            _stealQunit2.default.test('should be able to have the viewModel transform props before passing to child component', function (assert) {
                var TestComponent = function (_Component7) {
                    _inherits(TestComponent, _Component7);
                    function TestComponent() {
                        _classCallCheck(this, TestComponent);
                        return _possibleConstructorReturn(this, (TestComponent.__proto__ || Object.getPrototypeOf(TestComponent)).apply(this, arguments));
                    }
                    _createClass(TestComponent, [{
                            key: 'render',
                            value: function render() {
                                return _react2.default.createElement('div', null, this.viewModel.zzz);
                            }
                        }]);
                    return TestComponent;
                }(_component2.default);
                TestComponent.ViewModel = DefinedViewModel;
                var testInstance = _testUtils2.default.renderIntoDocument(_react2.default.createElement(TestComponent, { zzz: 'zzz' }));
                var divComponent = _testUtils2.default.findRenderedDOMComponentWithTag(testInstance, 'div');
                assert.equal(testInstance.viewModel.zzz, 'ZZZ');
                assert.equal(divComponent.innerText, 'ZZZ');
            });
            _stealQunit2.default.test('should be able to call the viewModel.interceptedCallback function received from parent component', function (assert) {
                var TestComponent = function (_Component8) {
                    _inherits(TestComponent, _Component8);
                    function TestComponent() {
                        _classCallCheck(this, TestComponent);
                        return _possibleConstructorReturn(this, (TestComponent.__proto__ || Object.getPrototypeOf(TestComponent)).apply(this, arguments));
                    }
                    _createClass(TestComponent, [{
                            key: 'render',
                            value: function render() {
                                return _react2.default.createElement('div', null, this.viewModel.foobar);
                            }
                        }]);
                    return TestComponent;
                }(_component2.default);
                TestComponent.ViewModel = DefinedViewModel;
                var expectedValue = [];
                var WrappingComponent = function (_ReactComponent4) {
                    _inherits(WrappingComponent, _ReactComponent4);
                    function WrappingComponent() {
                        _classCallCheck(this, WrappingComponent);
                        return _possibleConstructorReturn(this, (WrappingComponent.__proto__ || Object.getPrototypeOf(WrappingComponent)).apply(this, arguments));
                    }
                    _createClass(WrappingComponent, [
                        {
                            key: 'parentCallBack',
                            value: function parentCallBack() {
                                return expectedValue;
                            }
                        },
                        {
                            key: 'render',
                            value: function render() {
                                return _react2.default.createElement(TestComponent, { interceptedCallback: this.parentCallBack });
                            }
                        }
                    ]);
                    return WrappingComponent;
                }(ReactComponent);
                var wrappingInstance = _testUtils2.default.renderIntoDocument(_react2.default.createElement(WrappingComponent, null));
                var testInstance = _testUtils2.default.scryRenderedComponentsWithType(wrappingInstance, TestComponent)[0];
                var actual = testInstance.viewModel.interceptedCallback();
                assert.equal(actual, expectedValue, 'Value returned from wrapping components callback successfully');
                assert.equal(testInstance.viewModel.interceptedCallbackCalled, true, 'ViewModels interceptedCallback was called');
                testInstance.viewModel.interceptedCallbackCalled = undefined;
            });
        });
        _stealQunit2.default.module('when using reactViewModel', function () {
            _stealQunit2.default.test('should work with displayName, ViewModel, and render function', function (assert) {
                var ViewModel = _map2.default.extend('ViewModel', {
                    first: {
                        type: 'string',
                        value: 'Christopher'
                    },
                    last: 'string',
                    name: {
                        get: function get() {
                            return this.first + ' ' + this.last;
                        }
                    }
                });
                var Person = (0, _reactViewModel2.default)('Person', ViewModel, function (props) {
                    return _react2.default.createElement('div', null, props.name);
                });
                var testInstance = _testUtils2.default.renderIntoDocument(_react2.default.createElement(Person, { last: 'Baker' }));
                var divComponent = _testUtils2.default.findRenderedDOMComponentWithTag(testInstance, 'div');
                assert.ok(Person.prototype instanceof _component2.default, 'returned component is an instance of Component');
                supportsFunctionName && assert.equal(Person.name, 'Person', 'returned component is properly named');
                assert.equal(getTextFromElement(divComponent), 'Christopher Baker');
                testInstance.viewModel.first = 'Yetti';
                assert.equal(getTextFromElement(divComponent), 'Yetti Baker');
            });
            _stealQunit2.default.test('should work with displayName and render function', function (assert) {
                var Person = (0, _reactViewModel2.default)('Person', function (props) {
                    return _react2.default.createElement('div', null, props.first, ' ', props.last);
                });
                var testInstance = _testUtils2.default.renderIntoDocument(_react2.default.createElement(Person, {
                    first: 'Christopher',
                    last: 'Baker'
                }));
                var divComponent = _testUtils2.default.findRenderedDOMComponentWithTag(testInstance, 'div');
                assert.ok(Person.prototype instanceof _component2.default, 'returned component is an instance of Component');
                supportsFunctionName && assert.equal(Person.name, 'Person', 'returned component is properly named');
                assert.equal(getTextFromElement(divComponent), 'Christopher Baker');
                testInstance.viewModel.first = 'Yetti';
                assert.equal(getTextFromElement(divComponent), 'Yetti Baker');
            });
            _stealQunit2.default.test('should work with ViewModel and render function', function (assert) {
                var ViewModel = _map2.default.extend('ViewModel', {
                    first: {
                        type: 'string',
                        value: 'Christopher'
                    },
                    last: 'string',
                    name: {
                        get: function get() {
                            return this.first + ' ' + this.last;
                        }
                    }
                });
                var Person = (0, _reactViewModel2.default)(ViewModel, function Person(props) {
                    return _react2.default.createElement('div', null, props.name);
                });
                var testInstance = _testUtils2.default.renderIntoDocument(_react2.default.createElement(Person, { last: 'Baker' }));
                var divComponent = _testUtils2.default.findRenderedDOMComponentWithTag(testInstance, 'div');
                assert.ok(Person.prototype instanceof _component2.default, 'returned component is an instance of Component');
                supportsFunctionName && assert.equal(Person.name, 'PersonWrapper', 'returned component is properly named');
                assert.equal(getTextFromElement(divComponent), 'Christopher Baker');
                testInstance.viewModel.first = 'Yetti';
                assert.equal(getTextFromElement(divComponent), 'Yetti Baker');
            });
            _stealQunit2.default.test('should work with render function', function (assert) {
                var Person = (0, _reactViewModel2.default)(function (props) {
                    return _react2.default.createElement('div', null, props.first, ' ', props.last);
                });
                var testInstance = _testUtils2.default.renderIntoDocument(_react2.default.createElement(Person, {
                    first: 'Christopher',
                    last: 'Baker'
                }));
                var divComponent = _testUtils2.default.findRenderedDOMComponentWithTag(testInstance, 'div');
                assert.ok(Person.prototype instanceof _component2.default, 'returned component is an instance of Component');
                supportsFunctionName && assert.equal(Person.name, 'ReactVMComponentWrapper', 'returned component is properly named');
                assert.equal(getTextFromElement(divComponent), 'Christopher Baker');
                testInstance.viewModel.first = 'Yetti';
                assert.equal(getTextFromElement(divComponent), 'Yetti Baker');
            });
        });
        _stealQunit2.default.module('when using React patterns', function () {
            _stealQunit2.default.test('should work with prop spread', function (assert) {
                var ViewModel = _map2.default.extend('ViewModel', {
                    title: {
                        type: 'string',
                        value: 'Test Page'
                    },
                    href: {
                        get: function get() {
                            return '/' + this.title.toLowerCase().replace(/[^a-z]/g, '-').replace(/--+/g, '-');
                        }
                    }
                });
                var TestComponent = function (_Component9) {
                    _inherits(TestComponent, _Component9);
                    function TestComponent() {
                        _classCallCheck(this, TestComponent);
                        return _possibleConstructorReturn(this, (TestComponent.__proto__ || Object.getPrototypeOf(TestComponent)).apply(this, arguments));
                    }
                    _createClass(TestComponent, [{
                            key: 'render',
                            value: function render() {
                                var props = { target: '_blank' };
                                return _react2.default.createElement('a', _extends({}, this.viewModel, props));
                            }
                        }]);
                    return TestComponent;
                }(_component2.default);
                TestComponent.ViewModel = ViewModel;
                var testInstance = _testUtils2.default.renderIntoDocument(_react2.default.createElement(TestComponent, null));
                var aComponent = _testUtils2.default.findRenderedDOMComponentWithTag(testInstance, 'a');
                var props = {};
                for (var index = 0; index < aComponent.attributes.length; index++) {
                    var _aComponent$attribute = aComponent.attributes[index], name = _aComponent$attribute.name, value = _aComponent$attribute.value;
                    props[name] = value;
                }
                assert.equal(props.target, '_blank');
                assert.equal(props.title, 'Test Page');
                assert.equal(props.href, '/test-page');
            });
            _stealQunit2.default.test('should work with prop spread (nested)', function (assert) {
                var ViewModel = _map2.default.extend('ViewModel', {
                    inner: _map2.default.extend('Inner', {
                        title: {
                            type: 'string',
                            value: 'Test Page'
                        },
                        href: {
                            get: function get() {
                                return '/' + this.title.toLowerCase().replace(/[^a-z]/g, '-').replace(/--+/g, '-');
                            }
                        }
                    })
                });
                var TestComponent = function (_Component10) {
                    _inherits(TestComponent, _Component10);
                    function TestComponent() {
                        _classCallCheck(this, TestComponent);
                        return _possibleConstructorReturn(this, (TestComponent.__proto__ || Object.getPrototypeOf(TestComponent)).apply(this, arguments));
                    }
                    _createClass(TestComponent, [{
                            key: 'render',
                            value: function render() {
                                var props = { target: '_blank' };
                                return _react2.default.createElement('a', _extends({}, this.viewModel.inner, props));
                            }
                        }]);
                    return TestComponent;
                }(_component2.default);
                TestComponent.ViewModel = ViewModel;
                var testInstance = _testUtils2.default.renderIntoDocument(_react2.default.createElement(TestComponent, { inner: {} }));
                var aComponent = _testUtils2.default.findRenderedDOMComponentWithTag(testInstance, 'a');
                var props = {};
                for (var index = 0; index < aComponent.attributes.length; index++) {
                    var _aComponent$attribute2 = aComponent.attributes[index], name = _aComponent$attribute2.name, value = _aComponent$attribute2.value;
                    props[name] = value;
                }
                assert.equal(props.target, '_blank');
                assert.equal(props.title, 'Test Page');
                assert.equal(props.href, '/test-page');
            });
        });
    });
});
/*can-react-component@0.1.6#can-react-component*/
define('can-react-component@0.1.6#can-react-component', function (require, exports, module) {
    var React = require('react');
    var Scope = require('can-view-scope');
    var assign = require('can-util/js/assign/assign');
    var namespace = require('can-namespace');
    module.exports = namespace.reactComponent = function canReactComponent(displayName, CanComponent) {
        if (arguments.length === 1) {
            CanComponent = arguments[0];
            displayName = (CanComponent.shortName || 'CanComponent') + 'Wrapper';
        }
        function Wrapper() {
            React.Component.call(this);
            this.canComponent = null;
            this.createComponent = this.createComponent.bind(this);
        }
        Wrapper.displayName = displayName;
        Wrapper.prototype = Object.create(React.Component.prototype);
        assign(Wrapper.prototype, {
            constructor: Wrapper,
            createComponent: function (el) {
                if (this.canComponent) {
                    this.canComponent = null;
                }
                if (el) {
                    this.canComponent = new CanComponent(el, {
                        subtemplate: null,
                        templateType: 'react',
                        parentNodeList: undefined,
                        options: Scope.refsScope().add({}),
                        scope: new Scope.Options({}),
                        setupBindings: function (el, makeViewModel, initialViewModelData) {
                            assign(initialViewModelData, this.props);
                            makeViewModel(initialViewModelData);
                        }.bind(this)
                    });
                }
            },
            componentWillUpdate: function (props) {
                this.canComponent.viewModel.set(props);
            },
            render: function () {
                return React.createElement(CanComponent.prototype.tag, { ref: this.createComponent });
            }
        });
        Object.defineProperty(Wrapper.prototype, 'viewModel', {
            enumerable: false,
            configurable: true,
            get: function () {
                return this.canComponent && this.canComponent.viewModel;
            }
        });
        try {
            Object.defineProperty(Wrapper, 'name', {
                writable: false,
                enumerable: false,
                configurable: true,
                value: displayName
            });
        } catch (e) {
        }
        return Wrapper;
    };
});
/*can-react-component@0.1.6#test/test*/
define('can-react-component@0.1.6#test/test', [
    'steal-qunit',
    'react',
    'react-dom/test-utils',
    'can-define/map/map',
    'can-component',
    'can-stache',
    'can-react-component'
], function (_stealQunit, _react, _testUtils, _map, _canComponent, _canStache, _canReactComponent) {
    'use strict';
    var _stealQunit2 = _interopRequireDefault(_stealQunit);
    var _react2 = _interopRequireDefault(_react);
    var _testUtils2 = _interopRequireDefault(_testUtils);
    var _map2 = _interopRequireDefault(_map);
    var _canComponent2 = _interopRequireDefault(_canComponent);
    var _canStache2 = _interopRequireDefault(_canStache);
    var _canReactComponent2 = _interopRequireDefault(_canReactComponent);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError('Cannot call a class as a function');
        }
    }
    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor)
                    descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function (Constructor, protoProps, staticProps) {
            if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
                defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called');
        }
        return call && (typeof call === 'object' || typeof call === 'function') ? call : self;
    }
    function _inherits(subClass, superClass) {
        if (typeof superClass !== 'function' && superClass !== null) {
            throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass)
            Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var Component = _react2.default.Component;
    function getTextFromFrag(node) {
        var txt = '';
        node = node.firstChild;
        while (node) {
            if (node.nodeType === 3) {
                txt += node.nodeValue;
            } else {
                txt += getTextFromFrag(node);
            }
            node = node.nextSibling;
        }
        return txt;
    }
    _stealQunit2.default.module('can-react-component', function () {
        _stealQunit2.default.test('should be able to consume components', function (assert) {
            var ViewModel = _map2.default.extend('ViewModel', {
                first: {
                    type: 'string',
                    value: 'Christopher'
                },
                last: 'string',
                name: {
                    get: function get() {
                        return this.first + ' ' + this.last;
                    }
                }
            });
            var ConsumedComponent = (0, _canReactComponent2.default)('ConsumedComponent', _canComponent2.default.extend('ConsumedComponent', {
                tag: 'consumed-component1',
                ViewModel: ViewModel,
                view: (0, _canStache2.default)('<div class=\'inner\'>{{name}}</div>')
            }));
            var testInstance = _testUtils2.default.renderIntoDocument(_react2.default.createElement(ConsumedComponent, { last: 'Baker' }));
            var divComponent = _testUtils2.default.findRenderedDOMComponentWithTag(testInstance, 'consumed-component1');
            assert.equal(testInstance.constructor.name, 'ConsumedComponent');
            assert.equal(getTextFromFrag(divComponent), 'Christopher Baker');
            testInstance.viewModel.first = 'Yetti';
            assert.equal(getTextFromFrag(divComponent), 'Yetti Baker');
        });
        _stealQunit2.default.test('should work without a displayName', function (assert) {
            var ViewModel = _map2.default.extend('ViewModel', {
                first: {
                    type: 'string',
                    value: 'Christopher'
                },
                last: 'string',
                name: {
                    get: function get() {
                        return this.first + ' ' + this.last;
                    }
                }
            });
            var ConsumedComponent = (0, _canReactComponent2.default)(_canComponent2.default.extend('ConsumedComponent', {
                tag: 'consumed-component2',
                ViewModel: ViewModel,
                view: (0, _canStache2.default)('<div class=\'inner\'>{{name}}</div>')
            }));
            var testInstance = _testUtils2.default.renderIntoDocument(_react2.default.createElement(ConsumedComponent, { last: 'Baker' }));
            var divComponent = _testUtils2.default.findRenderedDOMComponentWithTag(testInstance, 'consumed-component2');
            assert.equal(testInstance.constructor.name, 'ConsumedComponentWrapper');
            assert.equal(getTextFromFrag(divComponent), 'Christopher Baker');
        });
        _stealQunit2.default.test('should update the component when new props are received', function (assert) {
            var ViewModel = _map2.default.extend('ViewModel', {
                first: {
                    type: 'string',
                    value: 'Christopher'
                },
                last: 'string',
                name: {
                    get: function get() {
                        return this.first + ' ' + this.last;
                    }
                }
            });
            var ConsumedComponent = (0, _canReactComponent2.default)(_canComponent2.default.extend('ConsumedComponent', {
                tag: 'consumed-component3',
                ViewModel: ViewModel,
                view: (0, _canStache2.default)('<div class=\'inner\'>{{name}}</div>')
            }));
            var WrappingComponent = function (_Component) {
                _inherits(WrappingComponent, _Component);
                function WrappingComponent() {
                    _classCallCheck(this, WrappingComponent);
                    var _this = _possibleConstructorReturn(this, (WrappingComponent.__proto__ || Object.getPrototypeOf(WrappingComponent)).call(this));
                    _this.state = {
                        first: 'Christopher',
                        last: 'Baker'
                    };
                    return _this;
                }
                _createClass(WrappingComponent, [
                    {
                        key: 'changeState',
                        value: function changeState() {
                            this.setState({ first: 'Yetti' });
                        }
                    },
                    {
                        key: 'render',
                        value: function render() {
                            return _react2.default.createElement(ConsumedComponent, {
                                first: this.state.first,
                                last: this.state.last
                            });
                        }
                    }
                ]);
                return WrappingComponent;
            }(Component);
            var wrappingInstance = _testUtils2.default.renderIntoDocument(_react2.default.createElement(WrappingComponent, null));
            var divComponent = _testUtils2.default.findRenderedDOMComponentWithTag(wrappingInstance, 'consumed-component3');
            assert.equal(getTextFromFrag(divComponent), 'Christopher Baker');
            wrappingInstance.changeState();
            assert.equal(getTextFromFrag(divComponent), 'Yetti Baker');
        });
    });
});
/*syn@0.10.0#synthetic*/
define('syn@0.10.0#synthetic', function (require, exports, module) {
    var opts = window.syn ? window.syn : {};
    var extend = function (d, s) {
            var p;
            for (p in s) {
                d[p] = s[p];
            }
            return d;
        }, browser = {
            msie: !!(window.attachEvent && !window.opera) || navigator.userAgent.indexOf('Trident/') > -1,
            opera: !!window.opera,
            webkit: navigator.userAgent.indexOf('AppleWebKit/') > -1,
            safari: navigator.userAgent.indexOf('AppleWebKit/') > -1 && navigator.userAgent.indexOf('Chrome/') === -1,
            gecko: navigator.userAgent.indexOf('Gecko') > -1,
            mobilesafari: !!navigator.userAgent.match(/Apple.*Mobile.*Safari/),
            rhino: navigator.userAgent.match(/Rhino/) && true
        }, createEventObject = function (type, options, element) {
            var event = element.ownerDocument.createEventObject();
            return extend(event, options);
        }, data = {}, id = 1, expando = '_synthetic' + new Date().getTime(), bind, unbind, schedule, key = /keypress|keyup|keydown/, page = /load|unload|abort|error|select|change|submit|reset|focus|blur|resize|scroll/, activeElement, syn = function (type, element, options, callback) {
            return new syn.init(type, element, options, callback);
        };
    syn.config = opts;
    syn.__tryFocus = function tryFocus(element) {
        try {
            element.focus();
        } catch (e) {
        }
    };
    bind = function (el, ev, f) {
        return el.addEventListener ? el.addEventListener(ev, f, false) : el.attachEvent('on' + ev, f);
    };
    unbind = function (el, ev, f) {
        return el.addEventListener ? el.removeEventListener(ev, f, false) : el.detachEvent('on' + ev, f);
    };
    schedule = syn.config.schedule || function (fn, ms) {
        setTimeout(fn, ms);
    };
    extend(syn, {
        init: function (type, element, options, callback) {
            var args = syn.args(options, element, callback), self = this;
            this.queue = [];
            this.element = args.element;
            if (typeof this[type] === 'function') {
                this[type](args.element, args.options, function (defaults, el) {
                    if (args.callback) {
                        args.callback.apply(self, arguments);
                    }
                    self.done.apply(self, arguments);
                });
            } else {
                this.result = syn.trigger(args.element, type, args.options);
                if (args.callback) {
                    args.callback.call(this, args.element, this.result);
                }
            }
        },
        jquery: function (el, fast) {
            if (window.FuncUnit && window.FuncUnit.jQuery) {
                return window.FuncUnit.jQuery;
            }
            if (el) {
                return syn.helpers.getWindow(el).jQuery || window.jQuery;
            } else {
                return window.jQuery;
            }
        },
        args: function () {
            var res = {}, i = 0;
            for (; i < arguments.length; i++) {
                if (typeof arguments[i] === 'function') {
                    res.callback = arguments[i];
                } else if (arguments[i] && arguments[i].jquery) {
                    res.element = arguments[i][0];
                } else if (arguments[i] && arguments[i].nodeName) {
                    res.element = arguments[i];
                } else if (res.options && typeof arguments[i] === 'string') {
                    res.element = document.getElementById(arguments[i]);
                } else if (arguments[i]) {
                    res.options = arguments[i];
                }
            }
            return res;
        },
        click: function (element, options, callback) {
            syn('click!', element, options, callback);
        },
        defaults: {
            focus: function focus() {
                if (!syn.support.focusChanges) {
                    var element = this, nodeName = element.nodeName.toLowerCase();
                    syn.data(element, 'syntheticvalue', element.value);
                    if (nodeName === 'input' || nodeName === 'textarea') {
                        bind(element, 'blur', function blur() {
                            if (syn.data(element, 'syntheticvalue') !== element.value) {
                                syn.trigger(element, 'change', {});
                            }
                            unbind(element, 'blur', blur);
                        });
                    }
                }
            },
            submit: function () {
                syn.onParents(this, function (el) {
                    if (el.nodeName.toLowerCase() === 'form') {
                        el.submit();
                        return false;
                    }
                });
            }
        },
        changeOnBlur: function (element, prop, value) {
            bind(element, 'blur', function onblur() {
                if (value !== element[prop]) {
                    syn.trigger(element, 'change', {});
                }
                unbind(element, 'blur', onblur);
            });
        },
        closest: function (el, type) {
            while (el && el.nodeName.toLowerCase() !== type.toLowerCase()) {
                el = el.parentNode;
            }
            return el;
        },
        data: function (el, key, value) {
            var d;
            if (!el[expando]) {
                el[expando] = id++;
            }
            if (!data[el[expando]]) {
                data[el[expando]] = {};
            }
            d = data[el[expando]];
            if (value) {
                data[el[expando]][key] = value;
            } else {
                return data[el[expando]][key];
            }
        },
        onParents: function (el, func) {
            var res;
            while (el && res !== false) {
                res = func(el);
                el = el.parentNode;
            }
            return el;
        },
        focusable: /^(a|area|frame|iframe|label|input|select|textarea|button|html|object)$/i,
        isFocusable: function (elem) {
            var attributeNode;
            if (elem.getAttributeNode) {
                attributeNode = elem.getAttributeNode('tabIndex');
            }
            return this.focusable.test(elem.nodeName) || attributeNode && attributeNode.specified && syn.isVisible(elem);
        },
        isVisible: function (elem) {
            return elem.offsetWidth && elem.offsetHeight || elem.clientWidth && elem.clientHeight;
        },
        tabIndex: function (elem) {
            var attributeNode = elem.getAttributeNode('tabIndex');
            return attributeNode && attributeNode.specified && (parseInt(elem.getAttribute('tabIndex')) || 0);
        },
        bind: bind,
        unbind: unbind,
        schedule: schedule,
        browser: browser,
        helpers: {
            createEventObject: createEventObject,
            createBasicStandardEvent: function (type, defaults, doc) {
                var event;
                try {
                    event = doc.createEvent('Events');
                } catch (e2) {
                    event = doc.createEvent('UIEvents');
                } finally {
                    event.initEvent(type, true, true);
                    extend(event, defaults);
                }
                return event;
            },
            inArray: function (item, array) {
                var i = 0;
                for (; i < array.length; i++) {
                    if (array[i] === item) {
                        return i;
                    }
                }
                return -1;
            },
            getWindow: function (element) {
                if (element.ownerDocument) {
                    return element.ownerDocument.defaultView || element.ownerDocument.parentWindow;
                }
            },
            extend: extend,
            scrollOffset: function (win, set) {
                var doc = win.document.documentElement, body = win.document.body;
                if (set) {
                    window.scrollTo(set.left, set.top);
                } else {
                    return {
                        left: (doc && doc.scrollLeft || body && body.scrollLeft || 0) + (doc.clientLeft || 0),
                        top: (doc && doc.scrollTop || body && body.scrollTop || 0) + (doc.clientTop || 0)
                    };
                }
            },
            scrollDimensions: function (win) {
                var doc = win.document.documentElement, body = win.document.body, docWidth = doc.clientWidth, docHeight = doc.clientHeight, compat = win.document.compatMode === 'CSS1Compat';
                return {
                    height: compat && docHeight || body.clientHeight || docHeight,
                    width: compat && docWidth || body.clientWidth || docWidth
                };
            },
            addOffset: function (options, el) {
                var jq = syn.jquery(el), off;
                if (typeof options === 'object' && options.clientX === undefined && options.clientY === undefined && options.pageX === undefined && options.pageY === undefined && jq) {
                    el = jq(el);
                    off = el.offset();
                    options.pageX = off.left + el.width() / 2;
                    options.pageY = off.top + el.height() / 2;
                }
            }
        },
        key: {
            ctrlKey: null,
            altKey: null,
            shiftKey: null,
            metaKey: null
        },
        dispatch: function (event, element, type, autoPrevent) {
            if (element.dispatchEvent && event) {
                var preventDefault = event.preventDefault, prevents = autoPrevent ? -1 : 0;
                if (autoPrevent) {
                    bind(element, type, function ontype(ev) {
                        ev.preventDefault();
                        unbind(this, type, ontype);
                    });
                }
                event.preventDefault = function () {
                    prevents++;
                    if (++prevents > 0) {
                        preventDefault.apply(this, []);
                    }
                };
                element.dispatchEvent(event);
                return prevents <= 0;
            } else {
                try {
                    window.event = event;
                } catch (e) {
                }
                return element.sourceIndex <= 0 || element.fireEvent && element.fireEvent('on' + type, event);
            }
        },
        create: {
            page: {
                event: function (type, options, element) {
                    var doc = syn.helpers.getWindow(element).document || document, event;
                    if (doc.createEvent) {
                        event = doc.createEvent('Events');
                        event.initEvent(type, true, true);
                        return event;
                    } else {
                        try {
                            event = createEventObject(type, options, element);
                        } catch (e) {
                        }
                        return event;
                    }
                }
            },
            focus: {
                event: function (type, options, element) {
                    syn.onParents(element, function (el) {
                        if (syn.isFocusable(el)) {
                            if (el.nodeName.toLowerCase() !== 'html') {
                                syn.__tryFocus(el);
                                activeElement = el;
                            } else if (activeElement) {
                                var doc = syn.helpers.getWindow(element).document;
                                if (doc !== window.document) {
                                    return false;
                                } else if (doc.activeElement) {
                                    doc.activeElement.blur();
                                    activeElement = null;
                                } else {
                                    activeElement.blur();
                                    activeElement = null;
                                }
                            }
                            return false;
                        }
                    });
                    return true;
                }
            }
        },
        support: {
            clickChanges: false,
            clickSubmits: false,
            keypressSubmits: false,
            mouseupSubmits: false,
            radioClickChanges: false,
            focusChanges: false,
            linkHrefJS: false,
            keyCharacters: false,
            backspaceWorks: false,
            mouseDownUpClicks: false,
            tabKeyTabs: false,
            keypressOnAnchorClicks: false,
            optionClickBubbles: false,
            pointerEvents: false,
            touchEvents: false,
            ready: 0
        },
        trigger: function (element, type, options) {
            if (!options) {
                options = {};
            }
            var create = syn.create, setup = create[type] && create[type].setup, kind = key.test(type) ? 'key' : page.test(type) ? 'page' : 'mouse', createType = create[type] || {}, createKind = create[kind], event, ret, autoPrevent, dispatchEl = element;
            if (syn.support.ready === 2 && setup) {
                setup(type, options, element);
            }
            autoPrevent = options._autoPrevent;
            delete options._autoPrevent;
            if (createType.event) {
                ret = createType.event(type, options, element);
            } else {
                options = createKind.options ? createKind.options(type, options, element) : options;
                if (!syn.support.changeBubbles && /option/i.test(element.nodeName)) {
                    dispatchEl = element.parentNode;
                }
                event = createKind.event(type, options, dispatchEl);
                ret = syn.dispatch(event, dispatchEl, type, autoPrevent);
            }
            if (ret && syn.support.ready === 2 && syn.defaults[type]) {
                syn.defaults[type].call(element, options, autoPrevent);
            }
            return ret;
        },
        eventSupported: function (eventName) {
            var el = document.createElement('div');
            eventName = 'on' + eventName;
            var isSupported = eventName in el;
            if (!isSupported) {
                el.setAttribute(eventName, 'return;');
                isSupported = typeof el[eventName] === 'function';
            }
            el = null;
            return isSupported;
        }
    });
    extend(syn.init.prototype, {
        then: function (type, element, options, callback) {
            if (syn.autoDelay) {
                this.delay();
            }
            var args = syn.args(options, element, callback), self = this;
            this.queue.unshift(function (el, prevented) {
                if (typeof this[type] === 'function') {
                    this.element = args.element || el;
                    this[type](this.element, args.options, function (defaults, el) {
                        if (args.callback) {
                            args.callback.apply(self, arguments);
                        }
                        self.done.apply(self, arguments);
                    });
                } else {
                    this.result = syn.trigger(args.element, type, args.options);
                    if (args.callback) {
                        args.callback.call(this, args.element, this.result);
                    }
                    return this;
                }
            });
            return this;
        },
        delay: function (timeout, callback) {
            if (typeof timeout === 'function') {
                callback = timeout;
                timeout = null;
            }
            timeout = timeout || 600;
            var self = this;
            this.queue.unshift(function () {
                schedule(function () {
                    if (callback) {
                        callback.apply(self, []);
                    }
                    self.done.apply(self, arguments);
                }, timeout);
            });
            return this;
        },
        done: function (defaults, el) {
            if (el) {
                this.element = el;
            }
            if (this.queue.length) {
                this.queue.pop().call(this, this.element, defaults);
            }
        },
        '_click': function (element, options, callback, force) {
            syn.helpers.addOffset(options, element);
            if (syn.support.pointerEvents) {
                syn.trigger(element, 'pointerdown', options);
            }
            if (syn.support.touchEvents) {
                syn.trigger(element, 'touchstart', options);
            }
            syn.trigger(element, 'mousedown', options);
            schedule(function () {
                if (syn.support.pointerEvents) {
                    syn.trigger(element, 'pointerup', options);
                }
                if (syn.support.touchEvents) {
                    syn.trigger(element, 'touchend', options);
                }
                syn.trigger(element, 'mouseup', options);
                if (!syn.support.mouseDownUpClicks || force) {
                    syn.trigger(element, 'click', options);
                    callback(true);
                } else {
                    syn.create.click.setup('click', options, element);
                    syn.defaults.click.call(element);
                    schedule(function () {
                        callback(true);
                    }, 1);
                }
            }, 1);
        },
        '_rightClick': function (element, options, callback) {
            syn.helpers.addOffset(options, element);
            var mouseopts = extend(extend({}, syn.mouse.browser.right.mouseup), options);
            if (syn.support.pointerEvents) {
                syn.trigger(element, 'pointerdown', mouseopts);
            }
            syn.trigger(element, 'mousedown', mouseopts);
            schedule(function () {
                if (syn.support.pointerEvents) {
                    syn.trigger(element, 'pointerup', mouseopts);
                }
                syn.trigger(element, 'mouseup', mouseopts);
                if (syn.mouse.browser.right.contextmenu) {
                    syn.trigger(element, 'contextmenu', extend(extend({}, syn.mouse.browser.right.contextmenu), options));
                }
                callback(true);
            }, 1);
        },
        '_dblclick': function (element, options, callback) {
            syn.helpers.addOffset(options, element);
            var self = this;
            this._click(element, options, function () {
                schedule(function () {
                    self._click(element, options, function () {
                        syn.trigger(element, 'dblclick', options);
                        callback(true);
                    }, true);
                }, 2);
            });
        }
    });
    var actions = [
            'click',
            'dblclick',
            'move',
            'drag',
            'key',
            'type',
            'rightClick'
        ], makeAction = function (name) {
            syn[name] = function (element, options, callback) {
                return syn('_' + name, element, options, callback);
            };
            syn.init.prototype[name] = function (element, options, callback) {
                return this.then('_' + name, element, options, callback);
            };
        }, i = 0;
    for (; i < actions.length; i++) {
        makeAction(actions[i]);
    }
    module.exports = syn;
});
/*syn@0.10.0#mouse*/
define('syn@0.10.0#mouse', function (require, exports, module) {
    var syn = require('./synthetic');
    var h = syn.helpers, getWin = h.getWindow;
    syn.mouse = {};
    h.extend(syn.defaults, {
        mousedown: function (options) {
            syn.trigger(this, 'focus', {});
        },
        click: function () {
            var element = this, href, type, createChange, radioChanged, nodeName, scope;
            try {
                href = element.href;
                type = element.type;
                createChange = syn.data(element, 'createChange');
                radioChanged = syn.data(element, 'radioChanged');
                scope = getWin(element);
                nodeName = element.nodeName.toLowerCase();
            } catch (e) {
                return;
            }
            if (!syn.support.linkHrefJS && /^\s*javascript:/.test(href)) {
                var code = href.replace(/^\s*javascript:/, '');
                if (code !== '//' && code.indexOf('void(0)') === -1) {
                    if (window.selenium) {
                        eval('with(selenium.browserbot.getCurrentWindow()){' + code + '}');
                    } else {
                        eval('with(scope){' + code + '}');
                    }
                }
            }
            if (!syn.support.clickSubmits && ((nodeName === 'input' || nodeName === 'button') && type === 'submit')) {
                var form = syn.closest(element, 'form');
                if (form) {
                    syn.trigger(form, 'submit', {});
                }
            }
            if (nodeName === 'a' && element.href && !/^\s*javascript:/.test(href)) {
                scope.location.href = href;
            }
            if (nodeName === 'input' && type === 'checkbox') {
                if (!syn.support.clickChanges) {
                    syn.trigger(element, 'change', {});
                }
            }
            if (nodeName === 'input' && type === 'radio') {
                if (radioChanged && !syn.support.radioClickChanges) {
                    syn.trigger(element, 'change', {});
                }
            }
            if (nodeName === 'option' && createChange) {
                syn.trigger(element.parentNode, 'change', {});
                syn.data(element, 'createChange', false);
            }
        }
    });
    h.extend(syn.create, {
        mouse: {
            options: function (type, options, element) {
                var doc = document.documentElement, body = document.body, center = [
                        options.pageX || 0,
                        options.pageY || 0
                    ], left = syn.mouse.browser && syn.mouse.browser.left[type], right = syn.mouse.browser && syn.mouse.browser.right[type];
                return h.extend({
                    bubbles: true,
                    cancelable: true,
                    view: window,
                    detail: 1,
                    screenX: 1,
                    screenY: 1,
                    clientX: options.clientX || center[0] - (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc.clientLeft || 0),
                    clientY: options.clientY || center[1] - (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc.clientTop || 0),
                    ctrlKey: !!syn.key.ctrlKey,
                    altKey: !!syn.key.altKey,
                    shiftKey: !!syn.key.shiftKey,
                    metaKey: !!syn.key.metaKey,
                    button: left && left.button !== null ? left.button : right && right.button || (type === 'contextmenu' ? 2 : 0),
                    relatedTarget: document.documentElement
                }, options);
            },
            event: function (type, defaults, element) {
                var doc = getWin(element).document || document, event;
                if (doc.createEvent) {
                    try {
                        event = doc.createEvent('MouseEvents');
                        event.initMouseEvent(type, defaults.bubbles, defaults.cancelable, defaults.view, defaults.detail, defaults.screenX, defaults.screenY, defaults.clientX, defaults.clientY, defaults.ctrlKey, defaults.altKey, defaults.shiftKey, defaults.metaKey, defaults.button, defaults.relatedTarget);
                    } catch (e) {
                        event = h.createBasicStandardEvent(type, defaults, doc);
                    }
                    event.synthetic = true;
                    return event;
                } else {
                    try {
                        event = h.createEventObject(type, defaults, element);
                    } catch (e) {
                    }
                    return event;
                }
            }
        },
        click: {
            setup: function (type, options, element) {
                var nodeName = element.nodeName.toLowerCase();
                if (!syn.support.clickChecks && !syn.support.changeChecks && nodeName === 'input') {
                    type = element.type.toLowerCase();
                    if (type === 'checkbox') {
                        element.checked = !element.checked;
                    }
                    if (type === 'radio') {
                        if (!element.checked) {
                            try {
                                syn.data(element, 'radioChanged', true);
                            } catch (e) {
                            }
                            element.checked = true;
                        }
                    }
                }
                if (nodeName === 'a' && element.href && !/^\s*javascript:/.test(element.href)) {
                    syn.data(element, 'href', element.href);
                }
                if (/option/i.test(element.nodeName)) {
                    var child = element.parentNode.firstChild, i = -1;
                    while (child) {
                        if (child.nodeType === 1) {
                            i++;
                            if (child === element) {
                                break;
                            }
                        }
                        child = child.nextSibling;
                    }
                    if (i !== element.parentNode.selectedIndex) {
                        element.parentNode.selectedIndex = i;
                        syn.data(element, 'createChange', true);
                    }
                }
            }
        },
        mousedown: {
            setup: function (type, options, element) {
                var nn = element.nodeName.toLowerCase();
                if (syn.browser.safari && (nn === 'select' || nn === 'option')) {
                    options._autoPrevent = true;
                }
            }
        }
    });
});
/*syn@0.10.0#mouse.support*/
define('syn@0.10.0#mouse.support', function (require, exports, module) {
    var syn = require('./synthetic');
    require('./mouse');
    (function checkSupport() {
        if (!document.body) {
            return syn.schedule(checkSupport, 1);
        }
        window.__synthTest = function () {
            syn.support.linkHrefJS = true;
        };
        var div = document.createElement('div'), checkbox, submit, form, select;
        div.innerHTML = '<form id=\'outer\'>' + '<input name=\'checkbox\' type=\'checkbox\'/>' + '<input name=\'radio\' type=\'radio\' />' + '<input type=\'submit\' name=\'submitter\'/>' + '<input type=\'input\' name=\'inputter\'/>' + '<input name=\'one\'>' + '<input name=\'two\'/>' + '<a href=\'javascript:__synthTest()\' id=\'synlink\'></a>' + '<select><option></option></select>' + '</form>';
        document.documentElement.appendChild(div);
        form = div.firstChild;
        checkbox = form.childNodes[0];
        submit = form.childNodes[2];
        select = form.getElementsByTagName('select')[0];
        syn.trigger(form.childNodes[6], 'click', {});
        checkbox.checked = false;
        checkbox.onchange = function () {
            syn.support.clickChanges = true;
        };
        syn.trigger(checkbox, 'click', {});
        syn.support.clickChecks = checkbox.checked;
        checkbox.checked = false;
        syn.trigger(checkbox, 'change', {});
        syn.support.changeChecks = checkbox.checked;
        form.onsubmit = function (ev) {
            if (ev.preventDefault) {
                ev.preventDefault();
            }
            syn.support.clickSubmits = true;
            return false;
        };
        syn.trigger(submit, 'click', {});
        form.childNodes[1].onchange = function () {
            syn.support.radioClickChanges = true;
        };
        syn.trigger(form.childNodes[1], 'click', {});
        syn.bind(div, 'click', function onclick() {
            syn.support.optionClickBubbles = true;
            syn.unbind(div, 'click', onclick);
        });
        syn.trigger(select.firstChild, 'click', {});
        syn.support.changeBubbles = syn.eventSupported('change');
        div.onclick = function () {
            syn.support.mouseDownUpClicks = true;
        };
        syn.trigger(div, 'mousedown', {});
        syn.trigger(div, 'mouseup', {});
        document.documentElement.removeChild(div);
        syn.support.pointerEvents = syn.eventSupported('pointerdown');
        syn.support.touchEvents = syn.eventSupported('touchstart');
        syn.support.ready++;
    }());
});
/*syn@0.10.0#browsers*/
define('syn@0.10.0#browsers', function (require, exports, module) {
    var syn = require('./synthetic');
    require('./mouse');
    syn.key.browsers = {
        webkit: {
            'prevent': {
                'keyup': [],
                'keydown': [
                    'char',
                    'keypress'
                ],
                'keypress': ['char']
            },
            'character': {
                'keydown': [
                    0,
                    'key'
                ],
                'keypress': [
                    'char',
                    'char'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'specialChars': {
                'keydown': [
                    0,
                    'char'
                ],
                'keyup': [
                    0,
                    'char'
                ]
            },
            'navigation': {
                'keydown': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'special': {
                'keydown': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'tab': {
                'keydown': [
                    0,
                    'char'
                ],
                'keyup': [
                    0,
                    'char'
                ]
            },
            'pause-break': {
                'keydown': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'caps': {
                'keydown': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'escape': {
                'keydown': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'num-lock': {
                'keydown': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'scroll-lock': {
                'keydown': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'print': {
                'keyup': [
                    0,
                    'key'
                ]
            },
            'function': {
                'keydown': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            '\r': {
                'keydown': [
                    0,
                    'key'
                ],
                'keypress': [
                    'char',
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            }
        },
        gecko: {
            'prevent': {
                'keyup': [],
                'keydown': ['char'],
                'keypress': ['char']
            },
            'character': {
                'keydown': [
                    0,
                    'key'
                ],
                'keypress': [
                    'char',
                    0
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'specialChars': {
                'keydown': [
                    0,
                    'key'
                ],
                'keypress': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'navigation': {
                'keydown': [
                    0,
                    'key'
                ],
                'keypress': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'special': {
                'keydown': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            '\t': {
                'keydown': [
                    0,
                    'key'
                ],
                'keypress': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'pause-break': {
                'keydown': [
                    0,
                    'key'
                ],
                'keypress': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'caps': {
                'keydown': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'escape': {
                'keydown': [
                    0,
                    'key'
                ],
                'keypress': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'num-lock': {
                'keydown': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'scroll-lock': {
                'keydown': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'print': {
                'keyup': [
                    0,
                    'key'
                ]
            },
            'function': {
                'keydown': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            '\r': {
                'keydown': [
                    0,
                    'key'
                ],
                'keypress': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            }
        },
        msie: {
            'prevent': {
                'keyup': [],
                'keydown': [
                    'char',
                    'keypress'
                ],
                'keypress': ['char']
            },
            'character': {
                'keydown': [
                    null,
                    'key'
                ],
                'keypress': [
                    null,
                    'char'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            'specialChars': {
                'keydown': [
                    null,
                    'char'
                ],
                'keyup': [
                    null,
                    'char'
                ]
            },
            'navigation': {
                'keydown': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            'special': {
                'keydown': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            'tab': {
                'keydown': [
                    null,
                    'char'
                ],
                'keyup': [
                    null,
                    'char'
                ]
            },
            'pause-break': {
                'keydown': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            'caps': {
                'keydown': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            'escape': {
                'keydown': [
                    null,
                    'key'
                ],
                'keypress': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            'num-lock': {
                'keydown': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            'scroll-lock': {
                'keydown': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            'print': {
                'keyup': [
                    null,
                    'key'
                ]
            },
            'function': {
                'keydown': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            '\r': {
                'keydown': [
                    null,
                    'key'
                ],
                'keypress': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            }
        },
        opera: {
            'prevent': {
                'keyup': [],
                'keydown': [],
                'keypress': ['char']
            },
            'character': {
                'keydown': [
                    null,
                    'key'
                ],
                'keypress': [
                    null,
                    'char'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            'specialChars': {
                'keydown': [
                    null,
                    'char'
                ],
                'keypress': [
                    null,
                    'char'
                ],
                'keyup': [
                    null,
                    'char'
                ]
            },
            'navigation': {
                'keydown': [
                    null,
                    'key'
                ],
                'keypress': [
                    null,
                    'key'
                ]
            },
            'special': {
                'keydown': [
                    null,
                    'key'
                ],
                'keypress': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            'tab': {
                'keydown': [
                    null,
                    'char'
                ],
                'keypress': [
                    null,
                    'char'
                ],
                'keyup': [
                    null,
                    'char'
                ]
            },
            'pause-break': {
                'keydown': [
                    null,
                    'key'
                ],
                'keypress': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            'caps': {
                'keydown': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            'escape': {
                'keydown': [
                    null,
                    'key'
                ],
                'keypress': [
                    null,
                    'key'
                ]
            },
            'num-lock': {
                'keyup': [
                    null,
                    'key'
                ],
                'keydown': [
                    null,
                    'key'
                ],
                'keypress': [
                    null,
                    'key'
                ]
            },
            'scroll-lock': {
                'keydown': [
                    null,
                    'key'
                ],
                'keypress': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            'print': {},
            'function': {
                'keydown': [
                    null,
                    'key'
                ],
                'keypress': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            '\r': {
                'keydown': [
                    null,
                    'key'
                ],
                'keypress': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            }
        }
    };
    syn.mouse.browsers = {
        webkit: {
            'right': {
                'mousedown': {
                    'button': 2,
                    'which': 3
                },
                'mouseup': {
                    'button': 2,
                    'which': 3
                },
                'contextmenu': {
                    'button': 2,
                    'which': 3
                }
            },
            'left': {
                'mousedown': {
                    'button': 0,
                    'which': 1
                },
                'mouseup': {
                    'button': 0,
                    'which': 1
                },
                'click': {
                    'button': 0,
                    'which': 1
                }
            }
        },
        opera: {
            'right': {
                'mousedown': {
                    'button': 2,
                    'which': 3
                },
                'mouseup': {
                    'button': 2,
                    'which': 3
                }
            },
            'left': {
                'mousedown': {
                    'button': 0,
                    'which': 1
                },
                'mouseup': {
                    'button': 0,
                    'which': 1
                },
                'click': {
                    'button': 0,
                    'which': 1
                }
            }
        },
        msie: {
            'right': {
                'mousedown': { 'button': 2 },
                'mouseup': { 'button': 2 },
                'contextmenu': { 'button': 0 }
            },
            'left': {
                'mousedown': { 'button': 1 },
                'mouseup': { 'button': 1 },
                'click': { 'button': 0 }
            }
        },
        chrome: {
            'right': {
                'mousedown': {
                    'button': 2,
                    'which': 3
                },
                'mouseup': {
                    'button': 2,
                    'which': 3
                },
                'contextmenu': {
                    'button': 2,
                    'which': 3
                }
            },
            'left': {
                'mousedown': {
                    'button': 0,
                    'which': 1
                },
                'mouseup': {
                    'button': 0,
                    'which': 1
                },
                'click': {
                    'button': 0,
                    'which': 1
                }
            }
        },
        gecko: {
            'left': {
                'mousedown': {
                    'button': 0,
                    'which': 1
                },
                'mouseup': {
                    'button': 0,
                    'which': 1
                },
                'click': {
                    'button': 0,
                    'which': 1
                }
            },
            'right': {
                'mousedown': {
                    'button': 2,
                    'which': 3
                },
                'mouseup': {
                    'button': 2,
                    'which': 3
                },
                'contextmenu': {
                    'button': 2,
                    'which': 3
                }
            }
        }
    };
    syn.key.browser = function () {
        if (syn.key.browsers[window.navigator.userAgent]) {
            return syn.key.browsers[window.navigator.userAgent];
        }
        for (var browser in syn.browser) {
            if (syn.browser[browser] && syn.key.browsers[browser]) {
                return syn.key.browsers[browser];
            }
        }
        return syn.key.browsers.gecko;
    }();
    syn.mouse.browser = function () {
        if (syn.mouse.browsers[window.navigator.userAgent]) {
            return syn.mouse.browsers[window.navigator.userAgent];
        }
        for (var browser in syn.browser) {
            if (syn.browser[browser] && syn.mouse.browsers[browser]) {
                return syn.mouse.browsers[browser];
            }
        }
        return syn.mouse.browsers.gecko;
    }();
});
/*syn@0.10.0#typeable*/
define('syn@0.10.0#typeable', function (require, exports, module) {
    var syn = require('./synthetic');
    var typeables = [];
    var __indexOf = [].indexOf || function (item) {
        for (var i = 0, l = this.length; i < l; i++) {
            if (i in this && this[i] === item) {
                return i;
            }
        }
        return -1;
    };
    syn.typeable = function (fn) {
        if (__indexOf.call(typeables, fn) === -1) {
            typeables.push(fn);
        }
    };
    syn.typeable.test = function (el) {
        for (var i = 0, len = typeables.length; i < len; i++) {
            if (typeables[i](el)) {
                return true;
            }
        }
        return false;
    };
    var type = syn.typeable;
    var typeableExp = /input|textarea/i;
    type(function (el) {
        return typeableExp.test(el.nodeName);
    });
    type(function (el) {
        return __indexOf.call([
            '',
            'true'
        ], el.getAttribute('contenteditable')) !== -1;
    });
});
/*syn@0.10.0#key*/
define('syn@0.10.0#key', function (require, exports, module) {
    var syn = require('./synthetic');
    require('./typeable');
    require('./browsers');
    var h = syn.helpers, formElExp = /input|textarea/i, supportsSelection = function (el) {
            var result;
            try {
                result = el.selectionStart !== undefined && el.selectionStart !== null;
            } catch (e) {
                result = false;
            }
            return result;
        }, getSelection = function (el) {
            var real, r, start;
            if (supportsSelection(el)) {
                if (document.activeElement && document.activeElement !== el && el.selectionStart === el.selectionEnd && el.selectionStart === 0) {
                    return {
                        start: el.value.length,
                        end: el.value.length
                    };
                }
                return {
                    start: el.selectionStart,
                    end: el.selectionEnd
                };
            } else {
                try {
                    if (el.nodeName.toLowerCase() === 'input') {
                        real = h.getWindow(el).document.selection.createRange();
                        r = el.createTextRange();
                        r.setEndPoint('EndToStart', real);
                        start = r.text.length;
                        return {
                            start: start,
                            end: start + real.text.length
                        };
                    } else {
                        real = h.getWindow(el).document.selection.createRange();
                        r = real.duplicate();
                        var r2 = real.duplicate(), r3 = real.duplicate();
                        r2.collapse();
                        r3.collapse(false);
                        r2.moveStart('character', -1);
                        r3.moveStart('character', -1);
                        r.moveToElementText(el);
                        r.setEndPoint('EndToEnd', real);
                        start = r.text.length - real.text.length;
                        var end = r.text.length;
                        if (start !== 0 && r2.text === '') {
                            start += 2;
                        }
                        if (end !== 0 && r3.text === '') {
                            end += 2;
                        }
                        return {
                            start: start,
                            end: end
                        };
                    }
                } catch (e) {
                    var prop = formElExp.test(el.nodeName) ? 'value' : 'textContent';
                    return {
                        start: el[prop].length,
                        end: el[prop].length
                    };
                }
            }
        }, getFocusable = function (el) {
            var document = h.getWindow(el).document, res = [];
            var els = document.getElementsByTagName('*'), len = els.length;
            for (var i = 0; i < len; i++) {
                if (syn.isFocusable(els[i]) && els[i] !== document.documentElement) {
                    res.push(els[i]);
                }
            }
            return res;
        }, textProperty = function () {
            var el = document.createElement('span');
            return el.textContent != null ? 'textContent' : 'innerText';
        }(), getText = function (el) {
            if (formElExp.test(el.nodeName)) {
                return el.value;
            }
            return el[textProperty];
        }, setText = function (el, value) {
            if (formElExp.test(el.nodeName)) {
                el.value = value;
            } else {
                el[textProperty] = value;
            }
        };
    h.extend(syn, {
        keycodes: {
            '\b': 8,
            '\t': 9,
            '\r': 13,
            'shift': 16,
            'ctrl': 17,
            'alt': 18,
            'meta': 91,
            'pause-break': 19,
            'caps': 20,
            'escape': 27,
            'num-lock': 144,
            'scroll-lock': 145,
            'print': 44,
            'page-up': 33,
            'page-down': 34,
            'end': 35,
            'home': 36,
            'left': 37,
            'up': 38,
            'right': 39,
            'down': 40,
            'insert': 45,
            'delete': 46,
            ' ': 32,
            '0': 48,
            '1': 49,
            '2': 50,
            '3': 51,
            '4': 52,
            '5': 53,
            '6': 54,
            '7': 55,
            '8': 56,
            '9': 57,
            'a': 65,
            'b': 66,
            'c': 67,
            'd': 68,
            'e': 69,
            'f': 70,
            'g': 71,
            'h': 72,
            'i': 73,
            'j': 74,
            'k': 75,
            'l': 76,
            'm': 77,
            'n': 78,
            'o': 79,
            'p': 80,
            'q': 81,
            'r': 82,
            's': 83,
            't': 84,
            'u': 85,
            'v': 86,
            'w': 87,
            'x': 88,
            'y': 89,
            'z': 90,
            'num0': 96,
            'num1': 97,
            'num2': 98,
            'num3': 99,
            'num4': 100,
            'num5': 101,
            'num6': 102,
            'num7': 103,
            'num8': 104,
            'num9': 105,
            '*': 106,
            '+': 107,
            'subtract': 109,
            'decimal': 110,
            'divide': 111,
            ';': 186,
            '=': 187,
            ',': 188,
            'dash': 189,
            '-': 189,
            'period': 190,
            '.': 190,
            'forward-slash': 191,
            '/': 191,
            '`': 192,
            '[': 219,
            '\\': 220,
            ']': 221,
            '\'': 222,
            'left window key': 91,
            'right window key': 92,
            'select key': 93,
            'f1': 112,
            'f2': 113,
            'f3': 114,
            'f4': 115,
            'f5': 116,
            'f6': 117,
            'f7': 118,
            'f8': 119,
            'f9': 120,
            'f10': 121,
            'f11': 122,
            'f12': 123
        },
        selectText: function (el, start, end) {
            if (supportsSelection(el)) {
                if (!end) {
                    syn.__tryFocus(el);
                    el.setSelectionRange(start, start);
                } else {
                    el.selectionStart = start;
                    el.selectionEnd = end;
                }
            } else if (el.createTextRange) {
                var r = el.createTextRange();
                r.moveStart('character', start);
                end = end || start;
                r.moveEnd('character', end - el.value.length);
                r.select();
            }
        },
        getText: function (el) {
            if (syn.typeable.test(el)) {
                var sel = getSelection(el);
                return el.value.substring(sel.start, sel.end);
            }
            var win = syn.helpers.getWindow(el);
            if (win.getSelection) {
                return win.getSelection().toString();
            } else if (win.document.getSelection) {
                return win.document.getSelection().toString();
            } else {
                return win.document.selection.createRange().text;
            }
        },
        getSelection: getSelection
    });
    h.extend(syn.key, {
        data: function (key) {
            if (syn.key.browser[key]) {
                return syn.key.browser[key];
            }
            for (var kind in syn.key.kinds) {
                if (h.inArray(key, syn.key.kinds[kind]) > -1) {
                    return syn.key.browser[kind];
                }
            }
            return syn.key.browser.character;
        },
        isSpecial: function (keyCode) {
            var specials = syn.key.kinds.special;
            for (var i = 0; i < specials.length; i++) {
                if (syn.keycodes[specials[i]] === keyCode) {
                    return specials[i];
                }
            }
        },
        options: function (key, event) {
            var keyData = syn.key.data(key);
            if (!keyData[event]) {
                return null;
            }
            var charCode = keyData[event][0], keyCode = keyData[event][1], result = {};
            if (keyCode === 'key') {
                result.keyCode = syn.keycodes[key];
            } else if (keyCode === 'char') {
                result.keyCode = key.charCodeAt(0);
            } else {
                result.keyCode = keyCode;
            }
            if (charCode === 'char') {
                result.charCode = key.charCodeAt(0);
            } else if (charCode !== null) {
                result.charCode = charCode;
            }
            if (result.keyCode) {
                result.which = result.keyCode;
            } else {
                result.which = result.charCode;
            }
            return result;
        },
        kinds: {
            special: [
                'shift',
                'ctrl',
                'alt',
                'meta',
                'caps'
            ],
            specialChars: ['\b'],
            navigation: [
                'page-up',
                'page-down',
                'end',
                'home',
                'left',
                'up',
                'right',
                'down',
                'insert',
                'delete'
            ],
            'function': [
                'f1',
                'f2',
                'f3',
                'f4',
                'f5',
                'f6',
                'f7',
                'f8',
                'f9',
                'f10',
                'f11',
                'f12'
            ]
        },
        getDefault: function (key) {
            if (syn.key.defaults[key]) {
                return syn.key.defaults[key];
            }
            for (var kind in syn.key.kinds) {
                if (h.inArray(key, syn.key.kinds[kind]) > -1 && syn.key.defaults[kind]) {
                    return syn.key.defaults[kind];
                }
            }
            return syn.key.defaults.character;
        },
        defaults: {
            'character': function (options, scope, key, force, sel) {
                if (/num\d+/.test(key)) {
                    key = key.match(/\d+/)[0];
                }
                if (force || !syn.support.keyCharacters && syn.typeable.test(this)) {
                    var current = getText(this), before = current.substr(0, sel.start), after = current.substr(sel.end), character = key;
                    setText(this, before + character + after);
                    var charLength = character === '\n' && syn.support.textareaCarriage ? 2 : character.length;
                    syn.selectText(this, before.length + charLength);
                }
            },
            'c': function (options, scope, key, force, sel) {
                if (syn.key.ctrlKey) {
                    syn.key.clipboard = syn.getText(this);
                } else {
                    syn.key.defaults.character.apply(this, arguments);
                }
            },
            'v': function (options, scope, key, force, sel) {
                if (syn.key.ctrlKey) {
                    syn.key.defaults.character.call(this, options, scope, syn.key.clipboard, true, sel);
                } else {
                    syn.key.defaults.character.apply(this, arguments);
                }
            },
            'a': function (options, scope, key, force, sel) {
                if (syn.key.ctrlKey) {
                    syn.selectText(this, 0, getText(this).length);
                } else {
                    syn.key.defaults.character.apply(this, arguments);
                }
            },
            'home': function () {
                syn.onParents(this, function (el) {
                    if (el.scrollHeight !== el.clientHeight) {
                        el.scrollTop = 0;
                        return false;
                    }
                });
            },
            'end': function () {
                syn.onParents(this, function (el) {
                    if (el.scrollHeight !== el.clientHeight) {
                        el.scrollTop = el.scrollHeight;
                        return false;
                    }
                });
            },
            'page-down': function () {
                syn.onParents(this, function (el) {
                    if (el.scrollHeight !== el.clientHeight) {
                        var ch = el.clientHeight;
                        el.scrollTop += ch;
                        return false;
                    }
                });
            },
            'page-up': function () {
                syn.onParents(this, function (el) {
                    if (el.scrollHeight !== el.clientHeight) {
                        var ch = el.clientHeight;
                        el.scrollTop -= ch;
                        return false;
                    }
                });
            },
            '\b': function (options, scope, key, force, sel) {
                if (!syn.support.backspaceWorks && syn.typeable.test(this)) {
                    var current = getText(this), before = current.substr(0, sel.start), after = current.substr(sel.end);
                    if (sel.start === sel.end && sel.start > 0) {
                        setText(this, before.substring(0, before.length - 1) + after);
                        syn.selectText(this, sel.start - 1);
                    } else {
                        setText(this, before + after);
                        syn.selectText(this, sel.start);
                    }
                }
            },
            'delete': function (options, scope, key, force, sel) {
                if (!syn.support.backspaceWorks && syn.typeable.test(this)) {
                    var current = getText(this), before = current.substr(0, sel.start), after = current.substr(sel.end);
                    if (sel.start === sel.end && sel.start <= getText(this).length - 1) {
                        setText(this, before + after.substring(1));
                    } else {
                        setText(this, before + after);
                    }
                    syn.selectText(this, sel.start);
                }
            },
            '\r': function (options, scope, key, force, sel) {
                var nodeName = this.nodeName.toLowerCase();
                if (nodeName === 'input') {
                    syn.trigger(this, 'change', {});
                }
                if (!syn.support.keypressSubmits && nodeName === 'input') {
                    var form = syn.closest(this, 'form');
                    if (form) {
                        syn.trigger(form, 'submit', {});
                    }
                }
                if (!syn.support.keyCharacters && nodeName === 'textarea') {
                    syn.key.defaults.character.call(this, options, scope, '\n', undefined, sel);
                }
                if (!syn.support.keypressOnAnchorClicks && nodeName === 'a') {
                    syn.trigger(this, 'click', {});
                }
            },
            '\t': function (options, scope) {
                var focusEls = getFocusable(this), current = null, i = 0, el, firstNotIndexed, orders = [];
                for (; i < focusEls.length; i++) {
                    orders.push([
                        focusEls[i],
                        i
                    ]);
                }
                var sort = function (order1, order2) {
                    var el1 = order1[0], el2 = order2[0], tab1 = syn.tabIndex(el1) || 0, tab2 = syn.tabIndex(el2) || 0;
                    if (tab1 === tab2) {
                        return order1[1] - order2[1];
                    } else {
                        if (tab1 === 0) {
                            return 1;
                        } else if (tab2 === 0) {
                            return -1;
                        } else {
                            return tab1 - tab2;
                        }
                    }
                };
                orders.sort(sort);
                for (i = 0; i < orders.length; i++) {
                    el = orders[i][0];
                    if (this === el) {
                        if (!syn.key.shiftKey) {
                            current = orders[i + 1][0];
                            if (!current) {
                                current = orders[0][0];
                            }
                        } else {
                            current = orders[i - 1][0];
                            if (!current) {
                                current = orders[focusEls.length - 1][0];
                            }
                        }
                    }
                }
                if (!current) {
                    current = firstNotIndexed;
                } else {
                    syn.__tryFocus(current);
                }
                return current;
            },
            'left': function (options, scope, key, force, sel) {
                if (syn.typeable.test(this)) {
                    if (syn.key.shiftKey) {
                        syn.selectText(this, sel.start === 0 ? 0 : sel.start - 1, sel.end);
                    } else {
                        syn.selectText(this, sel.start === 0 ? 0 : sel.start - 1);
                    }
                }
            },
            'right': function (options, scope, key, force, sel) {
                if (syn.typeable.test(this)) {
                    if (syn.key.shiftKey) {
                        syn.selectText(this, sel.start, sel.end + 1 > getText(this).length ? getText(this).length : sel.end + 1);
                    } else {
                        syn.selectText(this, sel.end + 1 > getText(this).length ? getText(this).length : sel.end + 1);
                    }
                }
            },
            'up': function () {
                if (/select/i.test(this.nodeName)) {
                    this.selectedIndex = this.selectedIndex ? this.selectedIndex - 1 : 0;
                }
            },
            'down': function () {
                if (/select/i.test(this.nodeName)) {
                    syn.changeOnBlur(this, 'selectedIndex', this.selectedIndex);
                    this.selectedIndex = this.selectedIndex + 1;
                }
            },
            'shift': function () {
                return null;
            },
            'ctrl': function () {
                return null;
            },
            'alt': function () {
                return null;
            },
            'meta': function () {
                return null;
            }
        }
    });
    h.extend(syn.create, {
        keydown: {
            setup: function (type, options, element) {
                if (h.inArray(options, syn.key.kinds.special) !== -1) {
                    syn.key[options + 'Key'] = element;
                }
            }
        },
        keypress: {
            setup: function (type, options, element) {
                if (syn.support.keyCharacters && !syn.support.keysOnNotFocused) {
                    syn.__tryFocus(element);
                }
            }
        },
        keyup: {
            setup: function (type, options, element) {
                if (h.inArray(options, syn.key.kinds.special) !== -1) {
                    syn.key[options + 'Key'] = null;
                }
            }
        },
        key: {
            options: function (type, options, element) {
                options = typeof options !== 'object' ? { character: options } : options;
                options = h.extend({}, options);
                if (options.character) {
                    h.extend(options, syn.key.options(options.character, type));
                    delete options.character;
                }
                options = h.extend({
                    ctrlKey: !!syn.key.ctrlKey,
                    altKey: !!syn.key.altKey,
                    shiftKey: !!syn.key.shiftKey,
                    metaKey: !!syn.key.metaKey
                }, options);
                return options;
            },
            event: function (type, options, element) {
                var doc = h.getWindow(element).document || document, event;
                if (doc.createEvent) {
                    try {
                        event = doc.createEvent('KeyEvents');
                        event.initKeyEvent(type, true, true, window, options.ctrlKey, options.altKey, options.shiftKey, options.metaKey, options.keyCode, options.charCode);
                    } catch (e) {
                        event = h.createBasicStandardEvent(type, options, doc);
                    }
                    event.synthetic = true;
                    return event;
                } else {
                    try {
                        event = h.createEventObject.apply(this, arguments);
                        h.extend(event, options);
                    } catch (e) {
                    }
                    return event;
                }
            }
        }
    });
    var convert = {
        'enter': '\r',
        'backspace': '\b',
        'tab': '\t',
        'space': ' '
    };
    h.extend(syn.init.prototype, {
        _key: function (element, options, callback) {
            if (/-up$/.test(options) && h.inArray(options.replace('-up', ''), syn.key.kinds.special) !== -1) {
                syn.trigger(element, 'keyup', options.replace('-up', ''));
                return callback(true, element);
            }
            var activeElement = h.getWindow(element).document.activeElement, caret = syn.typeable.test(element) && getSelection(element), key = convert[options] || options, runDefaults = syn.trigger(element, 'keydown', key), getDefault = syn.key.getDefault, prevent = syn.key.browser.prevent, defaultResult, keypressOptions = syn.key.options(key, 'keypress');
            if (runDefaults) {
                if (!keypressOptions) {
                    defaultResult = getDefault(key).call(element, keypressOptions, h.getWindow(element), key, undefined, caret);
                } else {
                    if (activeElement !== h.getWindow(element).document.activeElement) {
                        element = h.getWindow(element).document.activeElement;
                    }
                    runDefaults = syn.trigger(element, 'keypress', keypressOptions);
                    if (runDefaults) {
                        defaultResult = getDefault(key).call(element, keypressOptions, h.getWindow(element), key, undefined, caret);
                    }
                }
            } else {
                if (keypressOptions && h.inArray('keypress', prevent.keydown) === -1) {
                    if (activeElement !== h.getWindow(element).document.activeElement) {
                        element = h.getWindow(element).document.activeElement;
                    }
                    syn.trigger(element, 'keypress', keypressOptions);
                }
            }
            if (defaultResult && defaultResult.nodeName) {
                element = defaultResult;
            }
            if (defaultResult !== null) {
                syn.schedule(function () {
                    if (syn.support.oninput) {
                        syn.trigger(element, 'input', syn.key.options(key, 'input'));
                    }
                    syn.trigger(element, 'keyup', syn.key.options(key, 'keyup'));
                    callback(runDefaults, element);
                }, 1);
            } else {
                callback(runDefaults, element);
            }
            return element;
        },
        _type: function (element, options, callback) {
            var parts = (options + '').match(/(\[[^\]]+\])|([^\[])/g), self = this, runNextPart = function (runDefaults, el) {
                    var part = parts.shift();
                    if (!part) {
                        callback(runDefaults, el);
                        return;
                    }
                    el = el || element;
                    if (part.length > 1) {
                        part = part.substr(1, part.length - 2);
                    }
                    self._key(el, part, runNextPart);
                };
            runNextPart();
        }
    });
});
/*syn@0.10.0#key.support*/
define('syn@0.10.0#key.support', function (require, exports, module) {
    var syn = require('./synthetic');
    require('./key');
    if (!syn.config.support) {
        (function checkForSupport() {
            if (!document.body) {
                return syn.schedule(checkForSupport, 1);
            }
            var div = document.createElement('div'), checkbox, submit, form, anchor, textarea, inputter, one, doc;
            doc = document.documentElement;
            div.innerHTML = '<form id=\'outer\'>' + '<input name=\'checkbox\' type=\'checkbox\'/>' + '<input name=\'radio\' type=\'radio\' />' + '<input type=\'submit\' name=\'submitter\'/>' + '<input type=\'input\' name=\'inputter\'/>' + '<input name=\'one\'>' + '<input name=\'two\'/>' + '<a href=\'#abc\'></a>' + '<textarea>1\n2</textarea>' + '</form>';
            doc.insertBefore(div, doc.firstElementChild || doc.children[0]);
            form = div.firstChild;
            checkbox = form.childNodes[0];
            submit = form.childNodes[2];
            anchor = form.getElementsByTagName('a')[0];
            textarea = form.getElementsByTagName('textarea')[0];
            inputter = form.childNodes[3];
            one = form.childNodes[4];
            form.onsubmit = function (ev) {
                if (ev.preventDefault) {
                    ev.preventDefault();
                }
                syn.support.keypressSubmits = true;
                ev.returnValue = false;
                return false;
            };
            syn.__tryFocus(inputter);
            syn.trigger(inputter, 'keypress', '\r');
            syn.trigger(inputter, 'keypress', 'a');
            syn.support.keyCharacters = inputter.value === 'a';
            inputter.value = 'a';
            syn.trigger(inputter, 'keypress', '\b');
            syn.support.backspaceWorks = inputter.value === '';
            inputter.onchange = function () {
                syn.support.focusChanges = true;
            };
            syn.__tryFocus(inputter);
            syn.trigger(inputter, 'keypress', 'a');
            syn.__tryFocus(form.childNodes[5]);
            syn.trigger(inputter, 'keypress', 'b');
            syn.support.keysOnNotFocused = inputter.value === 'ab';
            syn.bind(anchor, 'click', function (ev) {
                if (ev.preventDefault) {
                    ev.preventDefault();
                }
                syn.support.keypressOnAnchorClicks = true;
                ev.returnValue = false;
                return false;
            });
            syn.trigger(anchor, 'keypress', '\r');
            syn.support.textareaCarriage = textarea.value.length === 4;
            syn.support.oninput = 'oninput' in one;
            doc.removeChild(div);
            syn.support.ready++;
        }());
    } else {
        syn.helpers.extend(syn.support, syn.config.support);
    }
});
/*syn@0.10.0#drag*/
define('syn@0.10.0#drag', function (require, exports, module) {
    var syn = require('./synthetic');
    (function dragSupport() {
        if (!document.body) {
            syn.schedule(dragSupport, 1);
            return;
        }
        var div = document.createElement('div');
        document.body.appendChild(div);
        syn.helpers.extend(div.style, {
            width: '100px',
            height: '10000px',
            backgroundColor: 'blue',
            position: 'absolute',
            top: '10px',
            left: '0px',
            zIndex: 19999
        });
        document.body.scrollTop = 11;
        if (!document.elementFromPoint) {
            return;
        }
        var el = document.elementFromPoint(3, 1);
        if (el === div) {
            syn.support.elementFromClient = true;
        } else {
            syn.support.elementFromPage = true;
        }
        document.body.removeChild(div);
        document.body.scrollTop = 0;
    }());
    var elementFromPoint = function (point, element) {
            var clientX = point.clientX, clientY = point.clientY, win = syn.helpers.getWindow(element), el;
            if (syn.support.elementFromPage) {
                var off = syn.helpers.scrollOffset(win);
                clientX = clientX + off.left;
                clientY = clientY + off.top;
            }
            el = win.document.elementFromPoint ? win.document.elementFromPoint(clientX, clientY) : element;
            if (el === win.document.documentElement && (point.clientY < 0 || point.clientX < 0)) {
                return element;
            } else {
                return el;
            }
        }, createEventAtPoint = function (event, point, element) {
            var el = elementFromPoint(point, element);
            syn.trigger(el || element, event, point);
            return el;
        }, mouseMove = function (point, element, last) {
            var el = elementFromPoint(point, element);
            if (last !== el && el && last) {
                var options = syn.helpers.extend({}, point);
                options.relatedTarget = el;
                if (syn.support.pointerEvents) {
                    syn.trigger(last, 'pointerout', options);
                }
                syn.trigger(last, 'mouseout', options);
                options.relatedTarget = last;
                if (syn.support.pointerEvents) {
                    syn.trigger(el, 'pointerover', options);
                }
                syn.trigger(el, 'mouseover', options);
            }
            if (syn.support.pointerEvents) {
                syn.trigger(el || element, 'pointermove', point);
            }
            if (syn.support.touchEvents) {
                syn.trigger(el || element, 'touchmove', point);
            }
            syn.trigger(el || element, 'mousemove', point);
            return el;
        }, startMove = function (start, end, duration, element, callback) {
            var startTime = new Date(), distX = end.clientX - start.clientX, distY = end.clientY - start.clientY, win = syn.helpers.getWindow(element), current = elementFromPoint(start, element), cursor = win.document.createElement('div'), calls = 0, move;
            move = function onmove() {
                var now = new Date(), scrollOffset = syn.helpers.scrollOffset(win), fraction = (calls === 0 ? 0 : now - startTime) / duration, options = {
                        clientX: distX * fraction + start.clientX,
                        clientY: distY * fraction + start.clientY
                    };
                calls++;
                if (fraction < 1) {
                    syn.helpers.extend(cursor.style, {
                        left: options.clientX + scrollOffset.left + 2 + 'px',
                        top: options.clientY + scrollOffset.top + 2 + 'px'
                    });
                    current = mouseMove(options, element, current);
                    syn.schedule(onmove, 15);
                } else {
                    current = mouseMove(end, element, current);
                    win.document.body.removeChild(cursor);
                    callback();
                }
            };
            syn.helpers.extend(cursor.style, {
                height: '5px',
                width: '5px',
                backgroundColor: 'red',
                position: 'absolute',
                zIndex: 19999,
                fontSize: '1px'
            });
            win.document.body.appendChild(cursor);
            move();
        }, startDrag = function (start, end, duration, element, callback) {
            if (syn.support.pointerEvents) {
                createEventAtPoint('pointerdown', start, element);
            }
            if (syn.support.touchEvents) {
                createEventAtPoint('touchstart', start, element);
            }
            createEventAtPoint('mousedown', start, element);
            startMove(start, end, duration, element, function () {
                if (syn.support.pointerEvents) {
                    createEventAtPoint('pointerup', end, element);
                }
                if (syn.support.touchEvents) {
                    createEventAtPoint('touchend', end, element);
                }
                createEventAtPoint('mouseup', end, element);
                callback();
            });
        }, center = function (el) {
            var j = syn.jquery()(el), o = j.offset();
            return {
                pageX: o.left + j.outerWidth() / 2,
                pageY: o.top + j.outerHeight() / 2
            };
        }, convertOption = function (option, win, from) {
            var page = /(\d+)[x ](\d+)/, client = /(\d+)X(\d+)/, relative = /([+-]\d+)[xX ]([+-]\d+)/, parts;
            if (typeof option === 'string' && relative.test(option) && from) {
                var cent = center(from);
                parts = option.match(relative);
                option = {
                    pageX: cent.pageX + parseInt(parts[1]),
                    pageY: cent.pageY + parseInt(parts[2])
                };
            }
            if (typeof option === 'string' && page.test(option)) {
                parts = option.match(page);
                option = {
                    pageX: parseInt(parts[1]),
                    pageY: parseInt(parts[2])
                };
            }
            if (typeof option === 'string' && client.test(option)) {
                parts = option.match(client);
                option = {
                    clientX: parseInt(parts[1]),
                    clientY: parseInt(parts[2])
                };
            }
            if (typeof option === 'string') {
                option = syn.jquery()(option, win.document)[0];
            }
            if (option.nodeName) {
                option = center(option);
            }
            if (option.pageX != null) {
                var off = syn.helpers.scrollOffset(win);
                option = {
                    clientX: option.pageX - off.left,
                    clientY: option.pageY - off.top
                };
            }
            return option;
        }, adjust = function (from, to, win) {
            if (from.clientY < 0) {
                var off = syn.helpers.scrollOffset(win);
                var top = off.top + from.clientY - 100, diff = top - off.top;
                if (top > 0) {
                } else {
                    top = 0;
                    diff = -off.top;
                }
                from.clientY = from.clientY - diff;
                to.clientY = to.clientY - diff;
                syn.helpers.scrollOffset(win, {
                    top: top,
                    left: off.left
                });
            }
        };
    syn.helpers.extend(syn.init.prototype, {
        _move: function (from, options, callback) {
            var win = syn.helpers.getWindow(from), fro = convertOption(options.from || from, win, from), to = convertOption(options.to || options, win, from);
            if (options.adjust !== false) {
                adjust(fro, to, win);
            }
            startMove(fro, to, options.duration || 500, from, callback);
        },
        _drag: function (from, options, callback) {
            var win = syn.helpers.getWindow(from), fro = convertOption(options.from || from, win, from), to = convertOption(options.to || options, win, from);
            if (options.adjust !== false) {
                adjust(fro, to, win);
            }
            startDrag(fro, to, options.duration || 500, from, callback);
        }
    });
});
/*syn@0.10.0#syn*/
define('syn@0.10.0#syn', function (require, exports, module) {
    var syn = require('./synthetic');
    require('./mouse.support');
    require('./browsers');
    require('./key.support');
    require('./drag');
    window.syn = syn;
    module.exports = syn;
});
/*jquery@1.11.0#dist/jquery*/
(function (global, factory) {
    if (typeof module === 'object' && typeof module.exports === 'object') {
        module.exports = global.document ? factory(global, true) : function (w) {
            if (!w.document) {
                throw new Error('jQuery requires a window with a document');
            }
            return factory(w);
        };
    } else {
        factory(global);
    }
}(typeof window !== 'undefined' ? window : this, function (window, noGlobal) {
    var deletedIds = [];
    var slice = deletedIds.slice;
    var concat = deletedIds.concat;
    var push = deletedIds.push;
    var indexOf = deletedIds.indexOf;
    var class2type = {};
    var toString = class2type.toString;
    var hasOwn = class2type.hasOwnProperty;
    var trim = ''.trim;
    var support = {};
    var version = '1.11.0', jQuery = function (selector, context) {
            return new jQuery.fn.init(selector, context);
        }, rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, rmsPrefix = /^-ms-/, rdashAlpha = /-([\da-z])/gi, fcamelCase = function (all, letter) {
            return letter.toUpperCase();
        };
    jQuery.fn = jQuery.prototype = {
        jquery: version,
        constructor: jQuery,
        selector: '',
        length: 0,
        toArray: function () {
            return slice.call(this);
        },
        get: function (num) {
            return num != null ? num < 0 ? this[num + this.length] : this[num] : slice.call(this);
        },
        pushStack: function (elems) {
            var ret = jQuery.merge(this.constructor(), elems);
            ret.prevObject = this;
            ret.context = this.context;
            return ret;
        },
        each: function (callback, args) {
            return jQuery.each(this, callback, args);
        },
        map: function (callback) {
            return this.pushStack(jQuery.map(this, function (elem, i) {
                return callback.call(elem, i, elem);
            }));
        },
        slice: function () {
            return this.pushStack(slice.apply(this, arguments));
        },
        first: function () {
            return this.eq(0);
        },
        last: function () {
            return this.eq(-1);
        },
        eq: function (i) {
            var len = this.length, j = +i + (i < 0 ? len : 0);
            return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
        },
        end: function () {
            return this.prevObject || this.constructor(null);
        },
        push: push,
        sort: deletedIds.sort,
        splice: deletedIds.splice
    };
    jQuery.extend = jQuery.fn.extend = function () {
        var src, copyIsArray, copy, name, options, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
        if (typeof target === 'boolean') {
            deep = target;
            target = arguments[i] || {};
            i++;
        }
        if (typeof target !== 'object' && !jQuery.isFunction(target)) {
            target = {};
        }
        if (i === length) {
            target = this;
            i--;
        }
        for (; i < length; i++) {
            if ((options = arguments[i]) != null) {
                for (name in options) {
                    src = target[name];
                    copy = options[name];
                    if (target === copy) {
                        continue;
                    }
                    if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
                        if (copyIsArray) {
                            copyIsArray = false;
                            clone = src && jQuery.isArray(src) ? src : [];
                        } else {
                            clone = src && jQuery.isPlainObject(src) ? src : {};
                        }
                        target[name] = jQuery.extend(deep, clone, copy);
                    } else if (copy !== undefined) {
                        target[name] = copy;
                    }
                }
            }
        }
        return target;
    };
    jQuery.extend({
        expando: 'jQuery' + (version + Math.random()).replace(/\D/g, ''),
        isReady: true,
        error: function (msg) {
            throw new Error(msg);
        },
        noop: function () {
        },
        isFunction: function (obj) {
            return jQuery.type(obj) === 'function';
        },
        isArray: Array.isArray || function (obj) {
            return jQuery.type(obj) === 'array';
        },
        isWindow: function (obj) {
            return obj != null && obj == obj.window;
        },
        isNumeric: function (obj) {
            return obj - parseFloat(obj) >= 0;
        },
        isEmptyObject: function (obj) {
            var name;
            for (name in obj) {
                return false;
            }
            return true;
        },
        isPlainObject: function (obj) {
            var key;
            if (!obj || jQuery.type(obj) !== 'object' || obj.nodeType || jQuery.isWindow(obj)) {
                return false;
            }
            try {
                if (obj.constructor && !hasOwn.call(obj, 'constructor') && !hasOwn.call(obj.constructor.prototype, 'isPrototypeOf')) {
                    return false;
                }
            } catch (e) {
                return false;
            }
            if (support.ownLast) {
                for (key in obj) {
                    return hasOwn.call(obj, key);
                }
            }
            for (key in obj) {
            }
            return key === undefined || hasOwn.call(obj, key);
        },
        type: function (obj) {
            if (obj == null) {
                return obj + '';
            }
            return typeof obj === 'object' || typeof obj === 'function' ? class2type[toString.call(obj)] || 'object' : typeof obj;
        },
        globalEval: function (data) {
            if (data && jQuery.trim(data)) {
                (window.execScript || function (data) {
                    window['eval'].call(window, data);
                })(data);
            }
        },
        camelCase: function (string) {
            return string.replace(rmsPrefix, 'ms-').replace(rdashAlpha, fcamelCase);
        },
        nodeName: function (elem, name) {
            return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
        },
        each: function (obj, callback, args) {
            var value, i = 0, length = obj.length, isArray = isArraylike(obj);
            if (args) {
                if (isArray) {
                    for (; i < length; i++) {
                        value = callback.apply(obj[i], args);
                        if (value === false) {
                            break;
                        }
                    }
                } else {
                    for (i in obj) {
                        value = callback.apply(obj[i], args);
                        if (value === false) {
                            break;
                        }
                    }
                }
            } else {
                if (isArray) {
                    for (; i < length; i++) {
                        value = callback.call(obj[i], i, obj[i]);
                        if (value === false) {
                            break;
                        }
                    }
                } else {
                    for (i in obj) {
                        value = callback.call(obj[i], i, obj[i]);
                        if (value === false) {
                            break;
                        }
                    }
                }
            }
            return obj;
        },
        trim: trim && !trim.call('\uFEFF\xA0') ? function (text) {
            return text == null ? '' : trim.call(text);
        } : function (text) {
            return text == null ? '' : (text + '').replace(rtrim, '');
        },
        makeArray: function (arr, results) {
            var ret = results || [];
            if (arr != null) {
                if (isArraylike(Object(arr))) {
                    jQuery.merge(ret, typeof arr === 'string' ? [arr] : arr);
                } else {
                    push.call(ret, arr);
                }
            }
            return ret;
        },
        inArray: function (elem, arr, i) {
            var len;
            if (arr) {
                if (indexOf) {
                    return indexOf.call(arr, elem, i);
                }
                len = arr.length;
                i = i ? i < 0 ? Math.max(0, len + i) : i : 0;
                for (; i < len; i++) {
                    if (i in arr && arr[i] === elem) {
                        return i;
                    }
                }
            }
            return -1;
        },
        merge: function (first, second) {
            var len = +second.length, j = 0, i = first.length;
            while (j < len) {
                first[i++] = second[j++];
            }
            if (len !== len) {
                while (second[j] !== undefined) {
                    first[i++] = second[j++];
                }
            }
            first.length = i;
            return first;
        },
        grep: function (elems, callback, invert) {
            var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert;
            for (; i < length; i++) {
                callbackInverse = !callback(elems[i], i);
                if (callbackInverse !== callbackExpect) {
                    matches.push(elems[i]);
                }
            }
            return matches;
        },
        map: function (elems, callback, arg) {
            var value, i = 0, length = elems.length, isArray = isArraylike(elems), ret = [];
            if (isArray) {
                for (; i < length; i++) {
                    value = callback(elems[i], i, arg);
                    if (value != null) {
                        ret.push(value);
                    }
                }
            } else {
                for (i in elems) {
                    value = callback(elems[i], i, arg);
                    if (value != null) {
                        ret.push(value);
                    }
                }
            }
            return concat.apply([], ret);
        },
        guid: 1,
        proxy: function (fn, context) {
            var args, proxy, tmp;
            if (typeof context === 'string') {
                tmp = fn[context];
                context = fn;
                fn = tmp;
            }
            if (!jQuery.isFunction(fn)) {
                return undefined;
            }
            args = slice.call(arguments, 2);
            proxy = function () {
                return fn.apply(context || this, args.concat(slice.call(arguments)));
            };
            proxy.guid = fn.guid = fn.guid || jQuery.guid++;
            return proxy;
        },
        now: function () {
            return +new Date();
        },
        support: support
    });
    jQuery.each('Boolean Number String Function Array Date RegExp Object Error'.split(' '), function (i, name) {
        class2type['[object ' + name + ']'] = name.toLowerCase();
    });
    function isArraylike(obj) {
        var length = obj.length, type = jQuery.type(obj);
        if (type === 'function' || jQuery.isWindow(obj)) {
            return false;
        }
        if (obj.nodeType === 1 && length) {
            return true;
        }
        return type === 'array' || length === 0 || typeof length === 'number' && length > 0 && length - 1 in obj;
    }
    var Sizzle = function (window) {
        var i, support, Expr, getText, isXML, compile, outermostContext, sortInput, hasDuplicate, setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = 'sizzle' + -new Date(), preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), sortOrder = function (a, b) {
                if (a === b) {
                    hasDuplicate = true;
                }
                return 0;
            }, strundefined = typeof undefined, MAX_NEGATIVE = 1 << 31, hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push = arr.push, slice = arr.slice, indexOf = arr.indexOf || function (elem) {
                var i = 0, len = this.length;
                for (; i < len; i++) {
                    if (this[i] === elem) {
                        return i;
                    }
                }
                return -1;
            }, booleans = 'checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped', whitespace = '[\\x20\\t\\r\\n\\f]', characterEncoding = '(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+', identifier = characterEncoding.replace('w', 'w#'), attributes = '\\[' + whitespace + '*(' + characterEncoding + ')' + whitespace + '*(?:([*^$|!~]?=)' + whitespace + '*(?:([\'"])((?:\\\\.|[^\\\\])*?)\\3|(' + identifier + ')|)|)' + whitespace + '*\\]', pseudos = ':(' + characterEncoding + ')(?:\\((([\'"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|' + attributes.replace(3, 8) + ')*)|.*)\\)|)', rtrim = new RegExp('^' + whitespace + '+|((?:^|[^\\\\])(?:\\\\.)*)' + whitespace + '+$', 'g'), rcomma = new RegExp('^' + whitespace + '*,' + whitespace + '*'), rcombinators = new RegExp('^' + whitespace + '*([>+~]|' + whitespace + ')' + whitespace + '*'), rattributeQuotes = new RegExp('=' + whitespace + '*([^\\]\'"]*?)' + whitespace + '*\\]', 'g'), rpseudo = new RegExp(pseudos), ridentifier = new RegExp('^' + identifier + '$'), matchExpr = {
                'ID': new RegExp('^#(' + characterEncoding + ')'),
                'CLASS': new RegExp('^\\.(' + characterEncoding + ')'),
                'TAG': new RegExp('^(' + characterEncoding.replace('w', 'w*') + ')'),
                'ATTR': new RegExp('^' + attributes),
                'PSEUDO': new RegExp('^' + pseudos),
                'CHILD': new RegExp('^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(' + whitespace + '*(even|odd|(([+-]|)(\\d*)n|)' + whitespace + '*(?:([+-]|)' + whitespace + '*(\\d+)|))' + whitespace + '*\\)|)', 'i'),
                'bool': new RegExp('^(?:' + booleans + ')$', 'i'),
                'needsContext': new RegExp('^' + whitespace + '*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(' + whitespace + '*((?:-\\d)?\\d*)' + whitespace + '*\\)|)(?=[^-]|$)', 'i')
            }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, rescape = /'|\\/g, runescape = new RegExp('\\\\([\\da-f]{1,6}' + whitespace + '?|(' + whitespace + ')|.)', 'ig'), funescape = function (_, escaped, escapedWhitespace) {
                var high = '0x' + escaped - 65536;
                return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
            };
        try {
            push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
            arr[preferredDoc.childNodes.length].nodeType;
        } catch (e) {
            push = {
                apply: arr.length ? function (target, els) {
                    push_native.apply(target, slice.call(els));
                } : function (target, els) {
                    var j = target.length, i = 0;
                    while (target[j++] = els[i++]) {
                    }
                    target.length = j - 1;
                }
            };
        }
        function Sizzle(selector, context, results, seed) {
            var match, elem, m, nodeType, i, groups, old, nid, newContext, newSelector;
            if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
                setDocument(context);
            }
            context = context || document;
            results = results || [];
            if (!selector || typeof selector !== 'string') {
                return results;
            }
            if ((nodeType = context.nodeType) !== 1 && nodeType !== 9) {
                return [];
            }
            if (documentIsHTML && !seed) {
                if (match = rquickExpr.exec(selector)) {
                    if (m = match[1]) {
                        if (nodeType === 9) {
                            elem = context.getElementById(m);
                            if (elem && elem.parentNode) {
                                if (elem.id === m) {
                                    results.push(elem);
                                    return results;
                                }
                            } else {
                                return results;
                            }
                        } else {
                            if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m) {
                                results.push(elem);
                                return results;
                            }
                        }
                    } else if (match[2]) {
                        push.apply(results, context.getElementsByTagName(selector));
                        return results;
                    } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
                        push.apply(results, context.getElementsByClassName(m));
                        return results;
                    }
                }
                if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                    nid = old = expando;
                    newContext = context;
                    newSelector = nodeType === 9 && selector;
                    if (nodeType === 1 && context.nodeName.toLowerCase() !== 'object') {
                        groups = tokenize(selector);
                        if (old = context.getAttribute('id')) {
                            nid = old.replace(rescape, '\\$&');
                        } else {
                            context.setAttribute('id', nid);
                        }
                        nid = '[id=\'' + nid + '\'] ';
                        i = groups.length;
                        while (i--) {
                            groups[i] = nid + toSelector(groups[i]);
                        }
                        newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                        newSelector = groups.join(',');
                    }
                    if (newSelector) {
                        try {
                            push.apply(results, newContext.querySelectorAll(newSelector));
                            return results;
                        } catch (qsaError) {
                        } finally {
                            if (!old) {
                                context.removeAttribute('id');
                            }
                        }
                    }
                }
            }
            return select(selector.replace(rtrim, '$1'), context, results, seed);
        }
        function createCache() {
            var keys = [];
            function cache(key, value) {
                if (keys.push(key + ' ') > Expr.cacheLength) {
                    delete cache[keys.shift()];
                }
                return cache[key + ' '] = value;
            }
            return cache;
        }
        function markFunction(fn) {
            fn[expando] = true;
            return fn;
        }
        function assert(fn) {
            var div = document.createElement('div');
            try {
                return !!fn(div);
            } catch (e) {
                return false;
            } finally {
                if (div.parentNode) {
                    div.parentNode.removeChild(div);
                }
                div = null;
            }
        }
        function addHandle(attrs, handler) {
            var arr = attrs.split('|'), i = attrs.length;
            while (i--) {
                Expr.attrHandle[arr[i]] = handler;
            }
        }
        function siblingCheck(a, b) {
            var cur = b && a, diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
            if (diff) {
                return diff;
            }
            if (cur) {
                while (cur = cur.nextSibling) {
                    if (cur === b) {
                        return -1;
                    }
                }
            }
            return a ? 1 : -1;
        }
        function createInputPseudo(type) {
            return function (elem) {
                var name = elem.nodeName.toLowerCase();
                return name === 'input' && elem.type === type;
            };
        }
        function createButtonPseudo(type) {
            return function (elem) {
                var name = elem.nodeName.toLowerCase();
                return (name === 'input' || name === 'button') && elem.type === type;
            };
        }
        function createPositionalPseudo(fn) {
            return markFunction(function (argument) {
                argument = +argument;
                return markFunction(function (seed, matches) {
                    var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length;
                    while (i--) {
                        if (seed[j = matchIndexes[i]]) {
                            seed[j] = !(matches[j] = seed[j]);
                        }
                    }
                });
            });
        }
        function testContext(context) {
            return context && typeof context.getElementsByTagName !== strundefined && context;
        }
        support = Sizzle.support = {};
        isXML = Sizzle.isXML = function (elem) {
            var documentElement = elem && (elem.ownerDocument || elem).documentElement;
            return documentElement ? documentElement.nodeName !== 'HTML' : false;
        };
        setDocument = Sizzle.setDocument = function (node) {
            var hasCompare, doc = node ? node.ownerDocument || node : preferredDoc, parent = doc.defaultView;
            if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
                return document;
            }
            document = doc;
            docElem = doc.documentElement;
            documentIsHTML = !isXML(doc);
            if (parent && parent !== parent.top) {
                if (parent.addEventListener) {
                    parent.addEventListener('unload', function () {
                        setDocument();
                    }, false);
                } else if (parent.attachEvent) {
                    parent.attachEvent('onunload', function () {
                        setDocument();
                    });
                }
            }
            support.attributes = assert(function (div) {
                div.className = 'i';
                return !div.getAttribute('className');
            });
            support.getElementsByTagName = assert(function (div) {
                div.appendChild(doc.createComment(''));
                return !div.getElementsByTagName('*').length;
            });
            support.getElementsByClassName = rnative.test(doc.getElementsByClassName) && assert(function (div) {
                div.innerHTML = '<div class=\'a\'></div><div class=\'a i\'></div>';
                div.firstChild.className = 'i';
                return div.getElementsByClassName('i').length === 2;
            });
            support.getById = assert(function (div) {
                docElem.appendChild(div).id = expando;
                return !doc.getElementsByName || !doc.getElementsByName(expando).length;
            });
            if (support.getById) {
                Expr.find['ID'] = function (id, context) {
                    if (typeof context.getElementById !== strundefined && documentIsHTML) {
                        var m = context.getElementById(id);
                        return m && m.parentNode ? [m] : [];
                    }
                };
                Expr.filter['ID'] = function (id) {
                    var attrId = id.replace(runescape, funescape);
                    return function (elem) {
                        return elem.getAttribute('id') === attrId;
                    };
                };
            } else {
                delete Expr.find['ID'];
                Expr.filter['ID'] = function (id) {
                    var attrId = id.replace(runescape, funescape);
                    return function (elem) {
                        var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode('id');
                        return node && node.value === attrId;
                    };
                };
            }
            Expr.find['TAG'] = support.getElementsByTagName ? function (tag, context) {
                if (typeof context.getElementsByTagName !== strundefined) {
                    return context.getElementsByTagName(tag);
                }
            } : function (tag, context) {
                var elem, tmp = [], i = 0, results = context.getElementsByTagName(tag);
                if (tag === '*') {
                    while (elem = results[i++]) {
                        if (elem.nodeType === 1) {
                            tmp.push(elem);
                        }
                    }
                    return tmp;
                }
                return results;
            };
            Expr.find['CLASS'] = support.getElementsByClassName && function (className, context) {
                if (typeof context.getElementsByClassName !== strundefined && documentIsHTML) {
                    return context.getElementsByClassName(className);
                }
            };
            rbuggyMatches = [];
            rbuggyQSA = [];
            if (support.qsa = rnative.test(doc.querySelectorAll)) {
                assert(function (div) {
                    div.innerHTML = '<select t=\'\'><option selected=\'\'></option></select>';
                    if (div.querySelectorAll('[t^=\'\']').length) {
                        rbuggyQSA.push('[*^$]=' + whitespace + '*(?:\'\'|"")');
                    }
                    if (!div.querySelectorAll('[selected]').length) {
                        rbuggyQSA.push('\\[' + whitespace + '*(?:value|' + booleans + ')');
                    }
                    if (!div.querySelectorAll(':checked').length) {
                        rbuggyQSA.push(':checked');
                    }
                });
                assert(function (div) {
                    var input = doc.createElement('input');
                    input.setAttribute('type', 'hidden');
                    div.appendChild(input).setAttribute('name', 'D');
                    if (div.querySelectorAll('[name=d]').length) {
                        rbuggyQSA.push('name' + whitespace + '*[*^$|!~]?=');
                    }
                    if (!div.querySelectorAll(':enabled').length) {
                        rbuggyQSA.push(':enabled', ':disabled');
                    }
                    div.querySelectorAll('*,:x');
                    rbuggyQSA.push(',.*:');
                });
            }
            if (support.matchesSelector = rnative.test(matches = docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
                assert(function (div) {
                    support.disconnectedMatch = matches.call(div, 'div');
                    matches.call(div, '[s!=\'\']:x');
                    rbuggyMatches.push('!=', pseudos);
                });
            }
            rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join('|'));
            rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join('|'));
            hasCompare = rnative.test(docElem.compareDocumentPosition);
            contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {
                var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
                return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
            } : function (a, b) {
                if (b) {
                    while (b = b.parentNode) {
                        if (b === a) {
                            return true;
                        }
                    }
                }
                return false;
            };
            sortOrder = hasCompare ? function (a, b) {
                if (a === b) {
                    hasDuplicate = true;
                    return 0;
                }
                var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                if (compare) {
                    return compare;
                }
                compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;
                if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
                    if (a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
                        return -1;
                    }
                    if (b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
                        return 1;
                    }
                    return sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0;
                }
                return compare & 4 ? -1 : 1;
            } : function (a, b) {
                if (a === b) {
                    hasDuplicate = true;
                    return 0;
                }
                var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [a], bp = [b];
                if (!aup || !bup) {
                    return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0;
                } else if (aup === bup) {
                    return siblingCheck(a, b);
                }
                cur = a;
                while (cur = cur.parentNode) {
                    ap.unshift(cur);
                }
                cur = b;
                while (cur = cur.parentNode) {
                    bp.unshift(cur);
                }
                while (ap[i] === bp[i]) {
                    i++;
                }
                return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
            };
            return doc;
        };
        Sizzle.matches = function (expr, elements) {
            return Sizzle(expr, null, null, elements);
        };
        Sizzle.matchesSelector = function (elem, expr) {
            if ((elem.ownerDocument || elem) !== document) {
                setDocument(elem);
            }
            expr = expr.replace(rattributeQuotes, '=\'$1\']');
            if (support.matchesSelector && documentIsHTML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
                try {
                    var ret = matches.call(elem, expr);
                    if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
                        return ret;
                    }
                } catch (e) {
                }
            }
            return Sizzle(expr, document, null, [elem]).length > 0;
        };
        Sizzle.contains = function (context, elem) {
            if ((context.ownerDocument || context) !== document) {
                setDocument(context);
            }
            return contains(context, elem);
        };
        Sizzle.attr = function (elem, name) {
            if ((elem.ownerDocument || elem) !== document) {
                setDocument(elem);
            }
            var fn = Expr.attrHandle[name.toLowerCase()], val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
            return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        };
        Sizzle.error = function (msg) {
            throw new Error('Syntax error, unrecognized expression: ' + msg);
        };
        Sizzle.uniqueSort = function (results) {
            var elem, duplicates = [], j = 0, i = 0;
            hasDuplicate = !support.detectDuplicates;
            sortInput = !support.sortStable && results.slice(0);
            results.sort(sortOrder);
            if (hasDuplicate) {
                while (elem = results[i++]) {
                    if (elem === results[i]) {
                        j = duplicates.push(i);
                    }
                }
                while (j--) {
                    results.splice(duplicates[j], 1);
                }
            }
            sortInput = null;
            return results;
        };
        getText = Sizzle.getText = function (elem) {
            var node, ret = '', i = 0, nodeType = elem.nodeType;
            if (!nodeType) {
                while (node = elem[i++]) {
                    ret += getText(node);
                }
            } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
                if (typeof elem.textContent === 'string') {
                    return elem.textContent;
                } else {
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                        ret += getText(elem);
                    }
                }
            } else if (nodeType === 3 || nodeType === 4) {
                return elem.nodeValue;
            }
            return ret;
        };
        Expr = Sizzle.selectors = {
            cacheLength: 50,
            createPseudo: markFunction,
            match: matchExpr,
            attrHandle: {},
            find: {},
            relative: {
                '>': {
                    dir: 'parentNode',
                    first: true
                },
                ' ': { dir: 'parentNode' },
                '+': {
                    dir: 'previousSibling',
                    first: true
                },
                '~': { dir: 'previousSibling' }
            },
            preFilter: {
                'ATTR': function (match) {
                    match[1] = match[1].replace(runescape, funescape);
                    match[3] = (match[4] || match[5] || '').replace(runescape, funescape);
                    if (match[2] === '~=') {
                        match[3] = ' ' + match[3] + ' ';
                    }
                    return match.slice(0, 4);
                },
                'CHILD': function (match) {
                    match[1] = match[1].toLowerCase();
                    if (match[1].slice(0, 3) === 'nth') {
                        if (!match[3]) {
                            Sizzle.error(match[0]);
                        }
                        match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === 'even' || match[3] === 'odd'));
                        match[5] = +(match[7] + match[8] || match[3] === 'odd');
                    } else if (match[3]) {
                        Sizzle.error(match[0]);
                    }
                    return match;
                },
                'PSEUDO': function (match) {
                    var excess, unquoted = !match[5] && match[2];
                    if (matchExpr['CHILD'].test(match[0])) {
                        return null;
                    }
                    if (match[3] && match[4] !== undefined) {
                        match[2] = match[4];
                    } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(')', unquoted.length - excess) - unquoted.length)) {
                        match[0] = match[0].slice(0, excess);
                        match[2] = unquoted.slice(0, excess);
                    }
                    return match.slice(0, 3);
                }
            },
            filter: {
                'TAG': function (nodeNameSelector) {
                    var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                    return nodeNameSelector === '*' ? function () {
                        return true;
                    } : function (elem) {
                        return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                    };
                },
                'CLASS': function (className) {
                    var pattern = classCache[className + ' '];
                    return pattern || (pattern = new RegExp('(^|' + whitespace + ')' + className + '(' + whitespace + '|$)')) && classCache(className, function (elem) {
                        return pattern.test(typeof elem.className === 'string' && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute('class') || '');
                    });
                },
                'ATTR': function (name, operator, check) {
                    return function (elem) {
                        var result = Sizzle.attr(elem, name);
                        if (result == null) {
                            return operator === '!=';
                        }
                        if (!operator) {
                            return true;
                        }
                        result += '';
                        return operator === '=' ? result === check : operator === '!=' ? result !== check : operator === '^=' ? check && result.indexOf(check) === 0 : operator === '*=' ? check && result.indexOf(check) > -1 : operator === '$=' ? check && result.slice(-check.length) === check : operator === '~=' ? (' ' + result + ' ').indexOf(check) > -1 : operator === '|=' ? result === check || result.slice(0, check.length + 1) === check + '-' : false;
                    };
                },
                'CHILD': function (type, what, argument, first, last) {
                    var simple = type.slice(0, 3) !== 'nth', forward = type.slice(-4) !== 'last', ofType = what === 'of-type';
                    return first === 1 && last === 0 ? function (elem) {
                        return !!elem.parentNode;
                    } : function (elem, context, xml) {
                        var cache, outerCache, node, diff, nodeIndex, start, dir = simple !== forward ? 'nextSibling' : 'previousSibling', parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType;
                        if (parent) {
                            if (simple) {
                                while (dir) {
                                    node = elem;
                                    while (node = node[dir]) {
                                        if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                                            return false;
                                        }
                                    }
                                    start = dir = type === 'only' && !start && 'nextSibling';
                                }
                                return true;
                            }
                            start = [forward ? parent.firstChild : parent.lastChild];
                            if (forward && useCache) {
                                outerCache = parent[expando] || (parent[expando] = {});
                                cache = outerCache[type] || [];
                                nodeIndex = cache[0] === dirruns && cache[1];
                                diff = cache[0] === dirruns && cache[2];
                                node = nodeIndex && parent.childNodes[nodeIndex];
                                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                                    if (node.nodeType === 1 && ++diff && node === elem) {
                                        outerCache[type] = [
                                            dirruns,
                                            nodeIndex,
                                            diff
                                        ];
                                        break;
                                    }
                                }
                            } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) {
                                diff = cache[1];
                            } else {
                                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                                    if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                                        if (useCache) {
                                            (node[expando] || (node[expando] = {}))[type] = [
                                                dirruns,
                                                diff
                                            ];
                                        }
                                        if (node === elem) {
                                            break;
                                        }
                                    }
                                }
                            }
                            diff -= last;
                            return diff === first || diff % first === 0 && diff / first >= 0;
                        }
                    };
                },
                'PSEUDO': function (pseudo, argument) {
                    var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error('unsupported pseudo: ' + pseudo);
                    if (fn[expando]) {
                        return fn(argument);
                    }
                    if (fn.length > 1) {
                        args = [
                            pseudo,
                            pseudo,
                            '',
                            argument
                        ];
                        return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
                            var idx, matched = fn(seed, argument), i = matched.length;
                            while (i--) {
                                idx = indexOf.call(seed, matched[i]);
                                seed[idx] = !(matches[idx] = matched[i]);
                            }
                        }) : function (elem) {
                            return fn(elem, 0, args);
                        };
                    }
                    return fn;
                }
            },
            pseudos: {
                'not': markFunction(function (selector) {
                    var input = [], results = [], matcher = compile(selector.replace(rtrim, '$1'));
                    return matcher[expando] ? markFunction(function (seed, matches, context, xml) {
                        var elem, unmatched = matcher(seed, null, xml, []), i = seed.length;
                        while (i--) {
                            if (elem = unmatched[i]) {
                                seed[i] = !(matches[i] = elem);
                            }
                        }
                    }) : function (elem, context, xml) {
                        input[0] = elem;
                        matcher(input, null, xml, results);
                        return !results.pop();
                    };
                }),
                'has': markFunction(function (selector) {
                    return function (elem) {
                        return Sizzle(selector, elem).length > 0;
                    };
                }),
                'contains': markFunction(function (text) {
                    return function (elem) {
                        return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
                    };
                }),
                'lang': markFunction(function (lang) {
                    if (!ridentifier.test(lang || '')) {
                        Sizzle.error('unsupported lang: ' + lang);
                    }
                    lang = lang.replace(runescape, funescape).toLowerCase();
                    return function (elem) {
                        var elemLang;
                        do {
                            if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute('xml:lang') || elem.getAttribute('lang')) {
                                elemLang = elemLang.toLowerCase();
                                return elemLang === lang || elemLang.indexOf(lang + '-') === 0;
                            }
                        } while ((elem = elem.parentNode) && elem.nodeType === 1);
                        return false;
                    };
                }),
                'target': function (elem) {
                    var hash = window.location && window.location.hash;
                    return hash && hash.slice(1) === elem.id;
                },
                'root': function (elem) {
                    return elem === docElem;
                },
                'focus': function (elem) {
                    return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                },
                'enabled': function (elem) {
                    return elem.disabled === false;
                },
                'disabled': function (elem) {
                    return elem.disabled === true;
                },
                'checked': function (elem) {
                    var nodeName = elem.nodeName.toLowerCase();
                    return nodeName === 'input' && !!elem.checked || nodeName === 'option' && !!elem.selected;
                },
                'selected': function (elem) {
                    if (elem.parentNode) {
                        elem.parentNode.selectedIndex;
                    }
                    return elem.selected === true;
                },
                'empty': function (elem) {
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                        if (elem.nodeType < 6) {
                            return false;
                        }
                    }
                    return true;
                },
                'parent': function (elem) {
                    return !Expr.pseudos['empty'](elem);
                },
                'header': function (elem) {
                    return rheader.test(elem.nodeName);
                },
                'input': function (elem) {
                    return rinputs.test(elem.nodeName);
                },
                'button': function (elem) {
                    var name = elem.nodeName.toLowerCase();
                    return name === 'input' && elem.type === 'button' || name === 'button';
                },
                'text': function (elem) {
                    var attr;
                    return elem.nodeName.toLowerCase() === 'input' && elem.type === 'text' && ((attr = elem.getAttribute('type')) == null || attr.toLowerCase() === 'text');
                },
                'first': createPositionalPseudo(function () {
                    return [0];
                }),
                'last': createPositionalPseudo(function (matchIndexes, length) {
                    return [length - 1];
                }),
                'eq': createPositionalPseudo(function (matchIndexes, length, argument) {
                    return [argument < 0 ? argument + length : argument];
                }),
                'even': createPositionalPseudo(function (matchIndexes, length) {
                    var i = 0;
                    for (; i < length; i += 2) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),
                'odd': createPositionalPseudo(function (matchIndexes, length) {
                    var i = 1;
                    for (; i < length; i += 2) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),
                'lt': createPositionalPseudo(function (matchIndexes, length, argument) {
                    var i = argument < 0 ? argument + length : argument;
                    for (; --i >= 0;) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),
                'gt': createPositionalPseudo(function (matchIndexes, length, argument) {
                    var i = argument < 0 ? argument + length : argument;
                    for (; ++i < length;) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                })
            }
        };
        Expr.pseudos['nth'] = Expr.pseudos['eq'];
        for (i in {
                radio: true,
                checkbox: true,
                file: true,
                password: true,
                image: true
            }) {
            Expr.pseudos[i] = createInputPseudo(i);
        }
        for (i in {
                submit: true,
                reset: true
            }) {
            Expr.pseudos[i] = createButtonPseudo(i);
        }
        function setFilters() {
        }
        setFilters.prototype = Expr.filters = Expr.pseudos;
        Expr.setFilters = new setFilters();
        function tokenize(selector, parseOnly) {
            var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + ' '];
            if (cached) {
                return parseOnly ? 0 : cached.slice(0);
            }
            soFar = selector;
            groups = [];
            preFilters = Expr.preFilter;
            while (soFar) {
                if (!matched || (match = rcomma.exec(soFar))) {
                    if (match) {
                        soFar = soFar.slice(match[0].length) || soFar;
                    }
                    groups.push(tokens = []);
                }
                matched = false;
                if (match = rcombinators.exec(soFar)) {
                    matched = match.shift();
                    tokens.push({
                        value: matched,
                        type: match[0].replace(rtrim, ' ')
                    });
                    soFar = soFar.slice(matched.length);
                }
                for (type in Expr.filter) {
                    if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                        matched = match.shift();
                        tokens.push({
                            value: matched,
                            type: type,
                            matches: match
                        });
                        soFar = soFar.slice(matched.length);
                    }
                }
                if (!matched) {
                    break;
                }
            }
            return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
        }
        function toSelector(tokens) {
            var i = 0, len = tokens.length, selector = '';
            for (; i < len; i++) {
                selector += tokens[i].value;
            }
            return selector;
        }
        function addCombinator(matcher, combinator, base) {
            var dir = combinator.dir, checkNonElements = base && dir === 'parentNode', doneName = done++;
            return combinator.first ? function (elem, context, xml) {
                while (elem = elem[dir]) {
                    if (elem.nodeType === 1 || checkNonElements) {
                        return matcher(elem, context, xml);
                    }
                }
            } : function (elem, context, xml) {
                var oldCache, outerCache, newCache = [
                        dirruns,
                        doneName
                    ];
                if (xml) {
                    while (elem = elem[dir]) {
                        if (elem.nodeType === 1 || checkNonElements) {
                            if (matcher(elem, context, xml)) {
                                return true;
                            }
                        }
                    }
                } else {
                    while (elem = elem[dir]) {
                        if (elem.nodeType === 1 || checkNonElements) {
                            outerCache = elem[expando] || (elem[expando] = {});
                            if ((oldCache = outerCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                                return newCache[2] = oldCache[2];
                            } else {
                                outerCache[dir] = newCache;
                                if (newCache[2] = matcher(elem, context, xml)) {
                                    return true;
                                }
                            }
                        }
                    }
                }
            };
        }
        function elementMatcher(matchers) {
            return matchers.length > 1 ? function (elem, context, xml) {
                var i = matchers.length;
                while (i--) {
                    if (!matchers[i](elem, context, xml)) {
                        return false;
                    }
                }
                return true;
            } : matchers[0];
        }
        function condense(unmatched, map, filter, context, xml) {
            var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = map != null;
            for (; i < len; i++) {
                if (elem = unmatched[i]) {
                    if (!filter || filter(elem, context, xml)) {
                        newUnmatched.push(elem);
                        if (mapped) {
                            map.push(i);
                        }
                    }
                }
            }
            return newUnmatched;
        }
        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
            if (postFilter && !postFilter[expando]) {
                postFilter = setMatcher(postFilter);
            }
            if (postFinder && !postFinder[expando]) {
                postFinder = setMatcher(postFinder, postSelector);
            }
            return markFunction(function (seed, results, context, xml) {
                var temp, i, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(selector || '*', context.nodeType ? [context] : context, []), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems, matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
                if (matcher) {
                    matcher(matcherIn, matcherOut, context, xml);
                }
                if (postFilter) {
                    temp = condense(matcherOut, postMap);
                    postFilter(temp, [], context, xml);
                    i = temp.length;
                    while (i--) {
                        if (elem = temp[i]) {
                            matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
                        }
                    }
                }
                if (seed) {
                    if (postFinder || preFilter) {
                        if (postFinder) {
                            temp = [];
                            i = matcherOut.length;
                            while (i--) {
                                if (elem = matcherOut[i]) {
                                    temp.push(matcherIn[i] = elem);
                                }
                            }
                            postFinder(null, matcherOut = [], temp, xml);
                        }
                        i = matcherOut.length;
                        while (i--) {
                            if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf.call(seed, elem) : preMap[i]) > -1) {
                                seed[temp] = !(results[temp] = elem);
                            }
                        }
                    }
                } else {
                    matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
                    if (postFinder) {
                        postFinder(null, results, matcherOut, xml);
                    } else {
                        push.apply(results, matcherOut);
                    }
                }
            });
        }
        function matcherFromTokens(tokens) {
            var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[' '], i = leadingRelative ? 1 : 0, matchContext = addCombinator(function (elem) {
                    return elem === checkContext;
                }, implicitRelative, true), matchAnyContext = addCombinator(function (elem) {
                    return indexOf.call(checkContext, elem) > -1;
                }, implicitRelative, true), matchers = [function (elem, context, xml) {
                        return !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
                    }];
            for (; i < len; i++) {
                if (matcher = Expr.relative[tokens[i].type]) {
                    matchers = [addCombinator(elementMatcher(matchers), matcher)];
                } else {
                    matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
                    if (matcher[expando]) {
                        j = ++i;
                        for (; j < len; j++) {
                            if (Expr.relative[tokens[j].type]) {
                                break;
                            }
                        }
                        return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === ' ' ? '*' : '' })).replace(rtrim, '$1'), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
                    }
                    matchers.push(matcher);
                }
            }
            return elementMatcher(matchers);
        }
        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
            var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function (seed, context, xml, results, outermost) {
                    var elem, j, matcher, matchedCount = 0, i = '0', unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find['TAG']('*', outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
                    if (outermost) {
                        outermostContext = context !== document && context;
                    }
                    for (; i !== len && (elem = elems[i]) != null; i++) {
                        if (byElement && elem) {
                            j = 0;
                            while (matcher = elementMatchers[j++]) {
                                if (matcher(elem, context, xml)) {
                                    results.push(elem);
                                    break;
                                }
                            }
                            if (outermost) {
                                dirruns = dirrunsUnique;
                            }
                        }
                        if (bySet) {
                            if (elem = !matcher && elem) {
                                matchedCount--;
                            }
                            if (seed) {
                                unmatched.push(elem);
                            }
                        }
                    }
                    matchedCount += i;
                    if (bySet && i !== matchedCount) {
                        j = 0;
                        while (matcher = setMatchers[j++]) {
                            matcher(unmatched, setMatched, context, xml);
                        }
                        if (seed) {
                            if (matchedCount > 0) {
                                while (i--) {
                                    if (!(unmatched[i] || setMatched[i])) {
                                        setMatched[i] = pop.call(results);
                                    }
                                }
                            }
                            setMatched = condense(setMatched);
                        }
                        push.apply(results, setMatched);
                        if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                            Sizzle.uniqueSort(results);
                        }
                    }
                    if (outermost) {
                        dirruns = dirrunsUnique;
                        outermostContext = contextBackup;
                    }
                    return unmatched;
                };
            return bySet ? markFunction(superMatcher) : superMatcher;
        }
        compile = Sizzle.compile = function (selector, group) {
            var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + ' '];
            if (!cached) {
                if (!group) {
                    group = tokenize(selector);
                }
                i = group.length;
                while (i--) {
                    cached = matcherFromTokens(group[i]);
                    if (cached[expando]) {
                        setMatchers.push(cached);
                    } else {
                        elementMatchers.push(cached);
                    }
                }
                cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
            }
            return cached;
        };
        function multipleContexts(selector, contexts, results) {
            var i = 0, len = contexts.length;
            for (; i < len; i++) {
                Sizzle(selector, contexts[i], results);
            }
            return results;
        }
        function select(selector, context, results, seed) {
            var i, tokens, token, type, find, match = tokenize(selector);
            if (!seed) {
                if (match.length === 1) {
                    tokens = match[0] = match[0].slice(0);
                    if (tokens.length > 2 && (token = tokens[0]).type === 'ID' && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
                        context = (Expr.find['ID'](token.matches[0].replace(runescape, funescape), context) || [])[0];
                        if (!context) {
                            return results;
                        }
                        selector = selector.slice(tokens.shift().value.length);
                    }
                    i = matchExpr['needsContext'].test(selector) ? 0 : tokens.length;
                    while (i--) {
                        token = tokens[i];
                        if (Expr.relative[type = token.type]) {
                            break;
                        }
                        if (find = Expr.find[type]) {
                            if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
                                tokens.splice(i, 1);
                                selector = seed.length && toSelector(tokens);
                                if (!selector) {
                                    push.apply(results, seed);
                                    return results;
                                }
                                break;
                            }
                        }
                    }
                }
            }
            compile(selector, match)(seed, context, !documentIsHTML, results, rsibling.test(selector) && testContext(context.parentNode) || context);
            return results;
        }
        support.sortStable = expando.split('').sort(sortOrder).join('') === expando;
        support.detectDuplicates = !!hasDuplicate;
        setDocument();
        support.sortDetached = assert(function (div1) {
            return div1.compareDocumentPosition(document.createElement('div')) & 1;
        });
        if (!assert(function (div) {
                div.innerHTML = '<a href=\'#\'></a>';
                return div.firstChild.getAttribute('href') === '#';
            })) {
            addHandle('type|href|height|width', function (elem, name, isXML) {
                if (!isXML) {
                    return elem.getAttribute(name, name.toLowerCase() === 'type' ? 1 : 2);
                }
            });
        }
        if (!support.attributes || !assert(function (div) {
                div.innerHTML = '<input/>';
                div.firstChild.setAttribute('value', '');
                return div.firstChild.getAttribute('value') === '';
            })) {
            addHandle('value', function (elem, name, isXML) {
                if (!isXML && elem.nodeName.toLowerCase() === 'input') {
                    return elem.defaultValue;
                }
            });
        }
        if (!assert(function (div) {
                return div.getAttribute('disabled') == null;
            })) {
            addHandle(booleans, function (elem, name, isXML) {
                var val;
                if (!isXML) {
                    return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
                }
            });
        }
        return Sizzle;
    }(window);
    jQuery.find = Sizzle;
    jQuery.expr = Sizzle.selectors;
    jQuery.expr[':'] = jQuery.expr.pseudos;
    jQuery.unique = Sizzle.uniqueSort;
    jQuery.text = Sizzle.getText;
    jQuery.isXMLDoc = Sizzle.isXML;
    jQuery.contains = Sizzle.contains;
    var rneedsContext = jQuery.expr.match.needsContext;
    var rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/;
    var risSimple = /^.[^:#\[\.,]*$/;
    function winnow(elements, qualifier, not) {
        if (jQuery.isFunction(qualifier)) {
            return jQuery.grep(elements, function (elem, i) {
                return !!qualifier.call(elem, i, elem) !== not;
            });
        }
        if (qualifier.nodeType) {
            return jQuery.grep(elements, function (elem) {
                return elem === qualifier !== not;
            });
        }
        if (typeof qualifier === 'string') {
            if (risSimple.test(qualifier)) {
                return jQuery.filter(qualifier, elements, not);
            }
            qualifier = jQuery.filter(qualifier, elements);
        }
        return jQuery.grep(elements, function (elem) {
            return jQuery.inArray(elem, qualifier) >= 0 !== not;
        });
    }
    jQuery.filter = function (expr, elems, not) {
        var elem = elems[0];
        if (not) {
            expr = ':not(' + expr + ')';
        }
        return elems.length === 1 && elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
            return elem.nodeType === 1;
        }));
    };
    jQuery.fn.extend({
        find: function (selector) {
            var i, ret = [], self = this, len = self.length;
            if (typeof selector !== 'string') {
                return this.pushStack(jQuery(selector).filter(function () {
                    for (i = 0; i < len; i++) {
                        if (jQuery.contains(self[i], this)) {
                            return true;
                        }
                    }
                }));
            }
            for (i = 0; i < len; i++) {
                jQuery.find(selector, self[i], ret);
            }
            ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
            ret.selector = this.selector ? this.selector + ' ' + selector : selector;
            return ret;
        },
        filter: function (selector) {
            return this.pushStack(winnow(this, selector || [], false));
        },
        not: function (selector) {
            return this.pushStack(winnow(this, selector || [], true));
        },
        is: function (selector) {
            return !!winnow(this, typeof selector === 'string' && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
        }
    });
    var rootjQuery, document = window.document, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/, init = jQuery.fn.init = function (selector, context) {
            var match, elem;
            if (!selector) {
                return this;
            }
            if (typeof selector === 'string') {
                if (selector.charAt(0) === '<' && selector.charAt(selector.length - 1) === '>' && selector.length >= 3) {
                    match = [
                        null,
                        selector,
                        null
                    ];
                } else {
                    match = rquickExpr.exec(selector);
                }
                if (match && (match[1] || !context)) {
                    if (match[1]) {
                        context = context instanceof jQuery ? context[0] : context;
                        jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));
                        if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                            for (match in context) {
                                if (jQuery.isFunction(this[match])) {
                                    this[match](context[match]);
                                } else {
                                    this.attr(match, context[match]);
                                }
                            }
                        }
                        return this;
                    } else {
                        elem = document.getElementById(match[2]);
                        if (elem && elem.parentNode) {
                            if (elem.id !== match[2]) {
                                return rootjQuery.find(selector);
                            }
                            this.length = 1;
                            this[0] = elem;
                        }
                        this.context = document;
                        this.selector = selector;
                        return this;
                    }
                } else if (!context || context.jquery) {
                    return (context || rootjQuery).find(selector);
                } else {
                    return this.constructor(context).find(selector);
                }
            } else if (selector.nodeType) {
                this.context = this[0] = selector;
                this.length = 1;
                return this;
            } else if (jQuery.isFunction(selector)) {
                return typeof rootjQuery.ready !== 'undefined' ? rootjQuery.ready(selector) : selector(jQuery);
            }
            if (selector.selector !== undefined) {
                this.selector = selector.selector;
                this.context = selector.context;
            }
            return jQuery.makeArray(selector, this);
        };
    init.prototype = jQuery.fn;
    rootjQuery = jQuery(document);
    var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
            children: true,
            contents: true,
            next: true,
            prev: true
        };
    jQuery.extend({
        dir: function (elem, dir, until) {
            var matched = [], cur = elem[dir];
            while (cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery(cur).is(until))) {
                if (cur.nodeType === 1) {
                    matched.push(cur);
                }
                cur = cur[dir];
            }
            return matched;
        },
        sibling: function (n, elem) {
            var r = [];
            for (; n; n = n.nextSibling) {
                if (n.nodeType === 1 && n !== elem) {
                    r.push(n);
                }
            }
            return r;
        }
    });
    jQuery.fn.extend({
        has: function (target) {
            var i, targets = jQuery(target, this), len = targets.length;
            return this.filter(function () {
                for (i = 0; i < len; i++) {
                    if (jQuery.contains(this, targets[i])) {
                        return true;
                    }
                }
            });
        },
        closest: function (selectors, context) {
            var cur, i = 0, l = this.length, matched = [], pos = rneedsContext.test(selectors) || typeof selectors !== 'string' ? jQuery(selectors, context || this.context) : 0;
            for (; i < l; i++) {
                for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
                    if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 : cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
                        matched.push(cur);
                        break;
                    }
                }
            }
            return this.pushStack(matched.length > 1 ? jQuery.unique(matched) : matched);
        },
        index: function (elem) {
            if (!elem) {
                return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
            }
            if (typeof elem === 'string') {
                return jQuery.inArray(this[0], jQuery(elem));
            }
            return jQuery.inArray(elem.jquery ? elem[0] : elem, this);
        },
        add: function (selector, context) {
            return this.pushStack(jQuery.unique(jQuery.merge(this.get(), jQuery(selector, context))));
        },
        addBack: function (selector) {
            return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
        }
    });
    function sibling(cur, dir) {
        do {
            cur = cur[dir];
        } while (cur && cur.nodeType !== 1);
        return cur;
    }
    jQuery.each({
        parent: function (elem) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function (elem) {
            return jQuery.dir(elem, 'parentNode');
        },
        parentsUntil: function (elem, i, until) {
            return jQuery.dir(elem, 'parentNode', until);
        },
        next: function (elem) {
            return sibling(elem, 'nextSibling');
        },
        prev: function (elem) {
            return sibling(elem, 'previousSibling');
        },
        nextAll: function (elem) {
            return jQuery.dir(elem, 'nextSibling');
        },
        prevAll: function (elem) {
            return jQuery.dir(elem, 'previousSibling');
        },
        nextUntil: function (elem, i, until) {
            return jQuery.dir(elem, 'nextSibling', until);
        },
        prevUntil: function (elem, i, until) {
            return jQuery.dir(elem, 'previousSibling', until);
        },
        siblings: function (elem) {
            return jQuery.sibling((elem.parentNode || {}).firstChild, elem);
        },
        children: function (elem) {
            return jQuery.sibling(elem.firstChild);
        },
        contents: function (elem) {
            return jQuery.nodeName(elem, 'iframe') ? elem.contentDocument || elem.contentWindow.document : jQuery.merge([], elem.childNodes);
        }
    }, function (name, fn) {
        jQuery.fn[name] = function (until, selector) {
            var ret = jQuery.map(this, fn, until);
            if (name.slice(-5) !== 'Until') {
                selector = until;
            }
            if (selector && typeof selector === 'string') {
                ret = jQuery.filter(selector, ret);
            }
            if (this.length > 1) {
                if (!guaranteedUnique[name]) {
                    ret = jQuery.unique(ret);
                }
                if (rparentsprev.test(name)) {
                    ret = ret.reverse();
                }
            }
            return this.pushStack(ret);
        };
    });
    var rnotwhite = /\S+/g;
    var optionsCache = {};
    function createOptions(options) {
        var object = optionsCache[options] = {};
        jQuery.each(options.match(rnotwhite) || [], function (_, flag) {
            object[flag] = true;
        });
        return object;
    }
    jQuery.Callbacks = function (options) {
        options = typeof options === 'string' ? optionsCache[options] || createOptions(options) : jQuery.extend({}, options);
        var firing, memory, fired, firingLength, firingIndex, firingStart, list = [], stack = !options.once && [], fire = function (data) {
                memory = options.memory && data;
                fired = true;
                firingIndex = firingStart || 0;
                firingStart = 0;
                firingLength = list.length;
                firing = true;
                for (; list && firingIndex < firingLength; firingIndex++) {
                    if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {
                        memory = false;
                        break;
                    }
                }
                firing = false;
                if (list) {
                    if (stack) {
                        if (stack.length) {
                            fire(stack.shift());
                        }
                    } else if (memory) {
                        list = [];
                    } else {
                        self.disable();
                    }
                }
            }, self = {
                add: function () {
                    if (list) {
                        var start = list.length;
                        (function add(args) {
                            jQuery.each(args, function (_, arg) {
                                var type = jQuery.type(arg);
                                if (type === 'function') {
                                    if (!options.unique || !self.has(arg)) {
                                        list.push(arg);
                                    }
                                } else if (arg && arg.length && type !== 'string') {
                                    add(arg);
                                }
                            });
                        }(arguments));
                        if (firing) {
                            firingLength = list.length;
                        } else if (memory) {
                            firingStart = start;
                            fire(memory);
                        }
                    }
                    return this;
                },
                remove: function () {
                    if (list) {
                        jQuery.each(arguments, function (_, arg) {
                            var index;
                            while ((index = jQuery.inArray(arg, list, index)) > -1) {
                                list.splice(index, 1);
                                if (firing) {
                                    if (index <= firingLength) {
                                        firingLength--;
                                    }
                                    if (index <= firingIndex) {
                                        firingIndex--;
                                    }
                                }
                            }
                        });
                    }
                    return this;
                },
                has: function (fn) {
                    return fn ? jQuery.inArray(fn, list) > -1 : !!(list && list.length);
                },
                empty: function () {
                    list = [];
                    firingLength = 0;
                    return this;
                },
                disable: function () {
                    list = stack = memory = undefined;
                    return this;
                },
                disabled: function () {
                    return !list;
                },
                lock: function () {
                    stack = undefined;
                    if (!memory) {
                        self.disable();
                    }
                    return this;
                },
                locked: function () {
                    return !stack;
                },
                fireWith: function (context, args) {
                    if (list && (!fired || stack)) {
                        args = args || [];
                        args = [
                            context,
                            args.slice ? args.slice() : args
                        ];
                        if (firing) {
                            stack.push(args);
                        } else {
                            fire(args);
                        }
                    }
                    return this;
                },
                fire: function () {
                    self.fireWith(this, arguments);
                    return this;
                },
                fired: function () {
                    return !!fired;
                }
            };
        return self;
    };
    jQuery.extend({
        Deferred: function (func) {
            var tuples = [
                    [
                        'resolve',
                        'done',
                        jQuery.Callbacks('once memory'),
                        'resolved'
                    ],
                    [
                        'reject',
                        'fail',
                        jQuery.Callbacks('once memory'),
                        'rejected'
                    ],
                    [
                        'notify',
                        'progress',
                        jQuery.Callbacks('memory')
                    ]
                ], state = 'pending', promise = {
                    state: function () {
                        return state;
                    },
                    always: function () {
                        deferred.done(arguments).fail(arguments);
                        return this;
                    },
                    then: function () {
                        var fns = arguments;
                        return jQuery.Deferred(function (newDefer) {
                            jQuery.each(tuples, function (i, tuple) {
                                var fn = jQuery.isFunction(fns[i]) && fns[i];
                                deferred[tuple[1]](function () {
                                    var returned = fn && fn.apply(this, arguments);
                                    if (returned && jQuery.isFunction(returned.promise)) {
                                        returned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify);
                                    } else {
                                        newDefer[tuple[0] + 'With'](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments);
                                    }
                                });
                            });
                            fns = null;
                        }).promise();
                    },
                    promise: function (obj) {
                        return obj != null ? jQuery.extend(obj, promise) : promise;
                    }
                }, deferred = {};
            promise.pipe = promise.then;
            jQuery.each(tuples, function (i, tuple) {
                var list = tuple[2], stateString = tuple[3];
                promise[tuple[1]] = list.add;
                if (stateString) {
                    list.add(function () {
                        state = stateString;
                    }, tuples[i ^ 1][2].disable, tuples[2][2].lock);
                }
                deferred[tuple[0]] = function () {
                    deferred[tuple[0] + 'With'](this === deferred ? promise : this, arguments);
                    return this;
                };
                deferred[tuple[0] + 'With'] = list.fireWith;
            });
            promise.promise(deferred);
            if (func) {
                func.call(deferred, deferred);
            }
            return deferred;
        },
        when: function (subordinate) {
            var i = 0, resolveValues = slice.call(arguments), length = resolveValues.length, remaining = length !== 1 || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0, deferred = remaining === 1 ? subordinate : jQuery.Deferred(), updateFunc = function (i, contexts, values) {
                    return function (value) {
                        contexts[i] = this;
                        values[i] = arguments.length > 1 ? slice.call(arguments) : value;
                        if (values === progressValues) {
                            deferred.notifyWith(contexts, values);
                        } else if (!--remaining) {
                            deferred.resolveWith(contexts, values);
                        }
                    };
                }, progressValues, progressContexts, resolveContexts;
            if (length > 1) {
                progressValues = new Array(length);
                progressContexts = new Array(length);
                resolveContexts = new Array(length);
                for (; i < length; i++) {
                    if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
                        resolveValues[i].promise().done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFunc(i, progressContexts, progressValues));
                    } else {
                        --remaining;
                    }
                }
            }
            if (!remaining) {
                deferred.resolveWith(resolveContexts, resolveValues);
            }
            return deferred.promise();
        }
    });
    var readyList;
    jQuery.fn.ready = function (fn) {
        jQuery.ready.promise().done(fn);
        return this;
    };
    jQuery.extend({
        isReady: false,
        readyWait: 1,
        holdReady: function (hold) {
            if (hold) {
                jQuery.readyWait++;
            } else {
                jQuery.ready(true);
            }
        },
        ready: function (wait) {
            if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
                return;
            }
            if (!document.body) {
                return setTimeout(jQuery.ready);
            }
            jQuery.isReady = true;
            if (wait !== true && --jQuery.readyWait > 0) {
                return;
            }
            readyList.resolveWith(document, [jQuery]);
            if (jQuery.fn.trigger) {
                jQuery(document).trigger('ready').off('ready');
            }
        }
    });
    function detach() {
        if (document.addEventListener) {
            document.removeEventListener('DOMContentLoaded', completed, false);
            window.removeEventListener('load', completed, false);
        } else {
            document.detachEvent('onreadystatechange', completed);
            window.detachEvent('onload', completed);
        }
    }
    function completed() {
        if (document.addEventListener || event.type === 'load' || document.readyState === 'complete') {
            detach();
            jQuery.ready();
        }
    }
    jQuery.ready.promise = function (obj) {
        if (!readyList) {
            readyList = jQuery.Deferred();
            if (document.readyState === 'complete') {
                setTimeout(jQuery.ready);
            } else if (document.addEventListener) {
                document.addEventListener('DOMContentLoaded', completed, false);
                window.addEventListener('load', completed, false);
            } else {
                document.attachEvent('onreadystatechange', completed);
                window.attachEvent('onload', completed);
                var top = false;
                try {
                    top = window.frameElement == null && document.documentElement;
                } catch (e) {
                }
                if (top && top.doScroll) {
                    (function doScrollCheck() {
                        if (!jQuery.isReady) {
                            try {
                                top.doScroll('left');
                            } catch (e) {
                                return setTimeout(doScrollCheck, 50);
                            }
                            detach();
                            jQuery.ready();
                        }
                    }());
                }
            }
        }
        return readyList.promise(obj);
    };
    var strundefined = typeof undefined;
    var i;
    for (i in jQuery(support)) {
        break;
    }
    support.ownLast = i !== '0';
    support.inlineBlockNeedsLayout = false;
    jQuery(function () {
        var container, div, body = document.getElementsByTagName('body')[0];
        if (!body) {
            return;
        }
        container = document.createElement('div');
        container.style.cssText = 'border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px';
        div = document.createElement('div');
        body.appendChild(container).appendChild(div);
        if (typeof div.style.zoom !== strundefined) {
            div.style.cssText = 'border:0;margin:0;width:1px;padding:1px;display:inline;zoom:1';
            if (support.inlineBlockNeedsLayout = div.offsetWidth === 3) {
                body.style.zoom = 1;
            }
        }
        body.removeChild(container);
        container = div = null;
    });
    (function () {
        var div = document.createElement('div');
        if (support.deleteExpando == null) {
            support.deleteExpando = true;
            try {
                delete div.test;
            } catch (e) {
                support.deleteExpando = false;
            }
        }
        div = null;
    }());
    jQuery.acceptData = function (elem) {
        var noData = jQuery.noData[(elem.nodeName + ' ').toLowerCase()], nodeType = +elem.nodeType || 1;
        return nodeType !== 1 && nodeType !== 9 ? false : !noData || noData !== true && elem.getAttribute('classid') === noData;
    };
    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /([A-Z])/g;
    function dataAttr(elem, key, data) {
        if (data === undefined && elem.nodeType === 1) {
            var name = 'data-' + key.replace(rmultiDash, '-$1').toLowerCase();
            data = elem.getAttribute(name);
            if (typeof data === 'string') {
                try {
                    data = data === 'true' ? true : data === 'false' ? false : data === 'null' ? null : +data + '' === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data;
                } catch (e) {
                }
                jQuery.data(elem, key, data);
            } else {
                data = undefined;
            }
        }
        return data;
    }
    function isEmptyDataObject(obj) {
        var name;
        for (name in obj) {
            if (name === 'data' && jQuery.isEmptyObject(obj[name])) {
                continue;
            }
            if (name !== 'toJSON') {
                return false;
            }
        }
        return true;
    }
    function internalData(elem, name, data, pvt) {
        if (!jQuery.acceptData(elem)) {
            return;
        }
        var ret, thisCache, internalKey = jQuery.expando, isNode = elem.nodeType, cache = isNode ? jQuery.cache : elem, id = isNode ? elem[internalKey] : elem[internalKey] && internalKey;
        if ((!id || !cache[id] || !pvt && !cache[id].data) && data === undefined && typeof name === 'string') {
            return;
        }
        if (!id) {
            if (isNode) {
                id = elem[internalKey] = deletedIds.pop() || jQuery.guid++;
            } else {
                id = internalKey;
            }
        }
        if (!cache[id]) {
            cache[id] = isNode ? {} : { toJSON: jQuery.noop };
        }
        if (typeof name === 'object' || typeof name === 'function') {
            if (pvt) {
                cache[id] = jQuery.extend(cache[id], name);
            } else {
                cache[id].data = jQuery.extend(cache[id].data, name);
            }
        }
        thisCache = cache[id];
        if (!pvt) {
            if (!thisCache.data) {
                thisCache.data = {};
            }
            thisCache = thisCache.data;
        }
        if (data !== undefined) {
            thisCache[jQuery.camelCase(name)] = data;
        }
        if (typeof name === 'string') {
            ret = thisCache[name];
            if (ret == null) {
                ret = thisCache[jQuery.camelCase(name)];
            }
        } else {
            ret = thisCache;
        }
        return ret;
    }
    function internalRemoveData(elem, name, pvt) {
        if (!jQuery.acceptData(elem)) {
            return;
        }
        var thisCache, i, isNode = elem.nodeType, cache = isNode ? jQuery.cache : elem, id = isNode ? elem[jQuery.expando] : jQuery.expando;
        if (!cache[id]) {
            return;
        }
        if (name) {
            thisCache = pvt ? cache[id] : cache[id].data;
            if (thisCache) {
                if (!jQuery.isArray(name)) {
                    if (name in thisCache) {
                        name = [name];
                    } else {
                        name = jQuery.camelCase(name);
                        if (name in thisCache) {
                            name = [name];
                        } else {
                            name = name.split(' ');
                        }
                    }
                } else {
                    name = name.concat(jQuery.map(name, jQuery.camelCase));
                }
                i = name.length;
                while (i--) {
                    delete thisCache[name[i]];
                }
                if (pvt ? !isEmptyDataObject(thisCache) : !jQuery.isEmptyObject(thisCache)) {
                    return;
                }
            }
        }
        if (!pvt) {
            delete cache[id].data;
            if (!isEmptyDataObject(cache[id])) {
                return;
            }
        }
        if (isNode) {
            jQuery.cleanData([elem], true);
        } else if (support.deleteExpando || cache != cache.window) {
            delete cache[id];
        } else {
            cache[id] = null;
        }
    }
    jQuery.extend({
        cache: {},
        noData: {
            'applet ': true,
            'embed ': true,
            'object ': 'clsid:D27CDB6E-AE6D-11cf-96B8-444553540000'
        },
        hasData: function (elem) {
            elem = elem.nodeType ? jQuery.cache[elem[jQuery.expando]] : elem[jQuery.expando];
            return !!elem && !isEmptyDataObject(elem);
        },
        data: function (elem, name, data) {
            return internalData(elem, name, data);
        },
        removeData: function (elem, name) {
            return internalRemoveData(elem, name);
        },
        _data: function (elem, name, data) {
            return internalData(elem, name, data, true);
        },
        _removeData: function (elem, name) {
            return internalRemoveData(elem, name, true);
        }
    });
    jQuery.fn.extend({
        data: function (key, value) {
            var i, name, data, elem = this[0], attrs = elem && elem.attributes;
            if (key === undefined) {
                if (this.length) {
                    data = jQuery.data(elem);
                    if (elem.nodeType === 1 && !jQuery._data(elem, 'parsedAttrs')) {
                        i = attrs.length;
                        while (i--) {
                            name = attrs[i].name;
                            if (name.indexOf('data-') === 0) {
                                name = jQuery.camelCase(name.slice(5));
                                dataAttr(elem, name, data[name]);
                            }
                        }
                        jQuery._data(elem, 'parsedAttrs', true);
                    }
                }
                return data;
            }
            if (typeof key === 'object') {
                return this.each(function () {
                    jQuery.data(this, key);
                });
            }
            return arguments.length > 1 ? this.each(function () {
                jQuery.data(this, key, value);
            }) : elem ? dataAttr(elem, key, jQuery.data(elem, key)) : undefined;
        },
        removeData: function (key) {
            return this.each(function () {
                jQuery.removeData(this, key);
            });
        }
    });
    jQuery.extend({
        queue: function (elem, type, data) {
            var queue;
            if (elem) {
                type = (type || 'fx') + 'queue';
                queue = jQuery._data(elem, type);
                if (data) {
                    if (!queue || jQuery.isArray(data)) {
                        queue = jQuery._data(elem, type, jQuery.makeArray(data));
                    } else {
                        queue.push(data);
                    }
                }
                return queue || [];
            }
        },
        dequeue: function (elem, type) {
            type = type || 'fx';
            var queue = jQuery.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem, type), next = function () {
                    jQuery.dequeue(elem, type);
                };
            if (fn === 'inprogress') {
                fn = queue.shift();
                startLength--;
            }
            if (fn) {
                if (type === 'fx') {
                    queue.unshift('inprogress');
                }
                delete hooks.stop;
                fn.call(elem, next, hooks);
            }
            if (!startLength && hooks) {
                hooks.empty.fire();
            }
        },
        _queueHooks: function (elem, type) {
            var key = type + 'queueHooks';
            return jQuery._data(elem, key) || jQuery._data(elem, key, {
                empty: jQuery.Callbacks('once memory').add(function () {
                    jQuery._removeData(elem, type + 'queue');
                    jQuery._removeData(elem, key);
                })
            });
        }
    });
    jQuery.fn.extend({
        queue: function (type, data) {
            var setter = 2;
            if (typeof type !== 'string') {
                data = type;
                type = 'fx';
                setter--;
            }
            if (arguments.length < setter) {
                return jQuery.queue(this[0], type);
            }
            return data === undefined ? this : this.each(function () {
                var queue = jQuery.queue(this, type, data);
                jQuery._queueHooks(this, type);
                if (type === 'fx' && queue[0] !== 'inprogress') {
                    jQuery.dequeue(this, type);
                }
            });
        },
        dequeue: function (type) {
            return this.each(function () {
                jQuery.dequeue(this, type);
            });
        },
        clearQueue: function (type) {
            return this.queue(type || 'fx', []);
        },
        promise: function (type, obj) {
            var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function () {
                    if (!--count) {
                        defer.resolveWith(elements, [elements]);
                    }
                };
            if (typeof type !== 'string') {
                obj = type;
                type = undefined;
            }
            type = type || 'fx';
            while (i--) {
                tmp = jQuery._data(elements[i], type + 'queueHooks');
                if (tmp && tmp.empty) {
                    count++;
                    tmp.empty.add(resolve);
                }
            }
            resolve();
            return defer.promise(obj);
        }
    });
    var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
    var cssExpand = [
        'Top',
        'Right',
        'Bottom',
        'Left'
    ];
    var isHidden = function (elem, el) {
        elem = el || elem;
        return jQuery.css(elem, 'display') === 'none' || !jQuery.contains(elem.ownerDocument, elem);
    };
    var access = jQuery.access = function (elems, fn, key, value, chainable, emptyGet, raw) {
        var i = 0, length = elems.length, bulk = key == null;
        if (jQuery.type(key) === 'object') {
            chainable = true;
            for (i in key) {
                jQuery.access(elems, fn, i, key[i], true, emptyGet, raw);
            }
        } else if (value !== undefined) {
            chainable = true;
            if (!jQuery.isFunction(value)) {
                raw = true;
            }
            if (bulk) {
                if (raw) {
                    fn.call(elems, value);
                    fn = null;
                } else {
                    bulk = fn;
                    fn = function (elem, key, value) {
                        return bulk.call(jQuery(elem), value);
                    };
                }
            }
            if (fn) {
                for (; i < length; i++) {
                    fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
                }
            }
        }
        return chainable ? elems : bulk ? fn.call(elems) : length ? fn(elems[0], key) : emptyGet;
    };
    var rcheckableType = /^(?:checkbox|radio)$/i;
    (function () {
        var fragment = document.createDocumentFragment(), div = document.createElement('div'), input = document.createElement('input');
        div.setAttribute('className', 't');
        div.innerHTML = '  <link/><table></table><a href=\'/a\'>a</a>';
        support.leadingWhitespace = div.firstChild.nodeType === 3;
        support.tbody = !div.getElementsByTagName('tbody').length;
        support.htmlSerialize = !!div.getElementsByTagName('link').length;
        support.html5Clone = document.createElement('nav').cloneNode(true).outerHTML !== '<:nav></:nav>';
        input.type = 'checkbox';
        input.checked = true;
        fragment.appendChild(input);
        support.appendChecked = input.checked;
        div.innerHTML = '<textarea>x</textarea>';
        support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
        fragment.appendChild(div);
        div.innerHTML = '<input type=\'radio\' checked=\'checked\' name=\'t\'/>';
        support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
        support.noCloneEvent = true;
        if (div.attachEvent) {
            div.attachEvent('onclick', function () {
                support.noCloneEvent = false;
            });
            div.cloneNode(true).click();
        }
        if (support.deleteExpando == null) {
            support.deleteExpando = true;
            try {
                delete div.test;
            } catch (e) {
                support.deleteExpando = false;
            }
        }
        fragment = div = input = null;
    }());
    (function () {
        var i, eventName, div = document.createElement('div');
        for (i in {
                submit: true,
                change: true,
                focusin: true
            }) {
            eventName = 'on' + i;
            if (!(support[i + 'Bubbles'] = eventName in window)) {
                div.setAttribute(eventName, 't');
                support[i + 'Bubbles'] = div.attributes[eventName].expando === false;
            }
        }
        div = null;
    }());
    var rformElems = /^(?:input|select|textarea)$/i, rkeyEvent = /^key/, rmouseEvent = /^(?:mouse|contextmenu)|click/, rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;
    function returnTrue() {
        return true;
    }
    function returnFalse() {
        return false;
    }
    function safeActiveElement() {
        try {
            return document.activeElement;
        } catch (err) {
        }
    }
    jQuery.event = {
        global: {},
        add: function (elem, types, handler, data, selector) {
            var tmp, events, t, handleObjIn, special, eventHandle, handleObj, handlers, type, namespaces, origType, elemData = jQuery._data(elem);
            if (!elemData) {
                return;
            }
            if (handler.handler) {
                handleObjIn = handler;
                handler = handleObjIn.handler;
                selector = handleObjIn.selector;
            }
            if (!handler.guid) {
                handler.guid = jQuery.guid++;
            }
            if (!(events = elemData.events)) {
                events = elemData.events = {};
            }
            if (!(eventHandle = elemData.handle)) {
                eventHandle = elemData.handle = function (e) {
                    return typeof jQuery !== strundefined && (!e || jQuery.event.triggered !== e.type) ? jQuery.event.dispatch.apply(eventHandle.elem, arguments) : undefined;
                };
                eventHandle.elem = elem;
            }
            types = (types || '').match(rnotwhite) || [''];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || '').split('.').sort();
                if (!type) {
                    continue;
                }
                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                special = jQuery.event.special[type] || {};
                handleObj = jQuery.extend({
                    type: type,
                    origType: origType,
                    data: data,
                    handler: handler,
                    guid: handler.guid,
                    selector: selector,
                    needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                    namespace: namespaces.join('.')
                }, handleObjIn);
                if (!(handlers = events[type])) {
                    handlers = events[type] = [];
                    handlers.delegateCount = 0;
                    if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                        if (elem.addEventListener) {
                            elem.addEventListener(type, eventHandle, false);
                        } else if (elem.attachEvent) {
                            elem.attachEvent('on' + type, eventHandle);
                        }
                    }
                }
                if (special.add) {
                    special.add.call(elem, handleObj);
                    if (!handleObj.handler.guid) {
                        handleObj.handler.guid = handler.guid;
                    }
                }
                if (selector) {
                    handlers.splice(handlers.delegateCount++, 0, handleObj);
                } else {
                    handlers.push(handleObj);
                }
                jQuery.event.global[type] = true;
            }
            elem = null;
        },
        remove: function (elem, types, handler, selector, mappedTypes) {
            var j, handleObj, tmp, origCount, t, events, special, handlers, type, namespaces, origType, elemData = jQuery.hasData(elem) && jQuery._data(elem);
            if (!elemData || !(events = elemData.events)) {
                return;
            }
            types = (types || '').match(rnotwhite) || [''];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || '').split('.').sort();
                if (!type) {
                    for (type in events) {
                        jQuery.event.remove(elem, type + types[t], handler, selector, true);
                    }
                    continue;
                }
                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                handlers = events[type] || [];
                tmp = tmp[2] && new RegExp('(^|\\.)' + namespaces.join('\\.(?:.*\\.|)') + '(\\.|$)');
                origCount = j = handlers.length;
                while (j--) {
                    handleObj = handlers[j];
                    if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === '**' && handleObj.selector)) {
                        handlers.splice(j, 1);
                        if (handleObj.selector) {
                            handlers.delegateCount--;
                        }
                        if (special.remove) {
                            special.remove.call(elem, handleObj);
                        }
                    }
                }
                if (origCount && !handlers.length) {
                    if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                        jQuery.removeEvent(elem, type, elemData.handle);
                    }
                    delete events[type];
                }
            }
            if (jQuery.isEmptyObject(events)) {
                delete elemData.handle;
                jQuery._removeData(elem, 'events');
            }
        },
        trigger: function (event, data, elem, onlyHandlers) {
            var handle, ontype, cur, bubbleType, special, tmp, i, eventPath = [elem || document], type = hasOwn.call(event, 'type') ? event.type : event, namespaces = hasOwn.call(event, 'namespace') ? event.namespace.split('.') : [];
            cur = tmp = elem = elem || document;
            if (elem.nodeType === 3 || elem.nodeType === 8) {
                return;
            }
            if (rfocusMorph.test(type + jQuery.event.triggered)) {
                return;
            }
            if (type.indexOf('.') >= 0) {
                namespaces = type.split('.');
                type = namespaces.shift();
                namespaces.sort();
            }
            ontype = type.indexOf(':') < 0 && 'on' + type;
            event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === 'object' && event);
            event.isTrigger = onlyHandlers ? 2 : 3;
            event.namespace = namespaces.join('.');
            event.namespace_re = event.namespace ? new RegExp('(^|\\.)' + namespaces.join('\\.(?:.*\\.|)') + '(\\.|$)') : null;
            event.result = undefined;
            if (!event.target) {
                event.target = elem;
            }
            data = data == null ? [event] : jQuery.makeArray(data, [event]);
            special = jQuery.event.special[type] || {};
            if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
                return;
            }
            if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
                bubbleType = special.delegateType || type;
                if (!rfocusMorph.test(bubbleType + type)) {
                    cur = cur.parentNode;
                }
                for (; cur; cur = cur.parentNode) {
                    eventPath.push(cur);
                    tmp = cur;
                }
                if (tmp === (elem.ownerDocument || document)) {
                    eventPath.push(tmp.defaultView || tmp.parentWindow || window);
                }
            }
            i = 0;
            while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
                event.type = i > 1 ? bubbleType : special.bindType || type;
                handle = (jQuery._data(cur, 'events') || {})[event.type] && jQuery._data(cur, 'handle');
                if (handle) {
                    handle.apply(cur, data);
                }
                handle = ontype && cur[ontype];
                if (handle && handle.apply && jQuery.acceptData(cur)) {
                    event.result = handle.apply(cur, data);
                    if (event.result === false) {
                        event.preventDefault();
                    }
                }
            }
            event.type = type;
            if (!onlyHandlers && !event.isDefaultPrevented()) {
                if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && jQuery.acceptData(elem)) {
                    if (ontype && elem[type] && !jQuery.isWindow(elem)) {
                        tmp = elem[ontype];
                        if (tmp) {
                            elem[ontype] = null;
                        }
                        jQuery.event.triggered = type;
                        try {
                            elem[type]();
                        } catch (e) {
                        }
                        jQuery.event.triggered = undefined;
                        if (tmp) {
                            elem[ontype] = tmp;
                        }
                    }
                }
            }
            return event.result;
        },
        dispatch: function (event) {
            event = jQuery.event.fix(event);
            var i, ret, handleObj, matched, j, handlerQueue = [], args = slice.call(arguments), handlers = (jQuery._data(this, 'events') || {})[event.type] || [], special = jQuery.event.special[event.type] || {};
            args[0] = event;
            event.delegateTarget = this;
            if (special.preDispatch && special.preDispatch.call(this, event) === false) {
                return;
            }
            handlerQueue = jQuery.event.handlers.call(this, event, handlers);
            i = 0;
            while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
                event.currentTarget = matched.elem;
                j = 0;
                while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
                    if (!event.namespace_re || event.namespace_re.test(handleObj.namespace)) {
                        event.handleObj = handleObj;
                        event.data = handleObj.data;
                        ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                        if (ret !== undefined) {
                            if ((event.result = ret) === false) {
                                event.preventDefault();
                                event.stopPropagation();
                            }
                        }
                    }
                }
            }
            if (special.postDispatch) {
                special.postDispatch.call(this, event);
            }
            return event.result;
        },
        handlers: function (event, handlers) {
            var sel, handleObj, matches, i, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
            if (delegateCount && cur.nodeType && (!event.button || event.type !== 'click')) {
                for (; cur != this; cur = cur.parentNode || this) {
                    if (cur.nodeType === 1 && (cur.disabled !== true || event.type !== 'click')) {
                        matches = [];
                        for (i = 0; i < delegateCount; i++) {
                            handleObj = handlers[i];
                            sel = handleObj.selector + ' ';
                            if (matches[sel] === undefined) {
                                matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) >= 0 : jQuery.find(sel, this, null, [cur]).length;
                            }
                            if (matches[sel]) {
                                matches.push(handleObj);
                            }
                        }
                        if (matches.length) {
                            handlerQueue.push({
                                elem: cur,
                                handlers: matches
                            });
                        }
                    }
                }
            }
            if (delegateCount < handlers.length) {
                handlerQueue.push({
                    elem: this,
                    handlers: handlers.slice(delegateCount)
                });
            }
            return handlerQueue;
        },
        fix: function (event) {
            if (event[jQuery.expando]) {
                return event;
            }
            var i, prop, copy, type = event.type, originalEvent = event, fixHook = this.fixHooks[type];
            if (!fixHook) {
                this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};
            }
            copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;
            event = new jQuery.Event(originalEvent);
            i = copy.length;
            while (i--) {
                prop = copy[i];
                event[prop] = originalEvent[prop];
            }
            if (!event.target) {
                event.target = originalEvent.srcElement || document;
            }
            if (event.target.nodeType === 3) {
                event.target = event.target.parentNode;
            }
            event.metaKey = !!event.metaKey;
            return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
        },
        props: 'altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which'.split(' '),
        fixHooks: {},
        keyHooks: {
            props: 'char charCode key keyCode'.split(' '),
            filter: function (event, original) {
                if (event.which == null) {
                    event.which = original.charCode != null ? original.charCode : original.keyCode;
                }
                return event;
            }
        },
        mouseHooks: {
            props: 'button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement'.split(' '),
            filter: function (event, original) {
                var body, eventDoc, doc, button = original.button, fromElement = original.fromElement;
                if (event.pageX == null && original.clientX != null) {
                    eventDoc = event.target.ownerDocument || document;
                    doc = eventDoc.documentElement;
                    body = eventDoc.body;
                    event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
                    event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
                }
                if (!event.relatedTarget && fromElement) {
                    event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
                }
                if (!event.which && button !== undefined) {
                    event.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
                }
                return event;
            }
        },
        special: {
            load: { noBubble: true },
            focus: {
                trigger: function () {
                    if (this !== safeActiveElement() && this.focus) {
                        try {
                            this.focus();
                            return false;
                        } catch (e) {
                        }
                    }
                },
                delegateType: 'focusin'
            },
            blur: {
                trigger: function () {
                    if (this === safeActiveElement() && this.blur) {
                        this.blur();
                        return false;
                    }
                },
                delegateType: 'focusout'
            },
            click: {
                trigger: function () {
                    if (jQuery.nodeName(this, 'input') && this.type === 'checkbox' && this.click) {
                        this.click();
                        return false;
                    }
                },
                _default: function (event) {
                    return jQuery.nodeName(event.target, 'a');
                }
            },
            beforeunload: {
                postDispatch: function (event) {
                    if (event.result !== undefined) {
                        event.originalEvent.returnValue = event.result;
                    }
                }
            }
        },
        simulate: function (type, elem, event, bubble) {
            var e = jQuery.extend(new jQuery.Event(), event, {
                type: type,
                isSimulated: true,
                originalEvent: {}
            });
            if (bubble) {
                jQuery.event.trigger(e, null, elem);
            } else {
                jQuery.event.dispatch.call(elem, e);
            }
            if (e.isDefaultPrevented()) {
                event.preventDefault();
            }
        }
    };
    jQuery.removeEvent = document.removeEventListener ? function (elem, type, handle) {
        if (elem.removeEventListener) {
            elem.removeEventListener(type, handle, false);
        }
    } : function (elem, type, handle) {
        var name = 'on' + type;
        if (elem.detachEvent) {
            if (typeof elem[name] === strundefined) {
                elem[name] = null;
            }
            elem.detachEvent(name, handle);
        }
    };
    jQuery.Event = function (src, props) {
        if (!(this instanceof jQuery.Event)) {
            return new jQuery.Event(src, props);
        }
        if (src && src.type) {
            this.originalEvent = src;
            this.type = src.type;
            this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && (src.returnValue === false || src.getPreventDefault && src.getPreventDefault()) ? returnTrue : returnFalse;
        } else {
            this.type = src;
        }
        if (props) {
            jQuery.extend(this, props);
        }
        this.timeStamp = src && src.timeStamp || jQuery.now();
        this[jQuery.expando] = true;
    };
    jQuery.Event.prototype = {
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,
        preventDefault: function () {
            var e = this.originalEvent;
            this.isDefaultPrevented = returnTrue;
            if (!e) {
                return;
            }
            if (e.preventDefault) {
                e.preventDefault();
            } else {
                e.returnValue = false;
            }
        },
        stopPropagation: function () {
            var e = this.originalEvent;
            this.isPropagationStopped = returnTrue;
            if (!e) {
                return;
            }
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            e.cancelBubble = true;
        },
        stopImmediatePropagation: function () {
            this.isImmediatePropagationStopped = returnTrue;
            this.stopPropagation();
        }
    };
    jQuery.each({
        mouseenter: 'mouseover',
        mouseleave: 'mouseout'
    }, function (orig, fix) {
        jQuery.event.special[orig] = {
            delegateType: fix,
            bindType: fix,
            handle: function (event) {
                var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
                if (!related || related !== target && !jQuery.contains(target, related)) {
                    event.type = handleObj.origType;
                    ret = handleObj.handler.apply(this, arguments);
                    event.type = fix;
                }
                return ret;
            }
        };
    });
    if (!support.submitBubbles) {
        jQuery.event.special.submit = {
            setup: function () {
                if (jQuery.nodeName(this, 'form')) {
                    return false;
                }
                jQuery.event.add(this, 'click._submit keypress._submit', function (e) {
                    var elem = e.target, form = jQuery.nodeName(elem, 'input') || jQuery.nodeName(elem, 'button') ? elem.form : undefined;
                    if (form && !jQuery._data(form, 'submitBubbles')) {
                        jQuery.event.add(form, 'submit._submit', function (event) {
                            event._submit_bubble = true;
                        });
                        jQuery._data(form, 'submitBubbles', true);
                    }
                });
            },
            postDispatch: function (event) {
                if (event._submit_bubble) {
                    delete event._submit_bubble;
                    if (this.parentNode && !event.isTrigger) {
                        jQuery.event.simulate('submit', this.parentNode, event, true);
                    }
                }
            },
            teardown: function () {
                if (jQuery.nodeName(this, 'form')) {
                    return false;
                }
                jQuery.event.remove(this, '._submit');
            }
        };
    }
    if (!support.changeBubbles) {
        jQuery.event.special.change = {
            setup: function () {
                if (rformElems.test(this.nodeName)) {
                    if (this.type === 'checkbox' || this.type === 'radio') {
                        jQuery.event.add(this, 'propertychange._change', function (event) {
                            if (event.originalEvent.propertyName === 'checked') {
                                this._just_changed = true;
                            }
                        });
                        jQuery.event.add(this, 'click._change', function (event) {
                            if (this._just_changed && !event.isTrigger) {
                                this._just_changed = false;
                            }
                            jQuery.event.simulate('change', this, event, true);
                        });
                    }
                    return false;
                }
                jQuery.event.add(this, 'beforeactivate._change', function (e) {
                    var elem = e.target;
                    if (rformElems.test(elem.nodeName) && !jQuery._data(elem, 'changeBubbles')) {
                        jQuery.event.add(elem, 'change._change', function (event) {
                            if (this.parentNode && !event.isSimulated && !event.isTrigger) {
                                jQuery.event.simulate('change', this.parentNode, event, true);
                            }
                        });
                        jQuery._data(elem, 'changeBubbles', true);
                    }
                });
            },
            handle: function (event) {
                var elem = event.target;
                if (this !== elem || event.isSimulated || event.isTrigger || elem.type !== 'radio' && elem.type !== 'checkbox') {
                    return event.handleObj.handler.apply(this, arguments);
                }
            },
            teardown: function () {
                jQuery.event.remove(this, '._change');
                return !rformElems.test(this.nodeName);
            }
        };
    }
    if (!support.focusinBubbles) {
        jQuery.each({
            focus: 'focusin',
            blur: 'focusout'
        }, function (orig, fix) {
            var handler = function (event) {
                jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);
            };
            jQuery.event.special[fix] = {
                setup: function () {
                    var doc = this.ownerDocument || this, attaches = jQuery._data(doc, fix);
                    if (!attaches) {
                        doc.addEventListener(orig, handler, true);
                    }
                    jQuery._data(doc, fix, (attaches || 0) + 1);
                },
                teardown: function () {
                    var doc = this.ownerDocument || this, attaches = jQuery._data(doc, fix) - 1;
                    if (!attaches) {
                        doc.removeEventListener(orig, handler, true);
                        jQuery._removeData(doc, fix);
                    } else {
                        jQuery._data(doc, fix, attaches);
                    }
                }
            };
        });
    }
    jQuery.fn.extend({
        on: function (types, selector, data, fn, one) {
            var type, origFn;
            if (typeof types === 'object') {
                if (typeof selector !== 'string') {
                    data = data || selector;
                    selector = undefined;
                }
                for (type in types) {
                    this.on(type, selector, data, types[type], one);
                }
                return this;
            }
            if (data == null && fn == null) {
                fn = selector;
                data = selector = undefined;
            } else if (fn == null) {
                if (typeof selector === 'string') {
                    fn = data;
                    data = undefined;
                } else {
                    fn = data;
                    data = selector;
                    selector = undefined;
                }
            }
            if (fn === false) {
                fn = returnFalse;
            } else if (!fn) {
                return this;
            }
            if (one === 1) {
                origFn = fn;
                fn = function (event) {
                    jQuery().off(event);
                    return origFn.apply(this, arguments);
                };
                fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
            }
            return this.each(function () {
                jQuery.event.add(this, types, fn, data, selector);
            });
        },
        one: function (types, selector, data, fn) {
            return this.on(types, selector, data, fn, 1);
        },
        off: function (types, selector, fn) {
            var handleObj, type;
            if (types && types.preventDefault && types.handleObj) {
                handleObj = types.handleObj;
                jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + '.' + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
                return this;
            }
            if (typeof types === 'object') {
                for (type in types) {
                    this.off(type, selector, types[type]);
                }
                return this;
            }
            if (selector === false || typeof selector === 'function') {
                fn = selector;
                selector = undefined;
            }
            if (fn === false) {
                fn = returnFalse;
            }
            return this.each(function () {
                jQuery.event.remove(this, types, fn, selector);
            });
        },
        trigger: function (type, data) {
            return this.each(function () {
                jQuery.event.trigger(type, data, this);
            });
        },
        triggerHandler: function (type, data) {
            var elem = this[0];
            if (elem) {
                return jQuery.event.trigger(type, data, elem, true);
            }
        }
    });
    function createSafeFragment(document) {
        var list = nodeNames.split('|'), safeFrag = document.createDocumentFragment();
        if (safeFrag.createElement) {
            while (list.length) {
                safeFrag.createElement(list.pop());
            }
        }
        return safeFrag;
    }
    var nodeNames = 'abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|' + 'header|hgroup|mark|meter|nav|output|progress|section|summary|time|video', rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g, rnoshimcache = new RegExp('<(?:' + nodeNames + ')[\\s/>]', 'i'), rleadingWhitespace = /^\s+/, rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, rtagName = /<([\w:]+)/, rtbody = /<tbody/i, rhtml = /<|&#?\w+;/, rnoInnerhtml = /<(?:script|style|link)/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rscriptType = /^$|\/(?:java|ecma)script/i, rscriptTypeMasked = /^true\/(.*)/, rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g, wrapMap = {
            option: [
                1,
                '<select multiple=\'multiple\'>',
                '</select>'
            ],
            legend: [
                1,
                '<fieldset>',
                '</fieldset>'
            ],
            area: [
                1,
                '<map>',
                '</map>'
            ],
            param: [
                1,
                '<object>',
                '</object>'
            ],
            thead: [
                1,
                '<table>',
                '</table>'
            ],
            tr: [
                2,
                '<table><tbody>',
                '</tbody></table>'
            ],
            col: [
                2,
                '<table><tbody></tbody><colgroup>',
                '</colgroup></table>'
            ],
            td: [
                3,
                '<table><tbody><tr>',
                '</tr></tbody></table>'
            ],
            _default: support.htmlSerialize ? [
                0,
                '',
                ''
            ] : [
                1,
                'X<div>',
                '</div>'
            ]
        }, safeFragment = createSafeFragment(document), fragmentDiv = safeFragment.appendChild(document.createElement('div'));
    wrapMap.optgroup = wrapMap.option;
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;
    function getAll(context, tag) {
        var elems, elem, i = 0, found = typeof context.getElementsByTagName !== strundefined ? context.getElementsByTagName(tag || '*') : typeof context.querySelectorAll !== strundefined ? context.querySelectorAll(tag || '*') : undefined;
        if (!found) {
            for (found = [], elems = context.childNodes || context; (elem = elems[i]) != null; i++) {
                if (!tag || jQuery.nodeName(elem, tag)) {
                    found.push(elem);
                } else {
                    jQuery.merge(found, getAll(elem, tag));
                }
            }
        }
        return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([context], found) : found;
    }
    function fixDefaultChecked(elem) {
        if (rcheckableType.test(elem.type)) {
            elem.defaultChecked = elem.checked;
        }
    }
    function manipulationTarget(elem, content) {
        return jQuery.nodeName(elem, 'table') && jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, 'tr') ? elem.getElementsByTagName('tbody')[0] || elem.appendChild(elem.ownerDocument.createElement('tbody')) : elem;
    }
    function disableScript(elem) {
        elem.type = (jQuery.find.attr(elem, 'type') !== null) + '/' + elem.type;
        return elem;
    }
    function restoreScript(elem) {
        var match = rscriptTypeMasked.exec(elem.type);
        if (match) {
            elem.type = match[1];
        } else {
            elem.removeAttribute('type');
        }
        return elem;
    }
    function setGlobalEval(elems, refElements) {
        var elem, i = 0;
        for (; (elem = elems[i]) != null; i++) {
            jQuery._data(elem, 'globalEval', !refElements || jQuery._data(refElements[i], 'globalEval'));
        }
    }
    function cloneCopyEvent(src, dest) {
        if (dest.nodeType !== 1 || !jQuery.hasData(src)) {
            return;
        }
        var type, i, l, oldData = jQuery._data(src), curData = jQuery._data(dest, oldData), events = oldData.events;
        if (events) {
            delete curData.handle;
            curData.events = {};
            for (type in events) {
                for (i = 0, l = events[type].length; i < l; i++) {
                    jQuery.event.add(dest, type, events[type][i]);
                }
            }
        }
        if (curData.data) {
            curData.data = jQuery.extend({}, curData.data);
        }
    }
    function fixCloneNodeIssues(src, dest) {
        var nodeName, e, data;
        if (dest.nodeType !== 1) {
            return;
        }
        nodeName = dest.nodeName.toLowerCase();
        if (!support.noCloneEvent && dest[jQuery.expando]) {
            data = jQuery._data(dest);
            for (e in data.events) {
                jQuery.removeEvent(dest, e, data.handle);
            }
            dest.removeAttribute(jQuery.expando);
        }
        if (nodeName === 'script' && dest.text !== src.text) {
            disableScript(dest).text = src.text;
            restoreScript(dest);
        } else if (nodeName === 'object') {
            if (dest.parentNode) {
                dest.outerHTML = src.outerHTML;
            }
            if (support.html5Clone && (src.innerHTML && !jQuery.trim(dest.innerHTML))) {
                dest.innerHTML = src.innerHTML;
            }
        } else if (nodeName === 'input' && rcheckableType.test(src.type)) {
            dest.defaultChecked = dest.checked = src.checked;
            if (dest.value !== src.value) {
                dest.value = src.value;
            }
        } else if (nodeName === 'option') {
            dest.defaultSelected = dest.selected = src.defaultSelected;
        } else if (nodeName === 'input' || nodeName === 'textarea') {
            dest.defaultValue = src.defaultValue;
        }
    }
    jQuery.extend({
        clone: function (elem, dataAndEvents, deepDataAndEvents) {
            var destElements, node, clone, i, srcElements, inPage = jQuery.contains(elem.ownerDocument, elem);
            if (support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test('<' + elem.nodeName + '>')) {
                clone = elem.cloneNode(true);
            } else {
                fragmentDiv.innerHTML = elem.outerHTML;
                fragmentDiv.removeChild(clone = fragmentDiv.firstChild);
            }
            if ((!support.noCloneEvent || !support.noCloneChecked) && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
                destElements = getAll(clone);
                srcElements = getAll(elem);
                for (i = 0; (node = srcElements[i]) != null; ++i) {
                    if (destElements[i]) {
                        fixCloneNodeIssues(node, destElements[i]);
                    }
                }
            }
            if (dataAndEvents) {
                if (deepDataAndEvents) {
                    srcElements = srcElements || getAll(elem);
                    destElements = destElements || getAll(clone);
                    for (i = 0; (node = srcElements[i]) != null; i++) {
                        cloneCopyEvent(node, destElements[i]);
                    }
                } else {
                    cloneCopyEvent(elem, clone);
                }
            }
            destElements = getAll(clone, 'script');
            if (destElements.length > 0) {
                setGlobalEval(destElements, !inPage && getAll(elem, 'script'));
            }
            destElements = srcElements = node = null;
            return clone;
        },
        buildFragment: function (elems, context, scripts, selection) {
            var j, elem, contains, tmp, tag, tbody, wrap, l = elems.length, safe = createSafeFragment(context), nodes = [], i = 0;
            for (; i < l; i++) {
                elem = elems[i];
                if (elem || elem === 0) {
                    if (jQuery.type(elem) === 'object') {
                        jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
                    } else if (!rhtml.test(elem)) {
                        nodes.push(context.createTextNode(elem));
                    } else {
                        tmp = tmp || safe.appendChild(context.createElement('div'));
                        tag = (rtagName.exec(elem) || [
                            '',
                            ''
                        ])[1].toLowerCase();
                        wrap = wrapMap[tag] || wrapMap._default;
                        tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, '<$1></$2>') + wrap[2];
                        j = wrap[0];
                        while (j--) {
                            tmp = tmp.lastChild;
                        }
                        if (!support.leadingWhitespace && rleadingWhitespace.test(elem)) {
                            nodes.push(context.createTextNode(rleadingWhitespace.exec(elem)[0]));
                        }
                        if (!support.tbody) {
                            elem = tag === 'table' && !rtbody.test(elem) ? tmp.firstChild : wrap[1] === '<table>' && !rtbody.test(elem) ? tmp : 0;
                            j = elem && elem.childNodes.length;
                            while (j--) {
                                if (jQuery.nodeName(tbody = elem.childNodes[j], 'tbody') && !tbody.childNodes.length) {
                                    elem.removeChild(tbody);
                                }
                            }
                        }
                        jQuery.merge(nodes, tmp.childNodes);
                        tmp.textContent = '';
                        while (tmp.firstChild) {
                            tmp.removeChild(tmp.firstChild);
                        }
                        tmp = safe.lastChild;
                    }
                }
            }
            if (tmp) {
                safe.removeChild(tmp);
            }
            if (!support.appendChecked) {
                jQuery.grep(getAll(nodes, 'input'), fixDefaultChecked);
            }
            i = 0;
            while (elem = nodes[i++]) {
                if (selection && jQuery.inArray(elem, selection) !== -1) {
                    continue;
                }
                contains = jQuery.contains(elem.ownerDocument, elem);
                tmp = getAll(safe.appendChild(elem), 'script');
                if (contains) {
                    setGlobalEval(tmp);
                }
                if (scripts) {
                    j = 0;
                    while (elem = tmp[j++]) {
                        if (rscriptType.test(elem.type || '')) {
                            scripts.push(elem);
                        }
                    }
                }
            }
            tmp = null;
            return safe;
        },
        cleanData: function (elems, acceptData) {
            var elem, type, id, data, i = 0, internalKey = jQuery.expando, cache = jQuery.cache, deleteExpando = support.deleteExpando, special = jQuery.event.special;
            for (; (elem = elems[i]) != null; i++) {
                if (acceptData || jQuery.acceptData(elem)) {
                    id = elem[internalKey];
                    data = id && cache[id];
                    if (data) {
                        if (data.events) {
                            for (type in data.events) {
                                if (special[type]) {
                                    jQuery.event.remove(elem, type);
                                } else {
                                    jQuery.removeEvent(elem, type, data.handle);
                                }
                            }
                        }
                        if (cache[id]) {
                            delete cache[id];
                            if (deleteExpando) {
                                delete elem[internalKey];
                            } else if (typeof elem.removeAttribute !== strundefined) {
                                elem.removeAttribute(internalKey);
                            } else {
                                elem[internalKey] = null;
                            }
                            deletedIds.push(id);
                        }
                    }
                }
            }
        }
    });
    jQuery.fn.extend({
        text: function (value) {
            return access(this, function (value) {
                return value === undefined ? jQuery.text(this) : this.empty().append((this[0] && this[0].ownerDocument || document).createTextNode(value));
            }, null, value, arguments.length);
        },
        append: function () {
            return this.domManip(arguments, function (elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.appendChild(elem);
                }
            });
        },
        prepend: function () {
            return this.domManip(arguments, function (elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.insertBefore(elem, target.firstChild);
                }
            });
        },
        before: function () {
            return this.domManip(arguments, function (elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this);
                }
            });
        },
        after: function () {
            return this.domManip(arguments, function (elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this.nextSibling);
                }
            });
        },
        remove: function (selector, keepData) {
            var elem, elems = selector ? jQuery.filter(selector, this) : this, i = 0;
            for (; (elem = elems[i]) != null; i++) {
                if (!keepData && elem.nodeType === 1) {
                    jQuery.cleanData(getAll(elem));
                }
                if (elem.parentNode) {
                    if (keepData && jQuery.contains(elem.ownerDocument, elem)) {
                        setGlobalEval(getAll(elem, 'script'));
                    }
                    elem.parentNode.removeChild(elem);
                }
            }
            return this;
        },
        empty: function () {
            var elem, i = 0;
            for (; (elem = this[i]) != null; i++) {
                if (elem.nodeType === 1) {
                    jQuery.cleanData(getAll(elem, false));
                }
                while (elem.firstChild) {
                    elem.removeChild(elem.firstChild);
                }
                if (elem.options && jQuery.nodeName(elem, 'select')) {
                    elem.options.length = 0;
                }
            }
            return this;
        },
        clone: function (dataAndEvents, deepDataAndEvents) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
            return this.map(function () {
                return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
            });
        },
        html: function (value) {
            return access(this, function (value) {
                var elem = this[0] || {}, i = 0, l = this.length;
                if (value === undefined) {
                    return elem.nodeType === 1 ? elem.innerHTML.replace(rinlinejQuery, '') : undefined;
                }
                if (typeof value === 'string' && !rnoInnerhtml.test(value) && (support.htmlSerialize || !rnoshimcache.test(value)) && (support.leadingWhitespace || !rleadingWhitespace.test(value)) && !wrapMap[(rtagName.exec(value) || [
                        '',
                        ''
                    ])[1].toLowerCase()]) {
                    value = value.replace(rxhtmlTag, '<$1></$2>');
                    try {
                        for (; i < l; i++) {
                            elem = this[i] || {};
                            if (elem.nodeType === 1) {
                                jQuery.cleanData(getAll(elem, false));
                                elem.innerHTML = value;
                            }
                        }
                        elem = 0;
                    } catch (e) {
                    }
                }
                if (elem) {
                    this.empty().append(value);
                }
            }, null, value, arguments.length);
        },
        replaceWith: function () {
            var arg = arguments[0];
            this.domManip(arguments, function (elem) {
                arg = this.parentNode;
                jQuery.cleanData(getAll(this));
                if (arg) {
                    arg.replaceChild(elem, this);
                }
            });
            return arg && (arg.length || arg.nodeType) ? this : this.remove();
        },
        detach: function (selector) {
            return this.remove(selector, true);
        },
        domManip: function (args, callback) {
            args = concat.apply([], args);
            var first, node, hasScripts, scripts, doc, fragment, i = 0, l = this.length, set = this, iNoClone = l - 1, value = args[0], isFunction = jQuery.isFunction(value);
            if (isFunction || l > 1 && typeof value === 'string' && !support.checkClone && rchecked.test(value)) {
                return this.each(function (index) {
                    var self = set.eq(index);
                    if (isFunction) {
                        args[0] = value.call(this, index, self.html());
                    }
                    self.domManip(args, callback);
                });
            }
            if (l) {
                fragment = jQuery.buildFragment(args, this[0].ownerDocument, false, this);
                first = fragment.firstChild;
                if (fragment.childNodes.length === 1) {
                    fragment = first;
                }
                if (first) {
                    scripts = jQuery.map(getAll(fragment, 'script'), disableScript);
                    hasScripts = scripts.length;
                    for (; i < l; i++) {
                        node = fragment;
                        if (i !== iNoClone) {
                            node = jQuery.clone(node, true, true);
                            if (hasScripts) {
                                jQuery.merge(scripts, getAll(node, 'script'));
                            }
                        }
                        callback.call(this[i], node, i);
                    }
                    if (hasScripts) {
                        doc = scripts[scripts.length - 1].ownerDocument;
                        jQuery.map(scripts, restoreScript);
                        for (i = 0; i < hasScripts; i++) {
                            node = scripts[i];
                            if (rscriptType.test(node.type || '') && !jQuery._data(node, 'globalEval') && jQuery.contains(doc, node)) {
                                if (node.src) {
                                    if (jQuery._evalUrl) {
                                        jQuery._evalUrl(node.src);
                                    }
                                } else {
                                    jQuery.globalEval((node.text || node.textContent || node.innerHTML || '').replace(rcleanScript, ''));
                                }
                            }
                        }
                    }
                    fragment = first = null;
                }
            }
            return this;
        }
    });
    jQuery.each({
        appendTo: 'append',
        prependTo: 'prepend',
        insertBefore: 'before',
        insertAfter: 'after',
        replaceAll: 'replaceWith'
    }, function (name, original) {
        jQuery.fn[name] = function (selector) {
            var elems, i = 0, ret = [], insert = jQuery(selector), last = insert.length - 1;
            for (; i <= last; i++) {
                elems = i === last ? this : this.clone(true);
                jQuery(insert[i])[original](elems);
                push.apply(ret, elems.get());
            }
            return this.pushStack(ret);
        };
    });
    var iframe, elemdisplay = {};
    function actualDisplay(name, doc) {
        var elem = jQuery(doc.createElement(name)).appendTo(doc.body), display = window.getDefaultComputedStyle ? window.getDefaultComputedStyle(elem[0]).display : jQuery.css(elem[0], 'display');
        elem.detach();
        return display;
    }
    function defaultDisplay(nodeName) {
        var doc = document, display = elemdisplay[nodeName];
        if (!display) {
            display = actualDisplay(nodeName, doc);
            if (display === 'none' || !display) {
                iframe = (iframe || jQuery('<iframe frameborder=\'0\' width=\'0\' height=\'0\'/>')).appendTo(doc.documentElement);
                doc = (iframe[0].contentWindow || iframe[0].contentDocument).document;
                doc.write();
                doc.close();
                display = actualDisplay(nodeName, doc);
                iframe.detach();
            }
            elemdisplay[nodeName] = display;
        }
        return display;
    }
    (function () {
        var a, shrinkWrapBlocksVal, div = document.createElement('div'), divReset = '-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;' + 'display:block;padding:0;margin:0;border:0';
        div.innerHTML = '  <link/><table></table><a href=\'/a\'>a</a><input type=\'checkbox\'/>';
        a = div.getElementsByTagName('a')[0];
        a.style.cssText = 'float:left;opacity:.5';
        support.opacity = /^0.5/.test(a.style.opacity);
        support.cssFloat = !!a.style.cssFloat;
        div.style.backgroundClip = 'content-box';
        div.cloneNode(true).style.backgroundClip = '';
        support.clearCloneStyle = div.style.backgroundClip === 'content-box';
        a = div = null;
        support.shrinkWrapBlocks = function () {
            var body, container, div, containerStyles;
            if (shrinkWrapBlocksVal == null) {
                body = document.getElementsByTagName('body')[0];
                if (!body) {
                    return;
                }
                containerStyles = 'border:0;width:0;height:0;position:absolute;top:0;left:-9999px';
                container = document.createElement('div');
                div = document.createElement('div');
                body.appendChild(container).appendChild(div);
                shrinkWrapBlocksVal = false;
                if (typeof div.style.zoom !== strundefined) {
                    div.style.cssText = divReset + ';width:1px;padding:1px;zoom:1';
                    div.innerHTML = '<div></div>';
                    div.firstChild.style.width = '5px';
                    shrinkWrapBlocksVal = div.offsetWidth !== 3;
                }
                body.removeChild(container);
                body = container = div = null;
            }
            return shrinkWrapBlocksVal;
        };
    }());
    var rmargin = /^margin/;
    var rnumnonpx = new RegExp('^(' + pnum + ')(?!px)[a-z%]+$', 'i');
    var getStyles, curCSS, rposition = /^(top|right|bottom|left)$/;
    if (window.getComputedStyle) {
        getStyles = function (elem) {
            return elem.ownerDocument.defaultView.getComputedStyle(elem, null);
        };
        curCSS = function (elem, name, computed) {
            var width, minWidth, maxWidth, ret, style = elem.style;
            computed = computed || getStyles(elem);
            ret = computed ? computed.getPropertyValue(name) || computed[name] : undefined;
            if (computed) {
                if (ret === '' && !jQuery.contains(elem.ownerDocument, elem)) {
                    ret = jQuery.style(elem, name);
                }
                if (rnumnonpx.test(ret) && rmargin.test(name)) {
                    width = style.width;
                    minWidth = style.minWidth;
                    maxWidth = style.maxWidth;
                    style.minWidth = style.maxWidth = style.width = ret;
                    ret = computed.width;
                    style.width = width;
                    style.minWidth = minWidth;
                    style.maxWidth = maxWidth;
                }
            }
            return ret === undefined ? ret : ret + '';
        };
    } else if (document.documentElement.currentStyle) {
        getStyles = function (elem) {
            return elem.currentStyle;
        };
        curCSS = function (elem, name, computed) {
            var left, rs, rsLeft, ret, style = elem.style;
            computed = computed || getStyles(elem);
            ret = computed ? computed[name] : undefined;
            if (ret == null && style && style[name]) {
                ret = style[name];
            }
            if (rnumnonpx.test(ret) && !rposition.test(name)) {
                left = style.left;
                rs = elem.runtimeStyle;
                rsLeft = rs && rs.left;
                if (rsLeft) {
                    rs.left = elem.currentStyle.left;
                }
                style.left = name === 'fontSize' ? '1em' : ret;
                ret = style.pixelLeft + 'px';
                style.left = left;
                if (rsLeft) {
                    rs.left = rsLeft;
                }
            }
            return ret === undefined ? ret : ret + '' || 'auto';
        };
    }
    function addGetHookIf(conditionFn, hookFn) {
        return {
            get: function () {
                var condition = conditionFn();
                if (condition == null) {
                    return;
                }
                if (condition) {
                    delete this.get;
                    return;
                }
                return (this.get = hookFn).apply(this, arguments);
            }
        };
    }
    (function () {
        var a, reliableHiddenOffsetsVal, boxSizingVal, boxSizingReliableVal, pixelPositionVal, reliableMarginRightVal, div = document.createElement('div'), containerStyles = 'border:0;width:0;height:0;position:absolute;top:0;left:-9999px', divReset = '-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;' + 'display:block;padding:0;margin:0;border:0';
        div.innerHTML = '  <link/><table></table><a href=\'/a\'>a</a><input type=\'checkbox\'/>';
        a = div.getElementsByTagName('a')[0];
        a.style.cssText = 'float:left;opacity:.5';
        support.opacity = /^0.5/.test(a.style.opacity);
        support.cssFloat = !!a.style.cssFloat;
        div.style.backgroundClip = 'content-box';
        div.cloneNode(true).style.backgroundClip = '';
        support.clearCloneStyle = div.style.backgroundClip === 'content-box';
        a = div = null;
        jQuery.extend(support, {
            reliableHiddenOffsets: function () {
                if (reliableHiddenOffsetsVal != null) {
                    return reliableHiddenOffsetsVal;
                }
                var container, tds, isSupported, div = document.createElement('div'), body = document.getElementsByTagName('body')[0];
                if (!body) {
                    return;
                }
                div.setAttribute('className', 't');
                div.innerHTML = '  <link/><table></table><a href=\'/a\'>a</a><input type=\'checkbox\'/>';
                container = document.createElement('div');
                container.style.cssText = containerStyles;
                body.appendChild(container).appendChild(div);
                div.innerHTML = '<table><tr><td></td><td>t</td></tr></table>';
                tds = div.getElementsByTagName('td');
                tds[0].style.cssText = 'padding:0;margin:0;border:0;display:none';
                isSupported = tds[0].offsetHeight === 0;
                tds[0].style.display = '';
                tds[1].style.display = 'none';
                reliableHiddenOffsetsVal = isSupported && tds[0].offsetHeight === 0;
                body.removeChild(container);
                div = body = null;
                return reliableHiddenOffsetsVal;
            },
            boxSizing: function () {
                if (boxSizingVal == null) {
                    computeStyleTests();
                }
                return boxSizingVal;
            },
            boxSizingReliable: function () {
                if (boxSizingReliableVal == null) {
                    computeStyleTests();
                }
                return boxSizingReliableVal;
            },
            pixelPosition: function () {
                if (pixelPositionVal == null) {
                    computeStyleTests();
                }
                return pixelPositionVal;
            },
            reliableMarginRight: function () {
                var body, container, div, marginDiv;
                if (reliableMarginRightVal == null && window.getComputedStyle) {
                    body = document.getElementsByTagName('body')[0];
                    if (!body) {
                        return;
                    }
                    container = document.createElement('div');
                    div = document.createElement('div');
                    container.style.cssText = containerStyles;
                    body.appendChild(container).appendChild(div);
                    marginDiv = div.appendChild(document.createElement('div'));
                    marginDiv.style.cssText = div.style.cssText = divReset;
                    marginDiv.style.marginRight = marginDiv.style.width = '0';
                    div.style.width = '1px';
                    reliableMarginRightVal = !parseFloat((window.getComputedStyle(marginDiv, null) || {}).marginRight);
                    body.removeChild(container);
                }
                return reliableMarginRightVal;
            }
        });
        function computeStyleTests() {
            var container, div, body = document.getElementsByTagName('body')[0];
            if (!body) {
                return;
            }
            container = document.createElement('div');
            div = document.createElement('div');
            container.style.cssText = containerStyles;
            body.appendChild(container).appendChild(div);
            div.style.cssText = '-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;' + 'position:absolute;display:block;padding:1px;border:1px;width:4px;' + 'margin-top:1%;top:1%';
            jQuery.swap(body, body.style.zoom != null ? { zoom: 1 } : {}, function () {
                boxSizingVal = div.offsetWidth === 4;
            });
            boxSizingReliableVal = true;
            pixelPositionVal = false;
            reliableMarginRightVal = true;
            if (window.getComputedStyle) {
                pixelPositionVal = (window.getComputedStyle(div, null) || {}).top !== '1%';
                boxSizingReliableVal = (window.getComputedStyle(div, null) || { width: '4px' }).width === '4px';
            }
            body.removeChild(container);
            div = body = null;
        }
    }());
    jQuery.swap = function (elem, options, callback, args) {
        var ret, name, old = {};
        for (name in options) {
            old[name] = elem.style[name];
            elem.style[name] = options[name];
        }
        ret = callback.apply(elem, args || []);
        for (name in options) {
            elem.style[name] = old[name];
        }
        return ret;
    };
    var ralpha = /alpha\([^)]*\)/i, ropacity = /opacity\s*=\s*([^)]*)/, rdisplayswap = /^(none|table(?!-c[ea]).+)/, rnumsplit = new RegExp('^(' + pnum + ')(.*)$', 'i'), rrelNum = new RegExp('^([+-])=(' + pnum + ')', 'i'), cssShow = {
            position: 'absolute',
            visibility: 'hidden',
            display: 'block'
        }, cssNormalTransform = {
            letterSpacing: 0,
            fontWeight: 400
        }, cssPrefixes = [
            'Webkit',
            'O',
            'Moz',
            'ms'
        ];
    function vendorPropName(style, name) {
        if (name in style) {
            return name;
        }
        var capName = name.charAt(0).toUpperCase() + name.slice(1), origName = name, i = cssPrefixes.length;
        while (i--) {
            name = cssPrefixes[i] + capName;
            if (name in style) {
                return name;
            }
        }
        return origName;
    }
    function showHide(elements, show) {
        var display, elem, hidden, values = [], index = 0, length = elements.length;
        for (; index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
                continue;
            }
            values[index] = jQuery._data(elem, 'olddisplay');
            display = elem.style.display;
            if (show) {
                if (!values[index] && display === 'none') {
                    elem.style.display = '';
                }
                if (elem.style.display === '' && isHidden(elem)) {
                    values[index] = jQuery._data(elem, 'olddisplay', defaultDisplay(elem.nodeName));
                }
            } else {
                if (!values[index]) {
                    hidden = isHidden(elem);
                    if (display && display !== 'none' || !hidden) {
                        jQuery._data(elem, 'olddisplay', hidden ? display : jQuery.css(elem, 'display'));
                    }
                }
            }
        }
        for (index = 0; index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
                continue;
            }
            if (!show || elem.style.display === 'none' || elem.style.display === '') {
                elem.style.display = show ? values[index] || '' : 'none';
            }
        }
        return elements;
    }
    function setPositiveNumber(elem, value, subtract) {
        var matches = rnumsplit.exec(value);
        return matches ? Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || 'px') : value;
    }
    function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
        var i = extra === (isBorderBox ? 'border' : 'content') ? 4 : name === 'width' ? 1 : 0, val = 0;
        for (; i < 4; i += 2) {
            if (extra === 'margin') {
                val += jQuery.css(elem, extra + cssExpand[i], true, styles);
            }
            if (isBorderBox) {
                if (extra === 'content') {
                    val -= jQuery.css(elem, 'padding' + cssExpand[i], true, styles);
                }
                if (extra !== 'margin') {
                    val -= jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles);
                }
            } else {
                val += jQuery.css(elem, 'padding' + cssExpand[i], true, styles);
                if (extra !== 'padding') {
                    val += jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles);
                }
            }
        }
        return val;
    }
    function getWidthOrHeight(elem, name, extra) {
        var valueIsBorderBox = true, val = name === 'width' ? elem.offsetWidth : elem.offsetHeight, styles = getStyles(elem), isBorderBox = support.boxSizing() && jQuery.css(elem, 'boxSizing', false, styles) === 'border-box';
        if (val <= 0 || val == null) {
            val = curCSS(elem, name, styles);
            if (val < 0 || val == null) {
                val = elem.style[name];
            }
            if (rnumnonpx.test(val)) {
                return val;
            }
            valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]);
            val = parseFloat(val) || 0;
        }
        return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? 'border' : 'content'), valueIsBorderBox, styles) + 'px';
    }
    jQuery.extend({
        cssHooks: {
            opacity: {
                get: function (elem, computed) {
                    if (computed) {
                        var ret = curCSS(elem, 'opacity');
                        return ret === '' ? '1' : ret;
                    }
                }
            }
        },
        cssNumber: {
            'columnCount': true,
            'fillOpacity': true,
            'fontWeight': true,
            'lineHeight': true,
            'opacity': true,
            'order': true,
            'orphans': true,
            'widows': true,
            'zIndex': true,
            'zoom': true
        },
        cssProps: { 'float': support.cssFloat ? 'cssFloat' : 'styleFloat' },
        style: function (elem, name, value, extra) {
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
                return;
            }
            var ret, type, hooks, origName = jQuery.camelCase(name), style = elem.style;
            name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName));
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            if (value !== undefined) {
                type = typeof value;
                if (type === 'string' && (ret = rrelNum.exec(value))) {
                    value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name));
                    type = 'number';
                }
                if (value == null || value !== value) {
                    return;
                }
                if (type === 'number' && !jQuery.cssNumber[origName]) {
                    value += 'px';
                }
                if (!support.clearCloneStyle && value === '' && name.indexOf('background') === 0) {
                    style[name] = 'inherit';
                }
                if (!hooks || !('set' in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
                    try {
                        style[name] = '';
                        style[name] = value;
                    } catch (e) {
                    }
                }
            } else {
                if (hooks && 'get' in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
                    return ret;
                }
                return style[name];
            }
        },
        css: function (elem, name, extra, styles) {
            var num, val, hooks, origName = jQuery.camelCase(name);
            name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName));
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            if (hooks && 'get' in hooks) {
                val = hooks.get(elem, true, extra);
            }
            if (val === undefined) {
                val = curCSS(elem, name, styles);
            }
            if (val === 'normal' && name in cssNormalTransform) {
                val = cssNormalTransform[name];
            }
            if (extra === '' || extra) {
                num = parseFloat(val);
                return extra === true || jQuery.isNumeric(num) ? num || 0 : val;
            }
            return val;
        }
    });
    jQuery.each([
        'height',
        'width'
    ], function (i, name) {
        jQuery.cssHooks[name] = {
            get: function (elem, computed, extra) {
                if (computed) {
                    return elem.offsetWidth === 0 && rdisplayswap.test(jQuery.css(elem, 'display')) ? jQuery.swap(elem, cssShow, function () {
                        return getWidthOrHeight(elem, name, extra);
                    }) : getWidthOrHeight(elem, name, extra);
                }
            },
            set: function (elem, value, extra) {
                var styles = extra && getStyles(elem);
                return setPositiveNumber(elem, value, extra ? augmentWidthOrHeight(elem, name, extra, support.boxSizing() && jQuery.css(elem, 'boxSizing', false, styles) === 'border-box', styles) : 0);
            }
        };
    });
    if (!support.opacity) {
        jQuery.cssHooks.opacity = {
            get: function (elem, computed) {
                return ropacity.test((computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || '') ? 0.01 * parseFloat(RegExp.$1) + '' : computed ? '1' : '';
            },
            set: function (elem, value) {
                var style = elem.style, currentStyle = elem.currentStyle, opacity = jQuery.isNumeric(value) ? 'alpha(opacity=' + value * 100 + ')' : '', filter = currentStyle && currentStyle.filter || style.filter || '';
                style.zoom = 1;
                if ((value >= 1 || value === '') && jQuery.trim(filter.replace(ralpha, '')) === '' && style.removeAttribute) {
                    style.removeAttribute('filter');
                    if (value === '' || currentStyle && !currentStyle.filter) {
                        return;
                    }
                }
                style.filter = ralpha.test(filter) ? filter.replace(ralpha, opacity) : filter + ' ' + opacity;
            }
        };
    }
    jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight, function (elem, computed) {
        if (computed) {
            return jQuery.swap(elem, { 'display': 'inline-block' }, curCSS, [
                elem,
                'marginRight'
            ]);
        }
    });
    jQuery.each({
        margin: '',
        padding: '',
        border: 'Width'
    }, function (prefix, suffix) {
        jQuery.cssHooks[prefix + suffix] = {
            expand: function (value) {
                var i = 0, expanded = {}, parts = typeof value === 'string' ? value.split(' ') : [value];
                for (; i < 4; i++) {
                    expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
                }
                return expanded;
            }
        };
        if (!rmargin.test(prefix)) {
            jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
        }
    });
    jQuery.fn.extend({
        css: function (name, value) {
            return access(this, function (elem, name, value) {
                var styles, len, map = {}, i = 0;
                if (jQuery.isArray(name)) {
                    styles = getStyles(elem);
                    len = name.length;
                    for (; i < len; i++) {
                        map[name[i]] = jQuery.css(elem, name[i], false, styles);
                    }
                    return map;
                }
                return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
            }, name, value, arguments.length > 1);
        },
        show: function () {
            return showHide(this, true);
        },
        hide: function () {
            return showHide(this);
        },
        toggle: function (state) {
            if (typeof state === 'boolean') {
                return state ? this.show() : this.hide();
            }
            return this.each(function () {
                if (isHidden(this)) {
                    jQuery(this).show();
                } else {
                    jQuery(this).hide();
                }
            });
        }
    });
    function Tween(elem, options, prop, end, easing) {
        return new Tween.prototype.init(elem, options, prop, end, easing);
    }
    jQuery.Tween = Tween;
    Tween.prototype = {
        constructor: Tween,
        init: function (elem, options, prop, end, easing, unit) {
            this.elem = elem;
            this.prop = prop;
            this.easing = easing || 'swing';
            this.options = options;
            this.start = this.now = this.cur();
            this.end = end;
            this.unit = unit || (jQuery.cssNumber[prop] ? '' : 'px');
        },
        cur: function () {
            var hooks = Tween.propHooks[this.prop];
            return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
        },
        run: function (percent) {
            var eased, hooks = Tween.propHooks[this.prop];
            if (this.options.duration) {
                this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
            } else {
                this.pos = eased = percent;
            }
            this.now = (this.end - this.start) * eased + this.start;
            if (this.options.step) {
                this.options.step.call(this.elem, this.now, this);
            }
            if (hooks && hooks.set) {
                hooks.set(this);
            } else {
                Tween.propHooks._default.set(this);
            }
            return this;
        }
    };
    Tween.prototype.init.prototype = Tween.prototype;
    Tween.propHooks = {
        _default: {
            get: function (tween) {
                var result;
                if (tween.elem[tween.prop] != null && (!tween.elem.style || tween.elem.style[tween.prop] == null)) {
                    return tween.elem[tween.prop];
                }
                result = jQuery.css(tween.elem, tween.prop, '');
                return !result || result === 'auto' ? 0 : result;
            },
            set: function (tween) {
                if (jQuery.fx.step[tween.prop]) {
                    jQuery.fx.step[tween.prop](tween);
                } else if (tween.elem.style && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
                    jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
                } else {
                    tween.elem[tween.prop] = tween.now;
                }
            }
        }
    };
    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function (tween) {
            if (tween.elem.nodeType && tween.elem.parentNode) {
                tween.elem[tween.prop] = tween.now;
            }
        }
    };
    jQuery.easing = {
        linear: function (p) {
            return p;
        },
        swing: function (p) {
            return 0.5 - Math.cos(p * Math.PI) / 2;
        }
    };
    jQuery.fx = Tween.prototype.init;
    jQuery.fx.step = {};
    var fxNow, timerId, rfxtypes = /^(?:toggle|show|hide)$/, rfxnum = new RegExp('^(?:([+-])=|)(' + pnum + ')([a-z%]*)$', 'i'), rrun = /queueHooks$/, animationPrefilters = [defaultPrefilter], tweeners = {
            '*': [function (prop, value) {
                    var tween = this.createTween(prop, value), target = tween.cur(), parts = rfxnum.exec(value), unit = parts && parts[3] || (jQuery.cssNumber[prop] ? '' : 'px'), start = (jQuery.cssNumber[prop] || unit !== 'px' && +target) && rfxnum.exec(jQuery.css(tween.elem, prop)), scale = 1, maxIterations = 20;
                    if (start && start[3] !== unit) {
                        unit = unit || start[3];
                        parts = parts || [];
                        start = +target || 1;
                        do {
                            scale = scale || '.5';
                            start = start / scale;
                            jQuery.style(tween.elem, prop, start + unit);
                        } while (scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations);
                    }
                    if (parts) {
                        start = tween.start = +start || +target || 0;
                        tween.unit = unit;
                        tween.end = parts[1] ? start + (parts[1] + 1) * parts[2] : +parts[2];
                    }
                    return tween;
                }]
        };
    function createFxNow() {
        setTimeout(function () {
            fxNow = undefined;
        });
        return fxNow = jQuery.now();
    }
    function genFx(type, includeWidth) {
        var which, attrs = { height: type }, i = 0;
        includeWidth = includeWidth ? 1 : 0;
        for (; i < 4; i += 2 - includeWidth) {
            which = cssExpand[i];
            attrs['margin' + which] = attrs['padding' + which] = type;
        }
        if (includeWidth) {
            attrs.opacity = attrs.width = type;
        }
        return attrs;
    }
    function createTween(value, prop, animation) {
        var tween, collection = (tweeners[prop] || []).concat(tweeners['*']), index = 0, length = collection.length;
        for (; index < length; index++) {
            if (tween = collection[index].call(animation, prop, value)) {
                return tween;
            }
        }
    }
    function defaultPrefilter(elem, props, opts) {
        var prop, value, toggle, tween, hooks, oldfire, display, dDisplay, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHidden(elem), dataShow = jQuery._data(elem, 'fxshow');
        if (!opts.queue) {
            hooks = jQuery._queueHooks(elem, 'fx');
            if (hooks.unqueued == null) {
                hooks.unqueued = 0;
                oldfire = hooks.empty.fire;
                hooks.empty.fire = function () {
                    if (!hooks.unqueued) {
                        oldfire();
                    }
                };
            }
            hooks.unqueued++;
            anim.always(function () {
                anim.always(function () {
                    hooks.unqueued--;
                    if (!jQuery.queue(elem, 'fx').length) {
                        hooks.empty.fire();
                    }
                });
            });
        }
        if (elem.nodeType === 1 && ('height' in props || 'width' in props)) {
            opts.overflow = [
                style.overflow,
                style.overflowX,
                style.overflowY
            ];
            display = jQuery.css(elem, 'display');
            dDisplay = defaultDisplay(elem.nodeName);
            if (display === 'none') {
                display = dDisplay;
            }
            if (display === 'inline' && jQuery.css(elem, 'float') === 'none') {
                if (!support.inlineBlockNeedsLayout || dDisplay === 'inline') {
                    style.display = 'inline-block';
                } else {
                    style.zoom = 1;
                }
            }
        }
        if (opts.overflow) {
            style.overflow = 'hidden';
            if (!support.shrinkWrapBlocks()) {
                anim.always(function () {
                    style.overflow = opts.overflow[0];
                    style.overflowX = opts.overflow[1];
                    style.overflowY = opts.overflow[2];
                });
            }
        }
        for (prop in props) {
            value = props[prop];
            if (rfxtypes.exec(value)) {
                delete props[prop];
                toggle = toggle || value === 'toggle';
                if (value === (hidden ? 'hide' : 'show')) {
                    if (value === 'show' && dataShow && dataShow[prop] !== undefined) {
                        hidden = true;
                    } else {
                        continue;
                    }
                }
                orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
            }
        }
        if (!jQuery.isEmptyObject(orig)) {
            if (dataShow) {
                if ('hidden' in dataShow) {
                    hidden = dataShow.hidden;
                }
            } else {
                dataShow = jQuery._data(elem, 'fxshow', {});
            }
            if (toggle) {
                dataShow.hidden = !hidden;
            }
            if (hidden) {
                jQuery(elem).show();
            } else {
                anim.done(function () {
                    jQuery(elem).hide();
                });
            }
            anim.done(function () {
                var prop;
                jQuery._removeData(elem, 'fxshow');
                for (prop in orig) {
                    jQuery.style(elem, prop, orig[prop]);
                }
            });
            for (prop in orig) {
                tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
                if (!(prop in dataShow)) {
                    dataShow[prop] = tween.start;
                    if (hidden) {
                        tween.end = tween.start;
                        tween.start = prop === 'width' || prop === 'height' ? 1 : 0;
                    }
                }
            }
        }
    }
    function propFilter(props, specialEasing) {
        var index, name, easing, value, hooks;
        for (index in props) {
            name = jQuery.camelCase(index);
            easing = specialEasing[name];
            value = props[index];
            if (jQuery.isArray(value)) {
                easing = value[1];
                value = props[index] = value[0];
            }
            if (index !== name) {
                props[name] = value;
                delete props[index];
            }
            hooks = jQuery.cssHooks[name];
            if (hooks && 'expand' in hooks) {
                value = hooks.expand(value);
                delete props[name];
                for (index in value) {
                    if (!(index in props)) {
                        props[index] = value[index];
                        specialEasing[index] = easing;
                    }
                }
            } else {
                specialEasing[name] = easing;
            }
        }
    }
    function Animation(elem, properties, options) {
        var result, stopped, index = 0, length = animationPrefilters.length, deferred = jQuery.Deferred().always(function () {
                delete tick.elem;
            }), tick = function () {
                if (stopped) {
                    return false;
                }
                var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0, length = animation.tweens.length;
                for (; index < length; index++) {
                    animation.tweens[index].run(percent);
                }
                deferred.notifyWith(elem, [
                    animation,
                    percent,
                    remaining
                ]);
                if (percent < 1 && length) {
                    return remaining;
                } else {
                    deferred.resolveWith(elem, [animation]);
                    return false;
                }
            }, animation = deferred.promise({
                elem: elem,
                props: jQuery.extend({}, properties),
                opts: jQuery.extend(true, { specialEasing: {} }, options),
                originalProperties: properties,
                originalOptions: options,
                startTime: fxNow || createFxNow(),
                duration: options.duration,
                tweens: [],
                createTween: function (prop, end) {
                    var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
                    animation.tweens.push(tween);
                    return tween;
                },
                stop: function (gotoEnd) {
                    var index = 0, length = gotoEnd ? animation.tweens.length : 0;
                    if (stopped) {
                        return this;
                    }
                    stopped = true;
                    for (; index < length; index++) {
                        animation.tweens[index].run(1);
                    }
                    if (gotoEnd) {
                        deferred.resolveWith(elem, [
                            animation,
                            gotoEnd
                        ]);
                    } else {
                        deferred.rejectWith(elem, [
                            animation,
                            gotoEnd
                        ]);
                    }
                    return this;
                }
            }), props = animation.props;
        propFilter(props, animation.opts.specialEasing);
        for (; index < length; index++) {
            result = animationPrefilters[index].call(animation, elem, props, animation.opts);
            if (result) {
                return result;
            }
        }
        jQuery.map(props, createTween, animation);
        if (jQuery.isFunction(animation.opts.start)) {
            animation.opts.start.call(elem, animation);
        }
        jQuery.fx.timer(jQuery.extend(tick, {
            elem: elem,
            anim: animation,
            queue: animation.opts.queue
        }));
        return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
    }
    jQuery.Animation = jQuery.extend(Animation, {
        tweener: function (props, callback) {
            if (jQuery.isFunction(props)) {
                callback = props;
                props = ['*'];
            } else {
                props = props.split(' ');
            }
            var prop, index = 0, length = props.length;
            for (; index < length; index++) {
                prop = props[index];
                tweeners[prop] = tweeners[prop] || [];
                tweeners[prop].unshift(callback);
            }
        },
        prefilter: function (callback, prepend) {
            if (prepend) {
                animationPrefilters.unshift(callback);
            } else {
                animationPrefilters.push(callback);
            }
        }
    });
    jQuery.speed = function (speed, easing, fn) {
        var opt = speed && typeof speed === 'object' ? jQuery.extend({}, speed) : {
            complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
            duration: speed,
            easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
        };
        opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === 'number' ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;
        if (opt.queue == null || opt.queue === true) {
            opt.queue = 'fx';
        }
        opt.old = opt.complete;
        opt.complete = function () {
            if (jQuery.isFunction(opt.old)) {
                opt.old.call(this);
            }
            if (opt.queue) {
                jQuery.dequeue(this, opt.queue);
            }
        };
        return opt;
    };
    jQuery.fn.extend({
        fadeTo: function (speed, to, easing, callback) {
            return this.filter(isHidden).css('opacity', 0).show().end().animate({ opacity: to }, speed, easing, callback);
        },
        animate: function (prop, speed, easing, callback) {
            var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function () {
                    var anim = Animation(this, jQuery.extend({}, prop), optall);
                    if (empty || jQuery._data(this, 'finish')) {
                        anim.stop(true);
                    }
                };
            doAnimation.finish = doAnimation;
            return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
        },
        stop: function (type, clearQueue, gotoEnd) {
            var stopQueue = function (hooks) {
                var stop = hooks.stop;
                delete hooks.stop;
                stop(gotoEnd);
            };
            if (typeof type !== 'string') {
                gotoEnd = clearQueue;
                clearQueue = type;
                type = undefined;
            }
            if (clearQueue && type !== false) {
                this.queue(type || 'fx', []);
            }
            return this.each(function () {
                var dequeue = true, index = type != null && type + 'queueHooks', timers = jQuery.timers, data = jQuery._data(this);
                if (index) {
                    if (data[index] && data[index].stop) {
                        stopQueue(data[index]);
                    }
                } else {
                    for (index in data) {
                        if (data[index] && data[index].stop && rrun.test(index)) {
                            stopQueue(data[index]);
                        }
                    }
                }
                for (index = timers.length; index--;) {
                    if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                        timers[index].anim.stop(gotoEnd);
                        dequeue = false;
                        timers.splice(index, 1);
                    }
                }
                if (dequeue || !gotoEnd) {
                    jQuery.dequeue(this, type);
                }
            });
        },
        finish: function (type) {
            if (type !== false) {
                type = type || 'fx';
            }
            return this.each(function () {
                var index, data = jQuery._data(this), queue = data[type + 'queue'], hooks = data[type + 'queueHooks'], timers = jQuery.timers, length = queue ? queue.length : 0;
                data.finish = true;
                jQuery.queue(this, type, []);
                if (hooks && hooks.stop) {
                    hooks.stop.call(this, true);
                }
                for (index = timers.length; index--;) {
                    if (timers[index].elem === this && timers[index].queue === type) {
                        timers[index].anim.stop(true);
                        timers.splice(index, 1);
                    }
                }
                for (index = 0; index < length; index++) {
                    if (queue[index] && queue[index].finish) {
                        queue[index].finish.call(this);
                    }
                }
                delete data.finish;
            });
        }
    });
    jQuery.each([
        'toggle',
        'show',
        'hide'
    ], function (i, name) {
        var cssFn = jQuery.fn[name];
        jQuery.fn[name] = function (speed, easing, callback) {
            return speed == null || typeof speed === 'boolean' ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
        };
    });
    jQuery.each({
        slideDown: genFx('show'),
        slideUp: genFx('hide'),
        slideToggle: genFx('toggle'),
        fadeIn: { opacity: 'show' },
        fadeOut: { opacity: 'hide' },
        fadeToggle: { opacity: 'toggle' }
    }, function (name, props) {
        jQuery.fn[name] = function (speed, easing, callback) {
            return this.animate(props, speed, easing, callback);
        };
    });
    jQuery.timers = [];
    jQuery.fx.tick = function () {
        var timer, timers = jQuery.timers, i = 0;
        fxNow = jQuery.now();
        for (; i < timers.length; i++) {
            timer = timers[i];
            if (!timer() && timers[i] === timer) {
                timers.splice(i--, 1);
            }
        }
        if (!timers.length) {
            jQuery.fx.stop();
        }
        fxNow = undefined;
    };
    jQuery.fx.timer = function (timer) {
        jQuery.timers.push(timer);
        if (timer()) {
            jQuery.fx.start();
        } else {
            jQuery.timers.pop();
        }
    };
    jQuery.fx.interval = 13;
    jQuery.fx.start = function () {
        if (!timerId) {
            timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval);
        }
    };
    jQuery.fx.stop = function () {
        clearInterval(timerId);
        timerId = null;
    };
    jQuery.fx.speeds = {
        slow: 600,
        fast: 200,
        _default: 400
    };
    jQuery.fn.delay = function (time, type) {
        time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
        type = type || 'fx';
        return this.queue(type, function (next, hooks) {
            var timeout = setTimeout(next, time);
            hooks.stop = function () {
                clearTimeout(timeout);
            };
        });
    };
    (function () {
        var a, input, select, opt, div = document.createElement('div');
        div.setAttribute('className', 't');
        div.innerHTML = '  <link/><table></table><a href=\'/a\'>a</a><input type=\'checkbox\'/>';
        a = div.getElementsByTagName('a')[0];
        select = document.createElement('select');
        opt = select.appendChild(document.createElement('option'));
        input = div.getElementsByTagName('input')[0];
        a.style.cssText = 'top:1px';
        support.getSetAttribute = div.className !== 't';
        support.style = /top/.test(a.getAttribute('style'));
        support.hrefNormalized = a.getAttribute('href') === '/a';
        support.checkOn = !!input.value;
        support.optSelected = opt.selected;
        support.enctype = !!document.createElement('form').enctype;
        select.disabled = true;
        support.optDisabled = !opt.disabled;
        input = document.createElement('input');
        input.setAttribute('value', '');
        support.input = input.getAttribute('value') === '';
        input.value = 't';
        input.setAttribute('type', 'radio');
        support.radioValue = input.value === 't';
        a = input = select = opt = div = null;
    }());
    var rreturn = /\r/g;
    jQuery.fn.extend({
        val: function (value) {
            var hooks, ret, isFunction, elem = this[0];
            if (!arguments.length) {
                if (elem) {
                    hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
                    if (hooks && 'get' in hooks && (ret = hooks.get(elem, 'value')) !== undefined) {
                        return ret;
                    }
                    ret = elem.value;
                    return typeof ret === 'string' ? ret.replace(rreturn, '') : ret == null ? '' : ret;
                }
                return;
            }
            isFunction = jQuery.isFunction(value);
            return this.each(function (i) {
                var val;
                if (this.nodeType !== 1) {
                    return;
                }
                if (isFunction) {
                    val = value.call(this, i, jQuery(this).val());
                } else {
                    val = value;
                }
                if (val == null) {
                    val = '';
                } else if (typeof val === 'number') {
                    val += '';
                } else if (jQuery.isArray(val)) {
                    val = jQuery.map(val, function (value) {
                        return value == null ? '' : value + '';
                    });
                }
                hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
                if (!hooks || !('set' in hooks) || hooks.set(this, val, 'value') === undefined) {
                    this.value = val;
                }
            });
        }
    });
    jQuery.extend({
        valHooks: {
            option: {
                get: function (elem) {
                    var val = jQuery.find.attr(elem, 'value');
                    return val != null ? val : jQuery.text(elem);
                }
            },
            select: {
                get: function (elem) {
                    var value, option, options = elem.options, index = elem.selectedIndex, one = elem.type === 'select-one' || index < 0, values = one ? null : [], max = one ? index + 1 : options.length, i = index < 0 ? max : one ? index : 0;
                    for (; i < max; i++) {
                        option = options[i];
                        if ((option.selected || i === index) && (support.optDisabled ? !option.disabled : option.getAttribute('disabled') === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, 'optgroup'))) {
                            value = jQuery(option).val();
                            if (one) {
                                return value;
                            }
                            values.push(value);
                        }
                    }
                    return values;
                },
                set: function (elem, value) {
                    var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length;
                    while (i--) {
                        option = options[i];
                        if (jQuery.inArray(jQuery.valHooks.option.get(option), values) >= 0) {
                            try {
                                option.selected = optionSet = true;
                            } catch (_) {
                                option.scrollHeight;
                            }
                        } else {
                            option.selected = false;
                        }
                    }
                    if (!optionSet) {
                        elem.selectedIndex = -1;
                    }
                    return options;
                }
            }
        }
    });
    jQuery.each([
        'radio',
        'checkbox'
    ], function () {
        jQuery.valHooks[this] = {
            set: function (elem, value) {
                if (jQuery.isArray(value)) {
                    return elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0;
                }
            }
        };
        if (!support.checkOn) {
            jQuery.valHooks[this].get = function (elem) {
                return elem.getAttribute('value') === null ? 'on' : elem.value;
            };
        }
    });
    var nodeHook, boolHook, attrHandle = jQuery.expr.attrHandle, ruseDefault = /^(?:checked|selected)$/i, getSetAttribute = support.getSetAttribute, getSetInput = support.input;
    jQuery.fn.extend({
        attr: function (name, value) {
            return access(this, jQuery.attr, name, value, arguments.length > 1);
        },
        removeAttr: function (name) {
            return this.each(function () {
                jQuery.removeAttr(this, name);
            });
        }
    });
    jQuery.extend({
        attr: function (elem, name, value) {
            var hooks, ret, nType = elem.nodeType;
            if (!elem || nType === 3 || nType === 8 || nType === 2) {
                return;
            }
            if (typeof elem.getAttribute === strundefined) {
                return jQuery.prop(elem, name, value);
            }
            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                name = name.toLowerCase();
                hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : nodeHook);
            }
            if (value !== undefined) {
                if (value === null) {
                    jQuery.removeAttr(elem, name);
                } else if (hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret;
                } else {
                    elem.setAttribute(name, value + '');
                    return value;
                }
            } else if (hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null) {
                return ret;
            } else {
                ret = jQuery.find.attr(elem, name);
                return ret == null ? undefined : ret;
            }
        },
        removeAttr: function (elem, value) {
            var name, propName, i = 0, attrNames = value && value.match(rnotwhite);
            if (attrNames && elem.nodeType === 1) {
                while (name = attrNames[i++]) {
                    propName = jQuery.propFix[name] || name;
                    if (jQuery.expr.match.bool.test(name)) {
                        if (getSetInput && getSetAttribute || !ruseDefault.test(name)) {
                            elem[propName] = false;
                        } else {
                            elem[jQuery.camelCase('default-' + name)] = elem[propName] = false;
                        }
                    } else {
                        jQuery.attr(elem, name, '');
                    }
                    elem.removeAttribute(getSetAttribute ? name : propName);
                }
            }
        },
        attrHooks: {
            type: {
                set: function (elem, value) {
                    if (!support.radioValue && value === 'radio' && jQuery.nodeName(elem, 'input')) {
                        var val = elem.value;
                        elem.setAttribute('type', value);
                        if (val) {
                            elem.value = val;
                        }
                        return value;
                    }
                }
            }
        }
    });
    boolHook = {
        set: function (elem, value, name) {
            if (value === false) {
                jQuery.removeAttr(elem, name);
            } else if (getSetInput && getSetAttribute || !ruseDefault.test(name)) {
                elem.setAttribute(!getSetAttribute && jQuery.propFix[name] || name, name);
            } else {
                elem[jQuery.camelCase('default-' + name)] = elem[name] = true;
            }
            return name;
        }
    };
    jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
        var getter = attrHandle[name] || jQuery.find.attr;
        attrHandle[name] = getSetInput && getSetAttribute || !ruseDefault.test(name) ? function (elem, name, isXML) {
            var ret, handle;
            if (!isXML) {
                handle = attrHandle[name];
                attrHandle[name] = ret;
                ret = getter(elem, name, isXML) != null ? name.toLowerCase() : null;
                attrHandle[name] = handle;
            }
            return ret;
        } : function (elem, name, isXML) {
            if (!isXML) {
                return elem[jQuery.camelCase('default-' + name)] ? name.toLowerCase() : null;
            }
        };
    });
    if (!getSetInput || !getSetAttribute) {
        jQuery.attrHooks.value = {
            set: function (elem, value, name) {
                if (jQuery.nodeName(elem, 'input')) {
                    elem.defaultValue = value;
                } else {
                    return nodeHook && nodeHook.set(elem, value, name);
                }
            }
        };
    }
    if (!getSetAttribute) {
        nodeHook = {
            set: function (elem, value, name) {
                var ret = elem.getAttributeNode(name);
                if (!ret) {
                    elem.setAttributeNode(ret = elem.ownerDocument.createAttribute(name));
                }
                ret.value = value += '';
                if (name === 'value' || value === elem.getAttribute(name)) {
                    return value;
                }
            }
        };
        attrHandle.id = attrHandle.name = attrHandle.coords = function (elem, name, isXML) {
            var ret;
            if (!isXML) {
                return (ret = elem.getAttributeNode(name)) && ret.value !== '' ? ret.value : null;
            }
        };
        jQuery.valHooks.button = {
            get: function (elem, name) {
                var ret = elem.getAttributeNode(name);
                if (ret && ret.specified) {
                    return ret.value;
                }
            },
            set: nodeHook.set
        };
        jQuery.attrHooks.contenteditable = {
            set: function (elem, value, name) {
                nodeHook.set(elem, value === '' ? false : value, name);
            }
        };
        jQuery.each([
            'width',
            'height'
        ], function (i, name) {
            jQuery.attrHooks[name] = {
                set: function (elem, value) {
                    if (value === '') {
                        elem.setAttribute(name, 'auto');
                        return value;
                    }
                }
            };
        });
    }
    if (!support.style) {
        jQuery.attrHooks.style = {
            get: function (elem) {
                return elem.style.cssText || undefined;
            },
            set: function (elem, value) {
                return elem.style.cssText = value + '';
            }
        };
    }
    var rfocusable = /^(?:input|select|textarea|button|object)$/i, rclickable = /^(?:a|area)$/i;
    jQuery.fn.extend({
        prop: function (name, value) {
            return access(this, jQuery.prop, name, value, arguments.length > 1);
        },
        removeProp: function (name) {
            name = jQuery.propFix[name] || name;
            return this.each(function () {
                try {
                    this[name] = undefined;
                    delete this[name];
                } catch (e) {
                }
            });
        }
    });
    jQuery.extend({
        propFix: {
            'for': 'htmlFor',
            'class': 'className'
        },
        prop: function (elem, name, value) {
            var ret, hooks, notxml, nType = elem.nodeType;
            if (!elem || nType === 3 || nType === 8 || nType === 2) {
                return;
            }
            notxml = nType !== 1 || !jQuery.isXMLDoc(elem);
            if (notxml) {
                name = jQuery.propFix[name] || name;
                hooks = jQuery.propHooks[name];
            }
            if (value !== undefined) {
                return hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined ? ret : elem[name] = value;
            } else {
                return hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null ? ret : elem[name];
            }
        },
        propHooks: {
            tabIndex: {
                get: function (elem) {
                    var tabindex = jQuery.find.attr(elem, 'tabindex');
                    return tabindex ? parseInt(tabindex, 10) : rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ? 0 : -1;
                }
            }
        }
    });
    if (!support.hrefNormalized) {
        jQuery.each([
            'href',
            'src'
        ], function (i, name) {
            jQuery.propHooks[name] = {
                get: function (elem) {
                    return elem.getAttribute(name, 4);
                }
            };
        });
    }
    if (!support.optSelected) {
        jQuery.propHooks.selected = {
            get: function (elem) {
                var parent = elem.parentNode;
                if (parent) {
                    parent.selectedIndex;
                    if (parent.parentNode) {
                        parent.parentNode.selectedIndex;
                    }
                }
                return null;
            }
        };
    }
    jQuery.each([
        'tabIndex',
        'readOnly',
        'maxLength',
        'cellSpacing',
        'cellPadding',
        'rowSpan',
        'colSpan',
        'useMap',
        'frameBorder',
        'contentEditable'
    ], function () {
        jQuery.propFix[this.toLowerCase()] = this;
    });
    if (!support.enctype) {
        jQuery.propFix.enctype = 'encoding';
    }
    var rclass = /[\t\r\n\f]/g;
    jQuery.fn.extend({
        addClass: function (value) {
            var classes, elem, cur, clazz, j, finalValue, i = 0, len = this.length, proceed = typeof value === 'string' && value;
            if (jQuery.isFunction(value)) {
                return this.each(function (j) {
                    jQuery(this).addClass(value.call(this, j, this.className));
                });
            }
            if (proceed) {
                classes = (value || '').match(rnotwhite) || [];
                for (; i < len; i++) {
                    elem = this[i];
                    cur = elem.nodeType === 1 && (elem.className ? (' ' + elem.className + ' ').replace(rclass, ' ') : ' ');
                    if (cur) {
                        j = 0;
                        while (clazz = classes[j++]) {
                            if (cur.indexOf(' ' + clazz + ' ') < 0) {
                                cur += clazz + ' ';
                            }
                        }
                        finalValue = jQuery.trim(cur);
                        if (elem.className !== finalValue) {
                            elem.className = finalValue;
                        }
                    }
                }
            }
            return this;
        },
        removeClass: function (value) {
            var classes, elem, cur, clazz, j, finalValue, i = 0, len = this.length, proceed = arguments.length === 0 || typeof value === 'string' && value;
            if (jQuery.isFunction(value)) {
                return this.each(function (j) {
                    jQuery(this).removeClass(value.call(this, j, this.className));
                });
            }
            if (proceed) {
                classes = (value || '').match(rnotwhite) || [];
                for (; i < len; i++) {
                    elem = this[i];
                    cur = elem.nodeType === 1 && (elem.className ? (' ' + elem.className + ' ').replace(rclass, ' ') : '');
                    if (cur) {
                        j = 0;
                        while (clazz = classes[j++]) {
                            while (cur.indexOf(' ' + clazz + ' ') >= 0) {
                                cur = cur.replace(' ' + clazz + ' ', ' ');
                            }
                        }
                        finalValue = value ? jQuery.trim(cur) : '';
                        if (elem.className !== finalValue) {
                            elem.className = finalValue;
                        }
                    }
                }
            }
            return this;
        },
        toggleClass: function (value, stateVal) {
            var type = typeof value;
            if (typeof stateVal === 'boolean' && type === 'string') {
                return stateVal ? this.addClass(value) : this.removeClass(value);
            }
            if (jQuery.isFunction(value)) {
                return this.each(function (i) {
                    jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
                });
            }
            return this.each(function () {
                if (type === 'string') {
                    var className, i = 0, self = jQuery(this), classNames = value.match(rnotwhite) || [];
                    while (className = classNames[i++]) {
                        if (self.hasClass(className)) {
                            self.removeClass(className);
                        } else {
                            self.addClass(className);
                        }
                    }
                } else if (type === strundefined || type === 'boolean') {
                    if (this.className) {
                        jQuery._data(this, '__className__', this.className);
                    }
                    this.className = this.className || value === false ? '' : jQuery._data(this, '__className__') || '';
                }
            });
        },
        hasClass: function (selector) {
            var className = ' ' + selector + ' ', i = 0, l = this.length;
            for (; i < l; i++) {
                if (this[i].nodeType === 1 && (' ' + this[i].className + ' ').replace(rclass, ' ').indexOf(className) >= 0) {
                    return true;
                }
            }
            return false;
        }
    });
    jQuery.each(('blur focus focusin focusout load resize scroll unload click dblclick ' + 'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave ' + 'change select submit keydown keypress keyup error contextmenu').split(' '), function (i, name) {
        jQuery.fn[name] = function (data, fn) {
            return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
        };
    });
    jQuery.fn.extend({
        hover: function (fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
        },
        bind: function (types, data, fn) {
            return this.on(types, null, data, fn);
        },
        unbind: function (types, fn) {
            return this.off(types, null, fn);
        },
        delegate: function (selector, types, data, fn) {
            return this.on(types, selector, data, fn);
        },
        undelegate: function (selector, types, fn) {
            return arguments.length === 1 ? this.off(selector, '**') : this.off(types, selector || '**', fn);
        }
    });
    var nonce = jQuery.now();
    var rquery = /\?/;
    var rvalidtokens = /(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;
    jQuery.parseJSON = function (data) {
        if (window.JSON && window.JSON.parse) {
            return window.JSON.parse(data + '');
        }
        var requireNonComma, depth = null, str = jQuery.trim(data + '');
        return str && !jQuery.trim(str.replace(rvalidtokens, function (token, comma, open, close) {
            if (requireNonComma && comma) {
                depth = 0;
            }
            if (depth === 0) {
                return token;
            }
            requireNonComma = open || comma;
            depth += !close - !open;
            return '';
        })) ? Function('return ' + str)() : jQuery.error('Invalid JSON: ' + data);
    };
    jQuery.parseXML = function (data) {
        var xml, tmp;
        if (!data || typeof data !== 'string') {
            return null;
        }
        try {
            if (window.DOMParser) {
                tmp = new DOMParser();
                xml = tmp.parseFromString(data, 'text/xml');
            } else {
                xml = new ActiveXObject('Microsoft.XMLDOM');
                xml.async = 'false';
                xml.loadXML(data);
            }
        } catch (e) {
            xml = undefined;
        }
        if (!xml || !xml.documentElement || xml.getElementsByTagName('parsererror').length) {
            jQuery.error('Invalid XML: ' + data);
        }
        return xml;
    };
    var ajaxLocParts, ajaxLocation, rhash = /#.*$/, rts = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/gm, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/, prefilters = {}, transports = {}, allTypes = '*/'.concat('*');
    try {
        ajaxLocation = location.href;
    } catch (e) {
        ajaxLocation = document.createElement('a');
        ajaxLocation.href = '';
        ajaxLocation = ajaxLocation.href;
    }
    ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];
    function addToPrefiltersOrTransports(structure) {
        return function (dataTypeExpression, func) {
            if (typeof dataTypeExpression !== 'string') {
                func = dataTypeExpression;
                dataTypeExpression = '*';
            }
            var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];
            if (jQuery.isFunction(func)) {
                while (dataType = dataTypes[i++]) {
                    if (dataType.charAt(0) === '+') {
                        dataType = dataType.slice(1) || '*';
                        (structure[dataType] = structure[dataType] || []).unshift(func);
                    } else {
                        (structure[dataType] = structure[dataType] || []).push(func);
                    }
                }
            }
        };
    }
    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
        var inspected = {}, seekingTransport = structure === transports;
        function inspect(dataType) {
            var selected;
            inspected[dataType] = true;
            jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
                var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                if (typeof dataTypeOrTransport === 'string' && !seekingTransport && !inspected[dataTypeOrTransport]) {
                    options.dataTypes.unshift(dataTypeOrTransport);
                    inspect(dataTypeOrTransport);
                    return false;
                } else if (seekingTransport) {
                    return !(selected = dataTypeOrTransport);
                }
            });
            return selected;
        }
        return inspect(options.dataTypes[0]) || !inspected['*'] && inspect('*');
    }
    function ajaxExtend(target, src) {
        var deep, key, flatOptions = jQuery.ajaxSettings.flatOptions || {};
        for (key in src) {
            if (src[key] !== undefined) {
                (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
            }
        }
        if (deep) {
            jQuery.extend(true, target, deep);
        }
        return target;
    }
    function ajaxHandleResponses(s, jqXHR, responses) {
        var firstDataType, ct, finalDataType, type, contents = s.contents, dataTypes = s.dataTypes;
        while (dataTypes[0] === '*') {
            dataTypes.shift();
            if (ct === undefined) {
                ct = s.mimeType || jqXHR.getResponseHeader('Content-Type');
            }
        }
        if (ct) {
            for (type in contents) {
                if (contents[type] && contents[type].test(ct)) {
                    dataTypes.unshift(type);
                    break;
                }
            }
        }
        if (dataTypes[0] in responses) {
            finalDataType = dataTypes[0];
        } else {
            for (type in responses) {
                if (!dataTypes[0] || s.converters[type + ' ' + dataTypes[0]]) {
                    finalDataType = type;
                    break;
                }
                if (!firstDataType) {
                    firstDataType = type;
                }
            }
            finalDataType = finalDataType || firstDataType;
        }
        if (finalDataType) {
            if (finalDataType !== dataTypes[0]) {
                dataTypes.unshift(finalDataType);
            }
            return responses[finalDataType];
        }
    }
    function ajaxConvert(s, response, jqXHR, isSuccess) {
        var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s.dataTypes.slice();
        if (dataTypes[1]) {
            for (conv in s.converters) {
                converters[conv.toLowerCase()] = s.converters[conv];
            }
        }
        current = dataTypes.shift();
        while (current) {
            if (s.responseFields[current]) {
                jqXHR[s.responseFields[current]] = response;
            }
            if (!prev && isSuccess && s.dataFilter) {
                response = s.dataFilter(response, s.dataType);
            }
            prev = current;
            current = dataTypes.shift();
            if (current) {
                if (current === '*') {
                    current = prev;
                } else if (prev !== '*' && prev !== current) {
                    conv = converters[prev + ' ' + current] || converters['* ' + current];
                    if (!conv) {
                        for (conv2 in converters) {
                            tmp = conv2.split(' ');
                            if (tmp[1] === current) {
                                conv = converters[prev + ' ' + tmp[0]] || converters['* ' + tmp[0]];
                                if (conv) {
                                    if (conv === true) {
                                        conv = converters[conv2];
                                    } else if (converters[conv2] !== true) {
                                        current = tmp[0];
                                        dataTypes.unshift(tmp[1]);
                                    }
                                    break;
                                }
                            }
                        }
                    }
                    if (conv !== true) {
                        if (conv && s['throws']) {
                            response = conv(response);
                        } else {
                            try {
                                response = conv(response);
                            } catch (e) {
                                return {
                                    state: 'parsererror',
                                    error: conv ? e : 'No conversion from ' + prev + ' to ' + current
                                };
                            }
                        }
                    }
                }
            }
        }
        return {
            state: 'success',
            data: response
        };
    }
    jQuery.extend({
        active: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: {
            url: ajaxLocation,
            type: 'GET',
            isLocal: rlocalProtocol.test(ajaxLocParts[1]),
            global: true,
            processData: true,
            async: true,
            contentType: 'application/x-www-form-urlencoded; charset=UTF-8',
            accepts: {
                '*': allTypes,
                text: 'text/plain',
                html: 'text/html',
                xml: 'application/xml, text/xml',
                json: 'application/json, text/javascript'
            },
            contents: {
                xml: /xml/,
                html: /html/,
                json: /json/
            },
            responseFields: {
                xml: 'responseXML',
                text: 'responseText',
                json: 'responseJSON'
            },
            converters: {
                '* text': String,
                'text html': true,
                'text json': jQuery.parseJSON,
                'text xml': jQuery.parseXML
            },
            flatOptions: {
                url: true,
                context: true
            }
        },
        ajaxSetup: function (target, settings) {
            return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
        },
        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),
        ajax: function (url, options) {
            if (typeof url === 'object') {
                options = url;
                url = undefined;
            }
            options = options || {};
            var parts, i, cacheURL, responseHeadersString, timeoutTimer, fireGlobals, transport, responseHeaders, s = jQuery.ajaxSetup({}, options), callbackContext = s.context || s, globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks('once memory'), statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, state = 0, strAbort = 'canceled', jqXHR = {
                    readyState: 0,
                    getResponseHeader: function (key) {
                        var match;
                        if (state === 2) {
                            if (!responseHeaders) {
                                responseHeaders = {};
                                while (match = rheaders.exec(responseHeadersString)) {
                                    responseHeaders[match[1].toLowerCase()] = match[2];
                                }
                            }
                            match = responseHeaders[key.toLowerCase()];
                        }
                        return match == null ? null : match;
                    },
                    getAllResponseHeaders: function () {
                        return state === 2 ? responseHeadersString : null;
                    },
                    setRequestHeader: function (name, value) {
                        var lname = name.toLowerCase();
                        if (!state) {
                            name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
                            requestHeaders[name] = value;
                        }
                        return this;
                    },
                    overrideMimeType: function (type) {
                        if (!state) {
                            s.mimeType = type;
                        }
                        return this;
                    },
                    statusCode: function (map) {
                        var code;
                        if (map) {
                            if (state < 2) {
                                for (code in map) {
                                    statusCode[code] = [
                                        statusCode[code],
                                        map[code]
                                    ];
                                }
                            } else {
                                jqXHR.always(map[jqXHR.status]);
                            }
                        }
                        return this;
                    },
                    abort: function (statusText) {
                        var finalText = statusText || strAbort;
                        if (transport) {
                            transport.abort(finalText);
                        }
                        done(0, finalText);
                        return this;
                    }
                };
            deferred.promise(jqXHR).complete = completeDeferred.add;
            jqXHR.success = jqXHR.done;
            jqXHR.error = jqXHR.fail;
            s.url = ((url || s.url || ajaxLocation) + '').replace(rhash, '').replace(rprotocol, ajaxLocParts[1] + '//');
            s.type = options.method || options.type || s.method || s.type;
            s.dataTypes = jQuery.trim(s.dataType || '*').toLowerCase().match(rnotwhite) || [''];
            if (s.crossDomain == null) {
                parts = rurl.exec(s.url.toLowerCase());
                s.crossDomain = !!(parts && (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] || (parts[3] || (parts[1] === 'http:' ? '80' : '443')) !== (ajaxLocParts[3] || (ajaxLocParts[1] === 'http:' ? '80' : '443'))));
            }
            if (s.data && s.processData && typeof s.data !== 'string') {
                s.data = jQuery.param(s.data, s.traditional);
            }
            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
            if (state === 2) {
                return jqXHR;
            }
            fireGlobals = s.global;
            if (fireGlobals && jQuery.active++ === 0) {
                jQuery.event.trigger('ajaxStart');
            }
            s.type = s.type.toUpperCase();
            s.hasContent = !rnoContent.test(s.type);
            cacheURL = s.url;
            if (!s.hasContent) {
                if (s.data) {
                    cacheURL = s.url += (rquery.test(cacheURL) ? '&' : '?') + s.data;
                    delete s.data;
                }
                if (s.cache === false) {
                    s.url = rts.test(cacheURL) ? cacheURL.replace(rts, '$1_=' + nonce++) : cacheURL + (rquery.test(cacheURL) ? '&' : '?') + '_=' + nonce++;
                }
            }
            if (s.ifModified) {
                if (jQuery.lastModified[cacheURL]) {
                    jqXHR.setRequestHeader('If-Modified-Since', jQuery.lastModified[cacheURL]);
                }
                if (jQuery.etag[cacheURL]) {
                    jqXHR.setRequestHeader('If-None-Match', jQuery.etag[cacheURL]);
                }
            }
            if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
                jqXHR.setRequestHeader('Content-Type', s.contentType);
            }
            jqXHR.setRequestHeader('Accept', s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== '*' ? ', ' + allTypes + '; q=0.01' : '') : s.accepts['*']);
            for (i in s.headers) {
                jqXHR.setRequestHeader(i, s.headers[i]);
            }
            if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
                return jqXHR.abort();
            }
            strAbort = 'abort';
            for (i in {
                    success: 1,
                    error: 1,
                    complete: 1
                }) {
                jqXHR[i](s[i]);
            }
            transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
            if (!transport) {
                done(-1, 'No Transport');
            } else {
                jqXHR.readyState = 1;
                if (fireGlobals) {
                    globalEventContext.trigger('ajaxSend', [
                        jqXHR,
                        s
                    ]);
                }
                if (s.async && s.timeout > 0) {
                    timeoutTimer = setTimeout(function () {
                        jqXHR.abort('timeout');
                    }, s.timeout);
                }
                try {
                    state = 1;
                    transport.send(requestHeaders, done);
                } catch (e) {
                    if (state < 2) {
                        done(-1, e);
                    } else {
                        throw e;
                    }
                }
            }
            function done(status, nativeStatusText, responses, headers) {
                var isSuccess, success, error, response, modified, statusText = nativeStatusText;
                if (state === 2) {
                    return;
                }
                state = 2;
                if (timeoutTimer) {
                    clearTimeout(timeoutTimer);
                }
                transport = undefined;
                responseHeadersString = headers || '';
                jqXHR.readyState = status > 0 ? 4 : 0;
                isSuccess = status >= 200 && status < 300 || status === 304;
                if (responses) {
                    response = ajaxHandleResponses(s, jqXHR, responses);
                }
                response = ajaxConvert(s, response, jqXHR, isSuccess);
                if (isSuccess) {
                    if (s.ifModified) {
                        modified = jqXHR.getResponseHeader('Last-Modified');
                        if (modified) {
                            jQuery.lastModified[cacheURL] = modified;
                        }
                        modified = jqXHR.getResponseHeader('etag');
                        if (modified) {
                            jQuery.etag[cacheURL] = modified;
                        }
                    }
                    if (status === 204 || s.type === 'HEAD') {
                        statusText = 'nocontent';
                    } else if (status === 304) {
                        statusText = 'notmodified';
                    } else {
                        statusText = response.state;
                        success = response.data;
                        error = response.error;
                        isSuccess = !error;
                    }
                } else {
                    error = statusText;
                    if (status || !statusText) {
                        statusText = 'error';
                        if (status < 0) {
                            status = 0;
                        }
                    }
                }
                jqXHR.status = status;
                jqXHR.statusText = (nativeStatusText || statusText) + '';
                if (isSuccess) {
                    deferred.resolveWith(callbackContext, [
                        success,
                        statusText,
                        jqXHR
                    ]);
                } else {
                    deferred.rejectWith(callbackContext, [
                        jqXHR,
                        statusText,
                        error
                    ]);
                }
                jqXHR.statusCode(statusCode);
                statusCode = undefined;
                if (fireGlobals) {
                    globalEventContext.trigger(isSuccess ? 'ajaxSuccess' : 'ajaxError', [
                        jqXHR,
                        s,
                        isSuccess ? success : error
                    ]);
                }
                completeDeferred.fireWith(callbackContext, [
                    jqXHR,
                    statusText
                ]);
                if (fireGlobals) {
                    globalEventContext.trigger('ajaxComplete', [
                        jqXHR,
                        s
                    ]);
                    if (!--jQuery.active) {
                        jQuery.event.trigger('ajaxStop');
                    }
                }
            }
            return jqXHR;
        },
        getJSON: function (url, data, callback) {
            return jQuery.get(url, data, callback, 'json');
        },
        getScript: function (url, callback) {
            return jQuery.get(url, undefined, callback, 'script');
        }
    });
    jQuery.each([
        'get',
        'post'
    ], function (i, method) {
        jQuery[method] = function (url, data, callback, type) {
            if (jQuery.isFunction(data)) {
                type = type || callback;
                callback = data;
                data = undefined;
            }
            return jQuery.ajax({
                url: url,
                type: method,
                dataType: type,
                data: data,
                success: callback
            });
        };
    });
    jQuery.each([
        'ajaxStart',
        'ajaxStop',
        'ajaxComplete',
        'ajaxError',
        'ajaxSuccess',
        'ajaxSend'
    ], function (i, type) {
        jQuery.fn[type] = function (fn) {
            return this.on(type, fn);
        };
    });
    jQuery._evalUrl = function (url) {
        return jQuery.ajax({
            url: url,
            type: 'GET',
            dataType: 'script',
            async: false,
            global: false,
            'throws': true
        });
    };
    jQuery.fn.extend({
        wrapAll: function (html) {
            if (jQuery.isFunction(html)) {
                return this.each(function (i) {
                    jQuery(this).wrapAll(html.call(this, i));
                });
            }
            if (this[0]) {
                var wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
                if (this[0].parentNode) {
                    wrap.insertBefore(this[0]);
                }
                wrap.map(function () {
                    var elem = this;
                    while (elem.firstChild && elem.firstChild.nodeType === 1) {
                        elem = elem.firstChild;
                    }
                    return elem;
                }).append(this);
            }
            return this;
        },
        wrapInner: function (html) {
            if (jQuery.isFunction(html)) {
                return this.each(function (i) {
                    jQuery(this).wrapInner(html.call(this, i));
                });
            }
            return this.each(function () {
                var self = jQuery(this), contents = self.contents();
                if (contents.length) {
                    contents.wrapAll(html);
                } else {
                    self.append(html);
                }
            });
        },
        wrap: function (html) {
            var isFunction = jQuery.isFunction(html);
            return this.each(function (i) {
                jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
            });
        },
        unwrap: function () {
            return this.parent().each(function () {
                if (!jQuery.nodeName(this, 'body')) {
                    jQuery(this).replaceWith(this.childNodes);
                }
            }).end();
        }
    });
    jQuery.expr.filters.hidden = function (elem) {
        return elem.offsetWidth <= 0 && elem.offsetHeight <= 0 || !support.reliableHiddenOffsets() && (elem.style && elem.style.display || jQuery.css(elem, 'display')) === 'none';
    };
    jQuery.expr.filters.visible = function (elem) {
        return !jQuery.expr.filters.hidden(elem);
    };
    var r20 = /%20/g, rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
    function buildParams(prefix, obj, traditional, add) {
        var name;
        if (jQuery.isArray(obj)) {
            jQuery.each(obj, function (i, v) {
                if (traditional || rbracket.test(prefix)) {
                    add(prefix, v);
                } else {
                    buildParams(prefix + '[' + (typeof v === 'object' ? i : '') + ']', v, traditional, add);
                }
            });
        } else if (!traditional && jQuery.type(obj) === 'object') {
            for (name in obj) {
                buildParams(prefix + '[' + name + ']', obj[name], traditional, add);
            }
        } else {
            add(prefix, obj);
        }
    }
    jQuery.param = function (a, traditional) {
        var prefix, s = [], add = function (key, value) {
                value = jQuery.isFunction(value) ? value() : value == null ? '' : value;
                s[s.length] = encodeURIComponent(key) + '=' + encodeURIComponent(value);
            };
        if (traditional === undefined) {
            traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
        }
        if (jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
            jQuery.each(a, function () {
                add(this.name, this.value);
            });
        } else {
            for (prefix in a) {
                buildParams(prefix, a[prefix], traditional, add);
            }
        }
        return s.join('&').replace(r20, '+');
    };
    jQuery.fn.extend({
        serialize: function () {
            return jQuery.param(this.serializeArray());
        },
        serializeArray: function () {
            return this.map(function () {
                var elements = jQuery.prop(this, 'elements');
                return elements ? jQuery.makeArray(elements) : this;
            }).filter(function () {
                var type = this.type;
                return this.name && !jQuery(this).is(':disabled') && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
            }).map(function (i, elem) {
                var val = jQuery(this).val();
                return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function (val) {
                    return {
                        name: elem.name,
                        value: val.replace(rCRLF, '\r\n')
                    };
                }) : {
                    name: elem.name,
                    value: val.replace(rCRLF, '\r\n')
                };
            }).get();
        }
    });
    jQuery.ajaxSettings.xhr = window.ActiveXObject !== undefined ? function () {
        return !this.isLocal && /^(get|post|head|put|delete|options)$/i.test(this.type) && createStandardXHR() || createActiveXHR();
    } : createStandardXHR;
    var xhrId = 0, xhrCallbacks = {}, xhrSupported = jQuery.ajaxSettings.xhr();
    if (window.ActiveXObject) {
        jQuery(window).on('unload', function () {
            for (var key in xhrCallbacks) {
                xhrCallbacks[key](undefined, true);
            }
        });
    }
    support.cors = !!xhrSupported && 'withCredentials' in xhrSupported;
    xhrSupported = support.ajax = !!xhrSupported;
    if (xhrSupported) {
        jQuery.ajaxTransport(function (options) {
            if (!options.crossDomain || support.cors) {
                var callback;
                return {
                    send: function (headers, complete) {
                        var i, xhr = options.xhr(), id = ++xhrId;
                        xhr.open(options.type, options.url, options.async, options.username, options.password);
                        if (options.xhrFields) {
                            for (i in options.xhrFields) {
                                xhr[i] = options.xhrFields[i];
                            }
                        }
                        if (options.mimeType && xhr.overrideMimeType) {
                            xhr.overrideMimeType(options.mimeType);
                        }
                        if (!options.crossDomain && !headers['X-Requested-With']) {
                            headers['X-Requested-With'] = 'XMLHttpRequest';
                        }
                        for (i in headers) {
                            if (headers[i] !== undefined) {
                                xhr.setRequestHeader(i, headers[i] + '');
                            }
                        }
                        xhr.send(options.hasContent && options.data || null);
                        callback = function (_, isAbort) {
                            var status, statusText, responses;
                            if (callback && (isAbort || xhr.readyState === 4)) {
                                delete xhrCallbacks[id];
                                callback = undefined;
                                xhr.onreadystatechange = jQuery.noop;
                                if (isAbort) {
                                    if (xhr.readyState !== 4) {
                                        xhr.abort();
                                    }
                                } else {
                                    responses = {};
                                    status = xhr.status;
                                    if (typeof xhr.responseText === 'string') {
                                        responses.text = xhr.responseText;
                                    }
                                    try {
                                        statusText = xhr.statusText;
                                    } catch (e) {
                                        statusText = '';
                                    }
                                    if (!status && options.isLocal && !options.crossDomain) {
                                        status = responses.text ? 200 : 404;
                                    } else if (status === 1223) {
                                        status = 204;
                                    }
                                }
                            }
                            if (responses) {
                                complete(status, statusText, responses, xhr.getAllResponseHeaders());
                            }
                        };
                        if (!options.async) {
                            callback();
                        } else if (xhr.readyState === 4) {
                            setTimeout(callback);
                        } else {
                            xhr.onreadystatechange = xhrCallbacks[id] = callback;
                        }
                    },
                    abort: function () {
                        if (callback) {
                            callback(undefined, true);
                        }
                    }
                };
            }
        });
    }
    function createStandardXHR() {
        try {
            return new window.XMLHttpRequest();
        } catch (e) {
        }
    }
    function createActiveXHR() {
        try {
            return new window.ActiveXObject('Microsoft.XMLHTTP');
        } catch (e) {
        }
    }
    jQuery.ajaxSetup({
        accepts: { script: 'text/javascript, application/javascript, application/ecmascript, application/x-ecmascript' },
        contents: { script: /(?:java|ecma)script/ },
        converters: {
            'text script': function (text) {
                jQuery.globalEval(text);
                return text;
            }
        }
    });
    jQuery.ajaxPrefilter('script', function (s) {
        if (s.cache === undefined) {
            s.cache = false;
        }
        if (s.crossDomain) {
            s.type = 'GET';
            s.global = false;
        }
    });
    jQuery.ajaxTransport('script', function (s) {
        if (s.crossDomain) {
            var script, head = document.head || jQuery('head')[0] || document.documentElement;
            return {
                send: function (_, callback) {
                    script = document.createElement('script');
                    script.async = true;
                    if (s.scriptCharset) {
                        script.charset = s.scriptCharset;
                    }
                    script.src = s.url;
                    script.onload = script.onreadystatechange = function (_, isAbort) {
                        if (isAbort || !script.readyState || /loaded|complete/.test(script.readyState)) {
                            script.onload = script.onreadystatechange = null;
                            if (script.parentNode) {
                                script.parentNode.removeChild(script);
                            }
                            script = null;
                            if (!isAbort) {
                                callback(200, 'success');
                            }
                        }
                    };
                    head.insertBefore(script, head.firstChild);
                },
                abort: function () {
                    if (script) {
                        script.onload(undefined, true);
                    }
                }
            };
        }
    });
    var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
    jQuery.ajaxSetup({
        jsonp: 'callback',
        jsonpCallback: function () {
            var callback = oldCallbacks.pop() || jQuery.expando + '_' + nonce++;
            this[callback] = true;
            return callback;
        }
    });
    jQuery.ajaxPrefilter('json jsonp', function (s, originalSettings, jqXHR) {
        var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? 'url' : typeof s.data === 'string' && !(s.contentType || '').indexOf('application/x-www-form-urlencoded') && rjsonp.test(s.data) && 'data');
        if (jsonProp || s.dataTypes[0] === 'jsonp') {
            callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
            if (jsonProp) {
                s[jsonProp] = s[jsonProp].replace(rjsonp, '$1' + callbackName);
            } else if (s.jsonp !== false) {
                s.url += (rquery.test(s.url) ? '&' : '?') + s.jsonp + '=' + callbackName;
            }
            s.converters['script json'] = function () {
                if (!responseContainer) {
                    jQuery.error(callbackName + ' was not called');
                }
                return responseContainer[0];
            };
            s.dataTypes[0] = 'json';
            overwritten = window[callbackName];
            window[callbackName] = function () {
                responseContainer = arguments;
            };
            jqXHR.always(function () {
                window[callbackName] = overwritten;
                if (s[callbackName]) {
                    s.jsonpCallback = originalSettings.jsonpCallback;
                    oldCallbacks.push(callbackName);
                }
                if (responseContainer && jQuery.isFunction(overwritten)) {
                    overwritten(responseContainer[0]);
                }
                responseContainer = overwritten = undefined;
            });
            return 'script';
        }
    });
    jQuery.parseHTML = function (data, context, keepScripts) {
        if (!data || typeof data !== 'string') {
            return null;
        }
        if (typeof context === 'boolean') {
            keepScripts = context;
            context = false;
        }
        context = context || document;
        var parsed = rsingleTag.exec(data), scripts = !keepScripts && [];
        if (parsed) {
            return [context.createElement(parsed[1])];
        }
        parsed = jQuery.buildFragment([data], context, scripts);
        if (scripts && scripts.length) {
            jQuery(scripts).remove();
        }
        return jQuery.merge([], parsed.childNodes);
    };
    var _load = jQuery.fn.load;
    jQuery.fn.load = function (url, params, callback) {
        if (typeof url !== 'string' && _load) {
            return _load.apply(this, arguments);
        }
        var selector, response, type, self = this, off = url.indexOf(' ');
        if (off >= 0) {
            selector = url.slice(off, url.length);
            url = url.slice(0, off);
        }
        if (jQuery.isFunction(params)) {
            callback = params;
            params = undefined;
        } else if (params && typeof params === 'object') {
            type = 'POST';
        }
        if (self.length > 0) {
            jQuery.ajax({
                url: url,
                type: type,
                dataType: 'html',
                data: params
            }).done(function (responseText) {
                response = arguments;
                self.html(selector ? jQuery('<div>').append(jQuery.parseHTML(responseText)).find(selector) : responseText);
            }).complete(callback && function (jqXHR, status) {
                self.each(callback, response || [
                    jqXHR.responseText,
                    status,
                    jqXHR
                ]);
            });
        }
        return this;
    };
    jQuery.expr.filters.animated = function (elem) {
        return jQuery.grep(jQuery.timers, function (fn) {
            return elem === fn.elem;
        }).length;
    };
    var docElem = window.document.documentElement;
    function getWindow(elem) {
        return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 ? elem.defaultView || elem.parentWindow : false;
    }
    jQuery.offset = {
        setOffset: function (elem, options, i) {
            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, 'position'), curElem = jQuery(elem), props = {};
            if (position === 'static') {
                elem.style.position = 'relative';
            }
            curOffset = curElem.offset();
            curCSSTop = jQuery.css(elem, 'top');
            curCSSLeft = jQuery.css(elem, 'left');
            calculatePosition = (position === 'absolute' || position === 'fixed') && jQuery.inArray('auto', [
                curCSSTop,
                curCSSLeft
            ]) > -1;
            if (calculatePosition) {
                curPosition = curElem.position();
                curTop = curPosition.top;
                curLeft = curPosition.left;
            } else {
                curTop = parseFloat(curCSSTop) || 0;
                curLeft = parseFloat(curCSSLeft) || 0;
            }
            if (jQuery.isFunction(options)) {
                options = options.call(elem, i, curOffset);
            }
            if (options.top != null) {
                props.top = options.top - curOffset.top + curTop;
            }
            if (options.left != null) {
                props.left = options.left - curOffset.left + curLeft;
            }
            if ('using' in options) {
                options.using.call(elem, props);
            } else {
                curElem.css(props);
            }
        }
    };
    jQuery.fn.extend({
        offset: function (options) {
            if (arguments.length) {
                return options === undefined ? this : this.each(function (i) {
                    jQuery.offset.setOffset(this, options, i);
                });
            }
            var docElem, win, box = {
                    top: 0,
                    left: 0
                }, elem = this[0], doc = elem && elem.ownerDocument;
            if (!doc) {
                return;
            }
            docElem = doc.documentElement;
            if (!jQuery.contains(docElem, elem)) {
                return box;
            }
            if (typeof elem.getBoundingClientRect !== strundefined) {
                box = elem.getBoundingClientRect();
            }
            win = getWindow(doc);
            return {
                top: box.top + (win.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0),
                left: box.left + (win.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0)
            };
        },
        position: function () {
            if (!this[0]) {
                return;
            }
            var offsetParent, offset, parentOffset = {
                    top: 0,
                    left: 0
                }, elem = this[0];
            if (jQuery.css(elem, 'position') === 'fixed') {
                offset = elem.getBoundingClientRect();
            } else {
                offsetParent = this.offsetParent();
                offset = this.offset();
                if (!jQuery.nodeName(offsetParent[0], 'html')) {
                    parentOffset = offsetParent.offset();
                }
                parentOffset.top += jQuery.css(offsetParent[0], 'borderTopWidth', true);
                parentOffset.left += jQuery.css(offsetParent[0], 'borderLeftWidth', true);
            }
            return {
                top: offset.top - parentOffset.top - jQuery.css(elem, 'marginTop', true),
                left: offset.left - parentOffset.left - jQuery.css(elem, 'marginLeft', true)
            };
        },
        offsetParent: function () {
            return this.map(function () {
                var offsetParent = this.offsetParent || docElem;
                while (offsetParent && (!jQuery.nodeName(offsetParent, 'html') && jQuery.css(offsetParent, 'position') === 'static')) {
                    offsetParent = offsetParent.offsetParent;
                }
                return offsetParent || docElem;
            });
        }
    });
    jQuery.each({
        scrollLeft: 'pageXOffset',
        scrollTop: 'pageYOffset'
    }, function (method, prop) {
        var top = /Y/.test(prop);
        jQuery.fn[method] = function (val) {
            return access(this, function (elem, method, val) {
                var win = getWindow(elem);
                if (val === undefined) {
                    return win ? prop in win ? win[prop] : win.document.documentElement[method] : elem[method];
                }
                if (win) {
                    win.scrollTo(!top ? val : jQuery(win).scrollLeft(), top ? val : jQuery(win).scrollTop());
                } else {
                    elem[method] = val;
                }
            }, method, val, arguments.length, null);
        };
    });
    jQuery.each([
        'top',
        'left'
    ], function (i, prop) {
        jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {
            if (computed) {
                computed = curCSS(elem, prop);
                return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + 'px' : computed;
            }
        });
    });
    jQuery.each({
        Height: 'height',
        Width: 'width'
    }, function (name, type) {
        jQuery.each({
            padding: 'inner' + name,
            content: type,
            '': 'outer' + name
        }, function (defaultExtra, funcName) {
            jQuery.fn[funcName] = function (margin, value) {
                var chainable = arguments.length && (defaultExtra || typeof margin !== 'boolean'), extra = defaultExtra || (margin === true || value === true ? 'margin' : 'border');
                return access(this, function (elem, type, value) {
                    var doc;
                    if (jQuery.isWindow(elem)) {
                        return elem.document.documentElement['client' + name];
                    }
                    if (elem.nodeType === 9) {
                        doc = elem.documentElement;
                        return Math.max(elem.body['scroll' + name], doc['scroll' + name], elem.body['offset' + name], doc['offset' + name], doc['client' + name]);
                    }
                    return value === undefined ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra);
                }, type, chainable ? margin : undefined, chainable, null);
            };
        });
    });
    jQuery.fn.size = function () {
        return this.length;
    };
    jQuery.fn.andSelf = jQuery.fn.addBack;
    if (typeof define === 'function' && define.amd) {
        define('jquery@1.11.0#dist/jquery', [], function () {
            return jQuery;
        });
    }
    var _jQuery = window.jQuery, _$ = window.$;
    jQuery.noConflict = function (deep) {
        if (window.$ === jQuery) {
            window.$ = _$;
        }
        if (deep && window.jQuery === jQuery) {
            window.jQuery = _jQuery;
        }
        return jQuery;
    };
    if (typeof noGlobal === strundefined) {
        window.jQuery = window.$ = jQuery;
    }
    return jQuery;
}));
/*funcunit@3.4.2#browser/jquery*/
define('funcunit@3.4.2#browser/jquery', function (require, exports, module) {
    var $ = require('jquery');
    module.exports = $.noConflict(true);
});
/*funcunit@3.4.2#browser/init*/
define('funcunit@3.4.2#browser/init', function (require, exports, module) {
    var jQuery = require('funcunit/browser/jquery');
    var FuncUnit = window.FuncUnit || {};
    jQuery.sub = function () {
        function jQuerySub(selector, context) {
            return new jQuerySub.fn.init(selector, context);
        }
        jQuery.extend(true, jQuerySub, this);
        jQuerySub.superclass = this;
        jQuerySub.fn = jQuerySub.prototype = this();
        jQuerySub.fn.constructor = jQuerySub;
        jQuerySub.sub = this.sub;
        jQuerySub.fn.init = function init(selector, context) {
            if (context && context instanceof jQuery && !(context instanceof jQuerySub)) {
                context = jQuerySub(context);
            }
            return jQuery.fn.init.call(this, selector, context, rootjQuerySub);
        };
        jQuerySub.fn.init.prototype = jQuerySub.fn;
        var rootjQuerySub = jQuerySub(document);
        return jQuerySub;
    };
    FuncUnit.jQuery = jQuery;
    module.exports = FuncUnit;
});
/*funcunit@3.4.2#browser/core*/
define('funcunit@3.4.2#browser/core', function (require, exports, module) {
    var jQuery = require('funcunit/browser/jquery');
    var oldFuncUnit = require('funcunit/browser/init');
    var FuncUnit = oldFuncUnit.jQuery.sub();
    var origFuncUnit = FuncUnit;
    FuncUnit = function (selector, frame) {
        var frame, forceSync, isSyncOnly = false;
        if (frame && frame.forceSync) {
            forceSync = frame.forceSync;
        }
        if (frame && typeof frame.frame !== 'undefined') {
            frame = frame.frame;
        }
        isSyncOnly = typeof forceSync === 'boolean' ? forceSync : isSyncOnly;
        if (typeof selector == 'function') {
            return FuncUnit.wait(0, selector);
        }
        this.selector = selector;
        if (isSyncOnly === true) {
            var collection = performSyncQuery(selector, frame);
            return collection;
        } else {
            performAsyncQuery(selector, frame, this);
            var collection = performSyncQuery(selector, frame);
            return collection;
        }
    };
    var getContext = function (context) {
            if (typeof context === 'number' || typeof context === 'string') {
                var sel = typeof context === 'number' ? 'iframe:eq(' + context + ')' : 'iframe[name=\'' + context + '\']', frames = new origFuncUnit.fn.init(sel, FuncUnit.win.document.documentElement, true);
                var frame = (frames.length ? frames.get(0).contentWindow : FuncUnit.win).document.documentElement;
            } else {
                frame = FuncUnit.win.document.documentElement;
            }
            return frame;
        }, performAsyncQuery = function (selector, frame, self) {
            FuncUnit.add({
                method: function (success, error) {
                    this.frame = frame;
                    if (FuncUnit.win) {
                        frame = getContext(frame);
                    }
                    this.selector = selector;
                    this.bind = new origFuncUnit.fn.init(selector, frame, true);
                    success();
                    return this;
                },
                error: 'selector failed: ' + selector,
                type: 'query'
            });
        }, performSyncQuery = function (selector, frame) {
            var origFrame = frame;
            if (FuncUnit.win) {
                frame = getContext(frame);
            }
            var obj = new origFuncUnit.fn.init(selector, frame, true);
            obj.frame = origFrame;
            return obj;
        };
    oldFuncUnit.jQuery.extend(FuncUnit, oldFuncUnit, origFuncUnit);
    FuncUnit.prototype = origFuncUnit.prototype;
    module.exports = FuncUnit;
});
/*funcunit@3.4.2#browser/adapters/jasmine*/
define('funcunit@3.4.2#browser/adapters/jasmine', function (require, exports, module) {
    module.exports = function (jasmine) {
        var paused = false;
        return {
            pauseTest: function () {
                paused = true;
                waitsFor(function () {
                    return paused === false;
                }, 60000);
            },
            resumeTest: function () {
                paused = false;
            },
            assertOK: function (assertion, message) {
                expect(assertion).toBeTruthy();
            },
            equiv: function (expected, actual) {
                return jasmine.getEnv().equals_(expected, actual);
            }
        };
    };
});
/*funcunit@3.4.2#browser/adapters/jasmine2*/
define('funcunit@3.4.2#browser/adapters/jasmine2', function (require, exports, module) {
    var FuncUnit = require('funcunit/browser/core');
    module.exports = function (jasmine) {
        FuncUnit.timeout = 4900;
        return {
            pauseTest: function () {
            },
            resumeTest: function () {
            },
            assertOK: function (assertion, message) {
                expect(assertion).toBeTruthy();
            },
            equiv: function (expected, actual) {
                return expected == actual;
            }
        };
    };
});
/*funcunit@3.4.2#browser/adapters/qunit*/
define('funcunit@3.4.2#browser/adapters/qunit', function (require, exports, module) {
    module.exports = function (QUnit) {
        return {
            pauseTest: function () {
                QUnit.stop();
            },
            resumeTest: function () {
                QUnit.start();
            },
            assertOK: function (assertion, message) {
                QUnit.ok(assertion, message);
            },
            equiv: function (expected, actual) {
                return QUnit.equiv(expected, actual);
            }
        };
    };
});
/*funcunit@3.4.2#browser/adapters/qunit2*/
define('funcunit@3.4.2#browser/adapters/qunit2', function (require, exports, module) {
    var FuncUnit = require('funcunit/browser/core');
    module.exports = function (QUnit) {
        var done;
        var currentTestAssert;
        var originalTest = QUnit.test;
        QUnit.test = function funcunitTest(title, test) {
            return originalTest(title, function (assert) {
                currentTestAssert = assert;
                return test.apply(this, arugments);
            });
        };
        return {
            pauseTest: function () {
                done = currentTestAssert.async();
            },
            resumeTest: function () {
                done();
            },
            assertOK: function (assertion, message) {
                currentTestAssert.ok(assertion, message);
            },
            equiv: function (expected, actual) {
                return QUnit.equiv(expected, actual);
            }
        };
    };
});
/*funcunit@3.4.2#browser/adapters/mocha*/
define('funcunit@3.4.2#browser/adapters/mocha', function (require, exports, module) {
    var FuncUnit = require('funcunit/browser/core');
    var ok = function (expr, msg) {
        if (!expr)
            throw new Error(msg);
    };
    module.exports = function (mocha) {
        FuncUnit.timeout = 1900;
        return {
            pauseTest: function () {
            },
            resumeTest: function () {
            },
            assertOK: function (assertion, message) {
                ok(assertion, message);
            },
            equiv: function (expected, actual) {
                return expected == actual;
            }
        };
    };
});
/*funcunit@3.4.2#browser/adapters/adapters*/
define('funcunit@3.4.2#browser/adapters/adapters', function (require, exports, module) {
    (function (global) {
        var jasmineAdapter = require('funcunit/browser/adapters/jasmine');
        var jasmine2Adapter = require('funcunit/browser/adapters/jasmine2');
        var qunitAdapter = require('funcunit/browser/adapters/qunit');
        var qunit2Adapter = require('funcunit/browser/adapters/qunit2');
        var mochaAdapter = require('funcunit/browser/adapters/mocha');
        var FuncUnit = require('funcunit/browser/core');
        var noop = function () {
        };
        var defaultAdapter = {
            pauseTest: noop,
            resumeTest: noop,
            assertOK: noop,
            equiv: function (expected, actual) {
                return expected == actual;
            }
        };
        FuncUnit.unit = defaultAdapter;
        FuncUnit.attach = function (runner) {
            var unit;
            if (isQUnit(runner)) {
                unit = qunitAdapter(runner);
            } else if (isQUnit2(runner)) {
                unit = qunit2Adapter(runner);
            } else if (isMocha(runner)) {
                unit = mochaAdapter(runner);
            } else if (isJasmine(runner)) {
                unit = jasmineAdapter(runner);
            } else if (isJasmine2(runner)) {
                unit = jasmine2Adapter(runner);
            } else {
                unit = defaultAdapter;
            }
            FuncUnit.unit = unit;
        };
        function isQUnit(runner) {
            return !!(runner.ok && runner.start && runner.stop);
        }
        function isQUnit2(runner) {
            return !!(runner.assert && runner.assert.ok && runner.assert.async);
        }
        function isMocha(runner) {
            return !!(runner.setup && runner.globals && runner.reporter);
        }
        function isJasmine(runner) {
            return !!(runner.getEnv && typeof window.waitsFor === 'function');
        }
        function isJasmine2(runner) {
            return !!(runner.getEnv && typeof runner.clock === 'function' && !window.waitsFor);
        }
        FuncUnit.detach = function () {
            FuncUnit.unit = defaultAdapter;
        };
    }(function () {
        return this;
    }()));
});
/*funcunit@3.4.2#browser/open*/
define('funcunit@3.4.2#browser/open', function (require, exports, module) {
    var $ = require('funcunit/browser/jquery');
    var FuncUnit = require('funcunit/browser/core');
    var syn = require('syn');
    if (FuncUnit.frameMode) {
        var ifrm = document.createElement('iframe');
        ifrm.id = 'funcunit_app';
        document.body.insertBefore(ifrm, document.body.firstChild);
    }
    var confirms = [], prompts = [], currentDocument, currentHref, appWin, lookingForNewDocument = false, urlWithoutHash = function (url) {
            return url.replace(/\#.*$/, '');
        }, isCurrentPage = function (url) {
            var pathname = urlWithoutHash(FuncUnit.win.location.pathname), href = urlWithoutHash(FuncUnit.win.location.href), url = urlWithoutHash(url);
            if (pathname === url || href === url) {
                return true;
            }
            return false;
        };
    $.extend(FuncUnit, {
        open: function (path, success, timeout) {
            if (typeof success != 'function') {
                timeout = success;
                success = undefined;
            }
            FuncUnit.add({
                method: function (success, error) {
                    if (typeof path === 'string') {
                        var fullPath = FuncUnit.getAbsolutePath(path);
                        FuncUnit._open(fullPath, error);
                        FuncUnit._onload(function () {
                            success();
                        }, error);
                    } else {
                        FuncUnit.win = path;
                        success();
                    }
                },
                success: success,
                error: 'Page ' + path + ' not loaded in time!',
                timeout: timeout || 30000
            });
        },
        _open: function (url) {
            FuncUnit.win = appWin;
            hasSteal = false;
            FuncUnit.frame = $('#funcunit_app').length ? $('#funcunit_app')[0] : null;
            if (newPage) {
                if (FuncUnit.frame) {
                    FuncUnit.win = FuncUnit.frame.contentWindow;
                    FuncUnit.win.location = url;
                } else {
                    var width = $(window).width();
                    FuncUnit.win = window.open(url, 'funcunit', 'height=1000,toolbar=yes,status=yes,width=' + width / 2 + ',left=' + width / 2);
                    if (FuncUnit.win && FuncUnit.win.___FUNCUNIT_OPENED) {
                        FuncUnit.win.close();
                        FuncUnit.win = window.open(url, 'funcunit', 'height=1000,toolbar=yes,status=yes,left=' + width / 2);
                    }
                    if (!FuncUnit.win) {
                        throw 'Could not open a popup window.  Your popup blocker is probably on.  Please turn it off and try again';
                    }
                }
                appWin = FuncUnit.win;
            } else {
                lookingForNewDocument = true;
                if (isCurrentPage(url)) {
                    FuncUnit.win.document.body.parentNode.removeChild(FuncUnit.win.document.body);
                    FuncUnit.win.location.hash = url.split('#')[1] || '';
                    FuncUnit.win.location.reload(true);
                } else {
                    FuncUnit.win.location = url;
                }
                currentDocument = null;
            }
            lookingForNewDocument = true;
        },
        confirm: function (answer) {
            confirms.push(!!answer);
        },
        prompt: function (answer) {
            prompts.push(answer);
        },
        _opened: function () {
            if (!this._isOverridden('alert')) {
                FuncUnit.win.alert = function () {
                };
            }
            if (!this._isOverridden('confirm')) {
                FuncUnit.win.confirm = function () {
                    var res = confirms.shift();
                    return res;
                };
            }
            if (!this._isOverridden('prompt')) {
                FuncUnit.win.prompt = function () {
                    return prompts.shift();
                };
            }
        },
        _isOverridden: function (type) {
            return !/(native code)|(source code not available)/.test(FuncUnit.win[type]);
        },
        _onload: function (success, error) {
            loadSuccess = function () {
                if (FuncUnit.win.steal) {
                    hasSteal = true;
                }
                if (!hasSteal) {
                    return success();
                }
                FuncUnit.win.steal.done().then(success);
            };
            if (!newPage) {
                return;
            }
            newPage = false;
            if (FuncUnit.support.readystate) {
                poller();
            } else {
                unloadLoader();
            }
        },
        getAbsolutePath: function (path) {
            if (/^\/\//.test(path)) {
                path = path.substr(2);
            }
            return path;
        },
        win: window,
        support: { readystate: 'readyState' in document },
        eval: function (str) {
            return FuncUnit.win.eval(str);
        },
        documentLoaded: function () {
            var loaded = FuncUnit.win.document.readyState === 'complete' && FuncUnit.win.location.href != 'about:blank' && FuncUnit.win.document.body;
            return loaded;
        },
        checkForNewDocument: function () {
            var documentFound = false;
            try {
                documentFound = (FuncUnit.win.document !== currentDocument && !FuncUnit.win.___FUNCUNIT_OPENED || currentHref != FuncUnit.win.location.href) && FuncUnit.documentLoaded();
            } catch (e) {
            }
            if (documentFound) {
                lookingForNewDocument = false;
                currentDocument = FuncUnit.win.document;
                currentHref = FuncUnit.win.location.href;
                FuncUnit.win.___FUNCUNIT_OPENED = true;
                FuncUnit._opened();
            }
            return documentFound;
        }
    });
    var newPage = true, hasSteal = false, unloadLoader, loadSuccess, firstLoad = true, onload = function () {
            FuncUnit.win.document.documentElement.tabIndex = 0;
            setTimeout(function () {
                FuncUnit.win.focus();
                var ls = loadSuccess;
                loadSuccess = null;
                if (ls) {
                    ls();
                }
            }, 0);
            syn.unbind(FuncUnit.win, 'load', onload);
        }, onunload = function () {
            FuncUnit.stop = true;
            removeListeners();
            setTimeout(unloadLoader, 0);
        }, removeListeners = function () {
            syn.unbind(FuncUnit.win, 'unload', onunload);
            Syn.unbind(FuncUnit.win, 'load', onload);
        };
    unloadLoader = function () {
        if (!firstLoad)
            removeListeners();
        syn.bind(FuncUnit.win, 'load', onload);
        syn.bind(FuncUnit.win, 'unload', onunload);
    };
    var newDocument = false, poller = function () {
            var ls;
            if (lookingForNewDocument && FuncUnit.checkForNewDocument()) {
                ls = loadSuccess;
                loadSuccess = null;
                if (ls) {
                    FuncUnit.win.focus();
                    FuncUnit.win.document.documentElement.tabIndex = 0;
                    ls();
                }
            }
            setTimeout(arguments.callee, 500);
        };
    $(window).unload(function () {
        if (FuncUnit.win && FuncUnit.win !== window.top) {
            FuncUnit.win.close();
        }
    });
    module.exports = FuncUnit;
});
/*funcunit@3.4.2#browser/actions*/
define('funcunit@3.4.2#browser/actions', function (require, exports, module) {
    var $ = require('funcunit/browser/jquery');
    var FuncUnit = require('funcunit/browser/core');
    var syn = window.syn = require('syn');
    var clicks = [
            'click',
            'dblclick',
            'rightClick'
        ], makeClick = function (name) {
            FuncUnit.prototype[name] = function (options, success) {
                this._addExists();
                if (typeof options == 'function') {
                    success = options;
                    options = {};
                }
                var selector = this.selector;
                FuncUnit.add({
                    method: function (success, error) {
                        options = options || {};
                        syn('_' + name, this.bind[0], options, success);
                    },
                    success: success,
                    error: 'Could not ' + name + ' \'' + this.selector + '\'',
                    bind: this,
                    type: 'action'
                });
                return this;
            };
        };
    for (var i = 0; i < clicks.length; i++) {
        makeClick(clicks[i]);
    }
    $.extend(FuncUnit.prototype, {
        _addExists: function () {
            this.exists(false);
        },
        type: function (text, success) {
            this._addExists();
            this.click();
            var selector = this.selector;
            if (text === '') {
                text = '[ctrl]a[ctrl-up]\b';
            }
            FuncUnit.add({
                method: function (success, error) {
                    syn('_type', this.bind[0], text, success);
                },
                success: success,
                error: 'Could not type ' + text + ' into ' + this.selector,
                bind: this,
                type: 'action'
            });
            return this;
        },
        sendKeys: function (keys, success) {
            this._addExists();
            var selector = this.selector;
            if (keys === '') {
                keys = '[ctrl]a[ctrl-up]\b';
            }
            FuncUnit.add({
                method: function (success, error) {
                    syn('_type', this.bind[0], keys, success);
                },
                success: success,
                error: 'Could not send the keys ' + keys + ' into ' + this.selector,
                bind: this,
                type: 'action'
            });
            return this;
        },
        trigger: function (evName, success) {
            this._addExists();
            FuncUnit.add({
                method: function (success, error) {
                    if (!FuncUnit.win.jQuery) {
                        throw 'Can not trigger custom event, no jQuery found on target page.';
                    }
                    FuncUnit.win.jQuery(this.bind.selector).trigger(evName);
                    success();
                },
                success: success,
                error: 'Could not trigger ' + evName,
                bind: this,
                type: 'action'
            });
            return this;
        },
        drag: function (options, success) {
            this._addExists();
            if (typeof options == 'string') {
                options = { to: options };
            }
            options.from = this.selector;
            var selector = this.selector;
            FuncUnit.add({
                method: function (success, error) {
                    syn('_drag', this.bind[0], options, success);
                },
                success: success,
                error: 'Could not drag ' + this.selector,
                bind: this,
                type: 'action'
            });
            return this;
        },
        move: function (options, success) {
            this._addExists();
            if (typeof options == 'string') {
                options = { to: options };
            }
            options.from = this.selector;
            var selector = this.selector;
            FuncUnit.add({
                method: function (success, error) {
                    syn('_move', this.bind[0], options, success);
                },
                success: success,
                error: 'Could not move ' + this.selector,
                bind: this,
                type: 'action'
            });
            return this;
        },
        scroll: function (direction, amount, success) {
            this._addExists();
            var selector = this.selector, direction;
            if (direction == 'left' || direction == 'right') {
                direction = 'Left';
            } else if (direction == 'top' || direction == 'bottom') {
                direction = 'Top';
            }
            FuncUnit.add({
                method: function (success, error) {
                    this.bind.each(function (i, el) {
                        this['scroll' + direction] = amount;
                    });
                    success();
                },
                success: success,
                error: 'Could not scroll ' + this.selector,
                bind: this,
                type: 'action'
            });
            return this;
        }
    });
    module.exports = FuncUnit;
});
/*funcunit@3.4.2#browser/getters*/
define('funcunit@3.4.2#browser/getters', function (require, exports, module) {
    var $ = require('funcunit/browser/jquery');
    var FuncUnit = require('funcunit/browser/core');
    FuncUnit.funcs = {
        'size': 0,
        'attr': 1,
        'hasClass': 1,
        'html': 0,
        'text': 0,
        'val': 0,
        'css': 1,
        'prop': 1,
        'offset': 0,
        'position': 0,
        'scrollTop': 0,
        'scrollLeft': 0,
        'height': 0,
        'width': 0,
        'innerHeight': 0,
        'innerWidth': 0,
        'outerHeight': 0,
        'outerWidth': 0
    };
    FuncUnit.makeFunc = function (fname, argIndex) {
        var orig = FuncUnit.fn[fname];
        FuncUnit.prototype[fname] = function () {
            var args = FuncUnit.makeArray(arguments), isWait = args.length > argIndex, success, self = this;
            args.unshift(this.selector, this.frame, fname);
            if (isWait) {
                var tester = args[argIndex + 3], timeout = args[argIndex + 4], success = args[argIndex + 5], message = args[argIndex + 6], testVal = tester, errorMessage = 'waiting for ' + fname + ' on ' + this.selector, frame = this.frame, logMessage = 'Checking ' + fname + ' on \'' + this.selector + '\'', ret;
                if (typeof tester == 'object' && !(tester instanceof RegExp)) {
                    timeout = tester.timeout;
                    success = tester.success;
                    message = tester.message;
                    if (tester.errorMessage) {
                        errorMessage = tester.errorMessage;
                    }
                    if (typeof tester.logMessage !== 'undefined') {
                        logMessage = tester.logMessage;
                    }
                    tester = tester.condition;
                }
                if (typeof timeout == 'function') {
                    message = success;
                    success = timeout;
                    timeout = undefined;
                }
                if (typeof timeout == 'string') {
                    message = timeout;
                    timeout = undefined;
                    success = undefined;
                }
                if (typeof message !== 'string') {
                    message = undefined;
                }
                args.splice(argIndex + 3, args.length - argIndex - 3);
                if (typeof tester != 'function') {
                    errorMessage += ' !== ' + testVal;
                    tester = function (val) {
                        return FuncUnit.unit.equiv(val, testVal) || testVal instanceof RegExp && testVal.test(val);
                    };
                }
                if (message) {
                    errorMessage = message;
                }
                FuncUnit.repeat({
                    method: function (print) {
                        if (this.bind.prevObject && this.bind.prevTraverser) {
                            var prev = this.bind;
                            this.bind = this.bind.prevObject[this.bind.prevTraverser](this.bind.prevTraverserSelector);
                            this.bind.prevTraverser = prev.prevTraverser;
                            this.bind.prevTraverserSelector = prev.prevTraverserSelector;
                        } else {
                            this.bind = F(this.selector, {
                                frame: frame,
                                forceSync: true
                            });
                        }
                        if (logMessage) {
                            print(logMessage);
                        }
                        var methodArgs = [];
                        if (argIndex > 0) {
                            methodArgs.push(args[3]);
                        }
                        FuncUnit._ignoreGetterError = true;
                        ret = this.bind[fname].apply(this.bind, methodArgs);
                        FuncUnit._ignoreGetterError = false;
                        var passed = tester.call(this.bind, ret);
                        if (this.bind.length === 0 && fname !== 'size') {
                            passed = false;
                        }
                        if (passed) {
                            if (!FuncUnit.documentLoaded()) {
                                passed = false;
                            } else {
                                FuncUnit.checkForNewDocument();
                            }
                        }
                        return passed;
                    },
                    success: function () {
                        if (message) {
                            FuncUnit.unit.assertOK(true, message);
                        }
                        success && success.apply(this, arguments);
                    },
                    error: function () {
                        var msg = errorMessage;
                        if (ret) {
                            msg += ', actual value: ' + ret;
                        }
                        FuncUnit.unit.assertOK(false, msg);
                    },
                    timeout: timeout,
                    bind: this,
                    type: 'wait'
                });
                return this;
            } else {
                if (!FuncUnit._ignoreGetterError && !FuncUnit._incallback && FuncUnit._haveAsyncQueries()) {
                    console && console.error('You can\'t run getters after actions and waits. Please put your getters in a callback or at the beginning of the test.');
                }
                var methodArgs = [];
                if (argIndex > 0) {
                    methodArgs.push(args[3]);
                }
                return orig.apply(this, methodArgs);
            }
        };
    };
    for (var prop in FuncUnit.funcs) {
        FuncUnit.makeFunc(prop, FuncUnit.funcs[prop]);
    }
    module.exports = FuncUnit;
});
/*funcunit@3.4.2#browser/traversers*/
define('funcunit@3.4.2#browser/traversers', function (require, exports, module) {
    var $ = require('funcunit/browser/jquery');
    var FuncUnit = require('funcunit/browser/core');
    var traversers = [
            'closest',
            'next',
            'prev',
            'siblings',
            'last',
            'first',
            'find'
        ], makeTraverser = function (name) {
            var orig = FuncUnit.prototype[name];
            FuncUnit.prototype[name] = function (selector) {
                var args = arguments;
                if (FuncUnit.win && this[0] && this[0].parentNode && this[0].parentNode.nodeType !== 9) {
                    FuncUnit.add({
                        method: function (success, error) {
                            var newBind = orig.apply(this.bind, args);
                            newBind.prevTraverser = name;
                            newBind.prevTraverserSelector = selector;
                            success(newBind);
                        },
                        error: 'Could not traverse: ' + name + ' ' + selector,
                        bind: this
                    });
                }
                return orig.apply(this, arguments);
            };
        };
    for (var i = 0; i < traversers.length; i++) {
        makeTraverser(traversers[i]);
    }
    module.exports = FuncUnit;
});
/*funcunit@3.4.2#browser/queue*/
define('funcunit@3.4.2#browser/queue', function (require, exports, module) {
    (function (global) {
        var FuncUnit = require('funcunit/browser/core');
        FuncUnit._incallback = false;
        var currentPosition = 0, startedQueue = false;
        FuncUnit.speed = 0;
        FuncUnit.timeout = 10000;
        FuncUnit._queue = [];
        FuncUnit._needSyncQuery = function () {
            if (FuncUnit._queue.length === 1) {
                if (FuncUnit._queue[0].type === 'query') {
                    FuncUnit._queue = [];
                    return true;
                }
            }
            if (FuncUnit._queue.length === 0) {
                return true;
            }
            return false;
        };
        FuncUnit._lastQueuedItem = function () {
            if (!FuncUnit._queue.length) {
                return null;
            }
            return FuncUnit._queue[FuncUnit._queue.length - 1];
        };
        FuncUnit._haveAsyncQueries = function () {
            for (var i = 0; i < FuncUnit._queue.length; i++) {
                if (FuncUnit._queue[i].type === 'action' || FuncUnit._queue[i].type === 'wait')
                    return true;
            }
            return false;
        };
        FuncUnit.add = function (handler, error, context) {
            if (handler instanceof Function) {
                if (typeof error === 'object') {
                    context = error;
                    delete error;
                }
                error = error && error.toString() || 'Custom method has failed.';
                var cb = handler;
                handler = {
                    method: function (success, error) {
                        success();
                    },
                    success: cb,
                    error: error,
                    bind: context
                };
            }
            if (FuncUnit._incallback) {
                FuncUnit._queue.splice(currentPosition, 0, handler);
                currentPosition++;
            } else {
                FuncUnit._queue.push(handler);
            }
            if (FuncUnit._queue.length == 1 && !FuncUnit._incallback) {
                FuncUnit.unit.pauseTest();
                setTimeout(FuncUnit._done, 13);
            }
        };
        var currentEl;
        FuncUnit._done = function (el, selector) {
            var next, timer, speed = FuncUnit.speed || 0;
            if (FuncUnit.speed === 'slow') {
                speed = 500;
            }
            if (FuncUnit._queue.length > 0) {
                next = FuncUnit._queue.shift();
                currentPosition = 0;
                setTimeout(function () {
                    timer = setTimeout(function () {
                        next.stop && next.stop();
                        if (typeof next.error === 'function') {
                            next.error();
                        } else {
                            FuncUnit.unit.assertOK(false, next.error);
                        }
                        FuncUnit._done();
                    }, (next.timeout || FuncUnit.timeout) + speed);
                    if (el && el.jquery) {
                        currentEl = el;
                    }
                    if (currentEl) {
                        next.bind = currentEl;
                    }
                    next.selector = selector;
                    next.method(function (el) {
                        if (el && el.jquery) {
                            next.bind = el;
                        }
                        clearTimeout(timer);
                        FuncUnit._incallback = true;
                        if (next.success) {
                            next.success.apply(next.bind, arguments);
                        }
                        FuncUnit._incallback = false;
                        FuncUnit._done(next.bind, next.selector);
                    }, function (message) {
                        clearTimeout(timer);
                        FuncUnit.unit.assertOK(false, message);
                        FuncUnit._done();
                    });
                }, speed);
            } else {
                FuncUnit.unit.resumeTest();
            }
        };
        module.exports = FuncUnit;
    }(function () {
        return this;
    }()));
});
/*funcunit@3.4.2#browser/waits*/
define('funcunit@3.4.2#browser/waits', function (require, exports, module) {
    var $ = require('funcunit/browser/jquery');
    var FuncUnit = require('funcunit/browser/core');
    FuncUnit.wait = function (time, success) {
        if (typeof time == 'function') {
            success = time;
            time = undefined;
        }
        time = time != null ? time : 5000;
        FuncUnit.add({
            method: function (success, error) {
                setTimeout(success, time);
            },
            success: success,
            error: 'Couldn\'t wait!',
            timeout: time + 1000
        });
        return this;
    };
    FuncUnit.branch = function (check1, success1, check2, success2, timeout) {
        FuncUnit.repeat({
            method: function (print) {
                print('Running a branch statement');
                if (check1()) {
                    success1();
                    return true;
                }
                if (check2()) {
                    success2();
                    return true;
                }
            },
            error: 'no branch condition was ever true',
            timeout: timeout,
            type: 'branch'
        });
    };
    FuncUnit.repeat = function (options) {
        var interval, stopped = false, stop = function () {
                clearTimeout(interval);
                stopped = true;
            };
        FuncUnit.add({
            method: function (success, error) {
                options.bind = this.bind;
                options.selector = this.selector;
                var printed = false, print = function (msg) {
                        if (!printed) {
                            printed = true;
                        }
                    };
                interval = setTimeout(function () {
                    var result = null;
                    try {
                        result = options.method(print);
                    } catch (e) {
                    }
                    if (result) {
                        success(options.bind);
                    } else if (!stopped) {
                        interval = setTimeout(arguments.callee, 10);
                    }
                }, 10);
            },
            success: options.success,
            error: options.error,
            timeout: options.timeout,
            stop: stop,
            bind: options.bind,
            type: options.type
        });
    };
    FuncUnit.animationEnd = function () {
        F('body').wait(200).size(function () {
            return F.win.$(':animated').length === 0;
        });
    };
    FuncUnit.animationsDone = FuncUnit.animationEnd;
    $.extend(FuncUnit.prototype, {
        exists: function (timeout, success, message) {
            var logMessage = 'Waiting for \'' + this.selector + '\' to exist';
            if (timeout === false) {
                logMessage = false;
            }
            return this.size({
                condition: function (size) {
                    return size > 0;
                },
                timeout: timeout,
                success: success,
                message: message,
                errorMessage: 'Exist failed: element with selector \'' + this.selector + '\' not found',
                logMessage: logMessage
            });
        },
        missing: function (timeout, success, message) {
            return this.size(0, timeout, success, message);
        },
        visible: function (timeout, success, message) {
            var self = this, sel = this.selector, ret;
            return this.size(function (size) {
                return this.is(':visible') === true;
            }, timeout, success, message);
        },
        invisible: function (timeout, success, message) {
            var self = this, sel = this.selector, ret;
            return this.size(function (size) {
                return this.is(':visible') === false;
            }, timeout, success, message);
        },
        wait: function (checker, timeout, success, message) {
            if (typeof checker === 'number') {
                timeout = checker;
                FuncUnit.wait(timeout, success);
                return this;
            } else {
                return this.size(checker, timeout, success, message);
            }
        },
        then: function (success) {
            var self = this;
            FuncUnit.wait(0, function () {
                success.call(this, this);
            });
            return this;
        }
    });
    module.exports = FuncUnit;
});
/*funcunit@3.4.2#funcunit*/
define('funcunit@3.4.2#funcunit', function (require, exports, module) {
    var syn = require('syn');
    var FuncUnit = require('funcunit/browser/core');
    require('funcunit/browser/adapters/');
    require('funcunit/browser/open');
    require('funcunit/browser/actions');
    require('funcunit/browser/getters');
    require('funcunit/browser/traversers');
    require('funcunit/browser/queue');
    require('funcunit/browser/waits');
    window.FuncUnit = window.S = window.F = FuncUnit;
    module.exports = FuncUnit;
});
/*can@3.9.0-pre.0#docs/can-guides/experiment/todomvc/test*/
define('can@3.9.0-pre.0#docs/can-guides/experiment/todomvc/test', function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var F = require('funcunit');
    F.attach(QUnit);
    QUnit.module('todomvc', {
        beforeEach: function (assert) {
            localStorage.clear();
        }
    });
    QUnit.test('basics work', function () {
        F('li.todo', 0).size(3, 'there are 3 todos');
        F('#new-todo', 0).type('new thing\r');
        F('li.todo', 0).size(4, 'new todo added');
    });
});
/*can@3.9.0-pre.0#test/integration/all/test*/
define('can@3.9.0-pre.0#test/integration/all/test', function (require, exports, module) {
    (function (__dirname) {
        var QUnit = require('steal-qunit');
        var makeIframe = function (src) {
            var iframe = document.createElement('iframe');
            window.removeMyself = function () {
                delete window.removeMyself;
                document.body.removeChild(iframe);
                QUnit.start();
            };
            document.body.appendChild(iframe);
            iframe.src = src;
        };
        QUnit.module('can.all.js');
        if (__dirname !== '/') {
            QUnit.asyncTest('works without jquery', function () {
                makeIframe(__dirname + '/no-jquery.html?' + Math.random());
            });
        }
    }('/'));
});
/*can@3.9.0-pre.0#test/test*/
define('can@3.9.0-pre.0#test/test', function (require, exports, module) {
    require('../component/component_test');
    require('../compute/compute_test');
    if (!System.isEnv('production')) {
        System.import('can-connect/test/test');
    }
    require('../construct/construct_test');
    require('can-construct-super/test/can-construct-super_test');
    require('can-define/test/test');
    require('can-set/test/test');
    require('../view/stache/stache_test');
    require('can-stache-converters/test/test');
    require('can-deparam/can-deparam-test');
    require('can-param/can-param-test');
    require('../event/event_test');
    if (!System.isEnv('production')) {
        System.import('can-observation/can-observation_test');
    }
    require('../util/util_test');
    if (!System.isEnv('production')) {
        System.import('can-view-callbacks/test/callbacks-test');
    }
    require('../view/import/import_test');
    require('../view/live/live_test');
    require('can-view-model/test/test');
    require('../view/node_lists/node_lists_test');
    require('../view/parser/parser_test');
    require('../view/scope/scope_test');
    require('../view/autorender/autorender_test');
    if (!System.isEnv('production')) {
        System.import('can-simple-map/can-simple-map_test');
    }
    require('can-view-target/test/test');
    require('can-simple-dom/test/test');
    if (!System.isEnv('production')) {
        System.import('can-cid/test/test');
    }
    if (!System.isEnv('production')) {
        System.import('can-types/test/test');
    }
    require('can-symbol/can-symbol-test');
    require('can-reflect/can-reflect-test');
    require('../control/control_test');
    require('../list/list_test');
    require('../map/map_test');
    require('can-map-define/can-map-define_test');
    require('can-view-href/test/test');
    require('can-map-backup/can-map-backup_test');
    require('can-validate-legacy/can-validate-test');
    require('../view/ejs/ejs_test');
    require('can-fixture/test/fixture_test');
    require('can-connect-signalr/test');
    require('can-connect-cloneable/test/test');
    require('can-stream/can-stream_test');
    require('can-stream-kefir/can-stream-kefir_test');
    require('can-ndjson-stream/can-ndjson-stream-test');
    require('can-connect-ndjson/test/can-connect-ndjson-test');
    require('can-define-stream/can-define-stream_test');
    require('can-define-stream-kefir/can-define-stream-kefir_test');
    require('can-ndjson-stream/can-ndjson-stream-test');
    require('can-connect-ndjson/test/can-connect-ndjson-test');
    require('react-view-model/test/test');
    require('can-react-component/test/test');
    require('../docs/can-guides/experiment/todomvc/test');
    require('./integration/all/test');
});