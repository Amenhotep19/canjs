/*[system-bundles-config]*/
System.bundles = {"bundles/can/test/test.css!":["qunitjs@1.23.1#qunit/qunit.css!steal-css@1.3.1#css"]};
/*npm-utils*/
define('npm-utils', function (require, exports, module) {
    (function (global, require, exports, module) {
        var slice = Array.prototype.slice;
        var npmModuleRegEx = /.+@.+\..+\..+#.+/;
        var conditionalModuleRegEx = /#\{[^\}]+\}|#\?.+$/;
        var gitUrlEx = /(git|http(s?)):\/\//;
        var supportsSet = typeof Set === 'function';
        var utils = {
            extend: function (d, s, deep, existingSet) {
                var val;
                var set = existingSet;
                if (deep) {
                    if (!set) {
                        if (supportsSet) {
                            set = new Set();
                        } else {
                            set = [];
                        }
                    }
                    if (supportsSet) {
                        if (set.has(s)) {
                            return s;
                        } else {
                            set.add(s);
                        }
                    } else {
                        if (set.indexOf(s) !== -1) {
                            return s;
                        } else {
                            set.push(s);
                        }
                    }
                }
                for (var prop in s) {
                    val = s[prop];
                    if (deep) {
                        if (utils.isArray(val)) {
                            d[prop] = slice.call(val);
                        } else if (utils.isPlainObject(val)) {
                            d[prop] = utils.extend({}, val, deep, set);
                        } else {
                            d[prop] = s[prop];
                        }
                    } else {
                        d[prop] = s[prop];
                    }
                }
                return d;
            },
            map: function (arr, fn) {
                var i = 0, len = arr.length, out = [];
                for (; i < len; i++) {
                    out.push(fn.call(arr, arr[i]));
                }
                return out;
            },
            filter: function (arr, fn) {
                var i = 0, len = arr.length, out = [], res;
                for (; i < len; i++) {
                    res = fn.call(arr, arr[i]);
                    if (res) {
                        out.push(arr[i]);
                    }
                }
                return out;
            },
            forEach: function (arr, fn) {
                var i = 0, len = arr.length;
                for (; i < len; i++) {
                    fn.call(arr, arr[i], i);
                }
            },
            isObject: function (obj) {
                return typeof obj === 'object';
            },
            isPlainObject: function (obj) {
                return utils.isObject(obj) && (!obj || obj.__proto__ === Object.prototype);
            },
            isArray: Array.isArray || function (arr) {
                return Object.prototype.toString.call(arr) === '[object Array]';
            },
            isEnv: function (name) {
                return this.isEnv ? this.isEnv(name) : this.env === name;
            },
            isGitUrl: function (str) {
                return gitUrlEx.test(str);
            },
            warnOnce: function (msg) {
                var w = this._warnings = this._warnings || {};
                if (w[msg])
                    return;
                w[msg] = true;
                this.warn(msg);
            },
            warn: function (msg) {
                if (typeof steal !== 'undefined' && typeof console !== 'undefined' && console.warn) {
                    steal.done().then(function () {
                        if (steal.dev && steal.dev.warn) {
                        } else if (console.warn) {
                            console.warn('steal.js WARNING: ' + msg);
                        } else {
                            console.log(msg);
                        }
                    });
                }
            },
            relativeURI: function (baseURL, url) {
                return typeof steal !== 'undefined' ? steal.relativeURI(baseURL, url) : url;
            },
            moduleName: {
                create: function (descriptor, standard) {
                    if (standard) {
                        return descriptor.moduleName;
                    } else {
                        if (descriptor === '@empty') {
                            return descriptor;
                        }
                        var modulePath;
                        if (descriptor.modulePath) {
                            modulePath = descriptor.modulePath.substr(0, 2) === './' ? descriptor.modulePath.substr(2) : descriptor.modulePath;
                        }
                        return descriptor.packageName + (descriptor.version ? '@' + descriptor.version : '') + (modulePath ? '#' + modulePath : '') + (descriptor.plugin ? descriptor.plugin : '');
                    }
                },
                isNpm: function (moduleName) {
                    return npmModuleRegEx.test(moduleName);
                },
                isConditional: function (moduleName) {
                    return conditionalModuleRegEx.test(moduleName);
                },
                isFullyConvertedNpm: function (parsedModuleName) {
                    return !!(parsedModuleName.packageName && parsedModuleName.version && parsedModuleName.modulePath);
                },
                isScoped: function (moduleName) {
                    return moduleName[0] === '@';
                },
                parse: function (moduleName, currentPackageName, global, context) {
                    var pluginParts = moduleName.split('!');
                    var modulePathParts = pluginParts[0].split('#');
                    var versionParts = modulePathParts[0].split('@');
                    if (!modulePathParts[1] && !versionParts[0]) {
                        versionParts = ['@' + versionParts[1]];
                    }
                    if (versionParts.length === 3 && utils.moduleName.isScoped(moduleName)) {
                        versionParts.splice(0, 1);
                        versionParts[0] = '@' + versionParts[0];
                    }
                    var packageName, modulePath;
                    if (currentPackageName && utils.path.isRelative(moduleName)) {
                        packageName = currentPackageName;
                        modulePath = versionParts[0];
                    } else if (currentPackageName && utils.path.isInHomeDir(moduleName, context)) {
                        packageName = currentPackageName;
                        modulePath = versionParts[0].split('/').slice(1).join('/');
                    } else {
                        if (modulePathParts[1]) {
                            packageName = versionParts[0];
                            modulePath = modulePathParts[1];
                        } else {
                            var folderParts = versionParts[0].split('/');
                            if (folderParts.length && folderParts[0][0] === '@') {
                                packageName = folderParts.splice(0, 2).join('/');
                            } else {
                                packageName = folderParts.shift();
                            }
                            modulePath = folderParts.join('/');
                        }
                    }
                    modulePath = utils.path.removeJS(modulePath);
                    return {
                        plugin: pluginParts.length === 2 ? '!' + pluginParts[1] : undefined,
                        version: versionParts[1],
                        modulePath: modulePath,
                        packageName: packageName,
                        moduleName: moduleName,
                        isGlobal: global
                    };
                },
                parseFromPackage: function (loader, refPkg, name, parentName) {
                    var packageName = utils.pkg.name(refPkg), parsedModuleName = utils.moduleName.parse(name, packageName, undefined, { loader: loader }), isRelative = utils.path.isRelative(parsedModuleName.modulePath);
                    if (isRelative && !parentName) {
                        throw new Error('Cannot resolve a relative module identifier ' + 'with no parent module:', name);
                    }
                    if (isRelative) {
                        var parentParsed = utils.moduleName.parse(parentName, packageName);
                        if (parentParsed.packageName === parsedModuleName.packageName && parentParsed.modulePath) {
                            var makePathRelative = true;
                            if (name === '../' || name === './' || name === '..') {
                                var relativePath = utils.path.relativeTo(parentParsed.modulePath, name);
                                var isInRoot = utils.path.isPackageRootDir(relativePath);
                                if (isInRoot) {
                                    parsedModuleName.modulePath = utils.pkg.main(refPkg);
                                    makePathRelative = false;
                                } else {
                                    parsedModuleName.modulePath = name + (utils.path.endsWithSlash(name) ? '' : '/') + 'index';
                                }
                            }
                            if (makePathRelative) {
                                parsedModuleName.modulePath = utils.path.makeRelative(utils.path.joinURIs(parentParsed.modulePath, parsedModuleName.modulePath));
                            }
                        }
                    }
                    var mapName = utils.moduleName.create(parsedModuleName), refSteal = utils.pkg.config(refPkg), mappedName;
                    if (refPkg.browser && typeof refPkg.browser !== 'string' && mapName in refPkg.browser && (!refSteal || !refSteal.ignoreBrowser)) {
                        mappedName = refPkg.browser[mapName] === false ? '@empty' : refPkg.browser[mapName];
                    }
                    var global = loader && loader.globalBrowser && loader.globalBrowser[mapName];
                    if (global) {
                        mappedName = global.moduleName === false ? '@empty' : global.moduleName;
                    }
                    if (mappedName) {
                        return utils.moduleName.parse(mappedName, packageName, !!global);
                    } else {
                        return parsedModuleName;
                    }
                },
                nameAndVersion: function (parsedModuleName) {
                    return parsedModuleName.packageName + '@' + parsedModuleName.version;
                },
                isBareIdentifier: function (identifier) {
                    return identifier && identifier[0] !== '.' && identifier[0] !== '@';
                }
            },
            pkg: {
                name: function (pkg) {
                    var steal = utils.pkg.config(pkg);
                    return steal && steal.name || pkg.name;
                },
                main: function (pkg) {
                    var main;
                    var steal = utils.pkg.config(pkg);
                    if (steal && steal.main) {
                        main = steal.main;
                    } else if (typeof pkg.browser === 'string') {
                        if (utils.path.endsWithSlash(pkg.browser)) {
                            main = pkg.browser + 'index';
                        } else {
                            main = pkg.browser;
                        }
                    } else if (typeof pkg.jam === 'object' && pkg.jam.main) {
                        main = pkg.jam.main;
                    } else if (pkg.main) {
                        main = pkg.main;
                    } else {
                        main = 'index';
                    }
                    return utils.path.removeJS(utils.path.removeDotSlash(main));
                },
                rootDir: function (pkg, isRoot) {
                    var root = isRoot ? utils.path.removePackage(pkg.fileUrl) : utils.path.pkgDir(pkg.fileUrl);
                    var lib = utils.pkg.directoriesLib(pkg);
                    if (lib) {
                        root = utils.path.joinURIs(utils.path.addEndingSlash(root), lib);
                    }
                    return root;
                },
                isRoot: function (loader, pkg) {
                    var root = utils.pkg.getDefault(loader);
                    return pkg.name === root.name && pkg.version === root.version;
                },
                homeAlias: function (context) {
                    return context && context.loader && context.loader.homeAlias || '~';
                },
                getDefault: function (loader) {
                    return loader.npmPaths.__default;
                },
                findByModuleNameOrAddress: function (loader, moduleName, moduleAddress) {
                    if (loader.npm) {
                        if (moduleName) {
                            var parsed = utils.moduleName.parse(moduleName);
                            if (parsed.version && parsed.packageName) {
                                var name = parsed.packageName + '@' + parsed.version;
                                if (name in loader.npm) {
                                    return loader.npm[name];
                                }
                            }
                        }
                        if (moduleAddress) {
                            var startingAddress = utils.relativeURI(loader.baseURL, moduleAddress);
                            var packageFolder = utils.pkg.folderAddress(startingAddress);
                            return packageFolder ? loader.npmPaths[packageFolder] : utils.pkg.getDefault(loader);
                        } else {
                            return utils.pkg.getDefault(loader);
                        }
                    }
                },
                folderAddress: function (address) {
                    var nodeModules = '/node_modules/', nodeModulesIndex = address.lastIndexOf(nodeModules), nextSlash = address.indexOf('/', nodeModulesIndex + nodeModules.length);
                    if (nodeModulesIndex >= 0) {
                        return nextSlash >= 0 ? address.substr(0, nextSlash) : address;
                    }
                },
                findDep: function (loader, refPkg, name) {
                    if (loader.npm && refPkg && !utils.path.startsWithDotSlash(name)) {
                        var nameAndVersion = name + '@' + refPkg.resolutions[name];
                        var pkg = loader.npm[nameAndVersion];
                        return pkg;
                    }
                },
                findDepWalking: function (loader, refPackage, name) {
                    if (loader.npm && refPackage && !utils.path.startsWithDotSlash(name)) {
                        var curPackage = utils.path.depPackageDir(refPackage.fileUrl, name);
                        while (curPackage) {
                            var pkg = loader.npmPaths[curPackage];
                            if (pkg) {
                                return pkg;
                            }
                            var parentAddress = utils.path.parentNodeModuleAddress(curPackage);
                            if (!parentAddress) {
                                return;
                            }
                            curPackage = parentAddress + '/' + name;
                        }
                    }
                },
                findByName: function (loader, name) {
                    if (loader.npm && !utils.path.startsWithDotSlash(name)) {
                        return loader.npm[name];
                    }
                },
                findByNameAndVersion: function (loader, name, version) {
                    if (loader.npm && !utils.path.startsWithDotSlash(name)) {
                        var nameAndVersion = name + '@' + version;
                        return loader.npm[nameAndVersion];
                    }
                },
                findByUrl: function (loader, url) {
                    if (loader.npm) {
                        var fullUrl = utils.pkg.folderAddress(url);
                        return loader.npmPaths[fullUrl];
                    }
                },
                directoriesLib: function (pkg) {
                    var steal = utils.pkg.config(pkg);
                    var lib = steal && steal.directories && steal.directories.lib;
                    var ignores = [
                            '.',
                            '/'
                        ], ignore;
                    if (!lib)
                        return undefined;
                    while (!!(ignore = ignores.shift())) {
                        if (lib[0] === ignore) {
                            lib = lib.substr(1);
                        }
                    }
                    return lib;
                },
                hasDirectoriesLib: function (pkg) {
                    var steal = utils.pkg.config(pkg);
                    return steal && steal.directories && !!steal.directories.lib;
                },
                findPackageInfo: function (context, pkg) {
                    var pkgInfo = context.pkgInfo;
                    if (pkgInfo) {
                        var out;
                        utils.forEach(pkgInfo, function (p) {
                            if (pkg.name === p.name && pkg.version === p.version) {
                                out = p;
                            }
                        });
                        return out;
                    }
                },
                saveResolution: function (context, refPkg, pkg) {
                    var npmPkg = utils.pkg.findPackageInfo(context, refPkg);
                    npmPkg.resolutions[pkg.name] = refPkg.resolutions[pkg.name] = pkg.version;
                },
                config: function (pkg) {
                    return pkg.steal || pkg.system;
                }
            },
            path: {
                makeRelative: function (path) {
                    if (utils.path.isRelative(path) && path.substr(0, 1) !== '/') {
                        return path;
                    } else {
                        return './' + path;
                    }
                },
                removeJS: function (path) {
                    return path.replace(/\.js(!|$)/, function (whole, part) {
                        return part;
                    });
                },
                removePackage: function (path) {
                    return path.replace(/\/package\.json.*/, '');
                },
                addJS: function (path) {
                    if (/\.js(on)?$/.test(path)) {
                        return path;
                    } else {
                        return path + '.js';
                    }
                },
                isRelative: function (path) {
                    return path.substr(0, 1) === '.';
                },
                isInHomeDir: function (path, context) {
                    return path.substr(0, 2) === utils.pkg.homeAlias(context) + '/';
                },
                joinURIs: function (baseUri, rel) {
                    function removeDotSegments(input) {
                        var output = [];
                        input.replace(/^(\.\.?(\/|$))+/, '').replace(/\/(\.(\/|$))+/g, '/').replace(/\/\.\.$/, '/../').replace(/\/?[^\/]*/g, function (p) {
                            if (p === '/..') {
                                output.pop();
                            } else {
                                output.push(p);
                            }
                        });
                        return output.join('').replace(/^\//, input.charAt(0) === '/' ? '/' : '');
                    }
                    var href = parseURI(rel || '');
                    var base = parseURI(baseUri || '');
                    return !href || !base ? null : (href.protocol || base.protocol) + (href.protocol || href.authority ? href.authority : base.authority) + removeDotSegments(href.protocol || href.authority || href.pathname.charAt(0) === '/' ? href.pathname : href.pathname ? (base.authority && !base.pathname ? '/' : '') + base.pathname.slice(0, base.pathname.lastIndexOf('/') + 1) + href.pathname : base.pathname) + (href.protocol || href.authority || href.pathname ? href.search : href.search || base.search) + href.hash;
                },
                startsWithDotSlash: function (path) {
                    return path.substr(0, 2) === './';
                },
                removeDotSlash: function (path) {
                    return utils.path.startsWithDotSlash(path) ? path.substr(2) : path;
                },
                endsWithSlash: function (path) {
                    return path[path.length - 1] === '/';
                },
                addEndingSlash: function (path) {
                    return utils.path.endsWithSlash(path) ? path : path + '/';
                },
                depPackage: function (parentPackageAddress, childName) {
                    var packageFolderName = parentPackageAddress.replace(/\/package\.json.*/, '');
                    return (packageFolderName ? packageFolderName + '/' : '') + 'node_modules/' + childName + '/package.json';
                },
                peerPackage: function (parentPackageAddress, childName) {
                    var packageFolderName = parentPackageAddress.replace(/\/package\.json.*/, '');
                    return packageFolderName.substr(0, packageFolderName.lastIndexOf('/')) + '/' + childName + '/package.json';
                },
                depPackageDir: function (parentPackageAddress, childName) {
                    return utils.path.depPackage(parentPackageAddress, childName).replace(/\/package\.json.*/, '');
                },
                peerNodeModuleAddress: function (address) {
                    var nodeModules = '/node_modules/', nodeModulesIndex = address.lastIndexOf(nodeModules);
                    if (nodeModulesIndex >= 0) {
                        return address.substr(0, nodeModulesIndex + nodeModules.length - 1);
                    }
                },
                parentNodeModuleAddress: function (address) {
                    var nodeModules = '/node_modules/', nodeModulesIndex = address.lastIndexOf(nodeModules), prevModulesIndex = address.lastIndexOf(nodeModules, nodeModulesIndex - 1);
                    if (prevModulesIndex >= 0) {
                        return address.substr(0, prevModulesIndex + nodeModules.length - 1);
                    }
                },
                pkgDir: function (address) {
                    var nodeModules = '/node_modules/', nodeModulesIndex = address.lastIndexOf(nodeModules), nextSlash = address.indexOf('/', nodeModulesIndex + nodeModules.length);
                    if (address[nodeModulesIndex + nodeModules.length] === '@') {
                        nextSlash = address.indexOf('/', nextSlash + 1);
                    }
                    if (nodeModulesIndex >= 0) {
                        return nextSlash >= 0 ? address.substr(0, nextSlash) : address;
                    }
                },
                basename: function (address) {
                    var parts = address.split('/');
                    return parts[parts.length - 1];
                },
                relativeTo: function (modulePath, rel) {
                    var parts = modulePath.split('/');
                    var idx = 1;
                    while (rel[idx] === '.') {
                        parts.pop();
                        idx++;
                    }
                    return parts.join('/');
                },
                isPackageRootDir: function (pth) {
                    return pth.indexOf('/') === -1;
                }
            },
            json: {
                transform: function (loader, load, data) {
                    data.steal = utils.pkg.config(data);
                    var fn = loader.jsonOptions && loader.jsonOptions.transform;
                    if (!fn)
                        return data;
                    return fn.call(loader, load, data);
                }
            },
            includeInBuild: true
        };
        function parseURI(url) {
            var m = String(url).replace(/^\s+|\s+$/g, '').match(/^([^:\/?#]+:)?(\/\/(?:[^:@\/]*(?::[^:@\/]*)?@)?(([^:\/?#]*)(?::(\d*))?))?([^?#]*)(\?[^#]*)?(#[\s\S]*)?/);
            return m ? {
                href: m[0] || '',
                protocol: m[1] || '',
                authority: m[2] || '',
                host: m[3] || '',
                hostname: m[4] || '',
                port: m[5] || '',
                pathname: m[6] || '',
                search: m[7] || '',
                hash: m[8] || ''
            } : null;
        }
        module.exports = utils;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*npm-extension*/
define('npm-extension', [
    'require',
    'exports',
    'module',
    '@steal',
    './npm-utils'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'format cjs';
        var steal = require('@steal');
        var utils = require('./npm-utils');
        exports.includeInBuild = true;
        var isNode = typeof process === 'object' && {}.toString.call(process) === '[object process]';
        var isWorker = typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope;
        var isBrowser = typeof window !== 'undefined' && !isNode && !isWorker;
        exports.addExtension = function (System) {
            if (System._extensions) {
                System._extensions.push(exports.addExtension);
            }
            var oldNormalize = System.normalize;
            System.normalize = function (identifier, parentModuleName, parentAddress, pluginNormalize) {
                var name = identifier;
                var parentName = parentModuleName;
                if (parentName && this.npmParentMap && this.npmParentMap[parentName]) {
                    parentName = this.npmParentMap[parentName];
                }
                var hasNoParent = !parentName;
                var nameIsRelative = utils.path.isRelative(name);
                var parentIsNpmModule = utils.moduleName.isNpm(parentName);
                var identifierEndsWithSlash = utils.path.endsWithSlash(name);
                if (parentName && nameIsRelative && !parentIsNpmModule) {
                    return oldNormalize.call(this, name, parentName, parentAddress, pluginNormalize);
                }
                if (utils.moduleName.isConditional(name)) {
                    return oldNormalize.call(this, name, parentName, parentAddress, pluginNormalize);
                }
                var hasContextualMap = typeof this.map[parentName] === 'object' && this.map[parentName][name];
                if (hasContextualMap) {
                    return oldNormalize.call(this, name, parentName, parentAddress, pluginNormalize);
                }
                var refPkg = utils.pkg.findByModuleNameOrAddress(this, parentName, parentAddress);
                if (!refPkg) {
                    return oldNormalize.call(this, name, parentName, parentAddress, pluginNormalize);
                }
                var isPointingAtParentFolder = name === '../' || name === './';
                if (parentIsNpmModule && isPointingAtParentFolder) {
                    var parsedParentModuleName = utils.moduleName.parse(parentName);
                    var parentModulePath = parsedParentModuleName.modulePath || '';
                    var relativePath = utils.path.relativeTo(parentModulePath, name);
                    var isInRoot = utils.path.isPackageRootDir(relativePath);
                    if (isInRoot) {
                        name = refPkg.name + '#' + utils.path.removeJS(refPkg.main);
                    } else {
                        name = name + 'index';
                    }
                }
                var parsedModuleName = utils.moduleName.parseFromPackage(this, refPkg, name, parentName);
                var isRoot = utils.pkg.isRoot(this, refPkg);
                var parsedPackageNameIsReferringPackage = parsedModuleName.packageName === refPkg.name;
                var isRelativeToParentNpmModule = parentIsNpmModule && nameIsRelative && parsedPackageNameIsReferringPackage;
                var depPkg, wantedPkg;
                if (isRelativeToParentNpmModule) {
                    depPkg = refPkg;
                }
                var context = this.npmContext;
                var crawl = context && context.crawl;
                var isDev = !!crawl;
                if (!depPkg) {
                    if (crawl) {
                        var parentPkg = nameIsRelative ? null : crawl.matchedVersion(context, refPkg.name, refPkg.version);
                        if (parentPkg) {
                            var depMap = crawl.getFullDependencyMap(this, parentPkg, isRoot);
                            wantedPkg = depMap[parsedModuleName.packageName];
                            if (wantedPkg) {
                                var wantedVersion = refPkg.resolutions && refPkg.resolutions[wantedPkg.name] || wantedPkg.version;
                                var foundPkg = crawl.matchedVersion(this.npmContext, wantedPkg.name, wantedVersion);
                                if (foundPkg) {
                                    depPkg = utils.pkg.findByUrl(this, foundPkg.fileUrl);
                                }
                            }
                        }
                    } else {
                        if (isRoot) {
                            depPkg = utils.pkg.findDepWalking(this, refPkg, parsedModuleName.packageName);
                        } else {
                            depPkg = utils.pkg.findDep(this, refPkg, parsedModuleName.packageName);
                        }
                    }
                }
                if (parsedPackageNameIsReferringPackage) {
                    depPkg = utils.pkg.findByNameAndVersion(this, parsedModuleName.packageName, refPkg.version);
                }
                var lookupByName = parsedModuleName.isGlobal || hasNoParent;
                if (!depPkg) {
                    depPkg = utils.pkg.findByName(this, parsedModuleName.packageName);
                }
                var isThePackageWeWant = !isDev || !depPkg || (wantedPkg ? crawl.pkgSatisfies(depPkg, wantedPkg.version) : true);
                if (!isThePackageWeWant) {
                    depPkg = undefined;
                } else if (isDev && depPkg) {
                    utils.pkg.saveResolution(context, refPkg, depPkg);
                }
                if (!depPkg) {
                    var browserPackageName = this.globalBrowser[parsedModuleName.packageName];
                    if (browserPackageName) {
                        parsedModuleName.packageName = browserPackageName.moduleName;
                        depPkg = utils.pkg.findByName(this, parsedModuleName.packageName);
                    }
                }
                if (!depPkg && isRoot && name === refPkg.main && utils.pkg.hasDirectoriesLib(refPkg)) {
                    parsedModuleName.version = refPkg.version;
                    parsedModuleName.packageName = refPkg.name;
                    parsedModuleName.modulePath = utils.pkg.main(refPkg);
                    return oldNormalize.call(this, utils.moduleName.create(parsedModuleName), parentName, parentAddress, pluginNormalize);
                }
                var loader = this;
                if (!depPkg) {
                    if (crawl) {
                        var parentPkg = crawl.matchedVersion(this.npmContext, refPkg.name, refPkg.version);
                        if (parentPkg) {
                            var depMap = crawl.getFullDependencyMap(this, parentPkg, isRoot);
                            depPkg = depMap[parsedModuleName.packageName];
                            if (!depPkg) {
                                var parents = crawl.findPackageAndParents(this.npmContext, parsedModuleName.packageName);
                                if (parents) {
                                    depPkg = parents.package;
                                }
                            }
                        }
                    }
                    if (!depPkg) {
                        if (refPkg.browser && refPkg.browser[name]) {
                            return oldNormalize.call(this, refPkg.browser[name], parentName, parentAddress, pluginNormalize);
                        }
                        var steal = utils.pkg.config(refPkg);
                        if (steal && steal.map && typeof steal.map[name] === 'string') {
                            return loader.normalize(steal.map[name], parentName, parentAddress, pluginNormalize);
                        } else {
                            return oldNormalize.call(this, name, parentName, parentAddress, pluginNormalize);
                        }
                    }
                    return crawl.dep(this.npmContext, parentPkg, refPkg, depPkg, isRoot).then(createModuleNameAndNormalize);
                } else {
                    return createModuleNameAndNormalize(depPkg);
                }
                function createModuleNameAndNormalize(depPkg) {
                    parsedModuleName.version = depPkg.version;
                    if (!parsedModuleName.modulePath) {
                        parsedModuleName.modulePath = utils.pkg.main(depPkg);
                    }
                    var p = oldNormalize.call(loader, utils.moduleName.create(parsedModuleName), parentName, parentAddress, pluginNormalize);
                    if (identifierEndsWithSlash) {
                        p.then(function (name) {
                            if (context && context.forwardSlashMap) {
                                context.forwardSlashMap[name] = true;
                            }
                        });
                    }
                    return p;
                }
            };
            var oldLocate = System.locate;
            System.locate = function (load) {
                var parsedModuleName = utils.moduleName.parse(load.name), loader = this;
                load.metadata.parsedModuleName = parsedModuleName;
                if (parsedModuleName.version && this.npm && !loader.paths[load.name]) {
                    var pkg = this.npm[utils.moduleName.nameAndVersion(parsedModuleName)];
                    if (pkg) {
                        return oldLocate.call(this, load).then(function (locatedAddress) {
                            var address = locatedAddress;
                            var expectedAddress = utils.path.joinURIs(System.baseURL, load.name);
                            if (isBrowser) {
                                expectedAddress = expectedAddress.replace(/#/g, '%23');
                            }
                            if (address !== expectedAddress + '.js' && address !== expectedAddress) {
                                return address;
                            }
                            var root = utils.pkg.rootDir(pkg, utils.pkg.isRoot(loader, pkg));
                            if (parsedModuleName.modulePath) {
                                var npmAddress = utils.path.joinURIs(utils.path.addEndingSlash(root), parsedModuleName.plugin ? parsedModuleName.modulePath : utils.path.addJS(parsedModuleName.modulePath));
                                address = typeof steal !== 'undefined' ? utils.path.joinURIs(loader.baseURL, npmAddress) : npmAddress;
                            }
                            return address;
                        });
                    }
                }
                return oldLocate.call(this, load);
            };
            var oldFetch = System.fetch;
            System.fetch = function (load) {
                if (load.metadata.dryRun) {
                    return oldFetch.apply(this, arguments);
                }
                var loader = this;
                var context = loader.npmContext;
                var fetchPromise = Promise.resolve(oldFetch.apply(this, arguments));
                if (utils.moduleName.isNpm(load.name)) {
                    fetchPromise = fetchPromise.then(null, function (err) {
                        if (err.statusCode !== 404) {
                            return Promise.reject(err);
                        }
                        var types = [].slice.call(retryTypes);
                        return retryAll(types, err);
                        function retryAll(types, err) {
                            if (!types.length) {
                                throw err;
                            }
                            var type = types.shift();
                            if (!type.test(load)) {
                                throw err;
                            }
                            return Promise.resolve(retryFetch.call(loader, load, type)).then(null, function (err) {
                                return retryAll(types, err);
                            });
                        }
                    });
                }
                return fetchPromise.catch(function (error) {
                    if (error.statusCode === 404 && utils.moduleName.isBareIdentifier(load.name)) {
                        throw new Error([
                            'Could not load \'' + load.name + '\'',
                            'Is this an npm module not saved in your package.json?'
                        ].join('\n'));
                    } else {
                        throw error;
                    }
                });
            };
            var convertName = function (loader, name) {
                var pkg = utils.pkg.findByName(loader, name.split('/')[0]);
                if (pkg) {
                    var parsed = utils.moduleName.parse(name, pkg.name);
                    parsed.version = pkg.version;
                    if (!parsed.modulePath) {
                        parsed.modulePath = utils.pkg.main(pkg);
                    }
                    return utils.moduleName.create(parsed);
                }
                return name;
            };
            var configSpecial = {
                map: function (map) {
                    var newMap = {}, val;
                    for (var name in map) {
                        val = map[name];
                        newMap[convertName(this, name)] = typeof val === 'object' ? configSpecial.map(val) : convertName(this, val);
                    }
                    return newMap;
                },
                meta: function (map) {
                    var newMap = {};
                    for (var name in map) {
                        newMap[convertName(this, name)] = map[name];
                    }
                    return newMap;
                },
                paths: function (paths) {
                    var newPaths = {};
                    for (var name in paths) {
                        newPaths[convertName(this, name)] = paths[name];
                    }
                    return newPaths;
                }
            };
            var oldConfig = System.config;
            System.config = function (cfg) {
                var loader = this;
                if (loader.npmContext) {
                    var context = loader.npmContext;
                    var pkg = context.versions.__default;
                    context.convert.steal(context, pkg, cfg, true, false, false);
                    oldConfig.apply(loader, arguments);
                    return;
                }
                for (var name in cfg) {
                    if (configSpecial[name]) {
                        cfg[name] = configSpecial[name].call(loader, cfg[name]);
                    }
                }
                oldConfig.apply(loader, arguments);
            };
            steal.addNpmPackages = function (npmPackages) {
                var packages = npmPackages || [];
                var loader = this.loader;
                for (var i = 0; i < packages.length; i += 1) {
                    var pkg = packages[i];
                    var path = pkg && pkg.fileUrl;
                    if (path) {
                        loader.npmContext.paths[path] = pkg;
                    }
                }
            };
            steal.getNpmPackages = function () {
                var context = this.loader.npmContext;
                return context ? context.packages || [] : [];
            };
            function retryFetch(load, type) {
                var loader = this;
                var moduleName = typeof type.name === 'function' ? type.name(loader, load) : load.name + type.name;
                var local = utils.extend({}, load);
                local.name = moduleName;
                local.metadata = { dryRun: true };
                return Promise.resolve(loader.locate(local)).then(function (address) {
                    local.address = address;
                    return loader.fetch(local);
                }).then(function (source) {
                    load.metadata.address = local.address;
                    loader.npmParentMap[load.name] = local.name;
                    var npmLoad = loader.npmContext && loader.npmContext.npmLoad;
                    if (npmLoad) {
                        npmLoad.saveLoadIfNeeded(loader.npmContext);
                        if (!isNode) {
                            utils.warnOnce('Some 404s were encountered ' + 'while loading. Don\'t panic! ' + 'These will only happen in dev ' + 'and are harmless.');
                        }
                    }
                    return source;
                });
            }
            var retryTypes = [
                {
                    name: function (loader, load) {
                        var context = loader.npmContext;
                        if (context.forwardSlashMap[load.name]) {
                            var parts = load.name.split('/');
                            parts.pop();
                            return parts.concat(['index']).join('/');
                        }
                        return load.name + '/index';
                    },
                    test: function () {
                        return true;
                    }
                },
                {
                    name: '.json',
                    test: function (load) {
                        return utils.moduleName.isNpm(load.name) && utils.path.basename(load.address) === 'package.js';
                    }
                }
            ];
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*node_modules/steal-conditional/conditional*/
define('node_modules/steal-conditional/conditional', [
    'module',
    'exports'
], function (module, exports) {
    exports.extensionBuilder = 'steal-conditional/slim';
    function addConditionals(loader) {
        var conditionalRegEx = /#\{[^\}]+\}|#\?.+$/;
        var isNode = typeof process === 'object' && {}.toString.call(process) === '[object process]';
        if (loader._extensions) {
            loader._extensions.push(addConditionals);
        }
        loader.set('@@conditional-helpers', loader.newModule({
            isConditionalModuleName: function (moduleName) {
                return conditionalRegEx.test(moduleName);
            }
        }));
        var normalize = loader.normalize;
        function readMemberExpression(p, value) {
            var pParts = p.split('.');
            while (pParts.length) {
                value = value[pParts.shift()];
            }
            return value;
        }
        function includeInBuild(loader, name) {
            var load = loader.getModuleLoad(name);
            load.metadata.includeInBuild = true;
        }
        function getGlob() {
            if (isNode) {
                return loader.import('@node-require', { name: module.id }).then(function (nodeRequire) {
                    return nodeRequire('glob');
                });
            }
            return Promise.resolve();
        }
        function pushIfUnique(array, item) {
            return array.indexOf(item) === -1 ? array.push(item) : array.length;
        }
        function getModuleName(nameWithConditional, variation) {
            var modName;
            var conditionIndex = nameWithConditional.search(conditionalRegEx);
            var lastSlashIndex = nameWithConditional.indexOf('/', nameWithConditional.indexOf('}'));
            if (lastSlashIndex !== -1) {
                modName = nameWithConditional.substr(0, conditionIndex) + variation;
            } else {
                modName = nameWithConditional.replace(conditionalRegEx, variation);
            }
            return modName;
        }
        loader.normalize = function (name, parentName, parentAddress, pluginNormalize) {
            var loader = this;
            var conditionalMatch = name.match(conditionalRegEx);
            if (conditionalMatch) {
                var substitution = conditionalMatch[0][1] !== '?';
                var conditionModule = substitution ? conditionalMatch[0].substr(2, conditionalMatch[0].length - 3) : conditionalMatch[0].substr(2);
                var conditionExport = 'default';
                var conditionExportParts = conditionModule.match(/^(?:\.\/|\.\.\/)+/);
                var conditionExportIndex = conditionModule.indexOf('.', conditionExportParts && conditionExportParts[0].length);
                if (conditionExportIndex !== -1) {
                    conditionExport = conditionModule.substr(conditionExportIndex + 1);
                    conditionModule = conditionModule.substr(0, conditionExportIndex);
                }
                var booleanNegation = !substitution && conditionModule[0] === '~';
                if (booleanNegation) {
                    conditionModule = conditionModule.substr(1);
                }
                var handleConditionalBuild = function () {
                };
                var handleConditionalEval = function (m) {
                    var conditionValue = typeof m === 'object' ? readMemberExpression(conditionExport, m) : m;
                    if (substitution) {
                        if (typeof conditionValue !== 'string') {
                            throw new TypeError('The condition value for ' + conditionalMatch[0] + ' doesn\'t resolve to a string.');
                        }
                        name = name.replace(conditionalRegEx, conditionValue);
                    } else {
                        if (typeof conditionValue !== 'boolean') {
                            throw new TypeError('The condition value for ' + conditionalMatch[0] + ' isn\'t resolving to a boolean.');
                        }
                        if (booleanNegation) {
                            conditionValue = !conditionValue;
                        }
                        if (!conditionValue) {
                            name = '@empty';
                        } else {
                            name = name.replace(conditionalRegEx, '');
                        }
                    }
                    if (name === '@empty') {
                        return normalize.call(loader, name, parentName, parentAddress, pluginNormalize);
                    } else {
                        return loader.normalize.call(loader, name, parentName, parentAddress, pluginNormalize);
                    }
                };
                var isBuild = (loader.env || '').indexOf('build') === 0;
                var pluginLoader = isBuild ? loader : loader.pluginLoader || loader;
                return pluginLoader['import'](conditionModule, {
                    name: parentName,
                    address: parentAddress
                }).then(function (m) {
                    return pluginLoader.normalize(conditionModule, parentName, parentAddress, pluginNormalize).then(function (fullName) {
                        includeInBuild(pluginLoader, fullName);
                        return m;
                    });
                }).then(function (m) {
                    return isBuild ? handleConditionalBuild() : handleConditionalEval(m);
                });
            }
            return Promise.resolve(normalize.call(loader, name, parentName, parentAddress, pluginNormalize));
        };
    }
    if (typeof System !== 'undefined') {
        addConditionals(System);
    }
});
/*npm-load*/
define('npm-load', [], function(){ return {}; });
/*semver*/
define('semver', [], function(){ return {}; });
/*npm-crawl*/
define('npm-crawl', [], function(){ return {}; });
/*npm-convert*/
define('npm-convert', [], function(){ return {}; });
/*npm*/
define('npm', [], function(){ return {}; });
/*package.json!npm*/
define('package.json!npm', [
    '@loader',
    'npm-extension',
    'module',
    './node_modules/steal-conditional/conditional.js',
    './node_modules/steal-conditional/conditional.js'
], function (loader, npmExtension, module) {
    npmExtension.addExtension(loader);
    if (!loader.main) {
        loader.main = 'can@4.0.0-pre.0#can';
    }
    loader._npmExtensions = [].slice.call(arguments, 2);
    (function (loader, packages, options) {
        var g = loader.global;
        if (!g.process) {
            g.process = {
                argv: [],
                cwd: function () {
                    var baseURL = loader.baseURL;
                    return baseURL;
                },
                browser: true,
                env: { NODE_ENV: loader.env },
                version: '',
                platform: navigator && navigator.userAgent && /Windows/.test(navigator.userAgent) ? 'win' : ''
            };
        }
        if (!loader.npm) {
            loader.npm = {};
            loader.npmPaths = {};
            loader.globalBrowser = {};
        }
        if (!loader.npmParentMap) {
            loader.npmParentMap = options.npmParentMap || {};
        }
        var rootPkg = loader.npmPaths.__default = packages[0];
        var rootConfig = rootPkg.steal || rootPkg.system;
        var lib = rootConfig && rootConfig.directories && rootConfig.directories.lib;
        var setGlobalBrowser = function (globals, pkg) {
            for (var name in globals) {
                loader.globalBrowser[name] = {
                    pkg: pkg,
                    moduleName: globals[name]
                };
            }
        };
        var setInNpm = function (name, pkg) {
            if (!loader.npm[name]) {
                loader.npm[name] = pkg;
            }
            loader.npm[name + '@' + pkg.version] = pkg;
        };
        var forEach = function (arr, fn) {
            var i = 0, len = arr.length;
            for (; i < len; i++) {
                res = fn.call(arr, arr[i], i);
                if (res === false)
                    break;
            }
        };
        var setupLiveReload = function () {
            if (loader.liveReloadInstalled) {
                loader['import']('live-reload', { name: module.id }).then(function (reload) {
                    reload.dispose(function () {
                        var pkgInfo = loader.npmContext.pkgInfo;
                        delete pkgInfo[rootPkg.name + '@' + rootPkg.version];
                        var idx = -1;
                        forEach(pkgInfo, function (pkg, i) {
                            if (pkg.name === rootPkg.name && pkg.version === rootPkg.version) {
                                idx = i;
                                return false;
                            }
                        });
                        pkgInfo.splice(idx, 1);
                    });
                });
            }
        };
        var ignoredConfig = [
            'bundle',
            'configDependencies',
            'transpiler'
        ];
        packages.reverse();
        forEach(packages, function (pkg) {
            var steal = pkg.steal || pkg.system;
            if (steal) {
                var main = steal.main;
                delete steal.main;
                var configDeps = steal.configDependencies;
                if (pkg !== rootPkg) {
                    forEach(ignoredConfig, function (name) {
                        delete steal[name];
                    });
                }
                loader.config(steal);
                if (pkg === rootPkg) {
                    steal.configDependencies = configDeps;
                }
                steal.main = main;
            }
            if (pkg.globalBrowser) {
                var doNotApplyGlobalBrowser = pkg.name === 'steal' && rootConfig.builtins === false;
                if (!doNotApplyGlobalBrowser) {
                    setGlobalBrowser(pkg.globalBrowser, pkg);
                }
            }
            var systemName = steal && steal.name;
            if (systemName) {
                setInNpm(systemName, pkg);
            } else {
                setInNpm(pkg.name, pkg);
            }
            if (!loader.npm[pkg.name]) {
                loader.npm[pkg.name] = pkg;
            }
            loader.npm[pkg.name + '@' + pkg.version] = pkg;
            var pkgAddress = pkg.fileUrl.replace(/\/package\.json.*/, '');
            loader.npmPaths[pkgAddress] = pkg;
        });
        setupLiveReload();
        forEach(loader._npmExtensions || [], function (ext) {
            if (ext.systemConfig) {
                loader.config(ext.systemConfig);
            }
        });
    }(loader, [
        {
            'name': 'can',
            'version': '4.0.0-pre.0',
            'fileUrl': './package.json',
            'main': 'can.js',
            'steal': {
                'npmAlgorithm': 'flat',
                'main': 'can',
                'npmIgnore': {
                    'bit-docs': true,
                    'testee': true,
                    'async': true,
                    'saucelabs': true,
                    'test-saucelabs': true,
                    'wd': true,
                    'http-server': true
                },
                'meta': { 'socket.io-client/dist/socket.io': { 'format': 'cjs' } },
                'configDependencies': ['./node_modules/steal-conditional/conditional.js']
            },
            'resolutions': {
                'can': '4.0.0-pre.0',
                'can-component': '4.0.0-pre.2',
                'can-define': '2.0.0-pre.11',
                'can-ajax': '1.0.9',
                'can-construct': '3.2.2',
                'can-stache-bindings': '4.0.0-pre.8',
                'can-control': '4.0.0-pre.2',
                'can-construct-super': '3.1.2',
                'can-define-lazy-value': '1.0.0',
                'can-event-queue': '0.2.2',
                'can-globals': '0.2.3',
                'can-key-tree': '0.1.0',
                'can-param': '1.0.1',
                'can-queues': '0.2.6',
                'can-reflect': '1.7.1',
                'can-reflect-promise': '2.0.0-pre.4',
                'can-simple-observable': '2.0.0-pre.16',
                'can-stache-key': '1.0.0-pre.8',
                'can-symbol': '1.4.1',
                'can-view-live': '4.0.0-pre.11',
                'can-view-model': '4.0.0-pre.3',
                'can-view-nodelist': '3.1.0',
                'can-view-parser': '3.6.2',
                'can-view-scope': '4.0.0-pre.22',
                'can-view-target': '3.1.4',
                'can-deparam': '1.0.1',
                'can-simple-dom': '1.3.0',
                'can-ndjson-stream': '0.1.6'
            }
        },
        {
            'name': 'can-component',
            'version': '4.0.0-pre.2',
            'fileUrl': './node_modules/can-component/package.json',
            'main': 'can-component',
            'steal': {},
            'resolutions': {
                'can-component': '4.0.0-pre.2',
                'can-util': '3.10.12',
                'can-view-model': '4.0.0-pre.3',
                'can-define': '2.0.0-pre.11',
                'can-queues': '0.2.6',
                'can-view-scope': '4.0.0-pre.22',
                'can-simple-observable': '2.0.0-pre.16',
                'can-reflect': '1.7.1',
                'can-construct': '3.2.2',
                'can-symbol': '1.4.1',
                'can-stache': '4.0.0-pre.7',
                'can-view-callbacks': '4.0.0-pre.2',
                'steal-qunit': '1.0.1',
                'can-simple-map': '4.0.0-pre.7',
                'can-namespace': '1.0.0',
                'can-stache-bindings': '4.0.0-pre.8',
                'can-view-nodelist': '3.1.0',
                'can-globals': '0.2.3',
                'can-control': '4.0.0-pre.2',
                'can-vdom': '3.2.3'
            }
        },
        {
            'name': 'can-define',
            'version': '2.0.0-pre.11',
            'fileUrl': './node_modules/can-define/package.json',
            'main': 'can-define.js',
            'resolutions': {
                'can-define': '2.0.0-pre.11',
                'can-reflect': '1.7.1',
                'can-util': '3.10.12',
                'can-observation': '4.0.0-pre.17',
                'steal-qunit': '1.0.1',
                'can-construct': '3.2.2',
                'can-namespace': '1.0.0',
                'can-symbol': '1.4.1',
                'can-queues': '0.2.6',
                'can-log': '0.1.0',
                'can-test-helpers': '1.1.0',
                'can-simple-observable': '2.0.0-pre.16',
                'can-event-queue': '0.2.2',
                'can-define-lazy-value': '1.0.0',
                'can-cid': '1.1.1'
            }
        },
        {
            'name': 'can-ajax',
            'version': '1.0.9',
            'fileUrl': './node_modules/can-ajax/package.json',
            'main': 'dist/cjs/can-ajax',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-ajax'
            },
            'resolutions': {
                'can-ajax': '1.0.9',
                'can-globals': '0.2.3',
                'can-namespace': '1.0.0',
                'can-parse-uri': '1.0.0',
                'can-make-map': '1.0.0',
                'can-param': '1.0.1',
                'qunitjs': '2.4.1',
                'steal-qunit': '1.0.1',
                'can-assign': '1.0.0'
            }
        },
        {
            'name': 'can-construct',
            'version': '3.2.2',
            'fileUrl': './node_modules/can-construct/package.json',
            'main': 'can-construct',
            'steal': {},
            'resolutions': {
                'can-construct': '3.2.2',
                'steal-qunit': '1.0.1',
                'can-util': '3.10.12',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-stache-bindings',
            'version': '4.0.0-pre.8',
            'fileUrl': './node_modules/can-stache-bindings/package.json',
            'main': 'can-stache-bindings',
            'steal': { 'main': 'can-stache-bindings' },
            'resolutions': {
                'can-stache-bindings': '4.0.0-pre.8',
                'can-util': '3.10.12',
                'can-define': '2.0.0-pre.11',
                'can-simple-observable': '2.0.0-pre.16',
                'can-symbol': '1.4.1',
                'can-reflect': '1.7.1',
                'can-view-model': '4.0.0-pre.3',
                'can-simple-map': '4.0.0-pre.7',
                'can-queues': '0.2.6',
                'can-stache': '4.0.0-pre.7',
                'can-view-callbacks': '4.0.0-pre.2',
                'steal-qunit': '1.0.1',
                'can-view-scope': '4.0.0-pre.22',
                'can-stache-key': '1.0.0-pre.8',
                'can-observation': '4.0.0-pre.17',
                'can-attribute-encoder': '0.3.1',
                'can-globals': '0.2.3',
                'can-view-nodelist': '3.1.0',
                'can-event-dom-enter': '1.0.2',
                'can-event-dom-radiochange': '1.0.2',
                'can-vdom': '3.2.3'
            }
        },
        {
            'name': 'can-control',
            'version': '4.0.0-pre.2',
            'fileUrl': './node_modules/can-control/package.json',
            'main': 'can-control',
            'steal': {},
            'resolutions': {
                'can-control': '4.0.0-pre.2',
                'can-define': '2.0.0-pre.11',
                'can-simple-observable': '2.0.0-pre.16',
                'can-simple-map': '4.0.0-pre.7',
                'steal-qunit': '1.0.1',
                'can-util': '3.10.12',
                'can-construct': '3.2.2',
                'can-namespace': '1.0.0',
                'can-stache-key': '1.0.0-pre.8',
                'can-reflect': '1.7.1',
                'can-observation': '4.0.0-pre.17',
                'can-symbol': '1.4.1'
            }
        },
        {
            'name': 'can-construct-super',
            'version': '3.1.2',
            'fileUrl': './node_modules/can-construct-super/package.json',
            'main': 'can-construct-super',
            'steal': {
                'npmIgnore': {
                    'documentjs': true,
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-construct-super'
            },
            'resolutions': {
                'can-construct-super': '3.1.2',
                'steal-qunit': '1.0.1',
                'can-util': '3.10.12',
                'can-construct': '3.2.2'
            }
        },
        {
            'name': 'can-define-lazy-value',
            'version': '1.0.0',
            'fileUrl': './node_modules/can-define-lazy-value/package.json',
            'main': 'define-lazy-value',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'steal-tools': true
                }
            },
            'resolutions': {
                'can-define-lazy-value': '1.0.0',
                'steal-qunit': '1.0.1'
            }
        },
        {
            'name': 'can-event-queue',
            'version': '0.2.2',
            'fileUrl': './node_modules/can-event-queue/package.json',
            'main': './can-event-queue.js',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'plugins': [
                    'steal-less',
                    'steal-stache'
                ]
            },
            'resolutions': {
                'can-event-queue': '0.2.2',
                'can-queues': '0.2.6',
                'steal-qunit': '1.0.1',
                'can-util': '3.10.12',
                'can-reflect': '1.7.1',
                'can-symbol': '1.4.1',
                'can-key-tree': '0.1.0'
            }
        },
        {
            'name': 'can-globals',
            'version': '0.2.3',
            'fileUrl': './node_modules/can-globals/package.json',
            'main': 'can-globals.js',
            'resolutions': {
                'can-globals': '0.2.3',
                'can-reflect': '1.7.1',
                'qunitjs': '2.4.1',
                'steal-qunit': '1.0.1',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-key-tree',
            'version': '0.1.0',
            'fileUrl': './node_modules/can-key-tree/package.json',
            'main': 'dist/cjs/can-key-tree',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'plugins': [
                    'steal-less',
                    'steal-stache'
                ],
                'main': 'can-key-tree'
            },
            'browser': {},
            'resolutions': {
                'can-key-tree': '0.1.0',
                'can-reflect': '1.7.1',
                'steal-qunit': '1.0.1'
            }
        },
        {
            'name': 'can-param',
            'version': '1.0.1',
            'fileUrl': './node_modules/can-param/package.json',
            'main': 'dist/cjs/can-param',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-param'
            },
            'resolutions': {
                'can-param': '1.0.1',
                'steal-qunit': '1.0.1',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-queues',
            'version': '0.2.6',
            'fileUrl': './node_modules/can-queues/package.json',
            'main': './can-queues.js',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-queues'
            },
            'resolutions': {
                'can-queues': '0.2.6',
                'can-util': '3.10.12',
                'steal-qunit': '1.0.1',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-reflect',
            'version': '1.7.1',
            'fileUrl': './node_modules/can-reflect/package.json',
            'main': 'can-reflect',
            'resolutions': {
                'can-reflect': '1.7.1',
                'can-symbol': '1.4.1',
                'can-namespace': '1.0.0',
                'steal-qunit': '1.0.1'
            }
        },
        {
            'name': 'can-reflect-promise',
            'version': '2.0.0-pre.4',
            'fileUrl': './node_modules/can-reflect-promise/package.json',
            'main': 'can-reflect-promise',
            'steal': { 'npmAlgorithm': 'flat' },
            'resolutions': {
                'can-symbol': '1.4.1',
                'can-reflect-promise': '2.0.0-pre.4',
                'can-observation-recorder': '0.1.0',
                'steal-qunit': '1.0.1',
                'can-util': '3.10.12',
                'can-reflect': '1.7.1',
                'can-queues': '0.2.6',
                'can-key-tree': '0.1.0'
            }
        },
        {
            'name': 'can-simple-observable',
            'version': '2.0.0-pre.16',
            'fileUrl': './node_modules/can-simple-observable/package.json',
            'main': 'can-simple-observable',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'steal-tools': true
                }
            },
            'resolutions': {
                'can-simple-observable': '2.0.0-pre.16',
                'can-reflect': '1.7.1',
                'steal-qunit': '1.0.1',
                'can-observation-recorder': '0.1.0',
                'can-namespace': '1.0.0',
                'can-key-tree': '0.1.0',
                'can-queues': '0.2.6',
                'can-observation': '4.0.0-pre.17',
                'can-log': '0.1.0'
            }
        },
        {
            'name': 'can-stache-key',
            'version': '1.0.0-pre.8',
            'fileUrl': './node_modules/can-stache-key/package.json',
            'main': 'can-stache-key',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-stache-key'
            },
            'resolutions': {
                'can-stache-key': '1.0.0-pre.8',
                'can-event-queue': '0.2.2',
                'can-simple-observable': '2.0.0-pre.16',
                'can-reflect': '1.7.1',
                'can-observation': '4.0.0-pre.17',
                'steal-qunit': '1.0.1',
                'can-util': '3.10.12',
                'can-simple-map': '4.0.0-pre.7',
                'can-symbol': '1.4.1',
                'can-reflect-promise': '2.0.0-pre.4'
            }
        },
        {
            'name': 'can-symbol',
            'version': '1.4.1',
            'fileUrl': './node_modules/can-symbol/package.json',
            'main': 'can-symbol',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-symbol'
            },
            'resolutions': {
                'can-symbol': '1.4.1',
                'steal-qunit': '1.0.1',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-view-live',
            'version': '4.0.0-pre.11',
            'fileUrl': './node_modules/can-view-live/package.json',
            'main': 'can-view-live',
            'steal': {
                'npmIgnore': {
                    'documentjs': true,
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-view-live'
            },
            'resolutions': {
                'can-view-live': '4.0.0-pre.11',
                'can-define': '2.0.0-pre.11',
                'can-observation': '4.0.0-pre.17',
                'can-simple-observable': '2.0.0-pre.16',
                'can-view-nodelist': '3.1.0',
                'can-util': '3.10.12',
                'can-reflect': '1.7.1',
                'can-simple-map': '4.0.0-pre.7',
                'can-queues': '0.2.6',
                'can-symbol': '1.4.1',
                'can-test-helpers': '1.1.0',
                'steal-qunit': '1.0.1',
                'can-key-tree': '0.1.0',
                'can-view-parser': '3.6.2',
                'can-view-callbacks': '4.0.0-pre.2'
            }
        },
        {
            'name': 'can-view-model',
            'version': '4.0.0-pre.3',
            'fileUrl': './node_modules/can-view-model/package.json',
            'main': 'can-view-model',
            'resolutions': {
                'can-view-model': '4.0.0-pre.3',
                'can-simple-map': '4.0.0-pre.7',
                'steal-qunit': '1.0.1',
                'can-util': '3.10.12',
                'can-namespace': '1.0.0',
                'can-reflect': '1.7.1'
            }
        },
        {
            'name': 'can-view-nodelist',
            'version': '3.1.0',
            'fileUrl': './node_modules/can-view-nodelist/package.json',
            'main': 'can-view-nodelist',
            'resolutions': {
                'can-view-nodelist': '3.1.0',
                'can-util': '3.10.12',
                'steal-qunit': '1.0.1',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-view-parser',
            'version': '3.6.2',
            'fileUrl': './node_modules/can-view-parser/package.json',
            'main': 'can-view-parser',
            'resolutions': {
                'can-view-parser': '3.6.2',
                'can-log': '0.1.0',
                'can-attribute-encoder': '0.3.1',
                'can-test-helpers': '1.1.0',
                'steal-qunit': '1.0.1',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-view-scope',
            'version': '4.0.0-pre.22',
            'fileUrl': './node_modules/can-view-scope/package.json',
            'main': 'can-view-scope',
            'resolutions': {
                'can-view-scope': '4.0.0-pre.22',
                'can-stache-key': '1.0.0-pre.8',
                'can-symbol': '1.4.1',
                'can-reflect': '1.7.1',
                'can-simple-observable': '2.0.0-pre.16',
                'can-observation': '4.0.0-pre.17',
                'can-simple-map': '4.0.0-pre.7',
                'steal-qunit': '1.0.1',
                'can-test-helpers': '1.1.0',
                'can-observation-recorder': '0.1.0',
                'can-util': '3.10.12',
                'can-namespace': '1.0.0',
                'can-key-tree': '0.1.0',
                'can-queues': '0.2.6',
                'can-cid': '1.1.1'
            }
        },
        {
            'name': 'can-view-target',
            'version': '3.1.4',
            'fileUrl': './node_modules/can-view-target/package.json',
            'main': 'can-view-target',
            'resolutions': {
                'can-view-target': '3.1.4',
                'can-simple-dom': '1.3.0',
                'can-globals': '0.2.3',
                'steal-qunit': '1.0.1',
                'can-util': '3.10.12',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-deparam',
            'version': '1.0.1',
            'fileUrl': './node_modules/can-deparam/package.json',
            'main': 'dist/cjs/can-deparam',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-deparam'
            },
            'resolutions': {
                'can-deparam': '1.0.1',
                'steal-qunit': '1.0.1',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-simple-dom',
            'version': '1.3.0',
            'fileUrl': './node_modules/can-simple-dom/package.json',
            'main': 'dist/cjs/simple-dom.js',
            'steal': {
                'directories': { 'lib': 'lib' },
                'npmIgnore': { 'testee': true },
                'main': 'simple-dom.js'
            },
            'resolutions': {
                'can-simple-dom': '1.3.0',
                'steal-qunit': '1.0.1',
                'he': '1.1.1',
                'simple-html-tokenizer': '0.2.6',
                'micro-location': '0.1.5'
            }
        },
        {
            'name': 'can-ndjson-stream',
            'version': '0.1.6',
            'fileUrl': './node_modules/can-ndjson-stream/package.json',
            'main': 'can-ndjson-stream',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-ndjson-stream'
            },
            'resolutions': {
                'can-ndjson-stream': '0.1.6',
                'steal-qunit': '1.0.1',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-util',
            'version': '3.10.12',
            'fileUrl': './node_modules/can-util/package.json',
            'main': 'can-util',
            'resolutions': {
                'can-globals': '0.2.3',
                'can-util': '3.10.12',
                'can-log': '0.1.0',
                'can-symbol': '1.4.1',
                'can-assign': '1.0.0',
                'can-cid': '1.1.1',
                'can-dom-data-state': '0.1.1',
                'can-types': '1.1.3',
                'can-namespace': '1.0.0',
                'can-parse-uri': '1.0.0',
                'can-ajax': '1.0.9',
                'can-reflect': '1.7.1'
            }
        },
        {
            'name': 'can-observation',
            'version': '4.0.0-pre.17',
            'fileUrl': './node_modules/can-observation/package.json',
            'main': 'can-observation',
            'steal': { 'npmAlgorithm': 'flat' },
            'resolutions': {
                'can-util': '3.10.12',
                'can-namespace': '1.0.0',
                'can-reflect': '1.7.1',
                'can-queues': '0.2.6',
                'can-key-tree': '0.1.0',
                'can-observation-recorder': '0.1.0',
                'can-observation': '4.0.0-pre.17',
                'can-symbol': '1.4.1',
                'can-log': '0.1.0'
            }
        },
        {
            'name': 'steal-qunit',
            'version': '1.0.1',
            'fileUrl': './node_modules/steal-qunit/package.json',
            'main': 'steal-qunit',
            'steal': {
                'plugins': ['steal-css'],
                'meta': {
                    'qunitjs@1.23.1#qunit/qunit': {
                        'format': 'global',
                        'exports': 'QUnit',
                        'deps': ['steal-qunit/add-dom']
                    }
                }
            },
            'resolutions': {
                'qunitjs': '1.23.1',
                'steal-css': '1.3.1'
            },
            'system': {
                'plugins': ['steal-css'],
                'meta': {
                    'qunitjs@1.23.1#qunit/qunit': {
                        'format': 'global',
                        'exports': 'QUnit',
                        'deps': ['steal-qunit/add-dom']
                    }
                }
            }
        },
        {
            'name': 'can-namespace',
            'version': '1.0.0',
            'fileUrl': './node_modules/can-namespace/package.json',
            'main': 'can-namespace',
            'steal': { 'npmAlgorithm': 'flat' },
            'resolutions': {}
        },
        {
            'name': 'can-parse-uri',
            'version': '1.0.0',
            'fileUrl': './node_modules/can-parse-uri/package.json',
            'main': 'dist/cjs/can-parse-uri',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-parse-uri'
            },
            'resolutions': {}
        },
        {
            'name': 'can-simple-map',
            'version': '4.0.0-pre.7',
            'fileUrl': './node_modules/can-simple-map/package.json',
            'main': 'can-simple-map',
            'steal': {
                'npmIgnore': {
                    'documentjs': true,
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-simple-map'
            },
            'resolutions': {
                'can-construct': '3.2.2',
                'can-event-queue': '0.2.2',
                'can-queues': '0.2.6',
                'can-util': '3.10.12',
                'can-observation-recorder': '0.1.0',
                'can-reflect': '1.7.1',
                'can-log': '0.1.0',
                'can-symbol': '1.4.1'
            }
        },
        {
            'name': 'can-make-map',
            'version': '1.0.0',
            'fileUrl': './node_modules/can-make-map/package.json',
            'main': 'dist/cjs/can-make-map',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-make-map'
            },
            'resolutions': {}
        },
        {
            'name': 'can-observation-recorder',
            'version': '0.1.0',
            'fileUrl': './node_modules/can-observation-recorder/package.json',
            'main': './can-observation-recorder.js',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                }
            },
            'resolutions': { 'can-namespace': '1.0.0' }
        },
        {
            'name': 'can-log',
            'version': '0.1.0',
            'fileUrl': './node_modules/can-log/package.json',
            'main': 'dist/cjs/can-log',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-log'
            },
            'resolutions': { 'can-log': '0.1.0' }
        },
        {
            'name': 'can-attribute-encoder',
            'version': '0.3.1',
            'fileUrl': './node_modules/can-attribute-encoder/package.json',
            'main': 'can-attribute-encoder',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'steal-tools': true
                },
                'main': 'can-attribute-encoder'
            },
            'resolutions': {
                'can-namespace': '1.0.0',
                'can-log': '0.1.0'
            }
        },
        {
            'name': 'can-test-helpers',
            'version': '1.1.0',
            'fileUrl': './node_modules/can-test-helpers/package.json',
            'main': 'can-test-helpers.js',
            'resolutions': {
                'can-test-helpers': '1.1.0',
                'can-log': '0.1.0',
                'can-util': '3.10.12'
            }
        },
        {
            'name': 'can-stache',
            'version': '4.0.0-pre.7',
            'fileUrl': './node_modules/can-stache/package.json',
            'main': 'can-stache',
            'resolutions': {
                'can-view-parser': '3.6.2',
                'can-view-callbacks': '4.0.0-pre.2',
                'can-stache': '4.0.0-pre.7',
                'can-attribute-encoder': '0.3.1',
                'can-util': '3.10.12',
                'can-namespace': '1.0.0',
                'can-view-target': '3.1.4',
                'can-view-nodelist': '3.1.0',
                'can-view-scope': '4.0.0-pre.22',
                'can-observation': '4.0.0-pre.17',
                'can-view-live': '4.0.0-pre.11',
                'can-reflect': '1.7.1',
                'can-symbol': '1.4.1',
                'can-stache-key': '1.0.0-pre.8',
                'can-simple-observable': '2.0.0-pre.16'
            }
        },
        {
            'name': 'can-view-callbacks',
            'version': '4.0.0-pre.2',
            'fileUrl': './node_modules/can-view-callbacks/package.json',
            'main': 'can-view-callbacks',
            'steal': {},
            'resolutions': {
                'can-observation-recorder': '0.1.0',
                'can-util': '3.10.12',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'steal-css',
            'version': '1.3.1',
            'fileUrl': './node_modules/steal-css/package.json',
            'main': 'css.js',
            'steal': {
                'ext': { 'css': 'steal-css' },
                'map': { '$css': 'steal-css@1.3.1#css' }
            },
            'resolutions': {}
        },
        {
            'name': 'qunitjs',
            'version': '2.4.1',
            'fileUrl': './node_modules/qunitjs/package.json',
            'main': 'qunit/qunit.js',
            'resolutions': {}
        },
        {
            'name': 'can-assign',
            'version': '1.0.0',
            'fileUrl': './node_modules/can-assign/package.json',
            'main': 'dist/cjs/can-assign',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-assign'
            },
            'resolutions': {}
        },
        {
            'name': 'he',
            'version': '1.1.1',
            'fileUrl': './node_modules/he/package.json',
            'main': 'he.js',
            'resolutions': {}
        },
        {
            'name': 'qunitjs',
            'version': '1.23.1',
            'fileUrl': './node_modules/steal-qunit/node_modules/qunitjs/package.json',
            'main': 'qunit/qunit.js',
            'resolutions': { 'steal-qunit': '1.0.1' }
        },
        {
            'name': 'simple-html-tokenizer',
            'version': '0.2.6',
            'fileUrl': './node_modules/simple-html-tokenizer/package.json',
            'main': 'dist/simple-html-tokenizer.js',
            'resolutions': { 'simple-html-tokenizer': '0.2.6' }
        },
        {
            'name': 'can-cid',
            'version': '1.1.1',
            'fileUrl': './node_modules/can-cid/package.json',
            'main': 'can-cid',
            'resolutions': {
                'can-namespace': '1.0.0',
                'can-cid': '1.1.1'
            }
        },
        {
            'name': 'can-dom-data-state',
            'version': '0.1.1',
            'fileUrl': './node_modules/can-dom-data-state/package.json',
            'main': 'dist/cjs/can-dom-data-state',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-dom-data-state'
            },
            'resolutions': {
                'can-namespace': '1.0.0',
                'can-cid': '1.1.1'
            }
        },
        {
            'name': 'can-types',
            'version': '1.1.3',
            'fileUrl': './node_modules/can-types/package.json',
            'main': 'can-types',
            'resolutions': {
                'can-namespace': '1.0.0',
                'can-reflect': '1.7.1',
                'can-symbol': '1.4.1',
                'can-log': '0.1.0'
            }
        },
        {
            'name': 'can-event-dom-enter',
            'version': '1.0.2',
            'fileUrl': './node_modules/can-event-dom-enter/package.json',
            'main': 'can-event-dom-enter',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'steal-tools': true
                },
                'main': 'can-event-dom-enter'
            },
            'resolutions': {
                'can-event-dom-enter': '1.0.2',
                'can-dom-events': '1.0.4'
            }
        },
        {
            'name': 'can-event-dom-radiochange',
            'version': '1.0.2',
            'fileUrl': './node_modules/can-event-dom-radiochange/package.json',
            'main': 'can-event-dom-radiochange',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'steal-tools': true
                },
                'main': 'can-event-dom-radiochange'
            },
            'resolutions': { 'can-event-dom-radiochange': '1.0.2' }
        },
        {
            'name': 'can-vdom',
            'version': '3.2.3',
            'fileUrl': './node_modules/can-vdom/package.json',
            'main': 'can-vdom.js',
            'steal': {
                'map': { 'can-vdom@3.2.3#assert': 'chai/chai' },
                'meta': {
                    'chai/chai': {
                        'format': 'global',
                        'exports': 'chai.assert'
                    }
                },
                'plugins': ['chai'],
                'main': 'can-vdom'
            },
            'resolutions': {
                'can-simple-dom': '1.3.0',
                'can-vdom': '3.2.3'
            }
        },
        {
            'name': 'micro-location',
            'version': '0.1.5',
            'fileUrl': './node_modules/micro-location/package.json',
            'main': 'lib/micro-location.js',
            'resolutions': {}
        },
        {
            'name': 'can-dom-events',
            'version': '1.0.4',
            'fileUrl': './node_modules/can-dom-events/package.json',
            'main': 'can-dom-events',
            'resolutions': {}
        }
    ], { 'npmParentMap': {} }));
});
/*steal-qunit@1.0.1#add-dom*/
define('steal-qunit@1.0.1#add-dom', function (require, exports, module) {
    'format cjs';
    if (!document.getElementById('qunit')) {
        var qunit = document.createElement('div');
        qunit.id = 'qunit';
        (document.body || document.documentElement).appendChild(qunit);
    }
});
/*qunitjs@1.23.1#qunit/qunit*/
define('qunitjs@1.23.1#qunit/qunit', [
    'module',
    '@loader',
    'require',
    'steal-qunit/add-dom'
], function (module, loader, require) {
    loader.get('@@global-helpers').prepareGlobal({
        require: require,
        name: module.id,
        deps: ['steal-qunit/add-dom'],
        exports: 'QUnit'
    });
    var define = loader.global.define;
    var require = loader.global.require;
    var source = '/*!\n * QUnit 1.23.1\n * https://qunitjs.com/\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2016-04-12T17:29Z\n */\n\n( function( global ) {\n\nvar QUnit = {};\n\nvar Date = global.Date;\nvar now = Date.now || function() {\n\treturn new Date().getTime();\n};\n\nvar setTimeout = global.setTimeout;\nvar clearTimeout = global.clearTimeout;\n\n// Store a local window from the global to allow direct references.\nvar window = global.window;\n\nvar defined = {\n\tdocument: window && window.document !== undefined,\n\tsetTimeout: setTimeout !== undefined,\n\tsessionStorage: ( function() {\n\t\tvar x = "qunit-test-string";\n\t\ttry {\n\t\t\tsessionStorage.setItem( x, x );\n\t\t\tsessionStorage.removeItem( x );\n\t\t\treturn true;\n\t\t} catch ( e ) {\n\t\t\treturn false;\n\t\t}\n\t}() )\n};\n\nvar fileName = ( sourceFromStacktrace( 0 ) || "" ).replace( /(:\\d+)+\\)?/, "" ).replace( /.+\\//, "" );\nvar globalStartCalled = false;\nvar runStarted = false;\n\nvar toString = Object.prototype.toString,\n\thasOwn = Object.prototype.hasOwnProperty;\n\n// Returns a new Array with the elements that are in a but not in b\nfunction diff( a, b ) {\n\tvar i, j,\n\t\tresult = a.slice();\n\n\tfor ( i = 0; i < result.length; i++ ) {\n\t\tfor ( j = 0; j < b.length; j++ ) {\n\t\t\tif ( result[ i ] === b[ j ] ) {\n\t\t\t\tresult.splice( i, 1 );\n\t\t\t\ti--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\n// From jquery.js\nfunction inArray( elem, array ) {\n\tif ( array.indexOf ) {\n\t\treturn array.indexOf( elem );\n\t}\n\n\tfor ( var i = 0, length = array.length; i < length; i++ ) {\n\t\tif ( array[ i ] === elem ) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n/**\n * Makes a clone of an object using only Array or Object as base,\n * and copies over the own enumerable properties.\n *\n * @param {Object} obj\n * @return {Object} New object with only the own properties (recursively).\n */\nfunction objectValues ( obj ) {\n\tvar key, val,\n\t\tvals = QUnit.is( "array", obj ) ? [] : {};\n\tfor ( key in obj ) {\n\t\tif ( hasOwn.call( obj, key ) ) {\n\t\t\tval = obj[ key ];\n\t\t\tvals[ key ] = val === Object( val ) ? objectValues( val ) : val;\n\t\t}\n\t}\n\treturn vals;\n}\n\nfunction extend( a, b, undefOnly ) {\n\tfor ( var prop in b ) {\n\t\tif ( hasOwn.call( b, prop ) ) {\n\n\t\t\t// Avoid "Member not found" error in IE8 caused by messing with window.constructor\n\t\t\t// This block runs on every environment, so `global` is being used instead of `window`\n\t\t\t// to avoid errors on node.\n\t\t\tif ( prop !== "constructor" || a !== global ) {\n\t\t\t\tif ( b[ prop ] === undefined ) {\n\t\t\t\t\tdelete a[ prop ];\n\t\t\t\t} else if ( !( undefOnly && typeof a[ prop ] !== "undefined" ) ) {\n\t\t\t\t\ta[ prop ] = b[ prop ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a;\n}\n\nfunction objectType( obj ) {\n\tif ( typeof obj === "undefined" ) {\n\t\treturn "undefined";\n\t}\n\n\t// Consider: typeof null === object\n\tif ( obj === null ) {\n\t\treturn "null";\n\t}\n\n\tvar match = toString.call( obj ).match( /^\\[object\\s(.*)\\]$/ ),\n\t\ttype = match && match[ 1 ];\n\n\tswitch ( type ) {\n\t\tcase "Number":\n\t\t\tif ( isNaN( obj ) ) {\n\t\t\t\treturn "nan";\n\t\t\t}\n\t\t\treturn "number";\n\t\tcase "String":\n\t\tcase "Boolean":\n\t\tcase "Array":\n\t\tcase "Set":\n\t\tcase "Map":\n\t\tcase "Date":\n\t\tcase "RegExp":\n\t\tcase "Function":\n\t\tcase "Symbol":\n\t\t\treturn type.toLowerCase();\n\t}\n\tif ( typeof obj === "object" ) {\n\t\treturn "object";\n\t}\n}\n\n// Safe object type checking\nfunction is( type, obj ) {\n\treturn QUnit.objectType( obj ) === type;\n}\n\n// Doesn\'t support IE6 to IE9, it will return undefined on these browsers\n// See also https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error/Stack\nfunction extractStacktrace( e, offset ) {\n\toffset = offset === undefined ? 4 : offset;\n\n\tvar stack, include, i;\n\n\tif ( e.stack ) {\n\t\tstack = e.stack.split( "\\n" );\n\t\tif ( /^error$/i.test( stack[ 0 ] ) ) {\n\t\t\tstack.shift();\n\t\t}\n\t\tif ( fileName ) {\n\t\t\tinclude = [];\n\t\t\tfor ( i = offset; i < stack.length; i++ ) {\n\t\t\t\tif ( stack[ i ].indexOf( fileName ) !== -1 ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tinclude.push( stack[ i ] );\n\t\t\t}\n\t\t\tif ( include.length ) {\n\t\t\t\treturn include.join( "\\n" );\n\t\t\t}\n\t\t}\n\t\treturn stack[ offset ];\n\n\t// Support: Safari <=6 only\n\t} else if ( e.sourceURL ) {\n\n\t\t// Exclude useless self-reference for generated Error objects\n\t\tif ( /qunit.js$/.test( e.sourceURL ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// For actual exceptions, this is useful\n\t\treturn e.sourceURL + ":" + e.line;\n\t}\n}\n\nfunction sourceFromStacktrace( offset ) {\n\tvar error = new Error();\n\n\t// Support: Safari <=7 only, IE <=10 - 11 only\n\t// Not all browsers generate the `stack` property for `new Error()`, see also #636\n\tif ( !error.stack ) {\n\t\ttry {\n\t\t\tthrow error;\n\t\t} catch ( err ) {\n\t\t\terror = err;\n\t\t}\n\t}\n\n\treturn extractStacktrace( error, offset );\n}\n\n/**\n * Config object: Maintain internal state\n * Later exposed as QUnit.config\n * `config` initialized at top of scope\n */\nvar config = {\n\n\t// The queue of tests to run\n\tqueue: [],\n\n\t// Block until document ready\n\tblocking: true,\n\n\t// By default, run previously failed tests first\n\t// very useful in combination with "Hide passed tests" checked\n\treorder: true,\n\n\t// By default, modify document.title when suite is done\n\taltertitle: true,\n\n\t// HTML Reporter: collapse every test except the first failing test\n\t// If false, all failing tests will be expanded\n\tcollapse: true,\n\n\t// By default, scroll to top of the page when suite is done\n\tscrolltop: true,\n\n\t// Depth up-to which object will be dumped\n\tmaxDepth: 5,\n\n\t// When enabled, all tests must call expect()\n\trequireExpects: false,\n\n\t// Placeholder for user-configurable form-exposed URL parameters\n\turlConfig: [],\n\n\t// Set of all modules.\n\tmodules: [],\n\n\t// Stack of nested modules\n\tmoduleStack: [],\n\n\t// The first unnamed module\n\tcurrentModule: {\n\t\tname: "",\n\t\ttests: []\n\t},\n\n\tcallbacks: {}\n};\n\n// Push a loose unnamed module to the modules collection\nconfig.modules.push( config.currentModule );\n\nvar loggingCallbacks = {};\n\n// Register logging callbacks\nfunction registerLoggingCallbacks( obj ) {\n\tvar i, l, key,\n\t\tcallbackNames = [ "begin", "done", "log", "testStart", "testDone",\n\t\t\t"moduleStart", "moduleDone" ];\n\n\tfunction registerLoggingCallback( key ) {\n\t\tvar loggingCallback = function( callback ) {\n\t\t\tif ( objectType( callback ) !== "function" ) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t"QUnit logging methods require a callback function as their first parameters."\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconfig.callbacks[ key ].push( callback );\n\t\t};\n\n\t\t// DEPRECATED: This will be removed on QUnit 2.0.0+\n\t\t// Stores the registered functions allowing restoring\n\t\t// at verifyLoggingCallbacks() if modified\n\t\tloggingCallbacks[ key ] = loggingCallback;\n\n\t\treturn loggingCallback;\n\t}\n\n\tfor ( i = 0, l = callbackNames.length; i < l; i++ ) {\n\t\tkey = callbackNames[ i ];\n\n\t\t// Initialize key collection of logging callback\n\t\tif ( objectType( config.callbacks[ key ] ) === "undefined" ) {\n\t\t\tconfig.callbacks[ key ] = [];\n\t\t}\n\n\t\tobj[ key ] = registerLoggingCallback( key );\n\t}\n}\n\nfunction runLoggingCallbacks( key, args ) {\n\tvar i, l, callbacks;\n\n\tcallbacks = config.callbacks[ key ];\n\tfor ( i = 0, l = callbacks.length; i < l; i++ ) {\n\t\tcallbacks[ i ]( args );\n\t}\n}\n\n// DEPRECATED: This will be removed on 2.0.0+\n// This function verifies if the loggingCallbacks were modified by the user\n// If so, it will restore it, assign the given callback and print a console warning\nfunction verifyLoggingCallbacks() {\n\tvar loggingCallback, userCallback;\n\n\tfor ( loggingCallback in loggingCallbacks ) {\n\t\tif ( QUnit[ loggingCallback ] !== loggingCallbacks[ loggingCallback ] ) {\n\n\t\t\tuserCallback = QUnit[ loggingCallback ];\n\n\t\t\t// Restore the callback function\n\t\t\tQUnit[ loggingCallback ] = loggingCallbacks[ loggingCallback ];\n\n\t\t\t// Assign the deprecated given callback\n\t\t\tQUnit[ loggingCallback ]( userCallback );\n\n\t\t\tif ( global.console && global.console.warn ) {\n\t\t\t\tglobal.console.warn(\n\t\t\t\t\t"QUnit." + loggingCallback + " was replaced with a new value.\\n" +\n\t\t\t\t\t"Please, check out the documentation on how to apply logging callbacks.\\n" +\n\t\t\t\t\t"Reference: https://api.qunitjs.com/category/callbacks/"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n}\n\n( function() {\n\tif ( !defined.document ) {\n\t\treturn;\n\t}\n\n\t// `onErrorFnPrev` initialized at top of scope\n\t// Preserve other handlers\n\tvar onErrorFnPrev = window.onerror;\n\n\t// Cover uncaught exceptions\n\t// Returning true will suppress the default browser handler,\n\t// returning false will let it run.\n\twindow.onerror = function( error, filePath, linerNr ) {\n\t\tvar ret = false;\n\t\tif ( onErrorFnPrev ) {\n\t\t\tret = onErrorFnPrev( error, filePath, linerNr );\n\t\t}\n\n\t\t// Treat return value as window.onerror itself does,\n\t\t// Only do our handling if not suppressed.\n\t\tif ( ret !== true ) {\n\t\t\tif ( QUnit.config.current ) {\n\t\t\t\tif ( QUnit.config.current.ignoreGlobalErrors ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tQUnit.pushFailure( error, filePath + ":" + linerNr );\n\t\t\t} else {\n\t\t\t\tQUnit.test( "global failure", extend( function() {\n\t\t\t\t\tQUnit.pushFailure( error, filePath + ":" + linerNr );\n\t\t\t\t}, { validTest: true } ) );\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\treturn ret;\n\t};\n}() );\n\n// Figure out if we\'re running the tests from a server or not\nQUnit.isLocal = !( defined.document && window.location.protocol !== "file:" );\n\n// Expose the current QUnit version\nQUnit.version = "1.23.1";\n\nextend( QUnit, {\n\n\t// Call on start of module test to prepend name to all tests\n\tmodule: function( name, testEnvironment, executeNow ) {\n\t\tvar module, moduleFns;\n\t\tvar currentModule = config.currentModule;\n\n\t\tif ( arguments.length === 2 ) {\n\t\t\tif ( objectType( testEnvironment ) === "function" ) {\n\t\t\t\texecuteNow = testEnvironment;\n\t\t\t\ttestEnvironment = undefined;\n\t\t\t}\n\t\t}\n\n\t\t// DEPRECATED: handles setup/teardown functions,\n\t\t// beforeEach and afterEach should be used instead\n\t\tif ( testEnvironment && testEnvironment.setup ) {\n\t\t\ttestEnvironment.beforeEach = testEnvironment.setup;\n\t\t\tdelete testEnvironment.setup;\n\t\t}\n\t\tif ( testEnvironment && testEnvironment.teardown ) {\n\t\t\ttestEnvironment.afterEach = testEnvironment.teardown;\n\t\t\tdelete testEnvironment.teardown;\n\t\t}\n\n\t\tmodule = createModule();\n\n\t\tmoduleFns = {\n\t\t\tbeforeEach: setHook( module, "beforeEach" ),\n\t\t\tafterEach: setHook( module, "afterEach" )\n\t\t};\n\n\t\tif ( objectType( executeNow ) === "function" ) {\n\t\t\tconfig.moduleStack.push( module );\n\t\t\tsetCurrentModule( module );\n\t\t\texecuteNow.call( module.testEnvironment, moduleFns );\n\t\t\tconfig.moduleStack.pop();\n\t\t\tmodule = module.parentModule || currentModule;\n\t\t}\n\n\t\tsetCurrentModule( module );\n\n\t\tfunction createModule() {\n\t\t\tvar parentModule = config.moduleStack.length ?\n\t\t\t\tconfig.moduleStack.slice( -1 )[ 0 ] : null;\n\t\t\tvar moduleName = parentModule !== null ?\n\t\t\t\t[ parentModule.name, name ].join( " > " ) : name;\n\t\t\tvar module = {\n\t\t\t\tname: moduleName,\n\t\t\t\tparentModule: parentModule,\n\t\t\t\ttests: [],\n\t\t\t\tmoduleId: generateHash( moduleName )\n\t\t\t};\n\n\t\t\tvar env = {};\n\t\t\tif ( parentModule ) {\n\t\t\t\textend( env, parentModule.testEnvironment );\n\t\t\t\tdelete env.beforeEach;\n\t\t\t\tdelete env.afterEach;\n\t\t\t}\n\t\t\textend( env, testEnvironment );\n\t\t\tmodule.testEnvironment = env;\n\n\t\t\tconfig.modules.push( module );\n\t\t\treturn module;\n\t\t}\n\n\t\tfunction setCurrentModule( module ) {\n\t\t\tconfig.currentModule = module;\n\t\t}\n\n\t},\n\n\t// DEPRECATED: QUnit.asyncTest() will be removed in QUnit 2.0.\n\tasyncTest: asyncTest,\n\n\ttest: test,\n\n\tskip: skip,\n\n\tonly: only,\n\n\t// DEPRECATED: The functionality of QUnit.start() will be altered in QUnit 2.0.\n\t// In QUnit 2.0, invoking it will ONLY affect the `QUnit.config.autostart` blocking behavior.\n\tstart: function( count ) {\n\t\tvar globalStartAlreadyCalled = globalStartCalled;\n\n\t\tif ( !config.current ) {\n\t\t\tglobalStartCalled = true;\n\n\t\t\tif ( runStarted ) {\n\t\t\t\tthrow new Error( "Called start() outside of a test context while already started" );\n\t\t\t} else if ( globalStartAlreadyCalled || count > 1 ) {\n\t\t\t\tthrow new Error( "Called start() outside of a test context too many times" );\n\t\t\t} else if ( config.autostart ) {\n\t\t\t\tthrow new Error( "Called start() outside of a test context when " +\n\t\t\t\t\t"QUnit.config.autostart was true" );\n\t\t\t} else if ( !config.pageLoaded ) {\n\n\t\t\t\t// The page isn\'t completely loaded yet, so bail out and let `QUnit.load` handle it\n\t\t\t\tconfig.autostart = true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\n\t\t\t// If a test is running, adjust its semaphore\n\t\t\tconfig.current.semaphore -= count || 1;\n\n\t\t\t// If semaphore is non-numeric, throw error\n\t\t\tif ( isNaN( config.current.semaphore ) ) {\n\t\t\t\tconfig.current.semaphore = 0;\n\n\t\t\t\tQUnit.pushFailure(\n\t\t\t\t\t"Called start() with a non-numeric decrement.",\n\t\t\t\t\tsourceFromStacktrace( 2 )\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Don\'t start until equal number of stop-calls\n\t\t\tif ( config.current.semaphore > 0 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Throw an Error if start is called more often than stop\n\t\t\tif ( config.current.semaphore < 0 ) {\n\t\t\t\tconfig.current.semaphore = 0;\n\n\t\t\t\tQUnit.pushFailure(\n\t\t\t\t\t"Called start() while already started (test\'s semaphore was 0 already)",\n\t\t\t\t\tsourceFromStacktrace( 2 )\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tresumeProcessing();\n\t},\n\n\t// DEPRECATED: QUnit.stop() will be removed in QUnit 2.0.\n\tstop: function( count ) {\n\n\t\t// If there isn\'t a test running, don\'t allow QUnit.stop() to be called\n\t\tif ( !config.current ) {\n\t\t\tthrow new Error( "Called stop() outside of a test context" );\n\t\t}\n\n\t\t// If a test is running, adjust its semaphore\n\t\tconfig.current.semaphore += count || 1;\n\n\t\tpauseProcessing();\n\t},\n\n\tconfig: config,\n\n\tis: is,\n\n\tobjectType: objectType,\n\n\textend: extend,\n\n\tload: function() {\n\t\tconfig.pageLoaded = true;\n\n\t\t// Initialize the configuration options\n\t\textend( config, {\n\t\t\tstats: { all: 0, bad: 0 },\n\t\t\tmoduleStats: { all: 0, bad: 0 },\n\t\t\tstarted: 0,\n\t\t\tupdateRate: 1000,\n\t\t\tautostart: true,\n\t\t\tfilter: ""\n\t\t}, true );\n\n\t\tconfig.blocking = false;\n\n\t\tif ( config.autostart ) {\n\t\t\tresumeProcessing();\n\t\t}\n\t},\n\n\tstack: function( offset ) {\n\t\toffset = ( offset || 0 ) + 2;\n\t\treturn sourceFromStacktrace( offset );\n\t}\n} );\n\nregisterLoggingCallbacks( QUnit );\n\nfunction begin() {\n\tvar i, l,\n\t\tmodulesLog = [];\n\n\t// If the test run hasn\'t officially begun yet\n\tif ( !config.started ) {\n\n\t\t// Record the time of the test run\'s beginning\n\t\tconfig.started = now();\n\n\t\tverifyLoggingCallbacks();\n\n\t\t// Delete the loose unnamed module if unused.\n\t\tif ( config.modules[ 0 ].name === "" && config.modules[ 0 ].tests.length === 0 ) {\n\t\t\tconfig.modules.shift();\n\t\t}\n\n\t\t// Avoid unnecessary information by not logging modules\' test environments\n\t\tfor ( i = 0, l = config.modules.length; i < l; i++ ) {\n\t\t\tmodulesLog.push( {\n\t\t\t\tname: config.modules[ i ].name,\n\t\t\t\ttests: config.modules[ i ].tests\n\t\t\t} );\n\t\t}\n\n\t\t// The test run is officially beginning now\n\t\trunLoggingCallbacks( "begin", {\n\t\t\ttotalTests: Test.count,\n\t\t\tmodules: modulesLog\n\t\t} );\n\t}\n\n\tconfig.blocking = false;\n\tprocess( true );\n}\n\nfunction process( last ) {\n\tfunction next() {\n\t\tprocess( last );\n\t}\n\tvar start = now();\n\tconfig.depth = ( config.depth || 0 ) + 1;\n\n\twhile ( config.queue.length && !config.blocking ) {\n\t\tif ( !defined.setTimeout || config.updateRate <= 0 ||\n\t\t\t\t( ( now() - start ) < config.updateRate ) ) {\n\t\t\tif ( config.current ) {\n\n\t\t\t\t// Reset async tracking for each phase of the Test lifecycle\n\t\t\t\tconfig.current.usedAsync = false;\n\t\t\t}\n\t\t\tconfig.queue.shift()();\n\t\t} else {\n\t\t\tsetTimeout( next, 13 );\n\t\t\tbreak;\n\t\t}\n\t}\n\tconfig.depth--;\n\tif ( last && !config.blocking && !config.queue.length && config.depth === 0 ) {\n\t\tdone();\n\t}\n}\n\nfunction pauseProcessing() {\n\tconfig.blocking = true;\n\n\tif ( config.testTimeout && defined.setTimeout ) {\n\t\tclearTimeout( config.timeout );\n\t\tconfig.timeout = setTimeout( function() {\n\t\t\tif ( config.current ) {\n\t\t\t\tconfig.current.semaphore = 0;\n\t\t\t\tQUnit.pushFailure( "Test timed out", sourceFromStacktrace( 2 ) );\n\t\t\t} else {\n\t\t\t\tthrow new Error( "Test timed out" );\n\t\t\t}\n\t\t\tresumeProcessing();\n\t\t}, config.testTimeout );\n\t}\n}\n\nfunction resumeProcessing() {\n\trunStarted = true;\n\n\t// A slight delay to allow this iteration of the event loop to finish (more assertions, etc.)\n\tif ( defined.setTimeout ) {\n\t\tsetTimeout( function() {\n\t\t\tif ( config.current && config.current.semaphore > 0 ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( config.timeout ) {\n\t\t\t\tclearTimeout( config.timeout );\n\t\t\t}\n\n\t\t\tbegin();\n\t\t}, 13 );\n\t} else {\n\t\tbegin();\n\t}\n}\n\nfunction done() {\n\tvar runtime, passed;\n\n\tconfig.autorun = true;\n\n\t// Log the last module results\n\tif ( config.previousModule ) {\n\t\trunLoggingCallbacks( "moduleDone", {\n\t\t\tname: config.previousModule.name,\n\t\t\ttests: config.previousModule.tests,\n\t\t\tfailed: config.moduleStats.bad,\n\t\t\tpassed: config.moduleStats.all - config.moduleStats.bad,\n\t\t\ttotal: config.moduleStats.all,\n\t\t\truntime: now() - config.moduleStats.started\n\t\t} );\n\t}\n\tdelete config.previousModule;\n\n\truntime = now() - config.started;\n\tpassed = config.stats.all - config.stats.bad;\n\n\trunLoggingCallbacks( "done", {\n\t\tfailed: config.stats.bad,\n\t\tpassed: passed,\n\t\ttotal: config.stats.all,\n\t\truntime: runtime\n\t} );\n}\n\nfunction setHook( module, hookName ) {\n\tif ( module.testEnvironment === undefined ) {\n\t\tmodule.testEnvironment = {};\n\t}\n\n\treturn function( callback ) {\n\t\tmodule.testEnvironment[ hookName ] = callback;\n\t};\n}\n\nvar focused = false;\nvar priorityCount = 0;\nvar unitSampler;\n\nfunction Test( settings ) {\n\tvar i, l;\n\n\t++Test.count;\n\n\textend( this, settings );\n\tthis.assertions = [];\n\tthis.semaphore = 0;\n\tthis.usedAsync = false;\n\tthis.module = config.currentModule;\n\tthis.stack = sourceFromStacktrace( 3 );\n\n\t// Register unique strings\n\tfor ( i = 0, l = this.module.tests; i < l.length; i++ ) {\n\t\tif ( this.module.tests[ i ].name === this.testName ) {\n\t\t\tthis.testName += " ";\n\t\t}\n\t}\n\n\tthis.testId = generateHash( this.module.name, this.testName );\n\n\tthis.module.tests.push( {\n\t\tname: this.testName,\n\t\ttestId: this.testId\n\t} );\n\n\tif ( settings.skip ) {\n\n\t\t// Skipped tests will fully ignore any sent callback\n\t\tthis.callback = function() {};\n\t\tthis.async = false;\n\t\tthis.expected = 0;\n\t} else {\n\t\tthis.assert = new Assert( this );\n\t}\n}\n\nTest.count = 0;\n\nTest.prototype = {\n\tbefore: function() {\n\t\tif (\n\n\t\t\t// Emit moduleStart when we\'re switching from one module to another\n\t\t\tthis.module !== config.previousModule ||\n\n\t\t\t\t// They could be equal (both undefined) but if the previousModule property doesn\'t\n\t\t\t\t// yet exist it means this is the first test in a suite that isn\'t wrapped in a\n\t\t\t\t// module, in which case we\'ll just emit a moduleStart event for \'undefined\'.\n\t\t\t\t// Without this, reporters can get testStart before moduleStart  which is a problem.\n\t\t\t\t!hasOwn.call( config, "previousModule" )\n\t\t) {\n\t\t\tif ( hasOwn.call( config, "previousModule" ) ) {\n\t\t\t\trunLoggingCallbacks( "moduleDone", {\n\t\t\t\t\tname: config.previousModule.name,\n\t\t\t\t\ttests: config.previousModule.tests,\n\t\t\t\t\tfailed: config.moduleStats.bad,\n\t\t\t\t\tpassed: config.moduleStats.all - config.moduleStats.bad,\n\t\t\t\t\ttotal: config.moduleStats.all,\n\t\t\t\t\truntime: now() - config.moduleStats.started\n\t\t\t\t} );\n\t\t\t}\n\t\t\tconfig.previousModule = this.module;\n\t\t\tconfig.moduleStats = { all: 0, bad: 0, started: now() };\n\t\t\trunLoggingCallbacks( "moduleStart", {\n\t\t\t\tname: this.module.name,\n\t\t\t\ttests: this.module.tests\n\t\t\t} );\n\t\t}\n\n\t\tconfig.current = this;\n\n\t\tif ( this.module.testEnvironment ) {\n\t\t\tdelete this.module.testEnvironment.beforeEach;\n\t\t\tdelete this.module.testEnvironment.afterEach;\n\t\t}\n\t\tthis.testEnvironment = extend( {}, this.module.testEnvironment );\n\n\t\tthis.started = now();\n\t\trunLoggingCallbacks( "testStart", {\n\t\t\tname: this.testName,\n\t\t\tmodule: this.module.name,\n\t\t\ttestId: this.testId\n\t\t} );\n\n\t\tif ( !config.pollution ) {\n\t\t\tsaveGlobal();\n\t\t}\n\t},\n\n\trun: function() {\n\t\tvar promise;\n\n\t\tconfig.current = this;\n\n\t\tif ( this.async ) {\n\t\t\tQUnit.stop();\n\t\t}\n\n\t\tthis.callbackStarted = now();\n\n\t\tif ( config.notrycatch ) {\n\t\t\trunTest( this );\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\trunTest( this );\n\t\t} catch ( e ) {\n\t\t\tthis.pushFailure( "Died on test #" + ( this.assertions.length + 1 ) + " " +\n\t\t\t\tthis.stack + ": " + ( e.message || e ), extractStacktrace( e, 0 ) );\n\n\t\t\t// Else next test will carry the responsibility\n\t\t\tsaveGlobal();\n\n\t\t\t// Restart the tests if they\'re blocking\n\t\t\tif ( config.blocking ) {\n\t\t\t\tQUnit.start();\n\t\t\t}\n\t\t}\n\n\t\tfunction runTest( test ) {\n\t\t\tpromise = test.callback.call( test.testEnvironment, test.assert );\n\t\t\ttest.resolvePromise( promise );\n\t\t}\n\t},\n\n\tafter: function() {\n\t\tcheckPollution();\n\t},\n\n\tqueueHook: function( hook, hookName ) {\n\t\tvar promise,\n\t\t\ttest = this;\n\t\treturn function runHook() {\n\t\t\tconfig.current = test;\n\t\t\tif ( config.notrycatch ) {\n\t\t\t\tcallHook();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tcallHook();\n\t\t\t} catch ( error ) {\n\t\t\t\ttest.pushFailure( hookName + " failed on " + test.testName + ": " +\n\t\t\t\t( error.message || error ), extractStacktrace( error, 0 ) );\n\t\t\t}\n\n\t\t\tfunction callHook() {\n\t\t\t\tpromise = hook.call( test.testEnvironment, test.assert );\n\t\t\t\ttest.resolvePromise( promise, hookName );\n\t\t\t}\n\t\t};\n\t},\n\n\t// Currently only used for module level hooks, can be used to add global level ones\n\thooks: function( handler ) {\n\t\tvar hooks = [];\n\n\t\tfunction processHooks( test, module ) {\n\t\t\tif ( module.parentModule ) {\n\t\t\t\tprocessHooks( test, module.parentModule );\n\t\t\t}\n\t\t\tif ( module.testEnvironment &&\n\t\t\t\tQUnit.objectType( module.testEnvironment[ handler ] ) === "function" ) {\n\t\t\t\thooks.push( test.queueHook( module.testEnvironment[ handler ], handler ) );\n\t\t\t}\n\t\t}\n\n\t\t// Hooks are ignored on skipped tests\n\t\tif ( !this.skip ) {\n\t\t\tprocessHooks( this, this.module );\n\t\t}\n\t\treturn hooks;\n\t},\n\n\tfinish: function() {\n\t\tconfig.current = this;\n\t\tif ( config.requireExpects && this.expected === null ) {\n\t\t\tthis.pushFailure( "Expected number of assertions to be defined, but expect() was " +\n\t\t\t\t"not called.", this.stack );\n\t\t} else if ( this.expected !== null && this.expected !== this.assertions.length ) {\n\t\t\tthis.pushFailure( "Expected " + this.expected + " assertions, but " +\n\t\t\t\tthis.assertions.length + " were run", this.stack );\n\t\t} else if ( this.expected === null && !this.assertions.length ) {\n\t\t\tthis.pushFailure( "Expected at least one assertion, but none were run - call " +\n\t\t\t\t"expect(0) to accept zero assertions.", this.stack );\n\t\t}\n\n\t\tvar i,\n\t\t\tbad = 0;\n\n\t\tthis.runtime = now() - this.started;\n\t\tconfig.stats.all += this.assertions.length;\n\t\tconfig.moduleStats.all += this.assertions.length;\n\n\t\tfor ( i = 0; i < this.assertions.length; i++ ) {\n\t\t\tif ( !this.assertions[ i ].result ) {\n\t\t\t\tbad++;\n\t\t\t\tconfig.stats.bad++;\n\t\t\t\tconfig.moduleStats.bad++;\n\t\t\t}\n\t\t}\n\n\t\trunLoggingCallbacks( "testDone", {\n\t\t\tname: this.testName,\n\t\t\tmodule: this.module.name,\n\t\t\tskipped: !!this.skip,\n\t\t\tfailed: bad,\n\t\t\tpassed: this.assertions.length - bad,\n\t\t\ttotal: this.assertions.length,\n\t\t\truntime: this.runtime,\n\n\t\t\t// HTML Reporter use\n\t\t\tassertions: this.assertions,\n\t\t\ttestId: this.testId,\n\n\t\t\t// Source of Test\n\t\t\tsource: this.stack,\n\n\t\t\t// DEPRECATED: this property will be removed in 2.0.0, use runtime instead\n\t\t\tduration: this.runtime\n\t\t} );\n\n\t\t// QUnit.reset() is deprecated and will be replaced for a new\n\t\t// fixture reset function on QUnit 2.0/2.1.\n\t\t// It\'s still called here for backwards compatibility handling\n\t\tQUnit.reset();\n\n\t\tconfig.current = undefined;\n\t},\n\n\tqueue: function() {\n\t\tvar priority,\n\t\t\ttest = this;\n\n\t\tif ( !this.valid() ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfunction run() {\n\n\t\t\t// Each of these can by async\n\t\t\tsynchronize( [\n\t\t\t\tfunction() {\n\t\t\t\t\ttest.before();\n\t\t\t\t},\n\n\t\t\t\ttest.hooks( "beforeEach" ),\n\t\t\t\tfunction() {\n\t\t\t\t\ttest.run();\n\t\t\t\t},\n\n\t\t\t\ttest.hooks( "afterEach" ).reverse(),\n\n\t\t\t\tfunction() {\n\t\t\t\t\ttest.after();\n\t\t\t\t},\n\t\t\t\tfunction() {\n\t\t\t\t\ttest.finish();\n\t\t\t\t}\n\t\t\t] );\n\t\t}\n\n\t\t// Prioritize previously failed tests, detected from sessionStorage\n\t\tpriority = QUnit.config.reorder && defined.sessionStorage &&\n\t\t\t\t+sessionStorage.getItem( "qunit-test-" + this.module.name + "-" + this.testName );\n\n\t\treturn synchronize( run, priority, config.seed );\n\t},\n\n\tpushResult: function( resultInfo ) {\n\n\t\t// Destructure of resultInfo = { result, actual, expected, message, negative }\n\t\tvar source,\n\t\t\tdetails = {\n\t\t\t\tmodule: this.module.name,\n\t\t\t\tname: this.testName,\n\t\t\t\tresult: resultInfo.result,\n\t\t\t\tmessage: resultInfo.message,\n\t\t\t\tactual: resultInfo.actual,\n\t\t\t\texpected: resultInfo.expected,\n\t\t\t\ttestId: this.testId,\n\t\t\t\tnegative: resultInfo.negative || false,\n\t\t\t\truntime: now() - this.started\n\t\t\t};\n\n\t\tif ( !resultInfo.result ) {\n\t\t\tsource = sourceFromStacktrace();\n\n\t\t\tif ( source ) {\n\t\t\t\tdetails.source = source;\n\t\t\t}\n\t\t}\n\n\t\trunLoggingCallbacks( "log", details );\n\n\t\tthis.assertions.push( {\n\t\t\tresult: !!resultInfo.result,\n\t\t\tmessage: resultInfo.message\n\t\t} );\n\t},\n\n\tpushFailure: function( message, source, actual ) {\n\t\tif ( !( this instanceof Test ) ) {\n\t\t\tthrow new Error( "pushFailure() assertion outside test context, was " +\n\t\t\t\tsourceFromStacktrace( 2 ) );\n\t\t}\n\n\t\tvar details = {\n\t\t\t\tmodule: this.module.name,\n\t\t\t\tname: this.testName,\n\t\t\t\tresult: false,\n\t\t\t\tmessage: message || "error",\n\t\t\t\tactual: actual || null,\n\t\t\t\ttestId: this.testId,\n\t\t\t\truntime: now() - this.started\n\t\t\t};\n\n\t\tif ( source ) {\n\t\t\tdetails.source = source;\n\t\t}\n\n\t\trunLoggingCallbacks( "log", details );\n\n\t\tthis.assertions.push( {\n\t\t\tresult: false,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tresolvePromise: function( promise, phase ) {\n\t\tvar then, message,\n\t\t\ttest = this;\n\t\tif ( promise != null ) {\n\t\t\tthen = promise.then;\n\t\t\tif ( QUnit.objectType( then ) === "function" ) {\n\t\t\t\tQUnit.stop();\n\t\t\t\tthen.call(\n\t\t\t\t\tpromise,\n\t\t\t\t\tfunction() { QUnit.start(); },\n\t\t\t\t\tfunction( error ) {\n\t\t\t\t\t\tmessage = "Promise rejected " +\n\t\t\t\t\t\t\t( !phase ? "during" : phase.replace( /Each$/, "" ) ) +\n\t\t\t\t\t\t\t" " + test.testName + ": " + ( error.message || error );\n\t\t\t\t\t\ttest.pushFailure( message, extractStacktrace( error, 0 ) );\n\n\t\t\t\t\t\t// Else next test will carry the responsibility\n\t\t\t\t\t\tsaveGlobal();\n\n\t\t\t\t\t\t// Unblock\n\t\t\t\t\t\tQUnit.start();\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t},\n\n\tvalid: function() {\n\t\tvar filter = config.filter,\n\t\t\tregexFilter = /^(!?)\\/([\\w\\W]*)\\/(i?$)/.exec( filter ),\n\t\t\tmodule = config.module && config.module.toLowerCase(),\n\t\t\tfullName = ( this.module.name + ": " + this.testName );\n\n\t\tfunction moduleChainNameMatch( testModule ) {\n\t\t\tvar testModuleName = testModule.name ? testModule.name.toLowerCase() : null;\n\t\t\tif ( testModuleName === module ) {\n\t\t\t\treturn true;\n\t\t\t} else if ( testModule.parentModule ) {\n\t\t\t\treturn moduleChainNameMatch( testModule.parentModule );\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfunction moduleChainIdMatch( testModule ) {\n\t\t\treturn inArray( testModule.moduleId, config.moduleId ) > -1 ||\n\t\t\t\ttestModule.parentModule && moduleChainIdMatch( testModule.parentModule );\n\t\t}\n\n\t\t// Internally-generated tests are always valid\n\t\tif ( this.callback && this.callback.validTest ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif ( config.moduleId && config.moduleId.length > 0 &&\n\t\t\t!moduleChainIdMatch( this.module ) ) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( config.testId && config.testId.length > 0 &&\n\t\t\tinArray( this.testId, config.testId ) < 0 ) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( module && !moduleChainNameMatch( this.module ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( !filter ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn regexFilter ?\n\t\t\tthis.regexFilter( !!regexFilter[ 1 ], regexFilter[ 2 ], regexFilter[ 3 ], fullName ) :\n\t\t\tthis.stringFilter( filter, fullName );\n\t},\n\n\tregexFilter: function( exclude, pattern, flags, fullName ) {\n\t\tvar regex = new RegExp( pattern, flags );\n\t\tvar match = regex.test( fullName );\n\n\t\treturn match !== exclude;\n\t},\n\n\tstringFilter: function( filter, fullName ) {\n\t\tfilter = filter.toLowerCase();\n\t\tfullName = fullName.toLowerCase();\n\n\t\tvar include = filter.charAt( 0 ) !== "!";\n\t\tif ( !include ) {\n\t\t\tfilter = filter.slice( 1 );\n\t\t}\n\n\t\t// If the filter matches, we need to honour include\n\t\tif ( fullName.indexOf( filter ) !== -1 ) {\n\t\t\treturn include;\n\t\t}\n\n\t\t// Otherwise, do the opposite\n\t\treturn !include;\n\t}\n};\n\n// Resets the test setup. Useful for tests that modify the DOM.\n/*\nDEPRECATED: Use multiple tests instead of resetting inside a test.\nUse testStart or testDone for custom cleanup.\nThis method will throw an error in 2.0, and will be removed in 2.1\n*/\nQUnit.reset = function() {\n\n\t// Return on non-browser environments\n\t// This is necessary to not break on node tests\n\tif ( !defined.document ) {\n\t\treturn;\n\t}\n\n\tvar fixture = defined.document && document.getElementById &&\n\t\t\tdocument.getElementById( "qunit-fixture" );\n\n\tif ( fixture ) {\n\t\tfixture.innerHTML = config.fixture;\n\t}\n};\n\nQUnit.pushFailure = function() {\n\tif ( !QUnit.config.current ) {\n\t\tthrow new Error( "pushFailure() assertion outside test context, in " +\n\t\t\tsourceFromStacktrace( 2 ) );\n\t}\n\n\t// Gets current test obj\n\tvar currentTest = QUnit.config.current;\n\n\treturn currentTest.pushFailure.apply( currentTest, arguments );\n};\n\n// Based on Java\'s String.hashCode, a simple but not\n// rigorously collision resistant hashing function\nfunction generateHash( module, testName ) {\n\tvar hex,\n\t\ti = 0,\n\t\thash = 0,\n\t\tstr = module + "\\x1C" + testName,\n\t\tlen = str.length;\n\n\tfor ( ; i < len; i++ ) {\n\t\thash  = ( ( hash << 5 ) - hash ) + str.charCodeAt( i );\n\t\thash |= 0;\n\t}\n\n\t// Convert the possibly negative integer hash code into an 8 character hex string, which isn\'t\n\t// strictly necessary but increases user understanding that the id is a SHA-like hash\n\thex = ( 0x100000000 + hash ).toString( 16 );\n\tif ( hex.length < 8 ) {\n\t\thex = "0000000" + hex;\n\t}\n\n\treturn hex.slice( -8 );\n}\n\nfunction synchronize( callback, priority, seed ) {\n\tvar last = !priority,\n\t\tindex;\n\n\tif ( QUnit.objectType( callback ) === "array" ) {\n\t\twhile ( callback.length ) {\n\t\t\tsynchronize( callback.shift() );\n\t\t}\n\t\treturn;\n\t}\n\n\tif ( priority ) {\n\t\tconfig.queue.splice( priorityCount++, 0, callback );\n\t} else if ( seed ) {\n\t\tif ( !unitSampler ) {\n\t\t\tunitSampler = unitSamplerGenerator( seed );\n\t\t}\n\n\t\t// Insert into a random position after all priority items\n\t\tindex = Math.floor( unitSampler() * ( config.queue.length - priorityCount + 1 ) );\n\t\tconfig.queue.splice( priorityCount + index, 0, callback );\n\t} else {\n\t\tconfig.queue.push( callback );\n\t}\n\n\tif ( config.autorun && !config.blocking ) {\n\t\tprocess( last );\n\t}\n}\n\nfunction unitSamplerGenerator( seed ) {\n\n\t// 32-bit xorshift, requires only a nonzero seed\n\t// http://excamera.com/sphinx/article-xorshift.html\n\tvar sample = parseInt( generateHash( seed ), 16 ) || -1;\n\treturn function() {\n\t\tsample ^= sample << 13;\n\t\tsample ^= sample >>> 17;\n\t\tsample ^= sample << 5;\n\n\t\t// ECMAScript has no unsigned number type\n\t\tif ( sample < 0 ) {\n\t\t\tsample += 0x100000000;\n\t\t}\n\n\t\treturn sample / 0x100000000;\n\t};\n}\n\nfunction saveGlobal() {\n\tconfig.pollution = [];\n\n\tif ( config.noglobals ) {\n\t\tfor ( var key in global ) {\n\t\t\tif ( hasOwn.call( global, key ) ) {\n\n\t\t\t\t// In Opera sometimes DOM element ids show up here, ignore them\n\t\t\t\tif ( /^qunit-test-output/.test( key ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconfig.pollution.push( key );\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction checkPollution() {\n\tvar newGlobals,\n\t\tdeletedGlobals,\n\t\told = config.pollution;\n\n\tsaveGlobal();\n\n\tnewGlobals = diff( config.pollution, old );\n\tif ( newGlobals.length > 0 ) {\n\t\tQUnit.pushFailure( "Introduced global variable(s): " + newGlobals.join( ", " ) );\n\t}\n\n\tdeletedGlobals = diff( old, config.pollution );\n\tif ( deletedGlobals.length > 0 ) {\n\t\tQUnit.pushFailure( "Deleted global variable(s): " + deletedGlobals.join( ", " ) );\n\t}\n}\n\n// Will be exposed as QUnit.asyncTest\nfunction asyncTest( testName, expected, callback ) {\n\tif ( arguments.length === 2 ) {\n\t\tcallback = expected;\n\t\texpected = null;\n\t}\n\n\tQUnit.test( testName, expected, callback, true );\n}\n\n// Will be exposed as QUnit.test\nfunction test( testName, expected, callback, async ) {\n\tif ( focused )  { return; }\n\n\tvar newTest;\n\n\tif ( arguments.length === 2 ) {\n\t\tcallback = expected;\n\t\texpected = null;\n\t}\n\n\tnewTest = new Test( {\n\t\ttestName: testName,\n\t\texpected: expected,\n\t\tasync: async,\n\t\tcallback: callback\n\t} );\n\n\tnewTest.queue();\n}\n\n// Will be exposed as QUnit.skip\nfunction skip( testName ) {\n\tif ( focused )  { return; }\n\n\tvar test = new Test( {\n\t\ttestName: testName,\n\t\tskip: true\n\t} );\n\n\ttest.queue();\n}\n\n// Will be exposed as QUnit.only\nfunction only( testName, expected, callback, async ) {\n\tvar newTest;\n\n\tif ( focused )  { return; }\n\n\tQUnit.config.queue.length = 0;\n\tfocused = true;\n\n\tif ( arguments.length === 2 ) {\n\t\tcallback = expected;\n\t\texpected = null;\n\t}\n\n\tnewTest = new Test( {\n\t\ttestName: testName,\n\t\texpected: expected,\n\t\tasync: async,\n\t\tcallback: callback\n\t} );\n\n\tnewTest.queue();\n}\n\nfunction Assert( testContext ) {\n\tthis.test = testContext;\n}\n\n// Assert helpers\nQUnit.assert = Assert.prototype = {\n\n\t// Specify the number of expected assertions to guarantee that failed test\n\t// (no assertions are run at all) don\'t slip through.\n\texpect: function( asserts ) {\n\t\tif ( arguments.length === 1 ) {\n\t\t\tthis.test.expected = asserts;\n\t\t} else {\n\t\t\treturn this.test.expected;\n\t\t}\n\t},\n\n\t// Increment this Test\'s semaphore counter, then return a function that\n\t// decrements that counter a maximum of once.\n\tasync: function( count ) {\n\t\tvar test = this.test,\n\t\t\tpopped = false,\n\t\t\tacceptCallCount = count;\n\n\t\tif ( typeof acceptCallCount === "undefined" ) {\n\t\t\tacceptCallCount = 1;\n\t\t}\n\n\t\ttest.semaphore += 1;\n\t\ttest.usedAsync = true;\n\t\tpauseProcessing();\n\n\t\treturn function done() {\n\n\t\t\tif ( popped ) {\n\t\t\t\ttest.pushFailure( "Too many calls to the `assert.async` callback",\n\t\t\t\t\tsourceFromStacktrace( 2 ) );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tacceptCallCount -= 1;\n\t\t\tif ( acceptCallCount > 0 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttest.semaphore -= 1;\n\t\t\tpopped = true;\n\t\t\tresumeProcessing();\n\t\t};\n\t},\n\n\t// Exports test.push() to the user API\n\t// Alias of pushResult.\n\tpush: function( result, actual, expected, message, negative ) {\n\t\tvar currentAssert = this instanceof Assert ? this : QUnit.config.current.assert;\n\t\treturn currentAssert.pushResult( {\n\t\t\tresult: result,\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message,\n\t\t\tnegative: negative\n\t\t} );\n\t},\n\n\tpushResult: function( resultInfo ) {\n\n\t\t// Destructure of resultInfo = { result, actual, expected, message, negative }\n\t\tvar assert = this,\n\t\t\tcurrentTest = ( assert instanceof Assert && assert.test ) || QUnit.config.current;\n\n\t\t// Backwards compatibility fix.\n\t\t// Allows the direct use of global exported assertions and QUnit.assert.*\n\t\t// Although, it\'s use is not recommended as it can leak assertions\n\t\t// to other tests from async tests, because we only get a reference to the current test,\n\t\t// not exactly the test where assertion were intended to be called.\n\t\tif ( !currentTest ) {\n\t\t\tthrow new Error( "assertion outside test context, in " + sourceFromStacktrace( 2 ) );\n\t\t}\n\n\t\tif ( currentTest.usedAsync === true && currentTest.semaphore === 0 ) {\n\t\t\tcurrentTest.pushFailure( "Assertion after the final `assert.async` was resolved",\n\t\t\t\tsourceFromStacktrace( 2 ) );\n\n\t\t\t// Allow this assertion to continue running anyway...\n\t\t}\n\n\t\tif ( !( assert instanceof Assert ) ) {\n\t\t\tassert = currentTest.assert;\n\t\t}\n\n\t\treturn assert.test.pushResult( resultInfo );\n\t},\n\n\tok: function( result, message ) {\n\t\tmessage = message || ( result ? "okay" : "failed, expected argument to be truthy, was: " +\n\t\t\tQUnit.dump.parse( result ) );\n\t\tthis.pushResult( {\n\t\t\tresult: !!result,\n\t\t\tactual: result,\n\t\t\texpected: true,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tnotOk: function( result, message ) {\n\t\tmessage = message || ( !result ? "okay" : "failed, expected argument to be falsy, was: " +\n\t\t\tQUnit.dump.parse( result ) );\n\t\tthis.pushResult( {\n\t\t\tresult: !result,\n\t\t\tactual: result,\n\t\t\texpected: false,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tequal: function( actual, expected, message ) {\n\t\t/*jshint eqeqeq:false */\n\t\tthis.pushResult( {\n\t\t\tresult: expected == actual,\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tnotEqual: function( actual, expected, message ) {\n\t\t/*jshint eqeqeq:false */\n\t\tthis.pushResult( {\n\t\t\tresult: expected != actual,\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message,\n\t\t\tnegative: true\n\t\t} );\n\t},\n\n\tpropEqual: function( actual, expected, message ) {\n\t\tactual = objectValues( actual );\n\t\texpected = objectValues( expected );\n\t\tthis.pushResult( {\n\t\t\tresult: QUnit.equiv( actual, expected ),\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tnotPropEqual: function( actual, expected, message ) {\n\t\tactual = objectValues( actual );\n\t\texpected = objectValues( expected );\n\t\tthis.pushResult( {\n\t\t\tresult: !QUnit.equiv( actual, expected ),\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message,\n\t\t\tnegative: true\n\t\t} );\n\t},\n\n\tdeepEqual: function( actual, expected, message ) {\n\t\tthis.pushResult( {\n\t\t\tresult: QUnit.equiv( actual, expected ),\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tnotDeepEqual: function( actual, expected, message ) {\n\t\tthis.pushResult( {\n\t\t\tresult: !QUnit.equiv( actual, expected ),\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message,\n\t\t\tnegative: true\n\t\t} );\n\t},\n\n\tstrictEqual: function( actual, expected, message ) {\n\t\tthis.pushResult( {\n\t\t\tresult: expected === actual,\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tnotStrictEqual: function( actual, expected, message ) {\n\t\tthis.pushResult( {\n\t\t\tresult: expected !== actual,\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message,\n\t\t\tnegative: true\n\t\t} );\n\t},\n\n\t"throws": function( block, expected, message ) {\n\t\tvar actual, expectedType,\n\t\t\texpectedOutput = expected,\n\t\t\tok = false,\n\t\t\tcurrentTest = ( this instanceof Assert && this.test ) || QUnit.config.current;\n\n\t\t// \'expected\' is optional unless doing string comparison\n\t\tif ( message == null && typeof expected === "string" ) {\n\t\t\tmessage = expected;\n\t\t\texpected = null;\n\t\t}\n\n\t\tcurrentTest.ignoreGlobalErrors = true;\n\t\ttry {\n\t\t\tblock.call( currentTest.testEnvironment );\n\t\t} catch ( e ) {\n\t\t\tactual = e;\n\t\t}\n\t\tcurrentTest.ignoreGlobalErrors = false;\n\n\t\tif ( actual ) {\n\t\t\texpectedType = QUnit.objectType( expected );\n\n\t\t\t// We don\'t want to validate thrown error\n\t\t\tif ( !expected ) {\n\t\t\t\tok = true;\n\t\t\t\texpectedOutput = null;\n\n\t\t\t// Expected is a regexp\n\t\t\t} else if ( expectedType === "regexp" ) {\n\t\t\t\tok = expected.test( errorString( actual ) );\n\n\t\t\t// Expected is a string\n\t\t\t} else if ( expectedType === "string" ) {\n\t\t\t\tok = expected === errorString( actual );\n\n\t\t\t// Expected is a constructor, maybe an Error constructor\n\t\t\t} else if ( expectedType === "function" && actual instanceof expected ) {\n\t\t\t\tok = true;\n\n\t\t\t// Expected is an Error object\n\t\t\t} else if ( expectedType === "object" ) {\n\t\t\t\tok = actual instanceof expected.constructor &&\n\t\t\t\t\tactual.name === expected.name &&\n\t\t\t\t\tactual.message === expected.message;\n\n\t\t\t// Expected is a validation function which returns true if validation passed\n\t\t\t} else if ( expectedType === "function" && expected.call( {}, actual ) === true ) {\n\t\t\t\texpectedOutput = null;\n\t\t\t\tok = true;\n\t\t\t}\n\t\t}\n\n\t\tcurrentTest.assert.pushResult( {\n\t\t\tresult: ok,\n\t\t\tactual: actual,\n\t\t\texpected: expectedOutput,\n\t\t\tmessage: message\n\t\t} );\n\t}\n};\n\n// Provide an alternative to assert.throws(), for environments that consider throws a reserved word\n// Known to us are: Closure Compiler, Narwhal\n( function() {\n\t/*jshint sub:true */\n\tAssert.prototype.raises = Assert.prototype [ "throws" ]; //jscs:ignore requireDotNotation\n}() );\n\nfunction errorString( error ) {\n\tvar name, message,\n\t\tresultErrorString = error.toString();\n\tif ( resultErrorString.substring( 0, 7 ) === "[object" ) {\n\t\tname = error.name ? error.name.toString() : "Error";\n\t\tmessage = error.message ? error.message.toString() : "";\n\t\tif ( name && message ) {\n\t\t\treturn name + ": " + message;\n\t\t} else if ( name ) {\n\t\t\treturn name;\n\t\t} else if ( message ) {\n\t\t\treturn message;\n\t\t} else {\n\t\t\treturn "Error";\n\t\t}\n\t} else {\n\t\treturn resultErrorString;\n\t}\n}\n\n// Test for equality any JavaScript type.\n// Author: Philippe Rathé <prathe@gmail.com>\nQUnit.equiv = ( function() {\n\n\t// Stack to decide between skip/abort functions\n\tvar callers = [];\n\n\t// Stack to avoiding loops from circular referencing\n\tvar parents = [];\n\tvar parentsB = [];\n\n\tvar getProto = Object.getPrototypeOf || function( obj ) {\n\n\t\t/*jshint proto: true */\n\t\treturn obj.__proto__;\n\t};\n\n\tfunction useStrictEquality( b, a ) {\n\n\t\t// To catch short annotation VS \'new\' annotation of a declaration. e.g.:\n\t\t// `var i = 1;`\n\t\t// `var j = new Number(1);`\n\t\tif ( typeof a === "object" ) {\n\t\t\ta = a.valueOf();\n\t\t}\n\t\tif ( typeof b === "object" ) {\n\t\t\tb = b.valueOf();\n\t\t}\n\n\t\treturn a === b;\n\t}\n\n\tfunction compareConstructors( a, b ) {\n\t\tvar protoA = getProto( a );\n\t\tvar protoB = getProto( b );\n\n\t\t// Comparing constructors is more strict than using `instanceof`\n\t\tif ( a.constructor === b.constructor ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Ref #851\n\t\t// If the obj prototype descends from a null constructor, treat it\n\t\t// as a null prototype.\n\t\tif ( protoA && protoA.constructor === null ) {\n\t\t\tprotoA = null;\n\t\t}\n\t\tif ( protoB && protoB.constructor === null ) {\n\t\t\tprotoB = null;\n\t\t}\n\n\t\t// Allow objects with no prototype to be equivalent to\n\t\t// objects with Object as their constructor.\n\t\tif ( ( protoA === null && protoB === Object.prototype ) ||\n\t\t\t\t( protoB === null && protoA === Object.prototype ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tfunction getRegExpFlags( regexp ) {\n\t\treturn "flags" in regexp ? regexp.flags : regexp.toString().match( /[gimuy]*$/ )[ 0 ];\n\t}\n\n\tvar callbacks = {\n\t\t"string": useStrictEquality,\n\t\t"boolean": useStrictEquality,\n\t\t"number": useStrictEquality,\n\t\t"null": useStrictEquality,\n\t\t"undefined": useStrictEquality,\n\t\t"symbol": useStrictEquality,\n\t\t"date": useStrictEquality,\n\n\t\t"nan": function() {\n\t\t\treturn true;\n\t\t},\n\n\t\t"regexp": function( b, a ) {\n\t\t\treturn a.source === b.source &&\n\n\t\t\t\t// Include flags in the comparison\n\t\t\t\tgetRegExpFlags( a ) === getRegExpFlags( b );\n\t\t},\n\n\t\t// - skip when the property is a method of an instance (OOP)\n\t\t// - abort otherwise,\n\t\t// initial === would have catch identical references anyway\n\t\t"function": function() {\n\t\t\tvar caller = callers[ callers.length - 1 ];\n\t\t\treturn caller !== Object && typeof caller !== "undefined";\n\t\t},\n\n\t\t"array": function( b, a ) {\n\t\t\tvar i, j, len, loop, aCircular, bCircular;\n\n\t\t\tlen = a.length;\n\t\t\tif ( len !== b.length ) {\n\n\t\t\t\t// Safe and faster\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Track reference to avoid circular references\n\t\t\tparents.push( a );\n\t\t\tparentsB.push( b );\n\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\tloop = false;\n\t\t\t\tfor ( j = 0; j < parents.length; j++ ) {\n\t\t\t\t\taCircular = parents[ j ] === a[ i ];\n\t\t\t\t\tbCircular = parentsB[ j ] === b[ i ];\n\t\t\t\t\tif ( aCircular || bCircular ) {\n\t\t\t\t\t\tif ( a[ i ] === b[ i ] || aCircular && bCircular ) {\n\t\t\t\t\t\t\tloop = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tparents.pop();\n\t\t\t\t\t\t\tparentsB.pop();\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( !loop && !innerEquiv( a[ i ], b[ i ] ) ) {\n\t\t\t\t\tparents.pop();\n\t\t\t\t\tparentsB.pop();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tparents.pop();\n\t\t\tparentsB.pop();\n\t\t\treturn true;\n\t\t},\n\n\t\t"set": function( b, a ) {\n\t\t\tvar innerEq,\n\t\t\t\touterEq = true;\n\n\t\t\tif ( a.size !== b.size ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\ta.forEach( function( aVal ) {\n\t\t\t\tinnerEq = false;\n\n\t\t\t\tb.forEach( function( bVal ) {\n\t\t\t\t\tif ( innerEquiv( bVal, aVal ) ) {\n\t\t\t\t\t\tinnerEq = true;\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\tif ( !innerEq ) {\n\t\t\t\t\touterEq = false;\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\treturn outerEq;\n\t\t},\n\n\t\t"map": function( b, a ) {\n\t\t\tvar innerEq,\n\t\t\t\touterEq = true;\n\n\t\t\tif ( a.size !== b.size ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\ta.forEach( function( aVal, aKey ) {\n\t\t\t\tinnerEq = false;\n\n\t\t\t\tb.forEach( function( bVal, bKey ) {\n\t\t\t\t\tif ( innerEquiv( [ bVal, bKey ], [ aVal, aKey ] ) ) {\n\t\t\t\t\t\tinnerEq = true;\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\tif ( !innerEq ) {\n\t\t\t\t\touterEq = false;\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\treturn outerEq;\n\t\t},\n\n\t\t"object": function( b, a ) {\n\t\t\tvar i, j, loop, aCircular, bCircular;\n\n\t\t\t// Default to true\n\t\t\tvar eq = true;\n\t\t\tvar aProperties = [];\n\t\t\tvar bProperties = [];\n\n\t\t\tif ( compareConstructors( a, b ) === false ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Stack constructor before traversing properties\n\t\t\tcallers.push( a.constructor );\n\n\t\t\t// Track reference to avoid circular references\n\t\t\tparents.push( a );\n\t\t\tparentsB.push( b );\n\n\t\t\t// Be strict: don\'t ensure hasOwnProperty and go deep\n\t\t\tfor ( i in a ) {\n\t\t\t\tloop = false;\n\t\t\t\tfor ( j = 0; j < parents.length; j++ ) {\n\t\t\t\t\taCircular = parents[ j ] === a[ i ];\n\t\t\t\t\tbCircular = parentsB[ j ] === b[ i ];\n\t\t\t\t\tif ( aCircular || bCircular ) {\n\t\t\t\t\t\tif ( a[ i ] === b[ i ] || aCircular && bCircular ) {\n\t\t\t\t\t\t\tloop = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\teq = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taProperties.push( i );\n\t\t\t\tif ( !loop && !innerEquiv( a[ i ], b[ i ] ) ) {\n\t\t\t\t\teq = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tparents.pop();\n\t\t\tparentsB.pop();\n\n\t\t\t// Unstack, we are done\n\t\t\tcallers.pop();\n\n\t\t\tfor ( i in b ) {\n\n\t\t\t\t// Collect b\'s properties\n\t\t\t\tbProperties.push( i );\n\t\t\t}\n\n\t\t\t// Ensures identical properties name\n\t\t\treturn eq && innerEquiv( aProperties.sort(), bProperties.sort() );\n\t\t}\n\t};\n\n\tfunction typeEquiv( a, b ) {\n\t\tvar type = QUnit.objectType( a );\n\t\treturn QUnit.objectType( b ) === type && callbacks[ type ]( b, a );\n\t}\n\n\t// The real equiv function\n\tfunction innerEquiv( a, b ) {\n\n\t\t// We\'re done when there\'s nothing more to compare\n\t\tif ( arguments.length < 2 ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Require type-specific equality\n\t\treturn ( a === b || typeEquiv( a, b ) ) &&\n\n\t\t\t// ...across all consecutive argument pairs\n\t\t\t( arguments.length === 2 || innerEquiv.apply( this, [].slice.call( arguments, 1 ) ) );\n\t}\n\n\treturn innerEquiv;\n}() );\n\n// Based on jsDump by Ariel Flesler\n// http://flesler.blogspot.com/2008/05/jsdump-pretty-dump-of-any-javascript.html\nQUnit.dump = ( function() {\n\tfunction quote( str ) {\n\t\treturn "\\"" + str.toString().replace( /\\\\/g, "\\\\\\\\" ).replace( /"/g, "\\\\\\"" ) + "\\"";\n\t}\n\tfunction literal( o ) {\n\t\treturn o + "";\n\t}\n\tfunction join( pre, arr, post ) {\n\t\tvar s = dump.separator(),\n\t\t\tbase = dump.indent(),\n\t\t\tinner = dump.indent( 1 );\n\t\tif ( arr.join ) {\n\t\t\tarr = arr.join( "," + s + inner );\n\t\t}\n\t\tif ( !arr ) {\n\t\t\treturn pre + post;\n\t\t}\n\t\treturn [ pre, inner + arr, base + post ].join( s );\n\t}\n\tfunction array( arr, stack ) {\n\t\tvar i = arr.length,\n\t\t\tret = new Array( i );\n\n\t\tif ( dump.maxDepth && dump.depth > dump.maxDepth ) {\n\t\t\treturn "[object Array]";\n\t\t}\n\n\t\tthis.up();\n\t\twhile ( i-- ) {\n\t\t\tret[ i ] = this.parse( arr[ i ], undefined, stack );\n\t\t}\n\t\tthis.down();\n\t\treturn join( "[", ret, "]" );\n\t}\n\n\tvar reName = /^function (\\w+)/,\n\t\tdump = {\n\n\t\t\t// The objType is used mostly internally, you can fix a (custom) type in advance\n\t\t\tparse: function( obj, objType, stack ) {\n\t\t\t\tstack = stack || [];\n\t\t\t\tvar res, parser, parserType,\n\t\t\t\t\tinStack = inArray( obj, stack );\n\n\t\t\t\tif ( inStack !== -1 ) {\n\t\t\t\t\treturn "recursion(" + ( inStack - stack.length ) + ")";\n\t\t\t\t}\n\n\t\t\t\tobjType = objType || this.typeOf( obj  );\n\t\t\t\tparser = this.parsers[ objType ];\n\t\t\t\tparserType = typeof parser;\n\n\t\t\t\tif ( parserType === "function" ) {\n\t\t\t\t\tstack.push( obj );\n\t\t\t\t\tres = parser.call( this, obj, stack );\n\t\t\t\t\tstack.pop();\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\treturn ( parserType === "string" ) ? parser : this.parsers.error;\n\t\t\t},\n\t\t\ttypeOf: function( obj ) {\n\t\t\t\tvar type;\n\t\t\t\tif ( obj === null ) {\n\t\t\t\t\ttype = "null";\n\t\t\t\t} else if ( typeof obj === "undefined" ) {\n\t\t\t\t\ttype = "undefined";\n\t\t\t\t} else if ( QUnit.is( "regexp", obj ) ) {\n\t\t\t\t\ttype = "regexp";\n\t\t\t\t} else if ( QUnit.is( "date", obj ) ) {\n\t\t\t\t\ttype = "date";\n\t\t\t\t} else if ( QUnit.is( "function", obj ) ) {\n\t\t\t\t\ttype = "function";\n\t\t\t\t} else if ( obj.setInterval !== undefined &&\n\t\t\t\t\t\tobj.document !== undefined &&\n\t\t\t\t\t\tobj.nodeType === undefined ) {\n\t\t\t\t\ttype = "window";\n\t\t\t\t} else if ( obj.nodeType === 9 ) {\n\t\t\t\t\ttype = "document";\n\t\t\t\t} else if ( obj.nodeType ) {\n\t\t\t\t\ttype = "node";\n\t\t\t\t} else if (\n\n\t\t\t\t\t// Native arrays\n\t\t\t\t\ttoString.call( obj ) === "[object Array]" ||\n\n\t\t\t\t\t// NodeList objects\n\t\t\t\t\t( typeof obj.length === "number" && obj.item !== undefined &&\n\t\t\t\t\t( obj.length ? obj.item( 0 ) === obj[ 0 ] : ( obj.item( 0 ) === null &&\n\t\t\t\t\tobj[ 0 ] === undefined ) ) )\n\t\t\t\t) {\n\t\t\t\t\ttype = "array";\n\t\t\t\t} else if ( obj.constructor === Error.prototype.constructor ) {\n\t\t\t\t\ttype = "error";\n\t\t\t\t} else {\n\t\t\t\t\ttype = typeof obj;\n\t\t\t\t}\n\t\t\t\treturn type;\n\t\t\t},\n\n\t\t\tseparator: function() {\n\t\t\t\treturn this.multiline ? this.HTML ? "<br />" : "\\n" : this.HTML ? "&#160;" : " ";\n\t\t\t},\n\n\t\t\t// Extra can be a number, shortcut for increasing-calling-decreasing\n\t\t\tindent: function( extra ) {\n\t\t\t\tif ( !this.multiline ) {\n\t\t\t\t\treturn "";\n\t\t\t\t}\n\t\t\t\tvar chr = this.indentChar;\n\t\t\t\tif ( this.HTML ) {\n\t\t\t\t\tchr = chr.replace( /\\t/g, "   " ).replace( / /g, "&#160;" );\n\t\t\t\t}\n\t\t\t\treturn new Array( this.depth + ( extra || 0 ) ).join( chr );\n\t\t\t},\n\t\t\tup: function( a ) {\n\t\t\t\tthis.depth += a || 1;\n\t\t\t},\n\t\t\tdown: function( a ) {\n\t\t\t\tthis.depth -= a || 1;\n\t\t\t},\n\t\t\tsetParser: function( name, parser ) {\n\t\t\t\tthis.parsers[ name ] = parser;\n\t\t\t},\n\n\t\t\t// The next 3 are exposed so you can use them\n\t\t\tquote: quote,\n\t\t\tliteral: literal,\n\t\t\tjoin: join,\n\t\t\tdepth: 1,\n\t\t\tmaxDepth: QUnit.config.maxDepth,\n\n\t\t\t// This is the list of parsers, to modify them, use dump.setParser\n\t\t\tparsers: {\n\t\t\t\twindow: "[Window]",\n\t\t\t\tdocument: "[Document]",\n\t\t\t\terror: function( error ) {\n\t\t\t\t\treturn "Error(\\"" + error.message + "\\")";\n\t\t\t\t},\n\t\t\t\tunknown: "[Unknown]",\n\t\t\t\t"null": "null",\n\t\t\t\t"undefined": "undefined",\n\t\t\t\t"function": function( fn ) {\n\t\t\t\t\tvar ret = "function",\n\n\t\t\t\t\t\t// Functions never have name in IE\n\t\t\t\t\t\tname = "name" in fn ? fn.name : ( reName.exec( fn ) || [] )[ 1 ];\n\n\t\t\t\t\tif ( name ) {\n\t\t\t\t\t\tret += " " + name;\n\t\t\t\t\t}\n\t\t\t\t\tret += "(";\n\n\t\t\t\t\tret = [ ret, dump.parse( fn, "functionArgs" ), "){" ].join( "" );\n\t\t\t\t\treturn join( ret, dump.parse( fn, "functionCode" ), "}" );\n\t\t\t\t},\n\t\t\t\tarray: array,\n\t\t\t\tnodelist: array,\n\t\t\t\t"arguments": array,\n\t\t\t\tobject: function( map, stack ) {\n\t\t\t\t\tvar keys, key, val, i, nonEnumerableProperties,\n\t\t\t\t\t\tret = [];\n\n\t\t\t\t\tif ( dump.maxDepth && dump.depth > dump.maxDepth ) {\n\t\t\t\t\t\treturn "[object Object]";\n\t\t\t\t\t}\n\n\t\t\t\t\tdump.up();\n\t\t\t\t\tkeys = [];\n\t\t\t\t\tfor ( key in map ) {\n\t\t\t\t\t\tkeys.push( key );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Some properties are not always enumerable on Error objects.\n\t\t\t\t\tnonEnumerableProperties = [ "message", "name" ];\n\t\t\t\t\tfor ( i in nonEnumerableProperties ) {\n\t\t\t\t\t\tkey = nonEnumerableProperties[ i ];\n\t\t\t\t\t\tif ( key in map && inArray( key, keys ) < 0 ) {\n\t\t\t\t\t\t\tkeys.push( key );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tkeys.sort();\n\t\t\t\t\tfor ( i = 0; i < keys.length; i++ ) {\n\t\t\t\t\t\tkey = keys[ i ];\n\t\t\t\t\t\tval = map[ key ];\n\t\t\t\t\t\tret.push( dump.parse( key, "key" ) + ": " +\n\t\t\t\t\t\t\tdump.parse( val, undefined, stack ) );\n\t\t\t\t\t}\n\t\t\t\t\tdump.down();\n\t\t\t\t\treturn join( "{", ret, "}" );\n\t\t\t\t},\n\t\t\t\tnode: function( node ) {\n\t\t\t\t\tvar len, i, val,\n\t\t\t\t\t\topen = dump.HTML ? "&lt;" : "<",\n\t\t\t\t\t\tclose = dump.HTML ? "&gt;" : ">",\n\t\t\t\t\t\ttag = node.nodeName.toLowerCase(),\n\t\t\t\t\t\tret = open + tag,\n\t\t\t\t\t\tattrs = node.attributes;\n\n\t\t\t\t\tif ( attrs ) {\n\t\t\t\t\t\tfor ( i = 0, len = attrs.length; i < len; i++ ) {\n\t\t\t\t\t\t\tval = attrs[ i ].nodeValue;\n\n\t\t\t\t\t\t\t// IE6 includes all attributes in .attributes, even ones not explicitly\n\t\t\t\t\t\t\t// set. Those have values like undefined, null, 0, false, "" or\n\t\t\t\t\t\t\t// "inherit".\n\t\t\t\t\t\t\tif ( val && val !== "inherit" ) {\n\t\t\t\t\t\t\t\tret += " " + attrs[ i ].nodeName + "=" +\n\t\t\t\t\t\t\t\t\tdump.parse( val, "attribute" );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tret += close;\n\n\t\t\t\t\t// Show content of TextNode or CDATASection\n\t\t\t\t\tif ( node.nodeType === 3 || node.nodeType === 4 ) {\n\t\t\t\t\t\tret += node.nodeValue;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn ret + open + "/" + tag + close;\n\t\t\t\t},\n\n\t\t\t\t// Function calls it internally, it\'s the arguments part of the function\n\t\t\t\tfunctionArgs: function( fn ) {\n\t\t\t\t\tvar args,\n\t\t\t\t\t\tl = fn.length;\n\n\t\t\t\t\tif ( !l ) {\n\t\t\t\t\t\treturn "";\n\t\t\t\t\t}\n\n\t\t\t\t\targs = new Array( l );\n\t\t\t\t\twhile ( l-- ) {\n\n\t\t\t\t\t\t// 97 is \'a\'\n\t\t\t\t\t\targs[ l ] = String.fromCharCode( 97 + l );\n\t\t\t\t\t}\n\t\t\t\t\treturn " " + args.join( ", " ) + " ";\n\t\t\t\t},\n\n\t\t\t\t// Object calls it internally, the key part of an item in a map\n\t\t\t\tkey: quote,\n\n\t\t\t\t// Function calls it internally, it\'s the content of the function\n\t\t\t\tfunctionCode: "[code]",\n\n\t\t\t\t// Node calls it internally, it\'s a html attribute value\n\t\t\t\tattribute: quote,\n\t\t\t\tstring: quote,\n\t\t\t\tdate: quote,\n\t\t\t\tregexp: literal,\n\t\t\t\tnumber: literal,\n\t\t\t\t"boolean": literal\n\t\t\t},\n\n\t\t\t// If true, entities are escaped ( <, >, \\t, space and \\n )\n\t\t\tHTML: false,\n\n\t\t\t// Indentation unit\n\t\t\tindentChar: "  ",\n\n\t\t\t// If true, items in a collection, are separated by a \\n, else just a space.\n\t\t\tmultiline: true\n\t\t};\n\n\treturn dump;\n}() );\n\n// Back compat\nQUnit.jsDump = QUnit.dump;\n\n// Deprecated\n// Extend assert methods to QUnit for Backwards compatibility\n( function() {\n\tvar i,\n\t\tassertions = Assert.prototype;\n\n\tfunction applyCurrent( current ) {\n\t\treturn function() {\n\t\t\tvar assert = new Assert( QUnit.config.current );\n\t\t\tcurrent.apply( assert, arguments );\n\t\t};\n\t}\n\n\tfor ( i in assertions ) {\n\t\tQUnit[ i ] = applyCurrent( assertions[ i ] );\n\t}\n}() );\n\n// For browser, export only select globals\nif ( defined.document ) {\n\n\t( function() {\n\t\tvar i, l,\n\t\t\tkeys = [\n\t\t\t\t"test",\n\t\t\t\t"module",\n\t\t\t\t"expect",\n\t\t\t\t"asyncTest",\n\t\t\t\t"start",\n\t\t\t\t"stop",\n\t\t\t\t"ok",\n\t\t\t\t"notOk",\n\t\t\t\t"equal",\n\t\t\t\t"notEqual",\n\t\t\t\t"propEqual",\n\t\t\t\t"notPropEqual",\n\t\t\t\t"deepEqual",\n\t\t\t\t"notDeepEqual",\n\t\t\t\t"strictEqual",\n\t\t\t\t"notStrictEqual",\n\t\t\t\t"throws",\n\t\t\t\t"raises"\n\t\t\t];\n\n\t\tfor ( i = 0, l = keys.length; i < l; i++ ) {\n\t\t\twindow[ keys[ i ] ] = QUnit[ keys[ i ] ];\n\t\t}\n\t}() );\n\n\twindow.QUnit = QUnit;\n}\n\n// For nodejs\nif ( typeof module !== "undefined" && module && module.exports ) {\n\tmodule.exports = QUnit;\n\n\t// For consistency with CommonJS environments\' exports\n\tmodule.exports.QUnit = QUnit;\n}\n\n// For CommonJS with exports, but without module.exports, like Rhino\nif ( typeof exports !== "undefined" && exports ) {\n\texports.QUnit = QUnit;\n}\n\nif ( typeof define === "function" && define.amd ) {\n\tdefine( function() {\n\t\treturn QUnit;\n\t} );\n\tQUnit.config.autostart = false;\n}\n\n// Get a reference to the global object, like window in browsers\n}( ( function() {\n\treturn this;\n}() ) ) );\n\n( function() {\n\n// Only interact with URLs via window.location\nvar location = typeof window !== "undefined" && window.location;\nif ( !location ) {\n\treturn;\n}\n\nvar urlParams = getUrlParams();\n\nQUnit.urlParams = urlParams;\n\n// Match module/test by inclusion in an array\nQUnit.config.moduleId = [].concat( urlParams.moduleId || [] );\nQUnit.config.testId = [].concat( urlParams.testId || [] );\n\n// Exact case-insensitive match of the module name\nQUnit.config.module = urlParams.module;\n\n// Regular expression or case-insenstive substring match against "moduleName: testName"\nQUnit.config.filter = urlParams.filter;\n\n// Test order randomization\nif ( urlParams.seed === true ) {\n\n\t// Generate a random seed if the option is specified without a value\n\tQUnit.config.seed = Math.random().toString( 36 ).slice( 2 );\n} else if ( urlParams.seed ) {\n\tQUnit.config.seed = urlParams.seed;\n}\n\n// Add URL-parameter-mapped config values with UI form rendering data\nQUnit.config.urlConfig.push(\n\t{\n\t\tid: "hidepassed",\n\t\tlabel: "Hide passed tests",\n\t\ttooltip: "Only show tests and assertions that fail. Stored as query-strings."\n\t},\n\t{\n\t\tid: "noglobals",\n\t\tlabel: "Check for Globals",\n\t\ttooltip: "Enabling this will test if any test introduces new properties on the " +\n\t\t\t"global object (`window` in Browsers). Stored as query-strings."\n\t},\n\t{\n\t\tid: "notrycatch",\n\t\tlabel: "No try-catch",\n\t\ttooltip: "Enabling this will run tests outside of a try-catch block. Makes debugging " +\n\t\t\t"exceptions in IE reasonable. Stored as query-strings."\n\t}\n);\n\nQUnit.begin( function() {\n\tvar i, option,\n\t\turlConfig = QUnit.config.urlConfig;\n\n\tfor ( i = 0; i < urlConfig.length; i++ ) {\n\n\t\t// Options can be either strings or objects with nonempty "id" properties\n\t\toption = QUnit.config.urlConfig[ i ];\n\t\tif ( typeof option !== "string" ) {\n\t\t\toption = option.id;\n\t\t}\n\n\t\tif ( QUnit.config[ option ] === undefined ) {\n\t\t\tQUnit.config[ option ] = urlParams[ option ];\n\t\t}\n\t}\n} );\n\nfunction getUrlParams() {\n\tvar i, param, name, value;\n\tvar urlParams = {};\n\tvar params = location.search.slice( 1 ).split( "&" );\n\tvar length = params.length;\n\n\tfor ( i = 0; i < length; i++ ) {\n\t\tif ( params[ i ] ) {\n\t\t\tparam = params[ i ].split( "=" );\n\t\t\tname = decodeURIComponent( param[ 0 ] );\n\n\t\t\t// Allow just a key to turn on a flag, e.g., test.html?noglobals\n\t\t\tvalue = param.length === 1 ||\n\t\t\t\tdecodeURIComponent( param.slice( 1 ).join( "=" ) ) ;\n\t\t\tif ( urlParams[ name ] ) {\n\t\t\t\turlParams[ name ] = [].concat( urlParams[ name ], value );\n\t\t\t} else {\n\t\t\t\turlParams[ name ] = value;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn urlParams;\n}\n\n// Don\'t load the HTML Reporter on non-browser environments\nif ( typeof window === "undefined" || !window.document ) {\n\treturn;\n}\n\n// Deprecated QUnit.init - Ref #530\n// Re-initialize the configuration options\nQUnit.init = function() {\n\tvar config = QUnit.config;\n\n\tconfig.stats = { all: 0, bad: 0 };\n\tconfig.moduleStats = { all: 0, bad: 0 };\n\tconfig.started = 0;\n\tconfig.updateRate = 1000;\n\tconfig.blocking = false;\n\tconfig.autostart = true;\n\tconfig.autorun = false;\n\tconfig.filter = "";\n\tconfig.queue = [];\n\n\tappendInterface();\n};\n\nvar config = QUnit.config,\n\tdocument = window.document,\n\tcollapseNext = false,\n\thasOwn = Object.prototype.hasOwnProperty,\n\tunfilteredUrl = setUrl( { filter: undefined, module: undefined,\n\t\tmoduleId: undefined, testId: undefined } ),\n\tdefined = {\n\t\tsessionStorage: ( function() {\n\t\t\tvar x = "qunit-test-string";\n\t\t\ttry {\n\t\t\t\tsessionStorage.setItem( x, x );\n\t\t\t\tsessionStorage.removeItem( x );\n\t\t\t\treturn true;\n\t\t\t} catch ( e ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}() )\n\t},\n\tmodulesList = [];\n\n/**\n* Escape text for attribute or text content.\n*/\nfunction escapeText( s ) {\n\tif ( !s ) {\n\t\treturn "";\n\t}\n\ts = s + "";\n\n\t// Both single quotes and double quotes (for attributes)\n\treturn s.replace( /[\'"<>&]/g, function( s ) {\n\t\tswitch ( s ) {\n\t\tcase "\'":\n\t\t\treturn "&#039;";\n\t\tcase "\\"":\n\t\t\treturn "&quot;";\n\t\tcase "<":\n\t\t\treturn "&lt;";\n\t\tcase ">":\n\t\t\treturn "&gt;";\n\t\tcase "&":\n\t\t\treturn "&amp;";\n\t\t}\n\t} );\n}\n\n/**\n * @param {HTMLElement} elem\n * @param {string} type\n * @param {Function} fn\n */\nfunction addEvent( elem, type, fn ) {\n\tif ( elem.addEventListener ) {\n\n\t\t// Standards-based browsers\n\t\telem.addEventListener( type, fn, false );\n\t} else if ( elem.attachEvent ) {\n\n\t\t// Support: IE <9\n\t\telem.attachEvent( "on" + type, function() {\n\t\t\tvar event = window.event;\n\t\t\tif ( !event.target ) {\n\t\t\t\tevent.target = event.srcElement || document;\n\t\t\t}\n\n\t\t\tfn.call( elem, event );\n\t\t} );\n\t}\n}\n\n/**\n * @param {Array|NodeList} elems\n * @param {string} type\n * @param {Function} fn\n */\nfunction addEvents( elems, type, fn ) {\n\tvar i = elems.length;\n\twhile ( i-- ) {\n\t\taddEvent( elems[ i ], type, fn );\n\t}\n}\n\nfunction hasClass( elem, name ) {\n\treturn ( " " + elem.className + " " ).indexOf( " " + name + " " ) >= 0;\n}\n\nfunction addClass( elem, name ) {\n\tif ( !hasClass( elem, name ) ) {\n\t\telem.className += ( elem.className ? " " : "" ) + name;\n\t}\n}\n\nfunction toggleClass( elem, name, force ) {\n\tif ( force || typeof force === "undefined" && !hasClass( elem, name ) ) {\n\t\taddClass( elem, name );\n\t} else {\n\t\tremoveClass( elem, name );\n\t}\n}\n\nfunction removeClass( elem, name ) {\n\tvar set = " " + elem.className + " ";\n\n\t// Class name may appear multiple times\n\twhile ( set.indexOf( " " + name + " " ) >= 0 ) {\n\t\tset = set.replace( " " + name + " ", " " );\n\t}\n\n\t// Trim for prettiness\n\telem.className = typeof set.trim === "function" ? set.trim() : set.replace( /^\\s+|\\s+$/g, "" );\n}\n\nfunction id( name ) {\n\treturn document.getElementById && document.getElementById( name );\n}\n\nfunction getUrlConfigHtml() {\n\tvar i, j, val,\n\t\tescaped, escapedTooltip,\n\t\tselection = false,\n\t\turlConfig = config.urlConfig,\n\t\turlConfigHtml = "";\n\n\tfor ( i = 0; i < urlConfig.length; i++ ) {\n\n\t\t// Options can be either strings or objects with nonempty "id" properties\n\t\tval = config.urlConfig[ i ];\n\t\tif ( typeof val === "string" ) {\n\t\t\tval = {\n\t\t\t\tid: val,\n\t\t\t\tlabel: val\n\t\t\t};\n\t\t}\n\n\t\tescaped = escapeText( val.id );\n\t\tescapedTooltip = escapeText( val.tooltip );\n\n\t\tif ( !val.value || typeof val.value === "string" ) {\n\t\t\turlConfigHtml += "<input id=\'qunit-urlconfig-" + escaped +\n\t\t\t\t"\' name=\'" + escaped + "\' type=\'checkbox\'" +\n\t\t\t\t( val.value ? " value=\'" + escapeText( val.value ) + "\'" : "" ) +\n\t\t\t\t( config[ val.id ] ? " checked=\'checked\'" : "" ) +\n\t\t\t\t" title=\'" + escapedTooltip + "\' /><label for=\'qunit-urlconfig-" + escaped +\n\t\t\t\t"\' title=\'" + escapedTooltip + "\'>" + val.label + "</label>";\n\t\t} else {\n\t\t\turlConfigHtml += "<label for=\'qunit-urlconfig-" + escaped +\n\t\t\t\t"\' title=\'" + escapedTooltip + "\'>" + val.label +\n\t\t\t\t": </label><select id=\'qunit-urlconfig-" + escaped +\n\t\t\t\t"\' name=\'" + escaped + "\' title=\'" + escapedTooltip + "\'><option></option>";\n\n\t\t\tif ( QUnit.is( "array", val.value ) ) {\n\t\t\t\tfor ( j = 0; j < val.value.length; j++ ) {\n\t\t\t\t\tescaped = escapeText( val.value[ j ] );\n\t\t\t\t\turlConfigHtml += "<option value=\'" + escaped + "\'" +\n\t\t\t\t\t\t( config[ val.id ] === val.value[ j ] ?\n\t\t\t\t\t\t\t( selection = true ) && " selected=\'selected\'" : "" ) +\n\t\t\t\t\t\t">" + escaped + "</option>";\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( j in val.value ) {\n\t\t\t\t\tif ( hasOwn.call( val.value, j ) ) {\n\t\t\t\t\t\turlConfigHtml += "<option value=\'" + escapeText( j ) + "\'" +\n\t\t\t\t\t\t\t( config[ val.id ] === j ?\n\t\t\t\t\t\t\t\t( selection = true ) && " selected=\'selected\'" : "" ) +\n\t\t\t\t\t\t\t">" + escapeText( val.value[ j ] ) + "</option>";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( config[ val.id ] && !selection ) {\n\t\t\t\tescaped = escapeText( config[ val.id ] );\n\t\t\t\turlConfigHtml += "<option value=\'" + escaped +\n\t\t\t\t\t"\' selected=\'selected\' disabled=\'disabled\'>" + escaped + "</option>";\n\t\t\t}\n\t\t\turlConfigHtml += "</select>";\n\t\t}\n\t}\n\n\treturn urlConfigHtml;\n}\n\n// Handle "click" events on toolbar checkboxes and "change" for select menus.\n// Updates the URL with the new state of `config.urlConfig` values.\nfunction toolbarChanged() {\n\tvar updatedUrl, value, tests,\n\t\tfield = this,\n\t\tparams = {};\n\n\t// Detect if field is a select menu or a checkbox\n\tif ( "selectedIndex" in field ) {\n\t\tvalue = field.options[ field.selectedIndex ].value || undefined;\n\t} else {\n\t\tvalue = field.checked ? ( field.defaultValue || true ) : undefined;\n\t}\n\n\tparams[ field.name ] = value;\n\tupdatedUrl = setUrl( params );\n\n\t// Check if we can apply the change without a page refresh\n\tif ( "hidepassed" === field.name && "replaceState" in window.history ) {\n\t\tQUnit.urlParams[ field.name ] = value;\n\t\tconfig[ field.name ] = value || false;\n\t\ttests = id( "qunit-tests" );\n\t\tif ( tests ) {\n\t\t\ttoggleClass( tests, "hidepass", value || false );\n\t\t}\n\t\twindow.history.replaceState( null, "", updatedUrl );\n\t} else {\n\t\twindow.location = updatedUrl;\n\t}\n}\n\nfunction setUrl( params ) {\n\tvar key, arrValue, i,\n\t\tquerystring = "?",\n\t\tlocation = window.location;\n\n\tparams = QUnit.extend( QUnit.extend( {}, QUnit.urlParams ), params );\n\n\tfor ( key in params ) {\n\n\t\t// Skip inherited or undefined properties\n\t\tif ( hasOwn.call( params, key ) && params[ key ] !== undefined ) {\n\n\t\t\t// Output a parameter for each value of this key (but usually just one)\n\t\t\tarrValue = [].concat( params[ key ] );\n\t\t\tfor ( i = 0; i < arrValue.length; i++ ) {\n\t\t\t\tquerystring += encodeURIComponent( key );\n\t\t\t\tif ( arrValue[ i ] !== true ) {\n\t\t\t\t\tquerystring += "=" + encodeURIComponent( arrValue[ i ] );\n\t\t\t\t}\n\t\t\t\tquerystring += "&";\n\t\t\t}\n\t\t}\n\t}\n\treturn location.protocol + "//" + location.host +\n\t\tlocation.pathname + querystring.slice( 0, -1 );\n}\n\nfunction applyUrlParams() {\n\tvar selectedModule,\n\t\tmodulesList = id( "qunit-modulefilter" ),\n\t\tfilter = id( "qunit-filter-input" ).value;\n\n\tselectedModule = modulesList ?\n\t\tdecodeURIComponent( modulesList.options[ modulesList.selectedIndex ].value ) :\n\t\tundefined;\n\n\twindow.location = setUrl( {\n\t\tmodule: ( selectedModule === "" ) ? undefined : selectedModule,\n\t\tfilter: ( filter === "" ) ? undefined : filter,\n\n\t\t// Remove moduleId and testId filters\n\t\tmoduleId: undefined,\n\t\ttestId: undefined\n\t} );\n}\n\nfunction toolbarUrlConfigContainer() {\n\tvar urlConfigContainer = document.createElement( "span" );\n\n\turlConfigContainer.innerHTML = getUrlConfigHtml();\n\taddClass( urlConfigContainer, "qunit-url-config" );\n\n\t// For oldIE support:\n\t// * Add handlers to the individual elements instead of the container\n\t// * Use "click" instead of "change" for checkboxes\n\taddEvents( urlConfigContainer.getElementsByTagName( "input" ), "click", toolbarChanged );\n\taddEvents( urlConfigContainer.getElementsByTagName( "select" ), "change", toolbarChanged );\n\n\treturn urlConfigContainer;\n}\n\nfunction toolbarLooseFilter() {\n\tvar filter = document.createElement( "form" ),\n\t\tlabel = document.createElement( "label" ),\n\t\tinput = document.createElement( "input" ),\n\t\tbutton = document.createElement( "button" );\n\n\taddClass( filter, "qunit-filter" );\n\n\tlabel.innerHTML = "Filter: ";\n\n\tinput.type = "text";\n\tinput.value = config.filter || "";\n\tinput.name = "filter";\n\tinput.id = "qunit-filter-input";\n\n\tbutton.innerHTML = "Go";\n\n\tlabel.appendChild( input );\n\n\tfilter.appendChild( label );\n\tfilter.appendChild( button );\n\taddEvent( filter, "submit", function( ev ) {\n\t\tapplyUrlParams();\n\n\t\tif ( ev && ev.preventDefault ) {\n\t\t\tev.preventDefault();\n\t\t}\n\n\t\treturn false;\n\t} );\n\n\treturn filter;\n}\n\nfunction toolbarModuleFilterHtml() {\n\tvar i,\n\t\tmoduleFilterHtml = "";\n\n\tif ( !modulesList.length ) {\n\t\treturn false;\n\t}\n\n\tmoduleFilterHtml += "<label for=\'qunit-modulefilter\'>Module: </label>" +\n\t\t"<select id=\'qunit-modulefilter\' name=\'modulefilter\'><option value=\'\' " +\n\t\t( QUnit.urlParams.module === undefined ? "selected=\'selected\'" : "" ) +\n\t\t">< All Modules ></option>";\n\n\tfor ( i = 0; i < modulesList.length; i++ ) {\n\t\tmoduleFilterHtml += "<option value=\'" +\n\t\t\tescapeText( encodeURIComponent( modulesList[ i ] ) ) + "\' " +\n\t\t\t( QUnit.urlParams.module === modulesList[ i ] ? "selected=\'selected\'" : "" ) +\n\t\t\t">" + escapeText( modulesList[ i ] ) + "</option>";\n\t}\n\tmoduleFilterHtml += "</select>";\n\n\treturn moduleFilterHtml;\n}\n\nfunction toolbarModuleFilter() {\n\tvar toolbar = id( "qunit-testrunner-toolbar" ),\n\t\tmoduleFilter = document.createElement( "span" ),\n\t\tmoduleFilterHtml = toolbarModuleFilterHtml();\n\n\tif ( !toolbar || !moduleFilterHtml ) {\n\t\treturn false;\n\t}\n\n\tmoduleFilter.setAttribute( "id", "qunit-modulefilter-container" );\n\tmoduleFilter.innerHTML = moduleFilterHtml;\n\n\taddEvent( moduleFilter.lastChild, "change", applyUrlParams );\n\n\ttoolbar.appendChild( moduleFilter );\n}\n\nfunction appendToolbar() {\n\tvar toolbar = id( "qunit-testrunner-toolbar" );\n\n\tif ( toolbar ) {\n\t\ttoolbar.appendChild( toolbarUrlConfigContainer() );\n\t\ttoolbar.appendChild( toolbarLooseFilter() );\n\t\ttoolbarModuleFilter();\n\t}\n}\n\nfunction appendHeader() {\n\tvar header = id( "qunit-header" );\n\n\tif ( header ) {\n\t\theader.innerHTML = "<a href=\'" + escapeText( unfilteredUrl ) + "\'>" + header.innerHTML +\n\t\t\t"</a> ";\n\t}\n}\n\nfunction appendBanner() {\n\tvar banner = id( "qunit-banner" );\n\n\tif ( banner ) {\n\t\tbanner.className = "";\n\t}\n}\n\nfunction appendTestResults() {\n\tvar tests = id( "qunit-tests" ),\n\t\tresult = id( "qunit-testresult" );\n\n\tif ( result ) {\n\t\tresult.parentNode.removeChild( result );\n\t}\n\n\tif ( tests ) {\n\t\ttests.innerHTML = "";\n\t\tresult = document.createElement( "p" );\n\t\tresult.id = "qunit-testresult";\n\t\tresult.className = "result";\n\t\ttests.parentNode.insertBefore( result, tests );\n\t\tresult.innerHTML = "Running...<br />&#160;";\n\t}\n}\n\nfunction storeFixture() {\n\tvar fixture = id( "qunit-fixture" );\n\tif ( fixture ) {\n\t\tconfig.fixture = fixture.innerHTML;\n\t}\n}\n\nfunction appendFilteredTest() {\n\tvar testId = QUnit.config.testId;\n\tif ( !testId || testId.length <= 0 ) {\n\t\treturn "";\n\t}\n\treturn "<div id=\'qunit-filteredTest\'>Rerunning selected tests: " +\n\t\tescapeText( testId.join( ", " ) ) +\n\t\t" <a id=\'qunit-clearFilter\' href=\'" +\n\t\tescapeText( unfilteredUrl ) +\n\t\t"\'>Run all tests</a></div>";\n}\n\nfunction appendUserAgent() {\n\tvar userAgent = id( "qunit-userAgent" );\n\n\tif ( userAgent ) {\n\t\tuserAgent.innerHTML = "";\n\t\tuserAgent.appendChild(\n\t\t\tdocument.createTextNode(\n\t\t\t\t"QUnit " + QUnit.version + "; " + navigator.userAgent\n\t\t\t)\n\t\t);\n\t}\n}\n\nfunction appendInterface() {\n\tvar qunit = id( "qunit" );\n\n\tif ( qunit ) {\n\t\tqunit.innerHTML =\n\t\t\t"<h1 id=\'qunit-header\'>" + escapeText( document.title ) + "</h1>" +\n\t\t\t"<h2 id=\'qunit-banner\'></h2>" +\n\t\t\t"<div id=\'qunit-testrunner-toolbar\'></div>" +\n\t\t\tappendFilteredTest() +\n\t\t\t"<h2 id=\'qunit-userAgent\'></h2>" +\n\t\t\t"<ol id=\'qunit-tests\'></ol>";\n\t}\n\n\tappendHeader();\n\tappendBanner();\n\tappendTestResults();\n\tappendUserAgent();\n\tappendToolbar();\n}\n\nfunction appendTestsList( modules ) {\n\tvar i, l, x, z, test, moduleObj;\n\n\tfor ( i = 0, l = modules.length; i < l; i++ ) {\n\t\tmoduleObj = modules[ i ];\n\n\t\tfor ( x = 0, z = moduleObj.tests.length; x < z; x++ ) {\n\t\t\ttest = moduleObj.tests[ x ];\n\n\t\t\tappendTest( test.name, test.testId, moduleObj.name );\n\t\t}\n\t}\n}\n\nfunction appendTest( name, testId, moduleName ) {\n\tvar title, rerunTrigger, testBlock, assertList,\n\t\ttests = id( "qunit-tests" );\n\n\tif ( !tests ) {\n\t\treturn;\n\t}\n\n\ttitle = document.createElement( "strong" );\n\ttitle.innerHTML = getNameHtml( name, moduleName );\n\n\trerunTrigger = document.createElement( "a" );\n\trerunTrigger.innerHTML = "Rerun";\n\trerunTrigger.href = setUrl( { testId: testId } );\n\n\ttestBlock = document.createElement( "li" );\n\ttestBlock.appendChild( title );\n\ttestBlock.appendChild( rerunTrigger );\n\ttestBlock.id = "qunit-test-output-" + testId;\n\n\tassertList = document.createElement( "ol" );\n\tassertList.className = "qunit-assert-list";\n\n\ttestBlock.appendChild( assertList );\n\n\ttests.appendChild( testBlock );\n}\n\n// HTML Reporter initialization and load\nQUnit.begin( function( details ) {\n\tvar i, moduleObj, tests;\n\n\t// Sort modules by name for the picker\n\tfor ( i = 0; i < details.modules.length; i++ ) {\n\t\tmoduleObj = details.modules[ i ];\n\t\tif ( moduleObj.name ) {\n\t\t\tmodulesList.push( moduleObj.name );\n\t\t}\n\t}\n\tmodulesList.sort( function( a, b ) {\n\t\treturn a.localeCompare( b );\n\t} );\n\n\t// Capture fixture HTML from the page\n\tstoreFixture();\n\n\t// Initialize QUnit elements\n\tappendInterface();\n\tappendTestsList( details.modules );\n\ttests = id( "qunit-tests" );\n\tif ( tests && config.hidepassed ) {\n\t\taddClass( tests, "hidepass" );\n\t}\n} );\n\nQUnit.done( function( details ) {\n\tvar i, key,\n\t\tbanner = id( "qunit-banner" ),\n\t\ttests = id( "qunit-tests" ),\n\t\thtml = [\n\t\t\t"Tests completed in ",\n\t\t\tdetails.runtime,\n\t\t\t" milliseconds.<br />",\n\t\t\t"<span class=\'passed\'>",\n\t\t\tdetails.passed,\n\t\t\t"</span> assertions of <span class=\'total\'>",\n\t\t\tdetails.total,\n\t\t\t"</span> passed, <span class=\'failed\'>",\n\t\t\tdetails.failed,\n\t\t\t"</span> failed."\n\t\t].join( "" );\n\n\tif ( banner ) {\n\t\tbanner.className = details.failed ? "qunit-fail" : "qunit-pass";\n\t}\n\n\tif ( tests ) {\n\t\tid( "qunit-testresult" ).innerHTML = html;\n\t}\n\n\tif ( config.altertitle && document.title ) {\n\n\t\t// Show \u2716 for good, \u2714 for bad suite result in title\n\t\t// use escape sequences in case file gets loaded with non-utf-8-charset\n\t\tdocument.title = [\n\t\t\t( details.failed ? "\\u2716" : "\\u2714" ),\n\t\t\tdocument.title.replace( /^[\\u2714\\u2716] /i, "" )\n\t\t].join( " " );\n\t}\n\n\t// Clear own sessionStorage items if all tests passed\n\tif ( config.reorder && defined.sessionStorage && details.failed === 0 ) {\n\t\tfor ( i = 0; i < sessionStorage.length; i++ ) {\n\t\t\tkey = sessionStorage.key( i++ );\n\t\t\tif ( key.indexOf( "qunit-test-" ) === 0 ) {\n\t\t\t\tsessionStorage.removeItem( key );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Scroll back to top to show results\n\tif ( config.scrolltop && window.scrollTo ) {\n\t\twindow.scrollTo( 0, 0 );\n\t}\n} );\n\nfunction getNameHtml( name, module ) {\n\tvar nameHtml = "";\n\n\tif ( module ) {\n\t\tnameHtml = "<span class=\'module-name\'>" + escapeText( module ) + "</span>: ";\n\t}\n\n\tnameHtml += "<span class=\'test-name\'>" + escapeText( name ) + "</span>";\n\n\treturn nameHtml;\n}\n\nQUnit.testStart( function( details ) {\n\tvar running, testBlock, bad;\n\n\ttestBlock = id( "qunit-test-output-" + details.testId );\n\tif ( testBlock ) {\n\t\ttestBlock.className = "running";\n\t} else {\n\n\t\t// Report later registered tests\n\t\tappendTest( details.name, details.testId, details.module );\n\t}\n\n\trunning = id( "qunit-testresult" );\n\tif ( running ) {\n\t\tbad = QUnit.config.reorder && defined.sessionStorage &&\n\t\t\t+sessionStorage.getItem( "qunit-test-" + details.module + "-" + details.name );\n\n\t\trunning.innerHTML = ( bad ?\n\t\t\t"Rerunning previously failed test: <br />" :\n\t\t\t"Running: <br />" ) +\n\t\t\tgetNameHtml( details.name, details.module );\n\t}\n\n} );\n\nfunction stripHtml( string ) {\n\n\t// Strip tags, html entity and whitespaces\n\treturn string.replace( /<\\/?[^>]+(>|$)/g, "" ).replace( /\\&quot;/g, "" ).replace( /\\s+/g, "" );\n}\n\nQUnit.log( function( details ) {\n\tvar assertList, assertLi,\n\t\tmessage, expected, actual, diff,\n\t\tshowDiff = false,\n\t\ttestItem = id( "qunit-test-output-" + details.testId );\n\n\tif ( !testItem ) {\n\t\treturn;\n\t}\n\n\tmessage = escapeText( details.message ) || ( details.result ? "okay" : "failed" );\n\tmessage = "<span class=\'test-message\'>" + message + "</span>";\n\tmessage += "<span class=\'runtime\'>@ " + details.runtime + " ms</span>";\n\n\t// The pushFailure doesn\'t provide details.expected\n\t// when it calls, it\'s implicit to also not show expected and diff stuff\n\t// Also, we need to check details.expected existence, as it can exist and be undefined\n\tif ( !details.result && hasOwn.call( details, "expected" ) ) {\n\t\tif ( details.negative ) {\n\t\t\texpected = "NOT " + QUnit.dump.parse( details.expected );\n\t\t} else {\n\t\t\texpected = QUnit.dump.parse( details.expected );\n\t\t}\n\n\t\tactual = QUnit.dump.parse( details.actual );\n\t\tmessage += "<table><tr class=\'test-expected\'><th>Expected: </th><td><pre>" +\n\t\t\tescapeText( expected ) +\n\t\t\t"</pre></td></tr>";\n\n\t\tif ( actual !== expected ) {\n\n\t\t\tmessage += "<tr class=\'test-actual\'><th>Result: </th><td><pre>" +\n\t\t\t\tescapeText( actual ) + "</pre></td></tr>";\n\n\t\t\t// Don\'t show diff if actual or expected are booleans\n\t\t\tif ( !( /^(true|false)$/.test( actual ) ) &&\n\t\t\t\t\t!( /^(true|false)$/.test( expected ) ) ) {\n\t\t\t\tdiff = QUnit.diff( expected, actual );\n\t\t\t\tshowDiff = stripHtml( diff ).length !==\n\t\t\t\t\tstripHtml( expected ).length +\n\t\t\t\t\tstripHtml( actual ).length;\n\t\t\t}\n\n\t\t\t// Don\'t show diff if expected and actual are totally different\n\t\t\tif ( showDiff ) {\n\t\t\t\tmessage += "<tr class=\'test-diff\'><th>Diff: </th><td><pre>" +\n\t\t\t\t\tdiff + "</pre></td></tr>";\n\t\t\t}\n\t\t} else if ( expected.indexOf( "[object Array]" ) !== -1 ||\n\t\t\t\texpected.indexOf( "[object Object]" ) !== -1 ) {\n\t\t\tmessage += "<tr class=\'test-message\'><th>Message: </th><td>" +\n\t\t\t\t"Diff suppressed as the depth of object is more than current max depth (" +\n\t\t\t\tQUnit.config.maxDepth + ").<p>Hint: Use <code>QUnit.dump.maxDepth</code> to " +\n\t\t\t\t" run with a higher max depth or <a href=\'" +\n\t\t\t\tescapeText( setUrl( { maxDepth: -1 } ) ) + "\'>" +\n\t\t\t\t"Rerun</a> without max depth.</p></td></tr>";\n\t\t} else {\n\t\t\tmessage += "<tr class=\'test-message\'><th>Message: </th><td>" +\n\t\t\t\t"Diff suppressed as the expected and actual results have an equivalent" +\n\t\t\t\t" serialization</td></tr>";\n\t\t}\n\n\t\tif ( details.source ) {\n\t\t\tmessage += "<tr class=\'test-source\'><th>Source: </th><td><pre>" +\n\t\t\t\tescapeText( details.source ) + "</pre></td></tr>";\n\t\t}\n\n\t\tmessage += "</table>";\n\n\t// This occurs when pushFailure is set and we have an extracted stack trace\n\t} else if ( !details.result && details.source ) {\n\t\tmessage += "<table>" +\n\t\t\t"<tr class=\'test-source\'><th>Source: </th><td><pre>" +\n\t\t\tescapeText( details.source ) + "</pre></td></tr>" +\n\t\t\t"</table>";\n\t}\n\n\tassertList = testItem.getElementsByTagName( "ol" )[ 0 ];\n\n\tassertLi = document.createElement( "li" );\n\tassertLi.className = details.result ? "pass" : "fail";\n\tassertLi.innerHTML = message;\n\tassertList.appendChild( assertLi );\n} );\n\nQUnit.testDone( function( details ) {\n\tvar testTitle, time, testItem, assertList,\n\t\tgood, bad, testCounts, skipped, sourceName,\n\t\ttests = id( "qunit-tests" );\n\n\tif ( !tests ) {\n\t\treturn;\n\t}\n\n\ttestItem = id( "qunit-test-output-" + details.testId );\n\n\tassertList = testItem.getElementsByTagName( "ol" )[ 0 ];\n\n\tgood = details.passed;\n\tbad = details.failed;\n\n\t// Store result when possible\n\tif ( config.reorder && defined.sessionStorage ) {\n\t\tif ( bad ) {\n\t\t\tsessionStorage.setItem( "qunit-test-" + details.module + "-" + details.name, bad );\n\t\t} else {\n\t\t\tsessionStorage.removeItem( "qunit-test-" + details.module + "-" + details.name );\n\t\t}\n\t}\n\n\tif ( bad === 0 ) {\n\n\t\t// Collapse the passing tests\n\t\taddClass( assertList, "qunit-collapsed" );\n\t} else if ( bad && config.collapse && !collapseNext ) {\n\n\t\t// Skip collapsing the first failing test\n\t\tcollapseNext = true;\n\t} else {\n\n\t\t// Collapse remaining tests\n\t\taddClass( assertList, "qunit-collapsed" );\n\t}\n\n\t// The testItem.firstChild is the test name\n\ttestTitle = testItem.firstChild;\n\n\ttestCounts = bad ?\n\t\t"<b class=\'failed\'>" + bad + "</b>, " + "<b class=\'passed\'>" + good + "</b>, " :\n\t\t"";\n\n\ttestTitle.innerHTML += " <b class=\'counts\'>(" + testCounts +\n\t\tdetails.assertions.length + ")</b>";\n\n\tif ( details.skipped ) {\n\t\ttestItem.className = "skipped";\n\t\tskipped = document.createElement( "em" );\n\t\tskipped.className = "qunit-skipped-label";\n\t\tskipped.innerHTML = "skipped";\n\t\ttestItem.insertBefore( skipped, testTitle );\n\t} else {\n\t\taddEvent( testTitle, "click", function() {\n\t\t\ttoggleClass( assertList, "qunit-collapsed" );\n\t\t} );\n\n\t\ttestItem.className = bad ? "fail" : "pass";\n\n\t\ttime = document.createElement( "span" );\n\t\ttime.className = "runtime";\n\t\ttime.innerHTML = details.runtime + " ms";\n\t\ttestItem.insertBefore( time, assertList );\n\t}\n\n\t// Show the source of the test when showing assertions\n\tif ( details.source ) {\n\t\tsourceName = document.createElement( "p" );\n\t\tsourceName.innerHTML = "<strong>Source: </strong>" + details.source;\n\t\taddClass( sourceName, "qunit-source" );\n\t\tif ( bad === 0 ) {\n\t\t\taddClass( sourceName, "qunit-collapsed" );\n\t\t}\n\t\taddEvent( testTitle, "click", function() {\n\t\t\ttoggleClass( sourceName, "qunit-collapsed" );\n\t\t} );\n\t\ttestItem.appendChild( sourceName );\n\t}\n} );\n\n// Avoid readyState issue with phantomjs\n// Ref: #818\nvar notPhantom = ( function( p ) {\n\treturn !( p && p.version && p.version.major > 0 );\n} )( window.phantom );\n\nif ( notPhantom && document.readyState === "complete" ) {\n\tQUnit.load();\n} else {\n\taddEvent( window, "load", QUnit.load );\n}\n\n/*\n * This file is a modified version of google-diff-match-patch\'s JavaScript implementation\n * (https://code.google.com/p/google-diff-match-patch/source/browse/trunk/javascript/diff_match_patch_uncompressed.js),\n * modifications are licensed as more fully set forth in LICENSE.txt.\n *\n * The original source of google-diff-match-patch is attributable and licensed as follows:\n *\n * Copyright 2006 Google Inc.\n * https://code.google.com/p/google-diff-match-patch/\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * More Info:\n *  https://code.google.com/p/google-diff-match-patch/\n *\n * Usage: QUnit.diff(expected, actual)\n *\n */\nQUnit.diff = ( function() {\n\tfunction DiffMatchPatch() {\n\t}\n\n\t//  DIFF FUNCTIONS\n\n\t/**\n\t * The data structure representing a diff is an array of tuples:\n\t * [[DIFF_DELETE, \'Hello\'], [DIFF_INSERT, \'Goodbye\'], [DIFF_EQUAL, \' world.\']]\n\t * which means: delete \'Hello\', add \'Goodbye\' and keep \' world.\'\n\t */\n\tvar DIFF_DELETE = -1,\n\t\tDIFF_INSERT = 1,\n\t\tDIFF_EQUAL = 0;\n\n\t/**\n\t * Find the differences between two texts.  Simplifies the problem by stripping\n\t * any common prefix or suffix off the texts before diffing.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {boolean=} optChecklines Optional speedup flag. If present and false,\n\t *     then don\'t run a line-level diff first to identify the changed areas.\n\t *     Defaults to true, which does a faster, slightly less optimal diff.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t */\n\tDiffMatchPatch.prototype.DiffMain = function( text1, text2, optChecklines ) {\n\t\tvar deadline, checklines, commonlength,\n\t\t\tcommonprefix, commonsuffix, diffs;\n\n\t\t// The diff must be complete in up to 1 second.\n\t\tdeadline = ( new Date() ).getTime() + 1000;\n\n\t\t// Check for null inputs.\n\t\tif ( text1 === null || text2 === null ) {\n\t\t\tthrow new Error( "Null input. (DiffMain)" );\n\t\t}\n\n\t\t// Check for equality (speedup).\n\t\tif ( text1 === text2 ) {\n\t\t\tif ( text1 ) {\n\t\t\t\treturn [\n\t\t\t\t\t[ DIFF_EQUAL, text1 ]\n\t\t\t\t];\n\t\t\t}\n\t\t\treturn [];\n\t\t}\n\n\t\tif ( typeof optChecklines === "undefined" ) {\n\t\t\toptChecklines = true;\n\t\t}\n\n\t\tchecklines = optChecklines;\n\n\t\t// Trim off common prefix (speedup).\n\t\tcommonlength = this.diffCommonPrefix( text1, text2 );\n\t\tcommonprefix = text1.substring( 0, commonlength );\n\t\ttext1 = text1.substring( commonlength );\n\t\ttext2 = text2.substring( commonlength );\n\n\t\t// Trim off common suffix (speedup).\n\t\tcommonlength = this.diffCommonSuffix( text1, text2 );\n\t\tcommonsuffix = text1.substring( text1.length - commonlength );\n\t\ttext1 = text1.substring( 0, text1.length - commonlength );\n\t\ttext2 = text2.substring( 0, text2.length - commonlength );\n\n\t\t// Compute the diff on the middle block.\n\t\tdiffs = this.diffCompute( text1, text2, checklines, deadline );\n\n\t\t// Restore the prefix and suffix.\n\t\tif ( commonprefix ) {\n\t\t\tdiffs.unshift( [ DIFF_EQUAL, commonprefix ] );\n\t\t}\n\t\tif ( commonsuffix ) {\n\t\t\tdiffs.push( [ DIFF_EQUAL, commonsuffix ] );\n\t\t}\n\t\tthis.diffCleanupMerge( diffs );\n\t\treturn diffs;\n\t};\n\n\t/**\n\t * Reduce the number of edits by eliminating operationally trivial equalities.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t */\n\tDiffMatchPatch.prototype.diffCleanupEfficiency = function( diffs ) {\n\t\tvar changes, equalities, equalitiesLength, lastequality,\n\t\t\tpointer, preIns, preDel, postIns, postDel;\n\t\tchanges = false;\n\t\tequalities = []; // Stack of indices where equalities are found.\n\t\tequalitiesLength = 0; // Keeping our own length var is faster in JS.\n\t\t/** @type {?string} */\n\t\tlastequality = null;\n\n\t\t// Always equal to diffs[equalities[equalitiesLength - 1]][1]\n\t\tpointer = 0; // Index of current position.\n\n\t\t// Is there an insertion operation before the last equality.\n\t\tpreIns = false;\n\n\t\t// Is there a deletion operation before the last equality.\n\t\tpreDel = false;\n\n\t\t// Is there an insertion operation after the last equality.\n\t\tpostIns = false;\n\n\t\t// Is there a deletion operation after the last equality.\n\t\tpostDel = false;\n\t\twhile ( pointer < diffs.length ) {\n\n\t\t\t// Equality found.\n\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_EQUAL ) {\n\t\t\t\tif ( diffs[ pointer ][ 1 ].length < 4 && ( postIns || postDel ) ) {\n\n\t\t\t\t\t// Candidate found.\n\t\t\t\t\tequalities[ equalitiesLength++ ] = pointer;\n\t\t\t\t\tpreIns = postIns;\n\t\t\t\t\tpreDel = postDel;\n\t\t\t\t\tlastequality = diffs[ pointer ][ 1 ];\n\t\t\t\t} else {\n\n\t\t\t\t\t// Not a candidate, and can never become one.\n\t\t\t\t\tequalitiesLength = 0;\n\t\t\t\t\tlastequality = null;\n\t\t\t\t}\n\t\t\t\tpostIns = postDel = false;\n\n\t\t\t// An insertion or deletion.\n\t\t\t} else {\n\n\t\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_DELETE ) {\n\t\t\t\t\tpostDel = true;\n\t\t\t\t} else {\n\t\t\t\t\tpostIns = true;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Five types to be split:\n\t\t\t\t * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n\t\t\t\t * <ins>A</ins>X<ins>C</ins><del>D</del>\n\t\t\t\t * <ins>A</ins><del>B</del>X<ins>C</ins>\n\t\t\t\t * <ins>A</del>X<ins>C</ins><del>D</del>\n\t\t\t\t * <ins>A</ins><del>B</del>X<del>C</del>\n\t\t\t\t */\n\t\t\t\tif ( lastequality && ( ( preIns && preDel && postIns && postDel ) ||\n\t\t\t\t\t\t( ( lastequality.length < 2 ) &&\n\t\t\t\t\t\t( preIns + preDel + postIns + postDel ) === 3 ) ) ) {\n\n\t\t\t\t\t// Duplicate record.\n\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\tequalities[ equalitiesLength - 1 ],\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t[ DIFF_DELETE, lastequality ]\n\t\t\t\t\t);\n\n\t\t\t\t\t// Change second copy to insert.\n\t\t\t\t\tdiffs[ equalities[ equalitiesLength - 1 ] + 1 ][ 0 ] = DIFF_INSERT;\n\t\t\t\t\tequalitiesLength--; // Throw away the equality we just deleted;\n\t\t\t\t\tlastequality = null;\n\t\t\t\t\tif ( preIns && preDel ) {\n\n\t\t\t\t\t\t// No changes made which could affect previous entry, keep going.\n\t\t\t\t\t\tpostIns = postDel = true;\n\t\t\t\t\t\tequalitiesLength = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tequalitiesLength--; // Throw away the previous equality.\n\t\t\t\t\t\tpointer = equalitiesLength > 0 ? equalities[ equalitiesLength - 1 ] : -1;\n\t\t\t\t\t\tpostIns = postDel = false;\n\t\t\t\t\t}\n\t\t\t\t\tchanges = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\n\t\tif ( changes ) {\n\t\t\tthis.diffCleanupMerge( diffs );\n\t\t}\n\t};\n\n\t/**\n\t * Convert a diff array into a pretty HTML report.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t * @param {integer} string to be beautified.\n\t * @return {string} HTML representation.\n\t */\n\tDiffMatchPatch.prototype.diffPrettyHtml = function( diffs ) {\n\t\tvar op, data, x,\n\t\t\thtml = [];\n\t\tfor ( x = 0; x < diffs.length; x++ ) {\n\t\t\top = diffs[ x ][ 0 ]; // Operation (insert, delete, equal)\n\t\t\tdata = diffs[ x ][ 1 ]; // Text of change.\n\t\t\tswitch ( op ) {\n\t\t\tcase DIFF_INSERT:\n\t\t\t\thtml[ x ] = "<ins>" + escapeText( data ) + "</ins>";\n\t\t\t\tbreak;\n\t\t\tcase DIFF_DELETE:\n\t\t\t\thtml[ x ] = "<del>" + escapeText( data ) + "</del>";\n\t\t\t\tbreak;\n\t\t\tcase DIFF_EQUAL:\n\t\t\t\thtml[ x ] = "<span>" + escapeText( data ) + "</span>";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn html.join( "" );\n\t};\n\n\t/**\n\t * Determine the common prefix of two strings.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {number} The number of characters common to the start of each\n\t *     string.\n\t */\n\tDiffMatchPatch.prototype.diffCommonPrefix = function( text1, text2 ) {\n\t\tvar pointermid, pointermax, pointermin, pointerstart;\n\n\t\t// Quick check for common null cases.\n\t\tif ( !text1 || !text2 || text1.charAt( 0 ) !== text2.charAt( 0 ) ) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Binary search.\n\t\t// Performance analysis: https://neil.fraser.name/news/2007/10/09/\n\t\tpointermin = 0;\n\t\tpointermax = Math.min( text1.length, text2.length );\n\t\tpointermid = pointermax;\n\t\tpointerstart = 0;\n\t\twhile ( pointermin < pointermid ) {\n\t\t\tif ( text1.substring( pointerstart, pointermid ) ===\n\t\t\t\t\ttext2.substring( pointerstart, pointermid ) ) {\n\t\t\t\tpointermin = pointermid;\n\t\t\t\tpointerstart = pointermin;\n\t\t\t} else {\n\t\t\t\tpointermax = pointermid;\n\t\t\t}\n\t\t\tpointermid = Math.floor( ( pointermax - pointermin ) / 2 + pointermin );\n\t\t}\n\t\treturn pointermid;\n\t};\n\n\t/**\n\t * Determine the common suffix of two strings.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {number} The number of characters common to the end of each string.\n\t */\n\tDiffMatchPatch.prototype.diffCommonSuffix = function( text1, text2 ) {\n\t\tvar pointermid, pointermax, pointermin, pointerend;\n\n\t\t// Quick check for common null cases.\n\t\tif ( !text1 ||\n\t\t\t\t!text2 ||\n\t\t\t\ttext1.charAt( text1.length - 1 ) !== text2.charAt( text2.length - 1 ) ) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Binary search.\n\t\t// Performance analysis: https://neil.fraser.name/news/2007/10/09/\n\t\tpointermin = 0;\n\t\tpointermax = Math.min( text1.length, text2.length );\n\t\tpointermid = pointermax;\n\t\tpointerend = 0;\n\t\twhile ( pointermin < pointermid ) {\n\t\t\tif ( text1.substring( text1.length - pointermid, text1.length - pointerend ) ===\n\t\t\t\t\ttext2.substring( text2.length - pointermid, text2.length - pointerend ) ) {\n\t\t\t\tpointermin = pointermid;\n\t\t\t\tpointerend = pointermin;\n\t\t\t} else {\n\t\t\t\tpointermax = pointermid;\n\t\t\t}\n\t\t\tpointermid = Math.floor( ( pointermax - pointermin ) / 2 + pointermin );\n\t\t}\n\t\treturn pointermid;\n\t};\n\n\t/**\n\t * Find the differences between two texts.  Assumes that the texts do not\n\t * have any common prefix or suffix.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {boolean} checklines Speedup flag.  If false, then don\'t run a\n\t *     line-level diff first to identify the changed areas.\n\t *     If true, then run a faster, slightly less optimal diff.\n\t * @param {number} deadline Time when the diff should be complete by.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffCompute = function( text1, text2, checklines, deadline ) {\n\t\tvar diffs, longtext, shorttext, i, hm,\n\t\t\ttext1A, text2A, text1B, text2B,\n\t\t\tmidCommon, diffsA, diffsB;\n\n\t\tif ( !text1 ) {\n\n\t\t\t// Just add some text (speedup).\n\t\t\treturn [\n\t\t\t\t[ DIFF_INSERT, text2 ]\n\t\t\t];\n\t\t}\n\n\t\tif ( !text2 ) {\n\n\t\t\t// Just delete some text (speedup).\n\t\t\treturn [\n\t\t\t\t[ DIFF_DELETE, text1 ]\n\t\t\t];\n\t\t}\n\n\t\tlongtext = text1.length > text2.length ? text1 : text2;\n\t\tshorttext = text1.length > text2.length ? text2 : text1;\n\t\ti = longtext.indexOf( shorttext );\n\t\tif ( i !== -1 ) {\n\n\t\t\t// Shorter text is inside the longer text (speedup).\n\t\t\tdiffs = [\n\t\t\t\t[ DIFF_INSERT, longtext.substring( 0, i ) ],\n\t\t\t\t[ DIFF_EQUAL, shorttext ],\n\t\t\t\t[ DIFF_INSERT, longtext.substring( i + shorttext.length ) ]\n\t\t\t];\n\n\t\t\t// Swap insertions for deletions if diff is reversed.\n\t\t\tif ( text1.length > text2.length ) {\n\t\t\t\tdiffs[ 0 ][ 0 ] = diffs[ 2 ][ 0 ] = DIFF_DELETE;\n\t\t\t}\n\t\t\treturn diffs;\n\t\t}\n\n\t\tif ( shorttext.length === 1 ) {\n\n\t\t\t// Single character string.\n\t\t\t// After the previous speedup, the character can\'t be an equality.\n\t\t\treturn [\n\t\t\t\t[ DIFF_DELETE, text1 ],\n\t\t\t\t[ DIFF_INSERT, text2 ]\n\t\t\t];\n\t\t}\n\n\t\t// Check to see if the problem can be split in two.\n\t\thm = this.diffHalfMatch( text1, text2 );\n\t\tif ( hm ) {\n\n\t\t\t// A half-match was found, sort out the return data.\n\t\t\ttext1A = hm[ 0 ];\n\t\t\ttext1B = hm[ 1 ];\n\t\t\ttext2A = hm[ 2 ];\n\t\t\ttext2B = hm[ 3 ];\n\t\t\tmidCommon = hm[ 4 ];\n\n\t\t\t// Send both pairs off for separate processing.\n\t\t\tdiffsA = this.DiffMain( text1A, text2A, checklines, deadline );\n\t\t\tdiffsB = this.DiffMain( text1B, text2B, checklines, deadline );\n\n\t\t\t// Merge the results.\n\t\t\treturn diffsA.concat( [\n\t\t\t\t[ DIFF_EQUAL, midCommon ]\n\t\t\t], diffsB );\n\t\t}\n\n\t\tif ( checklines && text1.length > 100 && text2.length > 100 ) {\n\t\t\treturn this.diffLineMode( text1, text2, deadline );\n\t\t}\n\n\t\treturn this.diffBisect( text1, text2, deadline );\n\t};\n\n\t/**\n\t * Do the two texts share a substring which is at least half the length of the\n\t * longer text?\n\t * This speedup can produce non-minimal diffs.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {Array.<string>} Five element Array, containing the prefix of\n\t *     text1, the suffix of text1, the prefix of text2, the suffix of\n\t *     text2 and the common middle.  Or null if there was no match.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffHalfMatch = function( text1, text2 ) {\n\t\tvar longtext, shorttext, dmp,\n\t\t\ttext1A, text2B, text2A, text1B, midCommon,\n\t\t\thm1, hm2, hm;\n\n\t\tlongtext = text1.length > text2.length ? text1 : text2;\n\t\tshorttext = text1.length > text2.length ? text2 : text1;\n\t\tif ( longtext.length < 4 || shorttext.length * 2 < longtext.length ) {\n\t\t\treturn null; // Pointless.\n\t\t}\n\t\tdmp = this; // \'this\' becomes \'window\' in a closure.\n\n\t\t/**\n\t\t * Does a substring of shorttext exist within longtext such that the substring\n\t\t * is at least half the length of longtext?\n\t\t * Closure, but does not reference any external variables.\n\t\t * @param {string} longtext Longer string.\n\t\t * @param {string} shorttext Shorter string.\n\t\t * @param {number} i Start index of quarter length substring within longtext.\n\t\t * @return {Array.<string>} Five element Array, containing the prefix of\n\t\t *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n\t\t *     of shorttext and the common middle.  Or null if there was no match.\n\t\t * @private\n\t\t */\n\t\tfunction diffHalfMatchI( longtext, shorttext, i ) {\n\t\t\tvar seed, j, bestCommon, prefixLength, suffixLength,\n\t\t\t\tbestLongtextA, bestLongtextB, bestShorttextA, bestShorttextB;\n\n\t\t\t// Start with a 1/4 length substring at position i as a seed.\n\t\t\tseed = longtext.substring( i, i + Math.floor( longtext.length / 4 ) );\n\t\t\tj = -1;\n\t\t\tbestCommon = "";\n\t\t\twhile ( ( j = shorttext.indexOf( seed, j + 1 ) ) !== -1 ) {\n\t\t\t\tprefixLength = dmp.diffCommonPrefix( longtext.substring( i ),\n\t\t\t\t\tshorttext.substring( j ) );\n\t\t\t\tsuffixLength = dmp.diffCommonSuffix( longtext.substring( 0, i ),\n\t\t\t\t\tshorttext.substring( 0, j ) );\n\t\t\t\tif ( bestCommon.length < suffixLength + prefixLength ) {\n\t\t\t\t\tbestCommon = shorttext.substring( j - suffixLength, j ) +\n\t\t\t\t\t\tshorttext.substring( j, j + prefixLength );\n\t\t\t\t\tbestLongtextA = longtext.substring( 0, i - suffixLength );\n\t\t\t\t\tbestLongtextB = longtext.substring( i + prefixLength );\n\t\t\t\t\tbestShorttextA = shorttext.substring( 0, j - suffixLength );\n\t\t\t\t\tbestShorttextB = shorttext.substring( j + prefixLength );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( bestCommon.length * 2 >= longtext.length ) {\n\t\t\t\treturn [ bestLongtextA, bestLongtextB,\n\t\t\t\t\tbestShorttextA, bestShorttextB, bestCommon\n\t\t\t\t];\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\t// First check if the second quarter is the seed for a half-match.\n\t\thm1 = diffHalfMatchI( longtext, shorttext,\n\t\t\tMath.ceil( longtext.length / 4 ) );\n\n\t\t// Check again based on the third quarter.\n\t\thm2 = diffHalfMatchI( longtext, shorttext,\n\t\t\tMath.ceil( longtext.length / 2 ) );\n\t\tif ( !hm1 && !hm2 ) {\n\t\t\treturn null;\n\t\t} else if ( !hm2 ) {\n\t\t\thm = hm1;\n\t\t} else if ( !hm1 ) {\n\t\t\thm = hm2;\n\t\t} else {\n\n\t\t\t// Both matched.  Select the longest.\n\t\t\thm = hm1[ 4 ].length > hm2[ 4 ].length ? hm1 : hm2;\n\t\t}\n\n\t\t// A half-match was found, sort out the return data.\n\t\ttext1A, text1B, text2A, text2B;\n\t\tif ( text1.length > text2.length ) {\n\t\t\ttext1A = hm[ 0 ];\n\t\t\ttext1B = hm[ 1 ];\n\t\t\ttext2A = hm[ 2 ];\n\t\t\ttext2B = hm[ 3 ];\n\t\t} else {\n\t\t\ttext2A = hm[ 0 ];\n\t\t\ttext2B = hm[ 1 ];\n\t\t\ttext1A = hm[ 2 ];\n\t\t\ttext1B = hm[ 3 ];\n\t\t}\n\t\tmidCommon = hm[ 4 ];\n\t\treturn [ text1A, text1B, text2A, text2B, midCommon ];\n\t};\n\n\t/**\n\t * Do a quick line-level diff on both strings, then rediff the parts for\n\t * greater accuracy.\n\t * This speedup can produce non-minimal diffs.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {number} deadline Time when the diff should be complete by.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffLineMode = function( text1, text2, deadline ) {\n\t\tvar a, diffs, linearray, pointer, countInsert,\n\t\t\tcountDelete, textInsert, textDelete, j;\n\n\t\t// Scan the text on a line-by-line basis first.\n\t\ta = this.diffLinesToChars( text1, text2 );\n\t\ttext1 = a.chars1;\n\t\ttext2 = a.chars2;\n\t\tlinearray = a.lineArray;\n\n\t\tdiffs = this.DiffMain( text1, text2, false, deadline );\n\n\t\t// Convert the diff back to original text.\n\t\tthis.diffCharsToLines( diffs, linearray );\n\n\t\t// Eliminate freak matches (e.g. blank lines)\n\t\tthis.diffCleanupSemantic( diffs );\n\n\t\t// Rediff any replacement blocks, this time character-by-character.\n\t\t// Add a dummy entry at the end.\n\t\tdiffs.push( [ DIFF_EQUAL, "" ] );\n\t\tpointer = 0;\n\t\tcountDelete = 0;\n\t\tcountInsert = 0;\n\t\ttextDelete = "";\n\t\ttextInsert = "";\n\t\twhile ( pointer < diffs.length ) {\n\t\t\tswitch ( diffs[ pointer ][ 0 ] ) {\n\t\t\tcase DIFF_INSERT:\n\t\t\t\tcountInsert++;\n\t\t\t\ttextInsert += diffs[ pointer ][ 1 ];\n\t\t\t\tbreak;\n\t\t\tcase DIFF_DELETE:\n\t\t\t\tcountDelete++;\n\t\t\t\ttextDelete += diffs[ pointer ][ 1 ];\n\t\t\t\tbreak;\n\t\t\tcase DIFF_EQUAL:\n\n\t\t\t\t// Upon reaching an equality, check for prior redundancies.\n\t\t\t\tif ( countDelete >= 1 && countInsert >= 1 ) {\n\n\t\t\t\t\t// Delete the offending records and add the merged ones.\n\t\t\t\t\tdiffs.splice( pointer - countDelete - countInsert,\n\t\t\t\t\t\tcountDelete + countInsert );\n\t\t\t\t\tpointer = pointer - countDelete - countInsert;\n\t\t\t\t\ta = this.DiffMain( textDelete, textInsert, false, deadline );\n\t\t\t\t\tfor ( j = a.length - 1; j >= 0; j-- ) {\n\t\t\t\t\t\tdiffs.splice( pointer, 0, a[ j ] );\n\t\t\t\t\t}\n\t\t\t\t\tpointer = pointer + a.length;\n\t\t\t\t}\n\t\t\t\tcountInsert = 0;\n\t\t\t\tcountDelete = 0;\n\t\t\t\ttextDelete = "";\n\t\t\t\ttextInsert = "";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\t\tdiffs.pop(); // Remove the dummy entry at the end.\n\n\t\treturn diffs;\n\t};\n\n\t/**\n\t * Find the \'middle snake\' of a diff, split the problem in two\n\t * and return the recursively constructed diff.\n\t * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {number} deadline Time at which to bail if not yet complete.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffBisect = function( text1, text2, deadline ) {\n\t\tvar text1Length, text2Length, maxD, vOffset, vLength,\n\t\t\tv1, v2, x, delta, front, k1start, k1end, k2start,\n\t\t\tk2end, k2Offset, k1Offset, x1, x2, y1, y2, d, k1, k2;\n\n\t\t// Cache the text lengths to prevent multiple calls.\n\t\ttext1Length = text1.length;\n\t\ttext2Length = text2.length;\n\t\tmaxD = Math.ceil( ( text1Length + text2Length ) / 2 );\n\t\tvOffset = maxD;\n\t\tvLength = 2 * maxD;\n\t\tv1 = new Array( vLength );\n\t\tv2 = new Array( vLength );\n\n\t\t// Setting all elements to -1 is faster in Chrome & Firefox than mixing\n\t\t// integers and undefined.\n\t\tfor ( x = 0; x < vLength; x++ ) {\n\t\t\tv1[ x ] = -1;\n\t\t\tv2[ x ] = -1;\n\t\t}\n\t\tv1[ vOffset + 1 ] = 0;\n\t\tv2[ vOffset + 1 ] = 0;\n\t\tdelta = text1Length - text2Length;\n\n\t\t// If the total number of characters is odd, then the front path will collide\n\t\t// with the reverse path.\n\t\tfront = ( delta % 2 !== 0 );\n\n\t\t// Offsets for start and end of k loop.\n\t\t// Prevents mapping of space beyond the grid.\n\t\tk1start = 0;\n\t\tk1end = 0;\n\t\tk2start = 0;\n\t\tk2end = 0;\n\t\tfor ( d = 0; d < maxD; d++ ) {\n\n\t\t\t// Bail out if deadline is reached.\n\t\t\tif ( ( new Date() ).getTime() > deadline ) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Walk the front path one step.\n\t\t\tfor ( k1 = -d + k1start; k1 <= d - k1end; k1 += 2 ) {\n\t\t\t\tk1Offset = vOffset + k1;\n\t\t\t\tif ( k1 === -d || ( k1 !== d && v1[ k1Offset - 1 ] < v1[ k1Offset + 1 ] ) ) {\n\t\t\t\t\tx1 = v1[ k1Offset + 1 ];\n\t\t\t\t} else {\n\t\t\t\t\tx1 = v1[ k1Offset - 1 ] + 1;\n\t\t\t\t}\n\t\t\t\ty1 = x1 - k1;\n\t\t\t\twhile ( x1 < text1Length && y1 < text2Length &&\n\t\t\t\t\ttext1.charAt( x1 ) === text2.charAt( y1 ) ) {\n\t\t\t\t\tx1++;\n\t\t\t\t\ty1++;\n\t\t\t\t}\n\t\t\t\tv1[ k1Offset ] = x1;\n\t\t\t\tif ( x1 > text1Length ) {\n\n\t\t\t\t\t// Ran off the right of the graph.\n\t\t\t\t\tk1end += 2;\n\t\t\t\t} else if ( y1 > text2Length ) {\n\n\t\t\t\t\t// Ran off the bottom of the graph.\n\t\t\t\t\tk1start += 2;\n\t\t\t\t} else if ( front ) {\n\t\t\t\t\tk2Offset = vOffset + delta - k1;\n\t\t\t\t\tif ( k2Offset >= 0 && k2Offset < vLength && v2[ k2Offset ] !== -1 ) {\n\n\t\t\t\t\t\t// Mirror x2 onto top-left coordinate system.\n\t\t\t\t\t\tx2 = text1Length - v2[ k2Offset ];\n\t\t\t\t\t\tif ( x1 >= x2 ) {\n\n\t\t\t\t\t\t\t// Overlap detected.\n\t\t\t\t\t\t\treturn this.diffBisectSplit( text1, text2, x1, y1, deadline );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Walk the reverse path one step.\n\t\t\tfor ( k2 = -d + k2start; k2 <= d - k2end; k2 += 2 ) {\n\t\t\t\tk2Offset = vOffset + k2;\n\t\t\t\tif ( k2 === -d || ( k2 !== d && v2[ k2Offset - 1 ] < v2[ k2Offset + 1 ] ) ) {\n\t\t\t\t\tx2 = v2[ k2Offset + 1 ];\n\t\t\t\t} else {\n\t\t\t\t\tx2 = v2[ k2Offset - 1 ] + 1;\n\t\t\t\t}\n\t\t\t\ty2 = x2 - k2;\n\t\t\t\twhile ( x2 < text1Length && y2 < text2Length &&\n\t\t\t\t\ttext1.charAt( text1Length - x2 - 1 ) ===\n\t\t\t\t\ttext2.charAt( text2Length - y2 - 1 ) ) {\n\t\t\t\t\tx2++;\n\t\t\t\t\ty2++;\n\t\t\t\t}\n\t\t\t\tv2[ k2Offset ] = x2;\n\t\t\t\tif ( x2 > text1Length ) {\n\n\t\t\t\t\t// Ran off the left of the graph.\n\t\t\t\t\tk2end += 2;\n\t\t\t\t} else if ( y2 > text2Length ) {\n\n\t\t\t\t\t// Ran off the top of the graph.\n\t\t\t\t\tk2start += 2;\n\t\t\t\t} else if ( !front ) {\n\t\t\t\t\tk1Offset = vOffset + delta - k2;\n\t\t\t\t\tif ( k1Offset >= 0 && k1Offset < vLength && v1[ k1Offset ] !== -1 ) {\n\t\t\t\t\t\tx1 = v1[ k1Offset ];\n\t\t\t\t\t\ty1 = vOffset + x1 - k1Offset;\n\n\t\t\t\t\t\t// Mirror x2 onto top-left coordinate system.\n\t\t\t\t\t\tx2 = text1Length - x2;\n\t\t\t\t\t\tif ( x1 >= x2 ) {\n\n\t\t\t\t\t\t\t// Overlap detected.\n\t\t\t\t\t\t\treturn this.diffBisectSplit( text1, text2, x1, y1, deadline );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Diff took too long and hit the deadline or\n\t\t// number of diffs equals number of characters, no commonality at all.\n\t\treturn [\n\t\t\t[ DIFF_DELETE, text1 ],\n\t\t\t[ DIFF_INSERT, text2 ]\n\t\t];\n\t};\n\n\t/**\n\t * Given the location of the \'middle snake\', split the diff in two parts\n\t * and recurse.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {number} x Index of split point in text1.\n\t * @param {number} y Index of split point in text2.\n\t * @param {number} deadline Time at which to bail if not yet complete.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffBisectSplit = function( text1, text2, x, y, deadline ) {\n\t\tvar text1a, text1b, text2a, text2b, diffs, diffsb;\n\t\ttext1a = text1.substring( 0, x );\n\t\ttext2a = text2.substring( 0, y );\n\t\ttext1b = text1.substring( x );\n\t\ttext2b = text2.substring( y );\n\n\t\t// Compute both diffs serially.\n\t\tdiffs = this.DiffMain( text1a, text2a, false, deadline );\n\t\tdiffsb = this.DiffMain( text1b, text2b, false, deadline );\n\n\t\treturn diffs.concat( diffsb );\n\t};\n\n\t/**\n\t * Reduce the number of edits by eliminating semantically trivial equalities.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t */\n\tDiffMatchPatch.prototype.diffCleanupSemantic = function( diffs ) {\n\t\tvar changes, equalities, equalitiesLength, lastequality,\n\t\t\tpointer, lengthInsertions2, lengthDeletions2, lengthInsertions1,\n\t\t\tlengthDeletions1, deletion, insertion, overlapLength1, overlapLength2;\n\t\tchanges = false;\n\t\tequalities = []; // Stack of indices where equalities are found.\n\t\tequalitiesLength = 0; // Keeping our own length var is faster in JS.\n\t\t/** @type {?string} */\n\t\tlastequality = null;\n\n\t\t// Always equal to diffs[equalities[equalitiesLength - 1]][1]\n\t\tpointer = 0; // Index of current position.\n\n\t\t// Number of characters that changed prior to the equality.\n\t\tlengthInsertions1 = 0;\n\t\tlengthDeletions1 = 0;\n\n\t\t// Number of characters that changed after the equality.\n\t\tlengthInsertions2 = 0;\n\t\tlengthDeletions2 = 0;\n\t\twhile ( pointer < diffs.length ) {\n\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_EQUAL ) { // Equality found.\n\t\t\t\tequalities[ equalitiesLength++ ] = pointer;\n\t\t\t\tlengthInsertions1 = lengthInsertions2;\n\t\t\t\tlengthDeletions1 = lengthDeletions2;\n\t\t\t\tlengthInsertions2 = 0;\n\t\t\t\tlengthDeletions2 = 0;\n\t\t\t\tlastequality = diffs[ pointer ][ 1 ];\n\t\t\t} else { // An insertion or deletion.\n\t\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_INSERT ) {\n\t\t\t\t\tlengthInsertions2 += diffs[ pointer ][ 1 ].length;\n\t\t\t\t} else {\n\t\t\t\t\tlengthDeletions2 += diffs[ pointer ][ 1 ].length;\n\t\t\t\t}\n\n\t\t\t\t// Eliminate an equality that is smaller or equal to the edits on both\n\t\t\t\t// sides of it.\n\t\t\t\tif ( lastequality && ( lastequality.length <=\n\t\t\t\t\t\tMath.max( lengthInsertions1, lengthDeletions1 ) ) &&\n\t\t\t\t\t\t( lastequality.length <= Math.max( lengthInsertions2,\n\t\t\t\t\t\t\tlengthDeletions2 ) ) ) {\n\n\t\t\t\t\t// Duplicate record.\n\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\tequalities[ equalitiesLength - 1 ],\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t[ DIFF_DELETE, lastequality ]\n\t\t\t\t\t);\n\n\t\t\t\t\t// Change second copy to insert.\n\t\t\t\t\tdiffs[ equalities[ equalitiesLength - 1 ] + 1 ][ 0 ] = DIFF_INSERT;\n\n\t\t\t\t\t// Throw away the equality we just deleted.\n\t\t\t\t\tequalitiesLength--;\n\n\t\t\t\t\t// Throw away the previous equality (it needs to be reevaluated).\n\t\t\t\t\tequalitiesLength--;\n\t\t\t\t\tpointer = equalitiesLength > 0 ? equalities[ equalitiesLength - 1 ] : -1;\n\n\t\t\t\t\t// Reset the counters.\n\t\t\t\t\tlengthInsertions1 = 0;\n\t\t\t\t\tlengthDeletions1 = 0;\n\t\t\t\t\tlengthInsertions2 = 0;\n\t\t\t\t\tlengthDeletions2 = 0;\n\t\t\t\t\tlastequality = null;\n\t\t\t\t\tchanges = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\n\t\t// Normalize the diff.\n\t\tif ( changes ) {\n\t\t\tthis.diffCleanupMerge( diffs );\n\t\t}\n\n\t\t// Find any overlaps between deletions and insertions.\n\t\t// e.g: <del>abcxxx</del><ins>xxxdef</ins>\n\t\t//   -> <del>abc</del>xxx<ins>def</ins>\n\t\t// e.g: <del>xxxabc</del><ins>defxxx</ins>\n\t\t//   -> <ins>def</ins>xxx<del>abc</del>\n\t\t// Only extract an overlap if it is as big as the edit ahead or behind it.\n\t\tpointer = 1;\n\t\twhile ( pointer < diffs.length ) {\n\t\t\tif ( diffs[ pointer - 1 ][ 0 ] === DIFF_DELETE &&\n\t\t\t\t\tdiffs[ pointer ][ 0 ] === DIFF_INSERT ) {\n\t\t\t\tdeletion = diffs[ pointer - 1 ][ 1 ];\n\t\t\t\tinsertion = diffs[ pointer ][ 1 ];\n\t\t\t\toverlapLength1 = this.diffCommonOverlap( deletion, insertion );\n\t\t\t\toverlapLength2 = this.diffCommonOverlap( insertion, deletion );\n\t\t\t\tif ( overlapLength1 >= overlapLength2 ) {\n\t\t\t\t\tif ( overlapLength1 >= deletion.length / 2 ||\n\t\t\t\t\t\t\toverlapLength1 >= insertion.length / 2 ) {\n\n\t\t\t\t\t\t// Overlap found.  Insert an equality and trim the surrounding edits.\n\t\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\t\tpointer,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t[ DIFF_EQUAL, insertion.substring( 0, overlapLength1 ) ]\n\t\t\t\t\t\t);\n\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] =\n\t\t\t\t\t\t\tdeletion.substring( 0, deletion.length - overlapLength1 );\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] = insertion.substring( overlapLength1 );\n\t\t\t\t\t\tpointer++;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif ( overlapLength2 >= deletion.length / 2 ||\n\t\t\t\t\t\t\toverlapLength2 >= insertion.length / 2 ) {\n\n\t\t\t\t\t\t// Reverse overlap found.\n\t\t\t\t\t\t// Insert an equality and swap and trim the surrounding edits.\n\t\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\t\tpointer,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t[ DIFF_EQUAL, deletion.substring( 0, overlapLength2 ) ]\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tdiffs[ pointer - 1 ][ 0 ] = DIFF_INSERT;\n\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] =\n\t\t\t\t\t\t\tinsertion.substring( 0, insertion.length - overlapLength2 );\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 0 ] = DIFF_DELETE;\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] =\n\t\t\t\t\t\t\tdeletion.substring( overlapLength2 );\n\t\t\t\t\t\tpointer++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpointer++;\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\t};\n\n\t/**\n\t * Determine if the suffix of one string is the prefix of another.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {number} The number of characters common to the end of the first\n\t *     string and the start of the second string.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffCommonOverlap = function( text1, text2 ) {\n\t\tvar text1Length, text2Length, textLength,\n\t\t\tbest, length, pattern, found;\n\n\t\t// Cache the text lengths to prevent multiple calls.\n\t\ttext1Length = text1.length;\n\t\ttext2Length = text2.length;\n\n\t\t// Eliminate the null case.\n\t\tif ( text1Length === 0 || text2Length === 0 ) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Truncate the longer string.\n\t\tif ( text1Length > text2Length ) {\n\t\t\ttext1 = text1.substring( text1Length - text2Length );\n\t\t} else if ( text1Length < text2Length ) {\n\t\t\ttext2 = text2.substring( 0, text1Length );\n\t\t}\n\t\ttextLength = Math.min( text1Length, text2Length );\n\n\t\t// Quick check for the worst case.\n\t\tif ( text1 === text2 ) {\n\t\t\treturn textLength;\n\t\t}\n\n\t\t// Start by looking for a single character match\n\t\t// and increase length until no match is found.\n\t\t// Performance analysis: https://neil.fraser.name/news/2010/11/04/\n\t\tbest = 0;\n\t\tlength = 1;\n\t\twhile ( true ) {\n\t\t\tpattern = text1.substring( textLength - length );\n\t\t\tfound = text2.indexOf( pattern );\n\t\t\tif ( found === -1 ) {\n\t\t\t\treturn best;\n\t\t\t}\n\t\t\tlength += found;\n\t\t\tif ( found === 0 || text1.substring( textLength - length ) ===\n\t\t\t\t\ttext2.substring( 0, length ) ) {\n\t\t\t\tbest = length;\n\t\t\t\tlength++;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Split two texts into an array of strings.  Reduce the texts to a string of\n\t * hashes where each Unicode character represents one line.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}\n\t *     An object containing the encoded text1, the encoded text2 and\n\t *     the array of unique strings.\n\t *     The zeroth element of the array of unique strings is intentionally blank.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffLinesToChars = function( text1, text2 ) {\n\t\tvar lineArray, lineHash, chars1, chars2;\n\t\tlineArray = []; // E.g. lineArray[4] === \'Hello\\n\'\n\t\tlineHash = {};  // E.g. lineHash[\'Hello\\n\'] === 4\n\n\t\t// \'\\x00\' is a valid character, but various debuggers don\'t like it.\n\t\t// So we\'ll insert a junk entry to avoid generating a null character.\n\t\tlineArray[ 0 ] = "";\n\n\t\t/**\n\t\t * Split a text into an array of strings.  Reduce the texts to a string of\n\t\t * hashes where each Unicode character represents one line.\n\t\t * Modifies linearray and linehash through being a closure.\n\t\t * @param {string} text String to encode.\n\t\t * @return {string} Encoded string.\n\t\t * @private\n\t\t */\n\t\tfunction diffLinesToCharsMunge( text ) {\n\t\t\tvar chars, lineStart, lineEnd, lineArrayLength, line;\n\t\t\tchars = "";\n\n\t\t\t// Walk the text, pulling out a substring for each line.\n\t\t\t// text.split(\'\\n\') would would temporarily double our memory footprint.\n\t\t\t// Modifying text would create many large strings to garbage collect.\n\t\t\tlineStart = 0;\n\t\t\tlineEnd = -1;\n\n\t\t\t// Keeping our own length variable is faster than looking it up.\n\t\t\tlineArrayLength = lineArray.length;\n\t\t\twhile ( lineEnd < text.length - 1 ) {\n\t\t\t\tlineEnd = text.indexOf( "\\n", lineStart );\n\t\t\t\tif ( lineEnd === -1 ) {\n\t\t\t\t\tlineEnd = text.length - 1;\n\t\t\t\t}\n\t\t\t\tline = text.substring( lineStart, lineEnd + 1 );\n\t\t\t\tlineStart = lineEnd + 1;\n\n\t\t\t\tif ( lineHash.hasOwnProperty ? lineHash.hasOwnProperty( line ) :\n\t\t\t\t\t\t\t( lineHash[ line ] !== undefined ) ) {\n\t\t\t\t\tchars += String.fromCharCode( lineHash[ line ] );\n\t\t\t\t} else {\n\t\t\t\t\tchars += String.fromCharCode( lineArrayLength );\n\t\t\t\t\tlineHash[ line ] = lineArrayLength;\n\t\t\t\t\tlineArray[ lineArrayLength++ ] = line;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn chars;\n\t\t}\n\n\t\tchars1 = diffLinesToCharsMunge( text1 );\n\t\tchars2 = diffLinesToCharsMunge( text2 );\n\t\treturn {\n\t\t\tchars1: chars1,\n\t\t\tchars2: chars2,\n\t\t\tlineArray: lineArray\n\t\t};\n\t};\n\n\t/**\n\t * Rehydrate the text in a diff from a string of line hashes to real lines of\n\t * text.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t * @param {!Array.<string>} lineArray Array of unique strings.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffCharsToLines = function( diffs, lineArray ) {\n\t\tvar x, chars, text, y;\n\t\tfor ( x = 0; x < diffs.length; x++ ) {\n\t\t\tchars = diffs[ x ][ 1 ];\n\t\t\ttext = [];\n\t\t\tfor ( y = 0; y < chars.length; y++ ) {\n\t\t\t\ttext[ y ] = lineArray[ chars.charCodeAt( y ) ];\n\t\t\t}\n\t\t\tdiffs[ x ][ 1 ] = text.join( "" );\n\t\t}\n\t};\n\n\t/**\n\t * Reorder and merge like edit sections.  Merge equalities.\n\t * Any edit section can move as long as it doesn\'t cross an equality.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t */\n\tDiffMatchPatch.prototype.diffCleanupMerge = function( diffs ) {\n\t\tvar pointer, countDelete, countInsert, textInsert, textDelete,\n\t\t\tcommonlength, changes, diffPointer, position;\n\t\tdiffs.push( [ DIFF_EQUAL, "" ] ); // Add a dummy entry at the end.\n\t\tpointer = 0;\n\t\tcountDelete = 0;\n\t\tcountInsert = 0;\n\t\ttextDelete = "";\n\t\ttextInsert = "";\n\t\tcommonlength;\n\t\twhile ( pointer < diffs.length ) {\n\t\t\tswitch ( diffs[ pointer ][ 0 ] ) {\n\t\t\tcase DIFF_INSERT:\n\t\t\t\tcountInsert++;\n\t\t\t\ttextInsert += diffs[ pointer ][ 1 ];\n\t\t\t\tpointer++;\n\t\t\t\tbreak;\n\t\t\tcase DIFF_DELETE:\n\t\t\t\tcountDelete++;\n\t\t\t\ttextDelete += diffs[ pointer ][ 1 ];\n\t\t\t\tpointer++;\n\t\t\t\tbreak;\n\t\t\tcase DIFF_EQUAL:\n\n\t\t\t\t// Upon reaching an equality, check for prior redundancies.\n\t\t\t\tif ( countDelete + countInsert > 1 ) {\n\t\t\t\t\tif ( countDelete !== 0 && countInsert !== 0 ) {\n\n\t\t\t\t\t\t// Factor out any common prefixes.\n\t\t\t\t\t\tcommonlength = this.diffCommonPrefix( textInsert, textDelete );\n\t\t\t\t\t\tif ( commonlength !== 0 ) {\n\t\t\t\t\t\t\tif ( ( pointer - countDelete - countInsert ) > 0 &&\n\t\t\t\t\t\t\t\t\tdiffs[ pointer - countDelete - countInsert - 1 ][ 0 ] ===\n\t\t\t\t\t\t\t\t\tDIFF_EQUAL ) {\n\t\t\t\t\t\t\t\tdiffs[ pointer - countDelete - countInsert - 1 ][ 1 ] +=\n\t\t\t\t\t\t\t\t\ttextInsert.substring( 0, commonlength );\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdiffs.splice( 0, 0, [ DIFF_EQUAL,\n\t\t\t\t\t\t\t\t\ttextInsert.substring( 0, commonlength )\n\t\t\t\t\t\t\t\t] );\n\t\t\t\t\t\t\t\tpointer++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttextInsert = textInsert.substring( commonlength );\n\t\t\t\t\t\t\ttextDelete = textDelete.substring( commonlength );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Factor out any common suffixies.\n\t\t\t\t\t\tcommonlength = this.diffCommonSuffix( textInsert, textDelete );\n\t\t\t\t\t\tif ( commonlength !== 0 ) {\n\t\t\t\t\t\t\tdiffs[ pointer ][ 1 ] = textInsert.substring( textInsert.length -\n\t\t\t\t\t\t\t\t\tcommonlength ) + diffs[ pointer ][ 1 ];\n\t\t\t\t\t\t\ttextInsert = textInsert.substring( 0, textInsert.length -\n\t\t\t\t\t\t\t\tcommonlength );\n\t\t\t\t\t\t\ttextDelete = textDelete.substring( 0, textDelete.length -\n\t\t\t\t\t\t\t\tcommonlength );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Delete the offending records and add the merged ones.\n\t\t\t\t\tif ( countDelete === 0 ) {\n\t\t\t\t\t\tdiffs.splice( pointer - countInsert,\n\t\t\t\t\t\t\tcountDelete + countInsert, [ DIFF_INSERT, textInsert ] );\n\t\t\t\t\t} else if ( countInsert === 0 ) {\n\t\t\t\t\t\tdiffs.splice( pointer - countDelete,\n\t\t\t\t\t\t\tcountDelete + countInsert, [ DIFF_DELETE, textDelete ] );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\t\tpointer - countDelete - countInsert,\n\t\t\t\t\t\t\tcountDelete + countInsert,\n\t\t\t\t\t\t\t[ DIFF_DELETE, textDelete ], [ DIFF_INSERT, textInsert ]\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tpointer = pointer - countDelete - countInsert +\n\t\t\t\t\t\t( countDelete ? 1 : 0 ) + ( countInsert ? 1 : 0 ) + 1;\n\t\t\t\t} else if ( pointer !== 0 && diffs[ pointer - 1 ][ 0 ] === DIFF_EQUAL ) {\n\n\t\t\t\t\t// Merge this equality with the previous one.\n\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] += diffs[ pointer ][ 1 ];\n\t\t\t\t\tdiffs.splice( pointer, 1 );\n\t\t\t\t} else {\n\t\t\t\t\tpointer++;\n\t\t\t\t}\n\t\t\t\tcountInsert = 0;\n\t\t\t\tcountDelete = 0;\n\t\t\t\ttextDelete = "";\n\t\t\t\ttextInsert = "";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif ( diffs[ diffs.length - 1 ][ 1 ] === "" ) {\n\t\t\tdiffs.pop(); // Remove the dummy entry at the end.\n\t\t}\n\n\t\t// Second pass: look for single edits surrounded on both sides by equalities\n\t\t// which can be shifted sideways to eliminate an equality.\n\t\t// e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n\t\tchanges = false;\n\t\tpointer = 1;\n\n\t\t// Intentionally ignore the first and last element (don\'t need checking).\n\t\twhile ( pointer < diffs.length - 1 ) {\n\t\t\tif ( diffs[ pointer - 1 ][ 0 ] === DIFF_EQUAL &&\n\t\t\t\t\tdiffs[ pointer + 1 ][ 0 ] === DIFF_EQUAL ) {\n\n\t\t\t\tdiffPointer = diffs[ pointer ][ 1 ];\n\t\t\t\tposition = diffPointer.substring(\n\t\t\t\t\tdiffPointer.length - diffs[ pointer - 1 ][ 1 ].length\n\t\t\t\t);\n\n\t\t\t\t// This is a single edit surrounded by equalities.\n\t\t\t\tif ( position === diffs[ pointer - 1 ][ 1 ] ) {\n\n\t\t\t\t\t// Shift the edit over the previous equality.\n\t\t\t\t\tdiffs[ pointer ][ 1 ] = diffs[ pointer - 1 ][ 1 ] +\n\t\t\t\t\t\tdiffs[ pointer ][ 1 ].substring( 0, diffs[ pointer ][ 1 ].length -\n\t\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ].length );\n\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] =\n\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] + diffs[ pointer + 1 ][ 1 ];\n\t\t\t\t\tdiffs.splice( pointer - 1, 1 );\n\t\t\t\t\tchanges = true;\n\t\t\t\t} else if ( diffPointer.substring( 0, diffs[ pointer + 1 ][ 1 ].length ) ===\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] ) {\n\n\t\t\t\t\t// Shift the edit over the next equality.\n\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] += diffs[ pointer + 1 ][ 1 ];\n\t\t\t\t\tdiffs[ pointer ][ 1 ] =\n\t\t\t\t\t\tdiffs[ pointer ][ 1 ].substring( diffs[ pointer + 1 ][ 1 ].length ) +\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ];\n\t\t\t\t\tdiffs.splice( pointer + 1, 1 );\n\t\t\t\t\tchanges = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\n\t\t// If shifts were made, the diff needs reordering and another shift sweep.\n\t\tif ( changes ) {\n\t\t\tthis.diffCleanupMerge( diffs );\n\t\t}\n\t};\n\n\treturn function( o, n ) {\n\t\tvar diff, output, text;\n\t\tdiff = new DiffMatchPatch();\n\t\toutput = diff.DiffMain( o, n );\n\t\tdiff.diffCleanupEfficiency( output );\n\t\ttext = diff.diffPrettyHtml( output );\n\n\t\treturn text;\n\t};\n}() );\n\n}() );\n';
    loader.global.define = undefined;
    loader.global.module = undefined;
    loader.global.exports = undefined;
    loader.__exec({
        'source': source,
        'address': module.uri
    });
    loader.global.require = require;
    loader.global.define = define;
    return loader.get('@@global-helpers').retrieveGlobal(module.id, 'QUnit');
});
/*steal-css@1.3.1#css*/
define('steal-css@1.3.1#css', [
    'require',
    'exports',
    'module',
    '@loader',
    '@steal'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var loader = require('@loader');
        var steal = require('@steal');
        var isNode = typeof process === 'object' && {}.toString.call(process) === '[object process]';
        var importRegEx = /@import [^uU]['"]?([^'"\)]*)['"]?/g;
        var resourceRegEx = /url\(['"]?([^'"\)]*)['"]?\)/g;
        var waitSeconds = loader.cssOptions && loader.cssOptions.timeout ? parseInt(loader.cssOptions.timeout, 10) : 60;
        var onloadCss = function (link, cb) {
            var styleSheets = getDocument().styleSheets, i = styleSheets.length;
            while (i--) {
                if (styleSheets[i].href === link.href) {
                    return cb();
                }
            }
            setTimeout(function () {
                onloadCss(link, cb);
            });
        };
        function isIE9() {
            var doc = getDocument();
            return doc && !!Function('/*@cc_on return (/^9/.test(@_jscript_version) && /MSIE 9.0(?!.*IEMobile)/i.test(navigator.userAgent)); @*/')();
        }
        function getDocument() {
            if (typeof doneSsr !== 'undefined' && doneSsr.globalDocument) {
                return doneSsr.globalDocument;
            }
            if (typeof document !== 'undefined') {
                return document;
            }
            throw new Error('Unable to load CSS in an environment without a document.');
        }
        function getHead() {
            var doc = getDocument();
            var head = doc.head || doc.getElementsByTagName('head')[0];
            if (!head) {
                var docEl = doc.documentElement || doc;
                head = doc.createElement('head');
                docEl.insertBefore(head, docEl.firstChild);
            }
            return head;
        }
        function CSSModule(load, loader) {
            if (typeof load === 'object') {
                this.load = load;
                this.loader = loader;
                this.address = this.load.address;
                this.source = this.load.source;
            } else {
                this.address = load;
                this.source = loader;
            }
        }
        CSSModule.cssCount = 0;
        CSSModule.ie9MaxStyleSheets = 31;
        CSSModule.currentStyleSheet = null;
        CSSModule.prototype = {
            injectLink: function () {
                if (this._loaded) {
                    return this._loaded;
                }
                if (this.linkExists()) {
                    this._loaded = Promise.resolve('');
                    return this._loaded;
                }
                var doc = getDocument();
                var link = this.link = doc.createElement('link');
                link.type = 'text/css';
                link.rel = 'stylesheet';
                link.href = this.address;
                this._loaded = new Promise(function (resolve, reject) {
                    var timeout = setTimeout(function () {
                        reject('Unable to load CSS');
                    }, waitSeconds * 1000);
                    var loadCB = function (event) {
                        clearTimeout(timeout);
                        link.removeEventListener('load', loadCB);
                        link.removeEventListener('error', loadCB);
                        if (event && event.type === 'error') {
                            reject('Unable to load CSS');
                        } else {
                            resolve('');
                        }
                    };
                    if ('isApplicationInstalled' in navigator || !link.addEventListener) {
                        onloadCss(link, loadCB);
                    } else if (navigator.noUI) {
                        loadCB();
                    } else {
                        link.addEventListener('load', loadCB);
                        link.addEventListener('error', loadCB);
                    }
                    getHead().appendChild(link);
                });
                return this._loaded;
            },
            injectStyle: function () {
                var doc = getDocument();
                var head = getHead();
                var style = this.style = doc.createElement('style');
                style.type = 'text/css';
                if (style.sheet) {
                    style.sheet.cssText = this.source;
                } else if (style.styleSheet) {
                    style.styleSheet.cssText = this.source;
                } else {
                    style.appendChild(doc.createTextNode(this.source));
                }
                head.appendChild(style);
            },
            ie9StyleSheetLimitHack: function () {
                var doc = getDocument();
                if (!CSSModule.cssCount) {
                    CSSModule.currentStyleSheet = doc.createStyleSheet();
                }
                CSSModule.cssCount += 1;
                CSSModule.currentStyleSheet.cssText += this.source;
                if (CSSModule.cssCount === CSSModule.ie9MaxStyleSheets) {
                    CSSModule.cssCount = 0;
                }
            },
            updateURLs: function () {
                var rawSource = this.source, address = this.address;
                this.source = rawSource.replace(importRegEx, function (whole, part) {
                    if (isNode) {
                        return '@import url(' + part + ')';
                    } else {
                        return '@import url(' + steal.joinURIs(address, part) + ')';
                    }
                });
                if (!loader.isEnv('build')) {
                    this.source = this.source + '/*# sourceURL=' + address + ' */';
                    this.source = this.source.replace(resourceRegEx, function (whole, part) {
                        return 'url(' + steal.joinURIs(address, part) + ')';
                    });
                }
                return this.source;
            },
            getExistingNode: function () {
                var doc = getDocument();
                var selector = '[href=\'' + this.address + '\']';
                return doc.querySelector && doc.querySelector(selector);
            },
            linkExists: function () {
                var styleSheets = getDocument().styleSheets;
                for (var i = 0; i < styleSheets.length; ++i) {
                    if (this.address === styleSheets[i].href) {
                        return true;
                    }
                }
                return false;
            },
            setupLiveReload: function (loader, name) {
                var head = getHead();
                var css = this;
                if (loader.liveReloadInstalled) {
                    var cssReload = loader['import']('live-reload', { name: module.id });
                    Promise.resolve(cssReload).then(function (reload) {
                        loader['import'](name).then(function () {
                            reload.once('!dispose/' + name, function () {
                                css.style.__isDirty = true;
                                reload.once('!cycleComplete', function () {
                                    head.removeChild(css.style);
                                });
                            });
                        });
                    });
                }
            }
        };
        if (loader.isEnv('production')) {
            exports.fetch = function (load) {
                var css = new CSSModule(load.address);
                return css.injectLink();
            };
        } else {
            exports.instantiate = function (load) {
                var loader = this;
                var css = new CSSModule(load.address, load.source);
                load.source = css.updateURLs();
                load.metadata.deps = [];
                load.metadata.format = 'css';
                load.metadata.execute = function () {
                    if (getDocument()) {
                        if (isIE9()) {
                            css.ie9StyleSheetLimitHack();
                        } else {
                            css.injectStyle();
                        }
                        css.setupLiveReload(loader, load.name);
                    }
                    return loader.newModule({ source: css.source });
                };
            };
        }
        exports.CSSModule = CSSModule;
        exports.getDocument = getDocument;
        exports.getHead = getHead;
        exports.locateScheme = true;
        exports.buildType = 'css';
        exports.includeInBuild = true;
        exports.pluginBuilder = 'steal-css/slim';
    }(function () {
        return this;
    }(), require, exports, module));
});
/*steal-qunit@1.0.1#steal-qunit*/
'format amd';
define('steal-qunit@1.0.1#steal-qunit', [
    '@loader',
    'qunitjs/qunit/qunit',
    'qunitjs/qunit/qunit.css'
], function (loader, QUnit) {
    if (loader.has('live-reload')) {
        setupLiveReload();
    }
    setupSauceLabsReporting();
    function setupLiveReload() {
        QUnit.done(updateResults);
        function findModule(name) {
            var mods = QUnit.config.modules;
            return mods.filter(function (mod) {
                return mod.name === name;
            }).pop();
        }
        function findTestResult(mod, id) {
            var tests = mod.tests || [];
            return tests.filter(function (test) {
                return test.testId === id;
            })[0];
        }
        function updateResults() {
            var tests = document.getElementById('qunit-tests').children;
            var node, id, test, moduleName, mod;
            passed = true, removedNodes = [];
            for (var i = 0, len = tests.length; i < len; i++) {
                node = tests.item(i);
                id = node.id.split('-').pop();
                moduleName = node.querySelector('.module-name').textContent;
                mod = findModule(moduleName);
                test = findTestResult(mod, id);
                if (test) {
                    removeAllButLast(node, 'runtime');
                    if (node.className !== 'pass') {
                        passed = false;
                        break;
                    }
                } else {
                    removedNodes.push(node);
                }
            }
            removedNodes.forEach(function (node) {
                node.parentNode.removeChild(node);
            });
            document.getElementById('qunit-banner').className = passed ? 'qunit-pass' : 'qunit-fail';
        }
        function removeAllButLast(parent, className) {
            var node, nodes = [];
            var children = parent.children;
            for (var i = 0, len = children.length; i < len; i++) {
                node = children.item(i);
                if (node.className === className)
                    nodes.push(node);
            }
            while (nodes.length > 1) {
                node = nodes.shift();
                parent.removeChild(node);
            }
        }
    }
    function setupSauceLabsReporting() {
        var log = [];
        QUnit.done(function (test_results) {
            var tests = [];
            for (var i = 0, len = log.length; i < len; i++) {
                var details = log[i];
                tests.push({
                    name: details.name,
                    result: details.result,
                    expected: details.expected,
                    actual: details.actual,
                    source: details.source
                });
            }
            test_results.tests = tests;
            window.global_test_results = test_results;
        });
        QUnit.testStart(function (testDetails) {
            QUnit.log(function (details) {
                if (!details.result) {
                    details.name = testDetails.name;
                    log.push(details);
                }
            });
        });
    }
    QUnit.config.autorun = false;
    steal.done().then(function () {
        if (window.Testee && window.Testee.init) {
            Testee.init();
        }
        QUnit.load();
    });
    return QUnit;
});
/*can-namespace@1.0.0#can-namespace*/
define('can-namespace@1.0.0#can-namespace', function (require, exports, module) {
    module.exports = {};
});
/*can-symbol@1.4.1#can-symbol*/
define('can-symbol@1.4.1#can-symbol', [
    'require',
    'exports',
    'module',
    'can-namespace'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var namespace = require('can-namespace');
        var CanSymbol;
        if (typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') {
            CanSymbol = Symbol;
        } else {
            var symbolNum = 0;
            CanSymbol = function CanSymbolPolyfill(description) {
                var symbolValue = '@@symbol' + symbolNum++ + description;
                var symbol = {};
                Object.defineProperties(symbol, {
                    toString: {
                        value: function () {
                            return symbolValue;
                        }
                    }
                });
                return symbol;
            };
            var descriptionToSymbol = {};
            var symbolToDescription = {};
            CanSymbol.for = function (description) {
                var symbol = descriptionToSymbol[description];
                if (!symbol) {
                    symbol = descriptionToSymbol[description] = CanSymbol(description);
                    symbolToDescription[symbol] = description;
                }
                return symbol;
            };
            CanSymbol.keyFor = function (symbol) {
                return symbolToDescription[symbol];
            };
            [
                'hasInstance',
                'isConcatSpreadable',
                'iterator',
                'match',
                'prototype',
                'replace',
                'search',
                'species',
                'split',
                'toPrimitive',
                'toStringTag',
                'unscopables'
            ].forEach(function (name) {
                CanSymbol[name] = CanSymbol.for(name);
            });
        }
        [
            'isMapLike',
            'isListLike',
            'isValueLike',
            'isFunctionLike',
            'getOwnKeys',
            'getOwnKeyDescriptor',
            'proto',
            'getOwnEnumerableKeys',
            'hasOwnKey',
            'size',
            'getName',
            'getIdentity',
            'assignDeep',
            'updateDeep',
            'getValue',
            'setValue',
            'getKeyValue',
            'setKeyValue',
            'updateValues',
            'addValue',
            'removeValues',
            'apply',
            'new',
            'onValue',
            'offValue',
            'onKeyValue',
            'offKeyValue',
            'getKeyDependencies',
            'getValueDependencies',
            'keyHasDependencies',
            'valueHasDependencies',
            'onKeys',
            'onKeysAdded',
            'onKeysRemoved'
        ].forEach(function (name) {
            CanSymbol.for('can.' + name);
        });
        module.exports = namespace.Symbol = CanSymbol;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-reflect@1.7.1#reflections/helpers*/
define('can-reflect@1.7.1#reflections/helpers', [
    'require',
    'exports',
    'module',
    'can-symbol'
], function (require, exports, module) {
    var canSymbol = require('can-symbol');
    module.exports = {
        makeGetFirstSymbolValue: function (symbolNames) {
            var symbols = symbolNames.map(function (name) {
                return canSymbol.for(name);
            });
            var length = symbols.length;
            return function getFirstSymbol(obj) {
                var index = -1;
                while (++index < length) {
                    if (obj[symbols[index]] !== undefined) {
                        return obj[symbols[index]];
                    }
                }
            };
        },
        hasLength: function (list) {
            var type = typeof list;
            var length = list && type !== 'boolean' && typeof list !== 'number' && 'length' in list && list.length;
            return typeof list !== 'function' && (length === 0 || typeof length === 'number' && length > 0 && length - 1 in list);
        }
    };
});
/*can-reflect@1.7.1#reflections/type/type*/
define('can-reflect@1.7.1#reflections/type/type', [
    'require',
    'exports',
    'module',
    'can-symbol',
    '../helpers'
], function (require, exports, module) {
    var canSymbol = require('can-symbol');
    var helpers = require('../helpers');
    var plainFunctionPrototypePropertyNames = Object.getOwnPropertyNames(function () {
    }.prototype);
    var plainFunctionPrototypeProto = Object.getPrototypeOf(function () {
    }.prototype);
    function isConstructorLike(func) {
        var value = func[canSymbol.for('can.new')];
        if (value !== undefined) {
            return value;
        }
        if (typeof func !== 'function') {
            return false;
        }
        var prototype = func.prototype;
        if (!prototype) {
            return false;
        }
        if (plainFunctionPrototypeProto !== Object.getPrototypeOf(prototype)) {
            return true;
        }
        var propertyNames = Object.getOwnPropertyNames(prototype);
        if (propertyNames.length === plainFunctionPrototypePropertyNames.length) {
            for (var i = 0, len = propertyNames.length; i < len; i++) {
                if (propertyNames[i] !== plainFunctionPrototypePropertyNames[i]) {
                    return true;
                }
            }
            return false;
        } else {
            return true;
        }
    }
    var getNewOrApply = helpers.makeGetFirstSymbolValue([
        'can.new',
        'can.apply'
    ]);
    function isFunctionLike(obj) {
        var result, symbolValue = obj[canSymbol.for('can.isFunctionLike')];
        if (symbolValue !== undefined) {
            return symbolValue;
        }
        result = getNewOrApply(obj);
        if (result !== undefined) {
            return !!result;
        }
        return typeof obj === 'function';
    }
    function isPrimitive(obj) {
        var type = typeof obj;
        if (obj == null || type !== 'function' && type !== 'object') {
            return true;
        } else {
            return false;
        }
    }
    function isBuiltIn(obj) {
        if (isPrimitive(obj) || Array.isArray(obj) || isPlainObject(obj) || Object.prototype.toString.call(obj) !== '[object Object]' && Object.prototype.toString.call(obj).indexOf('[object ') !== -1) {
            return true;
        } else {
            return false;
        }
    }
    function isValueLike(obj) {
        var symbolValue;
        if (isPrimitive(obj)) {
            return true;
        }
        symbolValue = obj[canSymbol.for('can.isValueLike')];
        if (typeof symbolValue !== 'undefined') {
            return symbolValue;
        }
        var value = obj[canSymbol.for('can.getValue')];
        if (value !== undefined) {
            return !!value;
        }
    }
    function isMapLike(obj) {
        if (isPrimitive(obj)) {
            return false;
        }
        var isMapLike = obj[canSymbol.for('can.isMapLike')];
        if (typeof isMapLike !== 'undefined') {
            return !!isMapLike;
        }
        var value = obj[canSymbol.for('can.getKeyValue')];
        if (value !== undefined) {
            return !!value;
        }
        return true;
    }
    var getObservableLikeSymbol = helpers.makeGetFirstSymbolValue([
        'can.onValue',
        'can.onKeyValue',
        'can.onKeys',
        'can.onKeysAdded'
    ]);
    function isObservableLike(obj) {
        if (isPrimitive(obj)) {
            return false;
        }
        var result = getObservableLikeSymbol(obj);
        if (result !== undefined) {
            return !!result;
        }
        return false;
    }
    function isListLike(list) {
        var symbolValue, type = typeof list;
        if (type === 'string') {
            return true;
        }
        if (isPrimitive(list)) {
            return false;
        }
        symbolValue = list[canSymbol.for('can.isListLike')];
        if (typeof symbolValue !== 'undefined') {
            return symbolValue;
        }
        var value = list[canSymbol.iterator];
        if (value !== undefined) {
            return !!value;
        }
        if (Array.isArray(list)) {
            return true;
        }
        return helpers.hasLength(list);
    }
    var supportsSymbols = typeof Symbol !== 'undefined' && typeof Symbol.for === 'function';
    var isSymbolLike;
    if (supportsSymbols) {
        isSymbolLike = function (symbol) {
            return typeof symbol === 'symbol';
        };
    } else {
        var symbolStart = '@@symbol';
        isSymbolLike = function (symbol) {
            if (typeof symbol === 'object' && !Array.isArray(symbol)) {
                return symbol.toString().substr(0, symbolStart.length) === symbolStart;
            } else {
                return false;
            }
        };
    }
    var coreHasOwn = Object.prototype.hasOwnProperty;
    var funcToString = Function.prototype.toString;
    var objectCtorString = funcToString.call(Object);
    function isPlainObject(obj) {
        if (!obj || typeof obj !== 'object') {
            return false;
        }
        var proto = Object.getPrototypeOf(obj);
        if (proto === Object.prototype || proto === null) {
            return true;
        }
        var Constructor = coreHasOwn.call(proto, 'constructor') && proto.constructor;
        return typeof Constructor === 'function' && Constructor instanceof Constructor && funcToString.call(Constructor) === objectCtorString;
    }
    module.exports = {
        isConstructorLike: isConstructorLike,
        isFunctionLike: isFunctionLike,
        isListLike: isListLike,
        isMapLike: isMapLike,
        isObservableLike: isObservableLike,
        isPrimitive: isPrimitive,
        isBuiltIn: isBuiltIn,
        isValueLike: isValueLike,
        isSymbolLike: isSymbolLike,
        isMoreListLikeThanMapLike: function (obj) {
            if (Array.isArray(obj)) {
                return true;
            }
            var value = obj[canSymbol.for('can.isMoreListLikeThanMapLike')];
            if (value !== undefined) {
                return value;
            }
            var isListLike = this.isListLike(obj), isMapLike = this.isMapLike(obj);
            if (isListLike && !isMapLike) {
                return true;
            } else if (!isListLike && isMapLike) {
                return false;
            }
        },
        isIteratorLike: function (obj) {
            return obj && typeof obj === 'object' && typeof obj.next === 'function' && obj.next.length === 0;
        },
        isPromise: function (obj) {
            return obj instanceof Promise || Object.prototype.toString.call(obj) === '[object Promise]';
        },
        isPlainObject: isPlainObject
    };
});
/*can-reflect@1.7.1#reflections/call/call*/
define('can-reflect@1.7.1#reflections/call/call', [
    'require',
    'exports',
    'module',
    'can-symbol',
    '../type/type'
], function (require, exports, module) {
    var canSymbol = require('can-symbol');
    var typeReflections = require('../type/type');
    module.exports = {
        call: function (func, context) {
            var args = [].slice.call(arguments, 2);
            var apply = func[canSymbol.for('can.apply')];
            if (apply) {
                return apply.call(func, context, args);
            } else {
                return func.apply(context, args);
            }
        },
        apply: function (func, context, args) {
            var apply = func[canSymbol.for('can.apply')];
            if (apply) {
                return apply.call(func, context, args);
            } else {
                return func.apply(context, args);
            }
        },
        'new': function (func) {
            var args = [].slice.call(arguments, 1);
            var makeNew = func[canSymbol.for('can.new')];
            if (makeNew) {
                return makeNew.apply(func, args);
            } else {
                var context = Object.create(func.prototype);
                var ret = func.apply(context, args);
                if (typeReflections.isPrimitive(ret)) {
                    return context;
                } else {
                    return ret;
                }
            }
        }
    };
});
/*can-reflect@1.7.1#reflections/get-set/get-set*/
define('can-reflect@1.7.1#reflections/get-set/get-set', [
    'require',
    'exports',
    'module',
    'can-symbol',
    '../type/type'
], function (require, exports, module) {
    var canSymbol = require('can-symbol');
    var typeReflections = require('../type/type');
    var setKeyValueSymbol = canSymbol.for('can.setKeyValue'), getKeyValueSymbol = canSymbol.for('can.getKeyValue'), getValueSymbol = canSymbol.for('can.getValue'), setValueSymbol = canSymbol.for('can.setValue');
    var reflections = {
        setKeyValue: function (obj, key, value) {
            if (typeReflections.isSymbolLike(key)) {
                if (typeof key === 'symbol') {
                    obj[key] = value;
                } else {
                    Object.defineProperty(obj, key, {
                        enumerable: false,
                        configurable: true,
                        value: value,
                        writable: true
                    });
                }
                return;
            }
            var setKeyValue = obj[setKeyValueSymbol];
            if (setKeyValue !== undefined) {
                return setKeyValue.call(obj, key, value);
            } else {
                obj[key] = value;
            }
        },
        getKeyValue: function (obj, key) {
            var getKeyValue = obj[getKeyValueSymbol];
            if (getKeyValue) {
                return getKeyValue.call(obj, key);
            }
            return obj[key];
        },
        deleteKeyValue: function (obj, key) {
            var deleteKeyValue = obj[canSymbol.for('can.deleteKeyValue')];
            if (deleteKeyValue) {
                return deleteKeyValue.call(obj, key);
            }
            delete obj[key];
        },
        getValue: function (value) {
            if (typeReflections.isPrimitive(value)) {
                return value;
            }
            var getValue = value[getValueSymbol];
            if (getValue) {
                return getValue.call(value);
            }
            return value;
        },
        setValue: function (item, value) {
            var setValue = item && item[setValueSymbol];
            if (setValue) {
                return setValue.call(item, value);
            } else {
                throw new Error('can-reflect.setValue - Can not set value.');
            }
        },
        splice: function (obj, index, removing, adding) {
            var howMany;
            if (typeof removing !== 'number') {
                var updateValues = obj[canSymbol.for('can.updateValues')];
                if (updateValues) {
                    return updateValues.call(obj, index, removing, adding);
                }
                howMany = removing.length;
            } else {
                howMany = removing;
            }
            var splice = obj[canSymbol.for('can.splice')];
            if (splice) {
                return splice.call(obj, index, howMany, adding);
            }
            return [].splice.apply(obj, [
                index,
                howMany
            ].concat(adding));
        },
        addValues: function (obj, adding, index) {
            var add = obj[canSymbol.for('can.addValues')];
            if (add) {
                return add.call(obj, adding, index);
            }
            if (Array.isArray(obj) && index === undefined) {
                return obj.push.apply(obj, adding);
            }
            return reflections.splice(obj, index, [], adding);
        },
        removeValues: function (obj, removing, index) {
            var removeValues = obj[canSymbol.for('can.removeValues')];
            if (removeValues) {
                return removeValues.call(obj, removing, index);
            }
            if (Array.isArray(obj) && index === undefined) {
                removing.forEach(function (item) {
                    var index = obj.indexOf(item);
                    if (index >= 0) {
                        obj.splice(index, 1);
                    }
                });
                return;
            }
            return reflections.splice(obj, index, removing, []);
        }
    };
    reflections.get = reflections.getKeyValue;
    reflections.set = reflections.setKeyValue;
    reflections['delete'] = reflections.deleteKeyValue;
    module.exports = reflections;
});
/*can-reflect@1.7.1#reflections/observe/observe*/
define('can-reflect@1.7.1#reflections/observe/observe', [
    'require',
    'exports',
    'module',
    'can-symbol'
], function (require, exports, module) {
    var canSymbol = require('can-symbol');
    var slice = [].slice;
    function makeFallback(symbolName, fallbackName) {
        return function (obj, event, handler, queueName) {
            var method = obj[canSymbol.for(symbolName)];
            if (method !== undefined) {
                return method.call(obj, event, handler, queueName);
            }
            return this[fallbackName].apply(this, arguments);
        };
    }
    function makeErrorIfMissing(symbolName, errorMessage) {
        return function (obj) {
            var method = obj[canSymbol.for(symbolName)];
            if (method !== undefined) {
                var args = slice.call(arguments, 1);
                return method.apply(obj, args);
            }
            throw new Error(errorMessage);
        };
    }
    module.exports = {
        onKeyValue: makeFallback('can.onKeyValue', 'onEvent'),
        offKeyValue: makeFallback('can.offKeyValue', 'offEvent'),
        onKeys: makeErrorIfMissing('can.onKeys', 'can-reflect: can not observe an onKeys event'),
        onKeysAdded: makeErrorIfMissing('can.onKeysAdded', 'can-reflect: can not observe an onKeysAdded event'),
        onKeysRemoved: makeErrorIfMissing('can.onKeysRemoved', 'can-reflect: can not unobserve an onKeysRemoved event'),
        getKeyDependencies: makeErrorIfMissing('can.getKeyDependencies', 'can-reflect: can not determine dependencies'),
        keyHasDependencies: makeErrorIfMissing('can.keyHasDependencies', 'can-reflect: can not determine if this has key dependencies'),
        onValue: makeErrorIfMissing('can.onValue', 'can-reflect: can not observe value change'),
        offValue: makeErrorIfMissing('can.offValue', 'can-reflect: can not unobserve value change'),
        getValueDependencies: makeErrorIfMissing('can.getValueDependencies', 'can-reflect: can not determine dependencies'),
        valueHasDependencies: makeErrorIfMissing('can.valueHasDependencies', 'can-reflect: can not determine if value has dependencies'),
        onEvent: function (obj, eventName, callback, queue) {
            if (obj) {
                var onEvent = obj[canSymbol.for('can.onEvent')];
                if (onEvent !== undefined) {
                    return onEvent.call(obj, eventName, callback, queue);
                } else if (obj.addEventListener) {
                    obj.addEventListener(eventName, callback, queue);
                }
            }
        },
        offEvent: function (obj, eventName, callback, queue) {
            if (obj) {
                var offEvent = obj[canSymbol.for('can.offEvent')];
                if (offEvent !== undefined) {
                    return offEvent.call(obj, eventName, callback, queue);
                } else if (obj.removeEventListener) {
                    obj.removeEventListener(eventName, callback, queue);
                }
            }
        },
        setPriority: function (obj, priority) {
            if (obj) {
                var setPriority = obj[canSymbol.for('can.setPriority')];
                if (setPriority !== undefined) {
                    setPriority.call(obj, priority);
                    return true;
                }
            }
            return false;
        },
        getPriority: function (obj) {
            if (obj) {
                var getPriority = obj[canSymbol.for('can.getPriority')];
                if (getPriority !== undefined) {
                    return getPriority.call(obj);
                }
            }
            return undefined;
        }
    };
});
/*can-reflect@1.7.1#reflections/shape/shape*/
define('can-reflect@1.7.1#reflections/shape/shape', [
    'require',
    'exports',
    'module',
    'can-symbol',
    '../get-set/get-set',
    '../type/type',
    '../helpers'
], function (require, exports, module) {
    var canSymbol = require('can-symbol');
    var getSetReflections = require('../get-set/get-set');
    var typeReflections = require('../type/type');
    var helpers = require('../helpers');
    var shapeReflections;
    var shiftFirstArgumentToThis = function (func) {
        return function () {
            var args = [this];
            args.push.apply(args, arguments);
            return func.apply(null, args);
        };
    };
    var getKeyValueSymbol = canSymbol.for('can.getKeyValue');
    var shiftedGetKeyValue = shiftFirstArgumentToThis(getSetReflections.getKeyValue);
    var setKeyValueSymbol = canSymbol.for('can.setKeyValue');
    var shiftedSetKeyValue = shiftFirstArgumentToThis(getSetReflections.setKeyValue);
    var sizeSymbol = canSymbol.for('can.size');
    var serializeMap = null;
    var hasUpdateSymbol = helpers.makeGetFirstSymbolValue([
        'can.updateDeep',
        'can.assignDeep',
        'can.setKeyValue'
    ]);
    var shouldUpdateOrAssign = function (obj) {
        return typeReflections.isPlainObject(obj) || Array.isArray(obj) || !!hasUpdateSymbol(obj);
    };
    function isSerializable(obj) {
        if (typeReflections.isPrimitive(obj)) {
            return true;
        }
        if (hasUpdateSymbol(obj)) {
            return false;
        }
        return typeReflections.isBuiltIn(obj) && !typeReflections.isPlainObject(obj);
    }
    var Object_Keys;
    try {
        Object.keys(1);
        Object_Keys = Object.keys;
    } catch (e) {
        Object_Keys = function (obj) {
            if (typeReflections.isPrimitive(obj)) {
                return [];
            } else {
                return Object.keys(obj);
            }
        };
    }
    function makeSerializer(methodName, symbolsToCheck) {
        return function serializer(value, MapType) {
            if (isSerializable(value)) {
                return value;
            }
            var firstSerialize;
            if (MapType && !serializeMap) {
                serializeMap = {
                    unwrap: new MapType(),
                    serialize: new MapType()
                };
                firstSerialize = true;
            }
            var serialized;
            if (typeReflections.isValueLike(value)) {
                serialized = this[methodName](getSetReflections.getValue(value));
            } else {
                var isListLike = typeReflections.isIteratorLike(value) || typeReflections.isMoreListLikeThanMapLike(value);
                serialized = isListLike ? [] : {};
                if (serializeMap) {
                    if (serializeMap[methodName].has(value)) {
                        return serializeMap[methodName].get(value);
                    } else {
                        serializeMap[methodName].set(value, serialized);
                    }
                }
                for (var i = 0, len = symbolsToCheck.length; i < len; i++) {
                    var serializer = value[symbolsToCheck[i]];
                    if (serializer) {
                        var result = serializer.call(value, serialized);
                        if (firstSerialize) {
                            serializeMap = null;
                        }
                        return result;
                    }
                }
                if (typeof obj === 'function') {
                    if (serializeMap) {
                        serializeMap[methodName].set(value, value);
                    }
                    serialized = value;
                } else if (isListLike) {
                    this.eachIndex(value, function (childValue, index) {
                        serialized[index] = this[methodName](childValue);
                    }, this);
                } else {
                    this.eachKey(value, function (childValue, prop) {
                        serialized[prop] = this[methodName](childValue);
                    }, this);
                }
            }
            if (firstSerialize) {
                serializeMap = null;
            }
            return serialized;
        };
    }
    var makeMap;
    if (typeof Map !== 'undefined') {
        makeMap = function (keys) {
            var map = new Map();
            shapeReflections.eachIndex(keys, function (key) {
                map.set(key, true);
            });
            return map;
        };
    } else {
        makeMap = function (keys) {
            var map = {};
            keys.forEach(function (key) {
                map[key] = true;
            });
            return {
                get: function (key) {
                    return map[key];
                },
                set: function (key, value) {
                    map[key] = value;
                },
                keys: function () {
                    return keys;
                }
            };
        };
    }
    var fastHasOwnKey = function (obj) {
        var hasOwnKey = obj[canSymbol.for('can.hasOwnKey')];
        if (hasOwnKey) {
            return hasOwnKey.bind(obj);
        } else {
            var map = makeMap(shapeReflections.getOwnEnumerableKeys(obj));
            return function (key) {
                return map.get(key);
            };
        }
    };
    function addPatch(patches, patch) {
        var lastPatch = patches[patches.length - 1];
        if (lastPatch) {
            if (lastPatch.deleteCount === lastPatch.insert.length && patch.index - lastPatch.index === lastPatch.deleteCount) {
                lastPatch.insert.push.apply(lastPatch.insert, patch.insert);
                lastPatch.deleteCount += patch.deleteCount;
                return;
            }
        }
        patches.push(patch);
    }
    function updateDeepList(target, source, isAssign) {
        var sourceArray = this.toArray(source);
        var patches = [], lastIndex = -1;
        this.eachIndex(target, function (curVal, index) {
            lastIndex = index;
            if (index >= sourceArray.length) {
                if (!isAssign) {
                    addPatch(patches, {
                        index: index,
                        deleteCount: sourceArray.length - index + 1,
                        insert: []
                    });
                }
                return false;
            }
            var newVal = sourceArray[index];
            if (typeReflections.isPrimitive(curVal) || typeReflections.isPrimitive(newVal) || shouldUpdateOrAssign(curVal) === false) {
                addPatch(patches, {
                    index: index,
                    deleteCount: 1,
                    insert: [newVal]
                });
            } else {
                this.updateDeep(curVal, newVal);
            }
        }, this);
        if (sourceArray.length > lastIndex) {
            addPatch(patches, {
                index: lastIndex + 1,
                deleteCount: 0,
                insert: sourceArray.slice(lastIndex + 1)
            });
        }
        for (var i = 0, patchLen = patches.length; i < patchLen; i++) {
            var patch = patches[i];
            getSetReflections.splice(target, patch.index, patch.deleteCount, patch.insert);
        }
        return target;
    }
    shapeReflections = {
        each: function (obj, callback, context) {
            if (typeReflections.isIteratorLike(obj) || typeReflections.isMoreListLikeThanMapLike(obj)) {
                return this.eachIndex(obj, callback, context);
            } else {
                return this.eachKey(obj, callback, context);
            }
        },
        eachIndex: function (list, callback, context) {
            if (Array.isArray(list)) {
                return this.eachListLike(list, callback, context);
            } else {
                var iter, iterator = list[canSymbol.iterator];
                if (typeReflections.isIteratorLike(list)) {
                    iter = list;
                } else if (iterator) {
                    iter = iterator.call(list);
                }
                if (iter) {
                    var res, index = 0;
                    while (!(res = iter.next()).done) {
                        if (callback.call(context || list, res.value, index++, list) === false) {
                            break;
                        }
                    }
                } else {
                    this.eachListLike(list, callback, context);
                }
            }
            return list;
        },
        eachListLike: function (list, callback, context) {
            var index = -1;
            var length = list.length;
            if (length === undefined) {
                var size = list[sizeSymbol];
                if (size) {
                    length = size.call(list);
                } else {
                    throw new Error('can-reflect: unable to iterate.');
                }
            }
            while (++index < length) {
                var item = list[index];
                if (callback.call(context || item, item, index, list) === false) {
                    break;
                }
            }
            return list;
        },
        toArray: function (obj) {
            var arr = [];
            this.each(obj, function (value) {
                arr.push(value);
            });
            return arr;
        },
        eachKey: function (obj, callback, context) {
            if (obj) {
                var enumerableKeys = this.getOwnEnumerableKeys(obj);
                var getKeyValue = obj[getKeyValueSymbol] || shiftedGetKeyValue;
                return this.eachIndex(enumerableKeys, function (key) {
                    var value = getKeyValue.call(obj, key);
                    return callback.call(context || obj, value, key, obj);
                });
            }
            return obj;
        },
        'hasOwnKey': function (obj, key) {
            var hasOwnKey = obj[canSymbol.for('can.hasOwnKey')];
            if (hasOwnKey) {
                return hasOwnKey.call(obj, key);
            }
            var getOwnKeys = obj[canSymbol.for('can.getOwnKeys')];
            if (getOwnKeys) {
                var found = false;
                this.eachIndex(getOwnKeys.call(obj), function (objKey) {
                    if (objKey === key) {
                        found = true;
                        return false;
                    }
                });
                return found;
            }
            return obj.hasOwnProperty(key);
        },
        getOwnEnumerableKeys: function (obj) {
            var getOwnEnumerableKeys = obj[canSymbol.for('can.getOwnEnumerableKeys')];
            if (getOwnEnumerableKeys) {
                return getOwnEnumerableKeys.call(obj);
            }
            if (obj[canSymbol.for('can.getOwnKeys')] && obj[canSymbol.for('can.getOwnKeyDescriptor')]) {
                var keys = [];
                this.eachIndex(this.getOwnKeys(obj), function (key) {
                    var descriptor = this.getOwnKeyDescriptor(obj, key);
                    if (descriptor.enumerable) {
                        keys.push(key);
                    }
                }, this);
                return keys;
            } else {
                return Object_Keys(obj);
            }
        },
        getOwnKeys: function (obj) {
            var getOwnKeys = obj[canSymbol.for('can.getOwnKeys')];
            if (getOwnKeys) {
                return getOwnKeys.call(obj);
            } else {
                return Object.getOwnPropertyNames(obj);
            }
        },
        getOwnKeyDescriptor: function (obj, key) {
            var getOwnKeyDescriptor = obj[canSymbol.for('can.getOwnKeyDescriptor')];
            if (getOwnKeyDescriptor) {
                return getOwnKeyDescriptor.call(obj, key);
            } else {
                return Object.getOwnPropertyDescriptor(obj, key);
            }
        },
        unwrap: makeSerializer('unwrap', [canSymbol.for('can.unwrap')]),
        serialize: makeSerializer('serialize', [
            canSymbol.for('can.serialize'),
            canSymbol.for('can.unwrap')
        ]),
        assignMap: function (target, source) {
            var hasOwnKey = fastHasOwnKey(target);
            var getKeyValue = target[getKeyValueSymbol] || shiftedGetKeyValue;
            var setKeyValue = target[setKeyValueSymbol] || shiftedSetKeyValue;
            this.eachKey(source, function (value, key) {
                if (!hasOwnKey(key) || getKeyValue.call(target, key) !== value) {
                    setKeyValue.call(target, key, value);
                }
            });
            return target;
        },
        assignList: function (target, source) {
            var inserting = this.toArray(source);
            getSetReflections.splice(target, 0, inserting, inserting);
            return target;
        },
        assign: function (target, source) {
            if (typeReflections.isIteratorLike(source) || typeReflections.isMoreListLikeThanMapLike(source)) {
                this.assignList(target, source);
            } else {
                this.assignMap(target, source);
            }
            return target;
        },
        assignDeepMap: function (target, source) {
            var hasOwnKey = fastHasOwnKey(target);
            var getKeyValue = target[getKeyValueSymbol] || shiftedGetKeyValue;
            var setKeyValue = target[setKeyValueSymbol] || shiftedSetKeyValue;
            this.eachKey(source, function (newVal, key) {
                if (!hasOwnKey(key)) {
                    getSetReflections.setKeyValue(target, key, newVal);
                } else {
                    var curVal = getKeyValue.call(target, key);
                    if (newVal === curVal) {
                    } else if (typeReflections.isPrimitive(curVal) || typeReflections.isPrimitive(newVal) || shouldUpdateOrAssign(curVal) === false) {
                        setKeyValue.call(target, key, newVal);
                    } else {
                        this.assignDeep(curVal, newVal);
                    }
                }
            }, this);
            return target;
        },
        assignDeepList: function (target, source) {
            return updateDeepList.call(this, target, source, true);
        },
        assignDeep: function (target, source) {
            var assignDeep = target[canSymbol.for('can.assignDeep')];
            if (assignDeep) {
                assignDeep.call(target, source);
            } else if (typeReflections.isMoreListLikeThanMapLike(source)) {
                this.assignDeepList(target, source);
            } else {
                this.assignDeepMap(target, source);
            }
            return target;
        },
        updateMap: function (target, source) {
            var sourceKeyMap = makeMap(this.getOwnEnumerableKeys(source));
            var sourceGetKeyValue = source[getKeyValueSymbol] || shiftedGetKeyValue;
            var targetSetKeyValue = target[setKeyValueSymbol] || shiftedSetKeyValue;
            this.eachKey(target, function (curVal, key) {
                if (!sourceKeyMap.get(key)) {
                    getSetReflections.deleteKeyValue(target, key);
                    return;
                }
                sourceKeyMap.set(key, false);
                var newVal = sourceGetKeyValue.call(source, key);
                if (newVal !== curVal) {
                    targetSetKeyValue.call(target, key, newVal);
                }
            }, this);
            this.eachIndex(sourceKeyMap.keys(), function (key) {
                if (sourceKeyMap.get(key)) {
                    targetSetKeyValue.call(target, key, sourceGetKeyValue.call(source, key));
                }
            });
            return target;
        },
        updateList: function (target, source) {
            var inserting = this.toArray(source);
            getSetReflections.splice(target, 0, target, inserting);
            return target;
        },
        update: function (target, source) {
            if (typeReflections.isIteratorLike(source) || typeReflections.isMoreListLikeThanMapLike(source)) {
                this.updateList(target, source);
            } else {
                this.updateMap(target, source);
            }
            return target;
        },
        updateDeepMap: function (target, source) {
            var sourceKeyMap = makeMap(this.getOwnEnumerableKeys(source));
            var sourceGetKeyValue = source[getKeyValueSymbol] || shiftedGetKeyValue;
            var targetSetKeyValue = target[setKeyValueSymbol] || shiftedSetKeyValue;
            this.eachKey(target, function (curVal, key) {
                if (!sourceKeyMap.get(key)) {
                    getSetReflections.deleteKeyValue(target, key);
                    return;
                }
                sourceKeyMap.set(key, false);
                var newVal = sourceGetKeyValue.call(source, key);
                if (typeReflections.isPrimitive(curVal) || typeReflections.isPrimitive(newVal) || shouldUpdateOrAssign(curVal) === false) {
                    targetSetKeyValue.call(target, key, newVal);
                } else {
                    this.updateDeep(curVal, newVal);
                }
            }, this);
            this.eachIndex(sourceKeyMap.keys(), function (key) {
                if (sourceKeyMap.get(key)) {
                    targetSetKeyValue.call(target, key, sourceGetKeyValue.call(source, key));
                }
            });
            return target;
        },
        updateDeepList: function (target, source) {
            return updateDeepList.call(this, target, source);
        },
        updateDeep: function (target, source) {
            var updateDeep = target[canSymbol.for('can.updateDeep')];
            if (updateDeep) {
                updateDeep.call(target, source);
            } else if (typeReflections.isMoreListLikeThanMapLike(source)) {
                this.updateDeepList(target, source);
            } else {
                this.updateDeepMap(target, source);
            }
            return target;
        },
        'in': function () {
        },
        getAllEnumerableKeys: function () {
        },
        getAllKeys: function () {
        },
        assignSymbols: function (target, source) {
            this.eachKey(source, function (value, key) {
                var symbol = typeReflections.isSymbolLike(canSymbol[key]) ? canSymbol[key] : canSymbol.for(key);
                getSetReflections.setKeyValue(target, symbol, value);
            });
            return target;
        },
        isSerializable: isSerializable,
        size: function (obj) {
            var size = obj[sizeSymbol];
            var count = 0;
            if (size) {
                return size.call(obj);
            } else if (helpers.hasLength(obj)) {
                return obj.length;
            } else if (typeReflections.isListLike(obj)) {
                this.each(obj, function () {
                    count++;
                });
                return count;
            } else if (obj) {
                for (var prop in obj) {
                    if (obj.hasOwnProperty(prop)) {
                        count++;
                    }
                }
                return count;
            } else {
                return undefined;
            }
        }
    };
    shapeReflections.keys = shapeReflections.getOwnEnumerableKeys;
    module.exports = shapeReflections;
});
/*can-reflect@1.7.1#reflections/get-name/get-name*/
define('can-reflect@1.7.1#reflections/get-name/get-name', [
    'require',
    'exports',
    'module',
    'can-symbol',
    '../type/type'
], function (require, exports, module) {
    var canSymbol = require('can-symbol');
    var typeReflections = require('../type/type');
    var getNameSymbol = canSymbol.for('can.getName');
    function setName(obj, nameGetter) {
        if (typeof nameGetter !== 'function') {
            var value = nameGetter;
            nameGetter = function () {
                return value;
            };
        }
        Object.defineProperty(obj, getNameSymbol, { value: nameGetter });
    }
    function getName(obj) {
        var nameGetter = obj[getNameSymbol];
        if (nameGetter) {
            return nameGetter.call(obj);
        }
        if (typeof obj === 'function') {
            return obj.name;
        }
        if (obj.constructor && obj !== obj.constructor) {
            var parent = getName(obj.constructor);
            if (parent) {
                if (typeReflections.isValueLike(obj)) {
                    return parent + '<>';
                }
                if (typeReflections.isMoreListLikeThanMapLike(obj)) {
                    return parent + '[]';
                }
                if (typeReflections.isMapLike(obj)) {
                    return parent + '{}';
                }
            }
        }
        return undefined;
    }
    module.exports = {
        setName: setName,
        getName: getName
    };
});
/*can-reflect@1.7.1#types/map*/
define('can-reflect@1.7.1#types/map', [
    'require',
    'exports',
    'module',
    '../reflections/shape/shape',
    'can-symbol'
], function (require, exports, module) {
    var shape = require('../reflections/shape/shape');
    var CanSymbol = require('can-symbol');
    function keysPolyfill() {
        var keys = [];
        var currentIndex = 0;
        this.forEach(function (val, key) {
            keys.push(key);
        });
        return {
            next: function () {
                return {
                    value: keys[currentIndex],
                    done: currentIndex++ === keys.length
                };
            }
        };
    }
    if (typeof Map !== 'undefined') {
        shape.assignSymbols(Map.prototype, {
            'can.getOwnEnumerableKeys': Map.prototype.keys,
            'can.setKeyValue': Map.prototype.set,
            'can.getKeyValue': Map.prototype.get,
            'can.deleteKeyValue': Map.prototype['delete'],
            'can.hasOwnKey': Map.prototype.has
        });
        if (typeof Map.prototype.keys !== 'function') {
            Map.prototype.keys = Map.prototype[CanSymbol.for('can.getOwnEnumerableKeys')] = keysPolyfill;
        }
    }
    if (typeof WeakMap !== 'undefined') {
        shape.assignSymbols(WeakMap.prototype, {
            'can.getOwnEnumerableKeys': function () {
                throw new Error('can-reflect: WeakMaps do not have enumerable keys.');
            },
            'can.setKeyValue': WeakMap.prototype.set,
            'can.getKeyValue': WeakMap.prototype.get,
            'can.deleteKeyValue': WeakMap.prototype['delete'],
            'can.hasOwnKey': WeakMap.prototype.has
        });
    }
});
/*can-reflect@1.7.1#types/set*/
define('can-reflect@1.7.1#types/set', [
    'require',
    'exports',
    'module',
    '../reflections/shape/shape',
    'can-symbol'
], function (require, exports, module) {
    var shape = require('../reflections/shape/shape');
    var CanSymbol = require('can-symbol');
    if (typeof Set !== 'undefined') {
        shape.assignSymbols(Set.prototype, {
            'can.isMoreListLikeThanMapLike': true,
            'can.updateValues': function (index, removing, adding) {
                if (removing !== adding) {
                    shape.each(removing, function (value) {
                        this.delete(value);
                    }, this);
                }
                shape.each(adding, function (value) {
                    this.add(value);
                }, this);
            },
            'can.size': function () {
                return this.size;
            }
        });
        if (typeof Set.prototype[CanSymbol.iterator] !== 'function') {
            Set.prototype[CanSymbol.iterator] = function () {
                var arr = [];
                var currentIndex = 0;
                this.forEach(function (val) {
                    arr.push(val);
                });
                return {
                    next: function () {
                        return {
                            value: arr[currentIndex],
                            done: currentIndex++ === arr.length
                        };
                    }
                };
            };
        }
    }
    if (typeof WeakSet !== 'undefined') {
        shape.assignSymbols(WeakSet.prototype, {
            'can.isListLike': true,
            'can.isMoreListLikeThanMapLike': true,
            'can.updateValues': function (index, removing, adding) {
                if (removing !== adding) {
                    shape.each(removing, function (value) {
                        this.delete(value);
                    }, this);
                }
                shape.each(adding, function (value) {
                    this.add(value);
                }, this);
            },
            'can.size': function () {
                throw new Error('can-reflect: WeakSets do not have enumerable keys.');
            }
        });
    }
});
/*can-reflect@1.7.1#can-reflect*/
define('can-reflect@1.7.1#can-reflect', [
    'require',
    'exports',
    'module',
    './reflections/call/call',
    './reflections/get-set/get-set',
    './reflections/observe/observe',
    './reflections/shape/shape',
    './reflections/type/type',
    './reflections/get-name/get-name',
    'can-namespace',
    './types/map',
    './types/set'
], function (require, exports, module) {
    var functionReflections = require('./reflections/call/call');
    var getSet = require('./reflections/get-set/get-set');
    var observe = require('./reflections/observe/observe');
    var shape = require('./reflections/shape/shape');
    var type = require('./reflections/type/type');
    var getName = require('./reflections/get-name/get-name');
    var namespace = require('can-namespace');
    var reflect = {};
    [
        functionReflections,
        getSet,
        observe,
        shape,
        type,
        getName
    ].forEach(function (reflections) {
        for (var prop in reflections) {
            reflect[prop] = reflections[prop];
        }
    });
    require('./types/map');
    require('./types/set');
    module.exports = namespace.Reflect = reflect;
});
/*can-globals@0.2.3#can-globals-proto*/
define('can-globals@0.2.3#can-globals-proto', [
    'require',
    'exports',
    'module',
    'can-reflect'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var canReflect = require('can-reflect');
        function dispatch(key, value) {
            var handlers = this.eventHandlers[key];
            if (handlers) {
                var handlersCopy = handlers.slice();
                for (var i = 0; i < handlersCopy.length; i++) {
                    handlersCopy[i](value);
                }
            }
        }
        function Globals() {
            this.eventHandlers = {};
            this.properties = {};
        }
        Globals.prototype.define = function (key, value, enableCache) {
            if (enableCache === undefined) {
                enableCache = true;
            }
            if (!this.properties[key]) {
                this.properties[key] = {
                    default: value,
                    value: value,
                    enableCache: enableCache
                };
            }
            return this;
        };
        Globals.prototype.getKeyValue = function (key) {
            var property = this.properties[key];
            if (property) {
                if (typeof property.value === 'function') {
                    if (property.cachedValue) {
                        return property.cachedValue;
                    }
                    if (property.enableCache) {
                        property.cachedValue = property.value();
                        return property.cachedValue;
                    } else {
                        return property.value();
                    }
                }
                return property.value;
            }
        };
        Globals.prototype.makeExport = function (key) {
            return function (value) {
                if (arguments.length === 0) {
                    return this.getKeyValue(key);
                }
                if (typeof value === 'undefined' || value === null) {
                    this.deleteKeyValue(key);
                } else {
                    if (typeof value === 'function') {
                        this.setKeyValue(key, function () {
                            return value;
                        });
                    } else {
                        this.setKeyValue(key, value);
                    }
                    return value;
                }
            }.bind(this);
        };
        Globals.prototype.offKeyValue = function (key, handler) {
            if (this.properties[key]) {
                var handlers = this.eventHandlers[key];
                if (handlers) {
                    var i = handlers.indexOf(handler);
                    handlers.splice(i, 1);
                }
            }
            return this;
        };
        Globals.prototype.onKeyValue = function (key, handler) {
            if (this.properties[key]) {
                if (!this.eventHandlers[key]) {
                    this.eventHandlers[key] = [];
                }
                this.eventHandlers[key].push(handler);
            }
            return this;
        };
        Globals.prototype.deleteKeyValue = function (key) {
            var property = this.properties[key];
            if (property !== undefined) {
                property.value = property.default;
                property.cachedValue = undefined;
                dispatch.call(this, key, property.value);
            }
            return this;
        };
        Globals.prototype.setKeyValue = function (key, value) {
            if (!this.properties[key]) {
                return this.define(key, value);
            }
            var property = this.properties[key];
            property.value = value;
            property.cachedValue = undefined;
            dispatch.call(this, key, value);
            return this;
        };
        Globals.prototype.reset = function () {
            for (var key in this.properties) {
                if (this.properties.hasOwnProperty(key)) {
                    this.properties[key].cachedValue = undefined;
                    dispatch.call(this, key, this.getKeyValue(key));
                }
            }
            return this;
        };
        canReflect.assignSymbols(Globals.prototype, {
            'can.getKeyValue': Globals.prototype.getKeyValue,
            'can.setKeyValue': Globals.prototype.setKeyValue,
            'can.deleteKeyValue': Globals.prototype.deleteKeyValue,
            'can.onKeyValue': Globals.prototype.onKeyValue,
            'can.offKeyValue': Globals.prototype.offKeyValue
        });
        module.exports = Globals;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-globals@0.2.3#can-globals-instance*/
define('can-globals@0.2.3#can-globals-instance', [
    'require',
    'exports',
    'module',
    'can-namespace',
    './can-globals-proto'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var namespace = require('can-namespace');
        var Globals = require('./can-globals-proto');
        var globals = new Globals();
        if (namespace.globals) {
            throw new Error('You can\'t have two versions of can-globals, check your dependencies');
        } else {
            module.exports = namespace.globals = globals;
        }
        module.exports = globals;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-globals@0.2.3#global/global*/
define('can-globals@0.2.3#global/global', [
    'require',
    'exports',
    'module',
    'can-globals/can-globals-instance'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var globals = require('can-globals/can-globals-instance');
        globals.define('global', function () {
            return typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope ? self : typeof process === 'object' && {}.toString.call(process) === '[object process]' ? global : window;
        });
        module.exports = globals.makeExport('global');
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-globals@0.2.3#document/document*/
define('can-globals@0.2.3#document/document', [
    'require',
    'exports',
    'module',
    'can-globals/global/global',
    'can-globals/can-globals-instance'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        require('can-globals/global/global');
        var globals = require('can-globals/can-globals-instance');
        globals.define('document', function () {
            return globals.getKeyValue('global').document;
        });
        module.exports = globals.makeExport('document');
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-globals@0.2.3#location/location*/
define('can-globals@0.2.3#location/location', [
    'require',
    'exports',
    'module',
    'can-globals/global/global',
    'can-globals/can-globals-instance'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        require('can-globals/global/global');
        var globals = require('can-globals/can-globals-instance');
        globals.define('location', function () {
            return globals.getKeyValue('global').location;
        });
        module.exports = globals.makeExport('location');
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-globals@0.2.3#mutation-observer/mutation-observer*/
define('can-globals@0.2.3#mutation-observer/mutation-observer', [
    'require',
    'exports',
    'module',
    'can-globals/global/global',
    'can-globals/can-globals-instance'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        require('can-globals/global/global');
        var globals = require('can-globals/can-globals-instance');
        globals.define('MutationObserver', function () {
            var GLOBAL = globals.getKeyValue('global');
            return GLOBAL.MutationObserver || GLOBAL.WebKitMutationObserver || GLOBAL.MozMutationObserver;
        });
        module.exports = globals.makeExport('MutationObserver');
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-globals@0.2.3#is-browser-window/is-browser-window*/
define('can-globals@0.2.3#is-browser-window/is-browser-window', [
    'require',
    'exports',
    'module',
    'can-globals/can-globals-instance'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var globals = require('can-globals/can-globals-instance');
        globals.define('isBrowserWindow', function () {
            return typeof window !== 'undefined' && typeof document !== 'undefined' && typeof SimpleDOM === 'undefined';
        });
        module.exports = globals.makeExport('isBrowserWindow');
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-globals@0.2.3#can-globals*/
define('can-globals@0.2.3#can-globals', [
    'require',
    'exports',
    'module',
    'can-globals/can-globals-instance',
    './global/global',
    './document/document',
    './location/location',
    './mutation-observer/mutation-observer',
    './is-browser-window/is-browser-window'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var globals = require('can-globals/can-globals-instance');
        require('./global/global');
        require('./document/document');
        require('./location/location');
        require('./mutation-observer/mutation-observer');
        require('./is-browser-window/is-browser-window');
        module.exports = globals;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-util@3.10.12#dom/mutation-observer/mutation-observer*/
define('can-util@3.10.12#dom/mutation-observer/mutation-observer', [
    'require',
    'exports',
    'module',
    'can-globals'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var globals = require('can-globals');
        module.exports = function (setMO) {
            if (setMO !== undefined) {
                globals.setKeyValue('MutationObserver', function () {
                    return setMO;
                });
            }
            return globals.getKeyValue('MutationObserver');
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-util@3.10.12#dom/document/document*/
define('can-util@3.10.12#dom/document/document', [
    'require',
    'exports',
    'module',
    'can-globals/document/document'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        module.exports = require('can-globals/document/document');
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-simple-dom@1.3.0#simple-dom/document/node*/
define('can-simple-dom@1.3.0#simple-dom/document/node', ['exports'], function (exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    function Node(nodeType, nodeName, nodeValue, ownerDocument) {
        this.nodeType = nodeType;
        this.nodeName = nodeName;
        this.nodeValue = nodeValue;
        this.ownerDocument = ownerDocument;
        this.childNodes = new ChildNodes(this);
        this.parentNode = null;
        this.previousSibling = null;
        this.nextSibling = null;
        this.firstChild = null;
        this.lastChild = null;
    }
    Node.prototype._cloneNode = function () {
        return new Node(this.nodeType, this.nodeName, this.nodeValue, this.ownerDocument);
    };
    Node.prototype.cloneNode = function (deep) {
        var node = this._cloneNode();
        if (deep) {
            var child = this.firstChild, nextChild = child;
            while (nextChild) {
                nextChild = child.nextSibling;
                nodeAppendChild.call(node, child.cloneNode(true));
                child = nextChild;
            }
        }
        return node;
    };
    var nodeAppendChild = Node.prototype.appendChild = function (node) {
        if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
            insertFragment(node, this, this.lastChild, null);
            return node;
        }
        if (node.parentNode) {
            nodeRemoveChild.call(node.parentNode, node);
        }
        node.parentNode = this;
        var refNode = this.lastChild;
        if (refNode === null) {
            this.firstChild = node;
            this.lastChild = node;
        } else {
            node.previousSibling = refNode;
            refNode.nextSibling = node;
            this.lastChild = node;
        }
        ensureOwnerDocument(this, node);
        return node;
    };
    function insertFragment(fragment, newParent, before, after) {
        if (!fragment.firstChild) {
            return;
        }
        var firstChild = fragment.firstChild;
        var lastChild = firstChild;
        var node = firstChild;
        firstChild.previousSibling = before;
        if (before) {
            before.nextSibling = firstChild;
        } else {
            newParent.firstChild = firstChild;
        }
        while (node) {
            node.parentNode = newParent;
            ensureOwnerDocument(newParent, node);
            lastChild = node;
            node = node.nextSibling;
        }
        lastChild.nextSibling = after;
        if (after) {
            after.previousSibling = lastChild;
        } else {
            newParent.lastChild = lastChild;
        }
        fragment.firstChild = null;
        fragment.lastChild = null;
    }
    function ensureOwnerDocument(parent, child) {
        var ownerDocument = parent.nodeType === 9 ? parent : parent.ownerDocument;
        if (parent.ownerDocument !== child.ownerDocument) {
            var node = child;
            while (node) {
                node.ownerDocument = ownerDocument;
                if (node.firstChild) {
                    ensureOwnerDocument(node, node.firstChild);
                }
                node = node.nextSibling;
            }
        }
    }
    var nodeInsertBefore = Node.prototype.insertBefore = function (node, refNode) {
        if (refNode == null) {
            return nodeAppendChild.call(this, node);
        }
        if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
            insertFragment(node, this, refNode ? refNode.previousSibling : null, refNode);
            return node;
        }
        if (node.parentNode) {
            nodeRemoveChild.call(node.parentNode, node);
        }
        node.parentNode = this;
        var previousSibling = refNode.previousSibling;
        if (previousSibling) {
            previousSibling.nextSibling = node;
            node.previousSibling = previousSibling;
        }
        refNode.previousSibling = node;
        node.nextSibling = refNode;
        if (this.firstChild === refNode) {
            this.firstChild = node;
        }
        ensureOwnerDocument(this, node);
        return node;
    };
    var nodeRemoveChild = Node.prototype.removeChild = function (refNode) {
        if (this.firstChild === refNode) {
            this.firstChild = refNode.nextSibling;
        }
        if (this.lastChild === refNode) {
            this.lastChild = refNode.previousSibling;
        }
        if (refNode.previousSibling) {
            refNode.previousSibling.nextSibling = refNode.nextSibling;
        }
        if (refNode.nextSibling) {
            refNode.nextSibling.previousSibling = refNode.previousSibling;
        }
        refNode.parentNode = null;
        refNode.nextSibling = null;
        refNode.previousSibling = null;
        return refNode;
    };
    Node.prototype.replaceChild = function (newChild, oldChild) {
        nodeInsertBefore.call(this, newChild, oldChild);
        nodeRemoveChild.call(this, oldChild);
        return oldChild;
    };
    Node.prototype.addEventListener = function () {
    };
    Node.prototype.removeEventListener = function () {
    };
    Node.ELEMENT_NODE = 1;
    Node.ATTRIBUTE_NODE = 2;
    Node.TEXT_NODE = 3;
    Node.CDATA_SECTION_NODE = 4;
    Node.ENTITY_REFERENCE_NODE = 5;
    Node.ENTITY_NODE = 6;
    Node.PROCESSING_INSTRUCTION_NODE = 7;
    Node.COMMENT_NODE = 8;
    Node.DOCUMENT_NODE = 9;
    Node.DOCUMENT_TYPE_NODE = 10;
    Node.DOCUMENT_FRAGMENT_NODE = 11;
    Node.NOTATION_NODE = 12;
    function ChildNodes(node) {
        this.node = node;
    }
    ChildNodes.prototype.item = function (index) {
        var child = this.node.firstChild;
        for (var i = 0; child && index !== i; i++) {
            child = child.nextSibling;
        }
        return child;
    };
    exports.default = Node;
    exports.nodeRemoveChild = nodeRemoveChild;
});
/*can-simple-dom@1.3.0#simple-dom/document/style*/
define('can-simple-dom@1.3.0#simple-dom/document/style', ['exports'], function (exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    function CSSStyleDeclaration(node) {
        this.__node = node;
    }
    CSSStyleDeclaration.prototype.getPropertyValue = function () {
    };
    Object.defineProperty(CSSStyleDeclaration.prototype, 'cssText', {
        enumerable: true,
        configurable: true,
        get: function get() {
            return this.__node.getAttribute('style') || '';
        },
        set: function set(val) {
            this.__node._setAttribute('style', val);
        }
    });
    exports.default = CSSStyleDeclaration;
});
/*can-simple-dom@1.3.0#simple-dom/document/element*/
define('can-simple-dom@1.3.0#simple-dom/document/element', [
    'exports',
    './node',
    './style'
], function (exports, _node, _style) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    var _node2 = _interopRequireDefault(_node);
    var _style2 = _interopRequireDefault(_style);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    var attrSpecial = {
        'class': function _class(element, value) {
            element._className = value;
        }
    };
    function Element(tagName, ownerDocument) {
        tagName = tagName.toUpperCase();
        this.nodeConstructor(1, tagName, null, ownerDocument);
        this.style = new _style2.default(this);
        this.attributes = [];
        this.tagName = tagName;
    }
    Element.prototype = Object.create(_node2.default.prototype);
    Element.prototype.constructor = Element;
    Element.prototype.nodeConstructor = _node2.default;
    Element.prototype._cloneNode = function () {
        var node = this.ownerDocument.createElement(this.tagName);
        node.attributes = this.attributes.map(function (attr) {
            return {
                name: attr.name,
                value: attr.value,
                specified: attr.specified
            };
        });
        return node;
    };
    Element.prototype.getAttribute = function (_name) {
        var attributes = this.attributes;
        var name = _name.toLowerCase();
        var attr;
        for (var i = 0, l = attributes.length; i < l; i++) {
            attr = attributes[i];
            if (attr.name === name) {
                return attr.value;
            }
        }
        return null;
    };
    Element.prototype.setAttribute = function () {
        return this._setAttribute.apply(this, arguments);
    };
    Element.prototype._setAttribute = function (_name, value) {
        var attributes = this.attributes;
        var name = _name.toLowerCase();
        var attr;
        for (var i = 0, l = attributes.length; i < l; i++) {
            attr = attributes[i];
            if (attr.name === name) {
                attr.value = value;
                return;
            }
        }
        attributes.push({
            name: name,
            value: value,
            specified: true
        });
        attributes[name] = value;
        var special = attrSpecial[name];
        if (special) {
            special(this, value);
        }
    };
    Element.prototype.hasAttribute = function (_name) {
        var attributes = this.attributes;
        var name = _name.toLowerCase();
        var attr;
        for (var i = 0, len = attributes.length; i < len; i++) {
            attr = attributes[i];
            if (attr.name === name) {
                return true;
            }
        }
        return false;
    };
    Element.prototype.removeAttribute = function (name) {
        var attributes = this.attributes;
        for (var i = 0, l = attributes.length; i < l; i++) {
            var attr = attributes[i];
            if (attr.name === name) {
                attributes.splice(i, 1);
                delete attributes[name];
                return;
            }
        }
    };
    Element.prototype.getElementsByTagName = function (name) {
        name = name.toUpperCase();
        var elements = [];
        var cur = this.firstChild;
        while (cur) {
            if (cur.nodeType === _node2.default.ELEMENT_NODE) {
                if (cur.nodeName === name || name === '*') {
                    elements.push(cur);
                }
                elements.push.apply(elements, cur.getElementsByTagName(name));
            }
            cur = cur.nextSibling;
        }
        return elements;
    };
    Element.prototype.contains = function (child) {
        child = child.parentNode;
        while (child) {
            if (child === this) {
                return true;
            }
            child = child.parentNode;
        }
        return false;
    };
    Element.prototype.getElementById = function (id) {
        var cur = this.firstChild, child;
        while (cur) {
            if (cur.attributes && cur.attributes.length) {
                var attr;
                for (var i = 0, len = cur.attributes.length; i < len; i++) {
                    attr = cur.attributes[i];
                    if (attr.name === 'id' && attr.value === id) {
                        return cur;
                    }
                }
            }
            if (cur.getElementById) {
                child = cur.getElementById(id);
                if (child) {
                    return child;
                }
            }
            cur = cur.nextSibling;
        }
    };
    function Style(node) {
        this.__node = node;
    }
    if (Object.defineProperty) {
        Object.defineProperty(Element.prototype, 'className', {
            configurable: true,
            enumerable: true,
            get: function get() {
                return this._className || '';
            },
            set: function set(val) {
                this._setAttribute('class', val);
                this._className = val;
            }
        });
        Object.defineProperty(Element.prototype, 'innerHTML', {
            configurable: true,
            enumerable: true,
            get: function get() {
                var html = '';
                var cur = this.firstChild;
                while (cur) {
                    html += this.ownerDocument.__serializer.serialize(cur);
                    cur = cur.nextSibling;
                }
                return html;
            },
            set: function set(html) {
                this.lastChild = this.firstChild = null;
                var fragment;
                if (this.nodeName === 'SCRIPT' || this.nodeName === 'STYLE') {
                    fragment = this.ownerDocument.createTextNode(html);
                } else {
                    fragment = this.ownerDocument.__parser.parse(html);
                }
                this.appendChild(fragment);
            }
        });
        Object.defineProperty(Element.prototype, 'outerHTML', {
            get: function get() {
                return this.ownerDocument.__serializer.serialize(this);
            },
            set: function set(html) {
                this.parentNode.replaceChild(this.ownerDocument.__parser.parse(html), this);
            }
        });
        Object.defineProperty(Element.prototype, 'textContent', {
            get: function get() {
                var fc = this.firstChild;
                return fc && fc.nodeValue || '';
            },
            set: function set(val) {
                while (this.firstChild) {
                    _node.nodeRemoveChild.call(this, this.firstChild);
                }
                var tn = this.ownerDocument.createTextNode(val);
                this.appendChild(tn);
            }
        });
    }
    exports.default = Element;
});
/*can-simple-dom@1.3.0#simple-dom/document/text*/
define('can-simple-dom@1.3.0#simple-dom/document/text', [
    'exports',
    './node'
], function (exports, _node) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    var _node2 = _interopRequireDefault(_node);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    function Text(text, ownerDocument) {
        this.nodeConstructor(3, '#text', text, ownerDocument);
    }
    Text.prototype._cloneNode = function () {
        return this.ownerDocument.createTextNode(this.nodeValue);
    };
    Text.prototype = Object.create(_node2.default.prototype);
    Text.prototype.constructor = Text;
    Text.prototype.nodeConstructor = _node2.default;
    exports.default = Text;
});
/*can-simple-dom@1.3.0#simple-dom/document/comment*/
define('can-simple-dom@1.3.0#simple-dom/document/comment', [
    'exports',
    './node'
], function (exports, _node) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    var _node2 = _interopRequireDefault(_node);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    function Comment(text, ownerDocument) {
        this.nodeConstructor(8, '#comment', text, ownerDocument);
    }
    Comment.prototype._cloneNode = function () {
        return this.ownerDocument.createComment(this.nodeValue);
    };
    Comment.prototype = Object.create(_node2.default.prototype);
    Comment.prototype.constructor = Comment;
    Comment.prototype.nodeConstructor = _node2.default;
    exports.default = Comment;
});
/*can-simple-dom@1.3.0#simple-dom/document/document-fragment*/
define('can-simple-dom@1.3.0#simple-dom/document/document-fragment', [
    'exports',
    './node'
], function (exports, _node) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    var _node2 = _interopRequireDefault(_node);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    function DocumentFragment(ownerDocument) {
        this.nodeConstructor(11, '#document-fragment', null, ownerDocument);
    }
    DocumentFragment.prototype._cloneNode = function () {
        return this.ownerDocument.createDocumentFragment();
    };
    DocumentFragment.prototype = Object.create(_node2.default.prototype);
    DocumentFragment.prototype.constructor = DocumentFragment;
    DocumentFragment.prototype.nodeConstructor = _node2.default;
    exports.default = DocumentFragment;
});
/*micro-location@0.1.5#lib/micro-location*/
function Location() {
    this.init.apply(this, arguments);
}
Location.prototype = {
    init: function (protocol, host, hostname, port, pathname, search, hash) {
        this.protocol = protocol;
        this.host = host;
        this.hostname = hostname;
        this.port = port || '';
        this.pathname = pathname || '';
        this.search = search || '';
        this.hash = hash || '';
        if (protocol) {
            with (this)
                this.href = protocol + '//' + host + pathname + search + hash;
        } else if (host) {
            with (this)
                this.href = '//' + host + pathname + search + hash;
        } else {
            with (this)
                this.href = pathname + search + hash;
        }
    },
    params: function (name) {
        if (!this._params) {
            var params = {};
            var pairs = this.search.substring(1).split(/[;&]/);
            for (var i = 0, len = pairs.length; i < len; i++) {
                if (!pairs[i])
                    continue;
                var pair = pairs[i].split(/=/);
                var key = decodeURIComponent(pair[0].replace(/\+/g, '%20'));
                var val = decodeURIComponent(pair[1].replace(/\+/g, '%20'));
                if (!params[key])
                    params[key] = [];
                params[key].push(val);
            }
            this._params = params;
        }
        switch (typeof name) {
        case 'undefined':
            return this._params;
        case 'object':
            return this.build(name);
        }
        return this._params[name] ? this._params[name][0] : null;
    },
    build: function (params) {
        if (!params)
            params = this._params;
        var ret = new Location();
        var _search = this.search;
        if (params) {
            var search = [];
            for (var key in params)
                if (params.hasOwnProperty(key)) {
                    var val = params[key];
                    switch (typeof val) {
                    case 'object':
                        for (var i = 0, len = val.length; i < len; i++) {
                            search.push(encodeURIComponent(key) + '=' + encodeURIComponent(val[i]));
                        }
                        break;
                    default:
                        search.push(encodeURIComponent(key) + '=' + encodeURIComponent(val));
                    }
                }
            _search = '?' + search.join('&');
        }
        with (this)
            ret.init.apply(ret, [
                protocol,
                host,
                hostname,
                port,
                pathname,
                _search,
                hash
            ]);
        return ret;
    }
};
Location.regexp = new RegExp('^(?:(https?:)//(([^:/]+)(:[^/]+)?))?([^#?]*)(\\?[^#]*)?(#.*)?$');
Location.parse = function (string) {
    var matched = String(string).match(this.regexp);
    var ret = new Location();
    ret.init.apply(ret, matched.slice(1));
    return ret;
};
(function (root, factory) {
    if (typeof module === 'object' && module.exports) {
        module.exports = { Location: factory() };
    } else if (typeof define === 'function' && define.amd) {
        define('micro-location@0.1.5#lib/micro-location', [], function () {
            return { Location: factory() };
        });
    } else {
        root.Location = factory();
    }
}(this, function () {
    return Location;
}));
/*can-simple-dom@1.3.0#simple-dom/extend*/
define('can-simple-dom@1.3.0#simple-dom/extend', ['exports'], function (exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.default = function (a, b) {
        for (var p in b) {
            a[p] = b[p];
        }
        return a;
    };
    ;
});
/*can-simple-dom@1.3.0#simple-dom/document/anchor-element*/
define('can-simple-dom@1.3.0#simple-dom/document/anchor-element', [
    'exports',
    './element',
    'micro-location',
    '../extend'
], function (exports, _element, _microLocation, _extend) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    var _element2 = _interopRequireDefault(_element);
    var _microLocation2 = _interopRequireDefault(_microLocation);
    var _extend2 = _interopRequireDefault(_extend);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    var Location = _microLocation2.default.Location || _microLocation2.default;
    function AnchorElement(tagName, ownerDocument) {
        this.elementConstructor(tagName, ownerDocument);
        (0, _extend2.default)(this, Location.parse(''));
    }
    AnchorElement.prototype = Object.create(_element2.default.prototype);
    AnchorElement.prototype.constructor = AnchorElement;
    AnchorElement.prototype.elementConstructor = _element2.default;
    AnchorElement.prototype.setAttribute = function (_name, value) {
        _element2.default.prototype.setAttribute.apply(this, arguments);
        if (_name.toLowerCase() === 'href') {
            (0, _extend2.default)(this, Location.parse(value));
        }
    };
    exports.default = AnchorElement;
});
/*can-simple-dom@1.3.0#simple-dom/document/utils*/
define('can-simple-dom@1.3.0#simple-dom/document/utils', ['exports'], function (exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.propToAttr = propToAttr;
    function propToAttr(Element, name) {
        Object.defineProperty(Element.prototype, name, {
            configurable: true,
            enumerable: true,
            get: function get() {
                return this.getAttribute(name);
            },
            set: function set(val) {
                this.setAttribute(name, val);
            }
        });
    }
    ;
});
/*can-simple-dom@1.3.0#simple-dom/document/input-element*/
define('can-simple-dom@1.3.0#simple-dom/document/input-element', [
    'exports',
    './element',
    './utils.js'
], function (exports, _element, _utils) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    var _element2 = _interopRequireDefault(_element);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    function InputElement(tagName, ownerDocument) {
        this.elementConstructor(tagName, ownerDocument);
    }
    InputElement.prototype = Object.create(_element2.default.prototype);
    InputElement.prototype.constructor = InputElement;
    InputElement.prototype.elementConstructor = _element2.default;
    (0, _utils.propToAttr)(InputElement, 'type');
    (0, _utils.propToAttr)(InputElement, 'value');
    Object.defineProperty(InputElement.prototype, 'checked', {
        configurable: true,
        enumerable: true,
        get: function get() {
            return this.hasAttribute('checked');
        },
        set: function set(value) {
            if (value) {
                this.setAttribute('checked', '');
            } else {
                this.removeAttribute('checked');
            }
        }
    });
    exports.default = InputElement;
});
/*can-simple-dom@1.3.0#simple-dom/document/option-element*/
define('can-simple-dom@1.3.0#simple-dom/document/option-element', [
    'exports',
    './element',
    './utils'
], function (exports, _element, _utils) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    var _element2 = _interopRequireDefault(_element);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    function OptionElement(tagName, ownerDocument) {
        this.elementConstructor(tagName, ownerDocument);
    }
    OptionElement.prototype = Object.create(_element2.default.prototype);
    OptionElement.prototype.constructor = OptionElement;
    OptionElement.prototype.elementConstructor = _element2.default;
    (0, _utils.propToAttr)(OptionElement, 'value');
    Object.defineProperty(OptionElement.prototype, 'selected', {
        enumerable: true,
        configurable: true,
        get: function get() {
            var val = this.value || '';
            var parent = this.parentNode;
            return parent && parent.value == val;
        },
        set: function set(val) {
            if (val) {
                var parent = this.parentNode;
                if (parent) {
                    parent.value = this.value;
                }
            }
        }
    });
    exports.default = OptionElement;
});
/*can-simple-dom@1.3.0#simple-dom/document/select-element*/
define('can-simple-dom@1.3.0#simple-dom/document/select-element', [
    'exports',
    './element',
    './utils'
], function (exports, _element, _utils) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    var _element2 = _interopRequireDefault(_element);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    function SelectElement(tagName, ownerDocument) {
        this.elementConstructor(tagName, ownerDocument);
        this.selectedIndex = 0;
    }
    SelectElement.prototype = Object.create(_element2.default.prototype);
    SelectElement.prototype.constructor = SelectElement;
    SelectElement.prototype.elementConstructor = _element2.default;
    (0, _utils.propToAttr)(SelectElement, 'value');
    exports.default = SelectElement;
});
/*can-simple-dom@1.3.0#simple-dom/document*/
define('can-simple-dom@1.3.0#simple-dom/document', [
    'exports',
    './document/node',
    './document/element',
    './document/text',
    './document/comment',
    './document/document-fragment',
    './document/anchor-element',
    './document/input-element',
    './document/option-element',
    './document/select-element'
], function (exports, _node, _element, _text, _comment, _documentFragment, _anchorElement, _inputElement, _optionElement, _selectElement) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    var _node2 = _interopRequireDefault(_node);
    var _element2 = _interopRequireDefault(_element);
    var _text2 = _interopRequireDefault(_text);
    var _comment2 = _interopRequireDefault(_comment);
    var _documentFragment2 = _interopRequireDefault(_documentFragment);
    var _anchorElement2 = _interopRequireDefault(_anchorElement);
    var _inputElement2 = _interopRequireDefault(_inputElement);
    var _optionElement2 = _interopRequireDefault(_optionElement);
    var _selectElement2 = _interopRequireDefault(_selectElement);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    var noop = Function.prototype;
    function Document() {
        this.nodeConstructor(9, '#document', null, this);
        var documentElement = new _element2.default('html', this);
        var body = new _element2.default('body', this);
        var head = new _element2.default('head', this);
        documentElement.appendChild(head);
        documentElement.appendChild(body);
        this.appendChild(documentElement);
        var self = this;
        this.implementation = {
            createHTMLDocument: function createHTMLDocument(content) {
                var document = new Document();
                var frag = self.__parser.parse(content);
                var body = _element2.default.prototype.getElementsByTagName.call(frag, 'body')[0];
                var head = _element2.default.prototype.getElementsByTagName.call(frag, 'head')[0];
                if (!body && !head) {
                    document.body.appendChild(frag);
                } else {
                    if (body) {
                        document.documentElement.replaceChild(body, document.body);
                    }
                    if (head) {
                        document.documentElement.replaceChild(head, document.head);
                    }
                    document.documentElement.appendChild(frag);
                }
                document.__addSerializerAndParser(self.__serializer, self.__parser);
                return document;
            }
        };
    }
    Document.prototype = Object.create(_node2.default.prototype);
    Document.prototype.constructor = Document;
    Document.prototype.nodeConstructor = _node2.default;
    var specialElements = {
        'a': _anchorElement2.default,
        'input': _inputElement2.default,
        'option': _optionElement2.default,
        'select': _selectElement2.default
    };
    Document.prototype.createElement = function (tagName) {
        var Special = specialElements[tagName.toLowerCase()];
        if (Special) {
            return new Special(tagName, this);
        }
        return new _element2.default(tagName, this);
    };
    Document.prototype.createTextNode = function (text) {
        return new _text2.default(text, this);
    };
    Document.prototype.createComment = function (text) {
        return new _comment2.default(text, this);
    };
    Document.prototype.createDocumentFragment = function () {
        return new _documentFragment2.default(this);
    };
    Document.prototype.getElementsByTagName = function (name) {
        name = name.toUpperCase();
        var elements = [];
        var cur = this.firstChild;
        while (cur) {
            if (cur.nodeType === _node2.default.ELEMENT_NODE) {
                if (cur.nodeName === name || name === '*') {
                    elements.push(cur);
                }
                elements.push.apply(elements, cur.getElementsByTagName(name));
            }
            cur = cur.nextSibling;
        }
        return elements;
    };
    Document.prototype.getElementById = function (id) {
        return _element2.default.prototype.getElementById.apply(this.documentElement, arguments);
    };
    Document.prototype.__addSerializerAndParser = function (serializer, parser) {
        this.__parser = parser;
        this.__serializer = serializer;
    };
    if (Object.defineProperty) {
        var firstOfKind = function firstOfKind(root, nodeName) {
            if (root == null)
                return null;
            var node = root.firstChild;
            while (node) {
                if (node.nodeName === nodeName) {
                    return node;
                }
                node = node.nextSibling;
            }
            return null;
        };
        Object.defineProperty(Document.prototype, 'currentScript', {
            get: function get() {
                var scripts = this.getElementsByTagName('script');
                var first = scripts[scripts.length - 1];
                if (!first) {
                    first = this.createElement('script');
                }
                return first;
            }
        });
        Object.defineProperty(Document.prototype, 'documentElement', {
            get: function get() {
                return this.firstChild;
            },
            set: noop
        });
        [
            'head',
            'body'
        ].forEach(function (localName) {
            var nodeName = localName.toUpperCase();
            Object.defineProperty(Document.prototype, localName, {
                get: function get() {
                    return firstOfKind(this.documentElement, nodeName);
                },
                set: noop
            });
        });
    }
    exports.default = Document;
});
/*can-simple-dom@1.3.0#simple-dom/event*/
define('can-simple-dom@1.3.0#simple-dom/event', [
    'exports',
    './document/node',
    './document'
], function (exports, _node, _document) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    var _node2 = _interopRequireDefault(_node);
    var _document2 = _interopRequireDefault(_document);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    var Event = function Event() {
    };
    Event.prototype.initEvent = function (type, bubbles, cancelable) {
        this.type = type;
        this.bubbles = !!bubbles;
        this.cancelable = !!cancelable;
    };
    Event.prototype.stopPropagation = function () {
        this.isPropagationStopped = true;
    };
    Event.prototype.preventDefault = function () {
        this.isDefaultPrevented = true;
    };
    _document2.default.prototype.createEvent = function (type) {
        return new Event();
    };
    _node2.default.prototype.addEventListener = function (event, handler, capture) {
        if (!this.__handlers) {
            Object.defineProperty(this, '__handlers', {
                value: {},
                enumerable: false
            });
        }
        var phase = capture ? 'capture' : 'bubble';
        var handlersByType = this.__handlers[event + ' ' + phase];
        if (!handlersByType) {
            handlersByType = this.__handlers[event + ' ' + phase] = [];
        }
        handlersByType.push(handler);
    };
    _node2.default.prototype.removeEventListener = function (event, handler, capture) {
        if (this.__handlers) {
            var phase = capture ? 'capture' : 'bubble';
            var handlersByType = this.__handlers[event + ' ' + phase];
            if (handlersByType) {
                var index = 0;
                while (index < handlersByType.length) {
                    if (handlersByType[index] === handler) {
                        handlersByType.splice(index, 1);
                    } else {
                        index++;
                    }
                }
            }
        }
    };
    _node2.default.prototype.dispatchEvent = function (event) {
        event.target = this;
        var cur = this;
        var dispatchHandlers = [];
        do {
            var handlers = cur.__handlers && cur.__handlers[event.type + ' bubble'];
            if (handlers) {
                dispatchHandlers.push({
                    node: cur,
                    handlers: handlers
                });
            }
            cur = cur.parentNode;
        } while (event.bubbles && cur);
        for (var i = 0; i < dispatchHandlers.length; i++) {
            var dispatches = dispatchHandlers[i];
            event.currentTarget = dispatches.node;
            for (var h = 0; h < dispatches.handlers.length; h++) {
                var handler = dispatches.handlers[h];
                var res = handler.call(this, event);
                if (res) {
                    event.stopPropagation();
                    event.preventDefault();
                }
                if (event.isImmediatePropagationStopped) {
                    return !event.isDefaultPrevented;
                }
            }
            if (event.isPropagationStopped) {
                return !event.isDefaultPrevented;
            }
        }
        return !event.isDefaultPrevented;
    };
    exports.default = Event;
});
/*he@1.1.1#he*/
;
(function (root) {
    var freeExports = typeof exports == 'object' && exports;
    var freeModule = typeof module == 'object' && module && module.exports == freeExports && module;
    var freeGlobal = typeof global == 'object' && global;
    if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
        root = freeGlobal;
    }
    var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    var regexAsciiWhitelist = /[\x01-\x7F]/g;
    var regexBmpWhitelist = /[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g;
    var regexEncodeNonAscii = /<\u20D2|=\u20E5|>\u20D2|\u205F\u200A|\u219D\u0338|\u2202\u0338|\u2220\u20D2|\u2229\uFE00|\u222A\uFE00|\u223C\u20D2|\u223D\u0331|\u223E\u0333|\u2242\u0338|\u224B\u0338|\u224D\u20D2|\u224E\u0338|\u224F\u0338|\u2250\u0338|\u2261\u20E5|\u2264\u20D2|\u2265\u20D2|\u2266\u0338|\u2267\u0338|\u2268\uFE00|\u2269\uFE00|\u226A\u0338|\u226A\u20D2|\u226B\u0338|\u226B\u20D2|\u227F\u0338|\u2282\u20D2|\u2283\u20D2|\u228A\uFE00|\u228B\uFE00|\u228F\u0338|\u2290\u0338|\u2293\uFE00|\u2294\uFE00|\u22B4\u20D2|\u22B5\u20D2|\u22D8\u0338|\u22D9\u0338|\u22DA\uFE00|\u22DB\uFE00|\u22F5\u0338|\u22F9\u0338|\u2933\u0338|\u29CF\u0338|\u29D0\u0338|\u2A6D\u0338|\u2A70\u0338|\u2A7D\u0338|\u2A7E\u0338|\u2AA1\u0338|\u2AA2\u0338|\u2AAC\uFE00|\u2AAD\uFE00|\u2AAF\u0338|\u2AB0\u0338|\u2AC5\u0338|\u2AC6\u0338|\u2ACB\uFE00|\u2ACC\uFE00|\u2AFD\u20E5|[\xA0-\u0113\u0116-\u0122\u0124-\u012B\u012E-\u014D\u0150-\u017E\u0192\u01B5\u01F5\u0237\u02C6\u02C7\u02D8-\u02DD\u0311\u0391-\u03A1\u03A3-\u03A9\u03B1-\u03C9\u03D1\u03D2\u03D5\u03D6\u03DC\u03DD\u03F0\u03F1\u03F5\u03F6\u0401-\u040C\u040E-\u044F\u0451-\u045C\u045E\u045F\u2002-\u2005\u2007-\u2010\u2013-\u2016\u2018-\u201A\u201C-\u201E\u2020-\u2022\u2025\u2026\u2030-\u2035\u2039\u203A\u203E\u2041\u2043\u2044\u204F\u2057\u205F-\u2063\u20AC\u20DB\u20DC\u2102\u2105\u210A-\u2113\u2115-\u211E\u2122\u2124\u2127-\u2129\u212C\u212D\u212F-\u2131\u2133-\u2138\u2145-\u2148\u2153-\u215E\u2190-\u219B\u219D-\u21A7\u21A9-\u21AE\u21B0-\u21B3\u21B5-\u21B7\u21BA-\u21DB\u21DD\u21E4\u21E5\u21F5\u21FD-\u2205\u2207-\u2209\u220B\u220C\u220F-\u2214\u2216-\u2218\u221A\u221D-\u2238\u223A-\u2257\u2259\u225A\u225C\u225F-\u2262\u2264-\u228B\u228D-\u229B\u229D-\u22A5\u22A7-\u22B0\u22B2-\u22BB\u22BD-\u22DB\u22DE-\u22E3\u22E6-\u22F7\u22F9-\u22FE\u2305\u2306\u2308-\u2310\u2312\u2313\u2315\u2316\u231C-\u231F\u2322\u2323\u232D\u232E\u2336\u233D\u233F\u237C\u23B0\u23B1\u23B4-\u23B6\u23DC-\u23DF\u23E2\u23E7\u2423\u24C8\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2550-\u256C\u2580\u2584\u2588\u2591-\u2593\u25A1\u25AA\u25AB\u25AD\u25AE\u25B1\u25B3-\u25B5\u25B8\u25B9\u25BD-\u25BF\u25C2\u25C3\u25CA\u25CB\u25EC\u25EF\u25F8-\u25FC\u2605\u2606\u260E\u2640\u2642\u2660\u2663\u2665\u2666\u266A\u266D-\u266F\u2713\u2717\u2720\u2736\u2758\u2772\u2773\u27C8\u27C9\u27E6-\u27ED\u27F5-\u27FA\u27FC\u27FF\u2902-\u2905\u290C-\u2913\u2916\u2919-\u2920\u2923-\u292A\u2933\u2935-\u2939\u293C\u293D\u2945\u2948-\u294B\u294E-\u2976\u2978\u2979\u297B-\u297F\u2985\u2986\u298B-\u2996\u299A\u299C\u299D\u29A4-\u29B7\u29B9\u29BB\u29BC\u29BE-\u29C5\u29C9\u29CD-\u29D0\u29DC-\u29DE\u29E3-\u29E5\u29EB\u29F4\u29F6\u2A00-\u2A02\u2A04\u2A06\u2A0C\u2A0D\u2A10-\u2A17\u2A22-\u2A27\u2A29\u2A2A\u2A2D-\u2A31\u2A33-\u2A3C\u2A3F\u2A40\u2A42-\u2A4D\u2A50\u2A53-\u2A58\u2A5A-\u2A5D\u2A5F\u2A66\u2A6A\u2A6D-\u2A75\u2A77-\u2A9A\u2A9D-\u2AA2\u2AA4-\u2AB0\u2AB3-\u2AC8\u2ACB\u2ACC\u2ACF-\u2ADB\u2AE4\u2AE6-\u2AE9\u2AEB-\u2AF3\u2AFD\uFB00-\uFB04]|\uD835[\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDD6B]/g;
    var encodeMap = {
        '\xAD': 'shy',
        '‌': 'zwnj',
        '‍': 'zwj',
        '\u200E': 'lrm',
        '\u2063': 'ic',
        '\u2062': 'it',
        '\u2061': 'af',
        '\u200F': 'rlm',
        '\u200B': 'ZeroWidthSpace',
        '\u2060': 'NoBreak',
        '̑': 'DownBreve',
        '⃛': 'tdot',
        '⃜': 'DotDot',
        '\t': 'Tab',
        '\n': 'NewLine',
        '\u2008': 'puncsp',
        '\u205F': 'MediumSpace',
        '\u2009': 'thinsp',
        '\u200A': 'hairsp',
        '\u2004': 'emsp13',
        '\u2002': 'ensp',
        '\u2005': 'emsp14',
        '\u2003': 'emsp',
        '\u2007': 'numsp',
        '\xA0': 'nbsp',
        '\u205F\u200A': 'ThickSpace',
        '\u203E': 'oline',
        '_': 'lowbar',
        '\u2010': 'dash',
        '\u2013': 'ndash',
        '\u2014': 'mdash',
        '\u2015': 'horbar',
        ',': 'comma',
        ';': 'semi',
        '\u204F': 'bsemi',
        ':': 'colon',
        '\u2A74': 'Colone',
        '!': 'excl',
        '\xA1': 'iexcl',
        '?': 'quest',
        '\xBF': 'iquest',
        '.': 'period',
        '\u2025': 'nldr',
        '\u2026': 'mldr',
        '\xB7': 'middot',
        '\'': 'apos',
        '\u2018': 'lsquo',
        '\u2019': 'rsquo',
        '\u201A': 'sbquo',
        '\u2039': 'lsaquo',
        '\u203A': 'rsaquo',
        '"': 'quot',
        '\u201C': 'ldquo',
        '\u201D': 'rdquo',
        '\u201E': 'bdquo',
        '\xAB': 'laquo',
        '\xBB': 'raquo',
        '(': 'lpar',
        ')': 'rpar',
        '[': 'lsqb',
        ']': 'rsqb',
        '{': 'lcub',
        '}': 'rcub',
        '\u2308': 'lceil',
        '\u2309': 'rceil',
        '\u230A': 'lfloor',
        '\u230B': 'rfloor',
        '\u2985': 'lopar',
        '\u2986': 'ropar',
        '\u298B': 'lbrke',
        '\u298C': 'rbrke',
        '\u298D': 'lbrkslu',
        '\u298E': 'rbrksld',
        '\u298F': 'lbrksld',
        '\u2990': 'rbrkslu',
        '\u2991': 'langd',
        '\u2992': 'rangd',
        '\u2993': 'lparlt',
        '\u2994': 'rpargt',
        '\u2995': 'gtlPar',
        '\u2996': 'ltrPar',
        '\u27E6': 'lobrk',
        '\u27E7': 'robrk',
        '\u27E8': 'lang',
        '\u27E9': 'rang',
        '\u27EA': 'Lang',
        '\u27EB': 'Rang',
        '\u27EC': 'loang',
        '\u27ED': 'roang',
        '\u2772': 'lbbrk',
        '\u2773': 'rbbrk',
        '\u2016': 'Vert',
        '\xA7': 'sect',
        '\xB6': 'para',
        '@': 'commat',
        '*': 'ast',
        '/': 'sol',
        'undefined': null,
        '&': 'amp',
        '#': 'num',
        '%': 'percnt',
        '\u2030': 'permil',
        '\u2031': 'pertenk',
        '\u2020': 'dagger',
        '\u2021': 'Dagger',
        '\u2022': 'bull',
        '\u2043': 'hybull',
        '\u2032': 'prime',
        '\u2033': 'Prime',
        '\u2034': 'tprime',
        '\u2057': 'qprime',
        '\u2035': 'bprime',
        '\u2041': 'caret',
        '`': 'grave',
        '\xB4': 'acute',
        '\u02DC': 'tilde',
        '^': 'Hat',
        '\xAF': 'macr',
        '\u02D8': 'breve',
        '\u02D9': 'dot',
        '\xA8': 'die',
        '\u02DA': 'ring',
        '\u02DD': 'dblac',
        '\xB8': 'cedil',
        '\u02DB': 'ogon',
        'ˆ': 'circ',
        'ˇ': 'caron',
        '\xB0': 'deg',
        '\xA9': 'copy',
        '\xAE': 'reg',
        '\u2117': 'copysr',
        '\u2118': 'wp',
        '\u211E': 'rx',
        '\u2127': 'mho',
        '\u2129': 'iiota',
        '\u2190': 'larr',
        '\u219A': 'nlarr',
        '\u2192': 'rarr',
        '\u219B': 'nrarr',
        '\u2191': 'uarr',
        '\u2193': 'darr',
        '\u2194': 'harr',
        '\u21AE': 'nharr',
        '\u2195': 'varr',
        '\u2196': 'nwarr',
        '\u2197': 'nearr',
        '\u2198': 'searr',
        '\u2199': 'swarr',
        '\u219D': 'rarrw',
        '\u219D̸': 'nrarrw',
        '\u219E': 'Larr',
        '\u219F': 'Uarr',
        '\u21A0': 'Rarr',
        '\u21A1': 'Darr',
        '\u21A2': 'larrtl',
        '\u21A3': 'rarrtl',
        '\u21A4': 'mapstoleft',
        '\u21A5': 'mapstoup',
        '\u21A6': 'map',
        '\u21A7': 'mapstodown',
        '\u21A9': 'larrhk',
        '\u21AA': 'rarrhk',
        '\u21AB': 'larrlp',
        '\u21AC': 'rarrlp',
        '\u21AD': 'harrw',
        '\u21B0': 'lsh',
        '\u21B1': 'rsh',
        '\u21B2': 'ldsh',
        '\u21B3': 'rdsh',
        '\u21B5': 'crarr',
        '\u21B6': 'cularr',
        '\u21B7': 'curarr',
        '\u21BA': 'olarr',
        '\u21BB': 'orarr',
        '\u21BC': 'lharu',
        '\u21BD': 'lhard',
        '\u21BE': 'uharr',
        '\u21BF': 'uharl',
        '\u21C0': 'rharu',
        '\u21C1': 'rhard',
        '\u21C2': 'dharr',
        '\u21C3': 'dharl',
        '\u21C4': 'rlarr',
        '\u21C5': 'udarr',
        '\u21C6': 'lrarr',
        '\u21C7': 'llarr',
        '\u21C8': 'uuarr',
        '\u21C9': 'rrarr',
        '\u21CA': 'ddarr',
        '\u21CB': 'lrhar',
        '\u21CC': 'rlhar',
        '\u21D0': 'lArr',
        '\u21CD': 'nlArr',
        '\u21D1': 'uArr',
        '\u21D2': 'rArr',
        '\u21CF': 'nrArr',
        '\u21D3': 'dArr',
        '\u21D4': 'iff',
        '\u21CE': 'nhArr',
        '\u21D5': 'vArr',
        '\u21D6': 'nwArr',
        '\u21D7': 'neArr',
        '\u21D8': 'seArr',
        '\u21D9': 'swArr',
        '\u21DA': 'lAarr',
        '\u21DB': 'rAarr',
        '\u21DD': 'zigrarr',
        '\u21E4': 'larrb',
        '\u21E5': 'rarrb',
        '\u21F5': 'duarr',
        '\u21FD': 'loarr',
        '\u21FE': 'roarr',
        '\u21FF': 'hoarr',
        '\u2200': 'forall',
        '\u2201': 'comp',
        '\u2202': 'part',
        '\u2202̸': 'npart',
        '\u2203': 'exist',
        '\u2204': 'nexist',
        '\u2205': 'empty',
        '\u2207': 'Del',
        '\u2208': 'in',
        '\u2209': 'notin',
        '\u220B': 'ni',
        '\u220C': 'notni',
        '\u03F6': 'bepsi',
        '\u220F': 'prod',
        '\u2210': 'coprod',
        '\u2211': 'sum',
        '+': 'plus',
        '\xB1': 'pm',
        '\xF7': 'div',
        '\xD7': 'times',
        '<': 'lt',
        '\u226E': 'nlt',
        '<⃒': 'nvlt',
        '=': 'equals',
        '\u2260': 'ne',
        '=⃥': 'bne',
        '\u2A75': 'Equal',
        '>': 'gt',
        '\u226F': 'ngt',
        '>⃒': 'nvgt',
        '\xAC': 'not',
        '|': 'vert',
        '\xA6': 'brvbar',
        '\u2212': 'minus',
        '\u2213': 'mp',
        '\u2214': 'plusdo',
        '\u2044': 'frasl',
        '\u2216': 'setmn',
        '\u2217': 'lowast',
        '\u2218': 'compfn',
        '\u221A': 'Sqrt',
        '\u221D': 'prop',
        '\u221E': 'infin',
        '\u221F': 'angrt',
        '\u2220': 'ang',
        '\u2220⃒': 'nang',
        '\u2221': 'angmsd',
        '\u2222': 'angsph',
        '\u2223': 'mid',
        '\u2224': 'nmid',
        '\u2225': 'par',
        '\u2226': 'npar',
        '\u2227': 'and',
        '\u2228': 'or',
        '\u2229': 'cap',
        '\u2229︀': 'caps',
        '\u222A': 'cup',
        '\u222A︀': 'cups',
        '\u222B': 'int',
        '\u222C': 'Int',
        '\u222D': 'tint',
        '\u2A0C': 'qint',
        '\u222E': 'oint',
        '\u222F': 'Conint',
        '\u2230': 'Cconint',
        '\u2231': 'cwint',
        '\u2232': 'cwconint',
        '\u2233': 'awconint',
        '\u2234': 'there4',
        '\u2235': 'becaus',
        '\u2236': 'ratio',
        '\u2237': 'Colon',
        '\u2238': 'minusd',
        '\u223A': 'mDDot',
        '\u223B': 'homtht',
        '\u223C': 'sim',
        '\u2241': 'nsim',
        '\u223C⃒': 'nvsim',
        '\u223D': 'bsim',
        '\u223Ḏ': 'race',
        '\u223E': 'ac',
        '\u223E̳': 'acE',
        '\u223F': 'acd',
        '\u2240': 'wr',
        '\u2242': 'esim',
        '\u2242̸': 'nesim',
        '\u2243': 'sime',
        '\u2244': 'nsime',
        '\u2245': 'cong',
        '\u2247': 'ncong',
        '\u2246': 'simne',
        '\u2248': 'ap',
        '\u2249': 'nap',
        '\u224A': 'ape',
        '\u224B': 'apid',
        '\u224B̸': 'napid',
        '\u224C': 'bcong',
        '\u224D': 'CupCap',
        '\u226D': 'NotCupCap',
        '\u224D⃒': 'nvap',
        '\u224E': 'bump',
        '\u224E̸': 'nbump',
        '\u224F': 'bumpe',
        '\u224F̸': 'nbumpe',
        '\u2250': 'doteq',
        '\u2250̸': 'nedot',
        '\u2251': 'eDot',
        '\u2252': 'efDot',
        '\u2253': 'erDot',
        '\u2254': 'colone',
        '\u2255': 'ecolon',
        '\u2256': 'ecir',
        '\u2257': 'cire',
        '\u2259': 'wedgeq',
        '\u225A': 'veeeq',
        '\u225C': 'trie',
        '\u225F': 'equest',
        '\u2261': 'equiv',
        '\u2262': 'nequiv',
        '\u2261⃥': 'bnequiv',
        '\u2264': 'le',
        '\u2270': 'nle',
        '\u2264⃒': 'nvle',
        '\u2265': 'ge',
        '\u2271': 'nge',
        '\u2265⃒': 'nvge',
        '\u2266': 'lE',
        '\u2266̸': 'nlE',
        '\u2267': 'gE',
        '\u2267̸': 'ngE',
        '\u2268︀': 'lvnE',
        '\u2268': 'lnE',
        '\u2269': 'gnE',
        '\u2269︀': 'gvnE',
        '\u226A': 'll',
        '\u226A̸': 'nLtv',
        '\u226A⃒': 'nLt',
        '\u226B': 'gg',
        '\u226B̸': 'nGtv',
        '\u226B⃒': 'nGt',
        '\u226C': 'twixt',
        '\u2272': 'lsim',
        '\u2274': 'nlsim',
        '\u2273': 'gsim',
        '\u2275': 'ngsim',
        '\u2276': 'lg',
        '\u2278': 'ntlg',
        '\u2277': 'gl',
        '\u2279': 'ntgl',
        '\u227A': 'pr',
        '\u2280': 'npr',
        '\u227B': 'sc',
        '\u2281': 'nsc',
        '\u227C': 'prcue',
        '\u22E0': 'nprcue',
        '\u227D': 'sccue',
        '\u22E1': 'nsccue',
        '\u227E': 'prsim',
        '\u227F': 'scsim',
        '\u227F̸': 'NotSucceedsTilde',
        '\u2282': 'sub',
        '\u2284': 'nsub',
        '\u2282⃒': 'vnsub',
        '\u2283': 'sup',
        '\u2285': 'nsup',
        '\u2283⃒': 'vnsup',
        '\u2286': 'sube',
        '\u2288': 'nsube',
        '\u2287': 'supe',
        '\u2289': 'nsupe',
        '\u228A︀': 'vsubne',
        '\u228A': 'subne',
        '\u228B︀': 'vsupne',
        '\u228B': 'supne',
        '\u228D': 'cupdot',
        '\u228E': 'uplus',
        '\u228F': 'sqsub',
        '\u228F̸': 'NotSquareSubset',
        '\u2290': 'sqsup',
        '\u2290̸': 'NotSquareSuperset',
        '\u2291': 'sqsube',
        '\u22E2': 'nsqsube',
        '\u2292': 'sqsupe',
        '\u22E3': 'nsqsupe',
        '\u2293': 'sqcap',
        '\u2293︀': 'sqcaps',
        '\u2294': 'sqcup',
        '\u2294︀': 'sqcups',
        '\u2295': 'oplus',
        '\u2296': 'ominus',
        '\u2297': 'otimes',
        '\u2298': 'osol',
        '\u2299': 'odot',
        '\u229A': 'ocir',
        '\u229B': 'oast',
        '\u229D': 'odash',
        '\u229E': 'plusb',
        '\u229F': 'minusb',
        '\u22A0': 'timesb',
        '\u22A1': 'sdotb',
        '\u22A2': 'vdash',
        '\u22AC': 'nvdash',
        '\u22A3': 'dashv',
        '\u22A4': 'top',
        '\u22A5': 'bot',
        '\u22A7': 'models',
        '\u22A8': 'vDash',
        '\u22AD': 'nvDash',
        '\u22A9': 'Vdash',
        '\u22AE': 'nVdash',
        '\u22AA': 'Vvdash',
        '\u22AB': 'VDash',
        '\u22AF': 'nVDash',
        '\u22B0': 'prurel',
        '\u22B2': 'vltri',
        '\u22EA': 'nltri',
        '\u22B3': 'vrtri',
        '\u22EB': 'nrtri',
        '\u22B4': 'ltrie',
        '\u22EC': 'nltrie',
        '\u22B4⃒': 'nvltrie',
        '\u22B5': 'rtrie',
        '\u22ED': 'nrtrie',
        '\u22B5⃒': 'nvrtrie',
        '\u22B6': 'origof',
        '\u22B7': 'imof',
        '\u22B8': 'mumap',
        '\u22B9': 'hercon',
        '\u22BA': 'intcal',
        '\u22BB': 'veebar',
        '\u22BD': 'barvee',
        '\u22BE': 'angrtvb',
        '\u22BF': 'lrtri',
        '\u22C0': 'Wedge',
        '\u22C1': 'Vee',
        '\u22C2': 'xcap',
        '\u22C3': 'xcup',
        '\u22C4': 'diam',
        '\u22C5': 'sdot',
        '\u22C6': 'Star',
        '\u22C7': 'divonx',
        '\u22C8': 'bowtie',
        '\u22C9': 'ltimes',
        '\u22CA': 'rtimes',
        '\u22CB': 'lthree',
        '\u22CC': 'rthree',
        '\u22CD': 'bsime',
        '\u22CE': 'cuvee',
        '\u22CF': 'cuwed',
        '\u22D0': 'Sub',
        '\u22D1': 'Sup',
        '\u22D2': 'Cap',
        '\u22D3': 'Cup',
        '\u22D4': 'fork',
        '\u22D5': 'epar',
        '\u22D6': 'ltdot',
        '\u22D7': 'gtdot',
        '\u22D8': 'Ll',
        '\u22D8̸': 'nLl',
        '\u22D9': 'Gg',
        '\u22D9̸': 'nGg',
        '\u22DA︀': 'lesg',
        '\u22DA': 'leg',
        '\u22DB': 'gel',
        '\u22DB︀': 'gesl',
        '\u22DE': 'cuepr',
        '\u22DF': 'cuesc',
        '\u22E6': 'lnsim',
        '\u22E7': 'gnsim',
        '\u22E8': 'prnsim',
        '\u22E9': 'scnsim',
        '\u22EE': 'vellip',
        '\u22EF': 'ctdot',
        '\u22F0': 'utdot',
        '\u22F1': 'dtdot',
        '\u22F2': 'disin',
        '\u22F3': 'isinsv',
        '\u22F4': 'isins',
        '\u22F5': 'isindot',
        '\u22F5̸': 'notindot',
        '\u22F6': 'notinvc',
        '\u22F7': 'notinvb',
        '\u22F9': 'isinE',
        '\u22F9̸': 'notinE',
        '\u22FA': 'nisd',
        '\u22FB': 'xnis',
        '\u22FC': 'nis',
        '\u22FD': 'notnivc',
        '\u22FE': 'notnivb',
        '\u2305': 'barwed',
        '\u2306': 'Barwed',
        '\u230C': 'drcrop',
        '\u230D': 'dlcrop',
        '\u230E': 'urcrop',
        '\u230F': 'ulcrop',
        '\u2310': 'bnot',
        '\u2312': 'profline',
        '\u2313': 'profsurf',
        '\u2315': 'telrec',
        '\u2316': 'target',
        '\u231C': 'ulcorn',
        '\u231D': 'urcorn',
        '\u231E': 'dlcorn',
        '\u231F': 'drcorn',
        '\u2322': 'frown',
        '\u2323': 'smile',
        '\u232D': 'cylcty',
        '\u232E': 'profalar',
        '\u2336': 'topbot',
        '\u233D': 'ovbar',
        '\u233F': 'solbar',
        '\u237C': 'angzarr',
        '\u23B0': 'lmoust',
        '\u23B1': 'rmoust',
        '\u23B4': 'tbrk',
        '\u23B5': 'bbrk',
        '\u23B6': 'bbrktbrk',
        '\u23DC': 'OverParenthesis',
        '\u23DD': 'UnderParenthesis',
        '\u23DE': 'OverBrace',
        '\u23DF': 'UnderBrace',
        '\u23E2': 'trpezium',
        '\u23E7': 'elinters',
        '\u2423': 'blank',
        '\u2500': 'boxh',
        '\u2502': 'boxv',
        '\u250C': 'boxdr',
        '\u2510': 'boxdl',
        '\u2514': 'boxur',
        '\u2518': 'boxul',
        '\u251C': 'boxvr',
        '\u2524': 'boxvl',
        '\u252C': 'boxhd',
        '\u2534': 'boxhu',
        '\u253C': 'boxvh',
        '\u2550': 'boxH',
        '\u2551': 'boxV',
        '\u2552': 'boxdR',
        '\u2553': 'boxDr',
        '\u2554': 'boxDR',
        '\u2555': 'boxdL',
        '\u2556': 'boxDl',
        '\u2557': 'boxDL',
        '\u2558': 'boxuR',
        '\u2559': 'boxUr',
        '\u255A': 'boxUR',
        '\u255B': 'boxuL',
        '\u255C': 'boxUl',
        '\u255D': 'boxUL',
        '\u255E': 'boxvR',
        '\u255F': 'boxVr',
        '\u2560': 'boxVR',
        '\u2561': 'boxvL',
        '\u2562': 'boxVl',
        '\u2563': 'boxVL',
        '\u2564': 'boxHd',
        '\u2565': 'boxhD',
        '\u2566': 'boxHD',
        '\u2567': 'boxHu',
        '\u2568': 'boxhU',
        '\u2569': 'boxHU',
        '\u256A': 'boxvH',
        '\u256B': 'boxVh',
        '\u256C': 'boxVH',
        '\u2580': 'uhblk',
        '\u2584': 'lhblk',
        '\u2588': 'block',
        '\u2591': 'blk14',
        '\u2592': 'blk12',
        '\u2593': 'blk34',
        '\u25A1': 'squ',
        '\u25AA': 'squf',
        '\u25AB': 'EmptyVerySmallSquare',
        '\u25AD': 'rect',
        '\u25AE': 'marker',
        '\u25B1': 'fltns',
        '\u25B3': 'xutri',
        '\u25B4': 'utrif',
        '\u25B5': 'utri',
        '\u25B8': 'rtrif',
        '\u25B9': 'rtri',
        '\u25BD': 'xdtri',
        '\u25BE': 'dtrif',
        '\u25BF': 'dtri',
        '\u25C2': 'ltrif',
        '\u25C3': 'ltri',
        '\u25CA': 'loz',
        '\u25CB': 'cir',
        '\u25EC': 'tridot',
        '\u25EF': 'xcirc',
        '\u25F8': 'ultri',
        '\u25F9': 'urtri',
        '\u25FA': 'lltri',
        '\u25FB': 'EmptySmallSquare',
        '\u25FC': 'FilledSmallSquare',
        '\u2605': 'starf',
        '\u2606': 'star',
        '\u260E': 'phone',
        '\u2640': 'female',
        '\u2642': 'male',
        '\u2660': 'spades',
        '\u2663': 'clubs',
        '\u2665': 'hearts',
        '\u2666': 'diams',
        '\u266A': 'sung',
        '\u2713': 'check',
        '\u2717': 'cross',
        '\u2720': 'malt',
        '\u2736': 'sext',
        '\u2758': 'VerticalSeparator',
        '\u27C8': 'bsolhsub',
        '\u27C9': 'suphsol',
        '\u27F5': 'xlarr',
        '\u27F6': 'xrarr',
        '\u27F7': 'xharr',
        '\u27F8': 'xlArr',
        '\u27F9': 'xrArr',
        '\u27FA': 'xhArr',
        '\u27FC': 'xmap',
        '\u27FF': 'dzigrarr',
        '\u2902': 'nvlArr',
        '\u2903': 'nvrArr',
        '\u2904': 'nvHarr',
        '\u2905': 'Map',
        '\u290C': 'lbarr',
        '\u290D': 'rbarr',
        '\u290E': 'lBarr',
        '\u290F': 'rBarr',
        '\u2910': 'RBarr',
        '\u2911': 'DDotrahd',
        '\u2912': 'UpArrowBar',
        '\u2913': 'DownArrowBar',
        '\u2916': 'Rarrtl',
        '\u2919': 'latail',
        '\u291A': 'ratail',
        '\u291B': 'lAtail',
        '\u291C': 'rAtail',
        '\u291D': 'larrfs',
        '\u291E': 'rarrfs',
        '\u291F': 'larrbfs',
        '\u2920': 'rarrbfs',
        '\u2923': 'nwarhk',
        '\u2924': 'nearhk',
        '\u2925': 'searhk',
        '\u2926': 'swarhk',
        '\u2927': 'nwnear',
        '\u2928': 'toea',
        '\u2929': 'tosa',
        '\u292A': 'swnwar',
        '\u2933': 'rarrc',
        '\u2933̸': 'nrarrc',
        '\u2935': 'cudarrr',
        '\u2936': 'ldca',
        '\u2937': 'rdca',
        '\u2938': 'cudarrl',
        '\u2939': 'larrpl',
        '\u293C': 'curarrm',
        '\u293D': 'cularrp',
        '\u2945': 'rarrpl',
        '\u2948': 'harrcir',
        '\u2949': 'Uarrocir',
        '\u294A': 'lurdshar',
        '\u294B': 'ldrushar',
        '\u294E': 'LeftRightVector',
        '\u294F': 'RightUpDownVector',
        '\u2950': 'DownLeftRightVector',
        '\u2951': 'LeftUpDownVector',
        '\u2952': 'LeftVectorBar',
        '\u2953': 'RightVectorBar',
        '\u2954': 'RightUpVectorBar',
        '\u2955': 'RightDownVectorBar',
        '\u2956': 'DownLeftVectorBar',
        '\u2957': 'DownRightVectorBar',
        '\u2958': 'LeftUpVectorBar',
        '\u2959': 'LeftDownVectorBar',
        '\u295A': 'LeftTeeVector',
        '\u295B': 'RightTeeVector',
        '\u295C': 'RightUpTeeVector',
        '\u295D': 'RightDownTeeVector',
        '\u295E': 'DownLeftTeeVector',
        '\u295F': 'DownRightTeeVector',
        '\u2960': 'LeftUpTeeVector',
        '\u2961': 'LeftDownTeeVector',
        '\u2962': 'lHar',
        '\u2963': 'uHar',
        '\u2964': 'rHar',
        '\u2965': 'dHar',
        '\u2966': 'luruhar',
        '\u2967': 'ldrdhar',
        '\u2968': 'ruluhar',
        '\u2969': 'rdldhar',
        '\u296A': 'lharul',
        '\u296B': 'llhard',
        '\u296C': 'rharul',
        '\u296D': 'lrhard',
        '\u296E': 'udhar',
        '\u296F': 'duhar',
        '\u2970': 'RoundImplies',
        '\u2971': 'erarr',
        '\u2972': 'simrarr',
        '\u2973': 'larrsim',
        '\u2974': 'rarrsim',
        '\u2975': 'rarrap',
        '\u2976': 'ltlarr',
        '\u2978': 'gtrarr',
        '\u2979': 'subrarr',
        '\u297B': 'suplarr',
        '\u297C': 'lfisht',
        '\u297D': 'rfisht',
        '\u297E': 'ufisht',
        '\u297F': 'dfisht',
        '\u299A': 'vzigzag',
        '\u299C': 'vangrt',
        '\u299D': 'angrtvbd',
        '\u29A4': 'ange',
        '\u29A5': 'range',
        '\u29A6': 'dwangle',
        '\u29A7': 'uwangle',
        '\u29A8': 'angmsdaa',
        '\u29A9': 'angmsdab',
        '\u29AA': 'angmsdac',
        '\u29AB': 'angmsdad',
        '\u29AC': 'angmsdae',
        '\u29AD': 'angmsdaf',
        '\u29AE': 'angmsdag',
        '\u29AF': 'angmsdah',
        '\u29B0': 'bemptyv',
        '\u29B1': 'demptyv',
        '\u29B2': 'cemptyv',
        '\u29B3': 'raemptyv',
        '\u29B4': 'laemptyv',
        '\u29B5': 'ohbar',
        '\u29B6': 'omid',
        '\u29B7': 'opar',
        '\u29B9': 'operp',
        '\u29BB': 'olcross',
        '\u29BC': 'odsold',
        '\u29BE': 'olcir',
        '\u29BF': 'ofcir',
        '\u29C0': 'olt',
        '\u29C1': 'ogt',
        '\u29C2': 'cirscir',
        '\u29C3': 'cirE',
        '\u29C4': 'solb',
        '\u29C5': 'bsolb',
        '\u29C9': 'boxbox',
        '\u29CD': 'trisb',
        '\u29CE': 'rtriltri',
        '\u29CF': 'LeftTriangleBar',
        '\u29CF̸': 'NotLeftTriangleBar',
        '\u29D0': 'RightTriangleBar',
        '\u29D0̸': 'NotRightTriangleBar',
        '\u29DC': 'iinfin',
        '\u29DD': 'infintie',
        '\u29DE': 'nvinfin',
        '\u29E3': 'eparsl',
        '\u29E4': 'smeparsl',
        '\u29E5': 'eqvparsl',
        '\u29EB': 'lozf',
        '\u29F4': 'RuleDelayed',
        '\u29F6': 'dsol',
        '\u2A00': 'xodot',
        '\u2A01': 'xoplus',
        '\u2A02': 'xotime',
        '\u2A04': 'xuplus',
        '\u2A06': 'xsqcup',
        '\u2A0D': 'fpartint',
        '\u2A10': 'cirfnint',
        '\u2A11': 'awint',
        '\u2A12': 'rppolint',
        '\u2A13': 'scpolint',
        '\u2A14': 'npolint',
        '\u2A15': 'pointint',
        '\u2A16': 'quatint',
        '\u2A17': 'intlarhk',
        '\u2A22': 'pluscir',
        '\u2A23': 'plusacir',
        '\u2A24': 'simplus',
        '\u2A25': 'plusdu',
        '\u2A26': 'plussim',
        '\u2A27': 'plustwo',
        '\u2A29': 'mcomma',
        '\u2A2A': 'minusdu',
        '\u2A2D': 'loplus',
        '\u2A2E': 'roplus',
        '\u2A2F': 'Cross',
        '\u2A30': 'timesd',
        '\u2A31': 'timesbar',
        '\u2A33': 'smashp',
        '\u2A34': 'lotimes',
        '\u2A35': 'rotimes',
        '\u2A36': 'otimesas',
        '\u2A37': 'Otimes',
        '\u2A38': 'odiv',
        '\u2A39': 'triplus',
        '\u2A3A': 'triminus',
        '\u2A3B': 'tritime',
        '\u2A3C': 'iprod',
        '\u2A3F': 'amalg',
        '\u2A40': 'capdot',
        '\u2A42': 'ncup',
        '\u2A43': 'ncap',
        '\u2A44': 'capand',
        '\u2A45': 'cupor',
        '\u2A46': 'cupcap',
        '\u2A47': 'capcup',
        '\u2A48': 'cupbrcap',
        '\u2A49': 'capbrcup',
        '\u2A4A': 'cupcup',
        '\u2A4B': 'capcap',
        '\u2A4C': 'ccups',
        '\u2A4D': 'ccaps',
        '\u2A50': 'ccupssm',
        '\u2A53': 'And',
        '\u2A54': 'Or',
        '\u2A55': 'andand',
        '\u2A56': 'oror',
        '\u2A57': 'orslope',
        '\u2A58': 'andslope',
        '\u2A5A': 'andv',
        '\u2A5B': 'orv',
        '\u2A5C': 'andd',
        '\u2A5D': 'ord',
        '\u2A5F': 'wedbar',
        '\u2A66': 'sdote',
        '\u2A6A': 'simdot',
        '\u2A6D': 'congdot',
        '\u2A6D̸': 'ncongdot',
        '\u2A6E': 'easter',
        '\u2A6F': 'apacir',
        '\u2A70': 'apE',
        '\u2A70̸': 'napE',
        '\u2A71': 'eplus',
        '\u2A72': 'pluse',
        '\u2A73': 'Esim',
        '\u2A77': 'eDDot',
        '\u2A78': 'equivDD',
        '\u2A79': 'ltcir',
        '\u2A7A': 'gtcir',
        '\u2A7B': 'ltquest',
        '\u2A7C': 'gtquest',
        '\u2A7D': 'les',
        '\u2A7D̸': 'nles',
        '\u2A7E': 'ges',
        '\u2A7E̸': 'nges',
        '\u2A7F': 'lesdot',
        '\u2A80': 'gesdot',
        '\u2A81': 'lesdoto',
        '\u2A82': 'gesdoto',
        '\u2A83': 'lesdotor',
        '\u2A84': 'gesdotol',
        '\u2A85': 'lap',
        '\u2A86': 'gap',
        '\u2A87': 'lne',
        '\u2A88': 'gne',
        '\u2A89': 'lnap',
        '\u2A8A': 'gnap',
        '\u2A8B': 'lEg',
        '\u2A8C': 'gEl',
        '\u2A8D': 'lsime',
        '\u2A8E': 'gsime',
        '\u2A8F': 'lsimg',
        '\u2A90': 'gsiml',
        '\u2A91': 'lgE',
        '\u2A92': 'glE',
        '\u2A93': 'lesges',
        '\u2A94': 'gesles',
        '\u2A95': 'els',
        '\u2A96': 'egs',
        '\u2A97': 'elsdot',
        '\u2A98': 'egsdot',
        '\u2A99': 'el',
        '\u2A9A': 'eg',
        '\u2A9D': 'siml',
        '\u2A9E': 'simg',
        '\u2A9F': 'simlE',
        '\u2AA0': 'simgE',
        '\u2AA1': 'LessLess',
        '\u2AA1̸': 'NotNestedLessLess',
        '\u2AA2': 'GreaterGreater',
        '\u2AA2̸': 'NotNestedGreaterGreater',
        '\u2AA4': 'glj',
        '\u2AA5': 'gla',
        '\u2AA6': 'ltcc',
        '\u2AA7': 'gtcc',
        '\u2AA8': 'lescc',
        '\u2AA9': 'gescc',
        '\u2AAA': 'smt',
        '\u2AAB': 'lat',
        '\u2AAC': 'smte',
        '\u2AAC︀': 'smtes',
        '\u2AAD': 'late',
        '\u2AAD︀': 'lates',
        '\u2AAE': 'bumpE',
        '\u2AAF': 'pre',
        '\u2AAF̸': 'npre',
        '\u2AB0': 'sce',
        '\u2AB0̸': 'nsce',
        '\u2AB3': 'prE',
        '\u2AB4': 'scE',
        '\u2AB5': 'prnE',
        '\u2AB6': 'scnE',
        '\u2AB7': 'prap',
        '\u2AB8': 'scap',
        '\u2AB9': 'prnap',
        '\u2ABA': 'scnap',
        '\u2ABB': 'Pr',
        '\u2ABC': 'Sc',
        '\u2ABD': 'subdot',
        '\u2ABE': 'supdot',
        '\u2ABF': 'subplus',
        '\u2AC0': 'supplus',
        '\u2AC1': 'submult',
        '\u2AC2': 'supmult',
        '\u2AC3': 'subedot',
        '\u2AC4': 'supedot',
        '\u2AC5': 'subE',
        '\u2AC5̸': 'nsubE',
        '\u2AC6': 'supE',
        '\u2AC6̸': 'nsupE',
        '\u2AC7': 'subsim',
        '\u2AC8': 'supsim',
        '\u2ACB︀': 'vsubnE',
        '\u2ACB': 'subnE',
        '\u2ACC︀': 'vsupnE',
        '\u2ACC': 'supnE',
        '\u2ACF': 'csub',
        '\u2AD0': 'csup',
        '\u2AD1': 'csube',
        '\u2AD2': 'csupe',
        '\u2AD3': 'subsup',
        '\u2AD4': 'supsub',
        '\u2AD5': 'subsub',
        '\u2AD6': 'supsup',
        '\u2AD7': 'suphsub',
        '\u2AD8': 'supdsub',
        '\u2AD9': 'forkv',
        '\u2ADA': 'topfork',
        '\u2ADB': 'mlcp',
        '\u2AE4': 'Dashv',
        '\u2AE6': 'Vdashl',
        '\u2AE7': 'Barv',
        '\u2AE8': 'vBar',
        '\u2AE9': 'vBarv',
        '\u2AEB': 'Vbar',
        '\u2AEC': 'Not',
        '\u2AED': 'bNot',
        '\u2AEE': 'rnmid',
        '\u2AEF': 'cirmid',
        '\u2AF0': 'midcir',
        '\u2AF1': 'topcir',
        '\u2AF2': 'nhpar',
        '\u2AF3': 'parsim',
        '\u2AFD': 'parsl',
        '\u2AFD⃥': 'nparsl',
        '\u266D': 'flat',
        '\u266E': 'natur',
        '\u266F': 'sharp',
        '\xA4': 'curren',
        '\xA2': 'cent',
        '$': 'dollar',
        '\xA3': 'pound',
        '\xA5': 'yen',
        '\u20AC': 'euro',
        '\xB9': 'sup1',
        '\xBD': 'half',
        '\u2153': 'frac13',
        '\xBC': 'frac14',
        '\u2155': 'frac15',
        '\u2159': 'frac16',
        '\u215B': 'frac18',
        '\xB2': 'sup2',
        '\u2154': 'frac23',
        '\u2156': 'frac25',
        '\xB3': 'sup3',
        '\xBE': 'frac34',
        '\u2157': 'frac35',
        '\u215C': 'frac38',
        '\u2158': 'frac45',
        '\u215A': 'frac56',
        '\u215D': 'frac58',
        '\u215E': 'frac78',
        '\uD835\uDCB6': 'ascr',
        '\uD835\uDD52': 'aopf',
        '\uD835\uDD1E': 'afr',
        '\uD835\uDD38': 'Aopf',
        '\uD835\uDD04': 'Afr',
        '\uD835\uDC9C': 'Ascr',
        'ª': 'ordf',
        'á': 'aacute',
        'Á': 'Aacute',
        'à': 'agrave',
        'À': 'Agrave',
        'ă': 'abreve',
        'Ă': 'Abreve',
        'â': 'acirc',
        'Â': 'Acirc',
        'å': 'aring',
        'Å': 'angst',
        'ä': 'auml',
        'Ä': 'Auml',
        'ã': 'atilde',
        'Ã': 'Atilde',
        'ą': 'aogon',
        'Ą': 'Aogon',
        'ā': 'amacr',
        'Ā': 'Amacr',
        'æ': 'aelig',
        'Æ': 'AElig',
        '\uD835\uDCB7': 'bscr',
        '\uD835\uDD53': 'bopf',
        '\uD835\uDD1F': 'bfr',
        '\uD835\uDD39': 'Bopf',
        'ℬ': 'Bscr',
        '\uD835\uDD05': 'Bfr',
        '\uD835\uDD20': 'cfr',
        '\uD835\uDCB8': 'cscr',
        '\uD835\uDD54': 'copf',
        'ℭ': 'Cfr',
        '\uD835\uDC9E': 'Cscr',
        'ℂ': 'Copf',
        'ć': 'cacute',
        'Ć': 'Cacute',
        'ĉ': 'ccirc',
        'Ĉ': 'Ccirc',
        'č': 'ccaron',
        'Č': 'Ccaron',
        'ċ': 'cdot',
        'Ċ': 'Cdot',
        'ç': 'ccedil',
        'Ç': 'Ccedil',
        '\u2105': 'incare',
        '\uD835\uDD21': 'dfr',
        'ⅆ': 'dd',
        '\uD835\uDD55': 'dopf',
        '\uD835\uDCB9': 'dscr',
        '\uD835\uDC9F': 'Dscr',
        '\uD835\uDD07': 'Dfr',
        'ⅅ': 'DD',
        '\uD835\uDD3B': 'Dopf',
        'ď': 'dcaron',
        'Ď': 'Dcaron',
        'đ': 'dstrok',
        'Đ': 'Dstrok',
        'ð': 'eth',
        'Ð': 'ETH',
        'ⅇ': 'ee',
        'ℯ': 'escr',
        '\uD835\uDD22': 'efr',
        '\uD835\uDD56': 'eopf',
        'ℰ': 'Escr',
        '\uD835\uDD08': 'Efr',
        '\uD835\uDD3C': 'Eopf',
        'é': 'eacute',
        'É': 'Eacute',
        'è': 'egrave',
        'È': 'Egrave',
        'ê': 'ecirc',
        'Ê': 'Ecirc',
        'ě': 'ecaron',
        'Ě': 'Ecaron',
        'ë': 'euml',
        'Ë': 'Euml',
        'ė': 'edot',
        'Ė': 'Edot',
        'ę': 'eogon',
        'Ę': 'Eogon',
        'ē': 'emacr',
        'Ē': 'Emacr',
        '\uD835\uDD23': 'ffr',
        '\uD835\uDD57': 'fopf',
        '\uD835\uDCBB': 'fscr',
        '\uD835\uDD09': 'Ffr',
        '\uD835\uDD3D': 'Fopf',
        'ℱ': 'Fscr',
        'ﬀ': 'fflig',
        'ﬃ': 'ffilig',
        'ﬄ': 'ffllig',
        'ﬁ': 'filig',
        'fj': 'fjlig',
        'ﬂ': 'fllig',
        'ƒ': 'fnof',
        'ℊ': 'gscr',
        '\uD835\uDD58': 'gopf',
        '\uD835\uDD24': 'gfr',
        '\uD835\uDCA2': 'Gscr',
        '\uD835\uDD3E': 'Gopf',
        '\uD835\uDD0A': 'Gfr',
        'ǵ': 'gacute',
        'ğ': 'gbreve',
        'Ğ': 'Gbreve',
        'ĝ': 'gcirc',
        'Ĝ': 'Gcirc',
        'ġ': 'gdot',
        'Ġ': 'Gdot',
        'Ģ': 'Gcedil',
        '\uD835\uDD25': 'hfr',
        'ℎ': 'planckh',
        '\uD835\uDCBD': 'hscr',
        '\uD835\uDD59': 'hopf',
        'ℋ': 'Hscr',
        'ℌ': 'Hfr',
        'ℍ': 'Hopf',
        'ĥ': 'hcirc',
        'Ĥ': 'Hcirc',
        'ℏ': 'hbar',
        'ħ': 'hstrok',
        'Ħ': 'Hstrok',
        '\uD835\uDD5A': 'iopf',
        '\uD835\uDD26': 'ifr',
        '\uD835\uDCBE': 'iscr',
        'ⅈ': 'ii',
        '\uD835\uDD40': 'Iopf',
        'ℐ': 'Iscr',
        'ℑ': 'Im',
        'í': 'iacute',
        'Í': 'Iacute',
        'ì': 'igrave',
        'Ì': 'Igrave',
        'î': 'icirc',
        'Î': 'Icirc',
        'ï': 'iuml',
        'Ï': 'Iuml',
        'ĩ': 'itilde',
        'Ĩ': 'Itilde',
        'İ': 'Idot',
        'į': 'iogon',
        'Į': 'Iogon',
        'ī': 'imacr',
        'Ī': 'Imacr',
        'ĳ': 'ijlig',
        'Ĳ': 'IJlig',
        'ı': 'imath',
        '\uD835\uDCBF': 'jscr',
        '\uD835\uDD5B': 'jopf',
        '\uD835\uDD27': 'jfr',
        '\uD835\uDCA5': 'Jscr',
        '\uD835\uDD0D': 'Jfr',
        '\uD835\uDD41': 'Jopf',
        'ĵ': 'jcirc',
        'Ĵ': 'Jcirc',
        'ȷ': 'jmath',
        '\uD835\uDD5C': 'kopf',
        '\uD835\uDCC0': 'kscr',
        '\uD835\uDD28': 'kfr',
        '\uD835\uDCA6': 'Kscr',
        '\uD835\uDD42': 'Kopf',
        '\uD835\uDD0E': 'Kfr',
        'ķ': 'kcedil',
        'Ķ': 'Kcedil',
        '\uD835\uDD29': 'lfr',
        '\uD835\uDCC1': 'lscr',
        'ℓ': 'ell',
        '\uD835\uDD5D': 'lopf',
        'ℒ': 'Lscr',
        '\uD835\uDD0F': 'Lfr',
        '\uD835\uDD43': 'Lopf',
        'ĺ': 'lacute',
        'Ĺ': 'Lacute',
        'ľ': 'lcaron',
        'Ľ': 'Lcaron',
        'ļ': 'lcedil',
        'Ļ': 'Lcedil',
        'ł': 'lstrok',
        'Ł': 'Lstrok',
        'ŀ': 'lmidot',
        'Ŀ': 'Lmidot',
        '\uD835\uDD2A': 'mfr',
        '\uD835\uDD5E': 'mopf',
        '\uD835\uDCC2': 'mscr',
        '\uD835\uDD10': 'Mfr',
        '\uD835\uDD44': 'Mopf',
        'ℳ': 'Mscr',
        '\uD835\uDD2B': 'nfr',
        '\uD835\uDD5F': 'nopf',
        '\uD835\uDCC3': 'nscr',
        'ℕ': 'Nopf',
        '\uD835\uDCA9': 'Nscr',
        '\uD835\uDD11': 'Nfr',
        'ń': 'nacute',
        'Ń': 'Nacute',
        'ň': 'ncaron',
        'Ň': 'Ncaron',
        'ñ': 'ntilde',
        'Ñ': 'Ntilde',
        'ņ': 'ncedil',
        'Ņ': 'Ncedil',
        '\u2116': 'numero',
        'ŋ': 'eng',
        'Ŋ': 'ENG',
        '\uD835\uDD60': 'oopf',
        '\uD835\uDD2C': 'ofr',
        'ℴ': 'oscr',
        '\uD835\uDCAA': 'Oscr',
        '\uD835\uDD12': 'Ofr',
        '\uD835\uDD46': 'Oopf',
        'º': 'ordm',
        'ó': 'oacute',
        'Ó': 'Oacute',
        'ò': 'ograve',
        'Ò': 'Ograve',
        'ô': 'ocirc',
        'Ô': 'Ocirc',
        'ö': 'ouml',
        'Ö': 'Ouml',
        'ő': 'odblac',
        'Ő': 'Odblac',
        'õ': 'otilde',
        'Õ': 'Otilde',
        'ø': 'oslash',
        'Ø': 'Oslash',
        'ō': 'omacr',
        'Ō': 'Omacr',
        'œ': 'oelig',
        'Œ': 'OElig',
        '\uD835\uDD2D': 'pfr',
        '\uD835\uDCC5': 'pscr',
        '\uD835\uDD61': 'popf',
        'ℙ': 'Popf',
        '\uD835\uDD13': 'Pfr',
        '\uD835\uDCAB': 'Pscr',
        '\uD835\uDD62': 'qopf',
        '\uD835\uDD2E': 'qfr',
        '\uD835\uDCC6': 'qscr',
        '\uD835\uDCAC': 'Qscr',
        '\uD835\uDD14': 'Qfr',
        'ℚ': 'Qopf',
        'ĸ': 'kgreen',
        '\uD835\uDD2F': 'rfr',
        '\uD835\uDD63': 'ropf',
        '\uD835\uDCC7': 'rscr',
        'ℛ': 'Rscr',
        'ℜ': 'Re',
        'ℝ': 'Ropf',
        'ŕ': 'racute',
        'Ŕ': 'Racute',
        'ř': 'rcaron',
        'Ř': 'Rcaron',
        'ŗ': 'rcedil',
        'Ŗ': 'Rcedil',
        '\uD835\uDD64': 'sopf',
        '\uD835\uDCC8': 'sscr',
        '\uD835\uDD30': 'sfr',
        '\uD835\uDD4A': 'Sopf',
        '\uD835\uDD16': 'Sfr',
        '\uD835\uDCAE': 'Sscr',
        '\u24C8': 'oS',
        'ś': 'sacute',
        'Ś': 'Sacute',
        'ŝ': 'scirc',
        'Ŝ': 'Scirc',
        'š': 'scaron',
        'Š': 'Scaron',
        'ş': 'scedil',
        'Ş': 'Scedil',
        'ß': 'szlig',
        '\uD835\uDD31': 'tfr',
        '\uD835\uDCC9': 'tscr',
        '\uD835\uDD65': 'topf',
        '\uD835\uDCAF': 'Tscr',
        '\uD835\uDD17': 'Tfr',
        '\uD835\uDD4B': 'Topf',
        'ť': 'tcaron',
        'Ť': 'Tcaron',
        'ţ': 'tcedil',
        'Ţ': 'Tcedil',
        '\u2122': 'trade',
        'ŧ': 'tstrok',
        'Ŧ': 'Tstrok',
        '\uD835\uDCCA': 'uscr',
        '\uD835\uDD66': 'uopf',
        '\uD835\uDD32': 'ufr',
        '\uD835\uDD4C': 'Uopf',
        '\uD835\uDD18': 'Ufr',
        '\uD835\uDCB0': 'Uscr',
        'ú': 'uacute',
        'Ú': 'Uacute',
        'ù': 'ugrave',
        'Ù': 'Ugrave',
        'ŭ': 'ubreve',
        'Ŭ': 'Ubreve',
        'û': 'ucirc',
        'Û': 'Ucirc',
        'ů': 'uring',
        'Ů': 'Uring',
        'ü': 'uuml',
        'Ü': 'Uuml',
        'ű': 'udblac',
        'Ű': 'Udblac',
        'ũ': 'utilde',
        'Ũ': 'Utilde',
        'ų': 'uogon',
        'Ų': 'Uogon',
        'ū': 'umacr',
        'Ū': 'Umacr',
        '\uD835\uDD33': 'vfr',
        '\uD835\uDD67': 'vopf',
        '\uD835\uDCCB': 'vscr',
        '\uD835\uDD19': 'Vfr',
        '\uD835\uDD4D': 'Vopf',
        '\uD835\uDCB1': 'Vscr',
        '\uD835\uDD68': 'wopf',
        '\uD835\uDCCC': 'wscr',
        '\uD835\uDD34': 'wfr',
        '\uD835\uDCB2': 'Wscr',
        '\uD835\uDD4E': 'Wopf',
        '\uD835\uDD1A': 'Wfr',
        'ŵ': 'wcirc',
        'Ŵ': 'Wcirc',
        '\uD835\uDD35': 'xfr',
        '\uD835\uDCCD': 'xscr',
        '\uD835\uDD69': 'xopf',
        '\uD835\uDD4F': 'Xopf',
        '\uD835\uDD1B': 'Xfr',
        '\uD835\uDCB3': 'Xscr',
        '\uD835\uDD36': 'yfr',
        '\uD835\uDCCE': 'yscr',
        '\uD835\uDD6A': 'yopf',
        '\uD835\uDCB4': 'Yscr',
        '\uD835\uDD1C': 'Yfr',
        '\uD835\uDD50': 'Yopf',
        'ý': 'yacute',
        'Ý': 'Yacute',
        'ŷ': 'ycirc',
        'Ŷ': 'Ycirc',
        'ÿ': 'yuml',
        'Ÿ': 'Yuml',
        '\uD835\uDCCF': 'zscr',
        '\uD835\uDD37': 'zfr',
        '\uD835\uDD6B': 'zopf',
        'ℨ': 'Zfr',
        'ℤ': 'Zopf',
        '\uD835\uDCB5': 'Zscr',
        'ź': 'zacute',
        'Ź': 'Zacute',
        'ž': 'zcaron',
        'Ž': 'Zcaron',
        'ż': 'zdot',
        'Ż': 'Zdot',
        'Ƶ': 'imped',
        'þ': 'thorn',
        'Þ': 'THORN',
        'ŉ': 'napos',
        'α': 'alpha',
        'Α': 'Alpha',
        'β': 'beta',
        'Β': 'Beta',
        'γ': 'gamma',
        'Γ': 'Gamma',
        'δ': 'delta',
        'Δ': 'Delta',
        'ε': 'epsi',
        'ϵ': 'epsiv',
        'Ε': 'Epsilon',
        'ϝ': 'gammad',
        'Ϝ': 'Gammad',
        'ζ': 'zeta',
        'Ζ': 'Zeta',
        'η': 'eta',
        'Η': 'Eta',
        'θ': 'theta',
        'ϑ': 'thetav',
        'Θ': 'Theta',
        'ι': 'iota',
        'Ι': 'Iota',
        'κ': 'kappa',
        'ϰ': 'kappav',
        'Κ': 'Kappa',
        'λ': 'lambda',
        'Λ': 'Lambda',
        'μ': 'mu',
        'µ': 'micro',
        'Μ': 'Mu',
        'ν': 'nu',
        'Ν': 'Nu',
        'ξ': 'xi',
        'Ξ': 'Xi',
        'ο': 'omicron',
        'Ο': 'Omicron',
        'π': 'pi',
        'ϖ': 'piv',
        'Π': 'Pi',
        'ρ': 'rho',
        'ϱ': 'rhov',
        'Ρ': 'Rho',
        'σ': 'sigma',
        'Σ': 'Sigma',
        'ς': 'sigmaf',
        'τ': 'tau',
        'Τ': 'Tau',
        'υ': 'upsi',
        'Υ': 'Upsilon',
        'ϒ': 'Upsi',
        'φ': 'phi',
        'ϕ': 'phiv',
        'Φ': 'Phi',
        'χ': 'chi',
        'Χ': 'Chi',
        'ψ': 'psi',
        'Ψ': 'Psi',
        'ω': 'omega',
        'Ω': 'ohm',
        'а': 'acy',
        'А': 'Acy',
        'б': 'bcy',
        'Б': 'Bcy',
        'в': 'vcy',
        'В': 'Vcy',
        'г': 'gcy',
        'Г': 'Gcy',
        'ѓ': 'gjcy',
        'Ѓ': 'GJcy',
        'д': 'dcy',
        'Д': 'Dcy',
        'ђ': 'djcy',
        'Ђ': 'DJcy',
        'е': 'iecy',
        'Е': 'IEcy',
        'ё': 'iocy',
        'Ё': 'IOcy',
        'є': 'jukcy',
        'Є': 'Jukcy',
        'ж': 'zhcy',
        'Ж': 'ZHcy',
        'з': 'zcy',
        'З': 'Zcy',
        'ѕ': 'dscy',
        'Ѕ': 'DScy',
        'и': 'icy',
        'И': 'Icy',
        'і': 'iukcy',
        'І': 'Iukcy',
        'ї': 'yicy',
        'Ї': 'YIcy',
        'й': 'jcy',
        'Й': 'Jcy',
        'ј': 'jsercy',
        'Ј': 'Jsercy',
        'к': 'kcy',
        'К': 'Kcy',
        'ќ': 'kjcy',
        'Ќ': 'KJcy',
        'л': 'lcy',
        'Л': 'Lcy',
        'љ': 'ljcy',
        'Љ': 'LJcy',
        'м': 'mcy',
        'М': 'Mcy',
        'н': 'ncy',
        'Н': 'Ncy',
        'њ': 'njcy',
        'Њ': 'NJcy',
        'о': 'ocy',
        'О': 'Ocy',
        'п': 'pcy',
        'П': 'Pcy',
        'р': 'rcy',
        'Р': 'Rcy',
        'с': 'scy',
        'С': 'Scy',
        'т': 'tcy',
        'Т': 'Tcy',
        'ћ': 'tshcy',
        'Ћ': 'TSHcy',
        'у': 'ucy',
        'У': 'Ucy',
        'ў': 'ubrcy',
        'Ў': 'Ubrcy',
        'ф': 'fcy',
        'Ф': 'Fcy',
        'х': 'khcy',
        'Х': 'KHcy',
        'ц': 'tscy',
        'Ц': 'TScy',
        'ч': 'chcy',
        'Ч': 'CHcy',
        'џ': 'dzcy',
        'Џ': 'DZcy',
        'ш': 'shcy',
        'Ш': 'SHcy',
        'щ': 'shchcy',
        'Щ': 'SHCHcy',
        'ъ': 'hardcy',
        'Ъ': 'HARDcy',
        'ы': 'ycy',
        'Ы': 'Ycy',
        'ь': 'softcy',
        'Ь': 'SOFTcy',
        'э': 'ecy',
        'Э': 'Ecy',
        'ю': 'yucy',
        'Ю': 'YUcy',
        'я': 'yacy',
        'Я': 'YAcy',
        'ℵ': 'aleph',
        'ℶ': 'beth',
        'ℷ': 'gimel',
        'ℸ': 'daleth'
    };
    var regexEscape = /["&'<>`]/g;
    var escapeMap = {
        '"': '&quot;',
        '&': '&amp;',
        '\'': '&#x27;',
        '<': '&lt;',
        '>': '&gt;',
        '`': '&#x60;'
    };
    var regexInvalidEntity = /&#(?:[xX][^a-fA-F0-9]|[^0-9xX])/;
    var regexInvalidRawCodePoint = /[\0-\x08\x0B\x0E-\x1F\x7F-\x9F\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
    var regexDecode = /&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)([=a-zA-Z0-9])?/g;
    var decodeMap = {
        'aacute': 'á',
        'Aacute': 'Á',
        'abreve': 'ă',
        'Abreve': 'Ă',
        'ac': '\u223E',
        'acd': '\u223F',
        'acE': '\u223E̳',
        'acirc': 'â',
        'Acirc': 'Â',
        'acute': '\xB4',
        'acy': 'а',
        'Acy': 'А',
        'aelig': 'æ',
        'AElig': 'Æ',
        'af': '\u2061',
        'afr': '\uD835\uDD1E',
        'Afr': '\uD835\uDD04',
        'agrave': 'à',
        'Agrave': 'À',
        'alefsym': 'ℵ',
        'aleph': 'ℵ',
        'alpha': 'α',
        'Alpha': 'Α',
        'amacr': 'ā',
        'Amacr': 'Ā',
        'amalg': '\u2A3F',
        'amp': '&',
        'AMP': '&',
        'and': '\u2227',
        'And': '\u2A53',
        'andand': '\u2A55',
        'andd': '\u2A5C',
        'andslope': '\u2A58',
        'andv': '\u2A5A',
        'ang': '\u2220',
        'ange': '\u29A4',
        'angle': '\u2220',
        'angmsd': '\u2221',
        'angmsdaa': '\u29A8',
        'angmsdab': '\u29A9',
        'angmsdac': '\u29AA',
        'angmsdad': '\u29AB',
        'angmsdae': '\u29AC',
        'angmsdaf': '\u29AD',
        'angmsdag': '\u29AE',
        'angmsdah': '\u29AF',
        'angrt': '\u221F',
        'angrtvb': '\u22BE',
        'angrtvbd': '\u299D',
        'angsph': '\u2222',
        'angst': 'Å',
        'angzarr': '\u237C',
        'aogon': 'ą',
        'Aogon': 'Ą',
        'aopf': '\uD835\uDD52',
        'Aopf': '\uD835\uDD38',
        'ap': '\u2248',
        'apacir': '\u2A6F',
        'ape': '\u224A',
        'apE': '\u2A70',
        'apid': '\u224B',
        'apos': '\'',
        'ApplyFunction': '\u2061',
        'approx': '\u2248',
        'approxeq': '\u224A',
        'aring': 'å',
        'Aring': 'Å',
        'ascr': '\uD835\uDCB6',
        'Ascr': '\uD835\uDC9C',
        'Assign': '\u2254',
        'ast': '*',
        'asymp': '\u2248',
        'asympeq': '\u224D',
        'atilde': 'ã',
        'Atilde': 'Ã',
        'auml': 'ä',
        'Auml': 'Ä',
        'awconint': '\u2233',
        'awint': '\u2A11',
        'backcong': '\u224C',
        'backepsilon': '\u03F6',
        'backprime': '\u2035',
        'backsim': '\u223D',
        'backsimeq': '\u22CD',
        'Backslash': '\u2216',
        'Barv': '\u2AE7',
        'barvee': '\u22BD',
        'barwed': '\u2305',
        'Barwed': '\u2306',
        'barwedge': '\u2305',
        'bbrk': '\u23B5',
        'bbrktbrk': '\u23B6',
        'bcong': '\u224C',
        'bcy': 'б',
        'Bcy': 'Б',
        'bdquo': '\u201E',
        'becaus': '\u2235',
        'because': '\u2235',
        'Because': '\u2235',
        'bemptyv': '\u29B0',
        'bepsi': '\u03F6',
        'bernou': 'ℬ',
        'Bernoullis': 'ℬ',
        'beta': 'β',
        'Beta': 'Β',
        'beth': 'ℶ',
        'between': '\u226C',
        'bfr': '\uD835\uDD1F',
        'Bfr': '\uD835\uDD05',
        'bigcap': '\u22C2',
        'bigcirc': '\u25EF',
        'bigcup': '\u22C3',
        'bigodot': '\u2A00',
        'bigoplus': '\u2A01',
        'bigotimes': '\u2A02',
        'bigsqcup': '\u2A06',
        'bigstar': '\u2605',
        'bigtriangledown': '\u25BD',
        'bigtriangleup': '\u25B3',
        'biguplus': '\u2A04',
        'bigvee': '\u22C1',
        'bigwedge': '\u22C0',
        'bkarow': '\u290D',
        'blacklozenge': '\u29EB',
        'blacksquare': '\u25AA',
        'blacktriangle': '\u25B4',
        'blacktriangledown': '\u25BE',
        'blacktriangleleft': '\u25C2',
        'blacktriangleright': '\u25B8',
        'blank': '\u2423',
        'blk12': '\u2592',
        'blk14': '\u2591',
        'blk34': '\u2593',
        'block': '\u2588',
        'bne': '=⃥',
        'bnequiv': '\u2261⃥',
        'bnot': '\u2310',
        'bNot': '\u2AED',
        'bopf': '\uD835\uDD53',
        'Bopf': '\uD835\uDD39',
        'bot': '\u22A5',
        'bottom': '\u22A5',
        'bowtie': '\u22C8',
        'boxbox': '\u29C9',
        'boxdl': '\u2510',
        'boxdL': '\u2555',
        'boxDl': '\u2556',
        'boxDL': '\u2557',
        'boxdr': '\u250C',
        'boxdR': '\u2552',
        'boxDr': '\u2553',
        'boxDR': '\u2554',
        'boxh': '\u2500',
        'boxH': '\u2550',
        'boxhd': '\u252C',
        'boxhD': '\u2565',
        'boxHd': '\u2564',
        'boxHD': '\u2566',
        'boxhu': '\u2534',
        'boxhU': '\u2568',
        'boxHu': '\u2567',
        'boxHU': '\u2569',
        'boxminus': '\u229F',
        'boxplus': '\u229E',
        'boxtimes': '\u22A0',
        'boxul': '\u2518',
        'boxuL': '\u255B',
        'boxUl': '\u255C',
        'boxUL': '\u255D',
        'boxur': '\u2514',
        'boxuR': '\u2558',
        'boxUr': '\u2559',
        'boxUR': '\u255A',
        'boxv': '\u2502',
        'boxV': '\u2551',
        'boxvh': '\u253C',
        'boxvH': '\u256A',
        'boxVh': '\u256B',
        'boxVH': '\u256C',
        'boxvl': '\u2524',
        'boxvL': '\u2561',
        'boxVl': '\u2562',
        'boxVL': '\u2563',
        'boxvr': '\u251C',
        'boxvR': '\u255E',
        'boxVr': '\u255F',
        'boxVR': '\u2560',
        'bprime': '\u2035',
        'breve': '\u02D8',
        'Breve': '\u02D8',
        'brvbar': '\xA6',
        'bscr': '\uD835\uDCB7',
        'Bscr': 'ℬ',
        'bsemi': '\u204F',
        'bsim': '\u223D',
        'bsime': '\u22CD',
        'bsol': '\\',
        'bsolb': '\u29C5',
        'bsolhsub': '\u27C8',
        'bull': '\u2022',
        'bullet': '\u2022',
        'bump': '\u224E',
        'bumpe': '\u224F',
        'bumpE': '\u2AAE',
        'bumpeq': '\u224F',
        'Bumpeq': '\u224E',
        'cacute': 'ć',
        'Cacute': 'Ć',
        'cap': '\u2229',
        'Cap': '\u22D2',
        'capand': '\u2A44',
        'capbrcup': '\u2A49',
        'capcap': '\u2A4B',
        'capcup': '\u2A47',
        'capdot': '\u2A40',
        'CapitalDifferentialD': 'ⅅ',
        'caps': '\u2229︀',
        'caret': '\u2041',
        'caron': 'ˇ',
        'Cayleys': 'ℭ',
        'ccaps': '\u2A4D',
        'ccaron': 'č',
        'Ccaron': 'Č',
        'ccedil': 'ç',
        'Ccedil': 'Ç',
        'ccirc': 'ĉ',
        'Ccirc': 'Ĉ',
        'Cconint': '\u2230',
        'ccups': '\u2A4C',
        'ccupssm': '\u2A50',
        'cdot': 'ċ',
        'Cdot': 'Ċ',
        'cedil': '\xB8',
        'Cedilla': '\xB8',
        'cemptyv': '\u29B2',
        'cent': '\xA2',
        'centerdot': '\xB7',
        'CenterDot': '\xB7',
        'cfr': '\uD835\uDD20',
        'Cfr': 'ℭ',
        'chcy': 'ч',
        'CHcy': 'Ч',
        'check': '\u2713',
        'checkmark': '\u2713',
        'chi': 'χ',
        'Chi': 'Χ',
        'cir': '\u25CB',
        'circ': 'ˆ',
        'circeq': '\u2257',
        'circlearrowleft': '\u21BA',
        'circlearrowright': '\u21BB',
        'circledast': '\u229B',
        'circledcirc': '\u229A',
        'circleddash': '\u229D',
        'CircleDot': '\u2299',
        'circledR': '\xAE',
        'circledS': '\u24C8',
        'CircleMinus': '\u2296',
        'CirclePlus': '\u2295',
        'CircleTimes': '\u2297',
        'cire': '\u2257',
        'cirE': '\u29C3',
        'cirfnint': '\u2A10',
        'cirmid': '\u2AEF',
        'cirscir': '\u29C2',
        'ClockwiseContourIntegral': '\u2232',
        'CloseCurlyDoubleQuote': '\u201D',
        'CloseCurlyQuote': '\u2019',
        'clubs': '\u2663',
        'clubsuit': '\u2663',
        'colon': ':',
        'Colon': '\u2237',
        'colone': '\u2254',
        'Colone': '\u2A74',
        'coloneq': '\u2254',
        'comma': ',',
        'commat': '@',
        'comp': '\u2201',
        'compfn': '\u2218',
        'complement': '\u2201',
        'complexes': 'ℂ',
        'cong': '\u2245',
        'congdot': '\u2A6D',
        'Congruent': '\u2261',
        'conint': '\u222E',
        'Conint': '\u222F',
        'ContourIntegral': '\u222E',
        'copf': '\uD835\uDD54',
        'Copf': 'ℂ',
        'coprod': '\u2210',
        'Coproduct': '\u2210',
        'copy': '\xA9',
        'COPY': '\xA9',
        'copysr': '\u2117',
        'CounterClockwiseContourIntegral': '\u2233',
        'crarr': '\u21B5',
        'cross': '\u2717',
        'Cross': '\u2A2F',
        'cscr': '\uD835\uDCB8',
        'Cscr': '\uD835\uDC9E',
        'csub': '\u2ACF',
        'csube': '\u2AD1',
        'csup': '\u2AD0',
        'csupe': '\u2AD2',
        'ctdot': '\u22EF',
        'cudarrl': '\u2938',
        'cudarrr': '\u2935',
        'cuepr': '\u22DE',
        'cuesc': '\u22DF',
        'cularr': '\u21B6',
        'cularrp': '\u293D',
        'cup': '\u222A',
        'Cup': '\u22D3',
        'cupbrcap': '\u2A48',
        'cupcap': '\u2A46',
        'CupCap': '\u224D',
        'cupcup': '\u2A4A',
        'cupdot': '\u228D',
        'cupor': '\u2A45',
        'cups': '\u222A︀',
        'curarr': '\u21B7',
        'curarrm': '\u293C',
        'curlyeqprec': '\u22DE',
        'curlyeqsucc': '\u22DF',
        'curlyvee': '\u22CE',
        'curlywedge': '\u22CF',
        'curren': '\xA4',
        'curvearrowleft': '\u21B6',
        'curvearrowright': '\u21B7',
        'cuvee': '\u22CE',
        'cuwed': '\u22CF',
        'cwconint': '\u2232',
        'cwint': '\u2231',
        'cylcty': '\u232D',
        'dagger': '\u2020',
        'Dagger': '\u2021',
        'daleth': 'ℸ',
        'darr': '\u2193',
        'dArr': '\u21D3',
        'Darr': '\u21A1',
        'dash': '\u2010',
        'dashv': '\u22A3',
        'Dashv': '\u2AE4',
        'dbkarow': '\u290F',
        'dblac': '\u02DD',
        'dcaron': 'ď',
        'Dcaron': 'Ď',
        'dcy': 'д',
        'Dcy': 'Д',
        'dd': 'ⅆ',
        'DD': 'ⅅ',
        'ddagger': '\u2021',
        'ddarr': '\u21CA',
        'DDotrahd': '\u2911',
        'ddotseq': '\u2A77',
        'deg': '\xB0',
        'Del': '\u2207',
        'delta': 'δ',
        'Delta': 'Δ',
        'demptyv': '\u29B1',
        'dfisht': '\u297F',
        'dfr': '\uD835\uDD21',
        'Dfr': '\uD835\uDD07',
        'dHar': '\u2965',
        'dharl': '\u21C3',
        'dharr': '\u21C2',
        'DiacriticalAcute': '\xB4',
        'DiacriticalDot': '\u02D9',
        'DiacriticalDoubleAcute': '\u02DD',
        'DiacriticalGrave': '`',
        'DiacriticalTilde': '\u02DC',
        'diam': '\u22C4',
        'diamond': '\u22C4',
        'Diamond': '\u22C4',
        'diamondsuit': '\u2666',
        'diams': '\u2666',
        'die': '\xA8',
        'DifferentialD': 'ⅆ',
        'digamma': 'ϝ',
        'disin': '\u22F2',
        'div': '\xF7',
        'divide': '\xF7',
        'divideontimes': '\u22C7',
        'divonx': '\u22C7',
        'djcy': 'ђ',
        'DJcy': 'Ђ',
        'dlcorn': '\u231E',
        'dlcrop': '\u230D',
        'dollar': '$',
        'dopf': '\uD835\uDD55',
        'Dopf': '\uD835\uDD3B',
        'dot': '\u02D9',
        'Dot': '\xA8',
        'DotDot': '⃜',
        'doteq': '\u2250',
        'doteqdot': '\u2251',
        'DotEqual': '\u2250',
        'dotminus': '\u2238',
        'dotplus': '\u2214',
        'dotsquare': '\u22A1',
        'doublebarwedge': '\u2306',
        'DoubleContourIntegral': '\u222F',
        'DoubleDot': '\xA8',
        'DoubleDownArrow': '\u21D3',
        'DoubleLeftArrow': '\u21D0',
        'DoubleLeftRightArrow': '\u21D4',
        'DoubleLeftTee': '\u2AE4',
        'DoubleLongLeftArrow': '\u27F8',
        'DoubleLongLeftRightArrow': '\u27FA',
        'DoubleLongRightArrow': '\u27F9',
        'DoubleRightArrow': '\u21D2',
        'DoubleRightTee': '\u22A8',
        'DoubleUpArrow': '\u21D1',
        'DoubleUpDownArrow': '\u21D5',
        'DoubleVerticalBar': '\u2225',
        'downarrow': '\u2193',
        'Downarrow': '\u21D3',
        'DownArrow': '\u2193',
        'DownArrowBar': '\u2913',
        'DownArrowUpArrow': '\u21F5',
        'DownBreve': '̑',
        'downdownarrows': '\u21CA',
        'downharpoonleft': '\u21C3',
        'downharpoonright': '\u21C2',
        'DownLeftRightVector': '\u2950',
        'DownLeftTeeVector': '\u295E',
        'DownLeftVector': '\u21BD',
        'DownLeftVectorBar': '\u2956',
        'DownRightTeeVector': '\u295F',
        'DownRightVector': '\u21C1',
        'DownRightVectorBar': '\u2957',
        'DownTee': '\u22A4',
        'DownTeeArrow': '\u21A7',
        'drbkarow': '\u2910',
        'drcorn': '\u231F',
        'drcrop': '\u230C',
        'dscr': '\uD835\uDCB9',
        'Dscr': '\uD835\uDC9F',
        'dscy': 'ѕ',
        'DScy': 'Ѕ',
        'dsol': '\u29F6',
        'dstrok': 'đ',
        'Dstrok': 'Đ',
        'dtdot': '\u22F1',
        'dtri': '\u25BF',
        'dtrif': '\u25BE',
        'duarr': '\u21F5',
        'duhar': '\u296F',
        'dwangle': '\u29A6',
        'dzcy': 'џ',
        'DZcy': 'Џ',
        'dzigrarr': '\u27FF',
        'eacute': 'é',
        'Eacute': 'É',
        'easter': '\u2A6E',
        'ecaron': 'ě',
        'Ecaron': 'Ě',
        'ecir': '\u2256',
        'ecirc': 'ê',
        'Ecirc': 'Ê',
        'ecolon': '\u2255',
        'ecy': 'э',
        'Ecy': 'Э',
        'eDDot': '\u2A77',
        'edot': 'ė',
        'eDot': '\u2251',
        'Edot': 'Ė',
        'ee': 'ⅇ',
        'efDot': '\u2252',
        'efr': '\uD835\uDD22',
        'Efr': '\uD835\uDD08',
        'eg': '\u2A9A',
        'egrave': 'è',
        'Egrave': 'È',
        'egs': '\u2A96',
        'egsdot': '\u2A98',
        'el': '\u2A99',
        'Element': '\u2208',
        'elinters': '\u23E7',
        'ell': 'ℓ',
        'els': '\u2A95',
        'elsdot': '\u2A97',
        'emacr': 'ē',
        'Emacr': 'Ē',
        'empty': '\u2205',
        'emptyset': '\u2205',
        'EmptySmallSquare': '\u25FB',
        'emptyv': '\u2205',
        'EmptyVerySmallSquare': '\u25AB',
        'emsp': '\u2003',
        'emsp13': '\u2004',
        'emsp14': '\u2005',
        'eng': 'ŋ',
        'ENG': 'Ŋ',
        'ensp': '\u2002',
        'eogon': 'ę',
        'Eogon': 'Ę',
        'eopf': '\uD835\uDD56',
        'Eopf': '\uD835\uDD3C',
        'epar': '\u22D5',
        'eparsl': '\u29E3',
        'eplus': '\u2A71',
        'epsi': 'ε',
        'epsilon': 'ε',
        'Epsilon': 'Ε',
        'epsiv': 'ϵ',
        'eqcirc': '\u2256',
        'eqcolon': '\u2255',
        'eqsim': '\u2242',
        'eqslantgtr': '\u2A96',
        'eqslantless': '\u2A95',
        'Equal': '\u2A75',
        'equals': '=',
        'EqualTilde': '\u2242',
        'equest': '\u225F',
        'Equilibrium': '\u21CC',
        'equiv': '\u2261',
        'equivDD': '\u2A78',
        'eqvparsl': '\u29E5',
        'erarr': '\u2971',
        'erDot': '\u2253',
        'escr': 'ℯ',
        'Escr': 'ℰ',
        'esdot': '\u2250',
        'esim': '\u2242',
        'Esim': '\u2A73',
        'eta': 'η',
        'Eta': 'Η',
        'eth': 'ð',
        'ETH': 'Ð',
        'euml': 'ë',
        'Euml': 'Ë',
        'euro': '\u20AC',
        'excl': '!',
        'exist': '\u2203',
        'Exists': '\u2203',
        'expectation': 'ℰ',
        'exponentiale': 'ⅇ',
        'ExponentialE': 'ⅇ',
        'fallingdotseq': '\u2252',
        'fcy': 'ф',
        'Fcy': 'Ф',
        'female': '\u2640',
        'ffilig': 'ﬃ',
        'fflig': 'ﬀ',
        'ffllig': 'ﬄ',
        'ffr': '\uD835\uDD23',
        'Ffr': '\uD835\uDD09',
        'filig': 'ﬁ',
        'FilledSmallSquare': '\u25FC',
        'FilledVerySmallSquare': '\u25AA',
        'fjlig': 'fj',
        'flat': '\u266D',
        'fllig': 'ﬂ',
        'fltns': '\u25B1',
        'fnof': 'ƒ',
        'fopf': '\uD835\uDD57',
        'Fopf': '\uD835\uDD3D',
        'forall': '\u2200',
        'ForAll': '\u2200',
        'fork': '\u22D4',
        'forkv': '\u2AD9',
        'Fouriertrf': 'ℱ',
        'fpartint': '\u2A0D',
        'frac12': '\xBD',
        'frac13': '\u2153',
        'frac14': '\xBC',
        'frac15': '\u2155',
        'frac16': '\u2159',
        'frac18': '\u215B',
        'frac23': '\u2154',
        'frac25': '\u2156',
        'frac34': '\xBE',
        'frac35': '\u2157',
        'frac38': '\u215C',
        'frac45': '\u2158',
        'frac56': '\u215A',
        'frac58': '\u215D',
        'frac78': '\u215E',
        'frasl': '\u2044',
        'frown': '\u2322',
        'fscr': '\uD835\uDCBB',
        'Fscr': 'ℱ',
        'gacute': 'ǵ',
        'gamma': 'γ',
        'Gamma': 'Γ',
        'gammad': 'ϝ',
        'Gammad': 'Ϝ',
        'gap': '\u2A86',
        'gbreve': 'ğ',
        'Gbreve': 'Ğ',
        'Gcedil': 'Ģ',
        'gcirc': 'ĝ',
        'Gcirc': 'Ĝ',
        'gcy': 'г',
        'Gcy': 'Г',
        'gdot': 'ġ',
        'Gdot': 'Ġ',
        'ge': '\u2265',
        'gE': '\u2267',
        'gel': '\u22DB',
        'gEl': '\u2A8C',
        'geq': '\u2265',
        'geqq': '\u2267',
        'geqslant': '\u2A7E',
        'ges': '\u2A7E',
        'gescc': '\u2AA9',
        'gesdot': '\u2A80',
        'gesdoto': '\u2A82',
        'gesdotol': '\u2A84',
        'gesl': '\u22DB︀',
        'gesles': '\u2A94',
        'gfr': '\uD835\uDD24',
        'Gfr': '\uD835\uDD0A',
        'gg': '\u226B',
        'Gg': '\u22D9',
        'ggg': '\u22D9',
        'gimel': 'ℷ',
        'gjcy': 'ѓ',
        'GJcy': 'Ѓ',
        'gl': '\u2277',
        'gla': '\u2AA5',
        'glE': '\u2A92',
        'glj': '\u2AA4',
        'gnap': '\u2A8A',
        'gnapprox': '\u2A8A',
        'gne': '\u2A88',
        'gnE': '\u2269',
        'gneq': '\u2A88',
        'gneqq': '\u2269',
        'gnsim': '\u22E7',
        'gopf': '\uD835\uDD58',
        'Gopf': '\uD835\uDD3E',
        'grave': '`',
        'GreaterEqual': '\u2265',
        'GreaterEqualLess': '\u22DB',
        'GreaterFullEqual': '\u2267',
        'GreaterGreater': '\u2AA2',
        'GreaterLess': '\u2277',
        'GreaterSlantEqual': '\u2A7E',
        'GreaterTilde': '\u2273',
        'gscr': 'ℊ',
        'Gscr': '\uD835\uDCA2',
        'gsim': '\u2273',
        'gsime': '\u2A8E',
        'gsiml': '\u2A90',
        'gt': '>',
        'Gt': '\u226B',
        'GT': '>',
        'gtcc': '\u2AA7',
        'gtcir': '\u2A7A',
        'gtdot': '\u22D7',
        'gtlPar': '\u2995',
        'gtquest': '\u2A7C',
        'gtrapprox': '\u2A86',
        'gtrarr': '\u2978',
        'gtrdot': '\u22D7',
        'gtreqless': '\u22DB',
        'gtreqqless': '\u2A8C',
        'gtrless': '\u2277',
        'gtrsim': '\u2273',
        'gvertneqq': '\u2269︀',
        'gvnE': '\u2269︀',
        'Hacek': 'ˇ',
        'hairsp': '\u200A',
        'half': '\xBD',
        'hamilt': 'ℋ',
        'hardcy': 'ъ',
        'HARDcy': 'Ъ',
        'harr': '\u2194',
        'hArr': '\u21D4',
        'harrcir': '\u2948',
        'harrw': '\u21AD',
        'Hat': '^',
        'hbar': 'ℏ',
        'hcirc': 'ĥ',
        'Hcirc': 'Ĥ',
        'hearts': '\u2665',
        'heartsuit': '\u2665',
        'hellip': '\u2026',
        'hercon': '\u22B9',
        'hfr': '\uD835\uDD25',
        'Hfr': 'ℌ',
        'HilbertSpace': 'ℋ',
        'hksearow': '\u2925',
        'hkswarow': '\u2926',
        'hoarr': '\u21FF',
        'homtht': '\u223B',
        'hookleftarrow': '\u21A9',
        'hookrightarrow': '\u21AA',
        'hopf': '\uD835\uDD59',
        'Hopf': 'ℍ',
        'horbar': '\u2015',
        'HorizontalLine': '\u2500',
        'hscr': '\uD835\uDCBD',
        'Hscr': 'ℋ',
        'hslash': 'ℏ',
        'hstrok': 'ħ',
        'Hstrok': 'Ħ',
        'HumpDownHump': '\u224E',
        'HumpEqual': '\u224F',
        'hybull': '\u2043',
        'hyphen': '\u2010',
        'iacute': 'í',
        'Iacute': 'Í',
        'ic': '\u2063',
        'icirc': 'î',
        'Icirc': 'Î',
        'icy': 'и',
        'Icy': 'И',
        'Idot': 'İ',
        'iecy': 'е',
        'IEcy': 'Е',
        'iexcl': '\xA1',
        'iff': '\u21D4',
        'ifr': '\uD835\uDD26',
        'Ifr': 'ℑ',
        'igrave': 'ì',
        'Igrave': 'Ì',
        'ii': 'ⅈ',
        'iiiint': '\u2A0C',
        'iiint': '\u222D',
        'iinfin': '\u29DC',
        'iiota': '\u2129',
        'ijlig': 'ĳ',
        'IJlig': 'Ĳ',
        'Im': 'ℑ',
        'imacr': 'ī',
        'Imacr': 'Ī',
        'image': 'ℑ',
        'ImaginaryI': 'ⅈ',
        'imagline': 'ℐ',
        'imagpart': 'ℑ',
        'imath': 'ı',
        'imof': '\u22B7',
        'imped': 'Ƶ',
        'Implies': '\u21D2',
        'in': '\u2208',
        'incare': '\u2105',
        'infin': '\u221E',
        'infintie': '\u29DD',
        'inodot': 'ı',
        'int': '\u222B',
        'Int': '\u222C',
        'intcal': '\u22BA',
        'integers': 'ℤ',
        'Integral': '\u222B',
        'intercal': '\u22BA',
        'Intersection': '\u22C2',
        'intlarhk': '\u2A17',
        'intprod': '\u2A3C',
        'InvisibleComma': '\u2063',
        'InvisibleTimes': '\u2062',
        'iocy': 'ё',
        'IOcy': 'Ё',
        'iogon': 'į',
        'Iogon': 'Į',
        'iopf': '\uD835\uDD5A',
        'Iopf': '\uD835\uDD40',
        'iota': 'ι',
        'Iota': 'Ι',
        'iprod': '\u2A3C',
        'iquest': '\xBF',
        'iscr': '\uD835\uDCBE',
        'Iscr': 'ℐ',
        'isin': '\u2208',
        'isindot': '\u22F5',
        'isinE': '\u22F9',
        'isins': '\u22F4',
        'isinsv': '\u22F3',
        'isinv': '\u2208',
        'it': '\u2062',
        'itilde': 'ĩ',
        'Itilde': 'Ĩ',
        'iukcy': 'і',
        'Iukcy': 'І',
        'iuml': 'ï',
        'Iuml': 'Ï',
        'jcirc': 'ĵ',
        'Jcirc': 'Ĵ',
        'jcy': 'й',
        'Jcy': 'Й',
        'jfr': '\uD835\uDD27',
        'Jfr': '\uD835\uDD0D',
        'jmath': 'ȷ',
        'jopf': '\uD835\uDD5B',
        'Jopf': '\uD835\uDD41',
        'jscr': '\uD835\uDCBF',
        'Jscr': '\uD835\uDCA5',
        'jsercy': 'ј',
        'Jsercy': 'Ј',
        'jukcy': 'є',
        'Jukcy': 'Є',
        'kappa': 'κ',
        'Kappa': 'Κ',
        'kappav': 'ϰ',
        'kcedil': 'ķ',
        'Kcedil': 'Ķ',
        'kcy': 'к',
        'Kcy': 'К',
        'kfr': '\uD835\uDD28',
        'Kfr': '\uD835\uDD0E',
        'kgreen': 'ĸ',
        'khcy': 'х',
        'KHcy': 'Х',
        'kjcy': 'ќ',
        'KJcy': 'Ќ',
        'kopf': '\uD835\uDD5C',
        'Kopf': '\uD835\uDD42',
        'kscr': '\uD835\uDCC0',
        'Kscr': '\uD835\uDCA6',
        'lAarr': '\u21DA',
        'lacute': 'ĺ',
        'Lacute': 'Ĺ',
        'laemptyv': '\u29B4',
        'lagran': 'ℒ',
        'lambda': 'λ',
        'Lambda': 'Λ',
        'lang': '\u27E8',
        'Lang': '\u27EA',
        'langd': '\u2991',
        'langle': '\u27E8',
        'lap': '\u2A85',
        'Laplacetrf': 'ℒ',
        'laquo': '\xAB',
        'larr': '\u2190',
        'lArr': '\u21D0',
        'Larr': '\u219E',
        'larrb': '\u21E4',
        'larrbfs': '\u291F',
        'larrfs': '\u291D',
        'larrhk': '\u21A9',
        'larrlp': '\u21AB',
        'larrpl': '\u2939',
        'larrsim': '\u2973',
        'larrtl': '\u21A2',
        'lat': '\u2AAB',
        'latail': '\u2919',
        'lAtail': '\u291B',
        'late': '\u2AAD',
        'lates': '\u2AAD︀',
        'lbarr': '\u290C',
        'lBarr': '\u290E',
        'lbbrk': '\u2772',
        'lbrace': '{',
        'lbrack': '[',
        'lbrke': '\u298B',
        'lbrksld': '\u298F',
        'lbrkslu': '\u298D',
        'lcaron': 'ľ',
        'Lcaron': 'Ľ',
        'lcedil': 'ļ',
        'Lcedil': 'Ļ',
        'lceil': '\u2308',
        'lcub': '{',
        'lcy': 'л',
        'Lcy': 'Л',
        'ldca': '\u2936',
        'ldquo': '\u201C',
        'ldquor': '\u201E',
        'ldrdhar': '\u2967',
        'ldrushar': '\u294B',
        'ldsh': '\u21B2',
        'le': '\u2264',
        'lE': '\u2266',
        'LeftAngleBracket': '\u27E8',
        'leftarrow': '\u2190',
        'Leftarrow': '\u21D0',
        'LeftArrow': '\u2190',
        'LeftArrowBar': '\u21E4',
        'LeftArrowRightArrow': '\u21C6',
        'leftarrowtail': '\u21A2',
        'LeftCeiling': '\u2308',
        'LeftDoubleBracket': '\u27E6',
        'LeftDownTeeVector': '\u2961',
        'LeftDownVector': '\u21C3',
        'LeftDownVectorBar': '\u2959',
        'LeftFloor': '\u230A',
        'leftharpoondown': '\u21BD',
        'leftharpoonup': '\u21BC',
        'leftleftarrows': '\u21C7',
        'leftrightarrow': '\u2194',
        'Leftrightarrow': '\u21D4',
        'LeftRightArrow': '\u2194',
        'leftrightarrows': '\u21C6',
        'leftrightharpoons': '\u21CB',
        'leftrightsquigarrow': '\u21AD',
        'LeftRightVector': '\u294E',
        'LeftTee': '\u22A3',
        'LeftTeeArrow': '\u21A4',
        'LeftTeeVector': '\u295A',
        'leftthreetimes': '\u22CB',
        'LeftTriangle': '\u22B2',
        'LeftTriangleBar': '\u29CF',
        'LeftTriangleEqual': '\u22B4',
        'LeftUpDownVector': '\u2951',
        'LeftUpTeeVector': '\u2960',
        'LeftUpVector': '\u21BF',
        'LeftUpVectorBar': '\u2958',
        'LeftVector': '\u21BC',
        'LeftVectorBar': '\u2952',
        'leg': '\u22DA',
        'lEg': '\u2A8B',
        'leq': '\u2264',
        'leqq': '\u2266',
        'leqslant': '\u2A7D',
        'les': '\u2A7D',
        'lescc': '\u2AA8',
        'lesdot': '\u2A7F',
        'lesdoto': '\u2A81',
        'lesdotor': '\u2A83',
        'lesg': '\u22DA︀',
        'lesges': '\u2A93',
        'lessapprox': '\u2A85',
        'lessdot': '\u22D6',
        'lesseqgtr': '\u22DA',
        'lesseqqgtr': '\u2A8B',
        'LessEqualGreater': '\u22DA',
        'LessFullEqual': '\u2266',
        'LessGreater': '\u2276',
        'lessgtr': '\u2276',
        'LessLess': '\u2AA1',
        'lesssim': '\u2272',
        'LessSlantEqual': '\u2A7D',
        'LessTilde': '\u2272',
        'lfisht': '\u297C',
        'lfloor': '\u230A',
        'lfr': '\uD835\uDD29',
        'Lfr': '\uD835\uDD0F',
        'lg': '\u2276',
        'lgE': '\u2A91',
        'lHar': '\u2962',
        'lhard': '\u21BD',
        'lharu': '\u21BC',
        'lharul': '\u296A',
        'lhblk': '\u2584',
        'ljcy': 'љ',
        'LJcy': 'Љ',
        'll': '\u226A',
        'Ll': '\u22D8',
        'llarr': '\u21C7',
        'llcorner': '\u231E',
        'Lleftarrow': '\u21DA',
        'llhard': '\u296B',
        'lltri': '\u25FA',
        'lmidot': 'ŀ',
        'Lmidot': 'Ŀ',
        'lmoust': '\u23B0',
        'lmoustache': '\u23B0',
        'lnap': '\u2A89',
        'lnapprox': '\u2A89',
        'lne': '\u2A87',
        'lnE': '\u2268',
        'lneq': '\u2A87',
        'lneqq': '\u2268',
        'lnsim': '\u22E6',
        'loang': '\u27EC',
        'loarr': '\u21FD',
        'lobrk': '\u27E6',
        'longleftarrow': '\u27F5',
        'Longleftarrow': '\u27F8',
        'LongLeftArrow': '\u27F5',
        'longleftrightarrow': '\u27F7',
        'Longleftrightarrow': '\u27FA',
        'LongLeftRightArrow': '\u27F7',
        'longmapsto': '\u27FC',
        'longrightarrow': '\u27F6',
        'Longrightarrow': '\u27F9',
        'LongRightArrow': '\u27F6',
        'looparrowleft': '\u21AB',
        'looparrowright': '\u21AC',
        'lopar': '\u2985',
        'lopf': '\uD835\uDD5D',
        'Lopf': '\uD835\uDD43',
        'loplus': '\u2A2D',
        'lotimes': '\u2A34',
        'lowast': '\u2217',
        'lowbar': '_',
        'LowerLeftArrow': '\u2199',
        'LowerRightArrow': '\u2198',
        'loz': '\u25CA',
        'lozenge': '\u25CA',
        'lozf': '\u29EB',
        'lpar': '(',
        'lparlt': '\u2993',
        'lrarr': '\u21C6',
        'lrcorner': '\u231F',
        'lrhar': '\u21CB',
        'lrhard': '\u296D',
        'lrm': '\u200E',
        'lrtri': '\u22BF',
        'lsaquo': '\u2039',
        'lscr': '\uD835\uDCC1',
        'Lscr': 'ℒ',
        'lsh': '\u21B0',
        'Lsh': '\u21B0',
        'lsim': '\u2272',
        'lsime': '\u2A8D',
        'lsimg': '\u2A8F',
        'lsqb': '[',
        'lsquo': '\u2018',
        'lsquor': '\u201A',
        'lstrok': 'ł',
        'Lstrok': 'Ł',
        'lt': '<',
        'Lt': '\u226A',
        'LT': '<',
        'ltcc': '\u2AA6',
        'ltcir': '\u2A79',
        'ltdot': '\u22D6',
        'lthree': '\u22CB',
        'ltimes': '\u22C9',
        'ltlarr': '\u2976',
        'ltquest': '\u2A7B',
        'ltri': '\u25C3',
        'ltrie': '\u22B4',
        'ltrif': '\u25C2',
        'ltrPar': '\u2996',
        'lurdshar': '\u294A',
        'luruhar': '\u2966',
        'lvertneqq': '\u2268︀',
        'lvnE': '\u2268︀',
        'macr': '\xAF',
        'male': '\u2642',
        'malt': '\u2720',
        'maltese': '\u2720',
        'map': '\u21A6',
        'Map': '\u2905',
        'mapsto': '\u21A6',
        'mapstodown': '\u21A7',
        'mapstoleft': '\u21A4',
        'mapstoup': '\u21A5',
        'marker': '\u25AE',
        'mcomma': '\u2A29',
        'mcy': 'м',
        'Mcy': 'М',
        'mdash': '\u2014',
        'mDDot': '\u223A',
        'measuredangle': '\u2221',
        'MediumSpace': '\u205F',
        'Mellintrf': 'ℳ',
        'mfr': '\uD835\uDD2A',
        'Mfr': '\uD835\uDD10',
        'mho': '\u2127',
        'micro': 'µ',
        'mid': '\u2223',
        'midast': '*',
        'midcir': '\u2AF0',
        'middot': '\xB7',
        'minus': '\u2212',
        'minusb': '\u229F',
        'minusd': '\u2238',
        'minusdu': '\u2A2A',
        'MinusPlus': '\u2213',
        'mlcp': '\u2ADB',
        'mldr': '\u2026',
        'mnplus': '\u2213',
        'models': '\u22A7',
        'mopf': '\uD835\uDD5E',
        'Mopf': '\uD835\uDD44',
        'mp': '\u2213',
        'mscr': '\uD835\uDCC2',
        'Mscr': 'ℳ',
        'mstpos': '\u223E',
        'mu': 'μ',
        'Mu': 'Μ',
        'multimap': '\u22B8',
        'mumap': '\u22B8',
        'nabla': '\u2207',
        'nacute': 'ń',
        'Nacute': 'Ń',
        'nang': '\u2220⃒',
        'nap': '\u2249',
        'napE': '\u2A70̸',
        'napid': '\u224B̸',
        'napos': 'ŉ',
        'napprox': '\u2249',
        'natur': '\u266E',
        'natural': '\u266E',
        'naturals': 'ℕ',
        'nbsp': '\xA0',
        'nbump': '\u224E̸',
        'nbumpe': '\u224F̸',
        'ncap': '\u2A43',
        'ncaron': 'ň',
        'Ncaron': 'Ň',
        'ncedil': 'ņ',
        'Ncedil': 'Ņ',
        'ncong': '\u2247',
        'ncongdot': '\u2A6D̸',
        'ncup': '\u2A42',
        'ncy': 'н',
        'Ncy': 'Н',
        'ndash': '\u2013',
        'ne': '\u2260',
        'nearhk': '\u2924',
        'nearr': '\u2197',
        'neArr': '\u21D7',
        'nearrow': '\u2197',
        'nedot': '\u2250̸',
        'NegativeMediumSpace': '\u200B',
        'NegativeThickSpace': '\u200B',
        'NegativeThinSpace': '\u200B',
        'NegativeVeryThinSpace': '\u200B',
        'nequiv': '\u2262',
        'nesear': '\u2928',
        'nesim': '\u2242̸',
        'NestedGreaterGreater': '\u226B',
        'NestedLessLess': '\u226A',
        'NewLine': '\n',
        'nexist': '\u2204',
        'nexists': '\u2204',
        'nfr': '\uD835\uDD2B',
        'Nfr': '\uD835\uDD11',
        'nge': '\u2271',
        'ngE': '\u2267̸',
        'ngeq': '\u2271',
        'ngeqq': '\u2267̸',
        'ngeqslant': '\u2A7E̸',
        'nges': '\u2A7E̸',
        'nGg': '\u22D9̸',
        'ngsim': '\u2275',
        'ngt': '\u226F',
        'nGt': '\u226B⃒',
        'ngtr': '\u226F',
        'nGtv': '\u226B̸',
        'nharr': '\u21AE',
        'nhArr': '\u21CE',
        'nhpar': '\u2AF2',
        'ni': '\u220B',
        'nis': '\u22FC',
        'nisd': '\u22FA',
        'niv': '\u220B',
        'njcy': 'њ',
        'NJcy': 'Њ',
        'nlarr': '\u219A',
        'nlArr': '\u21CD',
        'nldr': '\u2025',
        'nle': '\u2270',
        'nlE': '\u2266̸',
        'nleftarrow': '\u219A',
        'nLeftarrow': '\u21CD',
        'nleftrightarrow': '\u21AE',
        'nLeftrightarrow': '\u21CE',
        'nleq': '\u2270',
        'nleqq': '\u2266̸',
        'nleqslant': '\u2A7D̸',
        'nles': '\u2A7D̸',
        'nless': '\u226E',
        'nLl': '\u22D8̸',
        'nlsim': '\u2274',
        'nlt': '\u226E',
        'nLt': '\u226A⃒',
        'nltri': '\u22EA',
        'nltrie': '\u22EC',
        'nLtv': '\u226A̸',
        'nmid': '\u2224',
        'NoBreak': '\u2060',
        'NonBreakingSpace': '\xA0',
        'nopf': '\uD835\uDD5F',
        'Nopf': 'ℕ',
        'not': '\xAC',
        'Not': '\u2AEC',
        'NotCongruent': '\u2262',
        'NotCupCap': '\u226D',
        'NotDoubleVerticalBar': '\u2226',
        'NotElement': '\u2209',
        'NotEqual': '\u2260',
        'NotEqualTilde': '\u2242̸',
        'NotExists': '\u2204',
        'NotGreater': '\u226F',
        'NotGreaterEqual': '\u2271',
        'NotGreaterFullEqual': '\u2267̸',
        'NotGreaterGreater': '\u226B̸',
        'NotGreaterLess': '\u2279',
        'NotGreaterSlantEqual': '\u2A7E̸',
        'NotGreaterTilde': '\u2275',
        'NotHumpDownHump': '\u224E̸',
        'NotHumpEqual': '\u224F̸',
        'notin': '\u2209',
        'notindot': '\u22F5̸',
        'notinE': '\u22F9̸',
        'notinva': '\u2209',
        'notinvb': '\u22F7',
        'notinvc': '\u22F6',
        'NotLeftTriangle': '\u22EA',
        'NotLeftTriangleBar': '\u29CF̸',
        'NotLeftTriangleEqual': '\u22EC',
        'NotLess': '\u226E',
        'NotLessEqual': '\u2270',
        'NotLessGreater': '\u2278',
        'NotLessLess': '\u226A̸',
        'NotLessSlantEqual': '\u2A7D̸',
        'NotLessTilde': '\u2274',
        'NotNestedGreaterGreater': '\u2AA2̸',
        'NotNestedLessLess': '\u2AA1̸',
        'notni': '\u220C',
        'notniva': '\u220C',
        'notnivb': '\u22FE',
        'notnivc': '\u22FD',
        'NotPrecedes': '\u2280',
        'NotPrecedesEqual': '\u2AAF̸',
        'NotPrecedesSlantEqual': '\u22E0',
        'NotReverseElement': '\u220C',
        'NotRightTriangle': '\u22EB',
        'NotRightTriangleBar': '\u29D0̸',
        'NotRightTriangleEqual': '\u22ED',
        'NotSquareSubset': '\u228F̸',
        'NotSquareSubsetEqual': '\u22E2',
        'NotSquareSuperset': '\u2290̸',
        'NotSquareSupersetEqual': '\u22E3',
        'NotSubset': '\u2282⃒',
        'NotSubsetEqual': '\u2288',
        'NotSucceeds': '\u2281',
        'NotSucceedsEqual': '\u2AB0̸',
        'NotSucceedsSlantEqual': '\u22E1',
        'NotSucceedsTilde': '\u227F̸',
        'NotSuperset': '\u2283⃒',
        'NotSupersetEqual': '\u2289',
        'NotTilde': '\u2241',
        'NotTildeEqual': '\u2244',
        'NotTildeFullEqual': '\u2247',
        'NotTildeTilde': '\u2249',
        'NotVerticalBar': '\u2224',
        'npar': '\u2226',
        'nparallel': '\u2226',
        'nparsl': '\u2AFD⃥',
        'npart': '\u2202̸',
        'npolint': '\u2A14',
        'npr': '\u2280',
        'nprcue': '\u22E0',
        'npre': '\u2AAF̸',
        'nprec': '\u2280',
        'npreceq': '\u2AAF̸',
        'nrarr': '\u219B',
        'nrArr': '\u21CF',
        'nrarrc': '\u2933̸',
        'nrarrw': '\u219D̸',
        'nrightarrow': '\u219B',
        'nRightarrow': '\u21CF',
        'nrtri': '\u22EB',
        'nrtrie': '\u22ED',
        'nsc': '\u2281',
        'nsccue': '\u22E1',
        'nsce': '\u2AB0̸',
        'nscr': '\uD835\uDCC3',
        'Nscr': '\uD835\uDCA9',
        'nshortmid': '\u2224',
        'nshortparallel': '\u2226',
        'nsim': '\u2241',
        'nsime': '\u2244',
        'nsimeq': '\u2244',
        'nsmid': '\u2224',
        'nspar': '\u2226',
        'nsqsube': '\u22E2',
        'nsqsupe': '\u22E3',
        'nsub': '\u2284',
        'nsube': '\u2288',
        'nsubE': '\u2AC5̸',
        'nsubset': '\u2282⃒',
        'nsubseteq': '\u2288',
        'nsubseteqq': '\u2AC5̸',
        'nsucc': '\u2281',
        'nsucceq': '\u2AB0̸',
        'nsup': '\u2285',
        'nsupe': '\u2289',
        'nsupE': '\u2AC6̸',
        'nsupset': '\u2283⃒',
        'nsupseteq': '\u2289',
        'nsupseteqq': '\u2AC6̸',
        'ntgl': '\u2279',
        'ntilde': 'ñ',
        'Ntilde': 'Ñ',
        'ntlg': '\u2278',
        'ntriangleleft': '\u22EA',
        'ntrianglelefteq': '\u22EC',
        'ntriangleright': '\u22EB',
        'ntrianglerighteq': '\u22ED',
        'nu': 'ν',
        'Nu': 'Ν',
        'num': '#',
        'numero': '\u2116',
        'numsp': '\u2007',
        'nvap': '\u224D⃒',
        'nvdash': '\u22AC',
        'nvDash': '\u22AD',
        'nVdash': '\u22AE',
        'nVDash': '\u22AF',
        'nvge': '\u2265⃒',
        'nvgt': '>⃒',
        'nvHarr': '\u2904',
        'nvinfin': '\u29DE',
        'nvlArr': '\u2902',
        'nvle': '\u2264⃒',
        'nvlt': '<⃒',
        'nvltrie': '\u22B4⃒',
        'nvrArr': '\u2903',
        'nvrtrie': '\u22B5⃒',
        'nvsim': '\u223C⃒',
        'nwarhk': '\u2923',
        'nwarr': '\u2196',
        'nwArr': '\u21D6',
        'nwarrow': '\u2196',
        'nwnear': '\u2927',
        'oacute': 'ó',
        'Oacute': 'Ó',
        'oast': '\u229B',
        'ocir': '\u229A',
        'ocirc': 'ô',
        'Ocirc': 'Ô',
        'ocy': 'о',
        'Ocy': 'О',
        'odash': '\u229D',
        'odblac': 'ő',
        'Odblac': 'Ő',
        'odiv': '\u2A38',
        'odot': '\u2299',
        'odsold': '\u29BC',
        'oelig': 'œ',
        'OElig': 'Œ',
        'ofcir': '\u29BF',
        'ofr': '\uD835\uDD2C',
        'Ofr': '\uD835\uDD12',
        'ogon': '\u02DB',
        'ograve': 'ò',
        'Ograve': 'Ò',
        'ogt': '\u29C1',
        'ohbar': '\u29B5',
        'ohm': 'Ω',
        'oint': '\u222E',
        'olarr': '\u21BA',
        'olcir': '\u29BE',
        'olcross': '\u29BB',
        'oline': '\u203E',
        'olt': '\u29C0',
        'omacr': 'ō',
        'Omacr': 'Ō',
        'omega': 'ω',
        'Omega': 'Ω',
        'omicron': 'ο',
        'Omicron': 'Ο',
        'omid': '\u29B6',
        'ominus': '\u2296',
        'oopf': '\uD835\uDD60',
        'Oopf': '\uD835\uDD46',
        'opar': '\u29B7',
        'OpenCurlyDoubleQuote': '\u201C',
        'OpenCurlyQuote': '\u2018',
        'operp': '\u29B9',
        'oplus': '\u2295',
        'or': '\u2228',
        'Or': '\u2A54',
        'orarr': '\u21BB',
        'ord': '\u2A5D',
        'order': 'ℴ',
        'orderof': 'ℴ',
        'ordf': 'ª',
        'ordm': 'º',
        'origof': '\u22B6',
        'oror': '\u2A56',
        'orslope': '\u2A57',
        'orv': '\u2A5B',
        'oS': '\u24C8',
        'oscr': 'ℴ',
        'Oscr': '\uD835\uDCAA',
        'oslash': 'ø',
        'Oslash': 'Ø',
        'osol': '\u2298',
        'otilde': 'õ',
        'Otilde': 'Õ',
        'otimes': '\u2297',
        'Otimes': '\u2A37',
        'otimesas': '\u2A36',
        'ouml': 'ö',
        'Ouml': 'Ö',
        'ovbar': '\u233D',
        'OverBar': '\u203E',
        'OverBrace': '\u23DE',
        'OverBracket': '\u23B4',
        'OverParenthesis': '\u23DC',
        'par': '\u2225',
        'para': '\xB6',
        'parallel': '\u2225',
        'parsim': '\u2AF3',
        'parsl': '\u2AFD',
        'part': '\u2202',
        'PartialD': '\u2202',
        'pcy': 'п',
        'Pcy': 'П',
        'percnt': '%',
        'period': '.',
        'permil': '\u2030',
        'perp': '\u22A5',
        'pertenk': '\u2031',
        'pfr': '\uD835\uDD2D',
        'Pfr': '\uD835\uDD13',
        'phi': 'φ',
        'Phi': 'Φ',
        'phiv': 'ϕ',
        'phmmat': 'ℳ',
        'phone': '\u260E',
        'pi': 'π',
        'Pi': 'Π',
        'pitchfork': '\u22D4',
        'piv': 'ϖ',
        'planck': 'ℏ',
        'planckh': 'ℎ',
        'plankv': 'ℏ',
        'plus': '+',
        'plusacir': '\u2A23',
        'plusb': '\u229E',
        'pluscir': '\u2A22',
        'plusdo': '\u2214',
        'plusdu': '\u2A25',
        'pluse': '\u2A72',
        'PlusMinus': '\xB1',
        'plusmn': '\xB1',
        'plussim': '\u2A26',
        'plustwo': '\u2A27',
        'pm': '\xB1',
        'Poincareplane': 'ℌ',
        'pointint': '\u2A15',
        'popf': '\uD835\uDD61',
        'Popf': 'ℙ',
        'pound': '\xA3',
        'pr': '\u227A',
        'Pr': '\u2ABB',
        'prap': '\u2AB7',
        'prcue': '\u227C',
        'pre': '\u2AAF',
        'prE': '\u2AB3',
        'prec': '\u227A',
        'precapprox': '\u2AB7',
        'preccurlyeq': '\u227C',
        'Precedes': '\u227A',
        'PrecedesEqual': '\u2AAF',
        'PrecedesSlantEqual': '\u227C',
        'PrecedesTilde': '\u227E',
        'preceq': '\u2AAF',
        'precnapprox': '\u2AB9',
        'precneqq': '\u2AB5',
        'precnsim': '\u22E8',
        'precsim': '\u227E',
        'prime': '\u2032',
        'Prime': '\u2033',
        'primes': 'ℙ',
        'prnap': '\u2AB9',
        'prnE': '\u2AB5',
        'prnsim': '\u22E8',
        'prod': '\u220F',
        'Product': '\u220F',
        'profalar': '\u232E',
        'profline': '\u2312',
        'profsurf': '\u2313',
        'prop': '\u221D',
        'Proportion': '\u2237',
        'Proportional': '\u221D',
        'propto': '\u221D',
        'prsim': '\u227E',
        'prurel': '\u22B0',
        'pscr': '\uD835\uDCC5',
        'Pscr': '\uD835\uDCAB',
        'psi': 'ψ',
        'Psi': 'Ψ',
        'puncsp': '\u2008',
        'qfr': '\uD835\uDD2E',
        'Qfr': '\uD835\uDD14',
        'qint': '\u2A0C',
        'qopf': '\uD835\uDD62',
        'Qopf': 'ℚ',
        'qprime': '\u2057',
        'qscr': '\uD835\uDCC6',
        'Qscr': '\uD835\uDCAC',
        'quaternions': 'ℍ',
        'quatint': '\u2A16',
        'quest': '?',
        'questeq': '\u225F',
        'quot': '"',
        'QUOT': '"',
        'rAarr': '\u21DB',
        'race': '\u223Ḏ',
        'racute': 'ŕ',
        'Racute': 'Ŕ',
        'radic': '\u221A',
        'raemptyv': '\u29B3',
        'rang': '\u27E9',
        'Rang': '\u27EB',
        'rangd': '\u2992',
        'range': '\u29A5',
        'rangle': '\u27E9',
        'raquo': '\xBB',
        'rarr': '\u2192',
        'rArr': '\u21D2',
        'Rarr': '\u21A0',
        'rarrap': '\u2975',
        'rarrb': '\u21E5',
        'rarrbfs': '\u2920',
        'rarrc': '\u2933',
        'rarrfs': '\u291E',
        'rarrhk': '\u21AA',
        'rarrlp': '\u21AC',
        'rarrpl': '\u2945',
        'rarrsim': '\u2974',
        'rarrtl': '\u21A3',
        'Rarrtl': '\u2916',
        'rarrw': '\u219D',
        'ratail': '\u291A',
        'rAtail': '\u291C',
        'ratio': '\u2236',
        'rationals': 'ℚ',
        'rbarr': '\u290D',
        'rBarr': '\u290F',
        'RBarr': '\u2910',
        'rbbrk': '\u2773',
        'rbrace': '}',
        'rbrack': ']',
        'rbrke': '\u298C',
        'rbrksld': '\u298E',
        'rbrkslu': '\u2990',
        'rcaron': 'ř',
        'Rcaron': 'Ř',
        'rcedil': 'ŗ',
        'Rcedil': 'Ŗ',
        'rceil': '\u2309',
        'rcub': '}',
        'rcy': 'р',
        'Rcy': 'Р',
        'rdca': '\u2937',
        'rdldhar': '\u2969',
        'rdquo': '\u201D',
        'rdquor': '\u201D',
        'rdsh': '\u21B3',
        'Re': 'ℜ',
        'real': 'ℜ',
        'realine': 'ℛ',
        'realpart': 'ℜ',
        'reals': 'ℝ',
        'rect': '\u25AD',
        'reg': '\xAE',
        'REG': '\xAE',
        'ReverseElement': '\u220B',
        'ReverseEquilibrium': '\u21CB',
        'ReverseUpEquilibrium': '\u296F',
        'rfisht': '\u297D',
        'rfloor': '\u230B',
        'rfr': '\uD835\uDD2F',
        'Rfr': 'ℜ',
        'rHar': '\u2964',
        'rhard': '\u21C1',
        'rharu': '\u21C0',
        'rharul': '\u296C',
        'rho': 'ρ',
        'Rho': 'Ρ',
        'rhov': 'ϱ',
        'RightAngleBracket': '\u27E9',
        'rightarrow': '\u2192',
        'Rightarrow': '\u21D2',
        'RightArrow': '\u2192',
        'RightArrowBar': '\u21E5',
        'RightArrowLeftArrow': '\u21C4',
        'rightarrowtail': '\u21A3',
        'RightCeiling': '\u2309',
        'RightDoubleBracket': '\u27E7',
        'RightDownTeeVector': '\u295D',
        'RightDownVector': '\u21C2',
        'RightDownVectorBar': '\u2955',
        'RightFloor': '\u230B',
        'rightharpoondown': '\u21C1',
        'rightharpoonup': '\u21C0',
        'rightleftarrows': '\u21C4',
        'rightleftharpoons': '\u21CC',
        'rightrightarrows': '\u21C9',
        'rightsquigarrow': '\u219D',
        'RightTee': '\u22A2',
        'RightTeeArrow': '\u21A6',
        'RightTeeVector': '\u295B',
        'rightthreetimes': '\u22CC',
        'RightTriangle': '\u22B3',
        'RightTriangleBar': '\u29D0',
        'RightTriangleEqual': '\u22B5',
        'RightUpDownVector': '\u294F',
        'RightUpTeeVector': '\u295C',
        'RightUpVector': '\u21BE',
        'RightUpVectorBar': '\u2954',
        'RightVector': '\u21C0',
        'RightVectorBar': '\u2953',
        'ring': '\u02DA',
        'risingdotseq': '\u2253',
        'rlarr': '\u21C4',
        'rlhar': '\u21CC',
        'rlm': '\u200F',
        'rmoust': '\u23B1',
        'rmoustache': '\u23B1',
        'rnmid': '\u2AEE',
        'roang': '\u27ED',
        'roarr': '\u21FE',
        'robrk': '\u27E7',
        'ropar': '\u2986',
        'ropf': '\uD835\uDD63',
        'Ropf': 'ℝ',
        'roplus': '\u2A2E',
        'rotimes': '\u2A35',
        'RoundImplies': '\u2970',
        'rpar': ')',
        'rpargt': '\u2994',
        'rppolint': '\u2A12',
        'rrarr': '\u21C9',
        'Rrightarrow': '\u21DB',
        'rsaquo': '\u203A',
        'rscr': '\uD835\uDCC7',
        'Rscr': 'ℛ',
        'rsh': '\u21B1',
        'Rsh': '\u21B1',
        'rsqb': ']',
        'rsquo': '\u2019',
        'rsquor': '\u2019',
        'rthree': '\u22CC',
        'rtimes': '\u22CA',
        'rtri': '\u25B9',
        'rtrie': '\u22B5',
        'rtrif': '\u25B8',
        'rtriltri': '\u29CE',
        'RuleDelayed': '\u29F4',
        'ruluhar': '\u2968',
        'rx': '\u211E',
        'sacute': 'ś',
        'Sacute': 'Ś',
        'sbquo': '\u201A',
        'sc': '\u227B',
        'Sc': '\u2ABC',
        'scap': '\u2AB8',
        'scaron': 'š',
        'Scaron': 'Š',
        'sccue': '\u227D',
        'sce': '\u2AB0',
        'scE': '\u2AB4',
        'scedil': 'ş',
        'Scedil': 'Ş',
        'scirc': 'ŝ',
        'Scirc': 'Ŝ',
        'scnap': '\u2ABA',
        'scnE': '\u2AB6',
        'scnsim': '\u22E9',
        'scpolint': '\u2A13',
        'scsim': '\u227F',
        'scy': 'с',
        'Scy': 'С',
        'sdot': '\u22C5',
        'sdotb': '\u22A1',
        'sdote': '\u2A66',
        'searhk': '\u2925',
        'searr': '\u2198',
        'seArr': '\u21D8',
        'searrow': '\u2198',
        'sect': '\xA7',
        'semi': ';',
        'seswar': '\u2929',
        'setminus': '\u2216',
        'setmn': '\u2216',
        'sext': '\u2736',
        'sfr': '\uD835\uDD30',
        'Sfr': '\uD835\uDD16',
        'sfrown': '\u2322',
        'sharp': '\u266F',
        'shchcy': 'щ',
        'SHCHcy': 'Щ',
        'shcy': 'ш',
        'SHcy': 'Ш',
        'ShortDownArrow': '\u2193',
        'ShortLeftArrow': '\u2190',
        'shortmid': '\u2223',
        'shortparallel': '\u2225',
        'ShortRightArrow': '\u2192',
        'ShortUpArrow': '\u2191',
        'shy': '\xAD',
        'sigma': 'σ',
        'Sigma': 'Σ',
        'sigmaf': 'ς',
        'sigmav': 'ς',
        'sim': '\u223C',
        'simdot': '\u2A6A',
        'sime': '\u2243',
        'simeq': '\u2243',
        'simg': '\u2A9E',
        'simgE': '\u2AA0',
        'siml': '\u2A9D',
        'simlE': '\u2A9F',
        'simne': '\u2246',
        'simplus': '\u2A24',
        'simrarr': '\u2972',
        'slarr': '\u2190',
        'SmallCircle': '\u2218',
        'smallsetminus': '\u2216',
        'smashp': '\u2A33',
        'smeparsl': '\u29E4',
        'smid': '\u2223',
        'smile': '\u2323',
        'smt': '\u2AAA',
        'smte': '\u2AAC',
        'smtes': '\u2AAC︀',
        'softcy': 'ь',
        'SOFTcy': 'Ь',
        'sol': '/',
        'solb': '\u29C4',
        'solbar': '\u233F',
        'sopf': '\uD835\uDD64',
        'Sopf': '\uD835\uDD4A',
        'spades': '\u2660',
        'spadesuit': '\u2660',
        'spar': '\u2225',
        'sqcap': '\u2293',
        'sqcaps': '\u2293︀',
        'sqcup': '\u2294',
        'sqcups': '\u2294︀',
        'Sqrt': '\u221A',
        'sqsub': '\u228F',
        'sqsube': '\u2291',
        'sqsubset': '\u228F',
        'sqsubseteq': '\u2291',
        'sqsup': '\u2290',
        'sqsupe': '\u2292',
        'sqsupset': '\u2290',
        'sqsupseteq': '\u2292',
        'squ': '\u25A1',
        'square': '\u25A1',
        'Square': '\u25A1',
        'SquareIntersection': '\u2293',
        'SquareSubset': '\u228F',
        'SquareSubsetEqual': '\u2291',
        'SquareSuperset': '\u2290',
        'SquareSupersetEqual': '\u2292',
        'SquareUnion': '\u2294',
        'squarf': '\u25AA',
        'squf': '\u25AA',
        'srarr': '\u2192',
        'sscr': '\uD835\uDCC8',
        'Sscr': '\uD835\uDCAE',
        'ssetmn': '\u2216',
        'ssmile': '\u2323',
        'sstarf': '\u22C6',
        'star': '\u2606',
        'Star': '\u22C6',
        'starf': '\u2605',
        'straightepsilon': 'ϵ',
        'straightphi': 'ϕ',
        'strns': '\xAF',
        'sub': '\u2282',
        'Sub': '\u22D0',
        'subdot': '\u2ABD',
        'sube': '\u2286',
        'subE': '\u2AC5',
        'subedot': '\u2AC3',
        'submult': '\u2AC1',
        'subne': '\u228A',
        'subnE': '\u2ACB',
        'subplus': '\u2ABF',
        'subrarr': '\u2979',
        'subset': '\u2282',
        'Subset': '\u22D0',
        'subseteq': '\u2286',
        'subseteqq': '\u2AC5',
        'SubsetEqual': '\u2286',
        'subsetneq': '\u228A',
        'subsetneqq': '\u2ACB',
        'subsim': '\u2AC7',
        'subsub': '\u2AD5',
        'subsup': '\u2AD3',
        'succ': '\u227B',
        'succapprox': '\u2AB8',
        'succcurlyeq': '\u227D',
        'Succeeds': '\u227B',
        'SucceedsEqual': '\u2AB0',
        'SucceedsSlantEqual': '\u227D',
        'SucceedsTilde': '\u227F',
        'succeq': '\u2AB0',
        'succnapprox': '\u2ABA',
        'succneqq': '\u2AB6',
        'succnsim': '\u22E9',
        'succsim': '\u227F',
        'SuchThat': '\u220B',
        'sum': '\u2211',
        'Sum': '\u2211',
        'sung': '\u266A',
        'sup': '\u2283',
        'Sup': '\u22D1',
        'sup1': '\xB9',
        'sup2': '\xB2',
        'sup3': '\xB3',
        'supdot': '\u2ABE',
        'supdsub': '\u2AD8',
        'supe': '\u2287',
        'supE': '\u2AC6',
        'supedot': '\u2AC4',
        'Superset': '\u2283',
        'SupersetEqual': '\u2287',
        'suphsol': '\u27C9',
        'suphsub': '\u2AD7',
        'suplarr': '\u297B',
        'supmult': '\u2AC2',
        'supne': '\u228B',
        'supnE': '\u2ACC',
        'supplus': '\u2AC0',
        'supset': '\u2283',
        'Supset': '\u22D1',
        'supseteq': '\u2287',
        'supseteqq': '\u2AC6',
        'supsetneq': '\u228B',
        'supsetneqq': '\u2ACC',
        'supsim': '\u2AC8',
        'supsub': '\u2AD4',
        'supsup': '\u2AD6',
        'swarhk': '\u2926',
        'swarr': '\u2199',
        'swArr': '\u21D9',
        'swarrow': '\u2199',
        'swnwar': '\u292A',
        'szlig': 'ß',
        'Tab': '\t',
        'target': '\u2316',
        'tau': 'τ',
        'Tau': 'Τ',
        'tbrk': '\u23B4',
        'tcaron': 'ť',
        'Tcaron': 'Ť',
        'tcedil': 'ţ',
        'Tcedil': 'Ţ',
        'tcy': 'т',
        'Tcy': 'Т',
        'tdot': '⃛',
        'telrec': '\u2315',
        'tfr': '\uD835\uDD31',
        'Tfr': '\uD835\uDD17',
        'there4': '\u2234',
        'therefore': '\u2234',
        'Therefore': '\u2234',
        'theta': 'θ',
        'Theta': 'Θ',
        'thetasym': 'ϑ',
        'thetav': 'ϑ',
        'thickapprox': '\u2248',
        'thicksim': '\u223C',
        'ThickSpace': '\u205F\u200A',
        'thinsp': '\u2009',
        'ThinSpace': '\u2009',
        'thkap': '\u2248',
        'thksim': '\u223C',
        'thorn': 'þ',
        'THORN': 'Þ',
        'tilde': '\u02DC',
        'Tilde': '\u223C',
        'TildeEqual': '\u2243',
        'TildeFullEqual': '\u2245',
        'TildeTilde': '\u2248',
        'times': '\xD7',
        'timesb': '\u22A0',
        'timesbar': '\u2A31',
        'timesd': '\u2A30',
        'tint': '\u222D',
        'toea': '\u2928',
        'top': '\u22A4',
        'topbot': '\u2336',
        'topcir': '\u2AF1',
        'topf': '\uD835\uDD65',
        'Topf': '\uD835\uDD4B',
        'topfork': '\u2ADA',
        'tosa': '\u2929',
        'tprime': '\u2034',
        'trade': '\u2122',
        'TRADE': '\u2122',
        'triangle': '\u25B5',
        'triangledown': '\u25BF',
        'triangleleft': '\u25C3',
        'trianglelefteq': '\u22B4',
        'triangleq': '\u225C',
        'triangleright': '\u25B9',
        'trianglerighteq': '\u22B5',
        'tridot': '\u25EC',
        'trie': '\u225C',
        'triminus': '\u2A3A',
        'TripleDot': '⃛',
        'triplus': '\u2A39',
        'trisb': '\u29CD',
        'tritime': '\u2A3B',
        'trpezium': '\u23E2',
        'tscr': '\uD835\uDCC9',
        'Tscr': '\uD835\uDCAF',
        'tscy': 'ц',
        'TScy': 'Ц',
        'tshcy': 'ћ',
        'TSHcy': 'Ћ',
        'tstrok': 'ŧ',
        'Tstrok': 'Ŧ',
        'twixt': '\u226C',
        'twoheadleftarrow': '\u219E',
        'twoheadrightarrow': '\u21A0',
        'uacute': 'ú',
        'Uacute': 'Ú',
        'uarr': '\u2191',
        'uArr': '\u21D1',
        'Uarr': '\u219F',
        'Uarrocir': '\u2949',
        'ubrcy': 'ў',
        'Ubrcy': 'Ў',
        'ubreve': 'ŭ',
        'Ubreve': 'Ŭ',
        'ucirc': 'û',
        'Ucirc': 'Û',
        'ucy': 'у',
        'Ucy': 'У',
        'udarr': '\u21C5',
        'udblac': 'ű',
        'Udblac': 'Ű',
        'udhar': '\u296E',
        'ufisht': '\u297E',
        'ufr': '\uD835\uDD32',
        'Ufr': '\uD835\uDD18',
        'ugrave': 'ù',
        'Ugrave': 'Ù',
        'uHar': '\u2963',
        'uharl': '\u21BF',
        'uharr': '\u21BE',
        'uhblk': '\u2580',
        'ulcorn': '\u231C',
        'ulcorner': '\u231C',
        'ulcrop': '\u230F',
        'ultri': '\u25F8',
        'umacr': 'ū',
        'Umacr': 'Ū',
        'uml': '\xA8',
        'UnderBar': '_',
        'UnderBrace': '\u23DF',
        'UnderBracket': '\u23B5',
        'UnderParenthesis': '\u23DD',
        'Union': '\u22C3',
        'UnionPlus': '\u228E',
        'uogon': 'ų',
        'Uogon': 'Ų',
        'uopf': '\uD835\uDD66',
        'Uopf': '\uD835\uDD4C',
        'uparrow': '\u2191',
        'Uparrow': '\u21D1',
        'UpArrow': '\u2191',
        'UpArrowBar': '\u2912',
        'UpArrowDownArrow': '\u21C5',
        'updownarrow': '\u2195',
        'Updownarrow': '\u21D5',
        'UpDownArrow': '\u2195',
        'UpEquilibrium': '\u296E',
        'upharpoonleft': '\u21BF',
        'upharpoonright': '\u21BE',
        'uplus': '\u228E',
        'UpperLeftArrow': '\u2196',
        'UpperRightArrow': '\u2197',
        'upsi': 'υ',
        'Upsi': 'ϒ',
        'upsih': 'ϒ',
        'upsilon': 'υ',
        'Upsilon': 'Υ',
        'UpTee': '\u22A5',
        'UpTeeArrow': '\u21A5',
        'upuparrows': '\u21C8',
        'urcorn': '\u231D',
        'urcorner': '\u231D',
        'urcrop': '\u230E',
        'uring': 'ů',
        'Uring': 'Ů',
        'urtri': '\u25F9',
        'uscr': '\uD835\uDCCA',
        'Uscr': '\uD835\uDCB0',
        'utdot': '\u22F0',
        'utilde': 'ũ',
        'Utilde': 'Ũ',
        'utri': '\u25B5',
        'utrif': '\u25B4',
        'uuarr': '\u21C8',
        'uuml': 'ü',
        'Uuml': 'Ü',
        'uwangle': '\u29A7',
        'vangrt': '\u299C',
        'varepsilon': 'ϵ',
        'varkappa': 'ϰ',
        'varnothing': '\u2205',
        'varphi': 'ϕ',
        'varpi': 'ϖ',
        'varpropto': '\u221D',
        'varr': '\u2195',
        'vArr': '\u21D5',
        'varrho': 'ϱ',
        'varsigma': 'ς',
        'varsubsetneq': '\u228A︀',
        'varsubsetneqq': '\u2ACB︀',
        'varsupsetneq': '\u228B︀',
        'varsupsetneqq': '\u2ACC︀',
        'vartheta': 'ϑ',
        'vartriangleleft': '\u22B2',
        'vartriangleright': '\u22B3',
        'vBar': '\u2AE8',
        'Vbar': '\u2AEB',
        'vBarv': '\u2AE9',
        'vcy': 'в',
        'Vcy': 'В',
        'vdash': '\u22A2',
        'vDash': '\u22A8',
        'Vdash': '\u22A9',
        'VDash': '\u22AB',
        'Vdashl': '\u2AE6',
        'vee': '\u2228',
        'Vee': '\u22C1',
        'veebar': '\u22BB',
        'veeeq': '\u225A',
        'vellip': '\u22EE',
        'verbar': '|',
        'Verbar': '\u2016',
        'vert': '|',
        'Vert': '\u2016',
        'VerticalBar': '\u2223',
        'VerticalLine': '|',
        'VerticalSeparator': '\u2758',
        'VerticalTilde': '\u2240',
        'VeryThinSpace': '\u200A',
        'vfr': '\uD835\uDD33',
        'Vfr': '\uD835\uDD19',
        'vltri': '\u22B2',
        'vnsub': '\u2282⃒',
        'vnsup': '\u2283⃒',
        'vopf': '\uD835\uDD67',
        'Vopf': '\uD835\uDD4D',
        'vprop': '\u221D',
        'vrtri': '\u22B3',
        'vscr': '\uD835\uDCCB',
        'Vscr': '\uD835\uDCB1',
        'vsubne': '\u228A︀',
        'vsubnE': '\u2ACB︀',
        'vsupne': '\u228B︀',
        'vsupnE': '\u2ACC︀',
        'Vvdash': '\u22AA',
        'vzigzag': '\u299A',
        'wcirc': 'ŵ',
        'Wcirc': 'Ŵ',
        'wedbar': '\u2A5F',
        'wedge': '\u2227',
        'Wedge': '\u22C0',
        'wedgeq': '\u2259',
        'weierp': '\u2118',
        'wfr': '\uD835\uDD34',
        'Wfr': '\uD835\uDD1A',
        'wopf': '\uD835\uDD68',
        'Wopf': '\uD835\uDD4E',
        'wp': '\u2118',
        'wr': '\u2240',
        'wreath': '\u2240',
        'wscr': '\uD835\uDCCC',
        'Wscr': '\uD835\uDCB2',
        'xcap': '\u22C2',
        'xcirc': '\u25EF',
        'xcup': '\u22C3',
        'xdtri': '\u25BD',
        'xfr': '\uD835\uDD35',
        'Xfr': '\uD835\uDD1B',
        'xharr': '\u27F7',
        'xhArr': '\u27FA',
        'xi': 'ξ',
        'Xi': 'Ξ',
        'xlarr': '\u27F5',
        'xlArr': '\u27F8',
        'xmap': '\u27FC',
        'xnis': '\u22FB',
        'xodot': '\u2A00',
        'xopf': '\uD835\uDD69',
        'Xopf': '\uD835\uDD4F',
        'xoplus': '\u2A01',
        'xotime': '\u2A02',
        'xrarr': '\u27F6',
        'xrArr': '\u27F9',
        'xscr': '\uD835\uDCCD',
        'Xscr': '\uD835\uDCB3',
        'xsqcup': '\u2A06',
        'xuplus': '\u2A04',
        'xutri': '\u25B3',
        'xvee': '\u22C1',
        'xwedge': '\u22C0',
        'yacute': 'ý',
        'Yacute': 'Ý',
        'yacy': 'я',
        'YAcy': 'Я',
        'ycirc': 'ŷ',
        'Ycirc': 'Ŷ',
        'ycy': 'ы',
        'Ycy': 'Ы',
        'yen': '\xA5',
        'yfr': '\uD835\uDD36',
        'Yfr': '\uD835\uDD1C',
        'yicy': 'ї',
        'YIcy': 'Ї',
        'yopf': '\uD835\uDD6A',
        'Yopf': '\uD835\uDD50',
        'yscr': '\uD835\uDCCE',
        'Yscr': '\uD835\uDCB4',
        'yucy': 'ю',
        'YUcy': 'Ю',
        'yuml': 'ÿ',
        'Yuml': 'Ÿ',
        'zacute': 'ź',
        'Zacute': 'Ź',
        'zcaron': 'ž',
        'Zcaron': 'Ž',
        'zcy': 'з',
        'Zcy': 'З',
        'zdot': 'ż',
        'Zdot': 'Ż',
        'zeetrf': 'ℨ',
        'ZeroWidthSpace': '\u200B',
        'zeta': 'ζ',
        'Zeta': 'Ζ',
        'zfr': '\uD835\uDD37',
        'Zfr': 'ℨ',
        'zhcy': 'ж',
        'ZHcy': 'Ж',
        'zigrarr': '\u21DD',
        'zopf': '\uD835\uDD6B',
        'Zopf': 'ℤ',
        'zscr': '\uD835\uDCCF',
        'Zscr': '\uD835\uDCB5',
        'zwj': '‍',
        'zwnj': '‌'
    };
    var decodeMapLegacy = {
        'aacute': 'á',
        'Aacute': 'Á',
        'acirc': 'â',
        'Acirc': 'Â',
        'acute': '\xB4',
        'aelig': 'æ',
        'AElig': 'Æ',
        'agrave': 'à',
        'Agrave': 'À',
        'amp': '&',
        'AMP': '&',
        'aring': 'å',
        'Aring': 'Å',
        'atilde': 'ã',
        'Atilde': 'Ã',
        'auml': 'ä',
        'Auml': 'Ä',
        'brvbar': '\xA6',
        'ccedil': 'ç',
        'Ccedil': 'Ç',
        'cedil': '\xB8',
        'cent': '\xA2',
        'copy': '\xA9',
        'COPY': '\xA9',
        'curren': '\xA4',
        'deg': '\xB0',
        'divide': '\xF7',
        'eacute': 'é',
        'Eacute': 'É',
        'ecirc': 'ê',
        'Ecirc': 'Ê',
        'egrave': 'è',
        'Egrave': 'È',
        'eth': 'ð',
        'ETH': 'Ð',
        'euml': 'ë',
        'Euml': 'Ë',
        'frac12': '\xBD',
        'frac14': '\xBC',
        'frac34': '\xBE',
        'gt': '>',
        'GT': '>',
        'iacute': 'í',
        'Iacute': 'Í',
        'icirc': 'î',
        'Icirc': 'Î',
        'iexcl': '\xA1',
        'igrave': 'ì',
        'Igrave': 'Ì',
        'iquest': '\xBF',
        'iuml': 'ï',
        'Iuml': 'Ï',
        'laquo': '\xAB',
        'lt': '<',
        'LT': '<',
        'macr': '\xAF',
        'micro': 'µ',
        'middot': '\xB7',
        'nbsp': '\xA0',
        'not': '\xAC',
        'ntilde': 'ñ',
        'Ntilde': 'Ñ',
        'oacute': 'ó',
        'Oacute': 'Ó',
        'ocirc': 'ô',
        'Ocirc': 'Ô',
        'ograve': 'ò',
        'Ograve': 'Ò',
        'ordf': 'ª',
        'ordm': 'º',
        'oslash': 'ø',
        'Oslash': 'Ø',
        'otilde': 'õ',
        'Otilde': 'Õ',
        'ouml': 'ö',
        'Ouml': 'Ö',
        'para': '\xB6',
        'plusmn': '\xB1',
        'pound': '\xA3',
        'quot': '"',
        'QUOT': '"',
        'raquo': '\xBB',
        'reg': '\xAE',
        'REG': '\xAE',
        'sect': '\xA7',
        'shy': '\xAD',
        'sup1': '\xB9',
        'sup2': '\xB2',
        'sup3': '\xB3',
        'szlig': 'ß',
        'thorn': 'þ',
        'THORN': 'Þ',
        'times': '\xD7',
        'uacute': 'ú',
        'Uacute': 'Ú',
        'ucirc': 'û',
        'Ucirc': 'Û',
        'ugrave': 'ù',
        'Ugrave': 'Ù',
        'uml': '\xA8',
        'uuml': 'ü',
        'Uuml': 'Ü',
        'yacute': 'ý',
        'Yacute': 'Ý',
        'yen': '\xA5',
        'yuml': 'ÿ'
    };
    var decodeMapNumeric = {
        '0': '\uFFFD',
        '128': '\u20AC',
        '130': '\u201A',
        '131': 'ƒ',
        '132': '\u201E',
        '133': '\u2026',
        '134': '\u2020',
        '135': '\u2021',
        '136': 'ˆ',
        '137': '\u2030',
        '138': 'Š',
        '139': '\u2039',
        '140': 'Œ',
        '142': 'Ž',
        '145': '\u2018',
        '146': '\u2019',
        '147': '\u201C',
        '148': '\u201D',
        '149': '\u2022',
        '150': '\u2013',
        '151': '\u2014',
        '152': '\u02DC',
        '153': '\u2122',
        '154': 'š',
        '155': '\u203A',
        '156': 'œ',
        '158': 'ž',
        '159': 'Ÿ'
    };
    var invalidReferenceCodePoints = [
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        11,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        27,
        28,
        29,
        30,
        31,
        127,
        128,
        129,
        130,
        131,
        132,
        133,
        134,
        135,
        136,
        137,
        138,
        139,
        140,
        141,
        142,
        143,
        144,
        145,
        146,
        147,
        148,
        149,
        150,
        151,
        152,
        153,
        154,
        155,
        156,
        157,
        158,
        159,
        64976,
        64977,
        64978,
        64979,
        64980,
        64981,
        64982,
        64983,
        64984,
        64985,
        64986,
        64987,
        64988,
        64989,
        64990,
        64991,
        64992,
        64993,
        64994,
        64995,
        64996,
        64997,
        64998,
        64999,
        65000,
        65001,
        65002,
        65003,
        65004,
        65005,
        65006,
        65007,
        65534,
        65535,
        131070,
        131071,
        196606,
        196607,
        262142,
        262143,
        327678,
        327679,
        393214,
        393215,
        458750,
        458751,
        524286,
        524287,
        589822,
        589823,
        655358,
        655359,
        720894,
        720895,
        786430,
        786431,
        851966,
        851967,
        917502,
        917503,
        983038,
        983039,
        1048574,
        1048575,
        1114110,
        1114111
    ];
    var stringFromCharCode = String.fromCharCode;
    var object = {};
    var hasOwnProperty = object.hasOwnProperty;
    var has = function (object, propertyName) {
        return hasOwnProperty.call(object, propertyName);
    };
    var contains = function (array, value) {
        var index = -1;
        var length = array.length;
        while (++index < length) {
            if (array[index] == value) {
                return true;
            }
        }
        return false;
    };
    var merge = function (options, defaults) {
        if (!options) {
            return defaults;
        }
        var result = {};
        var key;
        for (key in defaults) {
            result[key] = has(options, key) ? options[key] : defaults[key];
        }
        return result;
    };
    var codePointToSymbol = function (codePoint, strict) {
        var output = '';
        if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
            if (strict) {
                parseError('character reference outside the permissible Unicode range');
            }
            return '\uFFFD';
        }
        if (has(decodeMapNumeric, codePoint)) {
            if (strict) {
                parseError('disallowed character reference');
            }
            return decodeMapNumeric[codePoint];
        }
        if (strict && contains(invalidReferenceCodePoints, codePoint)) {
            parseError('disallowed character reference');
        }
        if (codePoint > 65535) {
            codePoint -= 65536;
            output += stringFromCharCode(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
        }
        output += stringFromCharCode(codePoint);
        return output;
    };
    var hexEscape = function (codePoint) {
        return '&#x' + codePoint.toString(16).toUpperCase() + ';';
    };
    var decEscape = function (codePoint) {
        return '&#' + codePoint + ';';
    };
    var parseError = function (message) {
        throw Error('Parse error: ' + message);
    };
    var encode = function (string, options) {
        options = merge(options, encode.options);
        var strict = options.strict;
        if (strict && regexInvalidRawCodePoint.test(string)) {
            parseError('forbidden code point');
        }
        var encodeEverything = options.encodeEverything;
        var useNamedReferences = options.useNamedReferences;
        var allowUnsafeSymbols = options.allowUnsafeSymbols;
        var escapeCodePoint = options.decimal ? decEscape : hexEscape;
        var escapeBmpSymbol = function (symbol) {
            return escapeCodePoint(symbol.charCodeAt(0));
        };
        if (encodeEverything) {
            string = string.replace(regexAsciiWhitelist, function (symbol) {
                if (useNamedReferences && has(encodeMap, symbol)) {
                    return '&' + encodeMap[symbol] + ';';
                }
                return escapeBmpSymbol(symbol);
            });
            if (useNamedReferences) {
                string = string.replace(/&gt;\u20D2/g, '&nvgt;').replace(/&lt;\u20D2/g, '&nvlt;').replace(/&#x66;&#x6A;/g, '&fjlig;');
            }
            if (useNamedReferences) {
                string = string.replace(regexEncodeNonAscii, function (string) {
                    return '&' + encodeMap[string] + ';';
                });
            }
        } else if (useNamedReferences) {
            if (!allowUnsafeSymbols) {
                string = string.replace(regexEscape, function (string) {
                    return '&' + encodeMap[string] + ';';
                });
            }
            string = string.replace(/&gt;\u20D2/g, '&nvgt;').replace(/&lt;\u20D2/g, '&nvlt;');
            string = string.replace(regexEncodeNonAscii, function (string) {
                return '&' + encodeMap[string] + ';';
            });
        } else if (!allowUnsafeSymbols) {
            string = string.replace(regexEscape, escapeBmpSymbol);
        }
        return string.replace(regexAstralSymbols, function ($0) {
            var high = $0.charCodeAt(0);
            var low = $0.charCodeAt(1);
            var codePoint = (high - 55296) * 1024 + low - 56320 + 65536;
            return escapeCodePoint(codePoint);
        }).replace(regexBmpWhitelist, escapeBmpSymbol);
    };
    encode.options = {
        'allowUnsafeSymbols': false,
        'encodeEverything': false,
        'strict': false,
        'useNamedReferences': false,
        'decimal': false
    };
    var decode = function (html, options) {
        options = merge(options, decode.options);
        var strict = options.strict;
        if (strict && regexInvalidEntity.test(html)) {
            parseError('malformed character reference');
        }
        return html.replace(regexDecode, function ($0, $1, $2, $3, $4, $5, $6, $7) {
            var codePoint;
            var semicolon;
            var decDigits;
            var hexDigits;
            var reference;
            var next;
            if ($1) {
                decDigits = $1;
                semicolon = $2;
                if (strict && !semicolon) {
                    parseError('character reference was not terminated by a semicolon');
                }
                codePoint = parseInt(decDigits, 10);
                return codePointToSymbol(codePoint, strict);
            }
            if ($3) {
                hexDigits = $3;
                semicolon = $4;
                if (strict && !semicolon) {
                    parseError('character reference was not terminated by a semicolon');
                }
                codePoint = parseInt(hexDigits, 16);
                return codePointToSymbol(codePoint, strict);
            }
            if ($5) {
                reference = $5;
                if (has(decodeMap, reference)) {
                    return decodeMap[reference];
                } else {
                    if (strict) {
                        parseError('named character reference was not terminated by a semicolon');
                    }
                    return $0;
                }
            }
            reference = $6;
            next = $7;
            if (next && options.isAttributeValue) {
                if (strict && next == '=') {
                    parseError('`&` did not start a character reference');
                }
                return $0;
            } else {
                if (strict) {
                    parseError('named character reference was not terminated by a semicolon');
                }
                return decodeMapLegacy[reference] + (next || '');
            }
        });
    };
    decode.options = {
        'isAttributeValue': false,
        'strict': false
    };
    var escape = function (string) {
        return string.replace(regexEscape, function ($0) {
            return escapeMap[$0];
        });
    };
    var he = {
        'version': '1.1.1',
        'encode': encode,
        'decode': decode,
        'escape': escape,
        'unescape': decode
    };
    if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
        define('he@1.1.1#he', function () {
            return he;
        });
    } else if (freeExports && !freeExports.nodeType) {
        if (freeModule) {
            freeModule.exports = he;
        } else {
            for (var key in he) {
                has(he, key) && (freeExports[key] = he[key]);
            }
        }
    } else {
        root.he = he;
    }
}(this));
/*can-simple-dom@1.3.0#simple-dom/html-parser*/
define('can-simple-dom@1.3.0#simple-dom/html-parser', [
    'exports',
    'he'
], function (exports, _he) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    var _he2 = _interopRequireDefault(_he);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    function HTMLParser(tokenize, document, voidMap) {
        this.tokenize = tokenize;
        this.document = document;
        this.voidMap = voidMap;
        this.parentStack = [];
    }
    HTMLParser.prototype.isVoid = function (element) {
        return this.voidMap[element.nodeName] === true;
    };
    HTMLParser.prototype.pushElement = function (token) {
        var el = this.document.createElement(token.tagName);
        for (var i = 0; i < token.attributes.length; i++) {
            var attr = token.attributes[i];
            if (attr[0] !== 'href' && attr[0] !== 'src') {
                attr[1] = _he2.default.encode(attr[1]);
            }
            el.setAttribute(attr[0], attr[1]);
        }
        if (this.isVoid(el) || token.selfClosing) {
            return this.appendChild(el);
        }
        this.parentStack.push(el);
    };
    HTMLParser.prototype.popElement = function (token) {
        var el = this.parentStack.pop();
        if (el.nodeName !== token.tagName.toUpperCase()) {
            throw new Error('unbalanced tag');
        }
        this.appendChild(el);
    };
    HTMLParser.prototype.appendText = function (token) {
        var text = this.document.createTextNode(token.chars);
        this.appendChild(text);
    };
    HTMLParser.prototype.appendComment = function (token) {
        var comment = this.document.createComment(token.chars);
        this.appendChild(comment);
    };
    HTMLParser.prototype.appendChild = function (node) {
        var parentNode = this.parentStack[this.parentStack.length - 1];
        parentNode.appendChild(node);
    };
    HTMLParser.prototype.parse = function (html) {
        var fragment = this.document.createDocumentFragment();
        this.parentStack.push(fragment);
        var tokens = this.tokenize(html);
        for (var i = 0, l = tokens.length; i < l; i++) {
            var token = tokens[i];
            switch (token.type) {
            case 'StartTag':
                this.pushElement(token);
                break;
            case 'EndTag':
                this.popElement(token);
                break;
            case 'Chars':
                this.appendText(token);
                break;
            case 'Comment':
                this.appendComment(token);
                break;
            }
        }
        return this.parentStack.pop();
    };
    exports.default = HTMLParser;
});
/*can-simple-dom@1.3.0#simple-dom/html-serializer*/
define('can-simple-dom@1.3.0#simple-dom/html-serializer', ['exports'], function (exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    var REG_ESCAPE_ALL = /[<>&]/g;
    var REG_ESCAPE_PRESERVE_ENTITIES = /[<>]|&(?:#?[a-zA-Z0-9]+;)?/g;
    function HTMLSerializer(voidMap) {
        this.voidMap = voidMap;
    }
    HTMLSerializer.prototype.openTag = function (element) {
        return '<' + element.nodeName.toLowerCase() + this.attributes(element.attributes) + '>';
    };
    HTMLSerializer.prototype.closeTag = function (element) {
        return '</' + element.nodeName.toLowerCase() + '>';
    };
    HTMLSerializer.prototype.isVoid = function (element) {
        return this.voidMap[element.nodeName] === true;
    };
    HTMLSerializer.prototype.attributes = function (namedNodeMap) {
        var buffer = '';
        for (var i = 0, l = namedNodeMap.length; i < l; i++) {
            buffer += this.attr(namedNodeMap[i]);
        }
        return buffer;
    };
    HTMLSerializer.prototype.escapeAttrValue = function (attrValue) {
        return attrValue.replace(/"|&(?:#?[a-zA-Z0-9]+;)?/g, function (match) {
            switch (match) {
            case '&':
                return '&amp;';
            case '"':
                return '&quot;';
            default:
                return match;
            }
        });
    };
    HTMLSerializer.prototype.attr = function (attr) {
        if (!attr.specified) {
            return '';
        }
        if (attr.value) {
            if (attr.name === 'href' || attr.name === 'src') {
                return ' ' + attr.name + '="' + attr.value + '"';
            }
            return ' ' + attr.name + '="' + this.escapeAttrValue(attr.value) + '"';
        }
        return ' ' + attr.name;
    };
    HTMLSerializer.prototype.escapeText = function (textNodeValue, escapeAll) {
        return textNodeValue.replace(escapeAll ? REG_ESCAPE_ALL : REG_ESCAPE_PRESERVE_ENTITIES, function (match) {
            switch (match) {
            case '&':
                return '&amp;';
            case '<':
                return '&lt;';
            case '>':
                return '&gt;';
            default:
                return match;
            }
        });
    };
    var metadataContentTags = {
        style: true,
        script: true,
        template: true
    };
    function isMetadataTag(elem) {
        return !!elem && metadataContentTags[elem.nodeName.toLowerCase()];
    }
    HTMLSerializer.prototype.text = function (text) {
        if (isMetadataTag(text.parentNode)) {
            return text.nodeValue;
        }
        return this.escapeText(text.nodeValue);
    };
    HTMLSerializer.prototype.comment = function (comment) {
        return '<!--' + comment.nodeValue + '-->';
    };
    HTMLSerializer.prototype.serialize = function (node) {
        var buffer = '';
        var next;
        switch (node.nodeType) {
        case 1:
            buffer += this.openTag(node);
            break;
        case 3:
            buffer += this.text(node);
            break;
        case 8:
            buffer += this.comment(node);
            break;
        default:
            break;
        }
        next = node.firstChild;
        if (next) {
            while (next) {
                buffer += this.serialize(next);
                next = next.nextSibling;
            }
        } else if (node.nodeType === 1 && node.textContent) {
            buffer += this.escapeText(node.textContent, true);
        }
        if (node.nodeType === 1 && !this.isVoid(node)) {
            buffer += this.closeTag(node);
        }
        return buffer;
    };
    exports.default = HTMLSerializer;
});
/*can-simple-dom@1.3.0#simple-dom/void-map*/
define('can-simple-dom@1.3.0#simple-dom/void-map', ['exports'], function (exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.default = {
        AREA: true,
        BASE: true,
        BR: true,
        COL: true,
        COMMAND: true,
        EMBED: true,
        HR: true,
        IMG: true,
        INPUT: true,
        KEYGEN: true,
        LINK: true,
        META: true,
        PARAM: true,
        SOURCE: true,
        TRACK: true,
        WBR: true
    };
});
/*can-simple-dom@1.3.0#simple-dom/dom*/
define('can-simple-dom@1.3.0#simple-dom/dom', [
    'exports',
    './document/node',
    './document/element',
    './document',
    './event',
    './html-parser',
    './html-serializer',
    './void-map'
], function (exports, _node, _element, _document, _event, _htmlParser, _htmlSerializer, _voidMap) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.createDocument = exports.voidMap = exports.HTMLSerializer = exports.HTMLParser = exports.Event = exports.Document = exports.Element = exports.Node = undefined;
    var _node2 = _interopRequireDefault(_node);
    var _element2 = _interopRequireDefault(_element);
    var _document2 = _interopRequireDefault(_document);
    var _event2 = _interopRequireDefault(_event);
    var _htmlParser2 = _interopRequireDefault(_htmlParser);
    var _htmlSerializer2 = _interopRequireDefault(_htmlSerializer);
    var _voidMap2 = _interopRequireDefault(_voidMap);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    function createDocument(serializer, parser) {
        var doc = new _document2.default();
        doc.__serializer = serializer;
        doc.__parser = parser;
        return doc;
    }
    exports.Node = _node2.default;
    exports.Element = _element2.default;
    exports.Document = _document2.default;
    exports.Event = _event2.default;
    exports.HTMLParser = _htmlParser2.default;
    exports.HTMLSerializer = _htmlSerializer2.default;
    exports.voidMap = _voidMap2.default;
    exports.createDocument = createDocument;
});
/*can-simple-dom@1.3.0#simple-dom*/
define('can-simple-dom@1.3.0#simple-dom', [
    'exports',
    './simple-dom/dom'
], function (exports, _dom) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    Object.keys(_dom).forEach(function (key) {
        if (key === 'default' || key === '__esModule')
            return;
        Object.defineProperty(exports, key, {
            enumerable: true,
            get: function () {
                return _dom[key];
            }
        });
    });
    var SimpleDOM = _interopRequireWildcard(_dom);
    function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
            return obj;
        } else {
            var newObj = {};
            if (obj != null) {
                for (var key in obj) {
                    if (Object.prototype.hasOwnProperty.call(obj, key))
                        newObj[key] = obj[key];
                }
            }
            newObj.default = obj;
            return newObj;
        }
    }
    if (typeof window !== 'undefined') {
        window.SimpleDOM = SimpleDOM;
    }
});
/*can-log@0.1.0#can-log*/
define('can-log@0.1.0#can-log', function (require, exports, module) {
    'use strict';
    exports.warnTimeout = 5000;
    exports.logLevel = 0;
    exports.warn = function (out) {
        var ll = this.logLevel;
        if (ll < 2) {
            Array.prototype.unshift.call(arguments, 'WARN:');
            if (typeof console !== 'undefined' && console.warn) {
                this._logger('warn', Array.prototype.slice.call(arguments));
            } else if (typeof console !== 'undefined' && console.log) {
                this._logger('log', Array.prototype.slice.call(arguments));
            } else if (window && window.opera && window.opera.postError) {
                window.opera.postError('CanJS WARNING: ' + out);
            }
        }
    };
    exports.log = function (out) {
        var ll = this.logLevel;
        if (ll < 1) {
            if (typeof console !== 'undefined' && console.log) {
                Array.prototype.unshift.call(arguments, 'INFO:');
                this._logger('log', Array.prototype.slice.call(arguments));
            } else if (window && window.opera && window.opera.postError) {
                window.opera.postError('CanJS INFO: ' + out);
            }
        }
    };
    exports.error = function (out) {
        var ll = this.logLevel;
        if (ll < 1) {
            if (typeof console !== 'undefined' && console.error) {
                Array.prototype.unshift.call(arguments, 'ERROR:');
                this._logger('error', Array.prototype.slice.call(arguments));
            } else if (window && window.opera && window.opera.postError) {
                window.opera.postError('ERROR: ' + out);
            }
        }
    };
    exports._logger = function (type, arr) {
        try {
            console[type].apply(console, arr);
        } catch (e) {
            console[type](arr);
        }
    };
});
/*can-log@0.1.0#dev/dev*/
define('can-log@0.1.0#dev/dev', [
    'require',
    'exports',
    'module',
    '../can-log'
], function (require, exports, module) {
    'use strict';
    var canLog = require('../can-log');
    module.exports = {
        warnTimeout: 5000,
        logLevel: 0,
        stringify: function (value) {
            var flagUndefined = function flagUndefined(key, value) {
                return value === undefined ? '/* void(undefined) */' : value;
            };
            return JSON.stringify(value, flagUndefined, '  ').replace(/"\/\* void\(undefined\) \*\/"/g, 'undefined');
        },
        warn: function () {
        },
        log: function () {
        },
        error: function () {
        },
        _logger: canLog._logger
    };
});
/*can-attribute-encoder@0.3.1#can-attribute-encoder*/
define('can-attribute-encoder@0.3.1#can-attribute-encoder', [
    'require',
    'exports',
    'module',
    'can-namespace',
    'can-log/dev/dev'
], function (require, exports, module) {
    var namespace = require('can-namespace');
    var dev = require('can-log/dev/dev');
    function each(items, callback) {
        for (var i = 0; i < items.length; i++) {
            callback(items[i], i);
        }
    }
    function makeMap(str) {
        var obj = {}, items = str.split(',');
        each(items, function (name) {
            obj[name] = true;
        });
        return obj;
    }
    var caseMattersAttributes = makeMap('allowReorder,attributeName,attributeType,autoReverse,baseFrequency,baseProfile,calcMode,clipPathUnits,contentScriptType,contentStyleType,diffuseConstant,edgeMode,externalResourcesRequired,filterRes,filterUnits,glyphRef,gradientTransform,gradientUnits,kernelMatrix,kernelUnitLength,keyPoints,keySplines,keyTimes,lengthAdjust,limitingConeAngle,markerHeight,markerUnits,markerWidth,maskContentUnits,maskUnits,patternContentUnits,patternTransform,patternUnits,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,repeatCount,repeatDur,requiredExtensions,requiredFeatures,specularConstant,specularExponent,spreadMethod,startOffset,stdDeviation,stitchTiles,surfaceScale,systemLanguage,tableValues,textLength,viewBox,viewTarget,xChannelSelector,yChannelSelector');
    function camelCaseToSpinalCase(match, lowerCaseChar, upperCaseChar) {
        return lowerCaseChar + '-' + upperCaseChar.toLowerCase();
    }
    function startsWith(allOfIt, startsWith) {
        return allOfIt.indexOf(startsWith) === 0;
    }
    function endsWith(allOfIt, endsWith) {
        return allOfIt.length - allOfIt.indexOf(endsWith) === endsWith.length;
    }
    var regexes = {
        leftParens: /\(/g,
        rightParens: /\)/g,
        leftBrace: /\{/g,
        rightBrace: /\}/g,
        camelCase: /([a-z])([A-Z])/g,
        forwardSlash: /\//g,
        space: /\s/g,
        uppercase: /[A-Z]/g,
        uppercaseDelimiterThenChar: /:u:([a-z])/g,
        caret: /\^/g,
        dollar: /\$/g,
        at: /@/g
    };
    var delimiters = {
        prependUppercase: ':u:',
        replaceSpace: ':s:',
        replaceForwardSlash: ':f:',
        replaceLeftParens: ':lp:',
        replaceRightParens: ':rp:',
        replaceLeftBrace: ':lb:',
        replaceRightBrace: ':rb:',
        replaceCaret: ':c:',
        replaceDollar: ':d:',
        replaceAt: ':at:'
    };
    var encoder = {};
    encoder.encode = function (name) {
        var encoded = name;
        if (!caseMattersAttributes[encoded] && encoded.match(regexes.camelCase)) {
            if (startsWith(encoded, 'on:') || endsWith(encoded, ':to') || endsWith(encoded, ':from') || endsWith(encoded, ':bind')) {
                encoded = encoded.replace(regexes.uppercase, function (char) {
                    return delimiters.prependUppercase + char.toLowerCase();
                });
            } else {
                encoded = encoded.replace(regexes.camelCase, camelCaseToSpinalCase);
            }
        }
        encoded = encoded.replace(regexes.space, delimiters.replaceSpace).replace(regexes.forwardSlash, delimiters.replaceForwardSlash).replace(regexes.leftParens, delimiters.replaceLeftParens).replace(regexes.rightParens, delimiters.replaceRightParens).replace(regexes.leftBrace, delimiters.replaceLeftBrace).replace(regexes.rightBrace, delimiters.replaceRightBrace).replace(regexes.caret, delimiters.replaceCaret).replace(regexes.dollar, delimiters.replaceDollar).replace(regexes.at, delimiters.replaceAt);
        return encoded;
    };
    encoder.decode = function (name) {
        var decoded = name;
        decoded = decoded.replace(delimiters.replaceLeftParens, '(').replace(delimiters.replaceRightParens, ')').replace(delimiters.replaceLeftBrace, '{').replace(delimiters.replaceRightBrace, '}').replace(delimiters.replaceForwardSlash, '/').replace(delimiters.replaceSpace, ' ').replace(delimiters.replaceCaret, '^').replace(delimiters.replaceDollar, '$').replace(delimiters.replaceAt, '@');
        if (!caseMattersAttributes[decoded] && decoded.match(regexes.uppercaseDelimiterThenChar)) {
            if (startsWith(decoded, 'on:') || endsWith(decoded, ':to') || endsWith(decoded, ':from') || endsWith(decoded, ':bind')) {
                decoded = decoded.replace(regexes.uppercaseDelimiterThenChar, function (match, char) {
                    return char.toUpperCase();
                });
            }
        }
        return decoded;
    };
    if (namespace.encoder) {
        throw new Error('You can\'t have two versions of can-attribute-encoder, check your dependencies');
    } else {
        module.exports = namespace.encoder = encoder;
    }
});
/*can-view-parser@3.6.2#can-view-parser*/
define('can-view-parser@3.6.2#can-view-parser', [
    'require',
    'exports',
    'module',
    'can-namespace',
    'can-log/dev/dev',
    'can-attribute-encoder'
], function (require, exports, module) {
    var namespace = require('can-namespace'), dev = require('can-log/dev/dev'), encoder = require('can-attribute-encoder');
    function each(items, callback) {
        for (var i = 0; i < items.length; i++) {
            callback(items[i], i);
        }
    }
    function makeMap(str) {
        var obj = {}, items = str.split(',');
        each(items, function (name) {
            obj[name] = true;
        });
        return obj;
    }
    function handleIntermediate(intermediate, handler) {
        for (var i = 0, len = intermediate.length; i < len; i++) {
            var item = intermediate[i];
            handler[item.tokenType].apply(handler, item.args);
        }
        return intermediate;
    }
    var alphaNumeric = 'A-Za-z0-9', alphaNumericHU = '-:_' + alphaNumeric, defaultMagicStart = '{{', endTag = new RegExp('^<\\/([' + alphaNumericHU + ']+)[^>]*>'), defaultMagicMatch = new RegExp('\\{\\{(![\\s\\S]*?!|[\\s\\S]*?)\\}\\}\\}?', 'g'), space = /\s/, alphaRegex = new RegExp('[' + alphaNumeric + ']');
    var empty = makeMap('area,base,basefont,br,col,frame,hr,img,input,isindex,link,meta,param,embed');
    var caseMattersElements = makeMap('altGlyph,altGlyphDef,altGlyphItem,animateColor,animateMotion,animateTransform,clipPath,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,foreignObject,glyphRef,linearGradient,radialGradient,textPath');
    var closeSelf = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr');
    var special = makeMap('script');
    var tokenTypes = 'start,end,close,attrStart,attrEnd,attrValue,chars,comment,special,done'.split(',');
    var startOppositesMap = {
        '{': '}',
        '(': ')'
    };
    var fn = function () {
    };
    var HTMLParser = function (html, handler, returnIntermediate) {
        if (typeof html === 'object') {
            return handleIntermediate(html, handler);
        }
        var intermediate = [];
        handler = handler || {};
        if (returnIntermediate) {
            each(tokenTypes, function (name) {
                var callback = handler[name] || fn;
                handler[name] = function () {
                    if (callback.apply(this, arguments) !== false) {
                        var end = arguments.length;
                        if (arguments[end - 1] === undefined) {
                            end = arguments.length - 1;
                        }
                        intermediate.push({
                            tokenType: name,
                            args: [].slice.call(arguments, 0, end)
                        });
                    }
                };
            });
        }
        var magicMatch = handler.magicMatch || defaultMagicMatch, magicStart = handler.magicStart || defaultMagicStart;
        function parseStartTag(tag, tagName, rest, unary) {
            tagName = caseMattersElements[tagName] ? tagName : tagName.toLowerCase();
            if (closeSelf[tagName] && stack.last() === tagName) {
                parseEndTag('', tagName);
            }
            unary = empty[tagName] || !!unary;
            handler.start(tagName, unary, lineNo);
            if (!unary) {
                stack.push(tagName);
            }
            HTMLParser.parseAttrs(rest, handler, lineNo);
            handler.end(tagName, unary, lineNo);
        }
        function parseEndTag(tag, tagName) {
            var pos;
            if (!tagName) {
                pos = 0;
            } else {
                tagName = caseMattersElements[tagName] ? tagName : tagName.toLowerCase();
                for (pos = stack.length - 1; pos >= 0; pos--) {
                    if (stack[pos] === tagName) {
                        break;
                    }
                }
            }
            if (pos >= 0) {
                for (var i = stack.length - 1; i >= pos; i--) {
                    if (handler.close) {
                        handler.close(stack[i], lineNo);
                    }
                }
                stack.length = pos;
            }
        }
        function parseMustache(mustache, inside) {
            if (handler.special) {
                handler.special(inside, lineNo);
            }
        }
        var callChars = function () {
            if (charsText) {
                if (handler.chars) {
                    handler.chars(charsText, lineNo);
                }
            }
            charsText = '';
        };
        var index, chars, match, lineNo, stack = [], last = html, charsText = '';
        stack.last = function () {
            return this[this.length - 1];
        };
        while (html) {
            chars = true;
            if (!stack.last() || !special[stack.last()]) {
                if (html.indexOf('<!--') === 0) {
                    index = html.indexOf('-->');
                    if (index >= 0) {
                        callChars();
                        if (handler.comment) {
                            handler.comment(html.substring(4, index), lineNo);
                        }
                        html = html.substring(index + 3);
                        chars = false;
                    }
                } else if (html.indexOf('</') === 0) {
                    match = html.match(endTag);
                    if (match) {
                        callChars();
                        match[0].replace(endTag, parseEndTag);
                        html = html.substring(match[0].length);
                        chars = false;
                    }
                } else if (html.indexOf('<') === 0) {
                    var res = HTMLParser.searchStartTag(html);
                    if (res) {
                        callChars();
                        parseStartTag.apply(null, res.match);
                        html = res.html;
                        chars = false;
                    }
                } else if (html.indexOf(magicStart) === 0) {
                    match = html.match(magicMatch);
                    if (match) {
                        callChars();
                        match[0].replace(magicMatch, parseMustache);
                        html = html.substring(match[0].length);
                    }
                }
                if (chars) {
                    index = findBreak(html, magicStart);
                    if (index === 0 && html === last) {
                        charsText += html.charAt(0);
                        html = html.substr(1);
                        index = findBreak(html, magicStart);
                    }
                    var text = index < 0 ? html : html.substring(0, index);
                    html = index < 0 ? '' : html.substring(index);
                    if (text) {
                        charsText += text;
                    }
                }
            } else {
                html = html.replace(new RegExp('([\\s\\S]*?)</' + stack.last() + '[^>]*>'), function (all, text) {
                    text = text.replace(/<!--([\s\S]*?)-->|<!\[CDATA\[([\s\S]*?)]]>/g, '$1$2');
                    if (handler.chars) {
                        handler.chars(text, lineNo);
                    }
                    return '';
                });
                parseEndTag('', stack.last());
            }
            if (html === last) {
                throw new Error('Parse Error: ' + html);
            }
            last = html;
        }
        callChars();
        parseEndTag();
        handler.done(lineNo);
        return intermediate;
    };
    var callAttrStart = function (state, curIndex, handler, rest, lineNo) {
        var attrName = rest.substring(typeof state.nameStart === 'number' ? state.nameStart : curIndex, curIndex), newAttrName = encoder.encode(attrName);
        state.attrStart = newAttrName;
        handler.attrStart(state.attrStart, lineNo);
        state.inName = false;
    };
    var callAttrEnd = function (state, curIndex, handler, rest, lineNo) {
        if (state.valueStart !== undefined && state.valueStart < curIndex) {
            var val = rest.substring(state.valueStart, curIndex);
            handler.attrValue(val, lineNo);
        }
        handler.attrEnd(state.attrStart, lineNo);
        state.attrStart = undefined;
        state.valueStart = undefined;
        state.inValue = false;
        state.inName = false;
        state.lookingForEq = false;
        state.inQuote = false;
        state.lookingForName = true;
    };
    var findBreak = function (str, magicStart) {
        var magicLength = magicStart.length;
        for (var i = 0, len = str.length; i < len; i++) {
            if (str[i] === '<' || str.substr(i, magicLength) === magicStart) {
                return i;
            }
        }
        return -1;
    };
    HTMLParser.parseAttrs = function (rest, handler, lineNo) {
        if (!rest) {
            return;
        }
        var magicMatch = handler.magicMatch || defaultMagicMatch, magicStart = handler.magicStart || defaultMagicStart;
        var i = 0;
        var curIndex;
        var state = {
            inName: false,
            nameStart: undefined,
            inValue: false,
            valueStart: undefined,
            inQuote: false,
            attrStart: undefined,
            lookingForName: true,
            lookingForValue: false,
            lookingForEq: false
        };
        while (i < rest.length) {
            curIndex = i;
            var cur = rest.charAt(i);
            i++;
            if (magicStart === rest.substr(curIndex, magicStart.length)) {
                if (state.inValue && curIndex > state.valueStart) {
                    handler.attrValue(rest.substring(state.valueStart, curIndex), lineNo);
                } else if (state.inName && state.nameStart < curIndex) {
                    callAttrStart(state, curIndex, handler, rest, lineNo);
                    callAttrEnd(state, curIndex, handler, rest, lineNo);
                } else if (state.lookingForValue) {
                    state.inValue = true;
                } else if (state.lookingForEq && state.attrStart) {
                    callAttrEnd(state, curIndex, handler, rest, lineNo);
                }
                magicMatch.lastIndex = curIndex;
                var match = magicMatch.exec(rest);
                if (match) {
                    handler.special(match[1], lineNo);
                    i = curIndex + match[0].length;
                    if (state.inValue) {
                        state.valueStart = curIndex + match[0].length;
                    }
                }
            } else if (state.inValue) {
                if (state.inQuote) {
                    if (cur === state.inQuote) {
                        callAttrEnd(state, curIndex, handler, rest, lineNo);
                    }
                } else if (space.test(cur)) {
                    callAttrEnd(state, curIndex, handler, rest, lineNo);
                }
            } else if (cur === '=' && (state.lookingForEq || state.lookingForName || state.inName)) {
                if (!state.attrStart) {
                    callAttrStart(state, curIndex, handler, rest, lineNo);
                }
                state.lookingForValue = true;
                state.lookingForEq = false;
                state.lookingForName = false;
            } else if (state.inName) {
                var started = rest[state.nameStart], otherStart, otherOpposite;
                if (startOppositesMap[started] === cur) {
                    otherStart = started === '{' ? '(' : '{';
                    otherOpposite = startOppositesMap[otherStart];
                    if (rest[curIndex + 1] === otherOpposite) {
                        callAttrStart(state, curIndex + 2, handler, rest, lineNo);
                        i++;
                    } else {
                        callAttrStart(state, curIndex + 1, handler, rest, lineNo);
                    }
                    state.lookingForEq = true;
                } else if (space.test(cur) && started !== '{' && started !== '(') {
                    callAttrStart(state, curIndex, handler, rest, lineNo);
                    state.lookingForEq = true;
                }
            } else if (state.lookingForName) {
                if (!space.test(cur)) {
                    if (state.attrStart) {
                        callAttrEnd(state, curIndex, handler, rest, lineNo);
                    }
                    state.nameStart = curIndex;
                    state.inName = true;
                }
            } else if (state.lookingForValue) {
                if (!space.test(cur)) {
                    state.lookingForValue = false;
                    state.inValue = true;
                    if (cur === '\'' || cur === '"') {
                        state.inQuote = cur;
                        state.valueStart = curIndex + 1;
                    } else {
                        state.valueStart = curIndex;
                    }
                } else if (i === rest.length) {
                    callAttrEnd(state, curIndex, handler, rest, lineNo);
                }
            }
        }
        if (state.inName) {
            callAttrStart(state, curIndex + 1, handler, rest, lineNo);
            callAttrEnd(state, curIndex + 1, handler, rest, lineNo);
        } else if (state.lookingForEq || state.lookingForValue || state.inValue) {
            callAttrEnd(state, curIndex + 1, handler, rest, lineNo);
        }
        magicMatch.lastIndex = 0;
    };
    HTMLParser.searchStartTag = function (html) {
        var closingIndex = html.indexOf('>');
        if (closingIndex === -1 || !alphaRegex.test(html[1])) {
            return null;
        }
        var tagName, tagContent, match, rest = '', unary = '';
        var startTag = html.substring(0, closingIndex + 1);
        var isUnary = startTag[startTag.length - 2] === '/';
        var spaceIndex = startTag.search(space);
        if (isUnary) {
            unary = '/';
            tagContent = startTag.substring(1, startTag.length - 2).trim();
        } else {
            tagContent = startTag.substring(1, startTag.length - 1).trim();
        }
        if (spaceIndex === -1) {
            tagName = tagContent;
        } else {
            spaceIndex--;
            tagName = tagContent.substring(0, spaceIndex);
            rest = tagContent.substring(spaceIndex);
        }
        match = [
            startTag,
            tagName,
            rest,
            unary
        ];
        return {
            match: match,
            html: html.substring(startTag.length)
        };
    };
    module.exports = namespace.HTMLParser = HTMLParser;
});
/*can-vdom@3.2.3#make-parser/make-parser*/
define('can-vdom@3.2.3#make-parser/make-parser', [
    'require',
    'exports',
    'module',
    'can-view-parser',
    'can-simple-dom'
], function (require, exports, module) {
    var canParser = require('can-view-parser');
    var simpleDOM = require('can-simple-dom');
    module.exports = function (document) {
        return new simpleDOM.HTMLParser(function (string) {
            var tokens = [];
            var currentTag, currentAttr;
            canParser(string, {
                start: function (tagName, unary) {
                    currentTag = {
                        type: 'StartTag',
                        attributes: [],
                        tagName: tagName
                    };
                },
                end: function (tagName, unary) {
                    tokens.push(currentTag);
                    currentTag = undefined;
                },
                close: function (tagName) {
                    tokens.push({
                        type: 'EndTag',
                        tagName: tagName
                    });
                },
                attrStart: function (attrName) {
                    currentAttr = [
                        attrName,
                        ''
                    ];
                    currentTag.attributes.push(currentAttr);
                },
                attrEnd: function (attrName) {
                },
                attrValue: function (value) {
                    currentAttr[1] += value;
                },
                chars: function (value) {
                    tokens.push({
                        type: 'Chars',
                        chars: value
                    });
                },
                comment: function (value) {
                    tokens.push({
                        type: 'Comment',
                        chars: value
                    });
                },
                special: function (value) {
                },
                done: function () {
                }
            });
            return tokens;
        }, document, simpleDOM.voidMap);
    };
});
/*can-vdom@3.2.3#make-document/make-document*/
define('can-vdom@3.2.3#make-document/make-document', [
    'require',
    'exports',
    'module',
    'can-simple-dom',
    '../make-parser/make-parser'
], function (require, exports, module) {
    var simpleDOM = require('can-simple-dom');
    var makeParser = require('../make-parser/make-parser');
    function CanSimpleDocument() {
        simpleDOM.Document.apply(this, arguments);
        var serializer = new simpleDOM.HTMLSerializer(simpleDOM.voidMap);
        var parser = makeParser(this);
        this.__addSerializerAndParser(serializer, parser);
    }
    CanSimpleDocument.prototype = new simpleDOM.Document();
    CanSimpleDocument.prototype.constructor = CanSimpleDocument;
    module.exports = function () {
        return new CanSimpleDocument();
    };
});
/*can-util@3.10.12#js/is-array-like/is-array-like*/
define('can-util@3.10.12#js/is-array-like/is-array-like', function (require, exports, module) {
    'use strict';
    function isArrayLike(obj) {
        var type = typeof obj;
        if (type === 'string') {
            return true;
        } else if (type === 'number') {
            return false;
        }
        var length = obj && type !== 'boolean' && typeof obj !== 'number' && 'length' in obj && obj.length;
        return typeof obj !== 'function' && (length === 0 || typeof length === 'number' && length > 0 && length - 1 in obj);
    }
    module.exports = isArrayLike;
});
/*can-util@3.10.12#js/is-iterable/is-iterable*/
define('can-util@3.10.12#js/is-iterable/is-iterable', [
    'require',
    'exports',
    'module',
    'can-symbol'
], function (require, exports, module) {
    'use strict';
    var canSymbol = require('can-symbol');
    module.exports = function (obj) {
        return obj && !!obj[canSymbol.iterator || canSymbol.for('iterator')];
    };
});
/*can-util@3.10.12#js/each/each*/
define('can-util@3.10.12#js/each/each', [
    'require',
    'exports',
    'module',
    '../is-array-like/is-array-like',
    '../is-iterable/is-iterable',
    'can-symbol'
], function (require, exports, module) {
    'use strict';
    var isArrayLike = require('../is-array-like/is-array-like');
    var has = Object.prototype.hasOwnProperty;
    var isIterable = require('../is-iterable/is-iterable');
    var canSymbol = require('can-symbol');
    function each(elements, callback, context) {
        var i = 0, key, len, item;
        if (elements) {
            if (isArrayLike(elements)) {
                for (len = elements.length; i < len; i++) {
                    item = elements[i];
                    if (callback.call(context || item, item, i, elements) === false) {
                        break;
                    }
                }
            } else if (isIterable(elements)) {
                var iter = elements[canSymbol.iterator || canSymbol.for('iterator')]();
                var res, value;
                while (!(res = iter.next()).done) {
                    value = res.value;
                    callback.call(context || elements, Array.isArray(value) ? value[1] : value, value[0]);
                }
            } else if (typeof elements === 'object') {
                for (key in elements) {
                    if (has.call(elements, key) && callback.call(context || elements[key], elements[key], key, elements) === false) {
                        break;
                    }
                }
            }
        }
        return elements;
    }
    module.exports = each;
});
/*can-util@3.10.12#js/make-array/make-array*/
define('can-util@3.10.12#js/make-array/make-array', [
    'require',
    'exports',
    'module',
    '../each/each',
    '../is-array-like/is-array-like'
], function (require, exports, module) {
    'use strict';
    var each = require('../each/each');
    var isArrayLike = require('../is-array-like/is-array-like');
    function makeArray(element) {
        var ret = [];
        if (isArrayLike(element)) {
            each(element, function (a, i) {
                ret[i] = a;
            });
        } else if (element === 0 || element) {
            ret.push(element);
        }
        return ret;
    }
    module.exports = makeArray;
});
/*can-util@3.10.12#js/set-immediate/set-immediate*/
define('can-util@3.10.12#js/set-immediate/set-immediate', [
    'require',
    'exports',
    'module',
    'can-globals/global/global'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var global = require('can-globals/global/global')();
        module.exports = global.setImmediate || function (cb) {
            return setTimeout(cb, 0);
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-cid@1.1.1#can-cid*/
define('can-cid@1.1.1#can-cid', [
    'require',
    'exports',
    'module',
    'can-namespace'
], function (require, exports, module) {
    var namespace = require('can-namespace');
    var _cid = 0;
    var domExpando = 'can' + new Date();
    var cid = function (object, name) {
        var propertyName = object.nodeName ? domExpando : '_cid';
        if (!object[propertyName]) {
            _cid++;
            object[propertyName] = (name || '') + _cid;
        }
        return object[propertyName];
    };
    cid.domExpando = domExpando;
    cid.get = function (object) {
        var type = typeof object;
        var isObject = type !== null && (type === 'object' || type === 'function');
        return isObject ? cid(object) : type + ':' + object;
    };
    if (namespace.cid) {
        throw new Error('You can\'t have two versions of can-cid, check your dependencies');
    } else {
        module.exports = namespace.cid = cid;
    }
});
/*can-util@3.10.12#dom/child-nodes/child-nodes*/
define('can-util@3.10.12#dom/child-nodes/child-nodes', function (require, exports, module) {
    'use strict';
    function childNodes(node) {
        var childNodes = node.childNodes;
        if ('length' in childNodes) {
            return childNodes;
        } else {
            var cur = node.firstChild;
            var nodes = [];
            while (cur) {
                nodes.push(cur);
                cur = cur.nextSibling;
            }
            return nodes;
        }
    }
    module.exports = childNodes;
});
/*can-util@3.10.12#dom/contains/contains*/
define('can-util@3.10.12#dom/contains/contains', function (require, exports, module) {
    'use strict';
    module.exports = function (child) {
        return this.contains(child);
    };
});
/*can-util@3.10.12#js/is-plain-object/is-plain-object*/
define('can-util@3.10.12#js/is-plain-object/is-plain-object', function (require, exports, module) {
    'use strict';
    var core_hasOwn = Object.prototype.hasOwnProperty;
    function isWindow(obj) {
        return obj !== null && obj == obj.window;
    }
    function isPlainObject(obj) {
        if (!obj || typeof obj !== 'object' || obj.nodeType || isWindow(obj) || obj.constructor && obj.constructor.shortName) {
            return false;
        }
        try {
            if (obj.constructor && !core_hasOwn.call(obj, 'constructor') && !core_hasOwn.call(obj.constructor.prototype, 'isPrototypeOf')) {
                return false;
            }
        } catch (e) {
            return false;
        }
        var key;
        for (key in obj) {
        }
        return key === undefined || core_hasOwn.call(obj, key);
    }
    module.exports = isPlainObject;
});
/*can-util@3.10.12#dom/events/events*/
define('can-util@3.10.12#dom/events/events', [
    'require',
    'exports',
    'module',
    'can-globals/document/document',
    'can-globals/is-browser-window/is-browser-window',
    '../../js/is-plain-object/is-plain-object',
    'can-log/dev/dev'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var getDocument = require('can-globals/document/document');
        var isBrowserWindow = require('can-globals/is-browser-window/is-browser-window');
        var isPlainObject = require('../../js/is-plain-object/is-plain-object');
        var fixSyntheticEventsOnDisabled = false;
        var dev = require('can-log/dev/dev');
        function isDispatchingOnDisabled(element, ev) {
            var isInsertedOrRemoved = isPlainObject(ev) ? ev.type === 'inserted' || ev.type === 'removed' : ev === 'inserted' || ev === 'removed';
            var isDisabled = !!element.disabled;
            return isInsertedOrRemoved && isDisabled;
        }
        module.exports = {
            addEventListener: function () {
                this.addEventListener.apply(this, arguments);
            },
            removeEventListener: function () {
                this.removeEventListener.apply(this, arguments);
            },
            canAddEventListener: function () {
                return this.nodeName && (this.nodeType === 1 || this.nodeType === 9) || this === window;
            },
            dispatch: function (event, args, bubbles) {
                var ret;
                var dispatchingOnDisabled = fixSyntheticEventsOnDisabled && isDispatchingOnDisabled(this, event);
                var doc = this.ownerDocument || getDocument();
                var ev = doc.createEvent('HTMLEvents');
                var isString = typeof event === 'string';
                ev.initEvent(isString ? event : event.type, bubbles === undefined ? true : bubbles, false);
                if (!isString) {
                    for (var prop in event) {
                        if (ev[prop] === undefined) {
                            ev[prop] = event[prop];
                        }
                    }
                }
                if (this.disabled === true && ev.type !== 'fix_synthetic_events_on_disabled_test') {
                }
                ev.args = args;
                if (dispatchingOnDisabled) {
                    this.disabled = false;
                }
                ret = this.dispatchEvent(ev);
                if (dispatchingOnDisabled) {
                    this.disabled = true;
                }
                return ret;
            }
        };
        (function () {
            if (!isBrowserWindow()) {
                return;
            }
            var testEventName = 'fix_synthetic_events_on_disabled_test';
            var input = document.createElement('input');
            input.disabled = true;
            var timer = setTimeout(function () {
                fixSyntheticEventsOnDisabled = true;
            }, 50);
            var onTest = function onTest() {
                clearTimeout(timer);
                module.exports.removeEventListener.call(input, testEventName, onTest);
            };
            module.exports.addEventListener.call(input, testEventName, onTest);
            try {
                module.exports.dispatch.call(input, testEventName, [], false);
            } catch (e) {
                onTest();
                fixSyntheticEventsOnDisabled = true;
            }
        }());
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-util@3.10.12#dom/dispatch/dispatch*/
define('can-util@3.10.12#dom/dispatch/dispatch', [
    'require',
    'exports',
    'module',
    '../events/events'
], function (require, exports, module) {
    'use strict';
    var domEvents = require('../events/events');
    module.exports = function () {
        return domEvents.dispatch.apply(this, arguments);
    };
});
/*can-dom-data-state@0.1.1#can-dom-data-state*/
define('can-dom-data-state@0.1.1#can-dom-data-state', [
    'require',
    'exports',
    'module',
    'can-namespace',
    'can-cid'
], function (require, exports, module) {
    'use strict';
    var namespace = require('can-namespace');
    var CID = require('can-cid');
    var data = {};
    var isEmptyObject = function (obj) {
        for (var prop in obj) {
            return false;
        }
        return true;
    };
    var setData = function (name, value) {
        var id = CID(this), store = data[id], newStore = false;
        if (!data[id]) {
            newStore = true;
            store = data[id] = {};
        }
        if (name !== undefined) {
            store[name] = value;
        }
        return newStore;
    };
    var deleteNode = function () {
        var id = CID.get(this);
        var nodeDeleted = false;
        if (id && data[id]) {
            nodeDeleted = true;
            delete data[id];
        }
        return nodeDeleted;
    };
    var domDataState = {
        _data: data,
        getCid: function () {
            return CID.get(this);
        },
        cid: function () {
            return CID(this);
        },
        expando: CID.domExpando,
        get: function (key) {
            var id = CID.get(this), store = id && data[id];
            return key === undefined ? store || setData(this) : store && store[key];
        },
        set: setData,
        clean: function (prop) {
            var id = CID.get(this);
            var itemData = data[id];
            if (itemData && itemData[prop]) {
                delete itemData[prop];
            }
            if (isEmptyObject(itemData)) {
                deleteNode.call(this);
            }
        },
        delete: deleteNode
    };
    if (namespace.domDataState) {
        throw new Error('You can\'t have two versions of can-dom-data-state, check your dependencies');
    } else {
        module.exports = namespace.domDataState = domDataState;
    }
});
/*can-cid@1.1.1#helpers*/
define('can-cid@1.1.1#helpers', function (require, exports, module) {
    module.exports = {
        each: function (obj, cb, context) {
            for (var prop in obj) {
                cb.call(context, obj[prop], prop);
            }
            return obj;
        }
    };
});
/*can-cid@1.1.1#set/set*/
define('can-cid@1.1.1#set/set', [
    'require',
    'exports',
    'module',
    '../can-cid',
    '../helpers'
], function (require, exports, module) {
    'use strict';
    var getCID = require('../can-cid').get;
    var helpers = require('../helpers');
    var CIDSet;
    if (typeof Set !== 'undefined') {
        CIDSet = Set;
    } else {
        var CIDSet = function () {
            this.values = {};
        };
        CIDSet.prototype.add = function (value) {
            this.values[getCID(value)] = value;
        };
        CIDSet.prototype['delete'] = function (key) {
            var has = getCID(key) in this.values;
            if (has) {
                delete this.values[getCID(key)];
            }
            return has;
        };
        CIDSet.prototype.forEach = function (cb, thisArg) {
            helpers.each(this.values, cb, thisArg);
        };
        CIDSet.prototype.has = function (value) {
            return getCID(value) in this.values;
        };
        CIDSet.prototype.clear = function () {
            return this.values = {};
        };
        Object.defineProperty(CIDSet.prototype, 'size', {
            get: function () {
                var size = 0;
                helpers.each(this.values, function () {
                    size++;
                });
                return size;
            }
        });
    }
    module.exports = CIDSet;
});
/*can-util@3.10.12#js/is-container/is-container*/
define('can-util@3.10.12#js/is-container/is-container', function (require, exports, module) {
    'use strict';
    module.exports = function (current) {
        return /^f|^o/.test(typeof current);
    };
});
/*can-util@3.10.12#js/get/get*/
define('can-util@3.10.12#js/get/get', [
    'require',
    'exports',
    'module',
    '../is-container/is-container'
], function (require, exports, module) {
    'use strict';
    var isContainer = require('../is-container/is-container');
    function get(obj, name) {
        var parts = typeof name !== 'undefined' ? (name + '').replace(/\[/g, '.').replace(/]/g, '').split('.') : [], length = parts.length, current, i, container;
        if (!length) {
            return obj;
        }
        current = obj;
        for (i = 0; i < length && isContainer(current); i++) {
            container = current;
            current = container[parts[i]];
        }
        return current;
    }
    module.exports = get;
});
/*can-util@3.10.12#js/is-array/is-array*/
define('can-util@3.10.12#js/is-array/is-array', [
    'require',
    'exports',
    'module',
    'can-log/dev/dev'
], function (require, exports, module) {
    'use strict';
    var dev = require('can-log/dev/dev');
    var hasWarned = false;
    module.exports = function (arr) {
        return Array.isArray(arr);
    };
});
/*can-util@3.10.12#js/string/string*/
define('can-util@3.10.12#js/string/string', [
    'require',
    'exports',
    'module',
    '../get/get',
    '../is-container/is-container',
    'can-log/dev/dev',
    '../is-array/is-array'
], function (require, exports, module) {
    'use strict';
    var get = require('../get/get');
    var isContainer = require('../is-container/is-container');
    var canDev = require('can-log/dev/dev');
    var isArray = require('../is-array/is-array');
    var strUndHash = /_|-/, strColons = /\=\=/, strWords = /([A-Z]+)([A-Z][a-z])/g, strLowUp = /([a-z\d])([A-Z])/g, strDash = /([a-z\d])([A-Z])/g, strReplacer = /\{([^\}]+)\}/g, strQuote = /"/g, strSingleQuote = /'/g, strHyphenMatch = /-+(.)?/g, strCamelMatch = /[a-z][A-Z]/g, convertBadValues = function (content) {
            var isInvalid = content === null || content === undefined || isNaN(content) && '' + content === 'NaN';
            return '' + (isInvalid ? '' : content);
        }, deleteAtPath = function (data, path) {
            var parts = path ? path.replace(/\[/g, '.').replace(/]/g, '').split('.') : [];
            var current = data;
            for (var i = 0; i < parts.length - 1; i++) {
                if (current) {
                    current = current[parts[i]];
                }
            }
            if (current) {
                delete current[parts[parts.length - 1]];
            }
        };
    var string = {
        esc: function (content) {
            return convertBadValues(content).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(strQuote, '&#34;').replace(strSingleQuote, '&#39;');
        },
        getObject: function (name, roots) {
            roots = isArray(roots) ? roots : [roots || window];
            var result, l = roots.length;
            for (var i = 0; i < l; i++) {
                result = get(roots[i], name);
                if (result) {
                    return result;
                }
            }
        },
        capitalize: function (s, cache) {
            return s.charAt(0).toUpperCase() + s.slice(1);
        },
        camelize: function (str) {
            return convertBadValues(str).replace(strHyphenMatch, function (match, chr) {
                return chr ? chr.toUpperCase() : '';
            });
        },
        hyphenate: function (str) {
            return convertBadValues(str).replace(strCamelMatch, function (str, offset) {
                return str.charAt(0) + '-' + str.charAt(1).toLowerCase();
            });
        },
        underscore: function (s) {
            return s.replace(strColons, '/').replace(strWords, '$1_$2').replace(strLowUp, '$1_$2').replace(strDash, '_').toLowerCase();
        },
        sub: function (str, data, remove) {
            var obs = [];
            str = str || '';
            obs.push(str.replace(strReplacer, function (whole, inside) {
                var ob = get(data, inside);
                if (remove === true) {
                    deleteAtPath(data, inside);
                }
                if (ob === undefined || ob === null) {
                    obs = null;
                    return '';
                }
                if (isContainer(ob) && obs) {
                    obs.push(ob);
                    return '';
                }
                return '' + ob;
            }));
            return obs === null ? obs : obs.length <= 1 ? obs[0] : obs;
        },
        replacer: strReplacer,
        undHash: strUndHash
    };
    module.exports = string;
});
/*can-util@3.10.12#dom/mutation-observer/document/document*/
define('can-util@3.10.12#dom/mutation-observer/document/document', [
    'require',
    'exports',
    'module',
    'can-globals/document/document',
    'can-dom-data-state',
    'can-globals/mutation-observer/mutation-observer',
    '../../../js/each/each',
    'can-cid/set/set',
    '../../../js/make-array/make-array',
    '../../../js/string/string'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var getDocument = require('can-globals/document/document');
        var domDataState = require('can-dom-data-state');
        var getMutationObserver = require('can-globals/mutation-observer/mutation-observer');
        var each = require('../../../js/each/each');
        var CIDStore = require('can-cid/set/set');
        var makeArray = require('../../../js/make-array/make-array');
        var string = require('../../../js/string/string');
        var dispatchIfListening = function (mutatedNode, nodes, dispatched) {
            if (dispatched.has(mutatedNode)) {
                return true;
            }
            dispatched.add(mutatedNode);
            if (nodes.name === 'removedNodes') {
                var documentElement = getDocument().documentElement;
                if (documentElement.contains(mutatedNode)) {
                    return;
                }
            }
            nodes.handlers.forEach(function (handler) {
                handler(mutatedNode);
            });
            nodes.afterHandlers.forEach(function (handler) {
                handler(mutatedNode);
            });
        };
        var mutationObserverDocument = {
            add: function (handler) {
                var MO = getMutationObserver();
                if (MO) {
                    var documentElement = getDocument().documentElement;
                    var globalObserverData = domDataState.get.call(documentElement, 'globalObserverData');
                    if (!globalObserverData) {
                        var observer = new MO(function (mutations) {
                            globalObserverData.handlers.forEach(function (handler) {
                                handler(mutations);
                            });
                        });
                        observer.observe(documentElement, {
                            childList: true,
                            subtree: true
                        });
                        globalObserverData = {
                            observer: observer,
                            handlers: []
                        };
                        domDataState.set.call(documentElement, 'globalObserverData', globalObserverData);
                    }
                    globalObserverData.handlers.push(handler);
                }
            },
            remove: function (handler) {
                var documentElement = getDocument().documentElement;
                var globalObserverData = domDataState.get.call(documentElement, 'globalObserverData');
                if (globalObserverData) {
                    var index = globalObserverData.handlers.indexOf(handler);
                    if (index >= 0) {
                        globalObserverData.handlers.splice(index, 1);
                    }
                    if (globalObserverData.handlers.length === 0) {
                        globalObserverData.observer.disconnect();
                        domDataState.clean.call(documentElement, 'globalObserverData');
                    }
                }
            }
        };
        var makeMutationMethods = function (name) {
            var mutationName = name.toLowerCase() + 'Nodes';
            var getMutationData = function () {
                var documentElement = getDocument().documentElement;
                var mutationData = domDataState.get.call(documentElement, mutationName + 'MutationData');
                if (!mutationData) {
                    mutationData = {
                        name: mutationName,
                        handlers: [],
                        afterHandlers: [],
                        hander: null
                    };
                    if (getMutationObserver()) {
                        domDataState.set.call(documentElement, mutationName + 'MutationData', mutationData);
                    }
                }
                return mutationData;
            };
            var setup = function () {
                var mutationData = getMutationData();
                if (mutationData.handlers.length === 0 || mutationData.afterHandlers.length === 0) {
                    mutationData.handler = function (mutations) {
                        var dispatched = new CIDStore();
                        mutations.forEach(function (mutation) {
                            each(mutation[mutationName], function (mutatedNode) {
                                var children = mutatedNode.getElementsByTagName && makeArray(mutatedNode.getElementsByTagName('*'));
                                var alreadyChecked = dispatchIfListening(mutatedNode, mutationData, dispatched);
                                if (children && !alreadyChecked) {
                                    for (var j = 0, child; (child = children[j]) !== undefined; j++) {
                                        dispatchIfListening(child, mutationData, dispatched);
                                    }
                                }
                            });
                        });
                    };
                    this.add(mutationData.handler);
                }
                return mutationData;
            };
            var teardown = function () {
                var documentElement = getDocument().documentElement;
                var mutationData = getMutationData();
                if (mutationData.handlers.length === 0 && mutationData.afterHandlers.length === 0) {
                    this.remove(mutationData.handler);
                    domDataState.clean.call(documentElement, mutationName + 'MutationData');
                }
            };
            var createOnOffHandlers = function (name, handlerList) {
                mutationObserverDocument['on' + name] = function (handler) {
                    var mutationData = setup.call(this);
                    mutationData[handlerList].push(handler);
                };
                mutationObserverDocument['off' + name] = function (handler) {
                    var mutationData = getMutationData();
                    var index = mutationData[handlerList].indexOf(handler);
                    if (index >= 0) {
                        mutationData[handlerList].splice(index, 1);
                    }
                    teardown.call(this);
                };
            };
            var createHandlers = function (name) {
                createOnOffHandlers(name, 'handlers');
                createOnOffHandlers('After' + name, 'afterHandlers');
            };
            createHandlers(string.capitalize(mutationName));
        };
        makeMutationMethods('added');
        makeMutationMethods('removed');
        module.exports = mutationObserverDocument;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-util@3.10.12#dom/data/data*/
define('can-util@3.10.12#dom/data/data', [
    'require',
    'exports',
    'module',
    'can-dom-data-state',
    '../mutation-observer/document/document'
], function (require, exports, module) {
    'use strict';
    var domDataState = require('can-dom-data-state');
    var mutationDocument = require('../mutation-observer/document/document');
    var deleteNode = function () {
        return domDataState.delete.call(this);
    };
    var elementSetCount = 0;
    var cleanupDomData = function (node) {
        elementSetCount -= deleteNode.call(node) ? 1 : 0;
        if (elementSetCount === 0) {
            mutationDocument.offAfterRemovedNodes(cleanupDomData);
        }
    };
    module.exports = {
        getCid: domDataState.getCid,
        cid: domDataState.cid,
        expando: domDataState.expando,
        clean: domDataState.clean,
        get: domDataState.get,
        set: function (name, value) {
            if (elementSetCount === 0) {
                mutationDocument.onAfterRemovedNodes(cleanupDomData);
            }
            elementSetCount += domDataState.set.call(this, name, value) ? 1 : 0;
        },
        delete: deleteNode
    };
});
/*can-util@3.10.12#dom/mutate/mutate*/
define('can-util@3.10.12#dom/mutate/mutate', [
    'require',
    'exports',
    'module',
    '../../js/make-array/make-array',
    '../../js/set-immediate/set-immediate',
    'can-cid',
    'can-globals/mutation-observer/mutation-observer',
    '../child-nodes/child-nodes',
    '../contains/contains',
    '../dispatch/dispatch',
    'can-globals/document/document',
    '../data/data'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var makeArray = require('../../js/make-array/make-array');
        var setImmediate = require('../../js/set-immediate/set-immediate');
        var CID = require('can-cid');
        var getMutationObserver = require('can-globals/mutation-observer/mutation-observer');
        var childNodes = require('../child-nodes/child-nodes');
        var domContains = require('../contains/contains');
        var domDispatch = require('../dispatch/dispatch');
        var getDocument = require('can-globals/document/document');
        var domData = require('../data/data');
        var mutatedElements;
        var checks = {
            inserted: function (root, elem) {
                return domContains.call(root, elem);
            },
            removed: function (root, elem) {
                return !domContains.call(root, elem);
            }
        };
        var fireOn = function (elems, root, check, event, dispatched) {
            if (!elems.length) {
                return;
            }
            var children, cid;
            for (var i = 0, elem; (elem = elems[i]) !== undefined; i++) {
                cid = CID(elem);
                if (elem.getElementsByTagName && check(root, elem) && !dispatched[cid]) {
                    dispatched[cid] = true;
                    children = makeArray(elem.getElementsByTagName('*'));
                    domDispatch.call(elem, event, [], false);
                    if (event === 'removed') {
                        domData.delete.call(elem);
                    }
                    for (var j = 0, child; (child = children[j]) !== undefined; j++) {
                        cid = CID(child);
                        if (!dispatched[cid]) {
                            domDispatch.call(child, event, [], false);
                            if (event === 'removed') {
                                domData.delete.call(child);
                            }
                            dispatched[cid] = true;
                        }
                    }
                }
            }
        };
        var fireMutations = function () {
            var mutations = mutatedElements;
            mutatedElements = null;
            var firstElement = mutations[0][1][0];
            var doc = getDocument() || firstElement.ownerDocument || firstElement;
            var root = doc.contains ? doc : doc.documentElement;
            var dispatched = {
                inserted: {},
                removed: {}
            };
            mutations.forEach(function (mutation) {
                fireOn(mutation[1], root, checks[mutation[0]], mutation[0], dispatched[mutation[0]]);
            });
        };
        var mutated = function (elements, type) {
            if (!getMutationObserver() && elements.length) {
                var firstElement = elements[0];
                var doc = getDocument() || firstElement.ownerDocument || firstElement;
                var root = doc.contains ? doc : doc.documentElement;
                if (checks.inserted(root, firstElement)) {
                    if (!mutatedElements) {
                        mutatedElements = [];
                        setImmediate(fireMutations);
                    }
                    mutatedElements.push([
                        type,
                        elements
                    ]);
                }
            }
        };
        module.exports = {
            appendChild: function (child) {
                if (getMutationObserver()) {
                    this.appendChild(child);
                } else {
                    var children;
                    if (child.nodeType === 11) {
                        children = makeArray(childNodes(child));
                    } else {
                        children = [child];
                    }
                    this.appendChild(child);
                    mutated(children, 'inserted');
                }
            },
            insertBefore: function (child, ref, document) {
                if (getMutationObserver()) {
                    this.insertBefore(child, ref);
                } else {
                    var children;
                    if (child.nodeType === 11) {
                        children = makeArray(childNodes(child));
                    } else {
                        children = [child];
                    }
                    this.insertBefore(child, ref);
                    mutated(children, 'inserted');
                }
            },
            removeChild: function (child) {
                if (getMutationObserver()) {
                    this.removeChild(child);
                } else {
                    mutated([child], 'removed');
                    this.removeChild(child);
                }
            },
            replaceChild: function (newChild, oldChild) {
                if (getMutationObserver()) {
                    this.replaceChild(newChild, oldChild);
                } else {
                    var children;
                    if (newChild.nodeType === 11) {
                        children = makeArray(childNodes(newChild));
                    } else {
                        children = [newChild];
                    }
                    mutated([oldChild], 'removed');
                    this.replaceChild(newChild, oldChild);
                    mutated(children, 'inserted');
                }
            },
            inserted: function (elements) {
                mutated(elements, 'inserted');
            },
            removed: function (elements) {
                mutated(elements, 'removed');
            }
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-component@4.0.0-pre.2#test/helpers*/
define('can-component@4.0.0-pre.2#test/helpers', [
    'require',
    'exports',
    'module',
    'can-util/dom/mutation-observer/mutation-observer',
    'can-util/dom/document/document',
    'can-vdom/make-document/make-document',
    'can-util/dom/mutate/mutate',
    'can-util/dom/events/events',
    'can-globals'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var MUTATION_OBSERVER = require('can-util/dom/mutation-observer/mutation-observer');
        var DOCUMENT = require('can-util/dom/document/document');
        var makeDocument = require('can-vdom/make-document/make-document');
        var domMutate = require('can-util/dom/mutate/mutate');
        var domEvents = require('can-util/dom/events/events');
        var globals = require('can-globals');
        var helpers = {
            runTasks: function (tasks) {
                var nextTask = function () {
                    var next = tasks.shift();
                    next();
                    if (tasks.length) {
                        setTimeout(nextTask, 100);
                    } else {
                        start();
                    }
                };
                setTimeout(nextTask, 100);
            },
            makeTest: function (name, doc, mutObs, test, qUnitTest) {
                var DOC = DOCUMENT();
                var MUT_OBS = MUTATION_OBSERVER();
                QUnit.module(name, {
                    setup: function () {
                        DOCUMENT(doc);
                        MUTATION_OBSERVER(mutObs);
                        if (doc) {
                            this.fixture = doc.createElement('div');
                            doc.body.appendChild(this.fixture);
                        } else {
                            this.fixture = doc.getElementById('qunit-fixture');
                        }
                    },
                    teardown: function () {
                        doc.body.removeChild(this.fixture);
                        stop();
                        setTimeout(function () {
                            start();
                            DOCUMENT(DOC);
                            MUTATION_OBSERVER(MUT_OBS);
                        }, 100);
                    }
                });
                test(doc, qUnitTest);
            },
            makeTests: function (name, test) {
                helpers.makeTest(name + ' - dom', document, MUTATION_OBSERVER(), test, QUnit.test);
                helpers.makeTest(name + ' - vdom', makeDocument(), null, test, function () {
                });
            },
            afterMutation: function (cb) {
                var doc = globals.getKeyValue('document');
                var div = doc.createElement('div');
                domEvents.addEventListener.call(div, 'inserted', function () {
                    doc.body.removeChild(div);
                    setTimeout(cb, 5);
                });
                setTimeout(function () {
                    domMutate.appendChild.call(doc.body, div);
                }, 10);
            }
        };
        module.exports = helpers;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-assign@1.0.0#can-assign*/
define('can-assign@1.0.0#can-assign', function (require, exports, module) {
    module.exports = function (d, s) {
        for (var prop in s) {
            d[prop] = s[prop];
        }
        return d;
    };
});
/*can-util@3.10.12#js/assign/assign*/
define('can-util@3.10.12#js/assign/assign', [
    'require',
    'exports',
    'module',
    'can-assign'
], function (require, exports, module) {
    'use strict';
    module.exports = require('can-assign');
});
/*can-util@3.10.12#js/is-function/is-function*/
define('can-util@3.10.12#js/is-function/is-function', function (require, exports, module) {
    'use strict';
    var isFunction = function () {
        if (typeof document !== 'undefined' && typeof document.getElementsByTagName('body') === 'function') {
            return function (value) {
                return Object.prototype.toString.call(value) === '[object Function]';
            };
        }
        return function (value) {
            return typeof value === 'function';
        };
    }();
    module.exports = isFunction;
});
/*can-util@3.10.12#js/deep-assign/deep-assign*/
define('can-util@3.10.12#js/deep-assign/deep-assign', [
    'require',
    'exports',
    'module',
    '../is-function/is-function',
    '../is-plain-object/is-plain-object'
], function (require, exports, module) {
    'use strict';
    var isFunction = require('../is-function/is-function');
    var isPlainObject = require('../is-plain-object/is-plain-object');
    function deepAssign() {
        var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length;
        if (typeof target !== 'object' && !isFunction(target)) {
            target = {};
        }
        if (length === i) {
            target = this;
            --i;
        }
        for (; i < length; i++) {
            if ((options = arguments[i]) != null) {
                for (name in options) {
                    src = target[name];
                    copy = options[name];
                    if (target === copy) {
                        continue;
                    }
                    if (copy && (isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
                        if (copyIsArray) {
                            copyIsArray = false;
                            clone = src && Array.isArray(src) ? src : [];
                        } else {
                            clone = src && isPlainObject(src) ? src : {};
                        }
                        target[name] = deepAssign(clone, copy);
                    } else if (copy !== undefined) {
                        target[name] = copy;
                    }
                }
            }
        }
        return target;
    }
    module.exports = deepAssign;
});
/*can-util@3.10.12#js/dev/dev*/
define('can-util@3.10.12#js/dev/dev', [
    'require',
    'exports',
    'module',
    'can-log/dev/dev'
], function (require, exports, module) {
    'use strict';
    module.exports = require('can-log/dev/dev');
});
/*can-construct@3.2.2#can-construct*/
define('can-construct@3.2.2#can-construct', [
    'require',
    'exports',
    'module',
    'can-util/js/assign/assign',
    'can-util/js/deep-assign/deep-assign',
    'can-util/js/dev/dev',
    'can-util/js/make-array/make-array',
    'can-namespace'
], function (require, exports, module) {
    'use strict';
    var assign = require('can-util/js/assign/assign');
    var deepAssign = require('can-util/js/deep-assign/deep-assign');
    var dev = require('can-util/js/dev/dev');
    var makeArray = require('can-util/js/make-array/make-array');
    var namespace = require('can-namespace');
    var initializing = 0;
    var Construct = function () {
        if (arguments.length) {
            return Construct.extend.apply(Construct, arguments);
        }
    };
    var canGetDescriptor;
    try {
        Object.getOwnPropertyDescriptor({});
        canGetDescriptor = true;
    } catch (e) {
        canGetDescriptor = false;
    }
    var getDescriptor = function (newProps, name) {
            var descriptor = Object.getOwnPropertyDescriptor(newProps, name);
            if (descriptor && (descriptor.get || descriptor.set)) {
                return descriptor;
            }
            return null;
        }, inheritGetterSetter = function (newProps, oldProps, addTo) {
            addTo = addTo || newProps;
            var descriptor;
            for (var name in newProps) {
                if (descriptor = getDescriptor(newProps, name)) {
                    this._defineProperty(addTo, oldProps, name, descriptor);
                } else {
                    Construct._overwrite(addTo, oldProps, name, newProps[name]);
                }
            }
        }, simpleInherit = function (newProps, oldProps, addTo) {
            addTo = addTo || newProps;
            for (var name in newProps) {
                Construct._overwrite(addTo, oldProps, name, newProps[name]);
            }
        };
    assign(Construct, {
        constructorExtends: true,
        newInstance: function () {
            var inst = this.instance(), args;
            if (inst.setup) {
                Object.defineProperty(inst, '__inSetup', {
                    configurable: true,
                    enumerable: false,
                    value: true,
                    writable: true
                });
                args = inst.setup.apply(inst, arguments);
                if (args instanceof Construct.ReturnValue) {
                    return args.value;
                }
                inst.__inSetup = false;
            }
            if (inst.init) {
                inst.init.apply(inst, args || arguments);
            }
            return inst;
        },
        _inherit: canGetDescriptor ? inheritGetterSetter : simpleInherit,
        _defineProperty: function (what, oldProps, propName, descriptor) {
            Object.defineProperty(what, propName, descriptor);
        },
        _overwrite: function (what, oldProps, propName, val) {
            Object.defineProperty(what, propName, {
                value: val,
                configurable: true,
                enumerable: true,
                writable: true
            });
        },
        setup: function (base) {
            this.defaults = deepAssign(true, {}, base.defaults, this.defaults);
        },
        instance: function () {
            initializing = 1;
            var inst = new this();
            initializing = 0;
            return inst;
        },
        extend: function (name, staticProperties, instanceProperties) {
            var shortName = name, klass = staticProperties, proto = instanceProperties;
            if (typeof shortName !== 'string') {
                proto = klass;
                klass = shortName;
                shortName = null;
            }
            if (!proto) {
                proto = klass;
                klass = null;
            }
            proto = proto || {};
            var _super_class = this, _super = this.prototype, Constructor, prototype;
            prototype = this.instance();
            Construct._inherit(proto, _super, prototype);
            if (shortName) {
            } else if (klass && klass.shortName) {
                shortName = klass.shortName;
            } else if (this.shortName) {
                shortName = this.shortName;
            }
            function init() {
                if (!initializing) {
                    return (!this || this.constructor !== Constructor) && arguments.length && Constructor.constructorExtends ? Constructor.extend.apply(Constructor, arguments) : Constructor.newInstance.apply(Constructor, arguments);
                }
            }
            Constructor = typeof namedCtor === 'function' ? namedCtor(constructorName, init) : function () {
                return init.apply(this, arguments);
            };
            for (var propName in _super_class) {
                if (_super_class.hasOwnProperty(propName)) {
                    Constructor[propName] = _super_class[propName];
                }
            }
            Construct._inherit(klass, _super_class, Constructor);
            assign(Constructor, {
                constructor: Constructor,
                prototype: prototype
            });
            if (shortName !== undefined) {
                Constructor.shortName = shortName;
            }
            Constructor.prototype.constructor = Constructor;
            var t = [_super_class].concat(makeArray(arguments)), args = Constructor.setup.apply(Constructor, t);
            if (Constructor.init) {
                Constructor.init.apply(Constructor, args || t);
            }
            return Constructor;
        },
        ReturnValue: function (value) {
            this.value = value;
        }
    });
    Construct.prototype.setup = function () {
    };
    Construct.prototype.init = function () {
    };
    module.exports = namespace.Construct = Construct;
});
/*can-queues@0.2.6#queue-state*/
define('can-queues@0.2.6#queue-state', function (require, exports, module) {
    module.exports = { lastTask: null };
});
/*can-queues@0.2.6#queue*/
define('can-queues@0.2.6#queue', [
    'require',
    'exports',
    'module',
    './queue-state',
    'can-util/js/dev/dev'
], function (require, exports, module) {
    var queueState = require('./queue-state');
    var canDev = require('can-util/js/dev/dev');
    var noop = function () {
    };
    var Queue = function (name, callbacks) {
        this.callbacks = Object.assign({
            onFirstTask: noop,
            onComplete: function () {
                queueState.lastTask = null;
            }
        }, callbacks || {});
        this.name = name;
        this.index = 0;
        this.tasks = [];
        this._log = false;
    };
    Queue.prototype.enqueue = function (fn, context, args, meta) {
        this.tasks.push({
            fn: fn,
            context: context,
            args: args,
            meta: meta || {}
        });
        if (this.tasks.length === 1) {
            this.callbacks.onFirstTask(this);
        }
    };
    Queue.prototype.flush = function () {
        while (this.index < this.tasks.length) {
            var task = this.tasks[this.index++];
            task.fn.apply(task.context, task.args);
        }
        this.index = 0;
        this.tasks = [];
        this.callbacks.onComplete(this);
    };
    Queue.prototype.log = function () {
        this._log = arguments.length ? arguments[0] : true;
    };
    module.exports = Queue;
});
/*can-queues@0.2.6#priority-queue*/
define('can-queues@0.2.6#priority-queue', [
    'require',
    'exports',
    'module',
    './queue'
], function (require, exports, module) {
    var Queue = require('./queue');
    var PriorityQueue = function () {
        Queue.apply(this, arguments);
        this.taskMap = new Map();
        this.curPriorityIndex = Infinity;
        this.curPriorityMax = 0;
        this.taskContainersByPriority = [];
        this.isFlushing = false;
        this.tasksRemaining = 0;
    };
    PriorityQueue.prototype = Object.create(Queue.prototype);
    PriorityQueue.prototype.enqueue = function (fn, context, args, meta) {
        if (!this.taskMap.has(fn)) {
            this.tasksRemaining++;
            var isFirst = this.taskContainersByPriority.length === 0;
            var task = {
                fn: fn,
                context: context,
                args: args,
                meta: meta || {}
            };
            var taskContainer = this.getTaskContainerAndUpdateRange(task);
            taskContainer.tasks.push(task);
            this.taskMap.set(fn, task);
            if (isFirst) {
                this.callbacks.onFirstTask(this);
            }
        }
    };
    PriorityQueue.prototype.isEnqueued = function (fn) {
        return this.taskMap.has(fn);
    };
    PriorityQueue.prototype.flush = function () {
        if (this.isFlushing) {
            return;
        }
        this.isFlushing = true;
        while (true) {
            if (this.curPriorityIndex <= this.curPriorityMax) {
                var taskContainer = this.taskContainersByPriority[this.curPriorityIndex];
                if (taskContainer && taskContainer.tasks.length > taskContainer.index) {
                    var task = taskContainer.tasks[taskContainer.index++];
                    this.tasksRemaining--;
                    this.taskMap['delete'](task.fn);
                    task.fn.apply(task.context, task.args);
                } else {
                    this.curPriorityIndex++;
                }
            } else {
                this.taskMap = new Map();
                this.curPriorityIndex = Infinity;
                this.curPriorityMax = 0;
                this.taskContainersByPriority = [];
                this.isFlushing = false;
                this.callbacks.onComplete(this);
                return;
            }
        }
    };
    PriorityQueue.prototype.flushQueuedTask = function (fn) {
        var task = this.taskMap.get(fn);
        if (task) {
            var priority = task.meta.priority || 0;
            var taskContainer = this.taskContainersByPriority[priority];
            var index = taskContainer.tasks.indexOf(task, taskContainer.index);
            if (index >= 0) {
                taskContainer.tasks.splice(index, 1);
                this.tasksRemaining--;
                this.taskMap['delete'](task.fn);
                task.fn.apply(task.context, task.args);
            }
        }
    };
    PriorityQueue.prototype.getTaskContainerAndUpdateRange = function (task) {
        var priority = task.meta.priority || 0;
        if (priority < this.curPriorityIndex) {
            this.curPriorityIndex = priority;
        }
        if (priority > this.curPriorityMax) {
            this.curPriorityMax = priority;
        }
        var taskContainer = this.taskContainersByPriority[priority] || (this.taskContainersByPriority[priority] = {
            tasks: [],
            index: 0
        });
        return taskContainer;
    };
    PriorityQueue.prototype.tasksRemainingCount = function () {
        return this.tasksRemaining;
    };
    module.exports = PriorityQueue;
});
/*can-queues@0.2.6#completion-queue*/
define('can-queues@0.2.6#completion-queue', [
    'require',
    'exports',
    'module',
    './queue'
], function (require, exports, module) {
    var Queue = require('./queue');
    var CompletionQueue = function () {
        Queue.apply(this, arguments);
        this.flushCount = 0;
    };
    CompletionQueue.prototype = Object.create(Queue.prototype);
    CompletionQueue.prototype.flush = function () {
        if (this.flushCount > 0) {
        } else {
            this.flushCount++;
            while (this.index < this.tasks.length) {
                var task = this.tasks[this.index++];
                task.fn.apply(task.context, task.args);
            }
            this.index = 0;
            this.tasks = [];
            this.flushCount--;
            this.callbacks.onComplete(this);
        }
    };
    module.exports = CompletionQueue;
});
/*can-queues@0.2.6#can-queues*/
define('can-queues@0.2.6#can-queues', [
    'require',
    'exports',
    'module',
    'can-util/js/dev/dev',
    './queue',
    './priority-queue',
    './queue-state',
    './completion-queue',
    'can-namespace'
], function (require, exports, module) {
    var canDev = require('can-util/js/dev/dev');
    var Queue = require('./queue');
    var PriorityQueue = require('./priority-queue');
    var queueState = require('./queue-state');
    var CompletionQueue = require('./completion-queue');
    var ns = require('can-namespace');
    var batchStartCounter = 0;
    var addedNotifyTask = false;
    var isFlushing = false;
    var batchNum = 0;
    var batchData;
    var emptyObject = function () {
        return {};
    };
    var NOTIFY_QUEUE, DERIVE_QUEUE, DOM_UI_QUEUE, MUTATE_QUEUE;
    NOTIFY_QUEUE = new Queue('NOTIFY', {
        onComplete: function () {
            DERIVE_QUEUE.flush();
        },
        onFirstTask: function () {
            if (!batchStartCounter) {
                NOTIFY_QUEUE.flush();
            } else {
                addedNotifyTask = true;
            }
        }
    });
    DERIVE_QUEUE = new PriorityQueue('DERIVE', {
        onComplete: function () {
            DOM_UI_QUEUE.flush();
        },
        onFirstTask: function () {
            addedNotifyTask = true;
        }
    });
    DOM_UI_QUEUE = new CompletionQueue('DOM_UI', {
        onComplete: function () {
            MUTATE_QUEUE.flush();
        },
        onFirstTask: function () {
            addedNotifyTask = true;
        }
    });
    MUTATE_QUEUE = new Queue('MUTATE', {
        onComplete: function () {
            queueState.lastTask = null;
            isFlushing = false;
        },
        onFirstTask: function () {
            addedNotifyTask = true;
        }
    });
    var queues = {
        Queue: Queue,
        PriorityQueue: PriorityQueue,
        notifyQueue: NOTIFY_QUEUE,
        deriveQueue: DERIVE_QUEUE,
        domUIQueue: DOM_UI_QUEUE,
        mutateQueue: MUTATE_QUEUE,
        batch: {
            start: function () {
                batchStartCounter++;
                if (batchStartCounter === 1) {
                    batchNum++;
                    batchData = { number: batchNum };
                }
            },
            stop: function () {
                batchStartCounter--;
                if (batchStartCounter === 0) {
                    if (addedNotifyTask) {
                        addedNotifyTask = false;
                        isFlushing = true;
                        NOTIFY_QUEUE.flush();
                    }
                }
            },
            isCollecting: function () {
                return batchStartCounter > 0;
            },
            number: function () {
                return batchNum;
            },
            data: function () {
                return batchData;
            }
        },
        enqueueByQueue: function enqueueByQueue(fnByQueue, context, args, makeMeta, reasonLog) {
            if (fnByQueue) {
                makeMeta = makeMeta || emptyObject;
                queues.batch.start();
                [
                    'notify',
                    'derive',
                    'domUI',
                    'mutate'
                ].forEach(function (queueName) {
                    var name = queueName + 'Queue';
                    var QUEUE = queues[name], tasks = fnByQueue[queueName];
                    if (tasks !== undefined) {
                        tasks.forEach(function (handler) {
                            var meta = makeMeta && makeMeta(handler, context, args);
                            meta.reasonLog = reasonLog;
                            QUEUE.enqueue(handler, context, args, meta);
                        });
                    }
                });
                queues.batch.stop();
            }
        },
        stack: function () {
            var current = queueState.lastTask;
            var stack = [];
            while (current) {
                stack.unshift(current);
                current = current.meta.parentTask;
            }
            return stack;
        },
        logStack: function () {
            var stack = this.stack();
            stack.forEach(function (task) {
                var log = task.meta && task.meta.log ? task.meta.log : [
                    task.fn.name,
                    task
                ];
                canDev.log.apply(canDev, [task.meta.stack.name + ' ran task:'].concat(log));
            });
        },
        taskCount: function () {
            return NOTIFY_QUEUE.tasks.length + DERIVE_QUEUE.tasks.length + DOM_UI_QUEUE.tasks.length + MUTATE_QUEUE.tasks.length;
        },
        flush: function () {
            NOTIFY_QUEUE.flush();
        },
        log: function () {
            NOTIFY_QUEUE.log.apply(NOTIFY_QUEUE, arguments);
            DERIVE_QUEUE.log.apply(DERIVE_QUEUE, arguments);
            DOM_UI_QUEUE.log.apply(DOM_UI_QUEUE, arguments);
            MUTATE_QUEUE.log.apply(MUTATE_QUEUE, arguments);
        }
    };
    if (ns.queues) {
        throw new Error('You can\'t have two versions of can-queues, check your dependencies');
    } else {
        module.exports = ns.queues = queues;
    }
});
/*can-key-tree@0.1.0#can-key-tree*/
define('can-key-tree@0.1.0#can-key-tree', [
    'require',
    'exports',
    'module',
    'can-reflect'
], function (require, exports, module) {
    var reflect = require('can-reflect');
    function isBuiltInPrototype(obj) {
        return obj === Object.prototype || Object.prototype.toString.call(obj) !== '[object Object]' && Object.prototype.toString.call(obj).indexOf('[object ') !== -1;
    }
    var KeyTree = function (treeStructure, callbacks) {
        this.callbacks = callbacks || {};
        this.treeStructure = treeStructure;
        var FirstConstructor = treeStructure[0];
        if (reflect.isConstructorLike(FirstConstructor)) {
            this.root = new FirstConstructor();
        } else {
            this.root = FirstConstructor;
        }
    };
    KeyTree.prototype.add = function (keys) {
        if (keys.length > this.treeStructure.length) {
            throw new Error('can-key-tree: Can not add path deeper than tree.');
        }
        var place = this.root;
        var rootWasEmpty = reflect.size(this.root) === 0;
        for (var i = 0; i < keys.length - 1; i++) {
            var key = keys[i];
            var store = reflect.getKeyValue(place, key);
            if (!store) {
                var Constructor = this.treeStructure[i + 1];
                if (isBuiltInPrototype(Constructor.prototype)) {
                    store = new Constructor();
                } else {
                    store = new Constructor(key);
                }
                reflect.setKeyValue(place, key, store);
            }
            place = store;
        }
        if (reflect.isMoreListLikeThanMapLike(place)) {
            reflect.addValues(place, [keys[keys.length - 1]]);
        } else {
            throw new Error('can-key-tree: Map types are not supported yet.');
        }
        if (rootWasEmpty && this.callbacks.onFirst) {
            this.callbacks.onFirst.call(this);
        }
    };
    function getDeep(item, items, depth, maxDepth) {
        if (!item) {
            return;
        }
        if (maxDepth === depth) {
            if (reflect.isMoreListLikeThanMapLike(item)) {
                reflect.addValues(items, reflect.toArray(item));
            } else {
                throw new Error('can-key-tree: Map types are not supported yet.');
            }
        } else {
            reflect.each(item, function (value) {
                getDeep(value, items, depth + 1, maxDepth);
            });
        }
    }
    KeyTree.prototype.get = function (keys) {
        var place = this.getNode(keys);
        if (this.treeStructure.length === keys.length) {
            return place;
        } else {
            var Type = this.treeStructure[this.treeStructure.length - 1];
            var items = new Type();
            getDeep(place, items, keys.length, this.treeStructure.length - 1);
            return items;
        }
    };
    KeyTree.prototype.getNode = function (keys) {
        var place = this.root;
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            var store = reflect.getKeyValue(place, key);
            if (!store) {
                return;
            }
            place = store;
        }
        return place;
    };
    function clear(item, depth, maxDepth) {
        if (maxDepth === depth) {
            if (reflect.isMoreListLikeThanMapLike(item)) {
                reflect.removeValues(item, reflect.toArray(item));
            } else {
                throw new Error('can-key-tree: Map types are not supported yet.');
            }
        } else {
            reflect.each(item, function (value, key) {
                clear(value, depth + 1, maxDepth);
                reflect.deleteKeyValue(item, key);
            });
        }
    }
    KeyTree.prototype.delete = function (keys) {
        var place = this.root;
        var roots = [this.root];
        for (var i = 0; i < keys.length - 1; i++) {
            var key = keys[i];
            var store = reflect.getKeyValue(place, key);
            if (store === undefined) {
                return false;
            } else {
                roots.push(store);
            }
            place = store;
        }
        var lastKey = keys[keys.length - 1];
        if (keys.length === this.treeStructure.length) {
            if (reflect.isMoreListLikeThanMapLike(place)) {
                reflect.removeValues(place, [lastKey]);
            } else {
                throw new Error('can-key-tree: Map types are not supported yet.');
            }
        } else if (!keys.length) {
            clear(place, 0, this.treeStructure.length - 1);
        } else {
            var branch = reflect.getKeyValue(place, lastKey);
            if (branch !== undefined) {
                clear(branch, keys.length, this.treeStructure.length - 1);
                reflect.deleteKeyValue(place, lastKey);
            } else {
                return false;
            }
        }
        for (i = roots.length - 2; i >= 0; i--) {
            if (reflect.size(place) === 0) {
                place = roots[i];
                reflect.deleteKeyValue(place, keys[i]);
            } else {
                break;
            }
        }
        if (this.callbacks.onEmpty && reflect.size(this.root) === 0) {
            this.callbacks.onEmpty.call(this);
        }
        return true;
    };
    function getDepth(root, level) {
        if (level === 0) {
            return reflect.size(root);
        } else if (reflect.size(root) === 0) {
            return 0;
        } else {
            var count = 0;
            reflect.each(root, function (value) {
                count += getDepth(value, level - 1);
            });
            return count;
        }
    }
    KeyTree.prototype.size = function () {
        return getDepth(this.root, this.treeStructure.length - 1);
    };
    module.exports = KeyTree;
});
/*can-event-queue@0.2.2#can-event-queue*/
define('can-event-queue@0.2.2#can-event-queue', [
    'require',
    'exports',
    'module',
    'can-util/js/dev/dev',
    'can-util/js/assign/assign',
    'can-queues',
    'can-reflect',
    'can-symbol',
    'can-key-tree'
], function (require, exports, module) {
    var canDev = require('can-util/js/dev/dev');
    var assign = require('can-util/js/assign/assign');
    var queues = require('can-queues');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var KeyTree = require('can-key-tree');
    var ensureMeta = function ensureMeta(obj) {
        var metaSymbol = canSymbol.for('can.meta');
        var meta = obj[metaSymbol];
        if (!meta) {
            meta = {};
            canReflect.setKeyValue(obj, metaSymbol, meta);
        }
        return meta;
    };
    function getHandlers(obj) {
        var meta = ensureMeta(obj);
        var handlers = meta.handlers;
        if (!handlers) {
            handlers = meta.handlers = new KeyTree([
                Object,
                Object,
                Object,
                Array
            ], {
                onFirst: function () {
                    if (obj._eventSetup) {
                        obj._eventSetup();
                    }
                },
                onEmpty: function () {
                    if (obj._eventTeardown) {
                        obj._eventTeardown();
                    }
                }
            });
        }
        return handlers;
    }
    var props = {
        dispatch: function (event, args) {
            if (!this.__inSetup) {
                if (typeof event === 'string') {
                    event = { type: event };
                }
                var handlers = getHandlers(this);
                var handlersByType = handlers.getNode([event.type]);
                if (handlersByType) {
                    queues.batch.start();
                    if (handlersByType.onKeyValue) {
                        queues.enqueueByQueue(handlersByType.onKeyValue, this, args, event.makeMeta, event.reasonLog);
                    }
                    if (handlersByType.event) {
                        event.batchNum = queues.batch.number();
                        var eventAndArgs = [event].concat(args);
                        queues.enqueueByQueue(handlersByType.event, this, eventAndArgs, event.makeMeta, event.reasonLog);
                    }
                    queues.batch.stop();
                }
            }
        },
        addEventListener: function (key, handler, queueName) {
            getHandlers(this).add([
                key,
                'event',
                queueName || 'mutate',
                handler
            ]);
        },
        removeEventListener: function (key, handler, queueName) {
            getHandlers(this).delete([
                key,
                'event',
                queueName || 'mutate',
                handler
            ]);
        }
    };
    props.on = props.addEventListener;
    props.off = props.removeEventListener;
    var symbols = {
        'can.onKeyValue': function (key, handler, queueName) {
            getHandlers(this).add([
                key,
                'onKeyValue',
                queueName || 'mutate',
                handler
            ]);
        },
        'can.offKeyValue': function (key, handler, queueName) {
            getHandlers(this).delete([
                key,
                'onKeyValue',
                queueName || 'mutate',
                handler
            ]);
        }
    };
    var eventQueue = function (obj) {
        assign(obj, props);
        canReflect.assignSymbols(obj, symbols);
        return obj;
    };
    function defineNonEnumerable(obj, prop, value) {
        Object.defineProperty(obj, prop, {
            enumerable: false,
            value: value
        });
    }
    assign(eventQueue, props);
    defineNonEnumerable(eventQueue, 'start', function () {
        console.warn('use can-queues.batch.start()');
        queues.batch.start();
    });
    defineNonEnumerable(eventQueue, 'stop', function () {
        console.warn('use can-queues.batch.stop()');
        queues.batch.stop();
    });
    defineNonEnumerable(eventQueue, 'flush', function () {
        console.warn('use can-queues.flush()');
        queues.flush();
    });
    defineNonEnumerable(eventQueue, 'afterPreviousEvents', function (handler) {
        console.warn('don\'t use afterPreviousEvents');
        queues.mutateQueue.enqueue(function afterPreviousEvents() {
            queues.mutateQueue.enqueue(handler);
        });
        queues.flush();
    });
    defineNonEnumerable(eventQueue, 'after', function (handler) {
        console.warn('don\'t use after');
        queues.mutateQueue.enqueue(handler);
        queues.flush();
    });
    module.exports = eventQueue;
});
/*can-observation-recorder@0.1.0#can-observation-recorder*/
define('can-observation-recorder@0.1.0#can-observation-recorder', [
    'require',
    'exports',
    'module',
    'can-namespace'
], function (require, exports, module) {
    var namespace = require('can-namespace');
    var stack = [];
    var observationRecorder = {
        stack: stack,
        makeDependenciesRecorder: function () {
            return {
                traps: null,
                keyDependencies: new Map(),
                valueDependencies: new Set(),
                ignore: 0
            };
        },
        start: function () {
            stack.push({
                traps: null,
                keyDependencies: new Map(),
                valueDependencies: new Set(),
                ignore: 0
            });
        },
        stop: function () {
            return stack.pop();
        },
        add: function (obj, event) {
            var top = stack[stack.length - 1];
            if (top && top.ignore === 0) {
                if (top.traps) {
                    top.traps.push([
                        obj,
                        event
                    ]);
                } else {
                    if (event === undefined) {
                        top.valueDependencies.add(obj);
                    } else {
                        var eventSet = top.keyDependencies.get(obj);
                        if (!eventSet) {
                            eventSet = new Set();
                            top.keyDependencies.set(obj, eventSet);
                        }
                        eventSet.add(event);
                    }
                }
            }
        },
        addMany: function (observes) {
            var top = stack[stack.length - 1];
            if (top) {
                if (top.traps) {
                    top.traps.push.apply(top.traps, observes);
                } else {
                    for (var i = 0, len = observes.length; i < len; i++) {
                        this.add(observes[i][0], observes[i][1]);
                    }
                }
            }
        },
        ignore: function (fn) {
            return function () {
                if (stack.length) {
                    var top = stack[stack.length - 1];
                    top.ignore++;
                    var res = fn.apply(this, arguments);
                    top.ignore--;
                    return res;
                } else {
                    return fn.apply(this, arguments);
                }
            };
        },
        trap: function () {
            if (stack.length) {
                var top = stack[stack.length - 1];
                var oldTraps = top.traps;
                var traps = top.traps = [];
                return function () {
                    top.traps = oldTraps;
                    return traps;
                };
            } else {
                return function () {
                    return [];
                };
            }
        },
        trapsCount: function () {
            if (stack.length) {
                var top = stack[stack.length - 1];
                return top.traps.length;
            } else {
                return 0;
            }
        },
        isRecording: function () {
            var len = stack.length;
            var last = len && stack[len - 1];
            return last && last.ignore === 0 && last;
        }
    };
    if (namespace.observationRecorder) {
        throw new Error('You can\'t have two versions of can-observation-recorder, check your dependencies');
    } else {
        module.exports = namespace.observationRecorder = observationRecorder;
    }
});
/*can-simple-map@4.0.0-pre.7#can-simple-map*/
define('can-simple-map@4.0.0-pre.7#can-simple-map', [
    'require',
    'exports',
    'module',
    'can-construct',
    'can-event-queue',
    'can-queues',
    'can-util/js/each/each',
    'can-observation-recorder',
    'can-reflect',
    'can-log/dev/dev',
    'can-symbol'
], function (require, exports, module) {
    var Construct = require('can-construct');
    var eventQueue = require('can-event-queue');
    var queues = require('can-queues');
    var each = require('can-util/js/each/each');
    var ObservationRecorder = require('can-observation-recorder');
    var canReflect = require('can-reflect');
    var dev = require('can-log/dev/dev');
    var canSymbol = require('can-symbol');
    var ensureMeta = function ensureMeta(obj) {
        var metaSymbol = canSymbol.for('can.meta');
        var meta = obj[metaSymbol];
        if (!meta) {
            meta = {};
            canReflect.setKeyValue(obj, metaSymbol, meta);
        }
        return meta;
    };
    var SimpleMap = Construct.extend('SimpleMap', {
        setup: function (initialData) {
            this._data = {};
            this.attr(initialData);
        },
        attr: function (prop, value) {
            var self = this;
            if (arguments.length === 0) {
                ObservationRecorder.add(this, '__keys');
                var data = {};
                each(this._data, function (value, prop) {
                    ObservationRecorder.add(this, prop);
                    data[prop] = value;
                }, this);
                return data;
            } else if (arguments.length > 1) {
                var had = this._data.hasOwnProperty(prop);
                var old = this._data[prop];
                this._data[prop] = value;
                queues.batch.start();
                if (!had) {
                    this.dispatch('__keys', []);
                }
                this.dispatch({ type: prop }, [
                    value,
                    old
                ]);
                queues.batch.stop();
            } else if (typeof prop === 'object') {
                queues.batch.start();
                canReflect.eachKey(prop, function (value, key) {
                    self.attr(key, value);
                });
                queues.batch.stop();
            } else {
                if (prop !== 'constructor') {
                    ObservationRecorder.add(this, prop);
                    return this._data[prop];
                }
                return this.constructor;
            }
        },
        serialize: function () {
            return canReflect.serialize(this, Map);
        },
        get: function () {
            return this.attr.apply(this, arguments);
        },
        set: function () {
            return this.attr.apply(this, arguments);
        },
        log: function (key) {
        }
    });
    eventQueue(SimpleMap.prototype);
    canReflect.assignSymbols(SimpleMap.prototype, {
        'can.isMapLike': true,
        'can.isListLike': false,
        'can.isValueLike': false,
        'can.getKeyValue': SimpleMap.prototype.get,
        'can.setKeyValue': SimpleMap.prototype.set,
        'can.deleteKeyValue': function (prop) {
            return this.attr(prop, undefined);
        },
        'can.getOwnEnumerableKeys': function () {
            ObservationRecorder.add(this, '__keys');
            return Object.keys(this._data);
        },
        'can.assignDeep': function (source) {
            queues.batch.start();
            canReflect.assignMap(this, source);
            queues.batch.stop();
        },
        'can.updateDeep': function (source) {
            queues.batch.start();
            canReflect.updateMap(this, source);
            queues.batch.stop();
        },
        'can.keyHasDependencies': function (key) {
            return false;
        },
        'can.getKeyDependencies': function (key) {
            return undefined;
        }
    });
    module.exports = SimpleMap;
});
/*can-util@3.10.12#js/global/global*/
define('can-util@3.10.12#js/global/global', [
    'require',
    'exports',
    'module',
    'can-globals/global/global'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        module.exports = require('can-globals/global/global');
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-view-callbacks@4.0.0-pre.2#can-view-callbacks*/
define('can-view-callbacks@4.0.0-pre.2#can-view-callbacks', [
    'require',
    'exports',
    'module',
    'can-observation-recorder',
    'can-util/js/dev/dev',
    'can-util/js/global/global',
    'can-util/dom/mutate/mutate',
    'can-namespace'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var ObservationRecorder = require('can-observation-recorder');
        var dev = require('can-util/js/dev/dev');
        var getGlobal = require('can-util/js/global/global');
        var domMutate = require('can-util/dom/mutate/mutate');
        var namespace = require('can-namespace');
        var attr = function (attributeName, attrHandler) {
            if (attrHandler) {
                if (typeof attributeName === 'string') {
                    attributes[attributeName] = attrHandler;
                } else {
                    regExpAttributes.push({
                        match: attributeName,
                        handler: attrHandler
                    });
                }
            } else {
                var cb = attributes[attributeName];
                if (!cb) {
                    for (var i = 0, len = regExpAttributes.length; i < len; i++) {
                        var attrMatcher = regExpAttributes[i];
                        if (attrMatcher.match.test(attributeName)) {
                            return attrMatcher.handler;
                        }
                    }
                }
                return cb;
            }
        };
        var attributes = {}, regExpAttributes = [], automaticCustomElementCharacters = /[-\:]/;
        var defaultCallback = function () {
        };
        var tag = function (tagName, tagHandler) {
            if (tagHandler) {
                if (getGlobal().html5) {
                    getGlobal().html5.elements += ' ' + tagName;
                    getGlobal().html5.shivDocument();
                }
                tags[tagName.toLowerCase()] = tagHandler;
            } else {
                var cb;
                if (tagHandler === null) {
                    delete tags[tagName.toLowerCase()];
                } else {
                    cb = tags[tagName.toLowerCase()];
                }
                if (!cb && automaticCustomElementCharacters.test(tagName)) {
                    cb = defaultCallback;
                }
                return cb;
            }
        };
        var tags = {};
        var callbacks = {
            _tags: tags,
            _attributes: attributes,
            _regExpAttributes: regExpAttributes,
            defaultCallback: defaultCallback,
            tag: tag,
            attr: attr,
            tagHandler: function (el, tagName, tagData) {
                var helperTagCallback = tagData.options.get('tags.' + tagName, { proxyMethods: false }), tagCallback = helperTagCallback || tags[tagName];
                var scope = tagData.scope, res;
                if (tagCallback) {
                    res = ObservationRecorder.ignore(tagCallback)(el, tagData);
                } else {
                    res = scope;
                }
                if (res && tagData.subtemplate) {
                    if (scope !== res) {
                        scope = scope.add(res);
                    }
                    var result = tagData.subtemplate(scope, tagData.options);
                    var frag = typeof result === 'string' ? can.view.frag(result) : result;
                    domMutate.appendChild.call(el, frag);
                }
            }
        };
        namespace.view = namespace.view || {};
        if (namespace.view.callbacks) {
            throw new Error('You can\'t have two versions of can-view-callbacks, check your dependencies');
        } else {
            module.exports = namespace.view.callbacks = callbacks;
        }
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-util@3.10.12#dom/is-of-global-document/is-of-global-document*/
define('can-util@3.10.12#dom/is-of-global-document/is-of-global-document', [
    'require',
    'exports',
    'module',
    'can-globals/document/document'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var getDocument = require('can-globals/document/document');
        module.exports = function (el) {
            return (el.ownerDocument || el) === getDocument();
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-types@1.1.3#can-types*/
define('can-types@1.1.3#can-types', [
    'require',
    'exports',
    'module',
    'can-namespace',
    'can-reflect',
    'can-symbol',
    'can-log/dev/dev'
], function (require, exports, module) {
    var namespace = require('can-namespace');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var dev = require('can-log/dev/dev');
    var types = {
        isMapLike: function (obj) {
            return canReflect.isObservableLike(obj) && canReflect.isMapLike(obj);
        },
        isListLike: function (obj) {
            return canReflect.isObservableLike(obj) && canReflect.isListLike(obj);
        },
        isPromise: function (obj) {
            return canReflect.isPromise(obj);
        },
        isConstructor: function (func) {
            return canReflect.isConstructorLike(func);
        },
        isCallableForValue: function (obj) {
            return obj && canReflect.isFunctionLike(obj) && !canReflect.isConstructorLike(obj);
        },
        isCompute: function (obj) {
            return obj && obj.isComputed;
        },
        get iterator() {
            return canSymbol.iterator || canSymbol.for('iterator');
        },
        DefaultMap: null,
        DefaultList: null,
        queueTask: function (task) {
            var args = task[2] || [];
            task[0].apply(task[1], args);
        },
        wrapElement: function (element) {
            return element;
        },
        unwrapElement: function (element) {
            return element;
        }
    };
    if (namespace.types) {
        throw new Error('You can\'t have two versions of can-types, check your dependencies');
    } else {
        module.exports = namespace.types = types;
    }
});
/*can-util@3.10.12#js/diff/diff*/
define('can-util@3.10.12#js/diff/diff', function (require, exports, module) {
    'use strict';
    var slice = [].slice;
    var defaultIdentity = function (a, b) {
        return a === b;
    };
    function reverseDiff(oldDiffStopIndex, newDiffStopIndex, oldList, newList, identity) {
        var oldIndex = oldList.length - 1, newIndex = newList.length - 1;
        while (oldIndex > oldDiffStopIndex && newIndex > newDiffStopIndex) {
            var oldItem = oldList[oldIndex], newItem = newList[newIndex];
            if (identity(oldItem, newItem)) {
                oldIndex--;
                newIndex--;
                continue;
            } else {
                return [{
                        index: newDiffStopIndex,
                        deleteCount: oldIndex - oldDiffStopIndex + 1,
                        insert: slice.call(newList, newDiffStopIndex, newIndex + 1)
                    }];
            }
        }
        return [{
                index: newDiffStopIndex,
                deleteCount: oldIndex - oldDiffStopIndex + 1,
                insert: slice.call(newList, newDiffStopIndex, newIndex + 1)
            }];
    }
    module.exports = exports = function (oldList, newList, identity) {
        identity = identity || defaultIdentity;
        var oldIndex = 0, newIndex = 0, oldLength = oldList.length, newLength = newList.length, patches = [];
        while (oldIndex < oldLength && newIndex < newLength) {
            var oldItem = oldList[oldIndex], newItem = newList[newIndex];
            if (identity(oldItem, newItem)) {
                oldIndex++;
                newIndex++;
                continue;
            }
            if (newIndex + 1 < newLength && identity(oldItem, newList[newIndex + 1])) {
                patches.push({
                    index: newIndex,
                    deleteCount: 0,
                    insert: [newList[newIndex]]
                });
                oldIndex++;
                newIndex += 2;
                continue;
            } else if (oldIndex + 1 < oldLength && identity(oldList[oldIndex + 1], newItem)) {
                patches.push({
                    index: newIndex,
                    deleteCount: 1,
                    insert: []
                });
                oldIndex += 2;
                newIndex++;
                continue;
            } else {
                patches.push.apply(patches, reverseDiff(oldIndex, newIndex, oldList, newList, identity));
                return patches;
            }
        }
        if (newIndex === newLength && oldIndex === oldLength) {
            return patches;
        }
        patches.push({
            index: newIndex,
            deleteCount: oldLength - oldIndex,
            insert: slice.call(newList, newIndex)
        });
        return patches;
    };
});
/*can-util@3.10.12#dom/events/attributes/attributes*/
define('can-util@3.10.12#dom/events/attributes/attributes', [
    'require',
    'exports',
    'module',
    '../events',
    '../../is-of-global-document/is-of-global-document',
    '../../data/data',
    'can-globals/mutation-observer/mutation-observer',
    'can-assign',
    '../../dispatch/dispatch'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var events = require('../events');
        var isOfGlobalDocument = require('../../is-of-global-document/is-of-global-document');
        var domData = require('../../data/data');
        var getMutationObserver = require('can-globals/mutation-observer/mutation-observer');
        var assign = require('can-assign');
        var domDispatch = require('../../dispatch/dispatch');
        var originalAdd = events.addEventListener, originalRemove = events.removeEventListener;
        events.addEventListener = function (eventName) {
            if (eventName === 'attributes') {
                var MutationObserver = getMutationObserver();
                if (isOfGlobalDocument(this) && MutationObserver) {
                    var existingObserver = domData.get.call(this, 'canAttributesObserver');
                    if (!existingObserver) {
                        var self = this;
                        var observer = new MutationObserver(function (mutations) {
                            mutations.forEach(function (mutation) {
                                var copy = assign({}, mutation);
                                domDispatch.call(self, copy, [], false);
                            });
                        });
                        observer.observe(this, {
                            attributes: true,
                            attributeOldValue: true
                        });
                        domData.set.call(this, 'canAttributesObserver', observer);
                    }
                } else {
                    domData.set.call(this, 'canHasAttributesBindings', true);
                }
            }
            return originalAdd.apply(this, arguments);
        };
        events.removeEventListener = function (eventName) {
            if (eventName === 'attributes') {
                var MutationObserver = getMutationObserver();
                var observer;
                if (isOfGlobalDocument(this) && MutationObserver) {
                    observer = domData.get.call(this, 'canAttributesObserver');
                    if (observer && observer.disconnect) {
                        observer.disconnect();
                        domData.clean.call(this, 'canAttributesObserver');
                    }
                } else {
                    domData.clean.call(this, 'canHasAttributesBindings');
                }
            }
            return originalRemove.apply(this, arguments);
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-cid@1.1.1#map/map*/
define('can-cid@1.1.1#map/map', [
    'require',
    'exports',
    'module',
    '../can-cid',
    '../helpers'
], function (require, exports, module) {
    'use strict';
    var getCID = require('../can-cid').get;
    var helpers = require('../helpers');
    var CIDMap;
    if (typeof Map !== 'undefined') {
        CIDMap = Map;
    } else {
        var CIDMap = function () {
            this.values = {};
        };
        CIDMap.prototype.set = function (key, value) {
            this.values[getCID(key)] = {
                key: key,
                value: value
            };
        };
        CIDMap.prototype['delete'] = function (key) {
            var has = getCID(key) in this.values;
            if (has) {
                delete this.values[getCID(key)];
            }
            return has;
        };
        CIDMap.prototype.forEach = function (cb, thisArg) {
            helpers.each(this.values, function (pair) {
                return cb.call(thisArg || this, pair.value, pair.key, this);
            }, this);
        };
        CIDMap.prototype.has = function (key) {
            return getCID(key) in this.values;
        };
        CIDMap.prototype.get = function (key) {
            var obj = this.values[getCID(key)];
            return obj && obj.value;
        };
        CIDMap.prototype.clear = function () {
            return this.values = {};
        };
        Object.defineProperty(CIDMap.prototype, 'size', {
            get: function () {
                var size = 0;
                helpers.each(this.values, function () {
                    size++;
                });
                return size;
            }
        });
    }
    module.exports = CIDMap;
});
/*can-util@3.10.12#dom/events/make-mutation-event/make-mutation-event*/
define('can-util@3.10.12#dom/events/make-mutation-event/make-mutation-event', [
    'require',
    'exports',
    'module',
    '../events',
    '../../data/data',
    'can-globals/mutation-observer/mutation-observer',
    '../../dispatch/dispatch',
    '../../mutation-observer/document/document',
    'can-globals/document/document',
    'can-cid/map/map',
    '../../../js/string/string',
    '../../is-of-global-document/is-of-global-document'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var events = require('../events');
        var domData = require('../../data/data');
        var getMutationObserver = require('can-globals/mutation-observer/mutation-observer');
        var domDispatch = require('../../dispatch/dispatch');
        var mutationDocument = require('../../mutation-observer/document/document');
        var getDocument = require('can-globals/document/document');
        var CIDMap = require('can-cid/map/map');
        var string = require('../../../js/string/string');
        require('../../is-of-global-document/is-of-global-document');
        module.exports = function (specialEventName, mutationNodesProperty) {
            var originalAdd = events.addEventListener, originalRemove = events.removeEventListener;
            events.addEventListener = function (eventName) {
                if (eventName === specialEventName && getMutationObserver()) {
                    var documentElement = getDocument().documentElement;
                    var specialEventData = domData.get.call(documentElement, specialEventName + 'Data');
                    if (!specialEventData) {
                        specialEventData = {
                            handler: function (mutatedNode) {
                                if (specialEventData.nodeIdsRespondingToInsert.has(mutatedNode)) {
                                    domDispatch.call(mutatedNode, specialEventName, [], false);
                                    specialEventData.nodeIdsRespondingToInsert.delete(mutatedNode);
                                }
                            },
                            nodeIdsRespondingToInsert: new CIDMap()
                        };
                        mutationDocument['on' + string.capitalize(mutationNodesProperty)](specialEventData.handler);
                        domData.set.call(documentElement, specialEventName + 'Data', specialEventData);
                    }
                    if (this.nodeType !== 11) {
                        var count = specialEventData.nodeIdsRespondingToInsert.get(this) || 0;
                        specialEventData.nodeIdsRespondingToInsert.set(this, count + 1);
                    }
                }
                return originalAdd.apply(this, arguments);
            };
            events.removeEventListener = function (eventName) {
                if (eventName === specialEventName && getMutationObserver()) {
                    var documentElement = getDocument().documentElement;
                    var specialEventData = domData.get.call(documentElement, specialEventName + 'Data');
                    if (specialEventData) {
                        var newCount = specialEventData.nodeIdsRespondingToInsert.get(this) - 1;
                        if (newCount) {
                            specialEventData.nodeIdsRespondingToInsert.set(this, newCount);
                        } else {
                            specialEventData.nodeIdsRespondingToInsert.delete(this);
                        }
                        if (!specialEventData.nodeIdsRespondingToInsert.size) {
                            mutationDocument['off' + string.capitalize(mutationNodesProperty)](specialEventData.handler);
                            domData.clean.call(documentElement, specialEventName + 'Data');
                        }
                    }
                }
                return originalRemove.apply(this, arguments);
            };
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-util@3.10.12#dom/events/inserted/inserted*/
define('can-util@3.10.12#dom/events/inserted/inserted', [
    'require',
    'exports',
    'module',
    '../make-mutation-event/make-mutation-event'
], function (require, exports, module) {
    'use strict';
    var makeMutationEvent = require('../make-mutation-event/make-mutation-event');
    makeMutationEvent('inserted', 'addedNodes');
});
/*can-util@3.10.12#dom/attr/attr*/
define('can-util@3.10.12#dom/attr/attr', [
    'require',
    'exports',
    'module',
    '../../js/set-immediate/set-immediate',
    'can-globals/document/document',
    'can-globals/global/global',
    '../is-of-global-document/is-of-global-document',
    '../data/data',
    '../contains/contains',
    '../events/events',
    '../dispatch/dispatch',
    'can-globals/mutation-observer/mutation-observer',
    '../../js/each/each',
    'can-types',
    '../../js/diff/diff',
    '../events/attributes/attributes',
    '../events/inserted/inserted'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var setImmediate = require('../../js/set-immediate/set-immediate');
        var getDocument = require('can-globals/document/document');
        var global = require('can-globals/global/global')();
        var isOfGlobalDocument = require('../is-of-global-document/is-of-global-document');
        var setData = require('../data/data');
        var domContains = require('../contains/contains');
        var domEvents = require('../events/events');
        var domDispatch = require('../dispatch/dispatch');
        var getMutationObserver = require('can-globals/mutation-observer/mutation-observer');
        var each = require('../../js/each/each');
        var types = require('can-types');
        var diff = require('../../js/diff/diff');
        require('../events/attributes/attributes');
        require('../events/inserted/inserted');
        var namespaces = { 'xlink': 'http://www.w3.org/1999/xlink' };
        var formElements = {
                'INPUT': true,
                'TEXTAREA': true,
                'SELECT': true
            }, toString = function (value) {
                if (value == null) {
                    return '';
                } else {
                    return '' + value;
                }
            }, isSVG = function (el) {
                return el.namespaceURI === 'http://www.w3.org/2000/svg';
            }, truthy = function () {
                return true;
            }, getSpecialTest = function (special) {
                return special && special.test || truthy;
            }, propProp = function (prop, obj) {
                obj = obj || {};
                obj.get = function () {
                    return this[prop];
                };
                obj.set = function (value) {
                    if (this[prop] !== value) {
                        this[prop] = value;
                    }
                    return value;
                };
                return obj;
            }, booleanProp = function (prop) {
                return {
                    isBoolean: true,
                    set: function (value) {
                        if (prop in this) {
                            this[prop] = value !== false;
                        } else {
                            this.setAttribute(prop, '');
                        }
                    },
                    remove: function () {
                        this[prop] = false;
                    }
                };
            }, setupMO = function (el, callback) {
                var attrMO = setData.get.call(el, 'attrMO');
                if (!attrMO) {
                    var onMutation = function () {
                        callback.call(el);
                    };
                    var MO = getMutationObserver();
                    if (MO) {
                        var observer = new MO(onMutation);
                        observer.observe(el, {
                            childList: true,
                            subtree: true
                        });
                        setData.set.call(el, 'attrMO', observer);
                    } else {
                        setData.set.call(el, 'attrMO', true);
                        setData.set.call(el, 'canBindingCallback', { onMutation: onMutation });
                    }
                }
            }, _findOptionToSelect = function (parent, value) {
                var child = parent.firstChild;
                while (child) {
                    if (child.nodeName === 'OPTION' && value === child.value) {
                        return child;
                    }
                    if (child.nodeName === 'OPTGROUP') {
                        var groupChild = _findOptionToSelect(child, value);
                        if (groupChild) {
                            return groupChild;
                        }
                    }
                    child = child.nextSibling;
                }
            }, setChildOptions = function (el, value) {
                var option;
                if (value != null) {
                    option = _findOptionToSelect(el, value);
                }
                if (option) {
                    option.selected = true;
                } else {
                    el.selectedIndex = -1;
                }
            }, forEachOption = function (parent, fn) {
                var child = parent.firstChild;
                while (child) {
                    if (child.nodeName === 'OPTION') {
                        fn(child);
                    }
                    if (child.nodeName === 'OPTGROUP') {
                        forEachOption(child, fn);
                    }
                    child = child.nextSibling;
                }
            }, collectSelectedOptions = function (parent) {
                var selectedValues = [];
                forEachOption(parent, function (option) {
                    if (option.selected) {
                        selectedValues.push(option.value);
                    }
                });
                return selectedValues;
            }, markSelectedOptions = function (parent, values) {
                forEachOption(parent, function (option) {
                    option.selected = values.indexOf(option.value) !== -1;
                });
            }, setChildOptionsOnChange = function (select, aEL) {
                var handler = setData.get.call(select, 'attrSetChildOptions');
                if (handler) {
                    return Function.prototype;
                }
                handler = function () {
                    setChildOptions(select, select.value);
                };
                setData.set.call(select, 'attrSetChildOptions', handler);
                aEL.call(select, 'change', handler);
                return function (rEL) {
                    setData.clean.call(select, 'attrSetChildOptions');
                    rEL.call(select, 'change', handler);
                };
            }, attr = {
                special: {
                    checked: {
                        get: function () {
                            return this.checked;
                        },
                        set: function (val) {
                            var notFalse = !!val || val === '' || arguments.length === 0;
                            this.checked = notFalse;
                            if (notFalse && this.type === 'radio') {
                                this.defaultChecked = true;
                            }
                            return val;
                        },
                        remove: function () {
                            this.checked = false;
                        },
                        test: function () {
                            return this.nodeName === 'INPUT';
                        }
                    },
                    'class': {
                        get: function () {
                            if (isSVG(this)) {
                                return this.getAttribute('class');
                            }
                            return this.className;
                        },
                        set: function (val) {
                            val = val || '';
                            if (isSVG(this)) {
                                this.setAttribute('class', '' + val);
                            } else {
                                this.className = val;
                            }
                            return val;
                        }
                    },
                    disabled: booleanProp('disabled'),
                    focused: {
                        get: function () {
                            return this === document.activeElement;
                        },
                        set: function (val) {
                            var cur = attr.get(this, 'focused');
                            var docEl = this.ownerDocument.documentElement;
                            var element = this;
                            function focusTask() {
                                if (val) {
                                    element.focus();
                                } else {
                                    element.blur();
                                }
                            }
                            if (cur !== val) {
                                if (!domContains.call(docEl, element)) {
                                    var initialSetHandler = function () {
                                        domEvents.removeEventListener.call(element, 'inserted', initialSetHandler);
                                        focusTask();
                                    };
                                    domEvents.addEventListener.call(element, 'inserted', initialSetHandler);
                                } else {
                                    types.queueTask([
                                        focusTask,
                                        this,
                                        []
                                    ]);
                                }
                            }
                            return !!val;
                        },
                        addEventListener: function (eventName, handler, aEL) {
                            aEL.call(this, 'focus', handler);
                            aEL.call(this, 'blur', handler);
                            return function (rEL) {
                                rEL.call(this, 'focus', handler);
                                rEL.call(this, 'blur', handler);
                            };
                        },
                        test: function () {
                            return this.nodeName === 'INPUT';
                        }
                    },
                    'for': propProp('htmlFor'),
                    innertext: propProp('innerText'),
                    innerhtml: propProp('innerHTML'),
                    innerHTML: propProp('innerHTML', {
                        addEventListener: function (eventName, handler, aEL) {
                            var handlers = [];
                            var el = this;
                            each([
                                'change',
                                'blur'
                            ], function (eventName) {
                                var localHandler = function () {
                                    handler.apply(this, arguments);
                                };
                                domEvents.addEventListener.call(el, eventName, localHandler);
                                handlers.push([
                                    eventName,
                                    localHandler
                                ]);
                            });
                            return function (rEL) {
                                each(handlers, function (info) {
                                    rEL.call(el, info[0], info[1]);
                                });
                            };
                        }
                    }),
                    required: booleanProp('required'),
                    readonly: booleanProp('readOnly'),
                    selected: {
                        get: function () {
                            return this.selected;
                        },
                        set: function (val) {
                            val = !!val;
                            setData.set.call(this, 'lastSetValue', val);
                            return this.selected = val;
                        },
                        addEventListener: function (eventName, handler, aEL) {
                            var option = this;
                            var select = this.parentNode;
                            var lastVal = option.selected;
                            var localHandler = function (changeEvent) {
                                var curVal = option.selected;
                                lastVal = setData.get.call(option, 'lastSetValue') || lastVal;
                                if (curVal !== lastVal) {
                                    lastVal = curVal;
                                    domDispatch.call(option, eventName);
                                }
                            };
                            var removeChangeHandler = setChildOptionsOnChange(select, aEL);
                            domEvents.addEventListener.call(select, 'change', localHandler);
                            aEL.call(option, eventName, handler);
                            return function (rEL) {
                                removeChangeHandler(rEL);
                                domEvents.removeEventListener.call(select, 'change', localHandler);
                                rEL.call(option, eventName, handler);
                            };
                        },
                        test: function () {
                            return this.nodeName === 'OPTION' && this.parentNode && this.parentNode.nodeName === 'SELECT';
                        }
                    },
                    src: {
                        set: function (val) {
                            if (val == null || val === '') {
                                this.removeAttribute('src');
                                return null;
                            } else {
                                this.setAttribute('src', val);
                                return val;
                            }
                        }
                    },
                    style: {
                        set: function () {
                            var el = global.document && getDocument().createElement('div');
                            if (el && el.style && 'cssText' in el.style) {
                                return function (val) {
                                    return this.style.cssText = val || '';
                                };
                            } else {
                                return function (val) {
                                    return this.setAttribute('style', val);
                                };
                            }
                        }()
                    },
                    textcontent: propProp('textContent'),
                    value: {
                        get: function () {
                            var value = this.value;
                            if (this.nodeName === 'SELECT') {
                                if ('selectedIndex' in this && this.selectedIndex === -1) {
                                    value = undefined;
                                }
                            }
                            return value;
                        },
                        set: function (value) {
                            var nodeName = this.nodeName.toLowerCase();
                            if (nodeName === 'input') {
                                value = toString(value);
                            }
                            if (this.value !== value || nodeName === 'option') {
                                this.value = value;
                            }
                            if (attr.defaultValue[nodeName]) {
                                this.defaultValue = value;
                            }
                            if (nodeName === 'select') {
                                setData.set.call(this, 'attrValueLastVal', value);
                                setChildOptions(this, value === null ? value : this.value);
                                var docEl = this.ownerDocument.documentElement;
                                if (!domContains.call(docEl, this)) {
                                    var select = this;
                                    var initialSetHandler = function () {
                                        domEvents.removeEventListener.call(select, 'inserted', initialSetHandler);
                                        setChildOptions(select, value === null ? value : select.value);
                                    };
                                    domEvents.addEventListener.call(this, 'inserted', initialSetHandler);
                                }
                                setupMO(this, function () {
                                    var value = setData.get.call(this, 'attrValueLastVal');
                                    attr.set(this, 'value', value);
                                    domDispatch.call(this, 'change');
                                });
                            }
                            return value;
                        },
                        test: function () {
                            return formElements[this.nodeName];
                        }
                    },
                    values: {
                        get: function () {
                            return collectSelectedOptions(this);
                        },
                        set: function (values) {
                            values = values || [];
                            markSelectedOptions(this, values);
                            setData.set.call(this, 'stickyValues', attr.get(this, 'values'));
                            setupMO(this, function () {
                                var previousValues = setData.get.call(this, 'stickyValues');
                                attr.set(this, 'values', previousValues);
                                var currentValues = setData.get.call(this, 'stickyValues');
                                var changes = diff(previousValues.slice().sort(), currentValues.slice().sort());
                                if (changes.length) {
                                    domDispatch.call(this, 'values');
                                }
                            });
                            return values;
                        },
                        addEventListener: function (eventName, handler, aEL) {
                            var localHandler = function () {
                                domDispatch.call(this, 'values');
                            };
                            domEvents.addEventListener.call(this, 'change', localHandler);
                            aEL.call(this, eventName, handler);
                            return function (rEL) {
                                domEvents.removeEventListener.call(this, 'change', localHandler);
                                rEL.call(this, eventName, handler);
                            };
                        }
                    }
                },
                defaultValue: {
                    input: true,
                    textarea: true
                },
                setAttrOrProp: function (el, attrName, val) {
                    attrName = attrName.toLowerCase();
                    var special = attr.special[attrName];
                    if (special && special.isBoolean && !val) {
                        this.remove(el, attrName);
                    } else {
                        this.set(el, attrName, val);
                    }
                },
                set: function (el, attrName, val) {
                    var usingMutationObserver = isOfGlobalDocument(el) && getMutationObserver();
                    attrName = attrName.toLowerCase();
                    var oldValue;
                    if (!usingMutationObserver) {
                        oldValue = attr.get(el, attrName);
                    }
                    var newValue;
                    var special = attr.special[attrName];
                    var setter = special && special.set;
                    var test = getSpecialTest(special);
                    if (typeof setter === 'function' && test.call(el)) {
                        if (arguments.length === 2) {
                            newValue = setter.call(el);
                        } else {
                            newValue = setter.call(el, val);
                        }
                    } else {
                        attr.setAttribute(el, attrName, val);
                    }
                    if (!usingMutationObserver && newValue !== oldValue) {
                        attr.trigger(el, attrName, oldValue);
                    }
                },
                setSelectValue: function (el, value) {
                    attr.set(el, 'value', value);
                },
                setAttribute: function () {
                    var doc = getDocument();
                    if (doc && document.createAttribute) {
                        try {
                            doc.createAttribute('{}');
                        } catch (e) {
                            var invalidNodes = {}, attributeDummy = document.createElement('div');
                            return function (el, attrName, val) {
                                var first = attrName.charAt(0), cachedNode, node, attr;
                                if ((first === '{' || first === '(' || first === '*') && el.setAttributeNode) {
                                    cachedNode = invalidNodes[attrName];
                                    if (!cachedNode) {
                                        attributeDummy.innerHTML = '<div ' + attrName + '=""></div>';
                                        cachedNode = invalidNodes[attrName] = attributeDummy.childNodes[0].attributes[0];
                                    }
                                    node = cachedNode.cloneNode();
                                    node.value = val;
                                    el.setAttributeNode(node);
                                } else {
                                    attr = attrName.split(':');
                                    if (attr.length !== 1 && namespaces[attr[0]]) {
                                        el.setAttributeNS(namespaces[attr[0]], attrName, val);
                                    } else {
                                        el.setAttribute(attrName, val);
                                    }
                                }
                            };
                        }
                    }
                    return function (el, attrName, val) {
                        el.setAttribute(attrName, val);
                    };
                }(),
                trigger: function (el, attrName, oldValue) {
                    if (setData.get.call(el, 'canHasAttributesBindings')) {
                        attrName = attrName.toLowerCase();
                        return setImmediate(function () {
                            domDispatch.call(el, {
                                type: 'attributes',
                                attributeName: attrName,
                                target: el,
                                oldValue: oldValue,
                                bubbles: false
                            }, []);
                        });
                    }
                },
                get: function (el, attrName) {
                    attrName = attrName.toLowerCase();
                    var special = attr.special[attrName];
                    var getter = special && special.get;
                    var test = getSpecialTest(special);
                    if (typeof getter === 'function' && test.call(el)) {
                        return getter.call(el);
                    } else {
                        return el.getAttribute(attrName);
                    }
                },
                remove: function (el, attrName) {
                    attrName = attrName.toLowerCase();
                    var oldValue;
                    if (!getMutationObserver()) {
                        oldValue = attr.get(el, attrName);
                    }
                    var special = attr.special[attrName];
                    var setter = special && special.set;
                    var remover = special && special.remove;
                    var test = getSpecialTest(special);
                    if (typeof remover === 'function' && test.call(el)) {
                        remover.call(el);
                    } else if (typeof setter === 'function' && test.call(el)) {
                        setter.call(el, undefined);
                    } else {
                        el.removeAttribute(attrName);
                    }
                    if (!getMutationObserver() && oldValue != null) {
                        attr.trigger(el, attrName, oldValue);
                    }
                },
                has: function () {
                    var el = getDocument() && document.createElement('div');
                    if (el && el.hasAttribute) {
                        return function (el, name) {
                            return el.hasAttribute(name);
                        };
                    } else {
                        return function (el, name) {
                            return el.getAttribute(name) !== null;
                        };
                    }
                }()
            };
        var oldAddEventListener = domEvents.addEventListener;
        domEvents.addEventListener = function (eventName, handler) {
            var special = attr.special[eventName];
            if (special && special.addEventListener) {
                var teardown = special.addEventListener.call(this, eventName, handler, oldAddEventListener);
                var teardowns = setData.get.call(this, 'attrTeardowns');
                if (!teardowns) {
                    setData.set.call(this, 'attrTeardowns', teardowns = {});
                }
                if (!teardowns[eventName]) {
                    teardowns[eventName] = [];
                }
                teardowns[eventName].push({
                    teardown: teardown,
                    handler: handler
                });
                return;
            }
            return oldAddEventListener.apply(this, arguments);
        };
        var oldRemoveEventListener = domEvents.removeEventListener;
        domEvents.removeEventListener = function (eventName, handler) {
            var special = attr.special[eventName];
            if (special && special.addEventListener) {
                var teardowns = setData.get.call(this, 'attrTeardowns');
                if (teardowns && teardowns[eventName]) {
                    var eventTeardowns = teardowns[eventName];
                    for (var i = 0, len = eventTeardowns.length; i < len; i++) {
                        if (eventTeardowns[i].handler === handler) {
                            eventTeardowns[i].teardown.call(this, oldRemoveEventListener);
                            eventTeardowns.splice(i, 1);
                            break;
                        }
                    }
                    if (eventTeardowns.length === 0) {
                        delete teardowns[eventName];
                    }
                }
                return;
            }
            return oldRemoveEventListener.apply(this, arguments);
        };
        module.exports = exports = attr;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-view-target@3.1.4#can-view-target*/
define('can-view-target@3.1.4#can-view-target', [
    'require',
    'exports',
    'module',
    'can-util/dom/child-nodes/child-nodes',
    'can-util/dom/attr/attr',
    'can-util/js/each/each',
    'can-util/js/make-array/make-array',
    'can-util/dom/document/document',
    'can-util/dom/mutate/mutate',
    'can-namespace',
    'can-globals/mutation-observer/mutation-observer'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var childNodes = require('can-util/dom/child-nodes/child-nodes');
        var domAttr = require('can-util/dom/attr/attr');
        var each = require('can-util/js/each/each');
        var makeArray = require('can-util/js/make-array/make-array');
        var getDocument = require('can-util/dom/document/document');
        var domMutate = require('can-util/dom/mutate/mutate');
        var namespace = require('can-namespace');
        var MUTATION_OBSERVER = require('can-globals/mutation-observer/mutation-observer');
        var processNodes = function (nodes, paths, location, document) {
                var frag = document.createDocumentFragment();
                for (var i = 0, len = nodes.length; i < len; i++) {
                    var node = nodes[i];
                    frag.appendChild(processNode(node, paths, location.concat(i), document));
                }
                return frag;
            }, keepsTextNodes = typeof document !== 'undefined' && function () {
                var testFrag = document.createDocumentFragment();
                var div = document.createElement('div');
                div.appendChild(document.createTextNode(''));
                div.appendChild(document.createTextNode(''));
                testFrag.appendChild(div);
                var cloned = testFrag.cloneNode(true);
                return childNodes(cloned.firstChild).length === 2;
            }(), clonesWork = typeof document !== 'undefined' && function () {
                var el = document.createElement('a');
                el.innerHTML = '<xyz></xyz>';
                var clone = el.cloneNode(true);
                var works = clone.innerHTML === '<xyz></xyz>';
                var MO, observer;
                if (works) {
                    el = document.createDocumentFragment();
                    el.appendChild(document.createTextNode('foo-bar'));
                    MO = MUTATION_OBSERVER();
                    if (MO) {
                        observer = new MO(function () {
                        });
                        observer.observe(document.documentElement, {
                            childList: true,
                            subtree: true
                        });
                        clone = el.cloneNode(true);
                        observer.disconnect();
                    } else {
                        clone = el.cloneNode(true);
                    }
                    return clone.childNodes.length === 1;
                }
                return works;
            }(), namespacesWork = typeof document !== 'undefined' && !!document.createElementNS;
        var cloneNode = clonesWork ? function (el) {
            return el.cloneNode(true);
        } : function (node) {
            var document = node.ownerDocument;
            var copy;
            if (node.nodeType === 1) {
                if (node.namespaceURI !== 'http://www.w3.org/1999/xhtml' && namespacesWork && document.createElementNS) {
                    copy = document.createElementNS(node.namespaceURI, node.nodeName);
                } else {
                    copy = document.createElement(node.nodeName);
                }
            } else if (node.nodeType === 3) {
                copy = document.createTextNode(node.nodeValue);
            } else if (node.nodeType === 8) {
                copy = document.createComment(node.nodeValue);
            } else if (node.nodeType === 11) {
                copy = document.createDocumentFragment();
            }
            if (node.attributes) {
                var attributes = makeArray(node.attributes);
                each(attributes, function (node) {
                    if (node && node.specified) {
                        domAttr.setAttribute(copy, node.nodeName || node.name, node.nodeValue || node.value);
                    }
                });
            }
            if (node && node.firstChild) {
                var child = node.firstChild;
                while (child) {
                    copy.appendChild(cloneNode(child));
                    child = child.nextSibling;
                }
            }
            return copy;
        };
        function processNode(node, paths, location, document) {
            var callback, loc = location, nodeType = typeof node, el, p, i, len;
            var getCallback = function () {
                if (!callback) {
                    callback = {
                        path: location,
                        callbacks: []
                    };
                    paths.push(callback);
                    loc = [];
                }
                return callback;
            };
            if (nodeType === 'object') {
                if (node.tag) {
                    if (namespacesWork && node.namespace) {
                        el = document.createElementNS(node.namespace, node.tag);
                    } else {
                        el = document.createElement(node.tag);
                    }
                    if (node.attrs) {
                        for (var attrName in node.attrs) {
                            var value = node.attrs[attrName];
                            if (typeof value === 'function') {
                                getCallback().callbacks.push({ callback: value });
                            } else {
                                domAttr.setAttribute(el, attrName, value);
                            }
                        }
                    }
                    if (node.attributes) {
                        for (i = 0, len = node.attributes.length; i < len; i++) {
                            getCallback().callbacks.push({ callback: node.attributes[i] });
                        }
                    }
                    if (node.children && node.children.length) {
                        if (callback) {
                            p = callback.paths = [];
                        } else {
                            p = paths;
                        }
                        el.appendChild(processNodes(node.children, p, loc, document));
                    }
                } else if (node.comment) {
                    el = document.createComment(node.comment);
                    if (node.callbacks) {
                        for (i = 0, len = node.attributes.length; i < len; i++) {
                            getCallback().callbacks.push({ callback: node.callbacks[i] });
                        }
                    }
                }
            } else if (nodeType === 'string') {
                el = document.createTextNode(node);
            } else if (nodeType === 'function') {
                if (keepsTextNodes) {
                    el = document.createTextNode('');
                    getCallback().callbacks.push({ callback: node });
                } else {
                    el = document.createComment('~');
                    getCallback().callbacks.push({
                        callback: function () {
                            var el = document.createTextNode('');
                            domMutate.replaceChild.call(this.parentNode, el, this);
                            return node.apply(el, arguments);
                        }
                    });
                }
            }
            return el;
        }
        function getCallbacks(el, pathData, elementCallbacks) {
            var path = pathData.path, callbacks = pathData.callbacks, paths = pathData.paths, child = el, pathLength = path ? path.length : 0, pathsLength = paths ? paths.length : 0;
            for (var i = 0; i < pathLength; i++) {
                child = child.childNodes.item(path[i]);
            }
            for (i = 0; i < pathsLength; i++) {
                getCallbacks(child, paths[i], elementCallbacks);
            }
            elementCallbacks.push({
                element: child,
                callbacks: callbacks
            });
        }
        function hydrateCallbacks(callbacks, args) {
            var len = callbacks.length, callbacksLength, callbackElement, callbackData;
            for (var i = 0; i < len; i++) {
                callbackData = callbacks[i];
                callbacksLength = callbackData.callbacks.length;
                callbackElement = callbackData.element;
                for (var c = 0; c < callbacksLength; c++) {
                    callbackData.callbacks[c].callback.apply(callbackElement, args);
                }
            }
        }
        function makeTarget(nodes, doc) {
            var paths = [];
            var frag = processNodes(nodes, paths, [], doc || getDocument());
            return {
                paths: paths,
                clone: frag,
                hydrate: function () {
                    var cloned = cloneNode(this.clone);
                    var args = makeArray(arguments);
                    var callbacks = [];
                    for (var i = 0; i < paths.length; i++) {
                        getCallbacks(cloned, paths[i], callbacks);
                    }
                    hydrateCallbacks(callbacks, args);
                    return cloned;
                }
            };
        }
        makeTarget.keepsTextNodes = keepsTextNodes;
        makeTarget.cloneNode = cloneNode;
        namespace.view = namespace.view || {};
        module.exports = namespace.view.target = makeTarget;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-observation@4.0.0-pre.17#recorder-dependency-helpers*/
define('can-observation@4.0.0-pre.17#recorder-dependency-helpers', [
    'require',
    'exports',
    'module',
    'can-reflect'
], function (require, exports, module) {
    var canReflect = require('can-reflect');
    function removeEdge(event) {
        canReflect.offKeyValue(this.observable, event, this.onDependencyChange, 'notify');
    }
    function removeEdges(oldEventSet, observable) {
        oldEventSet.forEach(removeEdge, {
            onDependencyChange: this.onDependencyChange,
            observable: observable
        });
    }
    function addEdgeIfNotInOldSet(event) {
        if (!this.oldEventSet || !this.oldEventSet['delete'](event)) {
            canReflect.onKeyValue(this.observable, event, this.onDependencyChange, 'notify');
        }
    }
    function addEdges(eventSet, observable) {
        eventSet.forEach(addEdgeIfNotInOldSet, {
            onDependencyChange: this.onDependencyChange,
            observable: observable,
            oldEventSet: this.oldDependencies.keyDependencies.get(observable)
        });
    }
    function addValueDependencies(observable) {
        if (!this.oldDependencies.valueDependencies.delete(observable)) {
            canReflect.onValue(observable, this.onDependencyChange, 'notify');
        }
    }
    function removeValueDependencies(observable) {
        canReflect.offValue(observable, this.onDependencyChange, 'notify');
    }
    module.exports = {
        updateObservations: function (observationData) {
            observationData.newDependencies.keyDependencies.forEach(addEdges, observationData);
            observationData.oldDependencies.keyDependencies.forEach(removeEdges, observationData);
            observationData.newDependencies.valueDependencies.forEach(addValueDependencies, observationData);
            observationData.oldDependencies.valueDependencies.forEach(removeValueDependencies, observationData);
        },
        stopObserving: function (observationReciever, onDependencyChange) {
            observationReciever.keyDependencies.forEach(removeEdges, { onDependencyChange: onDependencyChange });
            observationReciever.valueDependencies.forEach(removeValueDependencies, { onDependencyChange: onDependencyChange });
        }
    };
});
/*can-observation@4.0.0-pre.17#can-observation*/
define('can-observation@4.0.0-pre.17#can-observation', [
    'require',
    'exports',
    'module',
    'can-util/js/assign/assign',
    'can-namespace',
    'can-reflect',
    'can-queues',
    'can-key-tree',
    'can-observation-recorder',
    './recorder-dependency-helpers',
    'can-symbol',
    'can-log/dev/dev'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var assign = require('can-util/js/assign/assign');
        var namespace = require('can-namespace');
        var canReflect = require('can-reflect');
        var queues = require('can-queues');
        var KeyTree = require('can-key-tree');
        var ObservationRecorder = require('can-observation-recorder');
        var recorderHelpers = require('./recorder-dependency-helpers');
        var canSymbol = require('can-symbol');
        var dev = require('can-log/dev/dev');
        function Observation(func, context, options) {
            this.func = func;
            this.context = context;
            this.options = options || {
                priority: 0,
                isObservable: true
            };
            this.newDependencies = ObservationRecorder.makeDependenciesRecorder();
            this.oldDependencies = null;
            this.handlers = new KeyTree([
                Object,
                Array
            ], {
                onFirst: this.start.bind(this),
                onEmpty: this.stop.bind(this)
            });
            this.bound = false;
            var self = this;
            this.onDependencyChange = function (newVal) {
                self.dependencyChange(this, newVal);
            };
            this.update = this.update.bind(this);
        }
        assign(Observation.prototype, {
            get: function () {
                if (this.options.isObservable && Observation.isRecording()) {
                    ObservationRecorder.add(this);
                    if (!this.bound) {
                        Observation.temporarilyBind(this);
                    }
                }
                if (this.bound === true) {
                    if (queues.deriveQueue.tasksRemainingCount() > 0) {
                        Observation.updateChildrenAndSelf(this);
                    }
                    return this.value;
                } else {
                    return this.func.call(this.context);
                }
            },
            dependencyChange: function (context, args) {
                if (this.bound === true) {
                    queues.deriveQueue.enqueue(this.update, this, [], { priority: this.options.priority });
                }
            },
            update: function () {
                if (this.bound === true) {
                    var oldValue = this.value;
                    this.oldValue = null;
                    this.start();
                    if (oldValue !== this.value) {
                        queues.enqueueByQueue(this.handlers.getNode([]), this, [
                            this.value,
                            oldValue
                        ], null, [
                            canReflect.getName(this),
                            'changed to',
                            this.value,
                            'from',
                            oldValue
                        ]);
                        return true;
                    }
                }
            },
            start: function () {
                this.bound = true;
                this.oldDependencies = this.newDependencies;
                ObservationRecorder.start();
                this.value = this.func.call(this.context);
                this.newDependencies = ObservationRecorder.stop();
                recorderHelpers.updateObservations(this);
            },
            stop: function () {
                this.bound = false;
                recorderHelpers.stopObserving(this.newDependencies, this.onDependencyChange);
                this.newDependencies = ObservationRecorder.makeDependenciesRecorder();
            },
            hasDependencies: function () {
                var newDependencies = this.newDependencies;
                return this.bound ? newDependencies.valueDependencies.size + newDependencies.keyDependencies.size > 0 : undefined;
            },
            log: function () {
            }
        });
        canReflect.assignSymbols(Observation.prototype, {
            'can.onValue': function (handler, queueName) {
                this.handlers.add([
                    queueName || 'mutate',
                    handler
                ]);
            },
            'can.offValue': function (handler, queueName) {
                this.handlers.delete([
                    queueName || 'mutate',
                    handler
                ]);
            },
            'can.getValue': Observation.prototype.get,
            'can.isValueLike': true,
            'can.isMapLike': false,
            'can.isListLike': false,
            'can.valueHasDependencies': Observation.prototype.hasDependencies,
            'can.getValueDependencies': function () {
                if (this.bound === true) {
                    return this.newDependencies;
                }
                return undefined;
            },
            'can.getPriority': function () {
                return this.options.priority;
            },
            'can.setPriority': function (priority) {
                this.options.priority = priority;
            }
        });
        var getValueDependenciesSymbol = canSymbol.for('can.getValueDependencies');
        Observation.updateChildrenAndSelf = function (observation) {
            if (observation.update && queues.deriveQueue.isEnqueued(observation.update) === true) {
                queues.deriveQueue.flushQueuedTask(observation.update);
                return true;
            }
            if (observation[getValueDependenciesSymbol]) {
                var childHasChanged = false;
                var valueDependencies = observation[getValueDependenciesSymbol]().valueDependencies || [];
                valueDependencies.forEach(function (observable) {
                    if (Observation.updateChildrenAndSelf(observable)) {
                        childHasChanged = true;
                    }
                });
                return childHasChanged;
            } else {
                return false;
            }
        };
        Observation.add = ObservationRecorder.add;
        Observation.addAll = ObservationRecorder.addMany;
        Observation.ignore = ObservationRecorder.ignore;
        Observation.trap = ObservationRecorder.trap;
        Observation.trapsCount = ObservationRecorder.trapsCount;
        Observation.isRecording = ObservationRecorder.isRecording;
        var temporarilyBoundNoOperation = function () {
        };
        var observables;
        var unbindComputes = function () {
            for (var i = 0, len = observables.length; i < len; i++) {
                canReflect.offValue(observables[i], temporarilyBoundNoOperation);
            }
            observables = null;
        };
        Observation.temporarilyBind = function (compute) {
            var computeInstance = compute.computeInstance || compute;
            canReflect.onValue(computeInstance, temporarilyBoundNoOperation);
            if (!observables) {
                observables = [];
                setTimeout(unbindComputes, 10);
            }
            observables.push(computeInstance);
        };
        if (namespace.Observation) {
            throw new Error('You can\'t have two versions of can-observation, check your dependencies');
        } else {
            module.exports = namespace.Observation = Observation;
        }
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-util@3.10.12#js/is-promise-like/is-promise-like*/
define('can-util@3.10.12#js/is-promise-like/is-promise-like', function (require, exports, module) {
    'use strict';
    module.exports = function (obj) {
        return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';
    };
});
/*can-reflect-promise@2.0.0-pre.4#can-reflect-promise*/
define('can-reflect-promise@2.0.0-pre.4#can-reflect-promise', [
    'require',
    'exports',
    'module',
    'can-reflect',
    'can-symbol',
    'can-observation-recorder',
    'can-queues',
    'can-key-tree',
    'can-util/js/dev/dev'
], function (require, exports, module) {
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var ObservationRecorder = require('can-observation-recorder');
    var queues = require('can-queues');
    var KeyTree = require('can-key-tree');
    var dev = require('can-util/js/dev/dev');
    var getKeyValueSymbol = canSymbol.for('can.getKeyValue'), observeDataSymbol = canSymbol.for('can.meta');
    var promiseDataPrototype = {
        isPending: true,
        state: 'pending',
        isResolved: false,
        isRejected: false,
        value: undefined,
        reason: undefined
    };
    function setVirtualProp(promise, property, value) {
        var observeData = promise[observeDataSymbol];
        var old = observeData[property];
        observeData[property] = value;
        queues.enqueueByQueue(observeData.handlers.getNode([property]), promise, [
            value,
            old
        ], function () {
            return {};
        }, [
            'Promise',
            promise,
            'resolved with value',
            value,
            'and changed virtual property: ' + property
        ]);
    }
    function initPromise(promise) {
        var observeData = promise[observeDataSymbol];
        if (!observeData) {
            Object.defineProperty(promise, observeDataSymbol, {
                enumerable: false,
                configurable: false,
                writable: false,
                value: Object.create(promiseDataPrototype)
            });
            observeData = promise[observeDataSymbol];
            observeData.handlers = new KeyTree([
                Object,
                Object,
                Array
            ]);
        }
        promise.then(function (value) {
            queues.batch.start();
            setVirtualProp(promise, 'isPending', false);
            setVirtualProp(promise, 'isResolved', true);
            setVirtualProp(promise, 'value', value);
            setVirtualProp(promise, 'state', 'resolved');
            queues.batch.stop();
        }, function (reason) {
            queues.batch.start();
            setVirtualProp(promise, 'isPending', false);
            setVirtualProp(promise, 'isRejected', true);
            setVirtualProp(promise, 'reason', reason);
            setVirtualProp(promise, 'state', 'rejected');
            queues.batch.stop();
        });
    }
    function setupPromise(value) {
        var oldPromiseFn;
        var proto = 'getPrototypeOf' in Object ? Object.getPrototypeOf(value) : value.__proto__;
        if (value[getKeyValueSymbol] && value[observeDataSymbol]) {
            return;
        }
        if (proto === null || proto === Object.prototype) {
            proto = value;
            if (typeof proto.promise === 'function') {
                oldPromiseFn = proto.promise;
                proto.promise = function () {
                    var result = oldPromiseFn.call(proto);
                    setupPromise(result);
                    return result;
                };
            }
        }
        canReflect.assignSymbols(proto, {
            'can.getKeyValue': function (key) {
                if (!this[observeDataSymbol]) {
                    initPromise(this);
                }
                ObservationRecorder.add(this, key);
                switch (key) {
                case 'state':
                case 'isPending':
                case 'isResolved':
                case 'isRejected':
                case 'value':
                case 'reason':
                    return this[observeDataSymbol][key];
                default:
                    return this[key];
                }
            },
            'can.getValue': function () {
                return this[getKeyValueSymbol]('value');
            },
            'can.isValueLike': false,
            'can.onKeyValue': function (key, handler, queue) {
                if (!this[observeDataSymbol]) {
                    initPromise(this);
                }
                this[observeDataSymbol].handlers.add([
                    key,
                    queue || 'mutate',
                    handler
                ]);
            },
            'can.offKeyValue': function (key, handler, queue) {
                if (!this[observeDataSymbol]) {
                    initPromise(this);
                }
                this[observeDataSymbol].handlers.delete([
                    key,
                    queue || 'mutate',
                    handler
                ]);
            }
        });
    }
    module.exports = setupPromise;
});
/*can-stache-key@1.0.0-pre.8#can-stache-key*/
define('can-stache-key@1.0.0-pre.8#can-stache-key', [
    'require',
    'exports',
    'module',
    'can-observation',
    'can-util/js/dev/dev',
    'can-util/js/each/each',
    'can-symbol',
    'can-reflect',
    'can-util/js/is-promise-like/is-promise-like',
    'can-reflect-promise'
], function (require, exports, module) {
    var Observation = require('can-observation');
    var dev = require('can-util/js/dev/dev');
    var each = require('can-util/js/each/each');
    var canSymbol = require('can-symbol');
    var canReflect = require('can-reflect');
    var isPromiseLike = require('can-util/js/is-promise-like/is-promise-like');
    var canReflectPromise = require('can-reflect-promise');
    var getValueSymbol = canSymbol.for('can.getValue');
    var setValueSymbol = canSymbol.for('can.setValue');
    var isValueLikeSymbol = canSymbol.for('can.isValueLike');
    var peek = Observation.ignore(canReflect.getKeyValue.bind(canReflect));
    var observeReader;
    var isAt = function (index, reads) {
        var prevRead = reads[index - 1];
        return prevRead && prevRead.at;
    };
    var readValue = function (value, index, reads, options, state, prev) {
        var usedValueReader;
        do {
            usedValueReader = false;
            for (var i = 0, len = observeReader.valueReaders.length; i < len; i++) {
                if (observeReader.valueReaders[i].test(value, index, reads, options)) {
                    value = observeReader.valueReaders[i].read(value, index, reads, options, state, prev);
                }
            }
        } while (usedValueReader);
        return value;
    };
    var specialRead = {
        index: true,
        key: true,
        event: true,
        element: true,
        viewModel: true
    };
    var checkForObservableAndNotify = function (options, state, getObserves, value, index) {
        if (options.foundObservable && !state.foundObservable) {
            if (Observation.trapsCount()) {
                Observation.addAll(getObserves());
                options.foundObservable(value, index);
                state.foundObservable = true;
            }
        }
    };
    observeReader = {
        read: function (parent, reads, options) {
            options = options || {};
            var state = { foundObservable: false };
            var getObserves;
            if (options.foundObservable) {
                getObserves = Observation.trap();
            }
            var cur = readValue(parent, 0, reads, options, state), type, prev, readLength = reads.length, i = 0, last;
            checkForObservableAndNotify(options, state, getObserves, parent, 0);
            while (i < readLength) {
                prev = cur;
                for (var r = 0, readersLength = observeReader.propertyReaders.length; r < readersLength; r++) {
                    var reader = observeReader.propertyReaders[r];
                    if (reader.test(cur)) {
                        cur = reader.read(cur, reads[i], i, options, state);
                        break;
                    }
                }
                checkForObservableAndNotify(options, state, getObserves, prev, i);
                last = cur;
                i = i + 1;
                cur = readValue(cur, i, reads, options, state, prev);
                checkForObservableAndNotify(options, state, getObserves, prev, i - 1);
                type = typeof cur;
                if (i < reads.length && (cur === null || cur === undefined)) {
                    if (options.earlyExit) {
                        options.earlyExit(prev, i - 1, cur);
                    }
                    return {
                        value: undefined,
                        parent: prev
                    };
                }
            }
            if (cur === undefined) {
                if (options.earlyExit) {
                    options.earlyExit(prev, i - 1);
                }
            }
            return {
                value: cur,
                parent: prev
            };
        },
        get: function (parent, reads, options) {
            return observeReader.read(parent, observeReader.reads(reads), options || {}).value;
        },
        valueReadersMap: {},
        valueReaders: [
            {
                name: 'function',
                test: function (value) {
                    return value && canReflect.isFunctionLike(value) && !canReflect.isConstructorLike(value);
                },
                read: function (value, i, reads, options, state, prev) {
                    if (isAt(i, reads)) {
                        return i === reads.length ? value.bind(prev) : value;
                    } else if (options.callMethodsOnObservables && canReflect.isObservableLike(prev) && canReflect.isMapLike(prev)) {
                        return value.apply(prev, options.args || []);
                    } else if (options.isArgument && i === reads.length) {
                        return options.proxyMethods !== false ? value.bind(prev) : value;
                    }
                    return value.apply(prev, options.args || []);
                }
            },
            {
                name: 'isValueLike',
                test: function (value, i, reads, options) {
                    return value && value[getValueSymbol] && value[isValueLikeSymbol] !== false && (options.foundAt || !isAt(i, reads));
                },
                read: function (value, i, reads, options) {
                    if (options.readCompute === false && i === reads.length) {
                        return value;
                    }
                    return canReflect.getValue(value);
                },
                write: function (base, newVal) {
                    if (base[setValueSymbol]) {
                        base[setValueSymbol](newVal);
                    } else if (base.set) {
                        base.set(newVal);
                    } else {
                        base(newVal);
                    }
                }
            }
        ],
        propertyReadersMap: {},
        propertyReaders: [
            {
                name: 'map',
                test: function (value) {
                    if (isPromiseLike(value) || typeof value === 'object' && value && typeof value.then === 'function') {
                        canReflectPromise(value);
                    }
                    return canReflect.isObservableLike(value) && canReflect.isMapLike(value);
                },
                read: function (value, prop) {
                    var res = canReflect.getKeyValue(value, prop.key);
                    if (res !== undefined) {
                        return res;
                    } else {
                        return value[prop.key];
                    }
                },
                write: canReflect.setKeyValue
            },
            {
                name: 'object',
                test: function () {
                    return true;
                },
                read: function (value, prop, i, options) {
                    if (value == null) {
                        return undefined;
                    } else {
                        if (typeof value === 'object') {
                            if (prop.key in value) {
                                return value[prop.key];
                            } else if (prop.at && specialRead[prop.key] && '@' + prop.key in value) {
                                options.foundAt = true;
                                return value['@' + prop.key];
                            }
                        } else {
                            return value[prop.key];
                        }
                    }
                },
                write: function (base, prop, newVal) {
                    var propValue = base[prop];
                    if (canReflect.isMapLike(propValue) && newVal && typeof newVal === 'object') {
                        dev.warn('can-stache-key: Merging data into "' + prop + '" because its parent is non-observable');
                        canReflect.update(propValue, newVal);
                    } else if (canReflect.isValueLike(propValue) && canReflect.isObservableLike(propValue)) {
                        canReflect.setValue(propValue, newVal);
                    } else {
                        base[prop] = newVal;
                    }
                }
            }
        ],
        reads: function (keyArg) {
            var key = '' + keyArg;
            var keys = [];
            var last = 0;
            var at = false;
            if (key.charAt(0) === '@') {
                last = 1;
                at = true;
            }
            var keyToAdd = '';
            for (var i = last; i < key.length; i++) {
                var character = key.charAt(i);
                if (character === '.' || character === '@') {
                    if (key.charAt(i - 1) !== '\\') {
                        keys.push({
                            key: keyToAdd,
                            at: at
                        });
                        at = character === '@';
                        keyToAdd = '';
                    } else {
                        keyToAdd = keyToAdd.substr(0, keyToAdd.length - 1) + '.';
                    }
                } else {
                    keyToAdd += character;
                }
            }
            keys.push({
                key: keyToAdd,
                at: at
            });
            return keys;
        },
        write: function (parent, key, value, options) {
            var keys = typeof key === 'string' ? observeReader.reads(key) : key;
            var last;
            options = options || {};
            if (keys.length > 1) {
                last = keys.pop();
                parent = observeReader.read(parent, keys, options).value;
                keys.push(last);
            } else {
                last = keys[0];
            }
            var keyValue = peek(parent, last.key);
            if (observeReader.valueReadersMap.isValueLike.test(keyValue, keys.length - 1, keys, options)) {
                observeReader.valueReadersMap.isValueLike.write(keyValue, value, options);
            } else {
                if (observeReader.valueReadersMap.isValueLike.test(parent, keys.length - 1, keys, options)) {
                    parent = parent[getValueSymbol]();
                }
                if (observeReader.propertyReadersMap.map.test(parent)) {
                    observeReader.propertyReadersMap.map.write(parent, last.key, value, options);
                } else if (observeReader.propertyReadersMap.object.test(parent)) {
                    observeReader.propertyReadersMap.object.write(parent, last.key, value, options);
                    if (options.observation) {
                        options.observation.update();
                    }
                }
            }
        }
    };
    each(observeReader.propertyReaders, function (reader) {
        observeReader.propertyReadersMap[reader.name] = reader;
    });
    each(observeReader.valueReaders, function (reader) {
        observeReader.valueReadersMap[reader.name] = reader;
    });
    observeReader.set = observeReader.write;
    module.exports = observeReader;
});
/*can-view-scope@4.0.0-pre.22#reference-map*/
define('can-view-scope@4.0.0-pre.22#reference-map', [
    'require',
    'exports',
    'module',
    'can-simple-map'
], function (require, exports, module) {
    var SimpleMap = require('can-simple-map');
    var ReferenceMap = SimpleMap.extend({});
    module.exports = ReferenceMap;
});
/*can-util@3.10.12#js/single-reference/single-reference*/
define('can-util@3.10.12#js/single-reference/single-reference', [
    'require',
    'exports',
    'module',
    'can-cid'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var CID = require('can-cid');
        var singleReference;
        function getKeyName(key, extraKey) {
            var keyName = extraKey ? CID(key) + ':' + extraKey : CID(key);
            return keyName || key;
        }
        singleReference = {
            set: function (obj, key, value, extraKey) {
                obj[getKeyName(key, extraKey)] = value;
            },
            getAndDelete: function (obj, key, extraKey) {
                var keyName = getKeyName(key, extraKey);
                var value = obj[keyName];
                delete obj[keyName];
                return value;
            }
        };
        module.exports = singleReference;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-view-scope@4.0.0-pre.22#make-compute-like*/
define('can-view-scope@4.0.0-pre.22#make-compute-like', [
    'require',
    'exports',
    'module',
    'can-util/js/single-reference/single-reference',
    'can-reflect'
], function (require, exports, module) {
    var singleReference = require('can-util/js/single-reference/single-reference');
    var canReflect = require('can-reflect');
    var Compute = function (newVal) {
        if (arguments.length) {
            return canReflect.setValue(this, newVal);
        } else {
            return canReflect.getValue(this);
        }
    };
    module.exports = function (observable) {
        var compute = Compute.bind(observable);
        compute.on = compute.bind = compute.addEventListener = function (event, handler) {
            var translationHandler = function (newVal, oldVal) {
                handler.call(compute, { type: 'change' }, newVal, oldVal);
            };
            singleReference.set(handler, this, translationHandler);
            observable.on(translationHandler);
        };
        compute.off = compute.unbind = compute.removeEventListener = function (event, handler) {
            observable.off(singleReference.getAndDelete(handler, this));
        };
        canReflect.assignSymbols(compute, {
            'can.getValue': function () {
                return canReflect.getValue(observable);
            },
            'can.setValue': function (newVal) {
                return canReflect.setValue(observable, newVal);
            },
            'can.onValue': function (handler, queue) {
                return canReflect.onValue(observable, handler, queue);
            },
            'can.offValue': function (handler, queue) {
                return canReflect.offValue(observable, handler, queue);
            },
            'can.valueHasDependencies': function () {
                return canReflect.valueHasDependencies(observable);
            },
            'can.getPriority': function () {
                return canReflect.getPriority(observable);
            },
            'can.setPriority': function (newPriority) {
                canReflect.setPriority(observable, newPriority);
            },
            'can.isValueLike': true,
            'can.isFunctionLike': false
        });
        compute.isComputed = true;
        return compute;
    };
});
/*can-view-scope@4.0.0-pre.22#compute_data*/
define('can-view-scope@4.0.0-pre.22#compute_data', [
    'require',
    'exports',
    'module',
    'can-observation',
    'can-stache-key',
    'can-util/js/assign/assign',
    'can-reflect',
    'can-symbol',
    'can-key-tree',
    'can-queues',
    'can-observation-recorder',
    'can-cid/set/set',
    './make-compute-like'
], function (require, exports, module) {
    'use strict';
    var Observation = require('can-observation');
    var observeReader = require('can-stache-key');
    var assign = require('can-util/js/assign/assign');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var KeyTree = require('can-key-tree');
    var queues = require('can-queues');
    var ObservationRecorder = require('can-observation-recorder');
    var CIDSet = require('can-cid/set/set');
    var makeComputeLike = require('./make-compute-like');
    var peekValue = ObservationRecorder.ignore(canReflect.getValue.bind(canReflect));
    var getFastPathRoot = ObservationRecorder.ignore(function (computeData) {
        if (computeData.reads && computeData.reads.length === 1) {
            var root = computeData.root;
            if (root && root[canSymbol.for('can.getValue')]) {
                root = canReflect.getValue(root);
            }
            return root && canReflect.isObservableLike(root) && canReflect.isMapLike(root) && typeof root[computeData.reads[0].key] !== 'function' && root;
        }
        return;
    });
    var isEventObject = function (obj) {
        return obj && typeof obj.batchNum === 'number' && typeof obj.type === 'string';
    };
    var ScopeKeyData = function (scope, key, options) {
        this.startingScope = scope;
        this.key = key;
        this.options = assign({ observation: this.observation }, options);
        var observation;
        this.read = this.read.bind(this);
        this.dispatch = this.dispatch.bind(this);
        this.handlers = new KeyTree([
            Object,
            Array
        ], {
            onFirst: this.setup.bind(this),
            onEmpty: this.teardown.bind(this)
        });
        observation = this.observation = new Observation(this.read, this);
        this.fastPath = undefined;
        this.root = undefined;
        this.initialValue = undefined;
        this.reads = undefined;
        this.setRoot = undefined;
        var valueDependencies = new CIDSet();
        valueDependencies.add(observation);
        this.dependencies = { valueDependencies: valueDependencies };
    };
    ScopeKeyData.prototype = {
        constructor: ScopeKeyData,
        dispatch: function (newVal) {
            var old = this.value;
            this.value = newVal;
            queues.enqueueByQueue(this.handlers.getNode([]), this, [
                newVal,
                old
            ], null, [
                canReflect.getName(this),
                'changed to',
                newVal,
                'from',
                old
            ]);
        },
        setup: function () {
            this.bound = true;
            canReflect.onValue(this.observation, this.dispatch, 'notify');
            var fastPathRoot = getFastPathRoot(this);
            if (fastPathRoot) {
                this.toFastPath(fastPathRoot);
            }
            this.value = peekValue(this.observation);
        },
        teardown: function () {
            this.bound = false;
            canReflect.offValue(this.observation, this.dispatch, 'notify');
            this.toSlowPath();
        },
        set: function (newVal) {
            var root = this.root || this.setRoot;
            if (root) {
                observeReader.write(root, this.reads, newVal, this.options);
            } else {
                this.startingScope.set(this.key, newVal, this.options);
            }
        },
        get: function () {
            if (ObservationRecorder.isRecording()) {
                ObservationRecorder.add(this);
                if (!this.bound) {
                    Observation.temporarilyBind(this);
                }
            }
            if (this.bound === true) {
                return this.value;
            } else {
                return this.observation.get();
            }
        },
        on: function (handler, queue) {
            this.handlers.add([
                queue || 'mutate',
                handler
            ]);
        },
        off: function (handler, queue) {
            this.handlers.delete([
                queue || 'mutate',
                handler
            ]);
        },
        toFastPath: function (fastPathRoot) {
            var self = this, observation = this.observation;
            this.fastPath = true;
            observation.dependencyChange = function (target, newVal) {
                if (isEventObject(newVal)) {
                    throw 'no event objects!';
                }
                if (target === fastPathRoot && typeof newVal !== 'function') {
                    this.newVal = newVal;
                } else {
                    self.toSlowPath();
                }
                return Observation.prototype.dependencyChange.apply(this, arguments);
            };
            observation.start = function () {
                this.value = this.newVal;
            };
        },
        toSlowPath: function () {
            this.observation.dependencyChange = Observation.prototype.dependencyChange;
            this.observation.start = Observation.prototype.start;
            this.fastPath = false;
        },
        read: function () {
            if (this.root) {
                return observeReader.read(this.root, this.reads, this.options).value;
            }
            var data = this.startingScope.read(this.key, this.options);
            this.scope = data.scope;
            this.reads = data.reads;
            this.root = data.rootObserve;
            this.setRoot = data.setRoot;
            return this.initialValue = data.value;
        },
        hasDependencies: function () {
            return canReflect.valueHasDependencies(this.observation);
        }
    };
    canReflect.assignSymbols(ScopeKeyData.prototype, {
        'can.getValue': ScopeKeyData.prototype.get,
        'can.setValue': ScopeKeyData.prototype.set,
        'can.onValue': ScopeKeyData.prototype.on,
        'can.offValue': ScopeKeyData.prototype.off,
        'can.valueHasDependencies': ScopeKeyData.prototype.hasDependencies,
        'can.getValueDependencies': function () {
            return this.dependencies;
        },
        'can.getPriority': function () {
            return canReflect.getPriority(this.observation);
        },
        'can.setPriority': function (newPriority) {
            canReflect.setPriority(this.observation, newPriority);
        }
    });
    Object.defineProperty(ScopeKeyData.prototype, 'compute', {
        get: function () {
            var compute = makeComputeLike(this);
            Object.defineProperty(this, 'compute', {
                value: compute,
                writable: false,
                configurable: false
            });
            return compute;
        },
        configurable: true
    });
    module.exports = function (scope, key, options) {
        return new ScopeKeyData(scope, key, options || { args: [] });
    };
});
/*can-util@3.10.12#js/log/log*/
define('can-util@3.10.12#js/log/log', [
    'require',
    'exports',
    'module',
    'can-log'
], function (require, exports, module) {
    'use strict';
    module.exports = require('can-log');
});
/*can-view-scope@4.0.0-pre.22#can-view-scope*/
define('can-view-scope@4.0.0-pre.22#can-view-scope', [
    'require',
    'exports',
    'module',
    'can-stache-key',
    'can-observation',
    './reference-map',
    './compute_data',
    'can-util/js/assign/assign',
    'can-util/js/each/each',
    'can-namespace',
    'can-util/js/dev/dev',
    'can-reflect',
    'can-util/js/log/log'
], function (require, exports, module) {
    var observeReader = require('can-stache-key');
    var Observation = require('can-observation');
    var ReferenceMap = require('./reference-map');
    var makeComputeData = require('./compute_data');
    var assign = require('can-util/js/assign/assign');
    var each = require('can-util/js/each/each');
    var namespace = require('can-namespace');
    var dev = require('can-util/js/dev/dev');
    var canReflect = require('can-reflect');
    var canLog = require('can-util/js/log/log');
    function Scope(context, parent, meta) {
        this._context = context;
        this._parent = parent;
        this._meta = meta || {};
        this.__cache = {};
    }
    assign(Scope, {
        read: observeReader.read,
        Refs: ReferenceMap,
        refsScope: function () {
            return new Scope(new this.Refs());
        },
        keyInfo: function (attr) {
            var info = {};
            info.isDotSlash = attr.substr(0, 2) === './';
            info.isThisDot = attr.substr(0, 5) === 'this.';
            info.isThisAt = attr.substr(0, 5) === 'this@';
            info.isInCurrentContext = info.isDotSlash || info.isThisDot || info.isThisAt;
            info.isInParentContext = attr.substr(0, 3) === '../';
            info.isCurrentContext = attr === '.' || attr === 'this';
            info.isParentContext = attr === '..';
            info.isContextBased = info.isInCurrentContext || info.isInParentContext || info.isCurrentContext || info.isParentContext;
            return info;
        }
    });
    assign(Scope.prototype, {
        add: function (context, meta) {
            if (context !== this._context) {
                return new this.constructor(context, this, meta);
            } else {
                return this;
            }
        },
        read: function (attr, options) {
            if (attr === '%root') {
                return { value: this.getRoot() };
            }
            if (attr === '%scope') {
                return { value: this };
            }
            var keyInfo = Scope.keyInfo(attr);
            if (keyInfo.isContextBased && this._meta.notContext) {
                return this._parent.read(attr, options);
            }
            var currentScopeOnly;
            if (keyInfo.isInCurrentContext) {
                currentScopeOnly = true;
                attr = keyInfo.isDotSlash ? attr.substr(2) : attr.substr(5);
            } else if (keyInfo.isInParentContext || keyInfo.isParentContext) {
                var parent = this._parent;
                while (parent._meta.notContext) {
                    parent = parent._parent;
                }
                if (keyInfo.isParentContext) {
                    return observeReader.read(parent._context, [], options);
                }
                return parent.read(attr.substr(3) || '.', options);
            } else if (keyInfo.isCurrentContext) {
                return observeReader.read(this._context, [], options);
            }
            var keyReads = observeReader.reads(attr);
            if (keyReads[0].key.charAt(0) === '*') {
                return this.getRefs()._read(keyReads, options, true);
            } else {
                return this._read(keyReads, options, currentScopeOnly);
            }
        },
        _read: function (keyReads, options, currentScopeOnly) {
            var currentScope = this, currentContext, undefinedObserves = [], currentObserve, currentReads, setObserveDepth = -1, currentSetReads, currentSetObserve, readOptions = assign({
                    foundObservable: function (observe, nameIndex) {
                        currentObserve = observe;
                        currentReads = keyReads.slice(nameIndex);
                    },
                    earlyExit: function (parentValue, nameIndex) {
                        if (nameIndex > setObserveDepth || nameIndex === setObserveDepth && (typeof parentValue === 'object' && keyReads[nameIndex].key in parentValue)) {
                            currentSetObserve = currentObserve;
                            currentSetReads = currentReads;
                            setObserveDepth = nameIndex;
                        }
                    }
                }, options);
            var isRecording = Observation.isRecording();
            while (currentScope) {
                currentContext = currentScope._context;
                if (currentContext !== null && (typeof currentContext === 'object' || typeof currentContext === 'function')) {
                    var getObserves = Observation.trap();
                    var data = observeReader.read(currentContext, keyReads, readOptions);
                    var observes = getObserves();
                    if (data.value !== undefined) {
                        if (!observes.length && isRecording) {
                            currentObserve = data.parent;
                            currentReads = keyReads.slice(keyReads.length - 1);
                        } else {
                            Observation.addAll(observes);
                        }
                        return {
                            scope: currentScope,
                            rootObserve: currentObserve,
                            value: data.value,
                            reads: currentReads
                        };
                    } else {
                        undefinedObserves.push.apply(undefinedObserves, observes);
                    }
                }
                if (currentScopeOnly) {
                    currentScope = null;
                } else {
                    currentScope = currentScope._parent;
                }
            }
            Observation.addAll(undefinedObserves);
            return {
                setRoot: currentSetObserve,
                reads: currentSetReads,
                value: undefined
            };
        },
        get: function (key, options) {
            options = assign({ isArgument: true }, options);
            var res = this.read(key, options);
            return res.value;
        },
        peek: Observation.ignore(function (key, options) {
            return this.get(key, options);
        }),
        peak: Observation.ignore(function (key, options) {
            return this.peek(key, options);
        }),
        getScope: function (tester) {
            var scope = this;
            while (scope) {
                if (tester(scope)) {
                    return scope;
                }
                scope = scope._parent;
            }
        },
        getContext: function (tester) {
            var res = this.getScope(tester);
            return res && res._context;
        },
        getRefs: function () {
            var lastScope;
            var refScope = this.getScope(function (scope) {
                lastScope = scope;
                return scope._context instanceof Scope.Refs;
            });
            if (!refScope) {
                lastScope._parent = Scope.refsScope();
                refScope = lastScope._parent;
            }
            return refScope;
        },
        getRoot: function () {
            var cur = this, child = this;
            while (cur._parent) {
                child = cur;
                cur = cur._parent;
            }
            if (cur._context instanceof Scope.Refs) {
                cur = child;
            }
            return cur._context;
        },
        set: function (key, value, options) {
            options = options || {};
            var keyInfo = Scope.keyInfo(key);
            if (keyInfo.isCurrentContext) {
                return canReflect.setValue(this._context, value);
            } else if (keyInfo.isInParentContext || keyInfo.isParentContext) {
                var parent = this._parent;
                while (parent._meta.notContext) {
                    parent = parent._parent;
                }
                if (keyInfo.isParentContext) {
                    return canReflect.setValue(parent._context, value);
                }
                return parent.set(key.substr(3) || '.', value, options);
            }
            var dotIndex = key.lastIndexOf('.'), slashIndex = key.lastIndexOf('/'), contextPath, propName;
            if (slashIndex > dotIndex) {
                contextPath = key.substring(0, slashIndex);
                propName = key.substring(slashIndex + 1, key.length);
            } else {
                if (dotIndex !== -1) {
                    contextPath = key.substring(0, dotIndex);
                    propName = key.substring(dotIndex + 1, key.length);
                } else {
                    contextPath = '.';
                    propName = key;
                }
            }
            if (key.charAt(0) === '*') {
                observeReader.write(this.getRefs()._context, key, value, options);
            } else {
                var context = this.read(contextPath, options).value;
                if (context === undefined) {
                    return;
                }
                observeReader.write(context, propName, value, options);
            }
        },
        attr: Observation.ignore(function (key, value, options) {
            canLog.warn('can-view-scope::attr is deprecated, please use peek, get or set');
            options = assign({ isArgument: true }, options);
            if (arguments.length === 2) {
                return this.set(key, value, options);
            } else {
                return this.get(key, options);
            }
        }),
        computeData: function (key, options) {
            return makeComputeData(this, key, options);
        },
        compute: function (key, options) {
            return this.computeData(key, options).compute;
        },
        cloneFromRef: function () {
            var contexts = [];
            var scope = this, context, parent;
            while (scope) {
                context = scope._context;
                if (context instanceof Scope.Refs) {
                    parent = scope._parent;
                    break;
                }
                contexts.unshift(context);
                scope = scope._parent;
            }
            if (parent) {
                each(contexts, function (context) {
                    parent = parent.add(context);
                });
                return parent;
            } else {
                return this;
            }
        }
    });
    function Options(data, parent, meta) {
        if (!data.helpers && !data.partials && !data.tags) {
            data = { helpers: data };
        }
        Scope.call(this, data, parent, meta);
    }
    Options.prototype = new Scope();
    Options.prototype.constructor = Options;
    Scope.Options = Options;
    namespace.view = namespace.view || {};
    module.exports = namespace.view.Scope = Scope;
});
/*can-simple-observable@2.0.0-pre.16#log*/
define('can-simple-observable@2.0.0-pre.16#log', [
    'require',
    'exports',
    'module',
    'can-log/dev/dev',
    'can-reflect'
], function (require, exports, module) {
    var dev = require('can-log/dev/dev');
    var canReflect = require('can-reflect');
    function quoteString(x) {
        return typeof x === 'string' ? JSON.stringify(x) : x;
    }
    module.exports = function log() {
    };
});
/*can-simple-observable@2.0.0-pre.16#can-simple-observable*/
define('can-simple-observable@2.0.0-pre.16#can-simple-observable', [
    'require',
    'exports',
    'module',
    'can-reflect',
    'can-observation-recorder',
    'can-namespace',
    'can-key-tree',
    'can-queues',
    './log'
], function (require, exports, module) {
    var canReflect = require('can-reflect');
    var ObservationRecorder = require('can-observation-recorder');
    var ns = require('can-namespace');
    var KeyTree = require('can-key-tree');
    var queues = require('can-queues');
    var log = require('./log');
    function SimpleObservable(initialValue) {
        this.handlers = new KeyTree([
            Object,
            Array
        ]);
        this.value = initialValue;
    }
    SimpleObservable.prototype = {
        constructor: SimpleObservable,
        get: function () {
            ObservationRecorder.add(this);
            return this.value;
        },
        set: function (value) {
            var old = this.value;
            this.value = value;
            queues.enqueueByQueue(this.handlers.getNode([]), this, [
                value,
                old
            ]);
        },
        on: function (handler, queue) {
            this.handlers.add([
                queue || 'mutate',
                handler
            ]);
        },
        off: function (handler, queue) {
            this.handlers.delete([
                queue || 'mutate',
                handler
            ]);
        },
        log: log
    };
    canReflect.assignSymbols(SimpleObservable.prototype, {
        'can.getValue': SimpleObservable.prototype.get,
        'can.setValue': SimpleObservable.prototype.set,
        'can.onValue': SimpleObservable.prototype.on,
        'can.offValue': SimpleObservable.prototype.off,
        'can.isMapLike': false,
        'can.valueHasDependencies': function () {
            return true;
        }
    });
    module.exports = ns.SimpleObservable = SimpleObservable;
});
/*can-simple-observable@2.0.0-pre.16#settable/settable*/
define('can-simple-observable@2.0.0-pre.16#settable/settable', [
    'require',
    'exports',
    'module',
    'can-reflect',
    'can-observation-recorder',
    '../can-simple-observable',
    'can-observation',
    'can-key-tree',
    'can-queues',
    '../log'
], function (require, exports, module) {
    var canReflect = require('can-reflect');
    var ObservationRecorder = require('can-observation-recorder');
    var SimpleObservable = require('../can-simple-observable');
    var Observation = require('can-observation');
    var KeyTree = require('can-key-tree');
    var queues = require('can-queues');
    var log = require('../log');
    function SettableObservable(fn, context, initialValue) {
        this.handlers = new KeyTree([
            Object,
            Array
        ], {
            onFirst: this.setup.bind(this),
            onEmpty: this.teardown.bind(this)
        });
        this.lastSetValue = new SimpleObservable(initialValue);
        function observe() {
            return fn.call(context, this.lastSetValue.get());
        }
        this.handler = this.handler.bind(this);
        this.observation = new Observation(observe, this);
    }
    var peek = ObservationRecorder.ignore(canReflect.getValue.bind(canReflect));
    SettableObservable.prototype = {
        handler: function (newVal) {
            var old = this.value;
            this.value = newVal;
            queues.enqueueByQueue(this.handlers.getNode([]), this, [
                newVal,
                old
            ], function () {
                return {};
            });
        },
        setup: function () {
            this.bound = true;
            canReflect.onValue(this.observation, this.handler, 'notify');
            this.value = peek(this.observation);
        },
        teardown: function () {
            this.bound = false;
            canReflect.offValue(this.observation, this.handler, 'notify');
        },
        set: function (newVal) {
            if (newVal !== this.lastSetValue.get()) {
                this.lastSetValue.set(newVal);
            }
        },
        get: function () {
            if (ObservationRecorder.isRecording()) {
                ObservationRecorder.add(this);
                if (!this.bound) {
                    Observation.temporarilyBind(this);
                }
            }
            if (this.bound === true) {
                return this.value;
            } else {
                return this.observation.get();
            }
        },
        on: function (handler, queue) {
            this.handlers.add([
                queue || 'mutate',
                handler
            ]);
        },
        off: function (handler, queue) {
            this.handlers.delete([
                queue || 'mutate',
                handler
            ]);
        },
        hasDependencies: function () {
            return canReflect.valueHasDependencies(this.observation);
        },
        getValueDependencies: function () {
            return canReflect.getValueDependencies(this.observation);
        },
        log: log
    };
    SettableObservable.prototype.constructor = SettableObservable;
    canReflect.assignSymbols(SettableObservable.prototype, {
        'can.getValue': SettableObservable.prototype.get,
        'can.setValue': SettableObservable.prototype.set,
        'can.onValue': SettableObservable.prototype.on,
        'can.offValue': SettableObservable.prototype.off,
        'can.isMapLike': false,
        'can.getPriority': function () {
            return canReflect.getPriority(this.observation);
        },
        'can.setPriority': function (newPriority) {
            canReflect.setPriority(this.observation, newPriority);
        },
        'can.valueHasDependencies': SettableObservable.prototype.hasDependencies,
        'can.getValueDependencies': SettableObservable.prototype.getValueDependencies
    });
    module.exports = SettableObservable;
});
/*can-stache@4.0.0-pre.7#src/key-observable*/
define('can-stache@4.0.0-pre.7#src/key-observable', [
    'require',
    'exports',
    'module',
    'can-simple-observable/settable/settable',
    'can-stache-key'
], function (require, exports, module) {
    var SettableObservable = require('can-simple-observable/settable/settable');
    var stacheKey = require('can-stache-key');
    function KeyObservable(root, key) {
        key = '' + key;
        this.key = key;
        this.root = root;
        SettableObservable.call(this, function () {
            return stacheKey.get(this, key);
        }, root);
    }
    KeyObservable.prototype = Object.create(SettableObservable.prototype);
    KeyObservable.prototype.set = function (newVal) {
        stacheKey.set(this.root, this.key, newVal);
    };
    module.exports = KeyObservable;
});
/*can-stache@4.0.0-pre.7#src/utils*/
define('can-stache@4.0.0-pre.7#src/utils', [
    'require',
    'exports',
    'module',
    'can-view-scope',
    'can-observation',
    'can-stache-key',
    'can-reflect',
    './key-observable',
    'can-util/js/is-array-like/is-array-like'
], function (require, exports, module) {
    var Scope = require('can-view-scope');
    var Observation = require('can-observation');
    var observationReader = require('can-stache-key');
    var canReflect = require('can-reflect');
    var KeyObservable = require('./key-observable');
    var isArrayLike = require('can-util/js/is-array-like/is-array-like');
    var Options = Scope.Options;
    var noop = function () {
    };
    module.exports = {
        isArrayLike: isArrayLike,
        emptyHandler: function () {
        },
        jsonParse: function (str) {
            if (str[0] === '\'') {
                return str.substr(1, str.length - 2);
            } else if (str === 'undefined') {
                return undefined;
            } else {
                return JSON.parse(str);
            }
        },
        mixins: {
            last: function () {
                return this.stack[this.stack.length - 1];
            },
            add: function (chars) {
                this.last().add(chars);
            },
            subSectionDepth: function () {
                return this.stack.length - 1;
            }
        },
        convertToScopes: function (helperOptions, scope, options, nodeList, truthyRenderer, falseyRenderer, isStringOnly) {
            helperOptions.fn = truthyRenderer ? this.makeRendererConvertScopes(truthyRenderer, scope, options, nodeList, isStringOnly) : noop;
            helperOptions.inverse = falseyRenderer ? this.makeRendererConvertScopes(falseyRenderer, scope, options, nodeList, isStringOnly) : noop;
            helperOptions.isSection = !!(truthyRenderer || falseyRenderer);
        },
        makeRendererConvertScopes: function (renderer, parentScope, parentOptions, nodeList, observeObservables) {
            var rendererWithScope = function (ctx, opts, parentNodeList) {
                return renderer(ctx || parentScope, opts, parentNodeList);
            };
            var convertedRenderer = function (newScope, newOptions, parentNodeList) {
                if (newScope !== undefined && !(newScope instanceof Scope)) {
                    if (parentScope) {
                        newScope = parentScope.add(newScope);
                    } else {
                        newScope = Scope.refsScope().add(newScope || {});
                    }
                }
                if (newOptions !== undefined && !(newOptions instanceof Options)) {
                    newOptions = parentOptions.add(newOptions);
                }
                var result = rendererWithScope(newScope, newOptions || parentOptions, parentNodeList || nodeList);
                return result;
            };
            return observeObservables ? convertedRenderer : Observation.ignore(convertedRenderer);
        },
        getItemsStringContent: function (items, isObserveList, helperOptions, options) {
            var txt = '', len = observationReader.get(items, 'length'), isObservable = canReflect.isObservableLike(items);
            for (var i = 0; i < len; i++) {
                var item = isObservable ? new KeyObservable(items, i) : items[i];
                txt += helperOptions.fn(item, options);
            }
            return txt;
        },
        getItemsFragContent: function (items, helperOptions, scope, asVariable) {
            var result = [], len = observationReader.get(items, 'length'), isObservable = canReflect.isObservableLike(items);
            for (var i = 0; i < len; i++) {
                var aliases = { '%index': i };
                var item = isObservable ? new KeyObservable(items, i) : items[i];
                if (asVariable) {
                    aliases[asVariable] = item;
                }
                result.push(helperOptions.fn(scope.add(aliases, { notContext: true }).add(item)));
            }
            return result;
        },
        Options: Options
    };
});
/*can-util@3.10.12#js/cid-map/cid-map*/
define('can-util@3.10.12#js/cid-map/cid-map', [
    'require',
    'exports',
    'module',
    'can-cid/map/map'
], function (require, exports, module) {
    'use strict';
    module.exports = require('can-cid/map/map');
});
/*can-view-nodelist@3.1.0#can-view-nodelist*/
define('can-view-nodelist@3.1.0#can-view-nodelist', [
    'require',
    'exports',
    'module',
    'can-util/js/make-array/make-array',
    'can-util/js/each/each',
    'can-namespace',
    'can-util/dom/mutate/mutate',
    'can-util/js/cid-map/cid-map'
], function (require, exports, module) {
    var makeArray = require('can-util/js/make-array/make-array');
    var each = require('can-util/js/each/each');
    var namespace = require('can-namespace');
    var domMutate = require('can-util/dom/mutate/mutate');
    var CIDMap = require('can-util/js/cid-map/cid-map');
    var nodeMap = new CIDMap(), splice = [].splice, push = [].push, itemsInChildListTree = function (list) {
            var count = 0;
            for (var i = 0, len = list.length; i < len; i++) {
                var item = list[i];
                if (item.nodeType) {
                    count++;
                } else {
                    count += itemsInChildListTree(item);
                }
            }
            return count;
        }, replacementMap = function (replacements) {
            var map = new CIDMap();
            for (var i = 0, len = replacements.length; i < len; i++) {
                var node = nodeLists.first(replacements[i]);
                map.set(node, replacements[i]);
            }
            return map;
        }, addUnfoundAsDeepChildren = function (list, rMap) {
            rMap.forEach(function (replacement) {
                list.newDeepChildren.push(replacement);
            });
        };
    var nodeLists = {
        update: function (nodeList, newNodes) {
            var oldNodes = nodeLists.unregisterChildren(nodeList);
            newNodes = makeArray(newNodes);
            var oldListLength = nodeList.length;
            splice.apply(nodeList, [
                0,
                oldListLength
            ].concat(newNodes));
            if (nodeList.replacements) {
                nodeLists.nestReplacements(nodeList);
                nodeList.deepChildren = nodeList.newDeepChildren;
                nodeList.newDeepChildren = [];
            } else {
                nodeLists.nestList(nodeList);
            }
            return oldNodes;
        },
        nestReplacements: function (list) {
            var index = 0, rMap = replacementMap(list.replacements), rCount = list.replacements.length;
            while (index < list.length && rCount) {
                var node = list[index], replacement = rMap.get(node);
                if (replacement) {
                    rMap['delete'](node);
                    list.splice(index, itemsInChildListTree(replacement), replacement);
                    rCount--;
                }
                index++;
            }
            if (rCount) {
                addUnfoundAsDeepChildren(list, rMap);
            }
            list.replacements = [];
        },
        nestList: function (list) {
            var index = 0;
            while (index < list.length) {
                var node = list[index], childNodeList = nodeMap.get(node);
                if (childNodeList) {
                    if (childNodeList !== list) {
                        list.splice(index, itemsInChildListTree(childNodeList), childNodeList);
                    }
                } else {
                    nodeMap.set(node, list);
                }
                index++;
            }
        },
        last: function (nodeList) {
            var last = nodeList[nodeList.length - 1];
            if (last.nodeType) {
                return last;
            } else {
                return nodeLists.last(last);
            }
        },
        first: function (nodeList) {
            var first = nodeList[0];
            if (first.nodeType) {
                return first;
            } else {
                return nodeLists.first(first);
            }
        },
        flatten: function (nodeList) {
            var items = [];
            for (var i = 0; i < nodeList.length; i++) {
                var item = nodeList[i];
                if (item.nodeType) {
                    items.push(item);
                } else {
                    items.push.apply(items, nodeLists.flatten(item));
                }
            }
            return items;
        },
        register: function (nodeList, unregistered, parent, directlyNested) {
            nodeList.unregistered = unregistered;
            nodeList.parentList = parent;
            nodeList.nesting = parent && typeof parent.nesting !== 'undefined' ? parent.nesting + 1 : 0;
            if (parent) {
                nodeList.deepChildren = [];
                nodeList.newDeepChildren = [];
                nodeList.replacements = [];
                if (parent !== true) {
                    if (directlyNested) {
                        parent.replacements.push(nodeList);
                    } else {
                        parent.newDeepChildren.push(nodeList);
                    }
                }
            } else {
                nodeLists.nestList(nodeList);
            }
            return nodeList;
        },
        unregisterChildren: function (nodeList) {
            var nodes = [];
            each(nodeList, function (node) {
                if (node.nodeType) {
                    if (!nodeList.replacements) {
                        nodeMap['delete'](node);
                    }
                    nodes.push(node);
                } else {
                    push.apply(nodes, nodeLists.unregister(node, true));
                }
            });
            each(nodeList.deepChildren, function (nodeList) {
                nodeLists.unregister(nodeList, true);
            });
            return nodes;
        },
        unregister: function (nodeList, isChild) {
            var nodes = nodeLists.unregisterChildren(nodeList, true);
            if (nodeList.unregistered) {
                var unregisteredCallback = nodeList.unregistered;
                nodeList.replacements = nodeList.unregistered = null;
                if (!isChild) {
                    var deepChildren = nodeList.parentList && nodeList.parentList.deepChildren;
                    if (deepChildren) {
                        var index = deepChildren.indexOf(nodeList);
                        if (index !== -1) {
                            deepChildren.splice(index, 1);
                        }
                    }
                }
                unregisteredCallback();
            }
            return nodes;
        },
        after: function (oldElements, newFrag) {
            var last = oldElements[oldElements.length - 1];
            if (last.nextSibling) {
                domMutate.insertBefore.call(last.parentNode, newFrag, last.nextSibling);
            } else {
                domMutate.appendChild.call(last.parentNode, newFrag);
            }
        },
        replace: function (oldElements, newFrag) {
            var selectedValue, parentNode = oldElements[0].parentNode;
            if (parentNode.nodeName.toUpperCase() === 'SELECT' && parentNode.selectedIndex >= 0) {
                selectedValue = parentNode.value;
            }
            if (oldElements.length === 1) {
                domMutate.replaceChild.call(parentNode, newFrag, oldElements[0]);
            } else {
                nodeLists.after(oldElements, newFrag);
                nodeLists.remove(oldElements);
            }
            if (selectedValue !== undefined) {
                parentNode.value = selectedValue;
            }
        },
        remove: function (elementsToBeRemoved) {
            var parent = elementsToBeRemoved[0] && elementsToBeRemoved[0].parentNode;
            each(elementsToBeRemoved, function (child) {
                domMutate.removeChild.call(parent, child);
            });
        },
        nodeMap: nodeMap
    };
    module.exports = namespace.nodeLists = nodeLists;
});
/*can-util@3.10.12#dom/fragment/fragment*/
define('can-util@3.10.12#dom/fragment/fragment', [
    'require',
    'exports',
    'module',
    'can-globals/document/document',
    '../child-nodes/child-nodes'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var getDocument = require('can-globals/document/document'), childNodes = require('../child-nodes/child-nodes');
        var fragmentRE = /^\s*<(\w+)[^>]*>/, toString = {}.toString, fragment = function (html, name, doc) {
                if (name === undefined) {
                    name = fragmentRE.test(html) && RegExp.$1;
                }
                if (html && toString.call(html.replace) === '[object Function]') {
                    html = html.replace(/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, '<$1></$2>');
                }
                var container = doc.createElement('div'), temp = doc.createElement('div');
                if (name === 'tbody' || name === 'tfoot' || name === 'thead' || name === 'colgroup') {
                    temp.innerHTML = '<table>' + html + '</table>';
                    container = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild;
                } else if (name === 'col') {
                    temp.innerHTML = '<table><colgroup>' + html + '</colgroup></table>';
                    container = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild.firstChild;
                } else if (name === 'tr') {
                    temp.innerHTML = '<table><tbody>' + html + '</tbody></table>';
                    container = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild.firstChild;
                } else if (name === 'td' || name === 'th') {
                    temp.innerHTML = '<table><tbody><tr>' + html + '</tr></tbody></table>';
                    container = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild.firstChild.firstChild;
                } else if (name === 'option') {
                    temp.innerHTML = '<select>' + html + '</select>';
                    container = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild;
                } else {
                    container.innerHTML = '' + html;
                }
                var tmp = {}, children = childNodes(container);
                tmp.length = children.length;
                for (var i = 0; i < children.length; i++) {
                    tmp[i] = children[i];
                }
                return [].slice.call(tmp);
            };
        var buildFragment = function (html, doc) {
            if (html && html.nodeType === 11) {
                return html;
            }
            if (!doc) {
                doc = getDocument();
            } else if (doc.length) {
                doc = doc[0];
            }
            var parts = fragment(html, undefined, doc), frag = (doc || document).createDocumentFragment();
            for (var i = 0, length = parts.length; i < length; i++) {
                frag.appendChild(parts[i]);
            }
            return frag;
        };
        module.exports = buildFragment;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-util@3.10.12#dom/frag/frag*/
define('can-util@3.10.12#dom/frag/frag', [
    'require',
    'exports',
    'module',
    'can-globals/document/document',
    '../fragment/fragment',
    '../../js/each/each',
    '../child-nodes/child-nodes'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var getDocument = require('can-globals/document/document');
        var fragment = require('../fragment/fragment');
        var each = require('../../js/each/each');
        var childNodes = require('../child-nodes/child-nodes');
        var makeFrag = function (item, doc) {
            var document = doc || getDocument();
            var frag;
            if (!item || typeof item === 'string') {
                frag = fragment(item == null ? '' : '' + item, document);
                if (!frag.childNodes.length) {
                    frag.appendChild(document.createTextNode(''));
                }
                return frag;
            } else if (item.nodeType === 11) {
                return item;
            } else if (typeof item.nodeType === 'number') {
                frag = document.createDocumentFragment();
                frag.appendChild(item);
                return frag;
            } else if (typeof item.length === 'number') {
                frag = document.createDocumentFragment();
                each(item, function (item) {
                    frag.appendChild(makeFrag(item));
                });
                if (!childNodes(frag).length) {
                    frag.appendChild(document.createTextNode(''));
                }
                return frag;
            } else {
                frag = fragment('' + item, document);
                if (!childNodes(frag).length) {
                    frag.appendChild(document.createTextNode(''));
                }
                return frag;
            }
        };
        module.exports = makeFrag;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-util@3.10.12#dom/events/removed/removed*/
define('can-util@3.10.12#dom/events/removed/removed', [
    'require',
    'exports',
    'module',
    '../make-mutation-event/make-mutation-event'
], function (require, exports, module) {
    'use strict';
    var makeMutationEvent = require('../make-mutation-event/make-mutation-event');
    makeMutationEvent('removed', 'removedNodes');
});
/*can-view-live@4.0.0-pre.11#lib/core*/
define('can-view-live@4.0.0-pre.11#lib/core', [
    'require',
    'exports',
    'module',
    'can-view-parser',
    'can-util/dom/events/events',
    'can-view-nodelist',
    'can-util/dom/frag/frag',
    'can-util/dom/child-nodes/child-nodes',
    'can-reflect',
    'can-util/dom/events/removed/removed'
], function (require, exports, module) {
    var parser = require('can-view-parser');
    var domEvents = require('can-util/dom/events/events');
    var nodeLists = require('can-view-nodelist');
    var makeFrag = require('can-util/dom/frag/frag');
    var childNodes = require('can-util/dom/child-nodes/child-nodes');
    var canReflect = require('can-reflect');
    require('can-util/dom/events/removed/removed');
    var elementDependenciesMap = new WeakMap();
    var live = {
        setup: function (el, bind, unbind) {
            var tornDown = false, data, teardown = function () {
                    if (!tornDown) {
                        tornDown = true;
                        unbind(data);
                        domEvents.removeEventListener.call(el, 'removed', teardown);
                    }
                    return true;
                };
            data = {
                teardownCheck: function (parent) {
                    return parent ? false : teardown();
                }
            };
            domEvents.addEventListener.call(el, 'removed', teardown);
            bind(data);
            return data;
        },
        listen: function (el, compute, change) {
            return live.setup(el, function bind() {
                canReflect.onValue(compute, change, 'notify');
            }, function unbind(data) {
                canReflect.offValue(compute, change, 'notify');
                if (data.nodeList) {
                    nodeLists.unregister(data.nodeList);
                }
            });
        },
        getAttributeParts: function (newVal) {
            var attrs = {}, attr;
            parser.parseAttrs(newVal, {
                attrStart: function (name) {
                    attrs[name] = '';
                    attr = name;
                },
                attrValue: function (value) {
                    attrs[attr] += value;
                },
                attrEnd: function () {
                }
            });
            return attrs;
        },
        isNode: function (obj) {
            return obj && obj.nodeType;
        },
        addTextNodeIfNoChildren: function (frag) {
            if (!frag.firstChild) {
                frag.appendChild(frag.ownerDocument.createTextNode(''));
            }
        },
        replace: function (nodes, val, teardown) {
            var oldNodes = nodes.slice(0), frag = makeFrag(val);
            nodeLists.register(nodes, teardown);
            nodeLists.update(nodes, childNodes(frag));
            nodeLists.replace(oldNodes, frag);
            return nodes;
        },
        getParentNode: function (el, defaultParentNode) {
            return defaultParentNode && el.parentNode.nodeType === 11 ? defaultParentNode : el.parentNode;
        },
        makeString: function (txt) {
            return txt == null ? '' : '' + txt;
        }
    };
    module.exports = live;
});
/*can-view-live@4.0.0-pre.11#lib/attr*/
define('can-view-live@4.0.0-pre.11#lib/attr', [
    'require',
    'exports',
    'module',
    'can-util/dom/attr/attr',
    './core',
    'can-reflect'
], function (require, exports, module) {
    var attr = require('can-util/dom/attr/attr');
    var live = require('./core');
    var canReflect = require('can-reflect');
    live.attr = function (el, attributeName, compute) {
        function liveUpdateAttr(newVal) {
            attr.set(el, attributeName, newVal);
        }
        live.listen(el, compute, liveUpdateAttr);
        liveUpdateAttr(canReflect.getValue(compute));
    };
});
/*can-view-live@4.0.0-pre.11#lib/attrs*/
define('can-view-live@4.0.0-pre.11#lib/attrs', [
    'require',
    'exports',
    'module',
    './core',
    'can-view-callbacks',
    'can-util/dom/attr/attr',
    'can-util/dom/events/events',
    'can-reflect'
], function (require, exports, module) {
    var live = require('./core');
    var viewCallbacks = require('can-view-callbacks');
    var attr = require('can-util/dom/attr/attr');
    var domEvents = require('can-util/dom/events/events');
    var canReflect = require('can-reflect');
    live.attrs = function (el, compute, scope, options) {
        if (!canReflect.isObservableLike(compute)) {
            var attrs = live.getAttributeParts(compute);
            for (var name in attrs) {
                attr.set(el, name, attrs[name]);
            }
            return;
        }
        var oldAttrs = {};
        function liveAttrsUpdate(newVal) {
            var newAttrs = live.getAttributeParts(newVal), name;
            for (name in newAttrs) {
                var newValue = newAttrs[name], oldValue = oldAttrs[name];
                if (newValue !== oldValue) {
                    attr.set(el, name, newValue);
                    var callback = viewCallbacks.attr(name);
                    if (callback) {
                        callback(el, {
                            attributeName: name,
                            scope: scope,
                            options: options
                        });
                    }
                }
                delete oldAttrs[name];
            }
            for (name in oldAttrs) {
                attr.remove(el, name);
            }
            oldAttrs = newAttrs;
        }
        canReflect.onValue(compute, liveAttrsUpdate);
        var teardownHandler = function () {
            canReflect.offValue(compute, liveAttrsUpdate);
            domEvents.removeEventListener.call(el, 'removed', teardownHandler);
        };
        domEvents.addEventListener.call(el, 'removed', teardownHandler);
        liveAttrsUpdate(canReflect.getValue(compute));
    };
});
/*can-view-live@4.0.0-pre.11#lib/html*/
define('can-view-live@4.0.0-pre.11#lib/html', [
    'require',
    'exports',
    'module',
    './core',
    'can-view-nodelist',
    'can-util/dom/frag/frag',
    'can-util/js/make-array/make-array',
    'can-util/dom/child-nodes/child-nodes',
    'can-reflect'
], function (require, exports, module) {
    var live = require('./core');
    var nodeLists = require('can-view-nodelist');
    var makeFrag = require('can-util/dom/frag/frag');
    var makeArray = require('can-util/js/make-array/make-array');
    var childNodes = require('can-util/dom/child-nodes/child-nodes');
    var canReflect = require('can-reflect');
    live.html = function (el, compute, parentNode, nodeList) {
        var data, makeAndPut, nodes;
        parentNode = live.getParentNode(el, parentNode);
        function liveHTMLUpdateHTML(newVal) {
            var attached = nodeLists.first(nodes).parentNode;
            if (attached) {
                makeAndPut(newVal);
            }
            var pn = nodeLists.first(nodes).parentNode;
            data.teardownCheck(pn);
        }
        data = live.listen(parentNode, compute, liveHTMLUpdateHTML);
        nodes = nodeList || [el];
        makeAndPut = function (val) {
            var isFunction = typeof val === 'function', frag = makeFrag(isFunction ? '' : val), oldNodes = makeArray(nodes);
            live.addTextNodeIfNoChildren(frag);
            oldNodes = nodeLists.update(nodes, childNodes(frag));
            if (isFunction) {
                val(frag.firstChild);
            }
            nodeLists.replace(oldNodes, frag);
        };
        data.nodeList = nodes;
        if (!nodeList) {
            nodeLists.register(nodes, data.teardownCheck);
        } else {
            nodeList.unregistered = data.teardownCheck;
        }
        makeAndPut(canReflect.getValue(compute));
    };
});
/*can-view-live@4.0.0-pre.11#lib/set-observable*/
define('can-view-live@4.0.0-pre.11#lib/set-observable', [
    'require',
    'exports',
    'module',
    'can-simple-observable',
    'can-reflect'
], function (require, exports, module) {
    var SimpleObservable = require('can-simple-observable');
    var canReflect = require('can-reflect');
    function SetObservable(initialValue, setter) {
        this.setter = setter;
        SimpleObservable.call(this, initialValue);
    }
    SetObservable.prototype = Object.create(SimpleObservable.prototype);
    SetObservable.prototype.constructor = SetObservable;
    SetObservable.prototype.set = function (newVal) {
        this.setter(newVal);
    };
    canReflect.assignSymbols(SetObservable.prototype, { 'can.setValue': SetObservable.prototype.set });
    module.exports = SetObservable;
});
/*can-view-live@4.0.0-pre.11#lib/patcher*/
define('can-view-live@4.0.0-pre.11#lib/patcher', [
    'require',
    'exports',
    'module',
    'can-reflect',
    'can-key-tree',
    'can-symbol',
    'can-util/js/diff/diff',
    'can-queues',
    'can-symbol'
], function (require, exports, module) {
    var canReflect = require('can-reflect');
    var KeyTree = require('can-key-tree');
    var canSymbol = require('can-symbol');
    var diff = require('can-util/js/diff/diff');
    var queues = require('can-queues');
    var canSymbol = require('can-symbol');
    var onValueSymbol = canSymbol.for('can.onValue'), offValueSymbol = canSymbol.for('can.offValue');
    var onPatchesSymbol = canSymbol.for('can.onPatches');
    var offPatchesSymbol = canSymbol.for('can.offPatches');
    var Patcher = function (observableOrList, priority) {
        this.handlers = new KeyTree([
            Object,
            Array
        ], {
            onFirst: this.setup.bind(this),
            onEmpty: this.teardown.bind(this)
        });
        this.observableOrList = observableOrList;
        this.isObservableValue = canReflect.isValueLike(this.observableOrList) || canReflect.isObservableLike(this.observableOrList);
        if (this.isObservableValue) {
            this.priority = canReflect.getPriority(observableOrList);
        } else {
            this.priority = priority || 0;
        }
        this.onList = this.onList.bind(this);
        this.onPatchesNotify = this.onPatchesNotify.bind(this);
        this.onPatchesDerive = this.onPatchesDerive.bind(this);
        this.patches = [];
    };
    Patcher.prototype = {
        constructor: Patcher,
        setup: function () {
            if (this.observableOrList[onValueSymbol]) {
                canReflect.onValue(this.observableOrList, this.onList, 'notify');
                this.setupList(canReflect.getValue(this.observableOrList));
            } else {
                this.setupList(this.observableOrList || []);
            }
        },
        teardown: function () {
            if (this.observableOrList[offValueSymbol]) {
                canReflect.offValue(this.observableOrList, this.onList, 'notify');
            }
        },
        setupList: function (list) {
            this.currentList = list;
            if (list[onPatchesSymbol]) {
                list[onPatchesSymbol](this.onPatchesNotify, 'notify');
            }
        },
        onList: function onList(newList) {
            var current = this.currentList || [];
            newList = newList || [];
            if (current[offPatchesSymbol]) {
                current[offPatchesSymbol](this.onPatchesNotify, 'notify');
            }
            var patches = diff(current, newList);
            this.currentList = newList;
            this.onPatchesNotify(patches);
            if (newList[onPatchesSymbol]) {
                newList[onPatchesSymbol](this.onPatchesNotify, 'notify');
            }
        },
        onPatchesNotify: function onPatchesNotify(patches) {
            this.patches.push.apply(this.patches, patches);
            queues.deriveQueue.enqueue(this.onPatchesDerive, this, [], { priority: this.priority });
        },
        onPatchesDerive: function onPatchesDerive() {
            var patches = this.patches;
            this.patches = [];
            queues.enqueueByQueue(this.handlers.getNode([]), this.currentList, [
                patches,
                this.currentList
            ], null, [
                'Apply patches',
                patches
            ]);
        }
    };
    canReflect.assignSymbols(Patcher.prototype, {
        'can.onPatches': function (handler, queue) {
            this.handlers.add([
                queue || 'mutate',
                handler
            ]);
        },
        'can.offPatches': function (handler, queue) {
            this.handlers.delete([
                queue || 'mutate',
                handler
            ]);
        }
    });
    module.exports = Patcher;
});
/*can-view-live@4.0.0-pre.11#lib/list*/
define('can-view-live@4.0.0-pre.11#lib/list', [
    'require',
    'exports',
    'module',
    './core',
    'can-view-nodelist',
    'can-util/dom/frag/frag',
    'can-util/dom/mutate/mutate',
    'can-util/dom/child-nodes/child-nodes',
    'can-util/js/make-array/make-array',
    'can-util/js/each/each',
    'can-reflect',
    'can-symbol',
    'can-simple-observable',
    './set-observable',
    './patcher'
], function (require, exports, module) {
    var live = require('./core');
    var nodeLists = require('can-view-nodelist');
    var frag = require('can-util/dom/frag/frag');
    var domMutate = require('can-util/dom/mutate/mutate');
    var childNodes = require('can-util/dom/child-nodes/child-nodes');
    var makeArray = require('can-util/js/make-array/make-array');
    var each = require('can-util/js/each/each');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var SimpleObservable = require('can-simple-observable');
    var SetObservable = require('./set-observable');
    var Patcher = require('./patcher');
    var splice = [].splice;
    var renderAndAddToNodeLists = function (newNodeLists, parentNodeList, render, context, args) {
            var itemNodeList = [];
            if (parentNodeList) {
                nodeLists.register(itemNodeList, null, parentNodeList, true);
                itemNodeList.parentList = parentNodeList;
                itemNodeList.expression = '#each SUBEXPRESSION';
            }
            var itemHTML = render.apply(context, args.concat([itemNodeList])), itemFrag = frag(itemHTML);
            var children = makeArray(childNodes(itemFrag));
            if (parentNodeList) {
                nodeLists.update(itemNodeList, children);
                newNodeLists.push(itemNodeList);
            } else {
                newNodeLists.push(nodeLists.register(children));
            }
            return itemFrag;
        }, removeFromNodeList = function (masterNodeList, index, length) {
            var removedMappings = masterNodeList.splice(index + 1, length), itemsToRemove = [];
            each(removedMappings, function (nodeList) {
                var nodesToRemove = nodeLists.unregister(nodeList);
                [].push.apply(itemsToRemove, nodesToRemove);
            });
            return itemsToRemove;
        };
    var onPatchesSymbol = canSymbol.for('can.onPatches');
    var offPatchesSymbol = canSymbol.for('can.offPatches');
    function ListDOMPatcher(el, compute, render, context, parentNode, nodeList, falseyRender) {
        this.patcher = new Patcher(compute);
        parentNode = live.getParentNode(el, parentNode);
        this.value = compute;
        this.render = render;
        this.context = context;
        this.parentNode = parentNode;
        this.falseyRender = falseyRender;
        this.masterNodeList = nodeList || nodeLists.register([el], null, true);
        this.placeholder = el;
        this.indexMap = [];
        this.isValueLike = canReflect.isValueLike(this.value);
        this.isObservableLike = canReflect.isObservableLike(this.value);
        this.onPatches = this.onPatches.bind(this);
        var data = this.data = live.setup(parentNode, this.setupValueBinding.bind(this), this.teardownValueBinding.bind(this));
        this.masterNodeList.unregistered = function () {
            data.teardownCheck();
        };
    }
    var onPatchesSymbol = canSymbol.for('can.onPatches');
    var offPatchesSymbol = canSymbol.for('can.offPatches');
    ListDOMPatcher.prototype = {
        setupValueBinding: function () {
            this.patcher[onPatchesSymbol](this.onPatches, 'domUI');
            if (this.patcher.currentList && this.patcher.currentList.length) {
                this.onPatches([{
                        insert: this.patcher.currentList,
                        index: 0,
                        deleteCount: 0
                    }]);
            } else {
                this.addFalseyIfEmpty();
            }
        },
        teardownValueBinding: function () {
            this.patcher[offPatchesSymbol](this.onPatches, 'domUI');
            this.exit = true;
            this.remove({ length: this.patcher.currentList.length }, 0, true);
        },
        onPatches: function ListDOMPatcher_onPatches(patches) {
            if (this.exit) {
                return;
            }
            for (var i = 0, patchLen = patches.length; i < patchLen; i++) {
                var patch = patches[i];
                if (patch.type === 'move') {
                    this.move(patch.toIndex, patch.fromIndex);
                } else {
                    if (patch.deleteCount) {
                        this.remove({ length: patch.deleteCount }, patch.index, true);
                    }
                    if (patch.insert && patch.insert.length) {
                        this.add(patch.insert, patch.index);
                    }
                }
            }
        },
        add: function (items, index) {
            var frag = this.placeholder.ownerDocument.createDocumentFragment(), newNodeLists = [], newIndicies = [], masterNodeList = this.masterNodeList, render = this.render, context = this.context;
            each(items, function (item, key) {
                var itemIndex = new SimpleObservable(key + index), itemCompute = new SetObservable(item, function (newVal) {
                        canReflect.setKeyValue(this.patcher.currentList, itemIndex.get(), newVal);
                    }.bind(this)), itemFrag = renderAndAddToNodeLists(newNodeLists, masterNodeList, render, context, [
                        itemCompute,
                        itemIndex
                    ]);
                frag.appendChild(itemFrag);
                newIndicies.push(itemIndex);
            }, this);
            var masterListIndex = index + 1;
            if (!this.indexMap.length) {
                var falseyItemsToRemove = removeFromNodeList(masterNodeList, 0, masterNodeList.length - 1);
                nodeLists.remove(falseyItemsToRemove);
            }
            if (!masterNodeList[masterListIndex]) {
                nodeLists.after(masterListIndex === 1 ? [this.placeholder] : [nodeLists.last(this.masterNodeList[masterListIndex - 1])], frag);
            } else {
                var el = nodeLists.first(masterNodeList[masterListIndex]);
                domMutate.insertBefore.call(el.parentNode, frag, el);
            }
            splice.apply(this.masterNodeList, [
                masterListIndex,
                0
            ].concat(newNodeLists));
            splice.apply(this.indexMap, [
                index,
                0
            ].concat(newIndicies));
            for (var i = index + newIndicies.length, len = this.indexMap.length; i < len; i++) {
                this.indexMap[i].set(i);
            }
        },
        remove: function (items, index) {
            if (index < 0) {
                index = this.indexMap.length + index;
            }
            var itemsToRemove = removeFromNodeList(this.masterNodeList, index, items.length);
            var indexMap = this.indexMap;
            indexMap.splice(index, items.length);
            for (var i = index, len = indexMap.length; i < len; i++) {
                indexMap[i].set(i);
            }
            if (!this.exit) {
                this.addFalseyIfEmpty();
                nodeLists.remove(itemsToRemove);
            } else {
                nodeLists.unregister(this.masterNodeList);
            }
        },
        addFalseyIfEmpty: function () {
            if (this.falseyRender && this.indexMap.length === 0) {
                var falseyNodeLists = [];
                var falseyFrag = renderAndAddToNodeLists(falseyNodeLists, this.masterNodeList, this.falseyRender, this.currentList, [this.currentList]);
                nodeLists.after([this.masterNodeList[0]], falseyFrag);
                this.masterNodeList.push(falseyNodeLists[0]);
            }
        },
        move: function move(newIndex, currentIndex) {
            newIndex = newIndex + 1;
            currentIndex = currentIndex + 1;
            var masterNodeList = this.masterNodeList, indexMap = this.indexMap;
            var referenceNodeList = masterNodeList[newIndex];
            var movedElements = frag(nodeLists.flatten(masterNodeList[currentIndex]));
            var referenceElement;
            if (currentIndex < newIndex) {
                referenceElement = nodeLists.last(referenceNodeList).nextSibling;
            } else {
                referenceElement = nodeLists.first(referenceNodeList);
            }
            var parentNode = masterNodeList[0].parentNode;
            parentNode.insertBefore(movedElements, referenceElement);
            var temp = masterNodeList[currentIndex];
            [].splice.apply(masterNodeList, [
                currentIndex,
                1
            ]);
            [].splice.apply(masterNodeList, [
                newIndex,
                0,
                temp
            ]);
            newIndex = newIndex - 1;
            currentIndex = currentIndex - 1;
            var indexCompute = indexMap[currentIndex];
            [].splice.apply(indexMap, [
                currentIndex,
                1
            ]);
            [].splice.apply(indexMap, [
                newIndex,
                0,
                indexCompute
            ]);
            var i = Math.min(currentIndex, newIndex);
            var len = indexMap.length;
            for (i, len; i < len; i++) {
                indexMap[i].set(i);
            }
        },
        set: function (newVal, index) {
            this.remove({ length: 1 }, index, true);
            this.add([newVal], index);
        }
    };
    live.list = function (el, list, render, context, parentNode, nodeList, falseyRender) {
        if (el.nodeType !== Node.TEXT_NODE) {
            var textNode;
            if (!nodeList) {
                textNode = document.createTextNode('');
                el.replaceWith(textNode);
                el = textNode;
            } else {
                textNode = document.createTextNode('');
                nodeLists.replace(nodeList, textNode);
                nodeLists.update(nodeList, [textNode]);
                el = textNode;
            }
        }
        new ListDOMPatcher(el, list, render, context, parentNode, nodeList, falseyRender);
    };
});
/*can-view-live@4.0.0-pre.11#lib/text*/
define('can-view-live@4.0.0-pre.11#lib/text', [
    'require',
    'exports',
    'module',
    './core',
    'can-view-nodelist',
    'can-reflect'
], function (require, exports, module) {
    var live = require('./core');
    var nodeLists = require('can-view-nodelist');
    var canReflect = require('can-reflect');
    live.text = function (el, compute, parentNode, nodeList) {
        if (el.nodeType !== Node.TEXT_NODE) {
            var textNode;
            if (!nodeList) {
                textNode = document.createTextNode('');
                el.replaceWith(textNode);
                el = textNode;
            } else {
                textNode = document.createTextNode('');
                nodeLists.replace(nodeList, textNode);
                nodeLists.update(nodeList, [textNode]);
                el = textNode;
            }
        }
        var parent = live.getParentNode(el, parentNode);
        el.nodeValue = live.makeString(canReflect.getValue(compute));
        function liveTextUpdateTextNode(newVal) {
            el.nodeValue = live.makeString(newVal);
        }
        var data = live.listen(parent, compute, liveTextUpdateTextNode);
        if (!nodeList) {
            nodeList = nodeLists.register([el], null, true);
        }
        nodeList.unregistered = data.teardownCheck;
        data.nodeList = nodeList;
    };
});
/*can-view-live@4.0.0-pre.11#can-view-live*/
define('can-view-live@4.0.0-pre.11#can-view-live', [
    'require',
    'exports',
    'module',
    './lib/core',
    './lib/attr',
    './lib/attrs',
    './lib/html',
    './lib/list',
    './lib/text'
], function (require, exports, module) {
    var live = require('./lib/core');
    require('./lib/attr');
    require('./lib/attrs');
    require('./lib/html');
    require('./lib/list');
    require('./lib/text');
    module.exports = live;
});
/*can-util@3.10.12#js/base-url/base-url*/
define('can-util@3.10.12#js/base-url/base-url', [
    'require',
    'exports',
    'module',
    'can-globals/global/global',
    'can-globals/document/document'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var getGlobal = require('can-globals/global/global');
        var getDomDocument = require('can-globals/document/document');
        var setBaseUrl;
        module.exports = function (setUrl) {
            if (setUrl !== undefined) {
                setBaseUrl = setUrl;
            }
            if (setBaseUrl !== undefined) {
                return setBaseUrl;
            }
            var global = getGlobal();
            var domDocument = getDomDocument();
            if (domDocument && 'baseURI' in domDocument) {
                return domDocument.baseURI;
            } else if (global.location) {
                var href = global.location.href;
                var lastSlash = href.lastIndexOf('/');
                return lastSlash !== -1 ? href.substr(0, lastSlash) : href;
            } else if (typeof process !== 'undefined') {
                return process.cwd();
            }
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-parse-uri@1.0.0#can-parse-uri*/
define('can-parse-uri@1.0.0#can-parse-uri', function (require, exports, module) {
    module.exports = function (url) {
        var m = String(url).replace(/^\s+|\s+$/g, '').match(/^([^:\/?#]+:)?(\/\/(?:[^:@]*(?::[^:@]*)?@)?(([^:\/?#]*)(?::(\d*))?))?([^?#]*)(\?[^#]*)?(#[\s\S]*)?/);
        return m ? {
            href: m[0] || '',
            protocol: m[1] || '',
            authority: m[2] || '',
            host: m[3] || '',
            hostname: m[4] || '',
            port: m[5] || '',
            pathname: m[6] || '',
            search: m[7] || '',
            hash: m[8] || ''
        } : null;
    };
});
/*can-util@3.10.12#js/join-uris/join-uris*/
define('can-util@3.10.12#js/join-uris/join-uris', [
    'require',
    'exports',
    'module',
    'can-parse-uri'
], function (require, exports, module) {
    'use strict';
    var parseURI = require('can-parse-uri');
    module.exports = function (base, href) {
        function removeDotSegments(input) {
            var output = [];
            input.replace(/^(\.\.?(\/|$))+/, '').replace(/\/(\.(\/|$))+/g, '/').replace(/\/\.\.$/, '/../').replace(/\/?[^\/]*/g, function (p) {
                if (p === '/..') {
                    output.pop();
                } else {
                    output.push(p);
                }
            });
            return output.join('').replace(/^\//, input.charAt(0) === '/' ? '/' : '');
        }
        href = parseURI(href || '');
        base = parseURI(base || '');
        return !href || !base ? null : (href.protocol || base.protocol) + (href.protocol || href.authority ? href.authority : base.authority) + removeDotSegments(href.protocol || href.authority || href.pathname.charAt(0) === '/' ? href.pathname : href.pathname ? (base.authority && !base.pathname ? '/' : '') + base.pathname.slice(0, base.pathname.lastIndexOf('/') + 1) + href.pathname : base.pathname) + (href.protocol || href.authority || href.pathname ? href.search : href.search || base.search) + href.hash;
    };
});
/*can-util@3.10.12#js/is-empty-object/is-empty-object*/
define('can-util@3.10.12#js/is-empty-object/is-empty-object', function (require, exports, module) {
    'use strict';
    module.exports = function (obj) {
        for (var prop in obj) {
            return false;
        }
        return true;
    };
});
/*can-stache@4.0.0-pre.7#helpers/-debugger*/
define('can-stache@4.0.0-pre.7#helpers/-debugger', [
    'require',
    'exports',
    'module',
    'can-util/js/log/log'
], function (require, exports, module) {
    var canLog = require('can-util/js/log/log');
    function noop() {
    }
    ;
    var resolveValue = noop;
    var evaluateArgs = noop;
    var __testing = {};
    function debuggerHelper(left, right) {
        canLog.warn('Forgotten {{debugger}} helper');
    }
    module.exports = {
        helper: debuggerHelper,
        evaluateArgs: evaluateArgs,
        resolveValue: resolveValue,
        __testing: __testing
    };
});
/*can-stache@4.0.0-pre.7#src/truthy-observable*/
define('can-stache@4.0.0-pre.7#src/truthy-observable', [
    'require',
    'exports',
    'module',
    'can-observation',
    'can-reflect'
], function (require, exports, module) {
    var Observation = require('can-observation');
    var canReflect = require('can-reflect');
    module.exports = function (observable) {
        return new Observation(function truthyObservation() {
            var val = canReflect.getValue(observable);
            return !!val;
        });
    };
});
/*can-stache@4.0.0-pre.7#helpers/core*/
define('can-stache@4.0.0-pre.7#helpers/core', [
    'require',
    'exports',
    'module',
    'can-view-live',
    'can-view-nodelist',
    '../src/utils',
    'can-util/js/is-function/is-function',
    'can-util/js/base-url/base-url',
    'can-util/js/join-uris/join-uris',
    'can-util/js/each/each',
    'can-util/js/assign/assign',
    'can-util/js/is-iterable/is-iterable',
    'can-util/js/dev/dev',
    'can-symbol',
    'can-reflect',
    'can-util/js/is-empty-object/is-empty-object',
    './-debugger',
    '../src/key-observable',
    'can-observation',
    '../src/truthy-observable',
    'can-util/dom/data/data'
], function (require, exports, module) {
    var live = require('can-view-live');
    var nodeLists = require('can-view-nodelist');
    var utils = require('../src/utils');
    var isFunction = require('can-util/js/is-function/is-function');
    var getBaseURL = require('can-util/js/base-url/base-url');
    var joinURIs = require('can-util/js/join-uris/join-uris');
    var each = require('can-util/js/each/each');
    var assign = require('can-util/js/assign/assign');
    var isIterable = require('can-util/js/is-iterable/is-iterable');
    var dev = require('can-util/js/dev/dev');
    var canSymbol = require('can-symbol');
    var canReflect = require('can-reflect');
    var isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');
    var debuggerHelper = require('./-debugger').helper;
    var KeyObservable = require('../src/key-observable');
    var Observation = require('can-observation');
    var TruthyObservable = require('../src/truthy-observable');
    var domData = require('can-util/dom/data/data');
    var looksLikeOptions = function (options) {
        return options && typeof options.fn === 'function' && typeof options.inverse === 'function';
    };
    var getValueSymbol = canSymbol.for('can.getValue'), isValueLikeSymbol = canSymbol.for('can.isValueLike');
    var resolve = function (value) {
        if (value && value[isValueLikeSymbol] && value[getValueSymbol]) {
            return value[getValueSymbol]();
        } else {
            return value;
        }
    };
    var resolveHash = function (hash) {
        var params = {};
        for (var prop in hash) {
            params[prop] = resolve(hash[prop]);
        }
        return params;
    };
    var helpers = {
        'each': function (items) {
            var args = [].slice.call(arguments), options = args.pop(), argsLen = args.length, argExprs = options.exprData.argExprs, hashExprs = options.exprData.hashExprs, resolved = resolve(items), asVariable, hashOptions, aliases, key;
            if (argsLen === 2 || argsLen === 3 && argExprs[1].key === 'as') {
                asVariable = args[argsLen - 1];
                if (typeof asVariable !== 'string') {
                    asVariable = argExprs[argsLen - 1].key;
                }
            }
            if (!isEmptyObject(hashExprs)) {
                hashOptions = {};
                each(hashExprs, function (exprs, key) {
                    hashOptions[exprs.key] = key;
                });
            }
            if ((canReflect.isObservableLike(resolved) && canReflect.isListLike(resolved) || utils.isArrayLike(resolved) && items.isComputed) && !options.stringOnly) {
                return function (el) {
                    var nodeList = [el];
                    nodeList.expression = 'live.list';
                    nodeLists.register(nodeList, null, options.nodeList, true);
                    nodeLists.update(options.nodeList, [el]);
                    var cb = function (item, index, parentNodeList) {
                        var aliases = { '%index': index };
                        if (asVariable) {
                            aliases[asVariable] = item;
                        }
                        if (!isEmptyObject(hashOptions)) {
                            if (hashOptions.value) {
                                aliases[hashOptions.value] = item;
                            }
                            if (hashOptions.index) {
                                aliases[hashOptions.index] = index;
                            }
                        }
                        return options.fn(options.scope.add(aliases, { notContext: true }).add(item), options.options, parentNodeList);
                    };
                    live.list(el, items, cb, options.context, el.parentNode, nodeList, function (list, parentNodeList) {
                        return options.inverse(options.scope.add(list), options.options, parentNodeList);
                    });
                };
            }
            var expr = resolved, result;
            if (!!expr && utils.isArrayLike(expr)) {
                result = utils.getItemsFragContent(expr, options, options.scope, asVariable);
                return options.stringOnly ? result.join('') : result;
            } else if (isIterable(expr)) {
                result = [];
                each(expr, function (value, key) {
                    aliases = { '%key': key };
                    if (asVariable) {
                        aliases[asVariable] = value;
                    }
                    if (!isEmptyObject(hashOptions)) {
                        if (hashOptions.value) {
                            aliases[hashOptions.value] = value;
                        }
                        if (hashOptions.key) {
                            aliases[hashOptions.key] = key;
                        }
                    }
                    result.push(options.fn(options.scope.add(aliases, { notContext: true }).add(value)));
                });
                return options.stringOnly ? result.join('') : result;
            } else if (canReflect.isObservableLike(expr) && canReflect.isMapLike(expr)) {
                result = [];
                canReflect.each(expr, function (val, key) {
                    var value = new KeyObservable(expr, key);
                    aliases = { '%key': key };
                    if (asVariable) {
                        aliases[asVariable] = expr[key];
                    }
                    result.push(options.fn(options.scope.add(aliases, { notContext: true }).add(value)));
                });
                return options.stringOnly ? result.join('') : result;
            } else if (expr instanceof Object) {
                result = [];
                for (key in expr) {
                    aliases = { '%key': key };
                    if (asVariable) {
                        aliases[asVariable] = expr[key];
                    }
                    result.push(options.fn(options.scope.add(aliases, { notContext: true }).add(expr[key])));
                }
                return options.stringOnly ? result.join('') : result;
            }
        },
        '%index': function (offset, options) {
            if (!options) {
                options = offset;
                offset = 0;
            }
            var index = options.scope.peek('%index');
            return '' + ((isFunction(index) ? index() : index) + offset);
        },
        'if': function (expr, options) {
            var value;
            if (expr && expr.isComputed) {
                value = canReflect.getValue(new TruthyObservable(expr));
            } else {
                value = !!resolve(expr);
            }
            if (value) {
                return options.fn(options.scope || this);
            } else {
                return options.inverse(options.scope || this);
            }
        },
        'is': function () {
            var lastValue, curValue, options = arguments[arguments.length - 1];
            if (arguments.length - 2 <= 0) {
                return options.inverse();
            }
            var args = arguments;
            var callFn = new Observation(function () {
                for (var i = 0; i < args.length - 1; i++) {
                    curValue = resolve(args[i]);
                    curValue = isFunction(curValue) ? curValue() : curValue;
                    if (i > 0) {
                        if (curValue !== lastValue) {
                            return false;
                        }
                    }
                    lastValue = curValue;
                }
                return true;
            });
            return callFn.get() ? options.fn() : options.inverse();
        },
        'eq': function () {
            return helpers.is.apply(this, arguments);
        },
        'unless': function (expr, options) {
            return helpers['if'].apply(this, [
                expr,
                assign(assign({}, options), {
                    fn: options.inverse,
                    inverse: options.fn
                })
            ]);
        },
        'with': function (expr, options) {
            var ctx = expr;
            if (!options) {
                options = expr;
                expr = true;
                ctx = options.hash;
            } else {
                expr = resolve(expr);
                if (options.hash && !isEmptyObject(options.hash)) {
                    ctx = options.scope.add(options.hash).add(ctx);
                }
            }
            return options.fn(ctx || {});
        },
        'log': function (options) {
            var logs = [];
            each(arguments, function (val) {
                if (!looksLikeOptions(val)) {
                    logs.push(val);
                }
            });
            if (typeof console !== 'undefined' && console.log) {
                if (!logs.length) {
                    console.log(options.context);
                } else {
                    console.log.apply(console, logs);
                }
            }
        },
        'data': function (attr) {
            var data = arguments.length === 2 ? this : arguments[1];
            return function (el) {
                domData.set.call(el, attr, data || this.context);
            };
        },
        'switch': function (expression, options) {
            resolve(expression);
            var found = false;
            var newOptions = options.helpers.add({
                'case': function (value, options) {
                    if (!found && resolve(expression) === resolve(value)) {
                        found = true;
                        return options.fn(options.scope || this);
                    }
                },
                'default': function (options) {
                    if (!found) {
                        return options.fn(options.scope || this);
                    }
                }
            });
            return options.fn(options.scope, newOptions);
        },
        'joinBase': function (firstExpr) {
            var args = [].slice.call(arguments);
            var options = args.pop();
            var moduleReference = args.map(function (expr) {
                var value = resolve(expr);
                return isFunction(value) ? value() : value;
            }).join('');
            var templateModule = options.helpers.peek('helpers.module');
            var parentAddress = templateModule ? templateModule.uri : undefined;
            var isRelative = moduleReference[0] === '.';
            if (isRelative && parentAddress) {
                return joinURIs(parentAddress, moduleReference);
            } else {
                var baseURL = typeof System !== 'undefined' && (System.renderingBaseURL || System.baseURL) || getBaseURL();
                if (moduleReference[0] !== '/' && baseURL[baseURL.length - 1] !== '/') {
                    baseURL += '/';
                }
                return joinURIs(baseURL, moduleReference);
            }
        }
    };
    helpers.eachOf = helpers.each;
    helpers.debugger = debuggerHelper;
    var registerHelper = function (name, callback) {
        helpers[name] = callback;
    };
    var makeSimpleHelper = function (fn) {
        return function () {
            var realArgs = [];
            each(arguments, function (val) {
                while (val && val.isComputed) {
                    val = val();
                }
                realArgs.push(val);
            });
            return fn.apply(this, realArgs);
        };
    };
    module.exports = {
        registerHelper: registerHelper,
        registerSimpleHelper: function (name, callback) {
            registerHelper(name, makeSimpleHelper(callback));
        },
        getHelper: function (name, options) {
            var helper = options && options.get && options.get('helpers.' + name, { proxyMethods: false });
            if (!helper) {
                helper = helpers[name];
            }
            if (helper) {
                return { fn: helper };
            }
        },
        resolve: resolve,
        resolveHash: resolveHash,
        looksLikeOptions: looksLikeOptions
    };
});
/*can-util@3.10.12#js/last/last*/
define('can-util@3.10.12#js/last/last', function (require, exports, module) {
    'use strict';
    module.exports = function (arr) {
        return arr && arr[arr.length - 1];
    };
});
/*can-simple-observable@2.0.0-pre.16#setter/setter*/
define('can-simple-observable@2.0.0-pre.16#setter/setter', [
    'require',
    'exports',
    'module',
    'can-reflect',
    'can-observation',
    'can-key-tree',
    '../settable/settable'
], function (require, exports, module) {
    var canReflect = require('can-reflect');
    var Observation = require('can-observation');
    var KeyTree = require('can-key-tree');
    var SettableObservable = require('../settable/settable');
    function SetterObservable(getter, setter) {
        this.handlers = new KeyTree([
            Object,
            Array
        ], {
            onFirst: this.setup.bind(this),
            onEmpty: this.teardown.bind(this)
        });
        this.setter = setter;
        this.observation = new Observation(getter);
        this.handler = this.handler.bind(this);
    }
    SetterObservable.prototype = Object.create(SettableObservable.prototype);
    SetterObservable.prototype.constructor = SetterObservable;
    SetterObservable.prototype.set = function (newVal) {
        this.setter(newVal);
    };
    SetterObservable.prototype.hasDependencies = function () {
        return canReflect.valueHasDependencies(this.observation);
    };
    canReflect.assignSymbols(SetterObservable.prototype, {
        'can.setValue': SetterObservable.prototype.set,
        'can.valueHasDependencies': SetterObservable.prototype.hasDependencies
    });
    module.exports = SetterObservable;
});
/*can-stache@4.0.0-pre.7#src/expression*/
define('can-stache@4.0.0-pre.7#src/expression', [
    'require',
    'exports',
    'module',
    'can-stache-key',
    './utils',
    '../helpers/core',
    'can-util/js/each/each',
    'can-util/js/is-empty-object/is-empty-object',
    'can-util/js/dev/dev',
    'can-util/js/assign/assign',
    'can-util/js/last/last',
    'can-reflect',
    'can-symbol',
    'can-observation',
    'can-simple-observable/setter/setter',
    'can-view-scope/make-compute-like'
], function (require, exports, module) {
    var observeReader = require('can-stache-key');
    var utils = require('./utils');
    var mustacheHelpers = require('../helpers/core');
    var each = require('can-util/js/each/each');
    var isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');
    var dev = require('can-util/js/dev/dev');
    var assign = require('can-util/js/assign/assign');
    var last = require('can-util/js/last/last');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var Observation = require('can-observation');
    var SetterObservable = require('can-simple-observable/setter/setter');
    var makeComputeLike = require('can-view-scope/make-compute-like');
    var sourceTextSymbol = canSymbol.for('can-stache.sourceText');
    var getObservableValue_fromKey = function (key, scope, readOptions) {
            var data = scope.computeData(key, readOptions);
            Observation.temporarilyBind(data);
            return data;
        }, computeHasDependencies = function (compute) {
            return compute[canSymbol.for('can.valueHasDependencies')] ? canReflect.valueHasDependencies(compute) : compute.computeInstance.hasDependencies;
        }, lookupValueOrHelper = function (key, scope, helperOptions, readOptions) {
            var scopeKeyData = getObservableValue_fromKey(key, scope, readOptions);
            var result = { value: scopeKeyData };
            if (scopeKeyData.initialValue === undefined) {
                if (key.charAt(0) === '@') {
                    key = key.substr(1);
                }
                var helper = mustacheHelpers.getHelper(key, helperOptions);
                result.helper = helper && helper.fn;
            }
            return result;
        }, getObservableValue_fromDynamicKey_fromObservable = function (key, root, helperOptions, readOptions) {
            var getKey = function () {
                return ('' + canReflect.getValue(key)).replace('.', '\\.');
            };
            var computeValue = new SetterObservable(function getDynamicKey() {
                return observeReader.get(canReflect.getValue(root), getKey());
            }, function setDynamicKey(newVal) {
                observeReader.write(canReflect.getValue(root), observeReader.reads(getKey()), newVal);
            });
            Observation.temporarilyBind(computeValue);
            return computeValue;
        }, convertToArgExpression = function (expr) {
            if (!(expr instanceof Arg) && !(expr instanceof Literal)) {
                return new Arg(expr);
            } else {
                return expr;
            }
        }, toComputeOrValue = function (value) {
            if (canReflect.isObservableLike(value)) {
                if (canReflect.valueHasDependencies(value) === false) {
                    return canReflect.getValue(value);
                }
                if (value.compute) {
                    return value.compute;
                } else {
                    return makeComputeLike(value);
                }
            }
            return value;
        }, toCompute = function (value) {
            if (value) {
                if (value.isComputed) {
                    return value;
                }
                if (value.compute) {
                    return value.compute;
                } else {
                    return makeComputeLike(value);
                }
            }
            return value;
        };
    var Bracket = function (key, root) {
        this.root = root;
        this.key = key;
    };
    Bracket.prototype.value = function (scope, helpers) {
        var root = this.root ? this.root.value(scope, helpers) : scope.peek('.');
        return getObservableValue_fromDynamicKey_fromObservable(this.key.value(scope, helpers), root, scope, helpers, {});
    };
    var Literal = function (value) {
        this._value = value;
    };
    Literal.prototype.value = function () {
        return this._value;
    };
    var Lookup = function (key, root, sourceText) {
        this.key = key;
        this.rootExpr = root;
        canReflect.setKeyValue(this, sourceTextSymbol, sourceText);
    };
    Lookup.prototype.value = function (scope, helperOptions) {
        if (this.rootExpr) {
            return getObservableValue_fromDynamicKey_fromObservable(this.key, this.rootExpr.value(scope, helperOptions), scope, {}, {});
        } else {
            var result = lookupValueOrHelper(this.key, scope, helperOptions);
            this.isHelper = result.helper && !result.helper.callAsMethod;
            return result.helper || result.value;
        }
    };
    var ScopeLookup = function (key, root) {
        Lookup.apply(this, arguments);
    };
    ScopeLookup.prototype.value = function (scope, helperOptions) {
        if (this.rootExpr) {
            return getObservableValue_fromDynamicKey_fromObservable(this.key, this.rootExpr.value(scope, helperOptions), scope, {}, {});
        }
        return getObservableValue_fromKey(this.key, scope, helperOptions);
    };
    var Arg = function (expression, modifiers) {
        this.expr = expression;
        this.modifiers = modifiers || {};
        this.isCompute = false;
    };
    Arg.prototype.value = function () {
        return this.expr.value.apply(this.expr, arguments);
    };
    var Hash = function () {
    };
    var Hashes = function (hashes) {
        this.hashExprs = hashes;
    };
    Hashes.prototype.value = function (scope, helperOptions) {
        var hash = {};
        for (var prop in this.hashExprs) {
            var val = convertToArgExpression(this.hashExprs[prop]), value = val.value.apply(val, arguments);
            hash[prop] = {
                call: !val.modifiers || !val.modifiers.compute,
                value: value
            };
        }
        return new Observation(function () {
            var finalHash = {};
            for (var prop in hash) {
                finalHash[prop] = hash[prop].call ? canReflect.getValue(hash[prop].value) : toComputeOrValue(hash[prop].value);
            }
            return finalHash;
        });
    };
    var Call = function (methodExpression, argExpressions) {
        this.methodExpr = methodExpression;
        this.argExprs = argExpressions.map(convertToArgExpression);
    };
    Call.prototype.args = function (scope, helperOptions) {
        var args = [];
        for (var i = 0, len = this.argExprs.length; i < len; i++) {
            var arg = this.argExprs[i];
            var value = arg.value.apply(arg, arguments);
            args.push({
                call: !arg.modifiers || !arg.modifiers.compute,
                value: value
            });
        }
        return function () {
            var finalArgs = [];
            for (var i = 0, len = args.length; i < len; i++) {
                finalArgs[i] = args[i].call ? canReflect.getValue(args[i].value) : toCompute(args[i].value);
            }
            return finalArgs;
        };
    };
    Call.prototype.value = function (scope, helperScope, helperOptions) {
        var method = this.methodExpr.value(scope, helperScope);
        var isHelper = this.isHelper = this.methodExpr.isHelper;
        var getArgs = this.args(scope, helperScope);
        var computeFn = function (newVal) {
            var func = canReflect.getValue(method);
            if (typeof func === 'function') {
                var args = getArgs();
                if (isHelper && helperOptions) {
                    args.push(helperOptions);
                }
                if (arguments.length) {
                    args.unshift(new expression.SetIdentifier(newVal));
                }
                return func.apply(null, args);
            }
        };
        var computeValue = new SetterObservable(computeFn, computeFn);
        Observation.temporarilyBind(computeValue);
        return computeValue;
    };
    var HelperLookup = function () {
        Lookup.apply(this, arguments);
    };
    HelperLookup.prototype.value = function (scope, helperOptions) {
        var result = lookupValueOrHelper(this.key, scope, helperOptions, {
            isArgument: true,
            args: [
                scope.peek('.'),
                scope
            ]
        });
        return result.helper || result.value;
    };
    var HelperScopeLookup = function () {
        Lookup.apply(this, arguments);
    };
    HelperScopeLookup.prototype.value = function (scope, helperOptions) {
        return getObservableValue_fromKey(this.key, scope, {
            callMethodsOnObservables: true,
            isArgument: true,
            args: [
                scope.peek('.'),
                scope
            ]
        });
    };
    var Helper = function (methodExpression, argExpressions, hashExpressions) {
        this.methodExpr = methodExpression;
        this.argExprs = argExpressions;
        this.hashExprs = hashExpressions;
        this.mode = null;
    };
    Helper.prototype.args = function (scope, helperOptions) {
        var args = [];
        for (var i = 0, len = this.argExprs.length; i < len; i++) {
            var arg = this.argExprs[i];
            args.push(toComputeOrValue(arg.value.apply(arg, arguments)));
        }
        return args;
    };
    Helper.prototype.hash = function (scope, helperOptions) {
        var hash = {};
        for (var prop in this.hashExprs) {
            var val = this.hashExprs[prop];
            hash[prop] = toComputeOrValue(val.value.apply(val, arguments));
        }
        return hash;
    };
    Helper.prototype.helperAndValue = function (scope, helperOptions) {
        var looksLikeAHelper = this.argExprs.length || !isEmptyObject(this.hashExprs), helper, computeData, methodKey = this.methodExpr instanceof Literal ? '' + this.methodExpr._value : this.methodExpr.key, initialValue, args;
        if (looksLikeAHelper) {
            helper = mustacheHelpers.getHelper(methodKey, helperOptions);
        }
        if (!helper) {
            computeData = getObservableValue_fromKey(methodKey, scope, { isArgument: true });
            if (typeof computeData.initialValue === 'function') {
                args = this.args(scope, helperOptions).map(toComputeOrValue);
                function observation() {
                    return computeData.initialValue.apply(null, args);
                }
                var functionResult = new Observation(observation);
                Observation.temporarilyBind(functionResult);
                return { value: functionResult };
            } else if (typeof computeData.initialValue !== 'undefined') {
                return { value: computeData };
            }
            if (!looksLikeAHelper && initialValue === undefined) {
                helper = mustacheHelpers.getHelper(methodKey, helperOptions);
            }
        }
        return {
            value: computeData,
            args: args,
            helper: helper && helper.fn
        };
    };
    Helper.prototype.evaluator = function (helper, scope, helperOptions, readOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly) {
        var helperOptionArg = { stringOnly: stringOnly }, context = scope.peek('.'), args = this.args(scope, helperOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly), hash = this.hash(scope, helperOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly);
        utils.convertToScopes(helperOptionArg, scope, helperOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly);
        assign(helperOptionArg, {
            context: context,
            scope: scope,
            contexts: scope,
            hash: hash,
            nodeList: nodeList,
            exprData: this,
            helperOptions: helperOptions,
            helpers: helperOptions
        });
        args.push(helperOptionArg);
        return function () {
            return helper.apply(context, args);
        };
    };
    Helper.prototype.value = function (scope, helperOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly) {
        var helperAndValue = this.helperAndValue(scope, helperOptions);
        var helper = helperAndValue.helper;
        if (!helper) {
            return helperAndValue.value;
        }
        var fn = this.evaluator(helper, scope, helperOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly);
        var computeValue = new Observation(fn);
        Observation.temporarilyBind(computeValue);
        if (!computeHasDependencies(computeValue)) {
            return computeValue();
        } else {
            return computeValue;
        }
    };
    Helper.prototype.closingTag = function () {
        return this.methodExpr.key;
    };
    canReflect.assignSymbols(Helper.prototype, {
        'can.getName': function () {
            return canReflect.getName(this.constructor) + '{{' + this.sourceText() + '}}';
        }
    });
    var keyRegExp = /[\w\.\\\-_@\/\&%]+/, tokensRegExp = /('.*?'|".*?"|=|[\w\.\\\-_@\/*%\$]+|[\(\)]|,|\~|\[|\]\s*|\s*(?=\[))/g, bracketSpaceRegExp = /\]\s+/, literalRegExp = /^('.*?'|".*?"|[0-9]+\.?[0-9]*|true|false|null|undefined)$/;
    var isTokenKey = function (token) {
        return keyRegExp.test(token);
    };
    var testDot = /^[\.@]\w/;
    var isAddingToExpression = function (token) {
        return isTokenKey(token) && testDot.test(token);
    };
    var ensureChildren = function (type) {
        if (!type.children) {
            type.children = [];
        }
        return type;
    };
    var Stack = function () {
        this.root = {
            children: [],
            type: 'Root'
        };
        this.current = this.root;
        this.stack = [this.root];
    };
    assign(Stack.prototype, {
        top: function () {
            return last(this.stack);
        },
        isRootTop: function () {
            return this.top() === this.root;
        },
        popTo: function (types) {
            this.popUntil(types);
            this.pop();
        },
        pop: function () {
            if (!this.isRootTop()) {
                this.stack.pop();
            }
        },
        first: function (types) {
            var curIndex = this.stack.length - 1;
            while (curIndex > 0 && types.indexOf(this.stack[curIndex].type) === -1) {
                curIndex--;
            }
            return this.stack[curIndex];
        },
        firstParent: function (types) {
            var curIndex = this.stack.length - 2;
            while (curIndex > 0 && types.indexOf(this.stack[curIndex].type) === -1) {
                curIndex--;
            }
            return this.stack[curIndex];
        },
        popUntil: function (types) {
            while (types.indexOf(this.top().type) === -1 && !this.isRootTop()) {
                this.stack.pop();
            }
            return this.top();
        },
        addTo: function (types, type) {
            var cur = this.popUntil(types);
            ensureChildren(cur).children.push(type);
        },
        addToAndPush: function (types, type) {
            this.addTo(types, type);
            this.stack.push(type);
        },
        push: function (type) {
            this.stack.push(type);
        },
        topLastChild: function () {
            return last(this.top().children);
        },
        replaceTopLastChild: function (type) {
            var children = ensureChildren(this.top()).children;
            children.pop();
            children.push(type);
            return type;
        },
        replaceTopLastChildAndPush: function (type) {
            this.replaceTopLastChild(type);
            this.stack.push(type);
        },
        replaceTopAndPush: function (type) {
            var children;
            if (this.top() === this.root) {
                children = ensureChildren(this.top()).children;
            } else {
                this.stack.pop();
                children = ensureChildren(this.top()).children;
            }
            children.pop();
            children.push(type);
            this.stack.push(type);
            return type;
        }
    });
    var convertKeyToLookup = function (key) {
        var lastPath = key.lastIndexOf('./');
        var lastDot = key.lastIndexOf('.');
        if (lastDot > lastPath) {
            return key.substr(0, lastDot) + '@' + key.substr(lastDot + 1);
        }
        var firstNonPathCharIndex = lastPath === -1 ? 0 : lastPath + 2;
        var firstNonPathChar = key.charAt(firstNonPathCharIndex);
        if (firstNonPathChar === '.' || firstNonPathChar === '@') {
            return key.substr(0, firstNonPathCharIndex) + '@' + key.substr(firstNonPathCharIndex + 1);
        } else {
            return key.substr(0, firstNonPathCharIndex) + '@' + key.substr(firstNonPathCharIndex);
        }
    };
    var convertToAtLookup = function (ast) {
        if (ast.type === 'Lookup') {
            canReflect.setKeyValue(ast, sourceTextSymbol, ast.key);
            ast.key = convertKeyToLookup(ast.key);
        }
        return ast;
    };
    var convertToHelperIfTopIsLookup = function (stack) {
        var top = stack.top();
        if (top && top.type === 'Lookup') {
            var base = stack.stack[stack.stack.length - 2];
            if (base.type !== 'Helper' && base) {
                stack.replaceTopAndPush({
                    type: 'Helper',
                    method: top
                });
            }
        }
    };
    var expression = {
        toComputeOrValue: toComputeOrValue,
        convertKeyToLookup: convertKeyToLookup,
        Literal: Literal,
        Lookup: Lookup,
        ScopeLookup: ScopeLookup,
        Arg: Arg,
        Hash: Hash,
        Hashes: Hashes,
        Call: Call,
        Helper: Helper,
        HelperLookup: HelperLookup,
        HelperScopeLookup: HelperScopeLookup,
        Bracket: Bracket,
        SetIdentifier: function (value) {
            this.value = value;
        },
        tokenize: function (expression) {
            var tokens = [];
            (expression.trim() + ' ').replace(tokensRegExp, function (whole, arg) {
                if (bracketSpaceRegExp.test(arg)) {
                    tokens.push(arg[0]);
                    tokens.push(arg.slice(1));
                } else {
                    tokens.push(arg);
                }
            });
            return tokens;
        },
        lookupRules: {
            'default': function (ast, methodType, isArg) {
                var name = (methodType === 'Helper' && !ast.root ? 'Helper' : '') + (isArg ? 'Scope' : '') + 'Lookup';
                return expression[name];
            },
            'method': function (ast, methodType, isArg) {
                return ScopeLookup;
            }
        },
        methodRules: {
            'default': function (ast) {
                return ast.type === 'Call' ? Call : Helper;
            },
            'call': function (ast) {
                return Call;
            }
        },
        parse: function (expressionString, options) {
            options = options || {};
            var ast = this.ast(expressionString);
            if (!options.lookupRule) {
                options.lookupRule = 'default';
            }
            if (typeof options.lookupRule === 'string') {
                options.lookupRule = expression.lookupRules[options.lookupRule];
            }
            if (!options.methodRule) {
                options.methodRule = 'default';
            }
            if (typeof options.methodRule === 'string') {
                options.methodRule = expression.methodRules[options.methodRule];
            }
            var expr = this.hydrateAst(ast, options, options.baseMethodType || 'Helper');
            return expr;
        },
        hydrateAst: function (ast, options, methodType, isArg) {
            var hashes;
            if (ast.type === 'Lookup') {
                var lookup = new (options.lookupRule(ast, methodType, isArg))(ast.key, ast.root && this.hydrateAst(ast.root, options, methodType), ast[sourceTextSymbol]);
                return lookup;
            } else if (ast.type === 'Literal') {
                return new Literal(ast.value);
            } else if (ast.type === 'Arg') {
                return new Arg(this.hydrateAst(ast.children[0], options, methodType, isArg), { compute: true });
            } else if (ast.type === 'Hash') {
                throw new Error('');
            } else if (ast.type === 'Hashes') {
                hashes = {};
                each(ast.children, function (hash) {
                    hashes[hash.prop] = this.hydrateAst(hash.children[0], options, methodType, true);
                }, this);
                return new Hashes(hashes);
            } else if (ast.type === 'Call' || ast.type === 'Helper') {
                hashes = {};
                var args = [], children = ast.children, ExpressionType = options.methodRule(ast);
                if (children) {
                    for (var i = 0; i < children.length; i++) {
                        var child = children[i];
                        if (child.type === 'Hashes' && ast.type === 'Helper' && ExpressionType !== Call) {
                            each(child.children, function (hash) {
                                hashes[hash.prop] = this.hydrateAst(hash.children[0], options, ast.type, true);
                            }, this);
                        } else {
                            args.push(this.hydrateAst(child, options, ast.type, true));
                        }
                    }
                }
                return new ExpressionType(this.hydrateAst(ast.method, options, ast.type), args, hashes);
            } else if (ast.type === 'Bracket') {
                return new Bracket(this.hydrateAst(ast.children[0], options), ast.root ? this.hydrateAst(ast.root, options) : undefined);
            }
        },
        ast: function (expression) {
            var tokens = this.tokenize(expression);
            return this.parseAst(tokens, { index: 0 });
        },
        parseAst: function (tokens, cursor) {
            var stack = new Stack(), top, firstParent, lastToken;
            while (cursor.index < tokens.length) {
                var token = tokens[cursor.index], nextToken = tokens[cursor.index + 1];
                cursor.index++;
                if (nextToken === '=') {
                    top = stack.top();
                    if (top && top.type === 'Lookup') {
                        firstParent = stack.firstParent([
                            'Call',
                            'Helper',
                            'Hash'
                        ]);
                        if (firstParent.type === 'Call' || firstParent.type === 'Root') {
                            stack.popUntil(['Call']);
                            top = stack.top();
                            stack.replaceTopAndPush({
                                type: 'Helper',
                                method: top.type === 'Root' ? last(top.children) : top
                            });
                        }
                    }
                    firstParent = stack.firstParent([
                        'Call',
                        'Helper',
                        'Hashes'
                    ]);
                    var hash = {
                        type: 'Hash',
                        prop: token
                    };
                    if (firstParent.type === 'Hashes') {
                        stack.addToAndPush(['Hashes'], hash);
                    } else {
                        stack.addToAndPush([
                            'Helper',
                            'Call'
                        ], {
                            type: 'Hashes',
                            children: [hash]
                        });
                        stack.push(hash);
                    }
                    cursor.index++;
                } else if (literalRegExp.test(token)) {
                    convertToHelperIfTopIsLookup(stack);
                    firstParent = stack.first([
                        'Helper',
                        'Call',
                        'Hash',
                        'Bracket'
                    ]);
                    if (firstParent.type === 'Hash' && (firstParent.children && firstParent.children.length > 0)) {
                        stack.addTo([
                            'Helper',
                            'Call',
                            'Bracket'
                        ], {
                            type: 'Literal',
                            value: utils.jsonParse(token)
                        });
                    } else if (firstParent.type === 'Bracket' && (firstParent.children && firstParent.children.length > 0)) {
                        stack.addTo([
                            'Helper',
                            'Call',
                            'Hash'
                        ], {
                            type: 'Literal',
                            value: utils.jsonParse(token)
                        });
                    } else {
                        stack.addTo([
                            'Helper',
                            'Call',
                            'Hash',
                            'Bracket'
                        ], {
                            type: 'Literal',
                            value: utils.jsonParse(token)
                        });
                    }
                } else if (keyRegExp.test(token)) {
                    lastToken = stack.topLastChild();
                    firstParent = stack.first([
                        'Helper',
                        'Call',
                        'Hash',
                        'Bracket'
                    ]);
                    if (lastToken && (lastToken.type === 'Call' || lastToken.type === 'Bracket') && isAddingToExpression(token)) {
                        stack.replaceTopLastChildAndPush({
                            type: 'Lookup',
                            root: lastToken,
                            key: token.slice(1)
                        });
                    } else if (firstParent.type === 'Bracket') {
                        if (!(firstParent.children && firstParent.children.length > 0)) {
                            stack.addToAndPush(['Bracket'], {
                                type: 'Lookup',
                                key: token
                            });
                        } else {
                            if (stack.first([
                                    'Helper',
                                    'Call',
                                    'Hash',
                                    'Arg'
                                ]).type === 'Helper' && token[0] !== '.') {
                                stack.addToAndPush(['Helper'], {
                                    type: 'Lookup',
                                    key: token
                                });
                            } else {
                                stack.replaceTopAndPush({
                                    type: 'Lookup',
                                    key: token.slice(1),
                                    root: firstParent
                                });
                            }
                        }
                    } else {
                        convertToHelperIfTopIsLookup(stack);
                        stack.addToAndPush([
                            'Helper',
                            'Call',
                            'Hash',
                            'Arg',
                            'Bracket'
                        ], {
                            type: 'Lookup',
                            key: token
                        });
                    }
                } else if (token === '~') {
                    convertToHelperIfTopIsLookup(stack);
                    stack.addToAndPush([
                        'Helper',
                        'Call',
                        'Hash'
                    ], {
                        type: 'Arg',
                        key: token
                    });
                } else if (token === '(') {
                    top = stack.top();
                    if (top.type === 'Lookup') {
                        stack.replaceTopAndPush({
                            type: 'Call',
                            method: convertToAtLookup(top)
                        });
                    } else {
                        throw new Error('Unable to understand expression ' + tokens.join(''));
                    }
                } else if (token === ')') {
                    stack.popTo(['Call']);
                } else if (token === ',') {
                    stack.popUntil(['Call']);
                } else if (token === '[') {
                    top = stack.top();
                    lastToken = stack.topLastChild();
                    if (lastToken && (lastToken.type === 'Call' || lastToken.type === 'Bracket')) {
                        stack.replaceTopAndPush({
                            type: 'Bracket',
                            root: lastToken
                        });
                    } else if (top.type === 'Lookup' || top.type === 'Bracket') {
                        stack.replaceTopAndPush({
                            type: 'Bracket',
                            root: top
                        });
                    } else if (top.type === 'Call') {
                        stack.addToAndPush(['Call'], { type: 'Bracket' });
                    } else if (top === ' ') {
                        stack.popUntil(['Lookup']);
                        convertToHelperIfTopIsLookup(stack);
                        stack.addToAndPush([
                            'Helper',
                            'Call',
                            'Hash'
                        ], { type: 'Bracket' });
                    } else {
                        stack.replaceTopAndPush({ type: 'Bracket' });
                    }
                } else if (token === ']') {
                    stack.pop();
                } else if (token === ' ') {
                    stack.push(token);
                }
            }
            return stack.root.children[0];
        }
    };
    module.exports = expression;
});
/*can-stache@4.0.0-pre.7#src/mustache_core*/
define('can-stache@4.0.0-pre.7#src/mustache_core', [
    'require',
    'exports',
    'module',
    'can-view-live',
    'can-view-nodelist',
    'can-observation',
    './utils',
    './expression',
    'can-util/dom/frag/frag',
    'can-util/dom/attr/attr',
    'can-symbol',
    'can-reflect'
], function (require, exports, module) {
    var live = require('can-view-live');
    var nodeLists = require('can-view-nodelist');
    var Observation = require('can-observation');
    var utils = require('./utils');
    var expression = require('./expression');
    var frag = require('can-util/dom/frag/frag');
    var attr = require('can-util/dom/attr/attr');
    var canSymbol = require('can-symbol');
    var canReflect = require('can-reflect');
    var mustacheLineBreakRegExp = /(?:(^|\r?\n)(\s*)(\{\{([\s\S]*)\}\}\}?)([^\S\n\r]*)($|\r?\n))|(\{\{([\s\S]*)\}\}\}?)/g, mustacheWhitespaceRegExp = /(\s*)(\{\{\{?)(-?)([\s\S]*?)(-?)(\}\}\}?)(\s*)/g, k = function () {
        };
    var core = {
        expression: expression,
        makeEvaluator: function (scope, helperOptions, nodeList, mode, exprData, truthyRenderer, falseyRenderer, stringOnly) {
            if (mode === '^') {
                var temp = truthyRenderer;
                truthyRenderer = falseyRenderer;
                falseyRenderer = temp;
            }
            var value, helperOptionArg;
            if (exprData instanceof expression.Call) {
                helperOptionArg = {
                    context: scope.peek('.'),
                    scope: scope,
                    nodeList: nodeList,
                    exprData: exprData,
                    helpersScope: helperOptions
                };
                utils.convertToScopes(helperOptionArg, scope, helperOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly);
                value = exprData.value(scope, helperOptions, helperOptionArg);
                if (exprData.isHelper) {
                    return value;
                }
            } else if (exprData instanceof expression.Bracket) {
                value = exprData.value(scope);
                if (exprData.isHelper) {
                    return value;
                }
            } else if (exprData instanceof expression.Lookup) {
                value = exprData.value(scope);
                if (exprData.isHelper) {
                    return value;
                }
            } else if (exprData instanceof expression.Helper && exprData.methodExpr instanceof expression.Bracket) {
                value = exprData.methodExpr.value(scope);
                if (exprData.isHelper) {
                    return value;
                }
            } else {
                var readOptions = {
                    isArgument: true,
                    args: [
                        scope.peek('.'),
                        scope
                    ],
                    asCompute: true
                };
                var helperAndValue = exprData.helperAndValue(scope, helperOptions, readOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly);
                var helper = helperAndValue.helper;
                value = helperAndValue.value;
                if (helper) {
                    return exprData.evaluator(helper, scope, helperOptions, readOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly);
                }
            }
            if (!mode) {
                return value;
            } else if (mode === '#' || mode === '^') {
                helperOptionArg = {};
                utils.convertToScopes(helperOptionArg, scope, helperOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly);
                return function () {
                    var finalValue = canReflect.getValue(value);
                    if (typeof finalValue === 'function') {
                        return finalValue;
                    } else if (typeof finalValue !== 'string' && utils.isArrayLike(finalValue)) {
                        var isObserveList = canReflect.isObservableLike(finalValue) && canReflect.isListLike(finalValue);
                        if (isObserveList ? finalValue.attr('length') : finalValue.length) {
                            if (stringOnly) {
                                return utils.getItemsStringContent(finalValue, isObserveList, helperOptionArg, helperOptions);
                            } else {
                                return frag(utils.getItemsFragContent(finalValue, helperOptionArg, scope));
                            }
                        } else {
                            return helperOptionArg.inverse(scope, helperOptions);
                        }
                    } else {
                        return finalValue ? helperOptionArg.fn(finalValue || scope, helperOptions) : helperOptionArg.inverse(scope, helperOptions);
                    }
                };
            } else {
            }
        },
        makeLiveBindingPartialRenderer: function (expressionString, state) {
            expressionString = expressionString.trim();
            var exprData, partialName = expressionString.split(/\s+/).shift();
            if (partialName !== expressionString) {
                exprData = core.expression.parse(expressionString);
            }
            return function (scope, options, parentSectionNodeList) {
                var nodeList = [this];
                nodeList.expression = '>' + partialName;
                nodeLists.register(nodeList, null, parentSectionNodeList || true, state.directlyNested);
                var partialFrag = new Observation(function () {
                    var localPartialName = partialName;
                    if (exprData && exprData.argExprs.length === 1) {
                        var newContext = canReflect.getValue(exprData.argExprs[0].value(scope, options));
                        if (typeof newContext === 'undefined') {
                        } else {
                            scope = scope.add(newContext);
                        }
                    }
                    var partial = options.peek('partials.' + localPartialName);
                    partial = partial || options.inlinePartials && options.inlinePartials[localPartialName];
                    var renderer;
                    if (partial) {
                        renderer = function () {
                            return partial.render ? partial.render(scope, options, nodeList) : partial(scope, options);
                        };
                    } else {
                        var scopePartialName = scope.read(localPartialName, { isArgument: true }).value;
                        if (scopePartialName === null || !scopePartialName && localPartialName[0] === '*') {
                            return frag('');
                        }
                        if (scopePartialName) {
                            localPartialName = scopePartialName;
                        }
                        renderer = function () {
                            if (typeof localPartialName === 'function') {
                                return localPartialName(scope, options, nodeList);
                            } else {
                                return core.getTemplateById(localPartialName)(scope, options, nodeList);
                            }
                        };
                    }
                    var res = Observation.ignore(renderer)();
                    return frag(res);
                });
                canReflect.setPriority(partialFrag, nodeList.nesting);
                live.html(this, partialFrag, this.parentNode, nodeList);
            };
        },
        makeStringBranchRenderer: function (mode, expressionString) {
            var exprData = core.expression.parse(expressionString), fullExpression = mode + expressionString;
            if (!(exprData instanceof expression.Helper) && !(exprData instanceof expression.Call)) {
                exprData = new expression.Helper(exprData, [], {});
            }
            var branchRenderer = function branchRenderer(scope, options, truthyRenderer, falseyRenderer) {
                var evaluator = scope.__cache[fullExpression];
                if (mode || !evaluator) {
                    evaluator = makeEvaluator(scope, options, null, mode, exprData, truthyRenderer, falseyRenderer, true);
                    if (!mode) {
                        scope.__cache[fullExpression] = evaluator;
                    }
                }
                var gotObservableValue = evaluator[canSymbol.for('can.onValue')], res;
                if (gotObservableValue) {
                    res = canReflect.getValue(evaluator);
                } else {
                    res = evaluator();
                }
                return res == null ? '' : '' + res;
            };
            branchRenderer.exprData = exprData;
            return branchRenderer;
        },
        makeLiveBindingBranchRenderer: function (mode, expressionString, state) {
            var exprData = core.expression.parse(expressionString);
            if (!(exprData instanceof expression.Helper) && !(exprData instanceof expression.Call) && !(exprData instanceof expression.Bracket) && !(exprData instanceof expression.Lookup)) {
                exprData = new expression.Helper(exprData, [], {});
            }
            var branchRenderer = function branchRenderer(scope, options, parentSectionNodeList, truthyRenderer, falseyRenderer) {
                var nodeList = [this];
                nodeList.expression = expressionString;
                nodeLists.register(nodeList, null, parentSectionNodeList || true, state.directlyNested);
                var evaluator = makeEvaluator(scope, options, nodeList, mode, exprData, truthyRenderer, falseyRenderer, state.tag);
                var gotObservableValue = evaluator[canSymbol.for('can.onValue')];
                var observable;
                if (gotObservableValue) {
                    observable = evaluator;
                } else {
                    observable = new Observation(evaluator, null, { isObservable: false });
                }
                if (canReflect.setPriority(observable, nodeList.nesting) === false) {
                    throw new Error('can-stache unable to set priority on observable');
                }
                canReflect.onValue(observable, k);
                var value = canReflect.getValue(observable);
                if (typeof value === 'function') {
                    Observation.ignore(value)(this);
                } else if (canReflect.valueHasDependencies(observable)) {
                    if (state.attr) {
                        live.attr(this, state.attr, observable);
                    } else if (state.tag) {
                        live.attrs(this, observable);
                    } else if (state.text && typeof value !== 'object') {
                        live.text(this, observable, this.parentNode, nodeList);
                    } else {
                        live.html(this, observable, this.parentNode, nodeList);
                    }
                } else {
                    if (state.attr) {
                        attr.set(this, state.attr, value);
                    } else if (state.tag) {
                        live.attrs(this, value);
                    } else if (state.text && typeof value === 'string') {
                        this.nodeValue = value;
                    } else if (value != null) {
                        nodeLists.replace([this], frag(value, this.ownerDocument));
                    }
                }
                canReflect.offValue(observable, k);
            };
            branchRenderer.exprData = exprData;
            return branchRenderer;
        },
        splitModeFromExpression: function (expression, state) {
            expression = expression.trim();
            var mode = expression.charAt(0);
            if ('#/{&^>!<'.indexOf(mode) >= 0) {
                expression = expression.substr(1).trim();
            } else {
                mode = null;
            }
            if (mode === '{' && state.node) {
                mode = null;
            }
            return {
                mode: mode,
                expression: expression
            };
        },
        cleanLineEndings: function (template) {
            return template.replace(mustacheLineBreakRegExp, function (whole, returnBefore, spaceBefore, special, expression, spaceAfter, returnAfter, spaceLessSpecial, spaceLessExpression, matchIndex) {
                spaceAfter = spaceAfter || '';
                returnBefore = returnBefore || '';
                spaceBefore = spaceBefore || '';
                var modeAndExpression = splitModeFromExpression(expression || spaceLessExpression, {});
                if (spaceLessSpecial || '>{'.indexOf(modeAndExpression.mode) >= 0) {
                    return whole;
                } else if ('^#!/'.indexOf(modeAndExpression.mode) >= 0) {
                    spaceBefore = returnBefore + spaceBefore && ' ';
                    return spaceBefore + special + (matchIndex !== 0 && returnAfter.length ? returnBefore + '\n' : '');
                } else {
                    return spaceBefore + special + spaceAfter + (spaceBefore.length || matchIndex !== 0 ? returnBefore + '\n' : '');
                }
            });
        },
        cleanWhitespaceControl: function (template) {
            return template.replace(mustacheWhitespaceRegExp, function (whole, spaceBefore, bracketBefore, controlBefore, expression, controlAfter, bracketAfter, spaceAfter, matchIndex) {
                if (controlBefore === '-') {
                    spaceBefore = '';
                }
                if (controlAfter === '-') {
                    spaceAfter = '';
                }
                return spaceBefore + bracketBefore + expression + bracketAfter + spaceAfter;
            });
        },
        Options: utils.Options,
        getTemplateById: function () {
        }
    };
    var makeEvaluator = core.makeEvaluator, splitModeFromExpression = core.splitModeFromExpression;
    module.exports = core;
});
/*can-stache@4.0.0-pre.7#src/html_section*/
define('can-stache@4.0.0-pre.7#src/html_section', [
    'require',
    'exports',
    'module',
    'can-view-target',
    'can-view-scope',
    'can-observation',
    './utils',
    './mustache_core',
    'can-util/dom/document/document',
    'can-util/js/assign/assign',
    'can-util/js/last/last'
], function (require, exports, module) {
    var target = require('can-view-target');
    var Scope = require('can-view-scope');
    var Observation = require('can-observation');
    var utils = require('./utils');
    var mustacheCore = require('./mustache_core');
    var getDocument = require('can-util/dom/document/document');
    var assign = require('can-util/js/assign/assign');
    var last = require('can-util/js/last/last');
    var decodeHTML = typeof document !== 'undefined' && function () {
        var el = getDocument().createElement('div');
        return function (html) {
            if (html.indexOf('&') === -1) {
                return html.replace(/\r\n/g, '\n');
            }
            el.innerHTML = html;
            return el.childNodes.length === 0 ? '' : el.childNodes.item(0).nodeValue;
        };
    }();
    var HTMLSectionBuilder = function () {
        this.stack = [new HTMLSection()];
    };
    HTMLSectionBuilder.scopify = function (renderer) {
        return Observation.ignore(function (scope, options, nodeList) {
            if (!(scope instanceof Scope)) {
                scope = Scope.refsScope().add(scope || {});
            }
            if (!(options instanceof mustacheCore.Options)) {
                options = new mustacheCore.Options(options || {});
            }
            return renderer(scope, options, nodeList);
        });
    };
    assign(HTMLSectionBuilder.prototype, utils.mixins);
    assign(HTMLSectionBuilder.prototype, {
        startSubSection: function (process) {
            var newSection = new HTMLSection(process);
            this.stack.push(newSection);
            return newSection;
        },
        endSubSectionAndReturnRenderer: function () {
            if (this.last().isEmpty()) {
                this.stack.pop();
                return null;
            } else {
                var htmlSection = this.endSection();
                return htmlSection.compiled.hydrate.bind(htmlSection.compiled);
            }
        },
        startSection: function (process) {
            var newSection = new HTMLSection(process);
            this.last().add(newSection.targetCallback);
            this.stack.push(newSection);
        },
        endSection: function () {
            this.last().compile();
            return this.stack.pop();
        },
        inverse: function () {
            this.last().inverse();
        },
        compile: function () {
            var compiled = this.stack.pop().compile();
            return Observation.ignore(function (scope, options, nodeList) {
                if (!(scope instanceof Scope)) {
                    scope = Scope.refsScope().add(scope || {});
                }
                if (!(options instanceof mustacheCore.Options)) {
                    options = new mustacheCore.Options(options || {});
                }
                return compiled.hydrate(scope, options, nodeList);
            });
        },
        push: function (chars) {
            this.last().push(chars);
        },
        pop: function () {
            return this.last().pop();
        },
        removeCurrentNode: function () {
            this.last().removeCurrentNode();
        }
    });
    var HTMLSection = function (process) {
        this.data = 'targetData';
        this.targetData = [];
        this.targetStack = [];
        var self = this;
        this.targetCallback = function (scope, options, sectionNode) {
            process.call(this, scope, options, sectionNode, self.compiled.hydrate.bind(self.compiled), self.inverseCompiled && self.inverseCompiled.hydrate.bind(self.inverseCompiled));
        };
    };
    assign(HTMLSection.prototype, {
        inverse: function () {
            this.inverseData = [];
            this.data = 'inverseData';
        },
        push: function (data) {
            this.add(data);
            this.targetStack.push(data);
        },
        pop: function () {
            return this.targetStack.pop();
        },
        add: function (data) {
            if (typeof data === 'string') {
                data = decodeHTML(data);
            }
            if (this.targetStack.length) {
                last(this.targetStack).children.push(data);
            } else {
                this[this.data].push(data);
            }
        },
        compile: function () {
            this.compiled = target(this.targetData, getDocument());
            if (this.inverseData) {
                this.inverseCompiled = target(this.inverseData, getDocument());
                delete this.inverseData;
            }
            this.targetStack = this.targetData = null;
            return this.compiled;
        },
        removeCurrentNode: function () {
            var children = this.children();
            return children.pop();
        },
        children: function () {
            if (this.targetStack.length) {
                return last(this.targetStack).children;
            } else {
                return this[this.data];
            }
        },
        isEmpty: function () {
            return !this.targetData.length;
        }
    });
    HTMLSectionBuilder.HTMLSection = HTMLSection;
    module.exports = HTMLSectionBuilder;
});
/*can-stache@4.0.0-pre.7#src/text_section*/
define('can-stache@4.0.0-pre.7#src/text_section', [
    'require',
    'exports',
    'module',
    'can-view-live',
    './utils',
    'can-util/dom/attr/attr',
    'can-util/js/assign/assign',
    'can-reflect',
    'can-observation'
], function (require, exports, module) {
    var live = require('can-view-live');
    var utils = require('./utils');
    var attr = require('can-util/dom/attr/attr');
    var assign = require('can-util/js/assign/assign');
    var canReflect = require('can-reflect');
    var Observation = require('can-observation');
    var noop = function () {
    };
    var TextSectionBuilder = function () {
        this.stack = [new TextSection()];
    };
    assign(TextSectionBuilder.prototype, utils.mixins);
    assign(TextSectionBuilder.prototype, {
        startSection: function (process) {
            var subSection = new TextSection();
            this.last().add({
                process: process,
                truthy: subSection
            });
            this.stack.push(subSection);
        },
        endSection: function () {
            this.stack.pop();
        },
        inverse: function () {
            this.stack.pop();
            var falseySection = new TextSection();
            this.last().last().falsey = falseySection;
            this.stack.push(falseySection);
        },
        compile: function (state) {
            var renderer = this.stack[0].compile();
            return function (scope, options) {
                function textSectionRender() {
                    return renderer(scope, options);
                }
                var observation = new Observation(textSectionRender, null, { isObservable: false });
                canReflect.onValue(observation, noop);
                var value = canReflect.getValue(observation);
                if (canReflect.valueHasDependencies(observation)) {
                    if (state.textContentOnly) {
                        live.text(this, observation);
                    } else if (state.attr) {
                        live.attr(this, state.attr, observation);
                    } else {
                        live.attrs(this, observation, scope, options);
                    }
                    canReflect.offValue(observation, noop);
                } else {
                    if (state.textContentOnly) {
                        this.nodeValue = value;
                    } else if (state.attr) {
                        attr.set(this, state.attr, value);
                    } else {
                        live.attrs(this, value);
                    }
                }
            };
        }
    });
    var passTruthyFalsey = function (process, truthy, falsey) {
        return function (scope, options) {
            return process.call(this, scope, options, truthy, falsey);
        };
    };
    var TextSection = function () {
        this.values = [];
    };
    assign(TextSection.prototype, {
        add: function (data) {
            this.values.push(data);
        },
        last: function () {
            return this.values[this.values.length - 1];
        },
        compile: function () {
            var values = this.values, len = values.length;
            for (var i = 0; i < len; i++) {
                var value = this.values[i];
                if (typeof value === 'object') {
                    values[i] = passTruthyFalsey(value.process, value.truthy && value.truthy.compile(), value.falsey && value.falsey.compile());
                }
            }
            return function (scope, options) {
                var txt = '', value;
                for (var i = 0; i < len; i++) {
                    value = values[i];
                    txt += typeof value === 'string' ? value : value.call(this, scope, options);
                }
                return txt;
            };
        }
    });
    module.exports = TextSectionBuilder;
});
/*can-stache@4.0.0-pre.7#helpers/converter*/
define('can-stache@4.0.0-pre.7#helpers/converter', [
    'require',
    'exports',
    'module',
    './core',
    '../src/expression',
    'can-util/js/make-array/make-array'
], function (require, exports, module) {
    var helpers = require('./core');
    var expression = require('../src/expression');
    var makeArray = require('can-util/js/make-array/make-array');
    helpers.registerConverter = function (name, getterSetter) {
        getterSetter = getterSetter || {};
        helpers.registerHelper(name, function (newVal, source) {
            var args = makeArray(arguments);
            if (newVal instanceof expression.SetIdentifier) {
                return typeof getterSetter.set === 'function' ? getterSetter.set.apply(this, [newVal.value].concat(args.slice(1))) : source(newVal.value);
            } else {
                return typeof getterSetter.get === 'function' ? getterSetter.get.apply(this, args) : args[0];
            }
        });
    };
    module.exports = helpers;
});
/*can-stache@4.0.0-pre.7#src/intermediate_and_imports*/
define('can-stache@4.0.0-pre.7#src/intermediate_and_imports', [
    'require',
    'exports',
    'module',
    './mustache_core',
    'can-view-parser'
], function (require, exports, module) {
    var mustacheCore = require('./mustache_core');
    var parser = require('can-view-parser');
    module.exports = function (source) {
        var template = source;
        template = mustacheCore.cleanWhitespaceControl(template);
        template = mustacheCore.cleanLineEndings(template);
        var imports = [], dynamicImports = [], ases = {}, inImport = false, inFrom = false, inAs = false, isUnary = false, importIsDynamic = false, currentAs = '', currentFrom = '';
        function processImport() {
            if (currentAs) {
                ases[currentAs] = currentFrom;
                currentAs = '';
            }
            if (importIsDynamic) {
                dynamicImports.push(currentFrom);
            } else {
                imports.push(currentFrom);
            }
        }
        var intermediate = parser(template, {
            start: function (tagName, unary) {
                if (tagName === 'can-import') {
                    isUnary = unary;
                    importIsDynamic = false;
                    inImport = true;
                } else if (tagName === 'can-dynamic-import') {
                    isUnary = unary;
                    importIsDynamic = true;
                    inImport = true;
                } else if (inImport) {
                    importIsDynamic = true;
                    inImport = false;
                }
            },
            attrStart: function (attrName) {
                if (attrName === 'from') {
                    inFrom = true;
                } else if (attrName === 'as' || attrName === 'export-as') {
                    inAs = true;
                }
            },
            attrEnd: function (attrName) {
                if (attrName === 'from') {
                    inFrom = false;
                } else if (attrName === 'as' || attrName === 'export-as') {
                    inAs = false;
                }
            },
            attrValue: function (value) {
                if (inFrom && inImport) {
                    currentFrom = value;
                } else if (inAs && inImport) {
                    currentAs = value;
                }
            },
            end: function (tagName) {
                if ((tagName === 'can-import' || tagName === 'can-dymamic-import') && isUnary) {
                    processImport();
                }
            },
            close: function (tagName) {
                if (tagName === 'can-import' || tagName === 'can-dymamic-import') {
                    processImport();
                }
            },
            chars: function (text) {
                if (text.trim().length > 0) {
                    importIsDynamic = true;
                }
            },
            special: function (text) {
                importIsDynamic = true;
            }
        }, true);
        return {
            intermediate: intermediate,
            imports: imports,
            dynamicImports: dynamicImports,
            ases: ases,
            exports: ases
        };
    };
});
/*can-util@3.10.12#js/import/import*/
define('can-util@3.10.12#js/import/import', [
    'require',
    'exports',
    'module',
    '../is-function/is-function',
    'can-globals/global/global'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var isFunction = require('../is-function/is-function');
        var global = require('can-globals/global/global')();
        module.exports = function (moduleName, parentName) {
            return new Promise(function (resolve, reject) {
                try {
                    if (typeof global.System === 'object' && isFunction(global.System['import'])) {
                        global.System['import'](moduleName, { name: parentName }).then(resolve, reject);
                    } else if (global.define && global.define.amd) {
                        global.require([moduleName], function (value) {
                            resolve(value);
                        });
                    } else if (global.require) {
                        resolve(global.require(moduleName));
                    } else {
                        resolve();
                    }
                } catch (err) {
                    reject(err);
                }
            });
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-stache@4.0.0-pre.7#can-stache*/
define('can-stache@4.0.0-pre.7#can-stache', [
    'require',
    'exports',
    'module',
    'can-view-parser',
    'can-view-callbacks',
    './src/html_section',
    './src/text_section',
    './src/mustache_core',
    './helpers/core',
    './helpers/converter',
    './src/intermediate_and_imports',
    './src/utils',
    'can-attribute-encoder',
    'can-util/js/dev/dev',
    'can-namespace',
    'can-util/dom/document/document',
    'can-util/js/assign/assign',
    'can-util/js/last/last',
    'can-util/js/import/import',
    'can-view-target',
    'can-view-nodelist'
], function (require, exports, module) {
    var parser = require('can-view-parser');
    var viewCallbacks = require('can-view-callbacks');
    var HTMLSectionBuilder = require('./src/html_section');
    var TextSectionBuilder = require('./src/text_section');
    var mustacheCore = require('./src/mustache_core');
    var mustacheHelpers = require('./helpers/core');
    require('./helpers/converter');
    var getIntermediateAndImports = require('./src/intermediate_and_imports');
    var makeRendererConvertScopes = require('./src/utils').makeRendererConvertScopes;
    var attributeEncoder = require('can-attribute-encoder');
    var dev = require('can-util/js/dev/dev');
    var namespace = require('can-namespace');
    var DOCUMENT = require('can-util/dom/document/document');
    var assign = require('can-util/js/assign/assign');
    var last = require('can-util/js/last/last');
    var importer = require('can-util/js/import/import');
    require('can-view-target');
    require('can-view-nodelist');
    viewCallbacks.tag('content', function (el, tagData) {
        return tagData.scope;
    });
    var wrappedAttrPattern = /[{(].*[)}]/;
    var colonWrappedAttrPattern = /^on:|(:to|:from|:bind)$|.*:to:on:.*/;
    var svgNamespace = 'http://www.w3.org/2000/svg';
    var namespaces = {
            'svg': svgNamespace,
            'g': svgNamespace
        }, textContentOnlyTag = {
            style: true,
            script: true
        };
    function stache(template) {
        var inlinePartials = {};
        if (typeof template === 'string') {
            template = mustacheCore.cleanWhitespaceControl(template);
            template = mustacheCore.cleanLineEndings(template);
        }
        var section = new HTMLSectionBuilder(), state = {
                node: null,
                attr: null,
                sectionElementStack: [],
                text: false,
                namespaceStack: [],
                textContentOnly: null
            }, makeRendererAndUpdateSection = function (section, mode, stache) {
                if (mode === '>') {
                    section.add(mustacheCore.makeLiveBindingPartialRenderer(stache, copyState()));
                } else if (mode === '/') {
                    var createdSection = section.last();
                    if (createdSection.startedWith === '<') {
                        inlinePartials[stache] = section.endSubSectionAndReturnRenderer();
                        section.removeCurrentNode();
                    } else {
                        section.endSection();
                    }
                    if (section instanceof HTMLSectionBuilder) {
                        state.sectionElementStack.pop();
                    }
                } else if (mode === 'else') {
                    section.inverse();
                } else {
                    var makeRenderer = section instanceof HTMLSectionBuilder ? mustacheCore.makeLiveBindingBranchRenderer : mustacheCore.makeStringBranchRenderer;
                    if (mode === '{' || mode === '&') {
                        section.add(makeRenderer(null, stache, copyState()));
                    } else if (mode === '#' || mode === '^' || mode === '<') {
                        var renderer = makeRenderer(mode, stache, copyState());
                        section.startSection(renderer);
                        section.last().startedWith = mode;
                        if (section instanceof HTMLSectionBuilder) {
                            state.sectionElementStack.push({ type: 'section' });
                        }
                    } else {
                        section.add(makeRenderer(null, stache, copyState({ text: true })));
                    }
                }
            }, copyState = function (overwrites) {
                var lastElement = state.sectionElementStack[state.sectionElementStack.length - 1];
                var cur = {
                    tag: state.node && state.node.tag,
                    attr: state.attr && state.attr.name,
                    directlyNested: state.sectionElementStack.length ? lastElement.type === 'section' || lastElement.type === 'custom' : true,
                    textContentOnly: !!state.textContentOnly
                };
                return overwrites ? assign(cur, overwrites) : cur;
            }, addAttributesCallback = function (node, callback) {
                if (!node.attributes) {
                    node.attributes = [];
                }
                node.attributes.unshift(callback);
            };
        parser(template, {
            start: function (tagName, unary) {
                var matchedNamespace = namespaces[tagName];
                if (matchedNamespace && !unary) {
                    state.namespaceStack.push(matchedNamespace);
                }
                state.node = {
                    tag: tagName,
                    children: [],
                    namespace: matchedNamespace || last(state.namespaceStack)
                };
            },
            end: function (tagName, unary) {
                var isCustomTag = viewCallbacks.tag(tagName);
                if (unary) {
                    section.add(state.node);
                    if (isCustomTag) {
                        addAttributesCallback(state.node, function (scope, options, parentNodeList) {
                            viewCallbacks.tagHandler(this, tagName, {
                                scope: scope,
                                options: options,
                                subtemplate: null,
                                templateType: 'stache',
                                parentNodeList: parentNodeList
                            });
                        });
                    }
                } else {
                    section.push(state.node);
                    state.sectionElementStack.push({
                        type: isCustomTag ? 'custom' : null,
                        tag: isCustomTag ? null : tagName,
                        templates: {}
                    });
                    if (isCustomTag) {
                        section.startSubSection();
                    } else if (textContentOnlyTag[tagName]) {
                        state.textContentOnly = new TextSectionBuilder();
                    }
                }
                state.node = null;
            },
            close: function (tagName) {
                var matchedNamespace = namespaces[tagName];
                if (matchedNamespace) {
                    state.namespaceStack.pop();
                }
                var isCustomTag = viewCallbacks.tag(tagName), renderer;
                if (isCustomTag) {
                    renderer = section.endSubSectionAndReturnRenderer();
                }
                if (textContentOnlyTag[tagName]) {
                    section.last().add(state.textContentOnly.compile(copyState()));
                    state.textContentOnly = null;
                }
                var oldNode = section.pop();
                if (isCustomTag) {
                    if (tagName === 'can-template') {
                        var parent = state.sectionElementStack[state.sectionElementStack.length - 2];
                        parent.templates[oldNode.attrs.name] = makeRendererConvertScopes(renderer);
                        section.removeCurrentNode();
                    } else {
                        var current = state.sectionElementStack[state.sectionElementStack.length - 1];
                        addAttributesCallback(oldNode, function (scope, options, parentNodeList) {
                            viewCallbacks.tagHandler(this, tagName, {
                                scope: scope,
                                options: options,
                                subtemplate: renderer ? makeRendererConvertScopes(renderer) : renderer,
                                templateType: 'stache',
                                parentNodeList: parentNodeList,
                                templates: current.templates
                            });
                        });
                    }
                }
                state.sectionElementStack.pop();
            },
            attrStart: function (attrName) {
                if (state.node.section) {
                    state.node.section.add(attrName + '="');
                } else {
                    state.attr = {
                        name: attrName,
                        value: ''
                    };
                }
            },
            attrEnd: function (attrName) {
                if (state.node.section) {
                    state.node.section.add('" ');
                } else {
                    if (!state.node.attrs) {
                        state.node.attrs = {};
                    }
                    state.node.attrs[state.attr.name] = state.attr.section ? state.attr.section.compile(copyState()) : state.attr.value;
                    var attrCallback = viewCallbacks.attr(attrName);
                    if (attrCallback) {
                        if (!state.node.attributes) {
                            state.node.attributes = [];
                        }
                        state.node.attributes.push(function (scope, options, nodeList) {
                            attrCallback(this, {
                                attributeName: attrName,
                                scope: scope,
                                options: options,
                                nodeList: nodeList
                            });
                        });
                    }
                    state.attr = null;
                }
            },
            attrValue: function (value) {
                var section = state.node.section || state.attr.section;
                if (section) {
                    section.add(value);
                } else {
                    state.attr.value += value;
                }
            },
            chars: function (text) {
                (state.textContentOnly || section).add(text);
            },
            special: function (text) {
                var firstAndText = mustacheCore.splitModeFromExpression(text, state), mode = firstAndText.mode, expression = firstAndText.expression;
                if (expression === 'else') {
                    var inverseSection;
                    if (state.attr && state.attr.section) {
                        inverseSection = state.attr.section;
                    } else if (state.node && state.node.section) {
                        inverseSection = state.node.section;
                    } else {
                        inverseSection = state.textContentOnly || section;
                    }
                    inverseSection.inverse();
                    return;
                }
                if (mode === '!') {
                    return;
                }
                if (state.node && state.node.section) {
                    makeRendererAndUpdateSection(state.node.section, mode, expression);
                    if (state.node.section.subSectionDepth() === 0) {
                        state.node.attributes.push(state.node.section.compile(copyState()));
                        delete state.node.section;
                    }
                } else if (state.attr) {
                    if (!state.attr.section) {
                        state.attr.section = new TextSectionBuilder();
                        if (state.attr.value) {
                            state.attr.section.add(state.attr.value);
                        }
                    }
                    makeRendererAndUpdateSection(state.attr.section, mode, expression);
                } else if (state.node) {
                    if (!state.node.attributes) {
                        state.node.attributes = [];
                    }
                    if (!mode) {
                        state.node.attributes.push(mustacheCore.makeLiveBindingBranchRenderer(null, expression, copyState()));
                    } else if (mode === '#' || mode === '^') {
                        if (!state.node.section) {
                            state.node.section = new TextSectionBuilder();
                        }
                        makeRendererAndUpdateSection(state.node.section, mode, expression);
                    } else {
                        throw new Error(mode + ' is currently not supported within a tag.');
                    }
                } else {
                    makeRendererAndUpdateSection(state.textContentOnly || section, mode, expression);
                }
            },
            comment: function (text) {
                section.add({ comment: text });
            },
            done: function () {
            }
        });
        var renderer = section.compile();
        var scopifiedRenderer = HTMLSectionBuilder.scopify(function (scope, optionsScope, nodeList) {
            if (Object.keys(inlinePartials).length) {
                optionsScope.inlinePartials = optionsScope.inlinePartials || {};
                assign(optionsScope.inlinePartials, inlinePartials);
            }
            scope.set('*self', scopifiedRenderer);
            return renderer.apply(this, arguments);
        });
        return scopifiedRenderer;
    }
    assign(stache, mustacheHelpers);
    stache.safeString = function (text) {
        return {
            toString: function () {
                return text;
            }
        };
    };
    stache.async = function (source) {
        var iAi = getIntermediateAndImports(source);
        var importPromises = iAi.imports.map(function (moduleName) {
            return importer(moduleName);
        });
        return Promise.all(importPromises).then(function () {
            return stache(iAi.intermediate);
        });
    };
    var templates = {};
    stache.from = mustacheCore.getTemplateById = function (id) {
        if (!templates[id]) {
            var el = DOCUMENT().getElementById(id);
            templates[id] = stache(el.innerHTML);
        }
        return templates[id];
    };
    stache.registerPartial = function (id, partial) {
        templates[id] = typeof partial === 'string' ? stache(partial) : partial;
    };
    module.exports = namespace.stache = stache;
});
/*can-util@3.10.12#dom/class-name/class-name*/
define('can-util@3.10.12#dom/class-name/class-name', function (require, exports, module) {
    'use strict';
    var has = function (className) {
        if (this.classList) {
            return this.classList.contains(className);
        } else {
            return !!this.className.match(new RegExp('(\\s|^)' + className + '(\\s|$)'));
        }
    };
    module.exports = {
        has: has,
        add: function (className) {
            if (this.classList) {
                this.classList.add(className);
            } else if (!has.call(this, className)) {
                this.className += ' ' + className;
            }
        },
        remove: function (className) {
            if (this.classList) {
                this.classList.remove(className);
            } else if (has.call(this, className)) {
                var reg = new RegExp('(\\s|^)' + className + '(\\s|$)');
                this.className = this.className.replace(reg, ' ');
            }
        }
    };
});
/*can-util@3.10.12#dom/matches/matches*/
define('can-util@3.10.12#dom/matches/matches', function (require, exports, module) {
    'use strict';
    var matchesMethod = function (element) {
        return element.matches || element.webkitMatchesSelector || element.webkitMatchesSelector || element.mozMatchesSelector || element.msMatchesSelector || element.oMatchesSelector;
    };
    module.exports = function () {
        var method = matchesMethod(this);
        return method ? method.apply(this, arguments) : false;
    };
});
/*can-util@3.10.12#dom/events/delegate/delegate*/
define('can-util@3.10.12#dom/events/delegate/delegate', [
    'require',
    'exports',
    'module',
    '../events',
    '../../data/data',
    '../../matches/matches',
    '../../../js/each/each',
    '../../../js/is-empty-object/is-empty-object'
], function (require, exports, module) {
    'use strict';
    var domEvents = require('../events');
    var domData = require('../../data/data');
    var domMatches = require('../../matches/matches');
    var each = require('../../../js/each/each');
    var isEmptyObject = require('../../../js/is-empty-object/is-empty-object');
    var dataName = 'delegateEvents';
    var useCapture = function (eventType) {
        return eventType === 'focus' || eventType === 'blur';
    };
    var handleEvent = function (ev) {
        var events = domData.get.call(this, dataName);
        var eventTypeEvents = events[ev.type];
        var matches = [];
        if (eventTypeEvents) {
            var selectorDelegates = [];
            each(eventTypeEvents, function (delegates) {
                selectorDelegates.push(delegates);
            });
            var cur = ev.target;
            do {
                selectorDelegates.forEach(function (delegates) {
                    if (domMatches.call(cur, delegates[0].selector)) {
                        matches.push({
                            target: cur,
                            delegates: delegates
                        });
                    }
                });
                cur = cur.parentNode;
            } while (cur && cur !== ev.currentTarget);
        }
        var oldStopProp = ev.stopPropagation;
        ev.stopPropagation = function () {
            oldStopProp.apply(this, arguments);
            this.cancelBubble = true;
        };
        for (var i = 0; i < matches.length; i++) {
            var match = matches[i];
            var delegates = match.delegates;
            for (var d = 0, dLen = delegates.length; d < dLen; d++) {
                if (delegates[d].handler.call(match.target, ev) === false) {
                    return false;
                }
                if (ev.cancelBubble) {
                    return;
                }
            }
        }
    };
    domEvents.addDelegateListener = function (eventType, selector, handler) {
        var events = domData.get.call(this, dataName), eventTypeEvents;
        if (!events) {
            domData.set.call(this, dataName, events = {});
        }
        if (!(eventTypeEvents = events[eventType])) {
            eventTypeEvents = events[eventType] = {};
            domEvents.addEventListener.call(this, eventType, handleEvent, useCapture(eventType));
        }
        if (!eventTypeEvents[selector]) {
            eventTypeEvents[selector] = [];
        }
        eventTypeEvents[selector].push({
            handler: handler,
            selector: selector
        });
    };
    domEvents.removeDelegateListener = function (eventType, selector, handler) {
        var events = domData.get.call(this, dataName);
        if (events && events[eventType] && events[eventType][selector]) {
            var eventTypeEvents = events[eventType], delegates = eventTypeEvents[selector], i = 0;
            while (i < delegates.length) {
                if (delegates[i].handler === handler) {
                    delegates.splice(i, 1);
                } else {
                    i++;
                }
            }
            if (delegates.length === 0) {
                delete eventTypeEvents[selector];
                if (isEmptyObject(eventTypeEvents)) {
                    domEvents.removeEventListener.call(this, eventType, handleEvent, useCapture(eventType));
                    delete events[eventType];
                    if (isEmptyObject(events)) {
                        domData.clean.call(this, dataName);
                    }
                }
            }
        }
    };
});
/*can-control@4.0.0-pre.2#can-control*/
define('can-control@4.0.0-pre.2#can-control', [
    'require',
    'exports',
    'module',
    'can-construct',
    'can-namespace',
    'can-util/js/string/string',
    'can-util/js/assign/assign',
    'can-util/js/is-function/is-function',
    'can-util/js/each/each',
    'can-util/js/dev/dev',
    'can-util/js/get/get',
    'can-util/dom/data/data',
    'can-util/dom/class-name/class-name',
    'can-util/dom/events/events',
    'can-stache-key',
    'can-reflect',
    'can-observation',
    'can-symbol',
    'can-util/dom/dispatch/dispatch',
    'can-util/dom/events/delegate/delegate'
], function (require, exports, module) {
    var Construct = require('can-construct');
    var namespace = require('can-namespace');
    var string = require('can-util/js/string/string');
    var assign = require('can-util/js/assign/assign');
    var isFunction = require('can-util/js/is-function/is-function');
    var each = require('can-util/js/each/each');
    var dev = require('can-util/js/dev/dev');
    var get = require('can-util/js/get/get');
    var domData = require('can-util/dom/data/data');
    var className = require('can-util/dom/class-name/class-name');
    var domEvents = require('can-util/dom/events/events');
    var observeReader = require('can-stache-key');
    var canReflect = require('can-reflect');
    var Observation = require('can-observation');
    var canSymbol = require('can-symbol');
    var processors;
    require('can-util/dom/dispatch/dispatch');
    require('can-util/dom/events/delegate/delegate');
    var onKeyValueSymbol = canSymbol.for('can.onKeyValue'), offKeyValueSymbol = canSymbol.for('can.offKeyValue'), onEventSymbol = canSymbol.for('can.onEvent'), offEventSymbol = canSymbol.for('can.offEvent'), onValueSymbol = canSymbol.for('can.onValue'), offValueSymbol = canSymbol.for('can.offValue');
    var canEvent = {
        on: function (eventName, handler, queue) {
            var listenWithDOM = domEvents.canAddEventListener.call(this);
            if (listenWithDOM) {
                var method = typeof handler === 'string' ? 'addDelegateListener' : 'addEventListener';
                domEvents[method].call(this, eventName, handler, queue);
            } else {
                if (this[onKeyValueSymbol]) {
                    canReflect.onKeyValue(this, eventName, handler, queue);
                } else if (this[onEventSymbol]) {
                    this[onEventSymbol](eventName, handler, queue);
                } else if ('addEventListener' in this) {
                    this.addEventListener(eventName, handler, queue);
                } else {
                    if (!eventName && this[onValueSymbol]) {
                        canReflect.onValue(this, handler);
                    } else {
                        throw new Error('can-control: Unable to bind ' + eventName);
                    }
                }
            }
        },
        off: function (eventName, handler, queue) {
            var listenWithDOM = domEvents.canAddEventListener.call(this);
            if (listenWithDOM) {
                var method = typeof handler === 'string' ? 'removeDelegateListener' : 'removeEventListener';
                domEvents[method].call(this, eventName, handler, queue);
            } else {
                if (this[offKeyValueSymbol]) {
                    canReflect.offKeyValue(this, eventName, handler, queue);
                } else if (this[offEventSymbol]) {
                    this[offEventSymbol](eventName, handler, queue);
                } else if ('removeEventListener' in this) {
                    this.removeEventListener(eventName, handler, queue);
                } else {
                    if (!eventName && this[offValueSymbol]) {
                        canReflect.offValue(this, handler);
                    } else {
                        throw new Error('can-control: Unable to unbind ' + eventName);
                    }
                }
            }
        }
    };
    var bind = function (el, ev, callback, queue) {
            canEvent.on.call(el, ev, callback, queue);
            return function () {
                canEvent.off.call(el, ev, callback, queue);
            };
        }, slice = [].slice, paramReplacer = /\{([^\}]+)\}/g, delegate = function (el, selector, ev, callback) {
            canEvent.on.call(el, ev, selector, callback);
            return function () {
                canEvent.off.call(el, ev, selector, callback);
            };
        }, binder = function (el, ev, callback, selector) {
            return selector ? delegate(el, selector.trim(), ev, callback) : bind(el, ev, callback);
        }, basicProcessor;
    var Control = Construct.extend('Control', {
        setup: function () {
            Construct.setup.apply(this, arguments);
            if (Control) {
                var control = this, funcName;
                control.actions = {};
                for (funcName in control.prototype) {
                    if (control._isAction(funcName)) {
                        control.actions[funcName] = control._action(funcName);
                    }
                }
            }
        },
        _shifter: function (context, name) {
            var method = typeof name === 'string' ? context[name] : name;
            if (!isFunction(method)) {
                method = context[method];
            }
            var Control = this;
            function controlMethod() {
                var wrapped = Control.wrapElement(this);
                context.called = name;
                return method.apply(context, [wrapped].concat(slice.call(arguments, 0)));
            }
            return controlMethod;
        },
        _isAction: function (methodName) {
            var val = this.prototype[methodName], type = typeof val;
            return methodName !== 'constructor' && (type === 'function' || type === 'string' && isFunction(this.prototype[val])) && !!(Control.isSpecial(methodName) || processors[methodName] || /[^\w]/.test(methodName));
        },
        _action: function (methodName, options, controlInstance) {
            var readyCompute, unableToBind;
            paramReplacer.lastIndex = 0;
            if (options || !paramReplacer.test(methodName)) {
                var controlActionData = function () {
                    var delegate;
                    var name = methodName.replace(paramReplacer, function (matched, key) {
                        var value, parent;
                        if (this._isDelegate(options, key)) {
                            delegate = this._getDelegate(options, key);
                            return '';
                        }
                        key = this._removeDelegateFromKey(key);
                        parent = this._lookup(options)[0];
                        value = observeReader.read(parent, observeReader.reads(key), { readCompute: false }).value;
                        if (value === undefined && typeof window !== 'undefined') {
                            value = get(window, key);
                        }
                        if (!parent || !(canReflect.isObservableLike(parent) && canReflect.isMapLike(parent)) && !value) {
                            unableToBind = true;
                            return null;
                        }
                        if (typeof value === 'string') {
                            return value;
                        } else {
                            delegate = value;
                            return '';
                        }
                    }.bind(this));
                    name = name.trim();
                    var parts = name.split(/\s+/g), event = parts.pop();
                    return {
                        processor: this.processors[event] || basicProcessor,
                        parts: [
                            name,
                            parts.join(' '),
                            event
                        ],
                        delegate: delegate || undefined
                    };
                };
                readyCompute = new Observation(controlActionData, this);
                if (controlInstance) {
                    var handler = function (actionData) {
                        controlInstance._bindings.control[methodName](controlInstance.element);
                        controlInstance._bindings.control[methodName] = actionData.processor(actionData.delegate || controlInstance.element, actionData.parts[2], actionData.parts[1], methodName, controlInstance);
                    };
                    canReflect.onValue(readyCompute, handler, 'mutate');
                    controlInstance._bindings.readyComputes[methodName] = {
                        compute: readyCompute,
                        handler: handler
                    };
                }
                return readyCompute.get();
            }
        },
        _lookup: function (options) {
            return [
                options,
                window
            ];
        },
        _removeDelegateFromKey: function (key) {
            return key;
        },
        _isDelegate: function (options, key) {
            return key === 'element';
        },
        _getDelegate: function (options, key) {
            return undefined;
        },
        processors: {},
        defaults: {},
        convertElement: function (element) {
            element = typeof element === 'string' ? document.querySelector(element) : element;
            return this.wrapElement(element);
        },
        wrapElement: function (el) {
            return el;
        },
        unwrapElement: function (el) {
            return el;
        },
        isSpecial: function (eventName) {
            return eventName === 'inserted' || eventName === 'removed';
        }
    }, {
        setup: function (element, options) {
            var cls = this.constructor, pluginname = cls.pluginName || cls.shortName, arr;
            if (!element) {
                throw new Error('Creating an instance of a named control without passing an element');
            }
            this.element = cls.convertElement(element);
            if (pluginname && pluginname !== 'Control') {
                className.add.call(this.element, pluginname);
            }
            arr = domData.get.call(this.element, 'controls');
            if (!arr) {
                arr = [];
                domData.set.call(this.element, 'controls', arr);
            }
            arr.push(this);
            if (canReflect.isObservableLike(options) && canReflect.isMapLike(options)) {
                for (var prop in cls.defaults) {
                    if (!options.hasOwnProperty(prop)) {
                        observeReader.set(options, prop, cls.defaults[prop]);
                    }
                }
                this.options = options;
            } else {
                this.options = assign(assign({}, cls.defaults), options);
            }
            this.on();
            return [
                this.element,
                this.options
            ];
        },
        on: function (el, selector, eventName, func) {
            if (!el) {
                this.off();
                var cls = this.constructor, bindings = this._bindings, actions = cls.actions, element = this.constructor.unwrapElement(this.element), destroyCB = Control._shifter(this, 'destroy'), funcName, ready;
                for (funcName in actions) {
                    if (actions.hasOwnProperty(funcName)) {
                        ready = actions[funcName] || cls._action(funcName, this.options, this);
                        if (ready) {
                            bindings.control[funcName] = ready.processor(ready.delegate || element, ready.parts[2], ready.parts[1], funcName, this);
                        }
                    }
                }
                domEvents.addEventListener.call(element, 'removed', destroyCB);
                bindings.user.push(function (el) {
                    domEvents.removeEventListener.call(el, 'removed', destroyCB);
                });
                return bindings.user.length;
            }
            if (typeof el === 'string') {
                func = eventName;
                eventName = selector;
                selector = el;
                el = this.element;
            }
            if (func === undefined) {
                func = eventName;
                eventName = selector;
                selector = null;
            }
            if (typeof func === 'string') {
                func = Control._shifter(this, func);
            }
            this._bindings.user.push(binder(el, eventName, func, selector));
            return this._bindings.user.length;
        },
        off: function () {
            var el = this.constructor.unwrapElement(this.element), bindings = this._bindings;
            if (bindings) {
                each(bindings.user || [], function (value) {
                    value(el);
                });
                each(bindings.control || {}, function (value) {
                    value(el);
                });
                each(bindings.readyComputes || {}, function (value) {
                    canReflect.offValue(value.compute, value.handler, 'mutate');
                });
            }
            this._bindings = {
                user: [],
                control: {},
                readyComputes: {}
            };
        },
        destroy: function () {
            if (this.element === null) {
                return;
            }
            var Class = this.constructor, pluginName = Class.pluginName || Class.shortName && string.underscore(Class.shortName), controls;
            this.off();
            if (pluginName && pluginName !== 'can_control') {
                className.remove.call(this.element, pluginName);
            }
            controls = domData.get.call(this.element, 'controls');
            if (controls) {
                controls.splice(controls.indexOf(this), 1);
            }
            this.element = null;
        }
    });
    processors = Control.processors;
    basicProcessor = function (el, event, selector, methodName, control) {
        return binder(el, event, Control._shifter(control, methodName), selector);
    };
    each([
        'beforeremove',
        'change',
        'click',
        'contextmenu',
        'dblclick',
        'keydown',
        'keyup',
        'keypress',
        'mousedown',
        'mousemove',
        'mouseout',
        'mouseover',
        'mouseup',
        'reset',
        'resize',
        'scroll',
        'select',
        'submit',
        'focusin',
        'focusout',
        'mouseenter',
        'mouseleave',
        'touchstart',
        'touchmove',
        'touchcancel',
        'touchend',
        'touchleave',
        'inserted',
        'removed',
        'dragstart',
        'dragenter',
        'dragover',
        'dragleave',
        'drag',
        'drop',
        'dragend'
    ], function (v) {
        processors[v] = basicProcessor;
    });
    module.exports = namespace.Control = Control;
});
/*can-component@4.0.0-pre.2#control/control*/
define('can-component@4.0.0-pre.2#control/control', [
    'require',
    'exports',
    'module',
    'can-control',
    'can-util/js/each/each',
    'can-reflect'
], function (require, exports, module) {
    var Control = require('can-control');
    var canEach = require('can-util/js/each/each');
    var canReflect = require('can-reflect');
    var paramReplacer = /\{([^\}]+)\}/g;
    var ComponentControl = Control.extend({
        _lookup: function (options) {
            return [
                options.scope,
                options,
                window
            ];
        },
        _removeDelegateFromKey: function (key) {
            return key.replace(/^(scope|^viewModel)\./, '');
        },
        _isDelegate: function (options, key) {
            return key === 'scope' || key === 'viewModel';
        },
        _getDelegate: function (options, key) {
            return options[key];
        },
        _action: function (methodName, options, controlInstance) {
            var hasObjectLookup;
            paramReplacer.lastIndex = 0;
            hasObjectLookup = paramReplacer.test(methodName);
            if (!controlInstance && hasObjectLookup) {
                return;
            } else {
                return Control._action.apply(this, arguments);
            }
        }
    }, {
        setup: function (el, options) {
            this.scope = options.scope;
            this.viewModel = options.viewModel;
            return Control.prototype.setup.call(this, el, options);
        },
        off: function () {
            if (this._bindings) {
                canEach(this._bindings.readyComputes || {}, function (value) {
                    canReflect.offValue(value.compute, value.handler);
                });
            }
            Control.prototype.off.apply(this, arguments);
            this._bindings.readyComputes = {};
        },
        destroy: function () {
            Control.prototype.destroy.apply(this, arguments);
            if (typeof this.options.destroy === 'function') {
                this.options.destroy.apply(this, arguments);
            }
        }
    });
    module.exports = ComponentControl;
});
/*can-view-model@4.0.0-pre.3#can-view-model*/
define('can-view-model@4.0.0-pre.3#can-view-model', [
    'require',
    'exports',
    'module',
    'can-util/dom/data/data',
    'can-simple-map',
    'can-namespace',
    'can-util/dom/document/document',
    'can-util/js/is-array-like/is-array-like',
    'can-reflect'
], function (require, exports, module) {
    'use strict';
    var domData = require('can-util/dom/data/data');
    var SimpleMap = require('can-simple-map');
    var ns = require('can-namespace');
    var getDocument = require('can-util/dom/document/document');
    var isArrayLike = require('can-util/js/is-array-like/is-array-like');
    var canReflect = require('can-reflect');
    module.exports = ns.viewModel = function (el, attr, val) {
        var scope;
        if (typeof el === 'string') {
            el = getDocument().querySelector(el);
        } else if (isArrayLike(el) && !el.nodeType) {
            el = el[0];
        }
        if (canReflect.isObservableLike(attr) && canReflect.isMapLike(attr)) {
            return domData.set.call(el, 'viewModel', attr);
        }
        scope = domData.get.call(el, 'viewModel');
        if (!scope) {
            scope = new SimpleMap();
            domData.set.call(el, 'viewModel', scope);
        }
        switch (arguments.length) {
        case 0:
        case 1:
            return scope;
        case 2:
            return canReflect.getKeyValue(scope, attr);
        default:
            canReflect.setKeyValue(scope, attr, val);
            return el;
        }
    };
});
/*can-dom-events@1.0.4#helpers/util*/
define('can-dom-events@1.0.4#helpers/util', [
    'require',
    'exports',
    'module',
    'can-globals/document/document',
    'can-globals/is-browser-window/is-browser-window'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var getCurrentDocument = require('can-globals/document/document');
        var isBrowserWindow = require('can-globals/is-browser-window/is-browser-window');
        function getTargetDocument(target) {
            return target.ownerDocument || getCurrentDocument();
        }
        function createEvent(target, eventData, bubbles, cancelable) {
            var doc = getTargetDocument(target);
            var event = doc.createEvent('HTMLEvents');
            var eventType;
            if (typeof eventData === 'string') {
                eventType = eventData;
            } else {
                eventType = eventData.type;
                for (var prop in eventData) {
                    if (event[prop] === undefined) {
                        event[prop] = eventData[prop];
                    }
                }
            }
            if (bubbles === undefined) {
                bubbles = true;
            }
            event.initEvent(eventType, bubbles, cancelable);
            return event;
        }
        function isDomEventTarget(obj) {
            if (!(obj && obj.nodeName)) {
                return obj === window;
            }
            var nodeType = obj.nodeType;
            return nodeType === Node.DOCUMENT_NODE || nodeType === Node.ELEMENT_NODE;
        }
        function addDomContext(context, args) {
            if (isDomEventTarget(context)) {
                args = Array.prototype.slice.call(args, 0);
                args.unshift(context);
            }
            return args;
        }
        function removeDomContext(context, args) {
            if (!isDomEventTarget(context)) {
                args = Array.prototype.slice.call(args, 0);
                context = args.shift();
            }
            return {
                context: context,
                args: args
            };
        }
        var fixSyntheticEventsOnDisabled = false;
        (function () {
            if (!isBrowserWindow()) {
                return;
            }
            var testEventName = 'fix_synthetic_events_on_disabled_test';
            var input = document.createElement('input');
            input.disabled = true;
            var timer = setTimeout(function () {
                fixSyntheticEventsOnDisabled = true;
            }, 50);
            var onTest = function onTest() {
                clearTimeout(timer);
                input.removeEventListener(testEventName, onTest);
            };
            input.addEventListener(testEventName, onTest);
            try {
                var event = document.create('HTMLEvents');
                event.initEvent(testEventName, false);
                input.dispatchEvent(event);
            } catch (e) {
                onTest();
                fixSyntheticEventsOnDisabled = true;
            }
        }());
        function isDispatchingOnDisabled(element, event) {
            var eventType = event.type;
            var isInsertedOrRemoved = eventType === 'inserted' || eventType === 'removed';
            var isDisabled = !!element.disabled;
            return isInsertedOrRemoved && isDisabled;
        }
        function forceEnabledForDispatch(element, event) {
            return fixSyntheticEventsOnDisabled && isDispatchingOnDisabled(element, event);
        }
        module.exports = {
            createEvent: createEvent,
            addDomContext: addDomContext,
            removeDomContext: removeDomContext,
            isDomEventTarget: isDomEventTarget,
            getTargetDocument: getTargetDocument,
            forceEnabledForDispatch: forceEnabledForDispatch
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-dom-events@1.0.4#helpers/add-event-compat*/
define('can-dom-events@1.0.4#helpers/add-event-compat', [
    'require',
    'exports',
    'module',
    './util'
], function (require, exports, module) {
    'use strict';
    var util = require('./util');
    var addDomContext = util.addDomContext;
    var removeDomContext = util.removeDomContext;
    function isDomEvents(obj) {
        return !!(obj && obj.addEventListener && obj.removeEventListener && obj.dispatch);
    }
    function isNewEvents(obj) {
        return typeof obj.addEvent === 'function';
    }
    module.exports = function addEventCompat(domEvents, customEvent, customEventType) {
        if (!isDomEvents(domEvents)) {
            throw new Error('addEventCompat() must be passed can-dom-events or can-util/dom/events/events');
        }
        customEventType = customEventType || customEvent.defaultEventType;
        if (isNewEvents(domEvents)) {
            return domEvents.addEvent(customEvent, customEventType);
        }
        var registry = domEvents._compatRegistry;
        if (!registry) {
            registry = domEvents._compatRegistry = {};
        }
        if (registry[customEventType]) {
            return function noopRemoveOverride() {
            };
        }
        registry[customEventType] = customEvent;
        var newEvents = {
            addEventListener: function () {
                var data = removeDomContext(this, arguments);
                return domEvents.addEventListener.apply(data.context, data.args);
            },
            removeEventListener: function () {
                var data = removeDomContext(this, arguments);
                return domEvents.removeEventListener.apply(data.context, data.args);
            },
            dispatch: function () {
                var data = removeDomContext(this, arguments);
                var eventData = data.args[0];
                var eventArgs = typeof eventData === 'object' ? eventData.args : [];
                data.args.splice(1, 0, eventArgs);
                return domEvents.dispatch.apply(data.context, data.args);
            }
        };
        var isOverriding = true;
        var oldAddEventListener = domEvents.addEventListener;
        var addEventListener = domEvents.addEventListener = function addEventListener(eventName) {
            if (isOverriding && eventName === customEventType) {
                var args = addDomContext(this, arguments);
                customEvent.addEventListener.apply(newEvents, args);
            }
            return oldAddEventListener.apply(this, arguments);
        };
        var oldRemoveEventListener = domEvents.removeEventListener;
        var removeEventListener = domEvents.removeEventListener = function removeEventListener(eventName) {
            if (isOverriding && eventName === customEventType) {
                var args = addDomContext(this, arguments);
                customEvent.removeEventListener.apply(newEvents, args);
            }
            return oldRemoveEventListener.apply(this, arguments);
        };
        return function removeOverride() {
            isOverriding = false;
            registry[customEventType] = null;
            if (domEvents.addEventListener === addEventListener) {
                domEvents.addEventListener = oldAddEventListener;
            }
            if (domEvents.removeEventListener === removeEventListener) {
                domEvents.removeEventListener = oldRemoveEventListener;
            }
        };
    };
});
/*can-event-dom-enter@1.0.2#can-event-dom-enter*/
define('can-event-dom-enter@1.0.2#can-event-dom-enter', [
    'require',
    'exports',
    'module',
    'can-dom-data-state',
    'can-cid'
], function (require, exports, module) {
    'use strict';
    var domData = require('can-dom-data-state');
    var canCid = require('can-cid');
    var baseEventType = 'keyup';
    function isEnterEvent(event) {
        var hasEnterKey = event.key === 'Enter';
        var hasEnterCode = event.keyCode === 13;
        return hasEnterKey || hasEnterCode;
    }
    function getHandlerKey(eventType, handler) {
        return eventType + ':' + canCid(handler);
    }
    function associateHandler(target, eventType, handler, otherHandler) {
        var key = getHandlerKey(eventType, handler);
        domData.set.call(target, key, otherHandler);
    }
    function disassociateHandler(target, eventType, handler) {
        var key = getHandlerKey(eventType, handler);
        var otherHandler = domData.get.call(target, key);
        if (otherHandler) {
            domData.clean.call(target, key);
        }
        return otherHandler;
    }
    module.exports = {
        defaultEventType: 'enter',
        addEventListener: function (target, eventType, handler) {
            var keyHandler = function (event) {
                if (isEnterEvent(event)) {
                    return handler.apply(this, arguments);
                }
            };
            associateHandler(target, eventType, handler, keyHandler);
            this.addEventListener(target, baseEventType, keyHandler);
        },
        removeEventListener: function (target, eventType, handler) {
            var keyHandler = disassociateHandler(target, eventType, handler);
            if (keyHandler) {
                this.removeEventListener(target, baseEventType, keyHandler);
            }
        }
    };
});
/*can-event-dom-enter@1.0.2#compat*/
define('can-event-dom-enter@1.0.2#compat', [
    'require',
    'exports',
    'module',
    'can-dom-events/helpers/add-event-compat',
    './can-event-dom-enter'
], function (require, exports, module) {
    var addEventCompat = require('can-dom-events/helpers/add-event-compat');
    var radioChange = require('./can-event-dom-enter');
    module.exports = function (domEvents, eventType) {
        return addEventCompat(domEvents, radioChange, eventType);
    };
});
/*can-dom-events@1.0.4#helpers/make-event-registry*/
define('can-dom-events@1.0.4#helpers/make-event-registry', function (require, exports, module) {
    'use strict';
    function EventRegistry() {
        this._registry = {};
    }
    module.exports = function makeEventRegistry() {
        return new EventRegistry();
    };
    EventRegistry.prototype.has = function (eventType) {
        return !!this._registry[eventType];
    };
    EventRegistry.prototype.get = function (eventType) {
        return this._registry[eventType];
    };
    EventRegistry.prototype.add = function (event, eventType) {
        if (!event) {
            throw new Error('An EventDefinition must be provided');
        }
        if (typeof event.addEventListener !== 'function') {
            throw new TypeError('EventDefinition addEventListener must be a function');
        }
        if (typeof event.removeEventListener !== 'function') {
            throw new TypeError('EventDefinition removeEventListener must be a function');
        }
        eventType = eventType || event.defaultEventType;
        if (typeof eventType !== 'string') {
            throw new TypeError('Event type must be a string, not ' + eventType);
        }
        if (this.has(eventType)) {
            throw new Error('Event "' + eventType + '" is already registered');
        }
        this._registry[eventType] = event;
        var self = this;
        return function remove() {
            self._registry[eventType] = undefined;
        };
    };
});
/*can-dom-events@1.0.4#can-dom-events*/
define('can-dom-events@1.0.4#can-dom-events', [
    'require',
    'exports',
    'module',
    'can-namespace',
    './helpers/util',
    './helpers/make-event-registry'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var namespace = require('can-namespace');
        var util = require('./helpers/util');
        var makeEventRegistry = require('./helpers/make-event-registry');
        var domEvents = {
            _eventRegistry: makeEventRegistry(),
            addEvent: function (event, eventType) {
                return this._eventRegistry.add(event, eventType);
            },
            addEventListener: function (target, eventType) {
                var hasCustomEvent = domEvents._eventRegistry.has(eventType);
                if (hasCustomEvent) {
                    var event = domEvents._eventRegistry.get(eventType);
                    return event.addEventListener.apply(domEvents, arguments);
                }
                var eventArgs = Array.prototype.slice.call(arguments, 1);
                return target.addEventListener.apply(target, eventArgs);
            },
            removeEventListener: function (target, eventType) {
                var hasCustomEvent = domEvents._eventRegistry.has(eventType);
                if (hasCustomEvent) {
                    var event = domEvents._eventRegistry.get(eventType);
                    return event.removeEventListener.apply(domEvents, arguments);
                }
                var eventArgs = Array.prototype.slice.call(arguments, 1);
                return target.removeEventListener.apply(target, eventArgs);
            },
            dispatch: function (target, eventData, bubbles, cancelable) {
                var event = util.createEvent(target, eventData, bubbles, cancelable);
                var enableForDispatch = util.forceEnabledForDispatch(target, event);
                if (enableForDispatch) {
                    target.disabled = false;
                }
                var ret = target.dispatchEvent(event);
                if (enableForDispatch) {
                    target.disabled = true;
                }
                return ret;
            }
        };
        module.exports = namespace.domEvents = domEvents;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-event-dom-radiochange@1.0.2#can-event-dom-radiochange*/
define('can-event-dom-radiochange@1.0.2#can-event-dom-radiochange', [
    'require',
    'exports',
    'module',
    'can-dom-data-state',
    'can-globals/document/document',
    'can-dom-events',
    'can-cid/map/map'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var domData = require('can-dom-data-state');
        var getDocument = require('can-globals/document/document');
        var domEvents = require('can-dom-events');
        var CIDMap = require('can-cid/map/map');
        function getRoot(el) {
            return el.ownerDocument || getDocument().documentElement;
        }
        function getRegistryName(eventName) {
            return 'can-event-radiochange:' + eventName + ':registry';
        }
        function getListenerName(eventName) {
            return 'can-event-radiochange:' + eventName + ':listener';
        }
        function getRegistry(root, eventName) {
            var name = getRegistryName(eventName);
            var registry = domData.get.call(root, name);
            if (!registry) {
                registry = new CIDMap();
                domData.set.call(root, name, registry);
            }
            return registry;
        }
        function findParentForm(el) {
            while (el) {
                if (el.nodeName === 'FORM') {
                    break;
                }
                el = el.parentNode;
            }
            return el;
        }
        function shouldReceiveEventFromRadio(source, dest) {
            var name = source.getAttribute('name');
            return name && name === dest.getAttribute('name') && findParentForm(source) === findParentForm(dest);
        }
        function isRadioInput(el) {
            return el.nodeName === 'INPUT' && el.type === 'radio';
        }
        function dispatch(eventName, target) {
            var root = getRoot(target);
            var registry = getRegistry(root, eventName);
            registry.forEach(function (el) {
                if (shouldReceiveEventFromRadio(target, el)) {
                    domEvents.dispatch(el, eventName);
                }
            });
        }
        function attachRootListener(root, eventName, events) {
            var listenerName = getListenerName(eventName);
            var listener = domData.get.call(root, listenerName);
            if (listener) {
                return;
            }
            var newListener = function (event) {
                var target = event.target;
                if (isRadioInput(target)) {
                    dispatch(eventName, target);
                }
            };
            events.addEventListener(root, 'change', newListener);
            domData.set.call(root, listenerName, newListener);
        }
        function detachRootListener(root, eventName, events) {
            var listenerName = getListenerName(eventName);
            var listener = domData.get.call(root, listenerName);
            if (!listener) {
                return;
            }
            var registry = getRegistry(root, eventName);
            if (registry.size > 0) {
                return;
            }
            events.removeEventListener(root, 'change', listener);
            domData.clean.call(root, listenerName);
        }
        function addListener(eventName, el, events) {
            if (!isRadioInput(el)) {
                throw new Error('Listeners for ' + eventName + ' must be radio inputs');
            }
            var root = getRoot(el);
            getRegistry(root, eventName).set(el, el);
            attachRootListener(root, eventName, events);
        }
        function removeListener(eventName, el, events) {
            var root = getRoot(el);
            getRegistry(root, eventName).delete(el);
            detachRootListener(root, eventName, events);
        }
        module.exports = {
            defaultEventType: 'radiochange',
            addEventListener: function (target, eventName, handler) {
                addListener(eventName, target, this);
                target.addEventListener(eventName, handler);
            },
            removeEventListener: function (target, eventName, handler) {
                removeListener(eventName, target, this);
                target.removeEventListener(eventName, handler);
            }
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-event-dom-radiochange@1.0.2#compat*/
define('can-event-dom-radiochange@1.0.2#compat', [
    'require',
    'exports',
    'module',
    'can-dom-events/helpers/add-event-compat',
    './can-event-dom-radiochange'
], function (require, exports, module) {
    var addEventCompat = require('can-dom-events/helpers/add-event-compat');
    var radioChange = require('./can-event-dom-radiochange');
    module.exports = function (domEvents, eventType) {
        return addEventCompat(domEvents, radioChange, eventType);
    };
});
/*can-stache-bindings@4.0.0-pre.8#can-stache-bindings*/
define('can-stache-bindings@4.0.0-pre.8#can-stache-bindings', [
    'require',
    'exports',
    'module',
    'can-stache/src/expression',
    'can-view-callbacks',
    'can-view-scope',
    'can-view-model',
    'can-stache-key',
    'can-observation',
    'can-simple-observable',
    'can-util/js/assign/assign',
    'can-util/js/make-array/make-array',
    'can-util/js/each/each',
    'can-util/js/dev/dev',
    'can-util/dom/events/events',
    'can-util/dom/events/removed/removed',
    'can-util/dom/data/data',
    'can-util/dom/attr/attr',
    'can-stache/helpers/core',
    'can-symbol',
    'can-reflect',
    'can-util/js/single-reference/single-reference',
    'can-attribute-encoder',
    'can-queues',
    'can-simple-observable/setter/setter',
    'can-view-scope/make-compute-like',
    'can-event-dom-enter/compat',
    'can-event-dom-radiochange/compat'
], function (require, exports, module) {
    var expression = require('can-stache/src/expression');
    var viewCallbacks = require('can-view-callbacks');
    var Scope = require('can-view-scope');
    var canViewModel = require('can-view-model');
    var observeReader = require('can-stache-key');
    var Observation = require('can-observation');
    var SimpleObservable = require('can-simple-observable');
    var assign = require('can-util/js/assign/assign');
    var makeArray = require('can-util/js/make-array/make-array');
    var each = require('can-util/js/each/each');
    var dev = require('can-util/js/dev/dev');
    var domEvents = require('can-util/dom/events/events');
    require('can-util/dom/events/removed/removed');
    var domData = require('can-util/dom/data/data');
    var attr = require('can-util/dom/attr/attr');
    var stacheHelperCore = require('can-stache/helpers/core');
    var canSymbol = require('can-symbol');
    var canReflect = require('can-reflect');
    var singleReference = require('can-util/js/single-reference/single-reference');
    var encoder = require('can-attribute-encoder');
    var queues = require('can-queues');
    var SettableObservable = require('can-simple-observable/setter/setter');
    var makeCompute = require('can-view-scope/make-compute-like');
    var addEnterEvent = require('can-event-dom-enter/compat');
    addEnterEvent(domEvents);
    var addRadioChange = require('can-event-dom-radiochange/compat');
    addRadioChange(domEvents);
    var canEvent = {
        on: function (eventName, handler, queue) {
            var listenWithDOM = domEvents.canAddEventListener.call(this);
            if (listenWithDOM) {
                domEvents.addEventListener.call(this, eventName, handler, queue);
            } else {
                canReflect.onKeyValue(this, eventName, handler, queue);
            }
        },
        off: function (eventName, handler, queue) {
            var listenWithDOM = domEvents.canAddEventListener.call(this);
            if (listenWithDOM) {
                domEvents.removeEventListener.call(this, eventName, handler, queue);
            } else {
                canReflect.offKeyValue(this, eventName, handler, queue);
            }
        },
        one: function (event, handler, queue) {
            var one = function () {
                canEvent.off.call(this, event, one, queue);
                return handler.apply(this, arguments);
            };
            canEvent.on.call(this, event, one, queue);
            return this;
        }
    };
    var noop = function () {
    };
    var onMatchStr = 'on:', vmMatchStr = 'vm:', elMatchStr = 'el:', byMatchStr = ':by:', toMatchStr = ':to', fromMatchStr = ':from', bindMatchStr = ':bind', attributesEventStr = 'attributes', removedStr = 'removed', viewModelBindingStr = 'viewModel', attributeBindingStr = 'attribute', scopeBindingStr = 'scope', viewModelOrAttributeBindingStr = 'viewModelOrAttribute', getValueSymbol = canSymbol.for('can.getValue'), setValueSymbol = canSymbol.for('can.setValue'), onValueSymbol = canSymbol.for('can.onValue'), offValueSymbol = canSymbol.for('can.offValue');
    var throwOnlyOneTypeOfBindingError = function () {
        throw new Error('can-stache-bindings - you can not have contextual bindings ( this:from=\'value\' ) and key bindings ( prop:from=\'value\' ) on one element.');
    };
    var checkBindingState = function (bindingState, dataBinding) {
        var isSettingOnViewModel = dataBinding.bindingInfo.parentToChild && dataBinding.bindingInfo.child === viewModelBindingStr;
        if (isSettingOnViewModel) {
            var bindingName = dataBinding.bindingInfo.childName;
            var isSettingViewModel = isSettingOnViewModel && (bindingName === 'this' || bindingName === '.');
            if (isSettingViewModel) {
                if (bindingState.isSettingViewModel || bindingState.isSettingOnViewModel) {
                    throwOnlyOneTypeOfBindingError();
                } else {
                    return {
                        isSettingViewModel: true,
                        initialViewModelData: undefined
                    };
                }
            } else {
                if (bindingState.isSettingViewModel) {
                    throwOnlyOneTypeOfBindingError();
                } else {
                    return {
                        isSettingOnViewModel: true,
                        initialViewModelData: bindingState.initialViewModelData
                    };
                }
            }
        } else {
            return bindingState;
        }
    };
    var behaviors = {
        viewModel: function (el, tagData, makeViewModel, initialViewModelData, staticDataBindingsOnly) {
            var bindingsSemaphore = {}, viewModel, onCompleteBindings = [], onTeardowns = {}, bindingInfos = {}, attributeViewModelBindings = assign({}, initialViewModelData), bindingsState = {
                    isSettingOnViewModel: false,
                    isSettingViewModel: false,
                    initialViewModelData: initialViewModelData || {}
                }, hasDataBinding = false;
            each(makeArray(el.attributes), function (node) {
                var dataBinding = makeDataBinding(node, el, {
                    templateType: tagData.templateType,
                    scope: tagData.scope,
                    semaphore: bindingsSemaphore,
                    getViewModel: function () {
                        return viewModel;
                    },
                    attributeViewModelBindings: attributeViewModelBindings,
                    alreadyUpdatedChild: true,
                    nodeList: tagData.parentNodeList,
                    favorViewModel: true
                });
                if (dataBinding) {
                    bindingsState = checkBindingState(bindingsState, dataBinding);
                    hasDataBinding = true;
                    if (dataBinding.onCompleteBinding) {
                        if (dataBinding.bindingInfo.parentToChild && dataBinding.value !== undefined) {
                            if (bindingsState.isSettingViewModel) {
                                bindingsState.initialViewModelData = dataBinding.value;
                            } else {
                                bindingsState.initialViewModelData[cleanVMName(dataBinding.bindingInfo.childName)] = dataBinding.value;
                            }
                        }
                        onCompleteBindings.push(dataBinding.onCompleteBinding);
                    }
                    onTeardowns[node.name] = dataBinding.onTeardown;
                }
            });
            if (staticDataBindingsOnly && !hasDataBinding) {
                return;
            }
            viewModel = makeViewModel(bindingsState.initialViewModelData, hasDataBinding);
            for (var i = 0, len = onCompleteBindings.length; i < len; i++) {
                onCompleteBindings[i]();
            }
            if (!bindingsState.isSettingViewModel) {
                domEvents.addEventListener.call(el, attributesEventStr, function (ev) {
                    var attrName = ev.attributeName, value = el.getAttribute(attrName);
                    if (onTeardowns[attrName]) {
                        onTeardowns[attrName]();
                    }
                    var parentBindingWasAttribute = bindingInfos[attrName] && bindingInfos[attrName].parent === attributeBindingStr;
                    if (value !== null || parentBindingWasAttribute) {
                        var dataBinding = makeDataBinding({
                            name: attrName,
                            value: value
                        }, el, {
                            templateType: tagData.templateType,
                            scope: tagData.scope,
                            semaphore: {},
                            getViewModel: function () {
                                return viewModel;
                            },
                            attributeViewModelBindings: attributeViewModelBindings,
                            initializeValues: true,
                            nodeList: tagData.parentNodeList
                        });
                        if (dataBinding) {
                            if (dataBinding.onCompleteBinding) {
                                dataBinding.onCompleteBinding();
                            }
                            bindingInfos[attrName] = dataBinding.bindingInfo;
                            onTeardowns[attrName] = dataBinding.onTeardown;
                        }
                    }
                });
            }
            return function () {
                for (var attrName in onTeardowns) {
                    onTeardowns[attrName]();
                }
            };
        },
        data: function (el, attrData) {
            if (domData.get.call(el, 'preventDataBindings')) {
                return;
            }
            var viewModel, getViewModel = Observation.ignore(function () {
                    return viewModel || (viewModel = canViewModel(el));
                }), semaphore = {}, teardown;
            var dataBinding = makeDataBinding({
                name: attrData.attributeName,
                value: el.getAttribute(attrData.attributeName),
                nodeList: attrData.nodeList
            }, el, {
                templateType: attrData.templateType,
                scope: attrData.scope,
                semaphore: semaphore,
                getViewModel: getViewModel,
                syncChildWithParent: false
            });
            if (dataBinding.onCompleteBinding) {
                dataBinding.onCompleteBinding();
            }
            teardown = dataBinding.onTeardown;
            canEvent.one.call(el, removedStr, function () {
                teardown();
            });
            domEvents.addEventListener.call(el, attributesEventStr, function (ev) {
                var attrName = ev.attributeName, value = el.getAttribute(attrName);
                if (attrName === attrData.attributeName) {
                    if (teardown) {
                        teardown();
                    }
                    if (value !== null) {
                        var dataBinding = makeDataBinding({
                            name: attrName,
                            value: value
                        }, el, {
                            templateType: attrData.templateType,
                            scope: attrData.scope,
                            semaphore: semaphore,
                            getViewModel: getViewModel,
                            initializeValues: true,
                            nodeList: attrData.nodeList,
                            syncChildWithParent: false
                        });
                        if (dataBinding) {
                            if (dataBinding.onCompleteBinding) {
                                dataBinding.onCompleteBinding();
                            }
                            teardown = dataBinding.onTeardown;
                        }
                    }
                }
            });
        },
        event: function (el, data) {
            var attributeName = encoder.decode(data.attributeName), event, bindingContext;
            if (attributeName.indexOf(toMatchStr + ':') !== -1 || attributeName.indexOf(fromMatchStr + ':') !== -1 || attributeName.indexOf(bindMatchStr + ':') !== -1) {
                return this.data(el, data);
            }
            if (startsWith.call(attributeName, onMatchStr)) {
                event = attributeName.substr(onMatchStr.length);
                var viewModel = domData.get.call(el, viewModelBindingStr);
                var byParent = data.scope;
                if (startsWith.call(event, elMatchStr)) {
                    event = event.substr(elMatchStr.length);
                    bindingContext = el;
                } else {
                    if (startsWith.call(event, vmMatchStr)) {
                        event = event.substr(vmMatchStr.length);
                        bindingContext = viewModel;
                        byParent = viewModel;
                    } else {
                        bindingContext = viewModel || el;
                    }
                    var byIndex = event.indexOf(byMatchStr);
                    if (byIndex >= 0) {
                        bindingContext = byParent.get(event.substr(byIndex + byMatchStr.length));
                        event = event.substr(0, byIndex);
                    }
                }
            } else {
                throw new Error('can-stache-bindings - unsupported event bindings ' + attributeName);
            }
            var handler = function (ev) {
                var attrVal = el.getAttribute(encoder.encode(attributeName));
                if (!attrVal) {
                    return;
                }
                var viewModel = canViewModel(el);
                var expr = expression.parse(attrVal, {
                    lookupRule: function () {
                        return expression.Lookup;
                    },
                    methodRule: 'call'
                });
                if (!(expr instanceof expression.Call)) {
                    throw new Error('can-stache-bindings: Event bindings must be a call expression. Make sure you have a () in ' + data.attributeName + '=' + JSON.stringify(attrVal));
                }
                var localScope = data.scope.add({
                    '%element': this,
                    '%event': ev,
                    '%viewModel': viewModel,
                    '%scope': data.scope,
                    '%context': data.scope._context,
                    '%arguments': arguments
                }, { notContext: true });
                var scopeData = localScope.read(expr.methodExpr.key, { isArgument: true }), args, stacheHelper, stacheHelperResult;
                if (!scopeData.value) {
                    var name = observeReader.reads(expr.methodExpr.key).map(function (part) {
                        return part.key;
                    }).join('.');
                    stacheHelper = stacheHelperCore.getHelper(name);
                    if (stacheHelper) {
                        args = expr.args(localScope, null)();
                        stacheHelperResult = stacheHelper.fn.apply(localScope.peek('.'), args);
                        if (typeof stacheHelperResult === 'function') {
                            stacheHelperResult(el);
                        }
                        return stacheHelperResult;
                    }
                    return null;
                }
                args = expr.args(localScope, null)();
                return scopeData.value.apply(scopeData.parent, args);
            };
            var attributesHandler = function (ev) {
                var isEventAttribute = ev.attributeName === attributeName;
                var isRemoved = !this.getAttribute(attributeName);
                var isEventAttributeRemoved = isEventAttribute && isRemoved;
                if (isEventAttributeRemoved) {
                    unbindEvent();
                }
            };
            var removedHandler = function (ev) {
                unbindEvent();
            };
            var unbindEvent = function () {
                canEvent.off.call(bindingContext, event, handler);
                canEvent.off.call(el, attributesEventStr, attributesHandler);
                canEvent.off.call(el, removedStr, removedHandler);
            };
            canEvent.on.call(bindingContext, event, handler);
            canEvent.on.call(el, attributesEventStr, attributesHandler);
            canEvent.on.call(el, removedStr, removedHandler);
        }
    };
    viewCallbacks.attr(/[\w\.:]+:to$/, behaviors.data);
    viewCallbacks.attr(/[\w\.:]+:from$/, behaviors.data);
    viewCallbacks.attr(/[\w\.:]+:bind$/, behaviors.data);
    viewCallbacks.attr(/[\w\.:]+:to:on:[\w\.:]+/, behaviors.data);
    viewCallbacks.attr(/[\w\.:]+:from:on:[\w\.:]+/, behaviors.data);
    viewCallbacks.attr(/[\w\.:]+:bind:on:[\w\.:]+/, behaviors.data);
    viewCallbacks.attr(/on:[\w\.:]+/, behaviors.event);
    var getObservableFrom = {
        viewModelOrAttribute: function (el, scope, vmNameOrProp, bindingData, mustBeSettable, stickyCompute, event) {
            var viewModel = domData.get.call(el, viewModelBindingStr);
            if (viewModel) {
                return this.viewModel.apply(this, arguments);
            } else {
                return this.attribute.apply(this, arguments);
            }
        },
        scope: function (el, scope, scopeProp, bindingData, mustBeSettable, stickyCompute) {
            if (!scopeProp) {
                return new SimpleObservable();
            } else {
                if (mustBeSettable) {
                    var parentExpression = expression.parse(scopeProp, { baseMethodType: 'Call' });
                    return parentExpression.value(scope, new Scope.Options({}));
                } else {
                    var observation = new Observation(function () {
                    });
                    observation[setValueSymbol] = function (newVal) {
                        scope.set(cleanVMName(scopeProp), newVal);
                    };
                    return observation;
                }
            }
        },
        viewModel: function (el, scope, vmName, bindingData, mustBeSettable, stickyCompute, childEvent) {
            var setName = cleanVMName(vmName);
            var isBoundToContext = vmName === '.' || vmName === 'this';
            var keysToRead = isBoundToContext ? [] : observeReader.reads(vmName);
            function getViewModelProperty() {
                var viewModel = bindingData.getViewModel();
                return observeReader.read(viewModel, keysToRead, {}).value;
            }
            var observation = new SettableObservable(getViewModelProperty, function setViewModelProperty(newVal) {
                var viewModel = bindingData.getViewModel();
                if (stickyCompute) {
                    var oldValue = canReflect.getKeyValue(viewModel, setName);
                    if (canReflect.isObservableLike(oldValue)) {
                        canReflect.setValue(oldValue, newVal);
                    } else {
                        canReflect.setKeyValue(viewModel, setName, new SimpleObservable(canReflect.getValue(stickyCompute)));
                    }
                } else {
                    if (isBoundToContext) {
                        canReflect.setValue(viewModel, newVal);
                    } else {
                        canReflect.setKeyValue(viewModel, setName, newVal);
                    }
                }
            });
            return observation;
        },
        attribute: function (el, scope, prop, bindingData, mustBeSettable, stickyCompute, event) {
            if (!event) {
                event = 'change';
                var isRadioInput = el.nodeName === 'INPUT' && el.type === 'radio';
                var isValidProp = prop === 'checked' && !bindingData.legacyBindings;
                if (isRadioInput && isValidProp) {
                    event = 'radiochange';
                }
                var isSpecialProp = attr.special[prop] && attr.special[prop].addEventListener;
                if (isSpecialProp) {
                    event = prop;
                }
            }
            var hasChildren = el.nodeName.toLowerCase() === 'select', isMultiselectValue = prop === 'value' && hasChildren && el.multiple, set = function (newVal) {
                    if (bindingData.legacyBindings && hasChildren && 'selectedIndex' in el && prop === 'value') {
                        attr.setAttrOrProp(el, prop, newVal == null ? '' : newVal);
                    } else {
                        attr.setAttrOrProp(el, prop, newVal);
                    }
                    return newVal;
                }, get = function () {
                    return attr.get(el, prop);
                };
            if (isMultiselectValue) {
                prop = 'values';
            }
            var observation = new Observation(get);
            observation[setValueSymbol] = set;
            observation[getValueSymbol] = get;
            observation[onValueSymbol] = function (updater) {
                var translationHandler = function () {
                    updater(get());
                };
                singleReference.set(updater, this, translationHandler);
                if (event === 'radiochange') {
                    canEvent.on.call(el, 'change', translationHandler);
                }
                canEvent.on.call(el, event, translationHandler);
            };
            observation[offValueSymbol] = function (updater) {
                var translationHandler = singleReference.getAndDelete(updater, this);
                if (event === 'radiochange') {
                    canEvent.off.call(el, 'change', translationHandler);
                }
                canEvent.off.call(el, event, translationHandler);
            };
            return observation;
        }
    };
    var bind = {
        childToParent: function (el, parentObservable, childObservable, bindingsSemaphore, attrName, syncChild, bindingInfo) {
            function updateParent(newVal) {
                if (!bindingsSemaphore[attrName]) {
                    if (parentObservable && parentObservable[getValueSymbol]) {
                        var hasDependencies = canReflect.valueHasDependencies(parentObservable);
                        if (!hasDependencies || canReflect.getValue(parentObservable) !== newVal) {
                            canReflect.setValue(parentObservable, newVal);
                        }
                        if (syncChild && hasDependencies) {
                            if (canReflect.getValue(parentObservable) !== canReflect.getValue(childObservable)) {
                                bindingsSemaphore[attrName] = (bindingsSemaphore[attrName] || 0) + 1;
                                queues.batch.start();
                                canReflect.setValue(childObservable, canReflect.getValue(parentObservable));
                                queues.mutateQueue.enqueue(function decrementChildToParentSemaphore() {
                                    --bindingsSemaphore[attrName];
                                }, null, [], {});
                                queues.batch.stop();
                            }
                        }
                    } else if (canReflect.isMapLike(parentObservable)) {
                        var attrValue = el.getAttribute(attrName);
                        dev.warn('can-stache-bindings: Merging ' + attrName + ' into ' + attrValue + ' because its parent is non-observable');
                        canReflect.eachKey(parentObservable, function (prop) {
                            canReflect.deleteKeyValue(parentObservable, prop);
                        });
                        canReflect.setValue(parentObservable, newVal && newVal.serialize ? newVal.serialize() : newVal, true);
                    }
                }
            }
            if (childObservable && childObservable[getValueSymbol]) {
                canReflect.onValue(childObservable, updateParent, 'mutate');
            }
            return updateParent;
        },
        parentToChild: function (el, parentObservable, childObservable, bindingsSemaphore, attrName, bindingInfo) {
            var updateChild = function (newValue) {
                bindingsSemaphore[attrName] = (bindingsSemaphore[attrName] || 0) + 1;
                queues.batch.start();
                canReflect.setValue(childObservable, newValue);
                queues.mutateQueue.enqueue(function decrementParentToChildSemaphore() {
                    --bindingsSemaphore[attrName];
                }, null, [], {});
                queues.batch.stop();
            };
            if (parentObservable && parentObservable[getValueSymbol]) {
                canReflect.onValue(parentObservable, updateChild, 'mutate');
            }
            return updateChild;
        }
    };
    var startsWith = String.prototype.startsWith || function (text) {
        return this.indexOf(text) === 0;
    };
    function getEventName(result) {
        if (result.special.on !== undefined) {
            return result.tokens[result.special.on + 1];
        }
    }
    var bindingRules = {
        to: {
            childToParent: true,
            parentToChild: false,
            syncChildWithParent: false
        },
        from: {
            childToParent: false,
            parentToChild: true,
            syncChildWithParent: false
        },
        bind: {
            childToParent: true,
            parentToChild: true,
            syncChildWithParent: true
        }
    };
    var bindingNames = [];
    var special = {
        vm: true,
        on: true
    };
    each(bindingRules, function (value, key) {
        bindingNames.push(key);
        special[key] = true;
    });
    function tokenize(source) {
        var splitByColon = source.split(':');
        var result = {
            tokens: [],
            special: {}
        };
        splitByColon.forEach(function (token) {
            if (special[token]) {
                result.special[token] = result.tokens.push(token) - 1;
            } else {
                result.tokens.push(token);
            }
        });
        return result;
    }
    var getChildBindingStr = function (tokens, favorViewModel) {
        if (tokens.indexOf('vm') >= 0) {
            return viewModelBindingStr;
        } else if (tokens.indexOf('el') >= 0) {
            return attributeBindingStr;
        } else {
            return favorViewModel ? viewModelBindingStr : viewModelOrAttributeBindingStr;
        }
    };
    var getBindingInfo = function (node, attributeViewModelBindings, templateType, tagName, favorViewModel) {
        var bindingInfo, attributeName = encoder.decode(node.name), attributeValue = node.value || '';
        var result = tokenize(attributeName), dataBindingName, specialIndex;
        bindingNames.forEach(function (name) {
            if (result.special[name] !== undefined && result.special[name] > 0) {
                dataBindingName = name;
                specialIndex = result.special[name];
                return false;
            }
        });
        if (dataBindingName) {
            var childEventName = getEventName(result);
            var initializeValues = childEventName ? false : true;
            bindingInfo = assign({
                parent: scopeBindingStr,
                child: getChildBindingStr(result.tokens, favorViewModel),
                childName: result.tokens[specialIndex - 1],
                childEvent: childEventName,
                bindingAttributeName: attributeName,
                parentName: attributeValue,
                initializeValues: initializeValues
            }, bindingRules[dataBindingName]);
            if (attributeValue.trim().charAt(0) === '~') {
                bindingInfo.stickyParentToChild = true;
            }
            return bindingInfo;
        }
    };
    var makeDataBinding = function (node, el, bindingData) {
        var bindingInfo = getBindingInfo(node, bindingData.attributeViewModelBindings, bindingData.templateType, el.nodeName.toLowerCase(), bindingData.favorViewModel);
        if (!bindingInfo) {
            return;
        }
        bindingInfo.alreadyUpdatedChild = bindingData.alreadyUpdatedChild;
        if (bindingData.initializeValues) {
            bindingInfo.initializeValues = true;
        }
        var parentObservable = getObservableFrom[bindingInfo.parent](el, bindingData.scope, bindingInfo.parentName, bindingData, bindingInfo.parentToChild, undefined, undefined, bindingInfo), childObservable = getObservableFrom[bindingInfo.child](el, bindingData.scope, bindingInfo.childName, bindingData, bindingInfo.childToParent, bindingInfo.stickyParentToChild && parentObservable, bindingInfo.childEvent, bindingInfo), updateParent, updateChild;
        if (bindingData.nodeList) {
            if (parentObservable) {
                canReflect.setPriority(parentObservable, bindingData.nodeList.nesting + 1);
            }
            if (childObservable) {
                canReflect.setPriority(childObservable, bindingData.nodeList.nesting + 1);
            }
        }
        if (bindingInfo.parentToChild) {
            updateChild = bind.parentToChild(el, parentObservable, childObservable, bindingData.semaphore, bindingInfo.bindingAttributeName, bindingInfo);
        }
        var completeBinding = function () {
            if (bindingInfo.childToParent) {
                updateParent = bind.childToParent(el, parentObservable, childObservable, bindingData.semaphore, bindingInfo.bindingAttributeName, bindingInfo.syncChildWithParent, bindingInfo);
            } else if (bindingInfo.stickyParentToChild && childObservable[onValueSymbol]) {
                canReflect.onValue(childObservable, noop, 'mutate');
            }
            if (bindingInfo.initializeValues) {
                initializeValues(bindingInfo, childObservable, parentObservable, updateChild, updateParent);
            }
        };
        var onTeardown = function () {
            unbindUpdate(parentObservable, updateChild);
            unbindUpdate(childObservable, updateParent);
            unbindUpdate(childObservable, noop);
        };
        if (bindingInfo.child === viewModelBindingStr) {
            return {
                value: bindingInfo.stickyParentToChild ? makeCompute(parentObservable) : canReflect.getValue(parentObservable),
                onCompleteBinding: completeBinding,
                bindingInfo: bindingInfo,
                onTeardown: onTeardown
            };
        } else {
            completeBinding();
            return {
                bindingInfo: bindingInfo,
                onTeardown: onTeardown
            };
        }
    };
    var initializeValues = function (bindingInfo, childObservable, parentObservable, updateChild, updateParent) {
        var doUpdateParent = false;
        if (bindingInfo.parentToChild && !bindingInfo.childToParent) {
        } else if (!bindingInfo.parentToChild && bindingInfo.childToParent) {
            doUpdateParent = true;
        } else if (canReflect.getValue(childObservable) === undefined) {
        } else if (canReflect.getValue(parentObservable) === undefined) {
            doUpdateParent = true;
        }
        if (doUpdateParent) {
            updateParent(canReflect.getValue(childObservable));
        } else {
            if (!bindingInfo.alreadyUpdatedChild) {
                updateChild(canReflect.getValue(parentObservable));
            }
        }
    };
    var unbindUpdate = function (observable, updater) {
            if (observable && observable[getValueSymbol] && typeof updater === 'function') {
                canReflect.offValue(observable, updater, 'mutate');
            }
        }, cleanVMName = function (name) {
            return name.replace(/@/g, '');
        };
    module.exports = {
        behaviors: behaviors,
        getBindingInfo: getBindingInfo
    };
});
/*can-component@4.0.0-pre.2#can-component*/
define('can-component@4.0.0-pre.2#can-component', [
    'require',
    'exports',
    'module',
    './control/control',
    'can-namespace',
    'can-construct',
    'can-stache-bindings',
    'can-view-scope',
    'can-view-callbacks',
    'can-view-nodelist',
    'can-util/dom/data/data',
    'can-util/dom/mutate/mutate',
    'can-util/dom/child-nodes/child-nodes',
    'can-util/dom/dispatch/dispatch',
    'can-util/js/string/string',
    'can-reflect',
    'can-util/js/each/each',
    'can-util/js/assign/assign',
    'can-util/js/is-function/is-function',
    'can-util/js/log/log',
    'can-util/js/dev/dev',
    'can-util/js/make-array/make-array',
    'can-util/js/is-empty-object/is-empty-object',
    'can-simple-observable',
    'can-simple-map',
    'can-util/dom/events/inserted/inserted',
    'can-util/dom/events/removed/removed',
    'can-view-model'
], function (require, exports, module) {
    var ComponentControl = require('./control/control');
    var namespace = require('can-namespace');
    var Construct = require('can-construct');
    var stacheBindings = require('can-stache-bindings');
    var Scope = require('can-view-scope');
    var viewCallbacks = require('can-view-callbacks');
    var nodeLists = require('can-view-nodelist');
    var domData = require('can-util/dom/data/data');
    var domMutate = require('can-util/dom/mutate/mutate');
    var getChildNodes = require('can-util/dom/child-nodes/child-nodes');
    var domDispatch = require('can-util/dom/dispatch/dispatch');
    var string = require('can-util/js/string/string');
    var canReflect = require('can-reflect');
    var canEach = require('can-util/js/each/each');
    var assign = require('can-util/js/assign/assign');
    var isFunction = require('can-util/js/is-function/is-function');
    var canLog = require('can-util/js/log/log');
    var canDev = require('can-util/js/dev/dev');
    var makeArray = require('can-util/js/make-array/make-array');
    var isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');
    var SimpleObservable = require('can-simple-observable');
    var SimpleMap = require('can-simple-map');
    require('can-util/dom/events/inserted/inserted');
    require('can-util/dom/events/removed/removed');
    require('can-view-model');
    function addContext(el, tagData, insertionElementTagData) {
        var vm;
        domData.set.call(el, 'preventDataBindings', true);
        var teardown = stacheBindings.behaviors.viewModel(el, insertionElementTagData, function (initialData) {
            return vm = new SimpleObservable(initialData);
        }, undefined, true);
        if (!teardown) {
            return tagData;
        } else {
            return assign(assign({}, tagData), {
                teardown: teardown,
                scope: tagData.scope.add(vm)
            });
        }
    }
    function makeInsertionTagCallback(tagName, componentTagData, shadowTagData, leakScope, getPrimaryTemplate) {
        var options = shadowTagData.options._context;
        return function hookupFunction(el, insertionElementTagData) {
            var template = getPrimaryTemplate(el) || insertionElementTagData.subtemplate, renderingLightContent = template !== insertionElementTagData.subtemplate;
            if (template) {
                delete options.tags[tagName];
                var tagData;
                if (renderingLightContent) {
                    if (leakScope.toLightContent) {
                        tagData = addContext(el, {
                            scope: insertionElementTagData.scope.cloneFromRef(),
                            options: insertionElementTagData.options
                        }, insertionElementTagData);
                    } else {
                        tagData = addContext(el, componentTagData, insertionElementTagData);
                    }
                } else {
                    tagData = addContext(el, insertionElementTagData, insertionElementTagData);
                }
                var nodeList = nodeLists.register([el], function () {
                    if (tagData.teardown) {
                        tagData.teardown();
                    }
                }, insertionElementTagData.parentNodeList || true, false);
                nodeList.expression = '<can-slot name=\'' + el.getAttribute('name') + '\'/>';
                var frag = template(tagData.scope, tagData.options, nodeList);
                var newNodes = makeArray(getChildNodes(frag));
                nodeLists.replace(nodeList, frag);
                nodeLists.update(nodeList, newNodes);
                options.tags[tagName] = hookupFunction;
            }
        };
    }
    var Component = Construct.extend({
        setup: function () {
            Construct.setup.apply(this, arguments);
            if (Component) {
                var self = this;
                if (!isEmptyObject(this.prototype.events)) {
                    this.Control = ComponentControl.extend(this.prototype.events);
                }
                var protoViewModel = this.prototype.viewModel || this.prototype.scope;
                if (protoViewModel && this.prototype.ViewModel) {
                    throw new Error('Cannot provide both a ViewModel and a viewModel property');
                }
                var vmName = string.capitalize(string.camelize(this.prototype.tag)) + 'VM';
                if (this.prototype.ViewModel) {
                    if (typeof this.prototype.ViewModel === 'function') {
                        this.ViewModel = this.prototype.ViewModel;
                    } else {
                        this.ViewModel = SimpleMap.extend(vmName, this.prototype.ViewModel);
                    }
                } else {
                    if (protoViewModel) {
                        if (typeof protoViewModel === 'function') {
                            if (canReflect.isObservableLike(protoViewModel.prototype) && canReflect.isMapLike(protoViewModel.prototype)) {
                                this.ViewModel = protoViewModel;
                            } else {
                                this.viewModelHandler = protoViewModel;
                            }
                        } else {
                            if (canReflect.isObservableLike(protoViewModel) && canReflect.isMapLike(protoViewModel)) {
                                this.viewModelInstance = protoViewModel;
                            } else {
                                this.ViewModel = SimpleMap.extend(vmName, protoViewModel);
                            }
                        }
                    } else {
                        this.ViewModel = SimpleMap.extend(vmName, {});
                    }
                }
                if (this.prototype.template) {
                    this.renderer = this.prototype.template;
                }
                if (this.prototype.view) {
                    this.renderer = this.prototype.view;
                }
                viewCallbacks.tag(this.prototype.tag, function (el, options) {
                    new self(el, options);
                });
            }
        }
    }, {
        setup: function (el, componentTagData) {
            var component = this;
            var teardownFunctions = [];
            var initialViewModelData = {};
            var callTeardownFunctions = function () {
                for (var i = 0, len = teardownFunctions.length; i < len; i++) {
                    teardownFunctions[i]();
                }
            };
            var setupBindings = !domData.get.call(el, 'preventDataBindings');
            var viewModel, frag;
            var teardownBindings;
            if (setupBindings) {
                var setupFn = componentTagData.setupBindings || function (el, callback, data) {
                    return stacheBindings.behaviors.viewModel(el, componentTagData, callback, data);
                };
                teardownBindings = setupFn(el, function (initialViewModelData) {
                    var ViewModel = component.constructor.ViewModel, viewModelHandler = component.constructor.viewModelHandler, viewModelInstance = component.constructor.viewModelInstance;
                    if (viewModelHandler) {
                        var scopeResult = viewModelHandler.call(component, initialViewModelData, componentTagData.scope, el);
                        if (canReflect.isObservableLike(scopeResult) && canReflect.isMapLike(scopeResult)) {
                            viewModelInstance = scopeResult;
                        } else if (canReflect.isObservableLike(scopeResult.prototype) && canReflect.isMapLike(scopeResult.prototype)) {
                            ViewModel = scopeResult;
                        } else {
                            ViewModel = SimpleMap.extend(scopeResult);
                        }
                    }
                    if (ViewModel) {
                        viewModelInstance = new component.constructor.ViewModel(initialViewModelData);
                    }
                    viewModel = viewModelInstance;
                    return viewModelInstance;
                }, initialViewModelData);
            }
            this.viewModel = viewModel;
            domData.set.call(el, 'viewModel', viewModel);
            domData.set.call(el, 'preventDataBindings', true);
            var options = {
                helpers: {},
                tags: {}
            };
            canEach(this.helpers || {}, function (val, prop) {
                if (isFunction(val)) {
                    options.helpers[prop] = val.bind(viewModel);
                }
            });
            if (this.constructor.Control) {
                this._control = new this.constructor.Control(el, {
                    scope: this.viewModel,
                    viewModel: this.viewModel,
                    destroy: callTeardownFunctions
                });
            }
            var leakScope = {
                toLightContent: this.leakScope === true,
                intoShadowContent: this.leakScope === true
            };
            var hasShadowTemplate = !!this.constructor.renderer;
            var betweenTagsRenderer;
            var betweenTagsTagData;
            if (hasShadowTemplate) {
                var shadowTagData;
                if (leakScope.intoShadowContent) {
                    shadowTagData = {
                        scope: componentTagData.scope.add(new Scope.Refs()).add(this.viewModel, { viewModel: true }),
                        options: componentTagData.options.add(options)
                    };
                } else {
                    shadowTagData = {
                        scope: Scope.refsScope().add(this.viewModel, { viewModel: true }),
                        options: new Scope.Options(options)
                    };
                }
                options.tags['can-slot'] = makeInsertionTagCallback('can-slot', componentTagData, shadowTagData, leakScope, function (el) {
                    return componentTagData.templates[el.getAttribute('name')];
                });
                options.tags.content = makeInsertionTagCallback('content', componentTagData, shadowTagData, leakScope, function () {
                    return componentTagData.subtemplate;
                });
                betweenTagsRenderer = this.constructor.renderer;
                betweenTagsTagData = shadowTagData;
            } else {
                var lightTemplateTagData = {
                    scope: componentTagData.scope.add(this.viewModel, { viewModel: true }),
                    options: componentTagData.options.add(options)
                };
                betweenTagsTagData = lightTemplateTagData;
                betweenTagsRenderer = componentTagData.subtemplate || el.ownerDocument.createDocumentFragment.bind(el.ownerDocument);
            }
            var nodeList = nodeLists.register([], function () {
                domDispatch.call(el, 'beforeremove', [], false);
                if (teardownBindings) {
                    teardownBindings();
                }
            }, componentTagData.parentNodeList || true, false);
            nodeList.expression = '<' + this.tag + '>';
            teardownFunctions.push(function () {
                nodeLists.unregister(nodeList);
            });
            frag = betweenTagsRenderer(betweenTagsTagData.scope, betweenTagsTagData.options, nodeList);
            domMutate.appendChild.call(el, frag);
            nodeLists.update(nodeList, getChildNodes(el));
        }
    });
    module.exports = namespace.Component = Component;
});
/*can-simple-observable@2.0.0-pre.16#async/async*/
define('can-simple-observable@2.0.0-pre.16#async/async', [
    'require',
    'exports',
    'module',
    '../can-simple-observable',
    'can-observation',
    'can-key-tree',
    'can-queues',
    '../settable/settable',
    'can-reflect',
    'can-observation-recorder'
], function (require, exports, module) {
    var SimpleObservable = require('../can-simple-observable');
    var Observation = require('can-observation');
    var KeyTree = require('can-key-tree');
    var queues = require('can-queues');
    var SettableObservable = require('../settable/settable');
    var canReflect = require('can-reflect');
    var ObservationRecorder = require('can-observation-recorder');
    function AsyncObservable(fn, context, initialValue) {
        this.handlers = new KeyTree([
            Object,
            Array
        ], {
            onFirst: this.setup.bind(this),
            onEmpty: this.teardown.bind(this)
        });
        this.resolve = this.resolve.bind(this);
        this.lastSetValue = new SimpleObservable(initialValue);
        this.handler = this.handler.bind(this);
        function observe() {
            this.resolveCalled = false;
            return fn.call(context, this.lastSetValue.get(), this.bound === true ? this.resolve : undefined);
        }
        this.observation = new Observation(observe, this);
    }
    AsyncObservable.prototype = Object.create(SettableObservable.prototype);
    AsyncObservable.prototype.constructor = AsyncObservable;
    AsyncObservable.prototype.handler = function (newVal) {
        if (newVal !== undefined) {
            SettableObservable.prototype.handler.apply(this, arguments);
        }
    };
    var peek = ObservationRecorder.ignore(canReflect.getValue.bind(canReflect));
    AsyncObservable.prototype.setup = function () {
        this.bound = true;
        canReflect.onValue(this.observation, this.handler, 'notify');
        if (!this.resolveCalled) {
            this.value = peek(this.observation);
        }
    };
    AsyncObservable.prototype.resolve = function resolve(newVal) {
        this.resolveCalled = true;
        var old = this.value;
        this.value = newVal;
        queues.enqueueByQueue(this.handlers.getNode([]), this, [
            newVal,
            old
        ], function () {
            return {};
        });
    };
    module.exports = AsyncObservable;
});
/*can-util@3.10.12#js/defaults/defaults*/
define('can-util@3.10.12#js/defaults/defaults', function (require, exports, module) {
    'use strict';
    module.exports = function (target) {
        var length = arguments.length;
        for (var i = 1; i < length; i++) {
            for (var prop in arguments[i]) {
                if (target[prop] === undefined) {
                    target[prop] = arguments[i][prop];
                }
            }
        }
        return target;
    };
});
/*can-util@3.10.12#js/string-to-any/string-to-any*/
define('can-util@3.10.12#js/string-to-any/string-to-any', function (require, exports, module) {
    'use strict';
    module.exports = function (str) {
        switch (str) {
        case 'NaN':
        case 'Infinity':
            return +str;
        case 'null':
            return null;
        case 'undefined':
            return undefined;
        case 'true':
        case 'false':
            return str === 'true';
        default:
            var val = +str;
            if (!isNaN(val)) {
                return val;
            } else {
                return str;
            }
        }
    };
});
/*can-define-lazy-value@1.0.0#define-lazy-value*/
define('can-define-lazy-value@1.0.0#define-lazy-value', function (require, exports, module) {
    module.exports = function defineLazyValue(obj, prop, initializer, writable) {
        Object.defineProperty(obj, prop, {
            configurable: true,
            get: function () {
                Object.defineProperty(this, prop, {
                    value: undefined,
                    writable: true
                });
                var value = initializer.call(this, obj, prop);
                Object.defineProperty(this, prop, {
                    value: value,
                    writable: !!writable
                });
                return value;
            },
            set: function (value) {
                Object.defineProperty(this, prop, {
                    value: value,
                    writable: !!writable
                });
                return value;
            }
        });
    };
});
/*can-define@2.0.0-pre.11#can-define*/
define('can-define@2.0.0-pre.11#can-define', [
    'require',
    'exports',
    'module',
    'can-namespace',
    'can-symbol',
    'can-reflect',
    'can-observation',
    'can-simple-observable/async/async',
    'can-simple-observable/settable/settable',
    'can-cid',
    'can-event-queue',
    'can-queues',
    'can-util/js/is-empty-object/is-empty-object',
    'can-util/js/assign/assign',
    'can-util/js/dev/dev',
    'can-util/js/is-plain-object/is-plain-object',
    'can-util/js/each/each',
    'can-util/js/defaults/defaults',
    'can-util/js/string-to-any/string-to-any',
    'can-define-lazy-value'
], function (require, exports, module) {
    'use strict';
    'format cjs';
    var ns = require('can-namespace');
    var canSymbol = require('can-symbol');
    var canReflect = require('can-reflect');
    var Observation = require('can-observation');
    var AsyncObservable = require('can-simple-observable/async/async');
    var SettableObservable = require('can-simple-observable/settable/settable');
    var CID = require('can-cid');
    var eventQueue = require('can-event-queue');
    var queues = require('can-queues');
    var isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');
    var assign = require('can-util/js/assign/assign');
    var dev = require('can-util/js/dev/dev');
    var isPlainObject = require('can-util/js/is-plain-object/is-plain-object');
    var each = require('can-util/js/each/each');
    var defaults = require('can-util/js/defaults/defaults');
    var stringToAny = require('can-util/js/string-to-any/string-to-any');
    var defineLazyValue = require('can-define-lazy-value');
    var eventsProto, define, make, makeDefinition, getDefinitionsAndMethods, isDefineType, getDefinitionOrMethod;
    var defineConfigurableAndNotEnumerable = function (obj, prop, value) {
        Object.defineProperty(obj, prop, {
            configurable: true,
            enumerable: false,
            writable: true,
            value: value
        });
    };
    var eachPropertyDescriptor = function (map, cb) {
        for (var prop in map) {
            if (map.hasOwnProperty(prop)) {
                cb(prop, Object.getOwnPropertyDescriptor(map, prop));
            }
        }
    };
    module.exports = define = ns.define = function (objPrototype, defines, baseDefine) {
        var prop, dataInitializers = Object.create(baseDefine ? baseDefine.dataInitializers : null), computedInitializers = Object.create(baseDefine ? baseDefine.computedInitializers : null);
        var result = getDefinitionsAndMethods(defines, baseDefine);
        result.dataInitializers = dataInitializers;
        result.computedInitializers = computedInitializers;
        each(result.definitions, function (definition, property) {
            define.property(objPrototype, property, definition, dataInitializers, computedInitializers);
        });
        if (objPrototype.hasOwnProperty('_data')) {
            for (prop in dataInitializers) {
                defineLazyValue(objPrototype._data, prop, dataInitializers[prop].bind(objPrototype), true);
            }
        } else {
            defineLazyValue(objPrototype, '_data', function () {
                var map = this;
                var data = {};
                for (var prop in dataInitializers) {
                    defineLazyValue(data, prop, dataInitializers[prop].bind(map), true);
                }
                return data;
            });
        }
        if (objPrototype.hasOwnProperty('_computed')) {
            for (prop in computedInitializers) {
                defineLazyValue(objPrototype._computed, prop, computedInitializers[prop].bind(objPrototype));
            }
        } else {
            defineLazyValue(objPrototype, '_computed', function () {
                var map = this;
                var data = Object.create(null);
                for (var prop in computedInitializers) {
                    defineLazyValue(data, prop, computedInitializers[prop].bind(map));
                }
                return data;
            });
        }
        if (!objPrototype.hasOwnProperty('_cid')) {
            defineLazyValue(objPrototype, '_cid', function () {
                return CID({});
            });
        }
        for (prop in eventsProto) {
            Object.defineProperty(objPrototype, prop, {
                enumerable: false,
                value: eventsProto[prop],
                configurable: true,
                writable: true
            });
        }
        Object.defineProperty(objPrototype, '_define', {
            enumerable: false,
            value: result,
            configurable: true,
            writable: true
        });
        var iteratorSymbol = canSymbol.iterator || canSymbol.for('iterator');
        if (!objPrototype[iteratorSymbol]) {
            defineConfigurableAndNotEnumerable(objPrototype, iteratorSymbol, function () {
                return new define.Iterator(this);
            });
        }
        return result;
    };
    define.extensions = function () {
    };
    var onlyType = function (obj) {
        for (var prop in obj) {
            if (prop !== 'type') {
                return false;
            }
        }
        return true;
    };
    define.property = function (objPrototype, prop, definition, dataInitializers, computedInitializers) {
        var propertyDefinition = define.extensions.apply(this, arguments);
        if (propertyDefinition) {
            definition = propertyDefinition;
        }
        var type = definition.type;
        if (type && onlyType(definition) && type === define.types['*']) {
            Object.defineProperty(objPrototype, prop, {
                get: make.get.data(prop),
                set: make.set.events(prop, make.get.data(prop), make.set.data(prop), make.eventType.data(prop)),
                enumerable: true,
                configurable: true
            });
            return;
        }
        definition.type = type;
        var dataProperty = definition.get ? 'computed' : 'data', reader = make.read[dataProperty](prop), getter = make.get[dataProperty](prop), setter = make.set[dataProperty](prop), getInitialValue;
        var typeConvert = function (val) {
            return val;
        };
        if (definition.Type) {
            typeConvert = make.set.Type(prop, definition.Type, typeConvert);
        }
        if (type) {
            typeConvert = make.set.type(prop, type, typeConvert);
        }
        var eventsSetter = make.set.events(prop, reader, setter, make.eventType[dataProperty](prop));
        if (definition.value !== undefined || definition.Value !== undefined) {
            getInitialValue = Observation.ignore(make.get.defaultValue(prop, definition, typeConvert, eventsSetter));
        }
        if (definition.get) {
            computedInitializers[prop] = make.compute(prop, definition.get, getInitialValue);
        } else if (getInitialValue) {
            dataInitializers[prop] = getInitialValue;
        }
        if (definition.get && definition.set) {
            setter = make.set.setter(prop, definition.set, make.read.lastSet(prop), setter, true);
        } else if (definition.set) {
            setter = make.set.setter(prop, definition.set, reader, eventsSetter, false);
        } else if (!definition.get) {
            setter = eventsSetter;
        } else if (definition.get.length < 1) {
            setter = function () {
            };
        }
        if (type) {
            setter = make.set.type(prop, type, setter);
        }
        if (definition.Type) {
            setter = make.set.Type(prop, definition.Type, setter);
        }
        Object.defineProperty(objPrototype, prop, {
            get: getter,
            set: setter,
            enumerable: 'serialize' in definition ? !!definition.serialize : !definition.get,
            configurable: true
        });
    };
    define.Constructor = function (defines) {
        var constructor = function (props) {
            define.setup.call(this, props);
        };
        define(constructor.prototype, defines);
        return constructor;
    };
    make = {
        compute: function (prop, get, defaultValueFn) {
            return function () {
                var map = this, defaultValue = defaultValueFn && defaultValueFn.call(this), observable, computeObj;
                if (get.length === 0) {
                    observable = new Observation(get, map);
                } else if (get.length === 1) {
                    observable = new SettableObservable(get, map, defaultValue);
                } else {
                    observable = new AsyncObservable(get, map, defaultValue);
                }
                computeObj = {
                    oldValue: undefined,
                    compute: observable,
                    count: 0,
                    handler: function (newVal) {
                        var oldValue = computeObj.oldValue;
                        computeObj.oldValue = newVal;
                        map.dispatch({
                            type: prop,
                            target: map
                        }, [
                            newVal,
                            oldValue
                        ]);
                    }
                };
                return computeObj;
            };
        },
        set: {
            data: function (prop) {
                return function (newVal) {
                    this._data[prop] = newVal;
                };
            },
            computed: function (prop) {
                return function (val) {
                    canReflect.setValue(this._computed[prop].compute, val);
                };
            },
            events: function (prop, getCurrent, setData, eventType) {
                return function (newVal) {
                    if (this.__inSetup) {
                        setData.call(this, newVal);
                    } else {
                        var current = getCurrent.call(this);
                        if (newVal !== current) {
                            setData.call(this, newVal);
                            this.dispatch({
                                type: prop,
                                target: this
                            }, [
                                newVal,
                                current
                            ]);
                        }
                    }
                };
            },
            setter: function (prop, setter, getCurrent, setEvents, hasGetter) {
                return function (value) {
                    var self = this;
                    queues.batch.start();
                    var setterCalled = false, current = getCurrent.call(this), setValue = setter.call(this, value, function (value) {
                            setEvents.call(self, value);
                            setterCalled = true;
                        }, current);
                    if (setterCalled) {
                        queues.batch.stop();
                    } else {
                        if (hasGetter) {
                            if (setValue !== undefined) {
                                if (current !== setValue) {
                                    setEvents.call(this, setValue);
                                }
                                queues.batch.stop();
                            } else if (setter.length === 0) {
                                setEvents.call(this, value);
                                queues.batch.stop();
                                return;
                            } else if (setter.length === 1) {
                                queues.batch.stop();
                            } else {
                                queues.batch.stop();
                                return;
                            }
                        } else {
                            if (setValue !== undefined) {
                                setEvents.call(this, setValue);
                                queues.batch.stop();
                            } else if (setter.length === 0) {
                                setEvents.call(this, value);
                                queues.batch.stop();
                                return;
                            } else if (setter.length === 1) {
                                setEvents.call(this, undefined);
                                queues.batch.stop();
                            } else {
                                queues.batch.stop();
                                return;
                            }
                        }
                    }
                };
            },
            type: function (prop, type, set) {
                if (typeof type === 'object') {
                    return make.set.Type(prop, type, set);
                } else {
                    return function (newValue) {
                        return set.call(this, type.call(this, newValue, prop));
                    };
                }
            },
            Type: function (prop, Type, set) {
                if (Array.isArray(Type) && define.DefineList) {
                    Type = define.DefineList.extend({ '#': Type[0] });
                } else if (typeof Type === 'object') {
                    if (define.DefineMap) {
                        Type = define.DefineMap.extend(Type);
                    } else {
                        Type = define.Constructor(Type);
                    }
                }
                return function (newValue) {
                    if (newValue instanceof Type || newValue == null) {
                        return set.call(this, newValue);
                    } else {
                        return set.call(this, new Type(newValue));
                    }
                };
            }
        },
        eventType: {
            data: function (prop) {
                return function (newVal, oldVal) {
                    return oldVal !== undefined || this._data.hasOwnProperty(prop) ? 'set' : 'add';
                };
            },
            computed: function () {
                return function () {
                    return 'set';
                };
            }
        },
        read: {
            data: function (prop) {
                return function () {
                    return this._data[prop];
                };
            },
            computed: function (prop) {
                return function () {
                    return canReflect.getValue(this._computed[prop].compute);
                };
            },
            lastSet: function (prop) {
                return function () {
                    var observable = this._computed[prop].compute;
                    if (observable.lastSetValue) {
                        return canReflect.getValue(observable.lastSetValue);
                    }
                };
            }
        },
        get: {
            defaultValue: function (prop, definition, typeConvert, callSetter) {
                return function () {
                    var value = definition.value;
                    if (value !== undefined) {
                        if (typeof value === 'function') {
                            value = value.call(this);
                        }
                        value = typeConvert(value);
                    } else {
                        var Value = definition.Value;
                        if (Value) {
                            value = typeConvert(new Value());
                        }
                    }
                    if (definition.set) {
                        var VALUE;
                        var sync = true;
                        var setter = make.set.setter(prop, definition.set, function () {
                        }, function (value) {
                            if (sync) {
                                VALUE = value;
                            } else {
                                callSetter.call(this, value);
                            }
                        }, definition.get);
                        setter.call(this, value);
                        sync = false;
                        return VALUE;
                    }
                    return value;
                };
            },
            data: function (prop) {
                return function () {
                    if (!this.__inSetup) {
                        Observation.add(this, prop);
                    }
                    return this._data[prop];
                };
            },
            computed: function (prop) {
                return function () {
                    return canReflect.getValue(this._computed[prop].compute);
                };
            }
        }
    };
    define.behaviors = [
        'get',
        'set',
        'value',
        'Value',
        'type',
        'Type',
        'serialize'
    ];
    var addDefinition = function (definition, behavior, value) {
        if (behavior === 'type') {
            var behaviorDef = value;
            if (typeof behaviorDef === 'string') {
                behaviorDef = define.types[behaviorDef];
                if (typeof behaviorDef === 'object') {
                    assign(definition, behaviorDef);
                    behaviorDef = behaviorDef[behavior];
                }
            }
            definition[behavior] = behaviorDef;
        } else {
            definition[behavior] = value;
        }
    };
    makeDefinition = function (prop, def, defaultDefinition) {
        var definition = {};
        each(def, function (value, behavior) {
            addDefinition(definition, behavior, value);
        });
        each(defaultDefinition, function (value, prop) {
            if (definition[prop] === undefined) {
                if (prop !== 'type' && prop !== 'Type') {
                    definition[prop] = value;
                }
            }
        });
        if (!definition.type && !definition.Type) {
            defaults(definition, defaultDefinition);
        }
        if (isEmptyObject(definition)) {
            definition.type = define.types['*'];
        }
        return definition;
    };
    getDefinitionOrMethod = function (prop, value, defaultDefinition) {
        var definition;
        if (typeof value === 'string') {
            definition = { type: value };
        } else if (typeof value === 'function') {
            if (canReflect.isConstructorLike(value)) {
                definition = { Type: value };
            } else if (isDefineType(value)) {
                definition = { type: value };
            }
        } else if (Array.isArray(value)) {
            definition = { Type: value };
        } else if (isPlainObject(value)) {
            definition = value;
        }
        if (definition) {
            return makeDefinition(prop, definition, defaultDefinition);
        } else {
            return value;
        }
    };
    getDefinitionsAndMethods = function (defines, baseDefines) {
        var definitions = Object.create(baseDefines ? baseDefines.definitions : null);
        var methods = {};
        var defaults = defines['*'], defaultDefinition;
        if (defaults) {
            delete defines['*'];
            defaultDefinition = getDefinitionOrMethod('*', defaults, {});
        } else {
            defaultDefinition = Object.create(null);
        }
        eachPropertyDescriptor(defines, function (prop, propertyDescriptor) {
            var value;
            if (propertyDescriptor.get || propertyDescriptor.set) {
                value = {
                    get: propertyDescriptor.get,
                    set: propertyDescriptor.set
                };
            } else {
                value = propertyDescriptor.value;
            }
            if (prop === 'constructor') {
                methods[prop] = value;
                return;
            } else {
                var result = getDefinitionOrMethod(prop, value, defaultDefinition);
                if (result && typeof result === 'object') {
                    definitions[prop] = result;
                } else {
                    methods[prop] = result;
                }
            }
        });
        if (defaults) {
            defines['*'] = defaults;
        }
        return {
            definitions: definitions,
            methods: methods,
            defaultDefinition: defaultDefinition
        };
    };
    eventsProto = eventQueue({});
    var canMetaSymbol = canSymbol.for('can.meta');
    assign(eventsProto, {
        _eventSetup: function () {
        },
        _eventTeardown: function () {
        },
        addEventListener: function (eventName, handler, queue) {
            var computedBinding = this._computed && this._computed[eventName];
            if (computedBinding && computedBinding.compute) {
                if (!computedBinding.count) {
                    computedBinding.count = 1;
                    canReflect.onValue(computedBinding.compute, computedBinding.handler, 'notify');
                    computedBinding.oldValue = canReflect.getValue(computedBinding.compute);
                } else {
                    computedBinding.count++;
                }
            }
            return eventQueue.addEventListener.apply(this, arguments);
        },
        removeEventListener: function (eventName, handler) {
            var computedBinding = this._computed && this._computed[eventName];
            if (computedBinding) {
                if (computedBinding.count === 1) {
                    computedBinding.count = 0;
                    canReflect.offValue(computedBinding.compute, computedBinding.handler, 'notify');
                } else {
                    computedBinding.count--;
                }
            }
            return eventQueue.removeEventListener.apply(this, arguments);
        }
    });
    eventsProto.on = eventsProto.bind = eventsProto.addEventListener;
    eventsProto.off = eventsProto.unbind = eventsProto.removeEventListener;
    delete eventsProto.one;
    define.setup = function (props, sealed) {
        CID(this);
        Object.defineProperty(this, '_cid', {
            value: this._cid,
            enumerable: false,
            writable: false
        });
        Object.defineProperty(this, 'constructor', {
            value: this.constructor,
            enumerable: false,
            writable: false
        });
        Object.defineProperty(this, canMetaSymbol, {
            value: Object.create(null),
            enumerable: false,
            writable: false
        });
        var definitions = this._define.definitions;
        var instanceDefinitions = Object.create(null);
        var map = this;
        canReflect.eachKey(props, function (value, prop) {
            if (definitions[prop] !== undefined) {
                map[prop] = value;
            } else {
                var def = define.makeSimpleGetterSetter(prop);
                instanceDefinitions[prop] = {};
                Object.defineProperty(map, prop, def);
                map[prop] = define.types.observable(value);
            }
        });
        if (!isEmptyObject(instanceDefinitions)) {
            defineConfigurableAndNotEnumerable(this, '_instanceDefinitions', instanceDefinitions);
        }
    };
    define.replaceWith = defineLazyValue;
    define.eventsProto = eventsProto;
    define.defineConfigurableAndNotEnumerable = defineConfigurableAndNotEnumerable;
    define.make = make;
    define.getDefinitionOrMethod = getDefinitionOrMethod;
    var simpleGetterSetters = {};
    define.makeSimpleGetterSetter = function (prop) {
        if (!simpleGetterSetters[prop]) {
            var setter = make.set.events(prop, make.get.data(prop), make.set.data(prop), make.eventType.data(prop));
            simpleGetterSetters[prop] = {
                get: make.get.data(prop),
                set: function (newVal) {
                    return setter.call(this, define.types.observable(newVal));
                },
                enumerable: true
            };
        }
        return simpleGetterSetters[prop];
    };
    define.Iterator = function (obj) {
        this.obj = obj;
        this.definitions = Object.keys(obj._define.definitions);
        this.instanceDefinitions = obj._instanceDefinitions ? Object.keys(obj._instanceDefinitions) : Object.keys(obj);
        this.hasGet = typeof obj.get === 'function';
    };
    define.Iterator.prototype.next = function () {
        var key;
        if (this.definitions.length) {
            key = this.definitions.shift();
            var def = this.obj._define.definitions[key];
            if (def.get) {
                return this.next();
            }
        } else if (this.instanceDefinitions.length) {
            key = this.instanceDefinitions.shift();
        } else {
            return {
                value: undefined,
                done: true
            };
        }
        return {
            value: [
                key,
                this.hasGet ? this.obj.get(key) : this.obj[key]
            ],
            done: false
        };
    };
    isDefineType = function (func) {
        return func && func.canDefineType === true;
    };
    function isObservableValue(obj) {
        return canReflect.isValueLike(obj) && canReflect.isObservableLike(obj);
    }
    define.types = {
        'date': function (str) {
            var type = typeof str;
            if (type === 'string') {
                str = Date.parse(str);
                return isNaN(str) ? null : new Date(str);
            } else if (type === 'number') {
                return new Date(str);
            } else {
                return str;
            }
        },
        'number': function (val) {
            if (val == null) {
                return val;
            }
            return +val;
        },
        'boolean': function (val) {
            if (val == null) {
                return val;
            }
            if (val === 'false' || val === '0' || !val) {
                return false;
            }
            return true;
        },
        'observable': function (newVal) {
            if (Array.isArray(newVal) && define.DefineList) {
                newVal = new define.DefineList(newVal);
            } else if (isPlainObject(newVal) && define.DefineMap) {
                newVal = new define.DefineMap(newVal);
            }
            return newVal;
        },
        'stringOrObservable': function (newVal) {
            if (Array.isArray(newVal)) {
                return new define.DefaultList(newVal);
            } else if (isPlainObject(newVal)) {
                return new define.DefaultMap(newVal);
            } else {
                return define.types.string(newVal);
            }
        },
        'htmlbool': function (val) {
            if (val === '') {
                return true;
            }
            return !!stringToAny(val);
        },
        '*': function (val) {
            return val;
        },
        'any': function (val) {
            return val;
        },
        'string': function (val) {
            if (val == null) {
                return val;
            }
            return '' + val;
        },
        'compute': {
            set: function (newValue, setVal, setErr, oldValue) {
                if (isObservableValue(newValue)) {
                    return newValue;
                }
                if (isObservableValue(oldValue)) {
                    canReflect.setValue(oldValue, newValue);
                    return oldValue;
                }
                return newValue;
            },
            get: function (value) {
                return isObservableValue(value) ? canReflect.getValue(value) : value;
            }
        }
    };
});
/*can-define@2.0.0-pre.11#define-helpers/define-helpers*/
define('can-define@2.0.0-pre.11#define-helpers/define-helpers', [
    'require',
    'exports',
    'module',
    'can-define',
    'can-reflect',
    'can-queues'
], function (require, exports, module) {
    var define = require('can-define');
    var canReflect = require('can-reflect');
    var queues = require('can-queues');
    var defineHelpers = {
        defineExpando: function (map, prop, value) {
            var constructorDefines = map._define.definitions;
            if (constructorDefines && constructorDefines[prop]) {
                return;
            }
            var instanceDefines = map._instanceDefinitions;
            if (!instanceDefines) {
                Object.defineProperty(map, '_instanceDefinitions', {
                    configurable: true,
                    enumerable: false,
                    value: {}
                });
                instanceDefines = map._instanceDefinitions;
            }
            if (!instanceDefines[prop]) {
                var defaultDefinition = map._define.defaultDefinition || { type: define.types.observable };
                define.property(map, prop, defaultDefinition, {}, {});
                map._data[prop] = defaultDefinition.type ? defaultDefinition.type(value) : define.types.observable(value);
                instanceDefines[prop] = defaultDefinition;
                queues.batch.start();
                map.dispatch({
                    type: '__keys',
                    target: map
                });
                if (map._data[prop] !== undefined) {
                    map.dispatch({
                        type: prop,
                        target: map
                    }, [
                        map._data[prop],
                        undefined
                    ]);
                }
                queues.batch.stop();
                return true;
            }
        },
        reflectSerialize: function (unwrapped) {
            var constructorDefinitions = this._define.definitions;
            var defaultDefinition = this._define.defaultDefinition;
            this.each(function (val, name) {
                var propDef = constructorDefinitions[name];
                if (propDef && typeof propDef.serialize === 'function') {
                    val = propDef.serialize.call(this, val, name);
                } else if (defaultDefinition && typeof defaultDefinition.serialize === 'function') {
                    val = defaultDefinition.serialize.call(this, val, name);
                } else {
                    val = canReflect.serialize(val);
                }
                if (val !== undefined) {
                    unwrapped[name] = val;
                }
            }, this);
            return unwrapped;
        },
        reflectUnwrap: function (unwrapped) {
            this.forEach(function (value, key) {
                if (value !== undefined) {
                    unwrapped[key] = canReflect.unwrap(value);
                }
            });
            return unwrapped;
        }
    };
    module.exports = defineHelpers;
});
/*can-util@3.10.12#js/cid-set/cid-set*/
define('can-util@3.10.12#js/cid-set/cid-set', [
    'require',
    'exports',
    'module',
    'can-cid/set/set'
], function (require, exports, module) {
    'use strict';
    module.exports = require('can-cid/set/set');
});
/*can-define@2.0.0-pre.11#ensure-meta*/
define('can-define@2.0.0-pre.11#ensure-meta', [
    'require',
    'exports',
    'module',
    'can-symbol',
    'can-reflect'
], function (require, exports, module) {
    var canSymbol = require('can-symbol');
    var canReflect = require('can-reflect');
    module.exports = function ensureMeta(obj) {
        var metaSymbol = canSymbol.for('can.meta');
        var meta = obj[metaSymbol];
        if (!meta) {
            meta = {};
            canReflect.setKeyValue(obj, metaSymbol, meta);
        }
        return meta;
    };
});
/*can-define@2.0.0-pre.11#map/map*/
define('can-define@2.0.0-pre.11#map/map', [
    'require',
    'exports',
    'module',
    'can-construct',
    'can-define',
    '../define-helpers/define-helpers',
    'can-observation',
    'can-namespace',
    'can-util/js/log/log',
    'can-reflect',
    'can-symbol',
    'can-util/js/cid-set/cid-set',
    'can-util/js/cid-map/cid-map',
    'can-util/js/dev/dev',
    'can-queues',
    '../ensure-meta',
    'can-log/dev/dev'
], function (require, exports, module) {
    var Construct = require('can-construct');
    var define = require('can-define');
    var defineHelpers = require('../define-helpers/define-helpers');
    var Observation = require('can-observation');
    var ns = require('can-namespace');
    var canLog = require('can-util/js/log/log');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var CIDSet = require('can-util/js/cid-set/cid-set');
    var CIDMap = require('can-util/js/cid-map/cid-map');
    var canDev = require('can-util/js/dev/dev');
    var queues = require('can-queues');
    var ensureMeta = require('../ensure-meta');
    var dev = require('can-log/dev/dev');
    var keysForDefinition = function (definitions) {
        var keys = [];
        for (var prop in definitions) {
            var definition = definitions[prop];
            if (typeof definition !== 'object' || ('serialize' in definition ? !!definition.serialize : !definition.get)) {
                keys.push(prop);
            }
        }
        return keys;
    };
    function assign(source) {
        queues.batch.start();
        canReflect.assignMap(this, source || {});
        queues.batch.stop();
    }
    function update(source) {
        queues.batch.start();
        canReflect.updateMap(this, source || {});
        queues.batch.stop();
    }
    function assignDeep(source) {
        queues.batch.start();
        canReflect.assignDeepMap(this, source || {});
        queues.batch.stop();
    }
    function updateDeep(source) {
        queues.batch.start();
        canReflect.updateDeepMap(this, source || {});
        queues.batch.stop();
    }
    function setKeyValue(key, value) {
        var defined = defineHelpers.defineExpando(this, key, value);
        if (!defined) {
            this[key] = value;
        }
    }
    function getKeyValue(key) {
        var value = this[key];
        if (value !== undefined || key in this || Object.isSealed(this)) {
            return value;
        } else {
            Observation.add(this, key);
            return this[key];
        }
    }
    var DefineMap = Construct.extend('DefineMap', {
        setup: function (base) {
            var key, prototype = this.prototype;
            if (DefineMap) {
                define(prototype, prototype, base.prototype._define);
                for (key in DefineMap.prototype) {
                    define.defineConfigurableAndNotEnumerable(prototype, key, prototype[key]);
                }
                this.prototype.setup = function (props) {
                    define.setup.call(this, props || {}, this.constructor.seal);
                };
            } else {
                for (key in prototype) {
                    define.defineConfigurableAndNotEnumerable(prototype, key, prototype[key]);
                }
            }
            define.defineConfigurableAndNotEnumerable(prototype, 'constructor', this);
        }
    }, {
        setup: function (props, sealed) {
            if (!this._define) {
                Object.defineProperty(this, '_define', {
                    enumerable: false,
                    value: { definitions: {} }
                });
                Object.defineProperty(this, '_data', {
                    enumerable: false,
                    value: {}
                });
            }
            define.setup.call(this, props || {}, sealed === true);
        },
        get: function (prop) {
            if (prop) {
                return getKeyValue.call(this, prop);
            } else {
                return canReflect.unwrap(this, CIDMap);
            }
        },
        set: function (prop, value) {
            if (typeof prop === 'object') {
                if (value === true) {
                    updateDeep.call(this, prop);
                } else {
                    assignDeep.call(this, prop);
                }
            } else {
                setKeyValue.call(this, prop, value);
            }
            return this;
        },
        assignDeep: function (prop) {
            assignDeep.call(this, prop);
            return this;
        },
        updateDeep: function (prop) {
            updateDeep.call(this, prop);
            return this;
        },
        assign: function (prop) {
            assign.call(this, prop);
            return this;
        },
        update: function (prop) {
            update.call(this, prop);
            return this;
        },
        serialize: function () {
            return canReflect.serialize(this, CIDMap);
        },
        forEach: function () {
            var forEach = function (list, cb, thisarg) {
                    return canReflect.eachKey(list, cb, thisarg);
                }, noObserve = Observation.ignore(forEach);
            return function (cb, thisarg, observe) {
                return observe === false ? noObserve(this, cb, thisarg) : forEach(this, cb, thisarg);
            };
        }(),
        '*': { type: define.types.observable },
        log: function (key) {
        }
    });
    canReflect.assignSymbols(DefineMap.prototype, {
        'can.isMapLike': true,
        'can.isListLike': false,
        'can.isValueLike': false,
        'can.getKeyValue': getKeyValue,
        'can.setKeyValue': setKeyValue,
        'can.deleteKeyValue': function (prop) {
            this.set(prop, undefined);
            return this;
        },
        'can.getOwnEnumerableKeys': function () {
            Observation.add(this, '__keys');
            return keysForDefinition(this._define.definitions).concat(keysForDefinition(this._instanceDefinitions));
        },
        'can.assignDeep': assignDeep,
        'can.updateDeep': updateDeep,
        'can.unwrap': defineHelpers.reflectUnwrap,
        'can.serialize': defineHelpers.reflectSerialize,
        'can.keyHasDependencies': function (key) {
            return !!(this._computed && this._computed[key] && this._computed[key].compute);
        },
        'can.getKeyDependencies': function (key) {
            var ret;
            if (this._computed && this._computed[key] && this._computed[key].compute) {
                ret = {};
                ret.valueDependencies = new CIDSet();
                ret.valueDependencies.add(this._computed[key].compute);
            }
            return ret;
        }
    });
    canReflect.setKeyValue(DefineMap.prototype, canSymbol.iterator, function () {
        return new define.Iterator(this);
    });
    for (var prop in define.eventsProto) {
        DefineMap[prop] = define.eventsProto[prop];
        Object.defineProperty(DefineMap.prototype, prop, {
            enumerable: false,
            value: define.eventsProto[prop],
            writable: true
        });
    }
    var eventsProtoSymbols = 'getOwnPropertySymbols' in Object ? Object.getOwnPropertySymbols(define.eventsProto) : [
        canSymbol.for('can.onKeyValue'),
        canSymbol.for('can.offKeyValue')
    ];
    eventsProtoSymbols.forEach(function (sym) {
        Object.defineProperty(DefineMap.prototype, sym, {
            enumerable: false,
            value: define.eventsProto[sym],
            writable: true
        });
    });
    define.DefineMap = DefineMap;
    Object.defineProperty(DefineMap.prototype, 'toObject', {
        enumerable: false,
        writable: true,
        value: function () {
            canLog.warn('Use DefineMap::get instead of DefineMap::toObject');
            return this.get();
        }
    });
    Object.defineProperty(DefineMap.prototype, 'each', {
        enumerable: false,
        writable: true,
        value: DefineMap.prototype.forEach
    });
    module.exports = ns.DefineMap = DefineMap;
});
/*can-component@4.0.0-pre.2#test/component-tag-test*/
define('can-component@4.0.0-pre.2#test/component-tag-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    './helpers',
    'can-simple-map',
    'can-stache',
    'can-component',
    'can-view-model',
    'can-util/dom/data/data',
    'can-define/map/map',
    'can-util/dom/events/events',
    'can-simple-observable/setter/setter',
    'can-simple-observable',
    'can-util/dom/mutate/mutate'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var helpers = require('./helpers');
    var SimpleMap = require('can-simple-map');
    var stache = require('can-stache');
    var Component = require('can-component');
    var canViewModel = require('can-view-model');
    var domData = require('can-util/dom/data/data');
    var DefineMap = require('can-define/map/map');
    var domEvents = require('can-util/dom/events/events');
    var SetterObservable = require('can-simple-observable/setter/setter');
    var SimpleObservable = require('can-simple-observable');
    var domMutate = require('can-util/dom/mutate/mutate');
    var innerHTML = function (el) {
        return el && el.innerHTML;
    };
    helpers.makeTests('can-component tag', function () {
        QUnit.test('hyphen-less tag names', function () {
            Component.extend({
                tag: 'foobar',
                view: stache('<div>{{name}}</div>'),
                viewModel: function () {
                    return new SimpleMap({ name: 'Brian' });
                }
            });
            var renderer = stache('<span></span><foobar></foobar>');
            var frag = renderer();
            equal(frag.lastChild.firstChild.firstChild.nodeValue, 'Brian');
        });
    });
});
/*can-define@2.0.0-pre.11#list/list*/
define('can-define@2.0.0-pre.11#list/list', [
    'require',
    'exports',
    'module',
    'can-construct',
    'can-define',
    'can-queues',
    'can-observation',
    'can-util/js/log/log',
    'can-util/js/dev/dev',
    '../define-helpers/define-helpers',
    'can-log/dev/dev',
    '../ensure-meta',
    'can-util/js/assign/assign',
    'can-util/js/diff/diff',
    'can-util/js/each/each',
    'can-util/js/make-array/make-array',
    'can-namespace',
    'can-reflect',
    'can-symbol',
    'can-util/js/cid-set/cid-set',
    'can-util/js/cid-map/cid-map',
    'can-util/js/single-reference/single-reference'
], function (require, exports, module) {
    var Construct = require('can-construct');
    var define = require('can-define');
    var make = define.make;
    var queues = require('can-queues');
    var Observation = require('can-observation');
    var canLog = require('can-util/js/log/log');
    var canDev = require('can-util/js/dev/dev');
    var defineHelpers = require('../define-helpers/define-helpers');
    var dev = require('can-log/dev/dev');
    var ensureMeta = require('../ensure-meta');
    var assign = require('can-util/js/assign/assign');
    var diff = require('can-util/js/diff/diff');
    var each = require('can-util/js/each/each');
    var makeArray = require('can-util/js/make-array/make-array');
    var ns = require('can-namespace');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var CIDSet = require('can-util/js/cid-set/cid-set');
    var CIDMap = require('can-util/js/cid-map/cid-map');
    var singleReference = require('can-util/js/single-reference/single-reference');
    var splice = [].splice;
    var runningNative = false;
    var identity = function (x) {
        return x;
    };
    var localOnPatchesSymbol = 'can.onPatches';
    var makeFilterCallback = function (props) {
        return function (item) {
            for (var prop in props) {
                if (item[prop] !== props[prop]) {
                    return false;
                }
            }
            return true;
        };
    };
    var onKeyValue = define.eventsProto[canSymbol.for('can.onKeyValue')];
    var offKeyValue = define.eventsProto[canSymbol.for('can.offKeyValue')];
    var DefineList = Construct.extend('DefineList', {
        setup: function (base) {
            if (DefineList) {
                var prototype = this.prototype;
                var result = define(prototype, prototype, base.prototype._define);
                var itemsDefinition = result.definitions['#'] || result.defaultDefinition;
                if (itemsDefinition) {
                    if (itemsDefinition.Type) {
                        this.prototype.__type = make.set.Type('*', itemsDefinition.Type, identity);
                    } else if (itemsDefinition.type) {
                        this.prototype.__type = make.set.type('*', itemsDefinition.type, identity);
                    }
                }
            }
        }
    }, {
        setup: function (items) {
            if (!this._define) {
                Object.defineProperty(this, '_define', {
                    enumerable: false,
                    value: {
                        definitions: {
                            length: { type: 'number' },
                            _length: { type: 'number' }
                        }
                    }
                });
                Object.defineProperty(this, '_data', {
                    enumerable: false,
                    value: {}
                });
            }
            define.setup.call(this, {}, false);
            Object.defineProperty(this, '_length', {
                enumerable: false,
                configurable: true,
                writable: true,
                value: 0
            });
            if (items) {
                this.splice.apply(this, [
                    0,
                    0
                ].concat(canReflect.toArray(items)));
            }
        },
        __type: define.types.observable,
        _triggerChange: function (attr, how, newVal, oldVal) {
            var index = +attr;
            if (!isNaN(index)) {
                var itemsDefinition = this._define.definitions['#'];
                if (how === 'add') {
                    if (itemsDefinition && typeof itemsDefinition.added === 'function') {
                        Observation.ignore(itemsDefinition.added).call(this, newVal, index);
                    }
                    queues.batch.start();
                    this.dispatch({ type: how }, [
                        newVal,
                        index
                    ]);
                    this.dispatch(localOnPatchesSymbol, [[{
                                insert: newVal,
                                index: index,
                                deleteCount: 0
                            }]]);
                    queues.batch.stop();
                } else if (how === 'remove') {
                    if (itemsDefinition && typeof itemsDefinition.removed === 'function') {
                        Observation.ignore(itemsDefinition.removed).call(this, oldVal, index);
                    }
                    queues.batch.start();
                    this.dispatch({ type: how }, [
                        oldVal,
                        index
                    ]);
                    this.dispatch(localOnPatchesSymbol, [[{
                                index: index,
                                deleteCount: oldVal.length
                            }]]);
                    queues.batch.stop();
                } else {
                    this.dispatch(how, [
                        newVal,
                        index
                    ]);
                }
            } else {
                this.dispatch({
                    type: '' + attr,
                    target: this
                }, [
                    newVal,
                    oldVal
                ]);
            }
        },
        get: function (index) {
            if (arguments.length) {
                if (isNaN(index)) {
                    Observation.add(this, index);
                } else {
                    Observation.add(this, 'length');
                }
                return this[index];
            } else {
                return canReflect.unwrap(this, CIDMap);
            }
        },
        set: function (prop, value) {
            if (typeof prop !== 'object') {
                prop = isNaN(+prop) || prop % 1 ? prop : +prop;
                if (typeof prop === 'number') {
                    if (typeof prop === 'number' && prop > this._length - 1) {
                        var newArr = new Array(prop + 1 - this._length);
                        newArr[newArr.length - 1] = value;
                        this.push.apply(this, newArr);
                        return newArr;
                    }
                    this.splice(prop, 1, value);
                } else {
                    var defined = defineHelpers.defineExpando(this, prop, value);
                    if (!defined) {
                        this[prop] = value;
                    }
                }
            } else {
                if (canReflect.isListLike(prop)) {
                    if (value) {
                        this.replace(prop);
                    } else {
                        canReflect.assignList(this, prop);
                    }
                } else {
                    canReflect.assignMap(this, prop);
                }
            }
            return this;
        },
        assign: function (prop) {
            if (canReflect.isListLike(prop)) {
                canReflect.assignList(this, prop);
            } else {
                canReflect.assignMap(this, prop);
            }
            return this;
        },
        update: function (prop) {
            if (canReflect.isListLike(prop)) {
                canReflect.updateList(this, prop);
            } else {
                canReflect.updateMap(this, prop);
            }
            return this;
        },
        assignDeep: function (prop) {
            if (canReflect.isListLike(prop)) {
                canReflect.assignDeepList(this, prop);
            } else {
                canReflect.assignDeepMap(this, prop);
            }
            return this;
        },
        updateDeep: function (prop) {
            if (canReflect.isListLike(prop)) {
                canReflect.updateDeepList(this, prop);
            } else {
                canReflect.updateDeepMap(this, prop);
            }
            return this;
        },
        _items: function () {
            var arr = [];
            this._each(function (item) {
                arr.push(item);
            });
            return arr;
        },
        _each: function (callback) {
            for (var i = 0, len = this._length; i < len; i++) {
                callback(this[i], i);
            }
        },
        splice: function (index, howMany) {
            var args = makeArray(arguments), added = [], i, len, listIndex, allSame = args.length > 2, oldLength = this._length;
            index = index || 0;
            for (i = 0, len = args.length - 2; i < len; i++) {
                listIndex = i + 2;
                args[listIndex] = this.__type(args[listIndex], listIndex);
                added.push(args[listIndex]);
                if (this[i + index] !== args[listIndex]) {
                    allSame = false;
                }
            }
            if (allSame && this._length <= added.length) {
                return added;
            }
            if (howMany === undefined) {
                howMany = args[1] = this._length - index;
            }
            runningNative = true;
            var removed = splice.apply(this, args);
            runningNative = false;
            queues.batch.start();
            if (howMany > 0) {
                this._triggerChange('' + index, 'remove', undefined, removed);
            }
            if (args.length > 2) {
                this._triggerChange('' + index, 'add', added, removed);
            }
            this.dispatch('length', [
                this._length,
                oldLength
            ]);
            queues.batch.stop();
            return removed;
        },
        serialize: function () {
            return canReflect.serialize(this, CIDMap);
        },
        log: function (key) {
        }
    });
    var getArgs = function (args) {
        return args[0] && Array.isArray(args[0]) ? args[0] : makeArray(args);
    };
    each({
        push: 'length',
        unshift: 0
    }, function (where, name) {
        var orig = [][name];
        DefineList.prototype[name] = function () {
            var args = [], len = where ? this._length : 0, i = arguments.length, res, val;
            while (i--) {
                val = arguments[i];
                args[i] = this.__type(val, i);
            }
            runningNative = true;
            res = orig.apply(this, args);
            runningNative = false;
            if (!this.comparator || args.length) {
                queues.batch.start();
                this._triggerChange('' + len, 'add', args, undefined);
                this.dispatch('length', [
                    this._length,
                    len
                ]);
                queues.batch.stop();
            }
            return res;
        };
    });
    each({
        pop: 'length',
        shift: 0
    }, function (where, name) {
        var orig = [][name];
        DefineList.prototype[name] = function () {
            if (!this._length) {
                return undefined;
            }
            var args = getArgs(arguments), len = where && this._length ? this._length - 1 : 0, oldLength = this._length ? this._length : 0, res;
            runningNative = true;
            res = orig.apply(this, args);
            runningNative = false;
            queues.batch.start();
            this._triggerChange('' + len, 'remove', undefined, [res]);
            this.dispatch('length', [
                this._length,
                oldLength
            ]);
            queues.batch.stop();
            return res;
        };
    });
    each({
        'map': 3,
        'filter': 3,
        'reduce': 4,
        'reduceRight': 4,
        'every': 3,
        'some': 3
    }, function a(fnLength, fnName) {
        DefineList.prototype[fnName] = function () {
            var self = this;
            var args = [].slice.call(arguments, 0);
            var callback = args[0];
            var thisArg = args[fnLength - 1] || self;
            if (typeof callback === 'object') {
                callback = makeFilterCallback(callback);
            }
            args[0] = function () {
                var cbArgs = [].slice.call(arguments, 0);
                cbArgs[fnLength - 3] = self.get(cbArgs[fnLength - 2]);
                return callback.apply(thisArg, cbArgs);
            };
            var ret = Array.prototype[fnName].apply(this, args);
            if (fnName === 'map') {
                return new DefineList(ret);
            } else if (fnName === 'filter') {
                return new self.constructor(ret);
            } else {
                return ret;
            }
        };
    });
    assign(DefineList.prototype, {
        indexOf: function (item, fromIndex) {
            for (var i = fromIndex || 0, len = this.length; i < len; i++) {
                if (this.get(i) === item) {
                    return i;
                }
            }
            return -1;
        },
        lastIndexOf: function (item, fromIndex) {
            fromIndex = typeof fromIndex === 'undefined' ? this.length - 1 : fromIndex;
            for (var i = fromIndex; i >= 0; i--) {
                if (this.get(i) === item) {
                    return i;
                }
            }
            return -1;
        },
        join: function () {
            Observation.add(this, 'length');
            return [].join.apply(this, arguments);
        },
        reverse: function () {
            var list = [].reverse.call(this._items());
            return this.replace(list);
        },
        slice: function () {
            Observation.add(this, 'length');
            var temp = Array.prototype.slice.apply(this, arguments);
            return new this.constructor(temp);
        },
        concat: function () {
            var args = [];
            each(arguments, function (arg) {
                if (canReflect.isListLike(arg)) {
                    var arr = Array.isArray(arg) ? arg : makeArray(arg);
                    arr.forEach(function (innerArg) {
                        args.push(this.__type(innerArg));
                    }, this);
                } else {
                    args.push(this.__type(arg));
                }
            }, this);
            return new this.constructor(Array.prototype.concat.apply(makeArray(this), args));
        },
        forEach: function (cb, thisarg) {
            var item;
            for (var i = 0, len = this.length; i < len; i++) {
                item = this.get(i);
                if (cb.call(thisarg || item, item, i, this) === false) {
                    break;
                }
            }
            return this;
        },
        replace: function (newList) {
            var patches = diff(this, newList);
            queues.batch.start();
            for (var i = 0, len = patches.length; i < len; i++) {
                this.splice.apply(this, [
                    patches[i].index,
                    patches[i].deleteCount
                ].concat(patches[i].insert));
            }
            queues.batch.stop();
            return this;
        },
        sort: function (compareFunction) {
            var removed = Array.prototype.slice.call(this);
            Array.prototype.sort.call(this, compareFunction);
            var added = Array.prototype.slice.call(this);
            queues.batch.start();
            this.dispatch('remove', [
                removed,
                0
            ]);
            this.dispatch('add', [
                added,
                0
            ]);
            this.dispatch('length', [
                this._length,
                this._length
            ]);
            queues.batch.stop();
            return this;
        }
    });
    for (var prop in define.eventsProto) {
        DefineList[prop] = define.eventsProto[prop];
        Object.defineProperty(DefineList.prototype, prop, {
            enumerable: false,
            value: define.eventsProto[prop],
            writable: true
        });
    }
    Object.defineProperty(DefineList.prototype, 'length', {
        get: function () {
            if (!this.__inSetup) {
                Observation.add(this, 'length');
            }
            return this._length;
        },
        set: function (newVal) {
            if (runningNative) {
                this._length = newVal;
                return;
            }
            if (newVal == null || isNaN(+newVal) || newVal === this._length) {
                return;
            }
            if (newVal > this._length - 1) {
                var newArr = new Array(newVal - this._length);
                this.push.apply(this, newArr);
            } else {
                this.splice(newVal);
            }
        },
        enumerable: true
    });
    Object.defineProperty(DefineList.prototype, 'each', {
        enumerable: false,
        writable: true,
        value: DefineList.prototype.forEach
    });
    DefineList.prototype.attr = function (prop, value) {
        canLog.warn('DefineMap::attr shouldn\'t be called');
        if (arguments.length === 0) {
            return this.get();
        } else if (prop && typeof prop === 'object') {
            return this.set.apply(this, arguments);
        } else if (arguments.length === 1) {
            return this.get(prop);
        } else {
            return this.set(prop, value);
        }
    };
    DefineList.prototype.item = function (index, value) {
        if (arguments.length === 1) {
            return this.get(index);
        } else {
            return this.set(index, value);
        }
    };
    DefineList.prototype.items = function () {
        canLog.warn('DefineList::get should should be used instead of DefineList::items');
        return this.get();
    };
    canReflect.assignSymbols(DefineList.prototype, {
        'can.isMoreListLikeThanMapLike': true,
        'can.isMapLike': true,
        'can.isListLike': true,
        'can.isValueLike': false,
        'can.getKeyValue': DefineList.prototype.get,
        'can.setKeyValue': DefineList.prototype.set,
        'can.onKeyValue': function (key, handler, queue) {
            var translationHandler;
            if (isNaN(key)) {
                return onKeyValue.apply(this, arguments);
            } else {
                translationHandler = function () {
                    handler(this[key]);
                };
                singleReference.set(handler, this, translationHandler, key);
                return onKeyValue.call(this, 'length', translationHandler, queue);
            }
        },
        'can.offKeyValue': function (key, handler, queue) {
            var translationHandler;
            if (isNaN(key)) {
                return offKeyValue.apply(this, arguments);
            } else {
                translationHandler = singleReference.getAndDelete(handler, this, key);
                return offKeyValue.call(this, 'length', translationHandler, queue);
            }
        },
        'can.deleteKeyValue': function (prop) {
            prop = isNaN(+prop) || prop % 1 ? prop : +prop;
            if (typeof prop === 'number') {
                this.splice(prop, 1);
            } else if (prop === 'length' || prop === '_length') {
                return;
            } else {
                this.set(prop, undefined);
            }
            return this;
        },
        'can.assignDeep': function (source) {
            queues.batch.start();
            canReflect.assignList(this, source);
            queues.batch.stop();
        },
        'can.updateDeep': function (source) {
            queues.batch.start();
            this.replace(source);
            queues.batch.stop();
        },
        'can.keyHasDependencies': function (key) {
            return !!(this._computed && this._computed[key] && this._computed[key].compute);
        },
        'can.getKeyDependencies': function (key) {
            var ret;
            if (this._computed && this._computed[key] && this._computed[key].compute) {
                ret = {};
                ret.valueDependencies = new CIDSet();
                ret.valueDependencies.add(this._computed[key].compute);
            }
            return ret;
        },
        'can.splice': function (index, deleteCount, insert) {
            this.splice.apply(this, [
                index,
                deleteCount
            ].concat(insert));
        },
        'can.onPatches': function (handler, queue) {
            this[canSymbol.for('can.onKeyValue')](localOnPatchesSymbol, handler, queue);
        },
        'can.offPatches': function (handler, queue) {
            this[canSymbol.for('can.offKeyValue')](localOnPatchesSymbol, handler, queue);
        }
    });
    canReflect.setKeyValue(DefineList.prototype, canSymbol.iterator, function () {
        var index = -1;
        if (typeof this._length !== 'number') {
            this._length = 0;
        }
        return {
            next: function () {
                index++;
                return {
                    value: this[index],
                    done: index >= this._length
                };
            }.bind(this)
        };
    });
    define.DefineList = DefineList;
    module.exports = ns.DefineList = DefineList;
});
/*can-component@4.0.0-pre.2#test/component-viewmodel-test*/
define('can-component@4.0.0-pre.2#test/component-viewmodel-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    './helpers',
    'can-simple-map',
    'can-stache',
    'can-component',
    'can-view-model',
    'can-util/dom/data/data',
    'can-define/map/map',
    'can-define/list/list',
    'can-util/dom/events/events',
    'can-simple-observable/setter/setter',
    'can-simple-observable',
    'can-util/dom/attr/attr',
    'can-reflect',
    'can-util/dom/mutate/mutate',
    'can-construct'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var helpers = require('./helpers');
    var SimpleMap = require('can-simple-map');
    var stache = require('can-stache');
    var Component = require('can-component');
    var canViewModel = require('can-view-model');
    var domData = require('can-util/dom/data/data');
    var DefineMap = require('can-define/map/map');
    var DefineList = require('can-define/list/list');
    var domEvents = require('can-util/dom/events/events');
    var SetterObservable = require('can-simple-observable/setter/setter');
    var SimpleObservable = require('can-simple-observable');
    var attr = require('can-util/dom/attr/attr');
    var canReflect = require('can-reflect');
    var domMutate = require('can-util/dom/mutate/mutate');
    var Construct = require('can-construct');
    var innerHTML = function (el) {
        return el && el.innerHTML;
    };
    helpers.makeTests('can-component viewModels', function () {
        QUnit.test('a SimpleMap constructor as .ViewModel', function () {
            var map = new SimpleMap({ name: 'Matthew' });
            Component.extend({
                tag: 'can-map-viewmodel',
                view: stache('{{name}}'),
                ViewModel: function () {
                    return map;
                }
            });
            var renderer = stache('<can-map-viewmodel></can-map-viewmodel>');
            equal(renderer().firstChild.firstChild.nodeValue, 'Matthew');
        });
        QUnit.test('a SimpleMap as viewModel', function () {
            var me = new SimpleMap({ name: 'Justin' });
            Component.extend({
                tag: 'my-viewmodel',
                view: stache('{{name}}}'),
                viewModel: me
            });
            var renderer = stache('<my-viewmodel></my-viewmodel>');
            equal(renderer().firstChild.firstChild.nodeValue, 'Justin');
        });
        QUnit.test('a SimpleMap constructor as viewModel', function () {
            var MyMap = SimpleMap.extend({
                setup: function (props) {
                    props.name = 'Matthew';
                    return SimpleMap.prototype.setup.apply(this, arguments);
                }
            });
            Component.extend({
                tag: 'can-map-viewmodel',
                view: stache('{{name}}'),
                viewModel: MyMap
            });
            var renderer = stache('<can-map-viewmodel></can-map-viewmodel>');
            equal(renderer().firstChild.firstChild.nodeValue, 'Matthew');
        });
        QUnit.test('an object is turned into a SimpleMap as viewModel', function () {
            Component.extend({
                tag: 'can-map-viewmodel',
                view: stache('{{name}}'),
                viewModel: {
                    setup: function (props) {
                        props.name = 'Matthew';
                        return SimpleMap.prototype.setup.apply(this, arguments);
                    }
                }
            });
            var renderer = stache('<can-map-viewmodel></can-map-viewmodel>');
            var fragOne = renderer();
            var vmOne = canViewModel(fragOne.firstChild);
            var fragTwo = renderer();
            vmOne.set('name', 'Wilbur');
            equal(fragOne.firstChild.firstChild.nodeValue, 'Wilbur', 'The first map changed values');
            equal(fragTwo.firstChild.firstChild.nodeValue, 'Matthew', 'The second map did not change');
        });
        test('Providing viewModel and ViewModel throws', function () {
            try {
                Component.extend({
                    tag: 'viewmodel-test',
                    view: stache('<div></div>'),
                    viewModel: {},
                    ViewModel: SimpleMap.extend({})
                });
                ok(false, 'Should have thrown because we provided both');
            } catch (er) {
                ok(true, 'It threw because we provided both viewModel and ViewModel');
            }
        });
        test('canViewModel utility', function () {
            Component({
                tag: 'my-taggy-tag',
                view: stache('<h1>hello</h1>'),
                viewModel: function () {
                    return new SimpleMap({ foo: 'bar' });
                }
            });
            var frag = stache('<my-taggy-tag id=\'x\'></my-taggy-tag>')();
            var el = frag.firstChild;
            equal(canViewModel(el), domData.get.call(el, 'viewModel'), 'one argument grabs the viewModel object');
            equal(canViewModel(el, 'foo'), 'bar', 'two arguments fetches a value');
            canViewModel(el, 'foo', 'baz');
            equal(canViewModel(el, 'foo'), 'baz', 'Three arguments sets the value');
        });
        test('setting passed variables - two way binding', function () {
            Component.extend({
                tag: 'my-toggler',
                view: stache('{{#if visible}}<content/>{{/if}}'),
                leakScope: true,
                ViewModel: DefineMap.extend({
                    visible: { value: true },
                    show: function () {
                        this.set('visible', true);
                    },
                    hide: function () {
                        this.set('visible', false);
                    }
                })
            });
            Component.extend({
                tag: 'my-app',
                ViewModel: DefineMap.extend({
                    visible: { value: true },
                    show: function () {
                        this.set('visible', true);
                    }
                })
            });
            var renderer = stache('<my-app>' + '{{^visible}}<button on:click="show()">show</button>{{/visible}}' + '<my-toggler visible:bind="visible">' + 'content' + '<button on:click="hide()">hide</button>' + '</my-toggler>' + '</my-app>');
            var frag = renderer({});
            var myApp = frag.firstChild, buttons = myApp.getElementsByTagName('button');
            equal(buttons.length, 1, 'there is one button');
            equal(innerHTML(buttons[0]), 'hide', 'the button\'s text is hide');
            domEvents.dispatch.call(buttons[0], 'click');
            buttons = myApp.getElementsByTagName('button');
            equal(buttons.length, 1, 'there is one button');
            equal(innerHTML(buttons[0]), 'show', 'the button\'s text is show');
            domEvents.dispatch.call(buttons[0], 'click');
            buttons = myApp.getElementsByTagName('button');
            equal(buttons.length, 1, 'there is one button');
            equal(innerHTML(buttons[0]), 'hide', 'the button\'s text is hide');
        });
        test('don\'t update computes unnecessarily', function () {
            var sourceAge = new SimpleObservable(30), timesComputeIsCalled = 0;
            var age = new SetterObservable(function () {
                timesComputeIsCalled++;
                if (timesComputeIsCalled === 1) {
                    ok(true, 'reading initial value to set as years');
                } else if (timesComputeIsCalled === 3) {
                    ok(true, 'updating value to 31');
                } else {
                    ok(false, 'You\'ve called the callback ' + timesComputeIsCalled + ' times');
                }
                return sourceAge.get();
            }, function (newVal) {
                timesComputeIsCalled++;
                if (timesComputeIsCalled === 2) {
                    ok(true, 'called back another time after set to get the value');
                } else {
                    ok(false, 'You\'ve called the callback ' + timesComputeIsCalled + ' times');
                }
                sourceAge.set(newVal);
            });
            Component.extend({ tag: 'age-er' });
            var renderer = stache('<age-er years:bind=\'age\'></age-er>');
            renderer({ age: age });
            age.set(31);
        });
        test('viewModel not rebound correctly (#550)', function () {
            var nameChanges = 0;
            Component.extend({
                tag: 'viewmodel-rebinder',
                events: {
                    '{name}': function () {
                        nameChanges++;
                    }
                }
            });
            var renderer = stache('<viewmodel-rebinder></viewmodel-rebinder>');
            var frag = renderer();
            var viewModel = canViewModel(frag.firstChild);
            var n1 = new SimpleObservable(), n2 = new SimpleObservable();
            viewModel.set('name', n1);
            n1.set('updated');
            viewModel.set('name', n2);
            n2.set('updated');
            equal(nameChanges, 2);
        });
        test('id and class should work now (#694)', function () {
            Component.extend({
                tag: 'stay-classy',
                ViewModel: SimpleMap.extend({
                    setup: function (props) {
                        canReflect.assign(props, {
                            notid: 'foo',
                            notclass: 5,
                            notdataviewid: {}
                        });
                        return SimpleMap.prototype.setup.apply(this, arguments);
                    }
                })
            });
            var data = {
                idData: 'id-success',
                classData: 'class-success'
            };
            var frag = stache('<stay-classy id:bind=\'idData\'' + ' class:bind=\'classData\'></stay-classy>')(data);
            var stayClassy = frag.firstChild;
            domMutate.appendChild.call(this.fixture, frag);
            var viewModel = canViewModel(stayClassy);
            equal(viewModel.get('id'), 'id-success');
            equal(viewModel.get('class'), 'class-success');
        });
        test('Construct are passed normally', function () {
            var Constructed = Construct.extend({ foo: 'bar' }, {});
            Component.extend({
                tag: 'con-struct',
                view: stache('{{con.foo}}')
            });
            var stached = stache('<con-struct con:bind=\'Constructed\'></con-struct>');
            var res = stached({ Constructed: Constructed });
            equal(innerHTML(res.firstChild), 'bar');
        });
        test('Component two way binding loop (#1579)', function () {
            var changeCount = 0;
            Component.extend({
                tag: 'product-swatch-color',
                viewModel: { tag: 'product-swatch-color' }
            });
            Component.extend({
                tag: 'product-swatch',
                view: stache('<product-swatch-color {(variations)}="variations"></product-swatch-color>'),
                ViewModel: DefineMap.extend({
                    variations: {
                        set: function (variations) {
                            if (changeCount > 500) {
                                return;
                            }
                            changeCount++;
                            return new DefineList(variations.get());
                        }
                    }
                })
            });
            var frag = stache('<product-swatch></product-swatch>')(), productSwatch = frag.firstChild;
            canViewModel(productSwatch).set('variations', new DefineList());
            ok(changeCount < 500, 'more than 500 events');
        });
        test('two-way binding syntax INTRODUCED in v2.3 ALLOWS a child property to initialize an undefined parent property', function () {
            var renderer = stache('<pa-rent/>');
            Component.extend({
                tag: 'pa-rent',
                view: stache('<chi-ld childProp:bind="parentProp" />')
            });
            Component.extend({
                tag: 'chi-ld',
                ViewModel: {
                    setup: function (props) {
                        props.childProp = 'bar';
                        return SimpleMap.prototype.setup.apply(this, arguments);
                    }
                }
            });
            var frag = renderer({});
            var parentVM = canViewModel(frag.firstChild);
            var childVM = canViewModel(frag.firstChild.firstChild);
            equal(parentVM.get('parentProp'), 'bar', 'parentProp is bar');
            equal(childVM.get('childProp'), 'bar', 'childProp is bar');
            parentVM.set('parentProp', 'foo');
            equal(parentVM.get('parentProp'), 'foo', 'parentProp is foo');
            equal(childVM.get('childProp'), 'foo', 'childProp is foo');
            childVM.set('childProp', 'baz');
            equal(parentVM.get('parentProp'), 'baz', 'parentProp is baz');
            equal(childVM.get('childProp'), 'baz', 'childProp is baz');
        });
        test('conditional attributes (#2077)', function () {
            Component.extend({ tag: 'some-comp' });
            var renderer = stache('<some-comp ' + '{{#if preview}}next:from=\'nextPage\'{{/if}} ' + 'swap:from=\'{{swapName}}\' ' + '{{#preview}}checked{{/preview}} ' + '></some-comp>');
            var map = new SimpleMap({
                preview: true,
                nextPage: 2,
                swapName: 'preview'
            });
            var frag = renderer(map);
            var vm = canViewModel(frag.firstChild);
            var threads = [
                function () {
                    equal(vm.get('next'), 2, 'has binidng');
                    equal(vm.get('swap'), true, 'swap - has binding');
                    map.attr('preview', false);
                },
                function () {
                    equal(vm.get('swap'), false, 'swap - updated binidng');
                    map.attr('nextPage', 3);
                    equal(vm.get('next'), 2, 'not updating after binding is torn down');
                    map.attr('preview', true);
                },
                function () {
                    equal(vm.get('next'), 3, 're-initialized with binding');
                    equal(vm.get('swap'), true, 'swap - updated binidng');
                    map.attr('swapName', 'nextPage');
                },
                function () {
                    equal(vm.get('swap'), 3, 'swap - updated binding key');
                    map.attr('nextPage', 4);
                    equal(vm.get('swap'), 4, 'swap - updated binding');
                }
            ];
            stop();
            var index = 0;
            var next = function () {
                if (index < threads.length) {
                    threads[index]();
                    index++;
                    setTimeout(next, 150);
                } else {
                    start();
                }
            };
            setTimeout(next, 100);
        });
        QUnit.test('one-way - child to parent - parent that does not leak scope, but has no view', function () {
            Component.extend({
                tag: 'outer-noleak',
                viewModel: {},
                leakScope: false
            });
            Component.extend({
                tag: 'my-child',
                viewModel: {},
                leakScope: false
            });
            var renderer = stache('<outer-noleak><my-child this:to=\'myChild\'/></outer-noleak>');
            var frag = renderer();
            var vm = canViewModel(frag.firstChild);
            ok(vm.get('myChild') instanceof SimpleMap, 'got instance');
        });
    });
});
/*can-component@4.0.0-pre.2#test/component-view-test*/
define('can-component@4.0.0-pre.2#test/component-view-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    './helpers',
    'can-simple-map',
    'can-stache',
    'can-component',
    'can-util/dom/events/events',
    'can-util/dom/mutate/mutate',
    'can-view-model',
    'can-define/map/map',
    'can-queues',
    'can-util/dom/fragment/fragment',
    'can-view-callbacks',
    'can-view-scope',
    'can-queues'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var helpers = require('./helpers');
    var SimpleMap = require('can-simple-map');
    var stache = require('can-stache');
    var Component = require('can-component');
    var domEvents = require('can-util/dom/events/events');
    var domMutate = require('can-util/dom/mutate/mutate');
    var canViewModel = require('can-view-model');
    var DefineMap = require('can-define/map/map');
    var queues = require('can-queues');
    var getFragment = require('can-util/dom/fragment/fragment');
    var viewCallbacks = require('can-view-callbacks');
    var Scope = require('can-view-scope');
    var innerHTML = function (el) {
        return el && el.innerHTML;
    };
    helpers.makeTests('can-component views', function (doc, runTestInOnlyDocument) {
        QUnit.test('lexical scoping', function () {
            Component.extend({
                tag: 'hello-world',
                view: stache('{{greeting}} <content>World</content>{{exclamation}}'),
                viewModel: function () {
                    return new SimpleMap({ greeting: 'Hello' });
                }
            });
            var renderer = stache('<hello-world>{{greeting}}</hello-world>');
            var frag = renderer({
                greeting: 'World',
                exclamation: '!'
            });
            var hello = frag.firstChild;
            equal(hello.innerHTML.trim(), 'Hello World');
            Component.extend({
                tag: 'hello-world-no-template',
                leakScope: false,
                viewModel: function () {
                    return new SimpleMap({ greeting: 'Hello' });
                }
            });
            renderer = stache('<hello-world-no-template>{{greeting}}</hello-world-no-template>');
            frag = renderer({
                greeting: 'World',
                exclamation: '!'
            });
            hello = frag.firstChild;
            equal(hello.innerHTML.trim(), 'Hello', 'If no view is provided to Component, treat <content> bindings as dynamic.');
        });
        QUnit.test('dynamic scoping', function () {
            Component.extend({
                tag: 'hello-world',
                leakScope: true,
                view: stache('{{greeting}} <content>World</content>{{exclamation}}'),
                viewModel: function () {
                    return new SimpleMap({ greeting: 'Hello' });
                }
            });
            var renderer = stache('<hello-world>{{greeting}}</hello-world>');
            var frag = renderer({
                greeting: 'World',
                exclamation: '!'
            });
            var hello = frag.firstChild;
            equal(hello.innerHTML.trim(), 'Hello Hello!');
        });
        QUnit.test('hello-world and whitespace around custom elements', function () {
            Component.extend({
                tag: 'hello-world',
                view: stache('{{#if visible}}{{message}}{{else}}Click me{{/if}}'),
                viewModel: function () {
                    return new SimpleMap({
                        visible: false,
                        message: 'Hello There!'
                    });
                },
                events: {
                    click: function () {
                        this.viewModel.attr('visible', true);
                    }
                }
            });
            var renderer = stache('  <hello-world></hello-world>  ');
            var frag = renderer({});
            var helloWorld = frag.childNodes.item(1);
            domEvents.dispatch.call(helloWorld, 'click');
            equal(helloWorld.innerHTML, 'Hello There!');
        });
        QUnit.test('self closing content tags', function () {
            Component.extend({
                'tag': 'my-greeting',
                view: stache('<h1><content/></h1>'),
                viewModel: function () {
                    return new SimpleMap({ title: 'Component' });
                }
            });
            var renderer = stache('<my-greeting><span>{{site}} - {{title}}</span></my-greeting>');
            var frag = renderer({ site: 'CanJS' });
            equal(frag.firstChild.getElementsByTagName('span').length, 1, 'there is an h1');
        });
        QUnit.test('content extension stack overflow error', function () {
            Component({
                tag: 'outer-tag',
                view: stache('<inner-tag>inner-tag CONTENT <content/></inner-tag>')
            });
            Component({
                tag: 'inner-tag',
                view: stache('inner-tag TEMPLATE <content/>')
            });
            var renderer = stache('<outer-tag>outer-tag CONTENT</outer-tag>');
            var frag = renderer();
            equal(innerHTML(frag.firstChild.firstChild), 'inner-tag TEMPLATE inner-tag CONTENT outer-tag CONTENT');
        });
        QUnit.test('inserted event fires twice if component inside live binding block', function () {
            var inited = 0, inserted = 0;
            Component.extend({
                tag: 'child-tag',
                ViewModel: SimpleMap.extend({
                    init: function () {
                        inited++;
                    }
                }),
                events: {
                    ' inserted': function () {
                        inserted++;
                    }
                }
            });
            Component.extend({
                tag: 'parent-tag',
                view: stache('{{#shown}}<child-tag></child-tag>{{/shown}}'),
                viewModel: { shown: false },
                events: {
                    ' inserted': function () {
                        this.viewModel.attr('shown', true);
                    }
                }
            });
            var frag = stache('<parent-tag id=\'pt\'></parent-tag>')({});
            domMutate.appendChild.call(this.fixture, frag);
            stop();
            function checkCount() {
                if (inserted >= 1) {
                    equal(inited, 1, 'inited');
                    equal(inserted, 1, 'inserted');
                    start();
                } else {
                    setTimeout(checkCount, 30);
                }
            }
            checkCount();
        });
        QUnit.test('Same component tag nested', function () {
            Component({
                'tag': 'my-tag',
                view: stache('<p><content/></p>')
            });
            var renderer = stache('<div><my-tag>Outter<my-tag>Inner</my-tag></my-tag></div>');
            var renderer2 = stache('<div><my-tag>3<my-tag>2<my-tag>1<my-tag>0</my-tag></my-tag></my-tag></my-tag></div>');
            var renderer3 = stache('<div><my-tag>First</my-tag><my-tag>Second</my-tag></div>');
            equal(renderer({}).firstChild.getElementsByTagName('p').length, 2, 'proper number of p tags');
            equal(renderer2({}).firstChild.getElementsByTagName('p').length, 4, 'proper number of p tags');
            equal(renderer3({}).firstChild.getElementsByTagName('p').length, 2, 'proper number of p tags');
        });
        QUnit.test('nested component within an #if is not live bound(#1025)', function () {
            Component.extend({
                tag: 'parent-component',
                view: stache('{{#if shown}}<child-component></child-component>{{/if}}'),
                viewModel: function () {
                    return new SimpleMap({ shown: false });
                }
            });
            Component.extend({
                tag: 'child-component',
                view: stache('Hello world.')
            });
            var renderer = stache('<parent-component></parent-component>');
            var frag = renderer({});
            equal(innerHTML(frag.firstChild), '', 'child component is not inserted');
            canViewModel(frag.firstChild).attr('shown', true);
            equal(innerHTML(frag.firstChild.firstChild), 'Hello world.', 'child component is inserted');
            canViewModel(frag.firstChild).attr('shown', false);
            equal(innerHTML(frag.firstChild), '', 'child component is removed');
        });
        var queues = require('can-queues');
        QUnit.test('references scopes are available to bindings nested in components (#2029)', function () {
            var renderer = stache('<export-er value:to="*reference" />' + '<wrap-er><simple-example key:from="*reference"/></wrap-er>');
            Component.extend({ tag: 'wrap-er' });
            Component.extend({
                tag: 'export-er',
                events: {
                    'init': function () {
                        var self = this.viewModel;
                        stop();
                        setTimeout(function () {
                            self.set('value', 100);
                            var wrapper = frag.lastChild, simpleExample = wrapper.firstChild, textNode = simpleExample.firstChild;
                            equal(textNode.nodeValue, '100', 'updated value with reference');
                            start();
                        }, 100);
                    }
                }
            });
            Component.extend({
                tag: 'simple-example',
                view: stache('{{key}}')
            });
            var frag = renderer({});
        });
        test('<content> (#2151)', function () {
            var mapInstance = new DefineMap({
                items: [
                    {
                        id: 1,
                        context: 'Item 1',
                        render: false
                    },
                    {
                        id: 2,
                        context: 'Item 2',
                        render: false
                    }
                ]
            });
            Component.extend({
                tag: 'list-items',
                view: stache('<ul>' + '{{#items}}' + '{{#if render}}' + '<li><content /></li>' + '{{/if}}' + '{{/items}}' + '</ul>'),
                viewModel: mapInstance,
                leakScope: true
            });
            Component.extend({
                tag: 'list-item',
                view: stache('{{item.context}}')
            });
            var renderer = stache('<list-items><list-item item:from=\'this\'/></list-items>');
            var frag = renderer();
            queues.batch.start();
            canViewModel(frag.firstChild).get('items').forEach(function (item, index) {
                item.set('render', true);
            });
            queues.batch.stop();
            var lis = frag.firstChild.getElementsByTagName('li');
            ok(innerHTML(lis[0]).indexOf('Item 1') >= 0, 'Item 1 written out');
            ok(innerHTML(lis[1]).indexOf('Item 2') >= 0, 'Item 2 written out');
        });
        QUnit.test('two-way - reference - with <content> tag', function () {
            Component.extend({
                tag: 'other-export',
                viewModel: function () {
                    return new SimpleMap({ name: 'OTHER-EXPORT' });
                }
            });
            Component.extend({
                tag: 'ref-export',
                view: stache('<other-export name:bind="*otherExport"/><content>{{*otherExport}}</content>')
            });
            var t1 = stache('<ref-export></ref-export>');
            var f1 = t1();
            equal(canViewModel(f1.firstChild.firstChild).get('name'), 'OTHER-EXPORT', 'viewModel set correctly');
            equal(f1.firstChild.lastChild.nodeValue, 'OTHER-EXPORT', 'content');
        });
        runTestInOnlyDocument('custom renderer can provide setupBindings', function () {
            var rendererFactory = function (tmpl) {
                var frag = getFragment(tmpl);
                return function (scope, options) {
                    scope = scope || new Scope();
                    options = options || new Scope.Options({});
                    if (frag.firstChild.nodeName === 'CUSTOM-RENDERER') {
                        viewCallbacks.tagHandler(frag.firstChild, 'custom-renderer', {
                            scope: scope,
                            options: options,
                            templateType: 'my-renderer',
                            setupBindings: function (el, callback, data) {
                                callback({ foo: 'qux' });
                            }
                        });
                    } else {
                        var tn = frag.firstChild.firstChild;
                        tn.nodeValue = scope.read('foo').value;
                    }
                    return frag;
                };
            };
            Component.extend({
                tag: 'custom-renderer',
                view: rendererFactory('<div>{{foo}}</div>'),
                ViewModel: SimpleMap.extend({})
            });
            var renderer = rendererFactory('<custom-renderer foo=\'bar\'></custom-renderer>');
            var frag = renderer();
            var tn = frag.firstChild.firstChild.firstChild;
            equal(tn.nodeValue, 'qux', 'was bound!');
        });
    });
});
/*can-component@4.0.0-pre.2#test/component-helpers-test*/
define('can-component@4.0.0-pre.2#test/component-helpers-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    './helpers',
    'can-simple-map',
    'can-stache',
    'can-component',
    'can-util/dom/events/events'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var helpers = require('./helpers');
    var SimpleMap = require('can-simple-map');
    var stache = require('can-stache');
    var Component = require('can-component');
    var domEvents = require('can-util/dom/events/events');
    var innerHTML = function (el) {
        return el && el.innerHTML;
    };
    helpers.makeTests('can-component helpers', function () {
        QUnit.test('helpers reference the correct instance (#515)', function () {
            expect(2);
            Component({
                tag: 'my-text',
                view: stache('<p>{{valueHelper}}</p>'),
                helpers: {
                    valueHelper: function () {
                        return this.attr('value');
                    }
                }
            });
            var renderer = stache('<my-text value:from="\'value1\'"></my-text><my-text value:from="\'value2\'"></my-text>');
            var frag = renderer({});
            equal(frag.firstChild.firstChild.firstChild.nodeValue, 'value1');
            equal(frag.lastChild.firstChild.firstChild.nodeValue, 'value2');
        });
    });
});
/*can-component@4.0.0-pre.2#test/component-events-test*/
define('can-component@4.0.0-pre.2#test/component-events-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    './helpers',
    'can-simple-map',
    'can-stache',
    'can-component',
    'can-view-model',
    'can-simple-observable',
    'can-util/dom/mutate/mutate'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var QUnit = require('steal-qunit');
        var helpers = require('./helpers');
        var SimpleMap = require('can-simple-map');
        var stache = require('can-stache');
        var Component = require('can-component');
        var canViewModel = require('can-view-model');
        var SimpleObservable = require('can-simple-observable');
        var domMutate = require('can-util/dom/mutate/mutate');
        helpers.makeTests('can-component events', function () {
            test('value observables formerly (#550)', function () {
                var nameChanges = 0;
                Component.extend({
                    tag: 'viewmodel-rebinder',
                    events: {
                        '{name}': function () {
                            nameChanges++;
                        }
                    }
                });
                var renderer = stache('<viewmodel-rebinder></viewmodel-rebinder>');
                var frag = renderer();
                var viewModel = canViewModel(frag.firstChild);
                var n1 = new SimpleObservable(), n2 = new SimpleObservable();
                viewModel.set('name', n1);
                n1.set('updated');
                viewModel.set('name', n2);
                n2.set('updated');
                equal(nameChanges, 2);
            });
            test('Component events bind to window', function () {
                window.tempMap = new SimpleMap();
                Component.extend({
                    tag: 'window-events',
                    events: {
                        '{tempMap} prop': function () {
                            ok(true, 'called templated event');
                        }
                    }
                });
                var renderer = stache('<window-events></window-events>');
                renderer();
                window.tempMap.set('prop', 'value');
                window.tempMap = undefined;
                try {
                    delete window.tempMap;
                } catch (e) {
                }
            });
            QUnit.test('stache conditionally nested components calls inserted once (#967)', function () {
                expect(1);
                Component.extend({
                    tag: 'can-parent-stache',
                    viewModel: function () {
                        return new SimpleMap({ shown: true });
                    },
                    view: stache('{{#if shown}}<can-child></can-child>{{/if}}')
                });
                Component.extend({
                    tag: 'can-child',
                    events: {
                        inserted: function () {
                            ok(true, 'called inserted once');
                        }
                    }
                });
                var renderer = stache('<can-parent-stache></can-parent-stache>');
                domMutate.appendChild.call(this.fixture, renderer());
                stop();
                setTimeout(start, 100);
            });
            QUnit.test('viewModel objects with Constructor functions as properties do not get converted (#1261)', 1, function () {
                stop();
                var HANDLER;
                var Test = SimpleMap.extend({
                    addEventListener: function (ev, handler) {
                        HANDLER = handler;
                    },
                    removeEventListener: function () {
                    }
                }, {
                    setup: function (props) {
                        props.test = 'Yeah';
                        return SimpleMap.prototype.setup.apply(this, arguments);
                    }
                });
                Component.extend({
                    tag: 'my-app',
                    viewModel: {
                        setup: function (props) {
                            props.MyConstruct = Test;
                            return SimpleMap.prototype.setup.apply(this, arguments);
                        }
                    },
                    events: {
                        '{MyConstruct} something': function () {
                            ok(true, 'Event got triggered');
                            start();
                        }
                    }
                });
                var frag = stache('<my-app></my-app>')();
                domMutate.appendChild.call(this.fixture, frag);
                HANDLER.call(Test, { type: 'something' });
            });
            QUnit.test('removing bound viewModel properties on destroy #1415', function () {
                var state = new SimpleMap({
                    product: new SimpleMap({
                        id: 1,
                        name: 'Tom'
                    })
                });
                Component.extend({
                    tag: 'destroyable-component',
                    events: {
                        destroy: function () {
                            this.viewModel.set('product', null);
                        }
                    }
                });
                var frag = stache('<destroyable-component product:bind="product"></destroyable-component>')(state);
                domMutate.appendChild.call(this.fixture, frag);
                domMutate.removeChild.call(this.fixture, this.fixture.firstChild);
                stop();
                helpers.afterMutation(function () {
                    ok(state.attr('product') == null, 'product was removed');
                    start();
                });
            });
            test('changing viewModel property rebinds {viewModel.<...>} events (#1529)', 2, function () {
                Component.extend({
                    tag: 'rebind-viewmodel',
                    events: {
                        init: function () {
                            this.viewModel.set('item', new SimpleMap({}));
                        },
                        '{scope.item} name': function () {
                            ok(true, 'Change event on scope');
                        },
                        '{viewModel.item} name': function () {
                            ok(true, 'Change event on viewModel');
                        }
                    }
                });
                var frag = stache('<rebind-viewmodel></rebind-viewmodel>')();
                var rebind = frag.firstChild;
                domMutate.appendChild.call(this.fixture, rebind);
                canViewModel(rebind).get('item').set('name', 'CDN');
            });
            test('DOM trees not releasing when referencing CanMap inside CanMap in view (#1593)', function () {
                var baseTemplate = stache('{{#if show}}<my-outside></my-outside>{{/if}}'), show = new SimpleObservable(true), state = new SimpleMap({ inner: 1 });
                var removeCount = 0;
                Component.extend({
                    tag: 'my-inside',
                    events: {
                        removed: function () {
                            removeCount++;
                        }
                    },
                    leakScope: true
                });
                Component.extend({
                    tag: 'my-outside',
                    view: stache('{{#if state.inner}}<my-inside></my-inside>{{/if}}'),
                    leakScope: true
                });
                domMutate.appendChild.call(this.fixture, baseTemplate({
                    show: show,
                    state: state
                }));
                helpers.runTasks([
                    function () {
                        show.set(false);
                    },
                    function () {
                        state.set('inner', null);
                    },
                    function () {
                        equal(removeCount, 1, 'internal removed once');
                        show.set(true);
                    },
                    function () {
                        state.set('inner', 2);
                    },
                    function () {
                        state.set('inner', null);
                    },
                    function () {
                        equal(removeCount, 2, 'internal removed twice');
                    }
                ]);
                stop();
            });
        });
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-component@4.0.0-pre.2#test/example-test*/
define('can-component@4.0.0-pre.2#test/example-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    './helpers',
    'can-simple-map',
    'can-stache',
    'can-component',
    'can-define/list/list',
    'can-define/map/map',
    'can-util/dom/events/events',
    'can-view-model',
    'can-util/dom/mutate/mutate',
    'can-util/js/log/log',
    'can-queues'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var helpers = require('./helpers');
    var SimpleMap = require('can-simple-map');
    var stache = require('can-stache');
    var Component = require('can-component');
    var DefineList = require('can-define/list/list');
    var DefineMap = require('can-define/map/map');
    var domEvents = require('can-util/dom/events/events');
    var canViewModel = require('can-view-model');
    var domMutate = require('can-util/dom/mutate/mutate');
    var canLog = require('can-util/js/log/log');
    var queues = require('can-queues');
    var innerHTML = function (el) {
        return el && el.innerHTML;
    };
    helpers.makeTests('can-component examples', function (doc) {
        var Paginate = DefineMap.extend({
            count: { value: Infinity },
            offset: { value: 0 },
            limit: { value: 100 },
            setCount: function (newCount, success, error) {
                return newCount < 0 ? 0 : newCount;
            },
            setOffset: function (newOffset) {
                return newOffset < 0 ? 0 : Math.min(newOffset, !isNaN(this.count - 1) ? this.count - 1 : Infinity);
            },
            next: function () {
                this.set('offset', this.offset + this.limit);
            },
            prev: function () {
                this.set('offset', this.offset - this.limit);
            },
            canNext: function () {
                return this.get('offset') < this.get('count') - this.get('limit');
            },
            canPrev: function () {
                return this.get('offset') > 0;
            },
            page: function (newVal) {
                if (newVal === undefined) {
                    return Math.floor(this.get('offset') / this.get('limit')) + 1;
                } else {
                    this.set('offset', (parseInt(newVal) - 1) * this.get('limit'));
                }
            },
            pageCount: function () {
                return this.get('count') ? Math.ceil(this.get('count') / this.get('limit')) : null;
            }
        });
        test('treecombo', function () {
            var TreeComboViewModel = DefineMap.extend({
                items: { Value: DefineList },
                breadcrumb: { Value: DefineList },
                selected: { Value: DefineList },
                selectableItems: function () {
                    var breadcrumb = this.get('breadcrumb');
                    if (breadcrumb.length) {
                        return breadcrumb[breadcrumb.length - 1].children;
                    } else {
                        return this.get('items');
                    }
                },
                showChildren: function (item, ev) {
                    ev.stopPropagation();
                    this.get('breadcrumb').push(item);
                },
                emptyBreadcrumb: function () {
                    this.get('breadcrumb').update([]);
                },
                updateBreadcrumb: function (item) {
                    var breadcrumb = this.get('breadcrumb'), index = breadcrumb.indexOf(item);
                    breadcrumb.splice(index + 1, breadcrumb.length - index - 1);
                },
                toggle: function (item) {
                    var selected = this.get('selected'), index = selected.indexOf(item);
                    if (index === -1) {
                        selected.push(item);
                    } else {
                        selected.splice(index, 1);
                    }
                },
                isSelected: function (item) {
                    return this.get('selected').indexOf(item) > -1;
                }
            });
            Component.extend({
                tag: 'treecombo',
                view: stache('<ul class=\'breadcrumb\'>' + '<li on:click=\'emptyBreadcrumb()\'>{{title}}</li>' + '{{#each breadcrumb}}' + '<li on:click=\'updateBreadcrumb(this)\'>{{title}}</li>' + '{{/each}}' + '</ul>' + '<ul class=\'options\'>' + '<content>' + '{{#selectableItems}}' + '<li {{#isSelected(.)}}class=\'active\'{{/isSelected}} on:click=\'toggle(this)\'>' + '<input type=\'checkbox\' {{#isSelected(.)}}checked{{/isSelected}}/>' + '{{title}}' + '{{#if children.length}}' + '<button class=\'showChildren\' on:click=\'showChildren(this, %event)\'>+</button>' + '{{/if}}' + '</li>' + '{{/selectableItems}}' + '</content>' + '</ul>'),
                ViewModel: TreeComboViewModel
            });
            var renderer = stache('<treecombo items:bind=\'locations\' title:from=\'"Locations"\'></treecombo>');
            var base = new DefineMap({});
            var frag = renderer(base);
            var root = doc.createElement('div');
            root.appendChild(frag);
            var items = [
                {
                    id: 1,
                    title: 'Midwest',
                    children: [
                        {
                            id: 5,
                            title: 'Illinois',
                            children: [
                                {
                                    id: 23423,
                                    title: 'Chicago'
                                },
                                {
                                    id: 4563,
                                    title: 'Springfield'
                                },
                                {
                                    id: 4564,
                                    title: 'Naperville'
                                }
                            ]
                        },
                        {
                            id: 6,
                            title: 'Wisconsin',
                            children: [
                                {
                                    id: 232423,
                                    title: 'Milwaulkee'
                                },
                                {
                                    id: 45463,
                                    title: 'Green Bay'
                                },
                                {
                                    id: 45464,
                                    title: 'Madison'
                                }
                            ]
                        }
                    ]
                },
                {
                    id: 2,
                    title: 'East Coast',
                    children: [
                        {
                            id: 25,
                            title: 'New York',
                            children: [
                                {
                                    id: 3413,
                                    title: 'New York'
                                },
                                {
                                    id: 4613,
                                    title: 'Rochester'
                                },
                                {
                                    id: 4516,
                                    title: 'Syracuse'
                                }
                            ]
                        },
                        {
                            id: 6,
                            title: 'Pennsylvania',
                            children: [
                                {
                                    id: 2362423,
                                    title: 'Philadelphia'
                                },
                                {
                                    id: 454663,
                                    title: 'Harrisburg'
                                },
                                {
                                    id: 454664,
                                    title: 'Scranton'
                                }
                            ]
                        }
                    ]
                }
            ];
            stop();
            setTimeout(function () {
                base.set('locations', items);
                var itemsList = base.get('locations');
                var treecombo = root.firstChild, breadcrumb = treecombo.firstChild, breadcrumbLIs = function () {
                        return breadcrumb.getElementsByTagName('li');
                    }, options = treecombo.lastChild, optionsLis = function () {
                        return options.getElementsByTagName('li');
                    };
                equal(breadcrumbLIs().length, 1, 'Only the default title is shown');
                equal(breadcrumbLIs()[0].innerHTML, 'Locations', 'The correct title from the attribute is shown');
                equal(itemsList.length, optionsLis().length, 'first level items are displayed');
                domEvents.dispatch.call(optionsLis()[0], 'click');
                equal(optionsLis()[0].className, 'active', 'toggling something not selected adds active');
                ok(optionsLis()[0].getElementsByTagName('input')[0].checked, 'toggling something not selected checks checkbox');
                equal(canViewModel(treecombo, 'selected').length, 1, 'there is one selected item');
                equal(canViewModel(treecombo).selected[0], itemsList[0], 'the midwest is in selected');
                canViewModel(treecombo, 'selected').pop();
                equal(optionsLis()[0].className, '', 'toggling something not selected adds active');
                domEvents.dispatch.call(optionsLis()[0].getElementsByTagName('button')[0], 'click');
                equal(breadcrumbLIs().length, 2, 'Only the default title is shown');
                equal(breadcrumbLIs()[1].innerHTML, 'Midwest', 'The breadcrumb has an item in it');
                ok(/Illinois/.test(optionsLis()[0].innerHTML), 'A child of the top breadcrumb is displayed');
                domEvents.dispatch.call(optionsLis()[0].getElementsByTagName('button')[0], 'click');
                ok(/Chicago/.test(optionsLis()[0].innerHTML), 'A child of the top breadcrumb is displayed');
                ok(!optionsLis()[0].getElementsByTagName('button').length, 'no show children button');
                domEvents.dispatch.call(breadcrumbLIs()[1], 'click');
                equal(innerHTML(breadcrumbLIs()[1]), 'Midwest', 'The breadcrumb has an item in it');
                ok(/Illinois/.test(innerHTML(optionsLis()[0])), 'A child of the top breadcrumb is displayed');
                domEvents.dispatch.call(breadcrumbLIs()[0], 'click');
                equal(breadcrumbLIs().length, 1, 'Only the default title is shown');
                equal(innerHTML(breadcrumbLIs()[0]), 'Locations', 'The correct title from the attribute is shown');
                start();
            }, 100);
        });
        test('deferred grid', function () {
            var GridViewModel = DefineMap.extend({
                items: { Value: DefineList },
                waiting: { value: true }
            });
            Component.extend({
                tag: 'grid',
                ViewModel: GridViewModel,
                view: stache('<table><tbody><content></content></tbody></table>'),
                leakScope: true,
                events: {
                    init: function () {
                        this.update();
                    },
                    '{viewModel} deferreddata': 'update',
                    update: function () {
                        var deferred = this.viewModel.get('deferreddata'), viewModel = this.viewModel;
                        if (deferred && deferred.then) {
                            this.viewModel.set('waiting', true);
                            deferred.then(function (items) {
                                viewModel.get('items').update(items);
                            });
                        } else {
                            viewModel.get('items').update(deferred);
                        }
                    },
                    '{items} length': function () {
                        this.viewModel.set('waiting', false);
                    }
                }
            });
            var SimulatedScope = DefineMap.extend({
                set: { value: 0 },
                deferredData: function () {
                    var deferred = {};
                    var promise = new Promise(function (resolve, reject) {
                        deferred.resolve = resolve;
                        deferred.reject = reject;
                    });
                    var set = this.get('set');
                    if (set === 0) {
                        setTimeout(function () {
                            deferred.resolve([{
                                    first: 'Justin',
                                    last: 'Meyer'
                                }]);
                        }, 100);
                    } else if (set === 1) {
                        setTimeout(function () {
                            deferred.resolve([{
                                    first: 'Brian',
                                    last: 'Moschel'
                                }]);
                        }, 100);
                    }
                    return promise;
                }
            });
            var viewModel = new SimulatedScope();
            var renderer = stache('<grid deferreddata:bind=\'viewModel.deferredData\'>' + '{{#each items}}' + '<tr>' + '<td width=\'40%\'>{{first}}</td>' + '<td width=\'70%\'>{{last}}</td>' + '</tr>' + '{{/each}}' + '</grid>');
            domMutate.appendChild.call(this.fixture, renderer({ viewModel: viewModel }));
            var gridScope = canViewModel(this.fixture.firstChild);
            equal(gridScope.get('waiting'), true, 'The grid is initially waiting on the deferreddata to resolve');
            stop();
            var self = this;
            var waitingHandler = function () {
                gridScope.off('waiting', waitingHandler);
                setTimeout(function () {
                    var tds = self.fixture.getElementsByTagName('td');
                    equal(tds.length, 2, 'there are 2 tds');
                    gridScope.on('waiting', function (ev, newVal) {
                        if (newVal === false) {
                            setTimeout(function () {
                                tds = self.fixture.getElementsByTagName('td');
                                equal(innerHTML(tds[0]), 'Brian', 'td changed to brian');
                                start();
                            }, 100);
                        }
                    });
                    viewModel.set = 1;
                }, 100);
            };
            gridScope.on('waiting', waitingHandler);
        });
        test('nextprev', function () {
            Component.extend({
                tag: 'next-prev',
                view: stache('<a href="javascript://"' + 'class="prev {{#paginate.canPrev()}}enabled{{/paginate.canPrev}}" on:click="paginate.prev()">Prev</a>' + '<a href="javascript://"' + 'class="next {{#paginate.canNext()}}enabled{{/paginate.canNext}}" on:click="paginate.next()">Next</a>')
            });
            var paginator = new Paginate({
                limit: 20,
                offset: 0,
                count: 100
            });
            var renderer = stache('<next-prev paginate:bind=\'paginator\'></next-prev>');
            var frag = renderer({ paginator: paginator });
            var nextPrev = frag.firstChild;
            var prev = nextPrev.firstChild, next = nextPrev.lastChild;
            ok(!/enabled/.test(prev.className), 'prev is not enabled');
            ok(/enabled/.test(next.className), 'next is  enabled');
            domEvents.dispatch.call(next, 'click');
            ok(/enabled/.test(prev.className), 'prev is enabled');
        });
        test('page-count', function () {
            Component.extend({
                tag: 'page-count',
                view: stache('Page <span>{{page}}</span>.')
            });
            var paginator = new Paginate({
                limit: 20,
                offset: 0,
                count: 100
            });
            var renderer = stache('<page-count page:from=\'paginator.page\'></page-count>');
            var frag = renderer(new SimpleMap({ paginator: paginator }));
            var span = frag.firstChild.getElementsByTagName('span')[0];
            equal(span.firstChild.nodeValue, '1');
            paginator.next();
            equal(span.firstChild.nodeValue, '2');
            paginator.next();
            equal(span.firstChild.nodeValue, '3');
        });
        if (System.env !== 'canjs-test') {
            test('basic tabs', function () {
                var TabsViewModel = DefineMap.extend({
                    active: 'any',
                    panels: { Value: DefineList },
                    addPanel: function (panel) {
                        if (this.panels.length === 0) {
                            this.makeActive(panel);
                        }
                        this.panels.push(panel);
                    },
                    removePanel: function (panel) {
                        var panels = this.panels;
                        queues.batch.start();
                        var index = panels.indexOf(panel);
                        canLog.log(index);
                        panels.splice(index, 1);
                        if (panel === this.active) {
                            if (panels.length) {
                                this.makeActive(panels[0]);
                            } else {
                                this.active = null;
                            }
                        }
                        queues.batch.stop();
                    },
                    makeActive: function (panel) {
                        this.active = panel;
                        this.panels.forEach(function (panel) {
                            panel.active = false;
                        });
                        panel.active = true;
                    },
                    isActive: function (panel) {
                        return this.active === panel;
                    }
                });
                Component.extend({
                    tag: 'tabs',
                    ViewModel: TabsViewModel,
                    view: stache('<ul>' + '{{#panels}}' + '<li {{#isActive(.)}}class=\'active\'{{/isActive}} on:click=\'makeActive(this)\'>{{title}}</li>' + '{{/panels}}' + '</ul>' + '<content></content>')
                });
                Component.extend({
                    view: stache('{{#if active}}<content></content>{{/if}}'),
                    tag: 'panel',
                    ViewModel: DefineMap.extend({ active: { value: false } }),
                    events: {
                        ' inserted': function () {
                            canViewModel(this.element.parentNode).addPanel(this.viewModel);
                        },
                        ' beforeremove': function () {
                            canViewModel(this.element.parentNode).removePanel(this.viewModel);
                        }
                    }
                });
                var renderer = stache('<tabs>{{#each foodTypes}}<panel title:from=\'title\'>{{content}}</panel>{{/each}}</tabs>');
                var foodTypes = new DefineList([
                    {
                        title: 'Fruits',
                        content: 'oranges, apples'
                    },
                    {
                        title: 'Breads',
                        content: 'pasta, cereal'
                    },
                    {
                        title: 'Sweets',
                        content: 'ice cream, candy'
                    }
                ]);
                var frag = renderer({ foodTypes: foodTypes });
                domMutate.appendChild.call(this.fixture, frag);
                var testArea = this.fixture;
                stop();
                helpers.runTasks([
                    function () {
                        var lis = testArea.getElementsByTagName('li');
                        equal(lis.length, 3, 'three lis added');
                        foodTypes.forEach(function (type, i) {
                            equal(innerHTML(lis[i]), type.title, 'li ' + i + ' has the right content');
                        });
                        foodTypes.push({
                            title: 'Vegies',
                            content: 'carrots, kale'
                        });
                    },
                    function () {
                        var lis = testArea.getElementsByTagName('li');
                        equal(lis.length, 4, 'li added');
                        foodTypes.forEach(function (type, i) {
                            equal(innerHTML(lis[i]), type.title, 'li ' + i + ' has the right content');
                        });
                        equal(testArea.getElementsByTagName('panel').length, 4, 'panel added');
                        canLog.log('SHIFTY');
                        foodTypes.shift();
                    },
                    function () {
                        var lis = testArea.getElementsByTagName('li');
                        equal(lis.length, 3, 'removed li after shifting a foodType');
                        foodTypes.each(function (type, i) {
                            equal(innerHTML(lis[i]), type.title, 'li ' + i + ' has the right content');
                        });
                        var panels = testArea.getElementsByTagName('panel');
                        equal(lis[0].className, 'active', 'the first element is active');
                        equal(innerHTML(panels[0]), 'pasta, cereal', 'the first content is shown');
                        equal(innerHTML(panels[1]), '', 'the second content is removed');
                        domEvents.dispatch.call(lis[1], 'click');
                        lis = testArea.getElementsByTagName('li');
                        equal(lis[1].className, 'active', 'the second element is active');
                        equal(lis[0].className, '', 'the first element is not active');
                        equal(innerHTML(panels[0]), '', 'the second content is removed');
                        equal(innerHTML(panels[1]), 'ice cream, candy', 'the second content is shown');
                    }
                ]);
            });
        }
    });
});
/*can-component@4.0.0-pre.2#test/component-slot-test*/
define('can-component@4.0.0-pre.2#test/component-slot-test', [
    'require',
    'exports',
    'module',
    'can-component',
    'can-stache',
    'steal-qunit',
    'can-define/map/map',
    'can-view-model',
    'can-symbol',
    'can-queues'
], function (require, exports, module) {
    var Component = require('can-component');
    var stache = require('can-stache');
    var QUnit = require('steal-qunit');
    var DefineMap = require('can-define/map/map');
    var viewModel = require('can-view-model');
    var canSymbol = require('can-symbol');
    QUnit.module('can-components - can-slots');
    test('<can-slot> Works', function () {
        var ViewModel = DefineMap.extend({
            subject: { value: 'Hello World' },
            body: { value: 'Later Gator' }
        });
        Component.extend({
            tag: 'my-email',
            view: stache('<can-slot name="subject" />' + '<can-slot name="body" />'),
            ViewModel: ViewModel,
            leakScope: true
        });
        var renderer = stache('<my-email>' + '<can-template name="subject">' + '{{subject}}' + '</can-template>' + '<can-template name="body">' + '{{body}}' + '</can-template>' + '</my-email>');
        var testView = renderer();
        equal(testView.firstChild.childNodes[0].nodeValue, 'Hello World');
        equal(testView.firstChild.childNodes[1].nodeValue, 'Later Gator');
    });
    test('<can-slot> leakScope false acts as expected', function () {
        var ViewModel = DefineMap.extend({
            subject: { value: 'Hello World' },
            body: { value: 'Later Gator' }
        });
        Component.extend({
            tag: 'my-email',
            view: stache('<can-slot name="subject" />' + '<can-slot name="body" />'),
            ViewModel: ViewModel
        });
        var renderer = stache('<my-email>' + '<can-template name="subject">' + '{{subject}}' + '</can-template>' + '<can-template name="body">' + '{{body}}' + '</can-template>' + '</my-email>');
        var testView = renderer({
            subject: 'foo',
            body: 'bar'
        });
        equal(testView.firstChild.childNodes[0].nodeValue, 'foo');
        equal(testView.firstChild.childNodes[1].nodeValue, 'bar');
    });
    test('<can-slot> Re-use templates', function () {
        var ViewModel = DefineMap.extend({
            subject: { value: 'Hello World' },
            body: { value: 'Later Gator' }
        });
        Component.extend({
            tag: 'my-email',
            view: stache('<can-slot name="subject" />' + '<can-slot name="subject" />'),
            ViewModel: ViewModel,
            leakScope: true
        });
        var renderer = stache('<my-email>' + '<can-template name="subject">' + '{{subject}}' + '</can-template>' + '</my-email>');
        var testView = renderer();
        equal(testView.firstChild.childNodes[0].nodeValue, 'Hello World');
        equal(testView.firstChild.childNodes[1].nodeValue, 'Hello World');
    });
    test('<can-slot> Works with default content', function () {
        var ViewModel = DefineMap.extend({});
        Component.extend({
            tag: 'my-email',
            view: stache('<can-slot name="subject">' + 'Default Content' + '</can-slot>'),
            ViewModel: ViewModel
        });
        var renderer = stache('<my-email>' + '<can-template name="subject" />' + '</my-email>');
        var testView = renderer();
        equal(testView.firstChild.innerHTML, 'Default Content');
    });
    test('<can-slot> Context one-way binding works', function () {
        var ViewModel = DefineMap.extend('MyEmailVM', { subject: { value: 'Hello World' } });
        Component.extend({
            tag: 'my-email',
            view: stache('<can-slot name="foo" this:from="subject" />'),
            ViewModel: ViewModel
        });
        var renderer = stache('<my-email>' + '<can-template name="foo"><span>{{this}}</span></can-template>' + '</my-email>');
        var frag = renderer();
        var vm = viewModel(frag.firstChild);
        equal(frag.firstChild.firstChild.innerHTML, 'Hello World');
        vm.subject = 'Later Gator';
        equal(frag.firstChild.firstChild.innerHTML, 'Later Gator');
    });
    var queues = require('can-queues');
    test('<can-slot> Context two-way binding works', function () {
        var ViewModel = DefineMap.extend('MyEmailVM', {}, { subject: { value: 'Hello World' } });
        Component.extend({
            tag: 'my-email',
            view: stache('<can-slot name="foo" this:bind="subject" />'),
            ViewModel: ViewModel
        });
        Component.extend({
            tag: 'my-subject',
            view: stache('{{subject}}'),
            ViewModel: DefineMap.extend('SubjectVM')
        });
        var renderer = stache('<my-email>' + '<can-template name="foo"><my-subject subject:bind="this" /></can-template>' + '</my-email>');
        var frag = renderer();
        var vm = viewModel(frag.firstChild);
        var childVM = viewModel(frag.firstChild.firstChild);
        equal(frag.firstChild.firstChild.innerHTML, 'Hello World');
        vm.subject = 'Later Gator';
        equal(frag.firstChild.firstChild.innerHTML, 'Later Gator');
        childVM.subject = 'After a while crocodile';
        equal(vm.subject, 'After a while crocodile');
    });
    test('<can-slot> Context child-to-parent binding works', function () {
        var ViewModel = DefineMap.extend({ subject: { value: 'Hello World' } });
        Component.extend({
            tag: 'my-email',
            view: stache('<can-slot name="foo" this:to="subject" />'),
            ViewModel: ViewModel
        });
        Component.extend({
            tag: 'my-subject',
            view: stache('{{subject}}'),
            ViewModel: DefineMap.extend({ subject: { value: 'Yo' } })
        });
        var renderer = stache('<my-email>' + '<can-template name="foo"><my-subject subject:to="this" /></can-template>' + '</my-email>');
        var frag = renderer();
        var vm = viewModel(frag.firstChild);
        var childVM = viewModel(frag.firstChild.firstChild);
        equal(frag.firstChild.firstChild.innerHTML, 'Yo');
        childVM.subject = 'bar';
        equal(frag.firstChild.firstChild.innerHTML, 'bar');
        equal(vm.subject, 'bar');
    });
    test('<can-slot> Works alongside <content>', function () {
        var ViewModel = DefineMap.extend({
            subject: { value: 'Hello World' },
            body: { value: 'Later Gator' }
        });
        Component.extend({
            tag: 'my-email',
            view: stache('<can-slot name="subject" />' + '<content />'),
            ViewModel: ViewModel,
            leakScope: true
        });
        var renderer = stache('<my-email>' + '<can-template name="subject">' + '<p>{{subject}}</p>' + '</can-template>' + '<span>Some content</span>' + '</my-email>');
        var testView = renderer();
        equal(testView.firstChild.childNodes[0].firstChild.nodeValue, 'Hello World');
        equal(testView.firstChild.childNodes[1].firstChild.nodeValue, 'Some content');
    });
    test('<can-slot> Works alongside <content> with default content', function () {
        var ViewModel = DefineMap.extend({
            subject: { value: 'Hello World' },
            body: { value: 'Later Gator' }
        });
        Component.extend({
            tag: 'my-email',
            view: stache('<can-slot name="subject" />' + '<content>Default content</content>'),
            ViewModel: ViewModel,
            leakScope: true
        });
        var renderer = stache('<my-email>' + '<can-template name="subject">' + '<p>{{subject}}</p>' + '</can-template>' + '</my-email>');
        var testView = renderer();
        equal(testView.firstChild.childNodes[0].firstChild.nodeValue, 'Hello World');
        equal(testView.firstChild.childNodes[1].nodeValue, 'Default content');
    });
    test('<can-slot> Can be used conditionally and will remove bindings', function () {
        var ViewModel = DefineMap.extend('MyEmailVM', {
            subject: { value: 'Hello World' },
            showSubject: { value: true }
        });
        Component.extend({
            tag: 'my-email',
            view: stache('{{#if showSubject}}<can-slot name="subject" this:from="subject" />{{/if}}'),
            ViewModel: ViewModel
        });
        var renderer = stache('<my-email>' + '<can-template name="subject">' + '<p>{{this}}</p>' + '</can-template>' + '</my-email>');
        var testView = renderer();
        equal(testView.firstChild.firstChild.firstChild.nodeValue, 'Hello World');
        var vm = viewModel(testView.firstChild);
        vm.showSubject = false;
        QUnit.stop();
        QUnit.equal(testView.firstChild.children.length, 0);
        setTimeout(function () {
            var handlers = vm[canSymbol.for('can.meta')].handlers;
            QUnit.equal(handlers.get(['subject']).length, 0);
            QUnit.start();
        }, 50);
    });
});
/*can-component@4.0.0-pre.2#test/component-define-test*/
define('can-component@4.0.0-pre.2#test/component-define-test', [
    'require',
    'exports',
    'module',
    'can-component',
    'can-stache',
    'steal-qunit',
    'can-define',
    'can-define/map/map',
    'can-view-model',
    'can-util/js/dev/dev'
], function (require, exports, module) {
    var Component = require('can-component');
    var stache = require('can-stache');
    var QUnit = require('steal-qunit');
    var define = require('can-define');
    var DefineMap = require('can-define/map/map');
    var viewModel = require('can-view-model');
    var canDev = require('can-util/js/dev/dev');
    QUnit.module('can-component with can-define');
    QUnit.test('Works with can-define', function () {
        var VM = define.Constructor({
            firstName: { type: 'string' },
            lastName: { type: 'string' },
            fullName: {
                get: function () {
                    return [
                        this.firstName,
                        this.lastName
                    ].join(' ');
                }
            }
        });
        Component.extend({
            tag: 'can-define-component',
            ViewModel: VM,
            view: stache('Name: {{fullName}}')
        });
        var frag = stache('<can-define-component firstName:from="firstName" lastName:from="lastName" />')({
            firstName: 'Chris',
            lastName: 'Gomez'
        });
        var vm = viewModel(frag.firstChild);
        QUnit.ok(vm instanceof VM, 'Constructor was called');
        QUnit.equal(vm.firstName, 'Chris', 'ViewModel was set from scope');
        QUnit.equal(vm.lastName, 'Gomez', 'ViewModel was set from scope');
        QUnit.equal(frag.firstChild.innerHTML, 'Name: Chris Gomez', 'Rendered fullName');
        vm.firstName = 'Justin';
        vm.lastName = 'Meyer';
        QUnit.equal(frag.firstChild.innerHTML, 'Name: Justin Meyer', 'Rendered fullName after change');
    });
    QUnit.test('scope method works', function () {
        Component.extend({
            tag: 'my-element',
            viewModel: function (properties, scope, element) {
                QUnit.deepEqual(properties, {
                    first: 'Justin',
                    last: 'Meyer'
                });
                return new DefineMap(properties);
            }
        });
        stache('<my-element first:from=\'firstName\' last:from=\'"Meyer"\'/>')({
            firstName: 'Justin',
            middleName: 'Barry'
        });
    });
    QUnit.test('33 - works when instantiated with an object for ViewModel', function () {
        Component.extend({
            tag: 'test-element',
            view: stache('{{someMethod}}'),
            ViewModel: {
                someMethod: function () {
                    ok(true, 'Function got called');
                    return true;
                }
            }
        });
        var renderer = stache('<test-element>');
        renderer();
    });
    QUnit.test('helpers do not leak when leakscope is false (#77)', function () {
        var called = 0;
        Component.extend({
            tag: 'inner-el',
            view: stache('inner{{test}}'),
            leakScope: false
        });
        Component.extend({
            tag: 'outer-el',
            view: stache('outer:<inner-el>'),
            helpers: {
                test: function () {
                    called++;
                    return 'heyo';
                }
            }
        });
        var renderer = stache('<outer-el>');
        renderer();
        QUnit.equal(called, 0, 'Outer helper not called');
    });
    QUnit.test('helpers do leak when leakscope is true (#77)', function () {
        var called = 0;
        Component.extend({
            tag: 'inner-el',
            view: stache('inner{{test}}'),
            leakScope: true
        });
        Component.extend({
            tag: 'outer-el',
            view: stache('outer:<inner-el>'),
            helpers: {
                test: function () {
                    called++;
                    return 'heyo';
                }
            }
        });
        var renderer = stache('<outer-el>');
        renderer();
        QUnit.equal(called, 1, 'Outer helper called once');
    });
    if (System.env.indexOf('production') < 0) {
        QUnit.test('warn if viewModel is assigned a DefineMap (#14)', function () {
            QUnit.expect(1);
            var oldwarn = canDev.warn;
            canDev.warn = function (mesg) {
                QUnit.equal(mesg, 'can-component: Assigning a DefineMap or constructor type to the viewModel property may not be what you intended. Did you mean ViewModel instead? More info: https://canjs.com/doc/can-component.prototype.ViewModel.html', 'Warning is expected message');
            };
            var VM = DefineMap.extend({});
            Component.extend({
                tag: 'can-vm1-test-component',
                viewModel: VM
            });
            Component.extend({
                tag: 'can-vm2-test-component',
                viewModel: function () {
                }
            });
            canDev.warn = oldwarn;
        });
    }
});
/*can-component@4.0.0-pre.2#test/tests*/
define('can-component@4.0.0-pre.2#test/tests', [
    'require',
    'exports',
    'module',
    './component-tag-test',
    './component-viewmodel-test',
    './component-view-test',
    './component-helpers-test',
    './component-events-test',
    './example-test',
    './component-slot-test',
    './component-define-test'
], function (require, exports, module) {
    require('./component-tag-test');
    require('./component-viewmodel-test');
    require('./component-view-test');
    require('./component-helpers-test');
    require('./component-events-test');
    require('./example-test');
    require('./component-slot-test');
    require('./component-define-test');
});
/*can-test-helpers@1.1.0#lib/dev*/
define('can-test-helpers@1.1.0#lib/dev', [
    'require',
    'exports',
    'module',
    'can-log/dev/dev',
    'can-util/js/make-array/make-array',
    'can-util/js/global/global'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var dev = require('can-log/dev/dev');
        var makeArray = require('can-util/js/make-array/make-array');
        var GLOBAL = require('can-util/js/global/global');
        function makeExpectation(type) {
            var original;
            var expectedResults = [];
            function stubbed() {
                var message = makeArray(arguments).map(function (token) {
                    if (typeof token !== 'string' && token.message) {
                        return token.message;
                    } else {
                        return token;
                    }
                }).join(' ');
                expectedResults.forEach(function (expected) {
                    var matched = typeof expected.source === 'string' ? message === expected.source : expected.source.test(message);
                    if (matched) {
                        expected.count++;
                    }
                    if (typeof expected.fn === 'function') {
                        expected.fn.call(null, message, matched);
                    }
                });
            }
            return function (expected, fn) {
                var matchData = {
                    source: expected,
                    fn: fn,
                    count: 0
                };
                expectedResults.push(matchData);
                if (!original) {
                    original = dev[type];
                    dev[type] = stubbed;
                }
                return function () {
                    expectedResults.splice(expectedResults.indexOf(matchData), 1);
                    if (original && expectedResults.length < 1) {
                        dev[type] = original;
                        original = null;
                    }
                    return matchData.count;
                };
            };
        }
        module.exports = {
            willWarn: makeExpectation('warn'),
            willError: makeExpectation('error'),
            devOnlyTest: function () {
                var global = GLOBAL();
                if (!global.System || !global.System.env || global.System.env.indexOf('production') < 0) {
                    global.test.apply(null, arguments);
                }
            }
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-define@2.0.0-pre.11#list/list-test*/
define('can-define@2.0.0-pre.11#list/list-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-define/list/list',
    'can-define/map/map',
    'can-observation',
    'can-define',
    'can-reflect',
    'can-symbol',
    'can-log/dev/dev',
    'can-test-helpers/lib/dev',
    'can-util/js/assign/assign'
], function (require, exports, module) {
    'use strict';
    var QUnit = require('steal-qunit');
    var DefineList = require('can-define/list/list');
    var DefineMap = require('can-define/map/map');
    var Observation = require('can-observation');
    var define = require('can-define');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var dev = require('can-log/dev/dev');
    var canTestHelpers = require('can-test-helpers/lib/dev');
    var assign = require('can-util/js/assign/assign');
    QUnit.module('can-define/list/list');
    QUnit.test('List is an event emitter', function (assert) {
        var Base = DefineList.extend({});
        assert.ok(Base.on, 'Base has event methods.');
        var List = Base.extend({});
        assert.ok(List.on, 'List has event methods.');
    });
    QUnit.test('creating an instance', function () {
        var list = new DefineList([
            'a',
            'b',
            'c'
        ]);
        list.on('add', function (ev, newVals, index) {
            QUnit.deepEqual(newVals, ['d']);
            QUnit.equal(index, 3);
        });
        list.push('d');
    });
    test('list attr changes length', function () {
        var l = new DefineList([
            0,
            1,
            2
        ]);
        l.set(3, 3);
        equal(l.length, 4);
    });
    test('remove on pop', function () {
        var l = new DefineList([
            0,
            1,
            2
        ]);
        l.pop();
        equal(l.length, 2);
        deepEqual(l.get(), [
            0,
            1
        ]);
    });
    test('list splice', function () {
        var l = new DefineList([
            0,
            1,
            2,
            3
        ]);
        l.on('add', function (ev, newVals, index) {
            deepEqual(newVals, [
                'a',
                'b'
            ], 'got the right newVals');
            equal(index, 1, 'adding items');
        });
        l.on('remove', function (ev, oldVals, index) {
            deepEqual(oldVals, [
                1,
                2
            ], 'got the right oldVals');
            equal(index, 1, 'no new Vals');
        });
        l.splice(1, 2, 'a', 'b');
        deepEqual(l.get(), [
            0,
            'a',
            'b',
            3
        ], 'serialized');
    });
    test('Array accessor methods', 11, function () {
        var l = new DefineList([
                'a',
                'b',
                'c'
            ]), sliced = l.slice(2), joined = l.join(' | '), concatenated = l.concat([
                2,
                1
            ], new DefineList([0]));
        ok(sliced instanceof DefineList, 'Slice is an Observable list');
        equal(sliced.length, 1, 'Sliced off two elements');
        equal(sliced[0], 'c', 'Single element as expected');
        equal(joined, 'a | b | c', 'Joined list properly');
        ok(concatenated instanceof DefineList, 'Concatenated is an Observable list');
        deepEqual(concatenated.serialize(), [
            'a',
            'b',
            'c',
            2,
            1,
            0
        ], 'DefineList concatenated properly');
        l.forEach(function (letter, index) {
            ok(true, 'Iteration');
            if (index === 0) {
                equal(letter, 'a', 'First letter right');
            }
            if (index === 2) {
                equal(letter, 'c', 'Last letter right');
            }
        });
    });
    test('Concatenated list items Equal original', function () {
        var l = new DefineList([
                { firstProp: 'Some data' },
                { secondProp: 'Next data' }
            ]), concatenated = l.concat([
                { hello: 'World' },
                { foo: 'Bar' }
            ]);
        ok(l[0] === concatenated[0], 'They are Equal');
        ok(l[1] === concatenated[1], 'They are Equal');
    });
    test('Lists with maps concatenate properly', function () {
        var Person = DefineMap.extend();
        var People = DefineList.extend({ '#': Person });
        var Genius = Person.extend();
        var Animal = DefineMap.extend();
        var me = new Person({ name: 'John' });
        var animal = new Animal({ name: 'Tak' });
        var genius = new Genius({ name: 'Einstein' });
        var hero = { name: 'Ghandi' };
        var people = new People([]);
        var specialPeople = new People([
            genius,
            hero
        ]);
        people = people.concat([
            me,
            animal,
            specialPeople
        ], specialPeople, [
            1,
            2
        ], 3);
        ok(people.length === 8, 'List length is right');
        ok(people[0] === me, 'Map in list === vars created before concat');
        ok(people[1] instanceof Person, 'Animal got serialized to Person');
    });
    test('splice removes items in IE (#562)', function () {
        var l = new DefineList(['a']);
        l.splice(0, 1);
        ok(!l.get(0), 'all props are removed');
    });
    test('reverse triggers add/remove events (#851)', function () {
        expect(4);
        var l = new DefineList([
            1,
            2,
            3
        ]);
        l.on('add', function () {
            ok(true, 'add called');
        });
        l.on('remove', function () {
            ok(true, 'remove called');
        });
        l.on('length', function () {
            ok(true, 'length should be called');
        });
        l.reverse();
        deepEqual(l.get(), [
            3,
            2,
            1
        ], 'reversed');
    });
    test('filter', function () {
        var l = new DefineList([
            {
                id: 1,
                name: 'John'
            },
            {
                id: 2,
                name: 'Mary'
            }
        ]);
        var filtered = l.filter(function (item) {
            return item.name === 'Mary';
        });
        notEqual(filtered._cid, l._cid, 'not same object');
        equal(filtered.length, 1, 'one item');
        equal(filtered[0].name, 'Mary', 'filter works');
    });
    test('No Add Events if DefineList Splice adds the same items that it is removing. (#1277, #1399)', function () {
        var list = new DefineList([
            'a',
            'b'
        ]);
        list.bind('add', function () {
            ok(false, 'Add callback should not be called.');
        });
        list.bind('remove', function () {
            ok(false, 'Remove callback should not be called.');
        });
        var result = list.splice(0, 2, 'a', 'b');
        deepEqual(result, [
            'a',
            'b'
        ]);
    });
    test('add event always returns an array as the value (#998)', function () {
        var list = new DefineList([]), msg;
        list.bind('add', function (ev, newElements, index) {
            deepEqual(newElements, [4], msg);
        });
        msg = 'works on push';
        list.push(4);
        list.pop();
        msg = 'works on attr()';
        list.set(0, 4);
        list.pop();
        msg = 'works on replace()';
        list.replace([4]);
    });
    test('Setting with .set() out of bounds of length triggers add event with leading undefineds', function () {
        var list = new DefineList([1]);
        list.bind('add', function (ev, newElements, index) {
            deepEqual(newElements, [
                undefined,
                undefined,
                4
            ], 'Leading undefineds are included');
            equal(index, 1, 'Index takes into account the leading undefineds from a .set()');
        });
        list.set(3, 4);
    });
    test('No events should fire if removals happened on empty arrays', function () {
        var list = new DefineList([]), msg;
        list.bind('remove', function (ev, removed, index) {
            ok(false, msg);
        });
        msg = 'works on pop';
        list.pop();
        msg = 'works on shift';
        list.shift();
        ok(true, 'No events were fired.');
    });
    test('setting an index out of bounds does not create an array', function () {
        expect(1);
        var l = new DefineList();
        l.set('1', 'foo');
        equal(l.get('1'), 'foo');
    });
    test('splice with similar but less items works (#1606)', function () {
        var list = new DefineList([
            'aa',
            'bb',
            'cc'
        ]);
        list.splice(0, list.length, 'aa', 'cc', 'dd');
        deepEqual(list.get(), [
            'aa',
            'cc',
            'dd'
        ]);
        list.splice(0, list.length, 'aa', 'cc');
        deepEqual(list.get(), [
            'aa',
            'cc'
        ]);
    });
    test('filter returns same list type (#1744)', function () {
        var ParentList = DefineList.extend();
        var ChildList = ParentList.extend();
        var children = new ChildList([
            1,
            2,
            3
        ]);
        ok(children.filter(function () {
        }) instanceof ChildList);
    });
    test('reverse returns the same list instance (#1744)', function () {
        var ParentList = DefineList.extend();
        var ChildList = ParentList.extend();
        var children = new ChildList([
            1,
            2,
            3
        ]);
        ok(children.reverse() === children);
    });
    test('slice and join are observable by a compute (#1884)', function () {
        expect(2);
        var list = new DefineList([
            1,
            2,
            3
        ]);
        var sliced = new Observation(function () {
            return list.slice(0, 1);
        });
        canReflect.onValue(sliced, function (newVal) {
            deepEqual(newVal.get(), [2], 'got a new DefineList');
        });
        var joined = new Observation(function () {
            return list.join(',');
        });
        canReflect.onValue(joined, function (newVal) {
            equal(newVal, '2,3', 'joined is observable');
        });
        list.shift();
    });
    test('list.replace', function () {
        var firstArray = [
            {
                id: 1,
                name: 'Marshall'
            },
            {
                id: 2,
                name: 'Austin'
            },
            {
                id: 3,
                name: 'Hyrum'
            }
        ];
        var myList = new DefineList(firstArray);
        var newArray = [
            {
                id: 4,
                name: 'Aubree'
            },
            {
                id: 5,
                name: 'Leah'
            },
            {
                id: 6,
                name: 'Lily'
            }
        ];
        myList.replace(newArray);
        equal(myList.length, 3);
        equal(myList[0].name, 'Aubree');
        equal(myList[1].name, 'Leah');
        equal(myList[2].name, 'Lily', 'Can replace a List with an Array.');
        myList.replace(firstArray);
        equal(myList.length, 3);
        equal(myList[0].name, 'Marshall');
        equal(myList[1].name, 'Austin');
        equal(myList[2].name, 'Hyrum', 'Can replace a List with another List.');
    });
    test('list.map', function () {
        var myArray = [
            {
                id: 1,
                name: 'Marshall'
            },
            {
                id: 2,
                name: 'Austin'
            },
            {
                id: 3,
                name: 'Hyrum'
            }
        ];
        var myList = new DefineList(myArray);
        var newList = myList.map(function (person) {
            person.lastName = 'Thompson';
            return person;
        });
        equal(newList.length, 3);
        equal(newList[0].name, 'Marshall');
        equal(newList[0].lastName, 'Thompson');
        equal(newList[1].name, 'Austin');
        equal(newList[1].lastName, 'Thompson');
        equal(newList[2].name, 'Hyrum');
        equal(newList[2].lastName, 'Thompson');
        var ExtendedList = DefineList.extend({
            testMe: function () {
                return 'It Worked!';
            }
        });
        var myExtendedList = new ExtendedList(myArray);
        var newExtendedList = myExtendedList.map(function (person) {
            person.lastName = 'Thompson';
            return person;
        });
        try {
            newExtendedList.testMe();
        } catch (err) {
            QUnit.ok(err.message.match(/testMe/), 'Does not return the same type of list.');
        }
    });
    test('list.sort a simple list', function () {
        var myList = new DefineList([
            'Marshall',
            'Austin',
            'Hyrum'
        ]);
        myList.sort();
        equal(myList.length, 3);
        equal(myList[0], 'Austin');
        equal(myList[1], 'Hyrum');
        equal(myList[2], 'Marshall', 'Basic list was properly sorted.');
    });
    test('list.sort a list of objects', function () {
        var objList = new DefineList([
            {
                id: 1,
                name: 'Marshall'
            },
            {
                id: 2,
                name: 'Austin'
            },
            {
                id: 3,
                name: 'Hyrum'
            }
        ]);
        objList.sort(function (a, b) {
            if (a.name < b.name) {
                return -1;
            } else if (a.name > b.name) {
                return 1;
            } else {
                return 0;
            }
        });
        equal(objList.length, 3);
        equal(objList[0].name, 'Austin');
        equal(objList[1].name, 'Hyrum');
        equal(objList[2].name, 'Marshall', 'List of objects was properly sorted.');
    });
    test('list.sort a list of objects without losing reference (#137)', function () {
        var unSorted = new DefineList([
            { id: 3 },
            { id: 2 },
            { id: 1 }
        ]);
        var sorted = unSorted.slice(0).sort(function (a, b) {
            return a.id > b.id ? 1 : a.id < b.id ? -1 : 0;
        });
        equal(unSorted[0], sorted[2], 'items should be equal');
    });
    test('list defines', 6, function () {
        var Todo = function (props) {
            assign(this, props);
        };
        define(Todo.prototype, {
            completed: 'boolean',
            destroyed: { value: false }
        });
        Todo.prototype.destroy = function () {
            this.destroyed = true;
        };
        var TodoList = DefineList.extend({
            '*': Todo,
            remaining: {
                get: function () {
                    return this.filter({ completed: false });
                }
            },
            completed: {
                get: function () {
                    return this.filter({ completed: true });
                }
            },
            destroyCompleted: function () {
                this.completed.forEach(function (todo) {
                    todo.destroy();
                });
            },
            setCompletedTo: function (value) {
                this.forEach(function (todo) {
                    todo.completed = value;
                });
            }
        });
        var todos = new TodoList([
            { completed: true },
            { completed: false }
        ]);
        ok(todos.item(0) instanceof Todo, 'correct instance');
        equal(todos.completed.length, 1, 'only one todo');
        todos.on('completed', function (ev, newVal, oldVal) {
            ok(newVal instanceof TodoList, 'right type');
            equal(newVal.length, 2, 'all items');
            ok(oldVal instanceof TodoList, 'right type');
            equal(oldVal.length, 1, 'all items');
        });
        todos.setCompletedTo(true);
    });
    QUnit.test('extending the base supports overwriting _eventSetup', function () {
        var L = DefineList.extend({});
        Object.getOwnPropertyDescriptor(DefineMap.prototype, '_eventSetup');
        L.prototype.arbitraryProp = true;
        ok(true, 'set arbitraryProp');
        L.prototype._eventSetup = function () {
        };
        ok(true, 'worked');
    });
    QUnit.test('setting expandos on a DefineList', function () {
        var DL = DefineList.extend({ count: 'number' });
        var dl = new DL();
        dl.assign({
            count: 5,
            skip: 2
        });
        QUnit.equal(dl.get('count'), 5, 'read with .get defined');
        QUnit.equal(dl.count, 5, 'read with . defined');
        QUnit.equal(dl.get('skip'), 2, 'read with .get expando');
        QUnit.equal(dl.skip, 2, 'read with . expando');
        QUnit.equal(dl.get('limit'), undefined, 'read with .get undefined');
    });
    QUnit.test('passing a DefineList to DefineList (#33)', function () {
        var m = new DefineList([
            {},
            {}
        ]);
        var m2 = new DefineList(m);
        QUnit.deepEqual(m.get(), m2.get());
        QUnit.ok(m[0] === m2[0], 'index the same');
        QUnit.ok(m[1] === m2[1], 'index the same');
    });
    QUnit.test('reading and setting expandos', function () {
        var list = new DefineList();
        var countObservation = new Observation(function () {
            return list.get('count');
        }, null, function (newValue) {
            QUnit.equal(newValue, 1000, 'got new value');
        });
        countObservation.start();
        list.set('count', 1000);
        QUnit.equal(countObservation.value, 1000);
        var list2 = new DefineList();
        list2.on('count', function (ev, newVal) {
            QUnit.equal(newVal, 5);
        });
        list2.set('count', 5);
    });
    QUnit.test('extending DefineList constructor functions (#61)', function () {
        var AList = DefineList.extend('AList', {
            aProp: {},
            aMethod: function () {
            }
        });
        var BList = AList.extend('BList', {
            bProp: {},
            bMethod: function () {
            }
        });
        var CList = BList.extend('CList', {
            cProp: {},
            cMethod: function () {
            }
        });
        var list = new CList([
            {},
            {}
        ]);
        list.on('aProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'PROP');
            QUnit.equal(oldVal, undefined);
        });
        list.on('bProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'FOO');
            QUnit.equal(oldVal, undefined);
        });
        list.on('cProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'BAR');
            QUnit.equal(oldVal, undefined);
        });
        list.aProp = 'PROP';
        list.bProp = 'FOO';
        list.cProp = 'BAR';
        QUnit.ok(list.aMethod);
        QUnit.ok(list.bMethod);
        QUnit.ok(list.cMethod);
    });
    QUnit.test('extending DefineList constructor functions more than once (#61)', function () {
        var AList = DefineList.extend('AList', {
            aProp: {},
            aMethod: function () {
            }
        });
        var BList = AList.extend('BList', {
            bProp: {},
            bMethod: function () {
            }
        });
        var CList = AList.extend('CList', {
            cProp: {},
            cMethod: function () {
            }
        });
        var list1 = new BList([
            {},
            {}
        ]);
        var list2 = new CList([
            {},
            {},
            {}
        ]);
        list1.on('aProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'PROP', 'aProp newVal on list1');
            QUnit.equal(oldVal, undefined);
        });
        list1.on('bProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'FOO', 'bProp newVal on list1');
            QUnit.equal(oldVal, undefined);
        });
        list2.on('aProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'PROP', 'aProp newVal on list2');
            QUnit.equal(oldVal, undefined);
        });
        list2.on('cProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'BAR', 'cProp newVal on list2');
            QUnit.equal(oldVal, undefined);
        });
        list1.aProp = 'PROP';
        list1.bProp = 'FOO';
        list2.aProp = 'PROP';
        list2.cProp = 'BAR';
        QUnit.ok(list1.aMethod, 'list1 aMethod');
        QUnit.ok(list1.bMethod);
        QUnit.ok(list2.aMethod);
        QUnit.ok(list2.cMethod, 'list2 cMethod');
    });
    QUnit.test('extending DefineList constructor functions - value (#61)', function () {
        var AList = DefineList.extend('AList', { aProp: { value: 1 } });
        var BList = AList.extend('BList', {});
        var CList = BList.extend('CList', {});
        var c = new CList([]);
        QUnit.equal(c.aProp, 1, 'got initial value');
    });
    QUnit.test('\'*\' inheritance works (#61)', function () {
        var Account = DefineMap.extend({
            name: 'string',
            amount: 'number',
            slug: {
                serialize: true,
                get: function () {
                    return this.name.toLowerCase().replace(/ /g, '-').replace(/[^\w-]+/g, '');
                }
            }
        });
        var BaseList = DefineList.extend({ '*': Account });
        var ExtendedList = BaseList.extend({});
        var xl = new ExtendedList([{}]);
        QUnit.ok(xl[0] instanceof Account);
    });
    QUnit.test('shorthand getter setter (#56)', function () {
        var People = DefineList.extend({
            first: '*',
            last: '*',
            get fullName() {
                return this.first + ' ' + this.last;
            },
            set fullName(newVal) {
                var parts = newVal.split(' ');
                this.first = parts[0];
                this.last = parts[1];
            }
        });
        var p = new People([]);
        p.fullName = 'Mohamed Cherif';
        p.on('fullName', function (ev, newVal, oldVal) {
            QUnit.equal(oldVal, 'Mohamed Cherif');
            QUnit.equal(newVal, 'Justin Meyer');
        });
        equal(p.fullName, 'Mohamed Cherif', 'fullName initialized right');
        p.fullName = 'Justin Meyer';
    });
    QUnit.test('added and removed are called after items are added/removed (#14)', function () {
        var Person = DefineMap.extend({
            id: 'number',
            name: 'string'
        });
        var addedFuncCalled, removedFuncCalled, theList;
        var People = DefineList.extend({
            '#': {
                added: function (items, index) {
                    addedFuncCalled = true;
                    ok(items, 'items added got passed to added');
                    ok(typeof index === 'number', 'index of items was passed to added and is a number');
                    ok(items[0].name === 'John', 'Name was correct');
                    theList = this;
                },
                removed: function (items, index) {
                    removedFuncCalled = true;
                    ok(items, 'items added got passed to removed');
                    ok(typeof index === 'number', 'index of items was passed to removed and is a number');
                    theList = this;
                },
                Type: Person
            },
            outsideProp: {
                type: 'boolean',
                value: true
            }
        });
        var people = new People([]);
        var me = new Person();
        me.name = 'John';
        me.id = '1234';
        ok(!addedFuncCalled, 'added function has not been called yet');
        people.push(me);
        ok(addedFuncCalled, 'added function was called');
        ok(theList.outsideProp === true && theList instanceof People, 'the list was passed correctly as this to added');
        theList = null;
        ok(!removedFuncCalled, 'removed function has not been called yet');
        people.splice(people.indexOf(me), 1);
        ok(removedFuncCalled, 'removed function was called');
        ok(theList.outsideProp === true && theList instanceof People, 'the list was passed correctly as this to removed');
    });
    QUnit.test('* vs # (#78)', function () {
        var MyList = DefineList.extend({
            '*': 'number',
            '#': {
                added: function () {
                    ok(true, 'called on init');
                },
                removed: function () {
                },
                type: 'string'
            }
        });
        var list = new MyList([
            1,
            2,
            3
        ]);
        QUnit.ok(list[0] === '1', 'converted to string');
        list.set('prop', '4');
        QUnit.ok(list.prop === 4, 'type converted');
    });
    QUnit.test('Array shorthand uses #', function () {
        var MyMap = DefineMap.extend({ 'numbers': ['number'] });
        var map = new MyMap({
            numbers: [
                '1',
                '2'
            ]
        });
        QUnit.ok(map.numbers[0] === 1, 'converted to number');
        map.numbers.set('prop', '4');
        QUnit.ok(map.numbers.prop === '4', 'type left alone');
    });
    QUnit.test('replace-with-self lists are diffed properly (can-view-live#10)', function () {
        var a = new DefineMap({ name: 'A' });
        var b = new DefineMap({ name: 'B' });
        var c = new DefineMap({ name: 'C' });
        var d = new DefineMap({ name: 'D' });
        expect(4);
        var list1 = new DefineList([
            a,
            b
        ]);
        list1.on('add', function (ev, newVals, where) {
            throw new Error('list1 should not add.');
        });
        list1.on('remove', function (ev, oldVals, where) {
            throw new Error('list1 should not remove.');
        });
        list1.replace([
            a,
            b
        ]);
        var list2 = new DefineList([
            a,
            b,
            c
        ]);
        list2.on('add', function (ev, newVals, where) {
            equal(newVals.length, 1, 'list2 added length');
            equal(where, 2, 'list2 added location');
        });
        list2.on('remove', function (ev, oldVals, where) {
            equal(oldVals.length, 1, 'list2 removed length');
            equal(where, 2, 'list2 removed location');
        });
        list2.replace([
            a,
            b,
            d
        ]);
    });
    QUnit.test('set >= length - triggers length event (#152)', function () {
        var l = new DefineList([
            1,
            2,
            3
        ]);
        var batchNum = null;
        l.on('add', function (e) {
            ok(true, 'add called');
            if (batchNum === null) {
                batchNum = e.batchNum;
            } else {
                equal(batchNum, e.batchNum, 'batch numbers match');
            }
        });
        l.on('remove', function (e) {
            ok(false, 'remove called');
            if (batchNum === null) {
                batchNum = e.batchNum;
            } else {
                equal(batchNum, e.batchNum, 'batch numbers match');
            }
        });
        l.on('length', function (e) {
            ok(true, 'length called');
            if (batchNum === null) {
                batchNum = e.batchNum;
            } else {
                equal(batchNum, e.batchNum, 'batch numbers match');
            }
        });
        expect(4);
        l.set(3, 5);
        deepEqual(l.get(), [
            1,
            2,
            3,
            5
        ], 'updated list');
    });
    QUnit.test('set < length - triggers length event (#150)', function () {
        var l = new DefineList([
            1,
            2,
            3
        ]);
        var batchNum = null;
        l.on('add', function (e) {
            ok(true, 'add called');
            if (batchNum === null) {
                batchNum = e.batchNum;
            } else {
                equal(batchNum, e.batchNum, 'batch numbers match');
            }
        });
        l.on('remove', function (e) {
            ok(true, 'remove called');
            if (batchNum === null) {
                batchNum = e.batchNum;
            } else {
                equal(batchNum, e.batchNum, 'batch numbers match');
            }
        });
        l.on('length', function (e) {
            ok(true, 'length called');
            if (batchNum === null) {
                batchNum = e.batchNum;
            } else {
                equal(batchNum, e.batchNum, 'batch numbers match');
            }
        });
        expect(6);
        l.set(2, 4);
        deepEqual(l.get(), [
            1,
            2,
            4
        ], 'updated list');
    });
    QUnit.test('set/splice are observable', function () {
        var list = new DefineList([
            1,
            2,
            3,
            4,
            5
        ]);
        var count = new Observation(function () {
            var count = 0;
            for (var i = 0; i < list.length; i++) {
                count += list[i] % 2 ? 1 : 0;
            }
            return count;
        });
        canReflect.onValue(count, function () {
            ok(true);
        });
        expect(3);
        list.set(3, 5);
        list.set(2, 4);
        list.splice(1, 1, 1);
    });
    QUnit.test('setting length > current (#147)', function () {
        var list = new DefineList([
            1,
            2
        ]);
        list.length = 5;
        equal(list.length, 5);
        equal(list.hasOwnProperty(0), true);
        equal(list.hasOwnProperty(1), true);
        equal(list.hasOwnProperty(2), true);
        equal(list.hasOwnProperty(3), true);
        equal(list.hasOwnProperty(4), true);
        equal(list.hasOwnProperty(5), false);
    });
    QUnit.test('setting length < current (#147)', function () {
        var list = new DefineList([
            1,
            2,
            3,
            4,
            5
        ]);
        list.length = 3;
        equal(list.length, 3);
        equal(list.hasOwnProperty(0), true);
        equal(list.hasOwnProperty(1), true);
        equal(list.hasOwnProperty(2), true);
        equal(list.hasOwnProperty(3), false);
        equal(list.hasOwnProperty(4), false);
        equal(list.hasOwnProperty(5), false);
    });
    test('every', function () {
        var l = new DefineList([
            {
                id: 1,
                name: 'Bob'
            },
            {
                id: 2,
                name: 'Bob'
            }
        ]);
        var allBobs = l.every(function (item) {
            return item.name === 'Bob';
        });
        ok(allBobs, 'Every works in true case');
        var idOne = l.every(function (item) {
            return item.id === 1;
        });
        ok(!idOne, 'Every works in false case');
        allBobs = l.every({ name: 'Bob' });
        ok(allBobs, 'Every works in true case');
        idOne = l.every({
            name: 'Bob',
            id: 1
        });
        ok(!idOne, 'Every works in false case');
    });
    test('some', function () {
        var l = new DefineList([
            {
                id: 1,
                name: 'Alice'
            },
            {
                id: 2,
                name: 'Bob'
            }
        ]);
        var allBobs = l.some(function (item) {
            return item.name === 'Bob';
        });
        ok(allBobs, 'Some works in true case');
        var idOne = l.some(function (item) {
            return item.name === 'Charlie';
        });
        ok(!idOne, 'Some works in false case');
        allBobs = l.some({ name: 'Bob' });
        ok(allBobs, 'Some works in true case');
        idOne = l.some({
            name: 'Bob',
            id: 1
        });
        ok(!idOne, 'Some works in false case');
    });
    test('lastIndexOf', function () {
        var l = new DefineList([
            {
                id: 1,
                name: 'Alice'
            },
            {
                id: 2,
                name: 'Bob'
            }
        ]);
        var bobIdx = l.lastIndexOf(l[1]);
        equal(bobIdx, 1, 'lastIndexOf found object');
        var charlieIdx = l.lastIndexOf({
            id: 3,
            name: 'Charlie'
        });
        equal(charlieIdx, -1, 'lastIndexOf not found object');
        l.push(l[1]);
        bobIdx = l.lastIndexOf(l[1]);
        equal(bobIdx, 2, 'lastIndexOf found last index of duped object');
    });
    test('reduce', function () {
        var l = new DefineList([
            {
                id: 1,
                name: 'Alice',
                score: 10
            },
            {
                id: 2,
                name: 'Bob',
                score: 20
            }
        ]);
        var totalScores = l.reduce(function (total, player) {
            return total + player.score;
        }, 0);
        equal(totalScores, 30, 'Reduce works over list');
    });
    test('reduceRight', function () {
        var l = new DefineList([
            {
                id: 1,
                name: 'Alice'
            },
            {
                id: 2,
                name: 'Bob'
            }
        ]);
        var concatenatedNames = l.reduceRight(function (string, person) {
            return string + person.name;
        }, '');
        equal(concatenatedNames, 'BobAlice', 'ReduceRight works over list');
    });
    QUnit.test('can-reflect onKeyValue', function (assert) {
        assert.expect(3);
        var list = new DefineList([
            1,
            2,
            3
        ]);
        var key = 1;
        canReflect.onKeyValue(list, key, function (newVal) {
            assert.equal(newVal, 5);
        });
        list.set(key, 5);
        canReflect.onKeyValue(list, 'length', function (newVal) {
            assert.equal(newVal, 4);
        });
        list.push(6);
    });
    test('works with can-reflect', function () {
        var a = new DefineMap({ foo: 4 });
        var b = new DefineList([
            'foo',
            'bar'
        ]);
        var c;
        QUnit.equal(canReflect.getKeyValue(b, '0'), 'foo', 'unbound value');
        QUnit.ok(!canReflect.isValueLike(b), 'isValueLike is false');
        QUnit.ok(canReflect.isObservableLike(b), 'isObservableLike is true');
        QUnit.ok(canReflect.isMapLike(b), 'isMapLike is true');
        QUnit.ok(canReflect.isListLike(b), 'isListLike is false');
        QUnit.ok(!canReflect.keyHasDependencies(b, 'length'), 'keyHasDependencies -- false');
        define(c = Object.create(b), {
            length: {
                get: function () {
                    return a.foo;
                }
            }
        });
        QUnit.ok(canReflect.getKeyDependencies(c, 'length'), 'dependencies exist');
        QUnit.ok(canReflect.getKeyDependencies(c, 'length').valueDependencies.has(c._computed.length.compute), 'dependencies returned');
    });
    QUnit.test('can-reflect setKeyValue', function () {
        var a = new DefineList([
            'a',
            'b'
        ]);
        canReflect.setKeyValue(a, 1, 'c');
        QUnit.equal(a[1], 'c', 'setKeyValue');
    });
    QUnit.test('can-reflect deleteKeyValue', function () {
        var a = new DefineList([
            'a',
            'b'
        ]);
        a.set('foo', 'bar');
        canReflect.deleteKeyValue(a, 0);
        QUnit.equal(a[1], undefined, 'last value is now undefined');
        QUnit.equal(a[0], 'b', 'last value is shifted down');
        canReflect.deleteKeyValue(a, 'foo');
        QUnit.equal(a.foo, undefined, 'value not included in serial');
        QUnit.ok(!('foo' in a.get()), 'value not included in serial');
    });
    QUnit.test('can-reflect getKeyDependencies', function () {
        var a = new DefineMap({ foo: 4 });
        var b = new DefineList([
            'foo',
            'bar'
        ]);
        var c;
        ok(!canReflect.getKeyDependencies(b, 'length'), 'No dependencies before binding');
        define(c = Object.create(b), {
            length: {
                get: function () {
                    return a.foo;
                }
            }
        });
        ok(canReflect.getKeyDependencies(c, 'length'), 'dependencies exist');
        ok(canReflect.getKeyDependencies(c, 'length').valueDependencies.has(c._computed.length.compute), 'dependencies returned');
    });
    QUnit.test('assign property', function () {
        var list = new DefineList([
            'A',
            'B'
        ]);
        list.assign({
            count: 0,
            skip: 2,
            arr: [
                '1',
                '2',
                '3'
            ]
        });
        equal(list.get('count'), 0, 'Count set properly');
        list.assign({
            count: 1000,
            arr: ['first']
        });
        deepEqual(list.get('arr'), new DefineList(['first']), 'Array is set properly');
        equal(list.get('count'), 1000, 'Count set properly');
        equal(list.get('skip'), 2, 'Skip is unchanged');
    });
    QUnit.test('update property', function () {
        var list = new DefineList([
            'A',
            'B'
        ]);
        list.update({
            count: 0,
            skip: 2
        });
        equal(list.get('count'), 0, 'Count set properly');
        list.update({ count: 1000 });
        equal(list.get('count'), 1000, 'Count set properly');
        equal(list.get('skip'), undefined, 'Skip is changed');
    });
    QUnit.test('assignDeep property', function () {
        var list = new DefineList([
            'A',
            'B'
        ]);
        list.assignDeep({
            count: 0,
            skip: 2,
            foo: {
                bar: 'zed',
                tar: 'yap'
            }
        });
        equal(list.get('count'), 0, 'Count set properly');
        list.assignDeep({
            count: 1000,
            foo: { bar: 'updated' }
        });
        equal(list.get('count'), 1000, 'Count set properly');
        equal(list.get('skip'), 2, 'Skip is unchanged');
        propEqual(list.get('foo'), {
            bar: 'updated',
            tar: 'yap'
        }, 'Foo was updated properly');
    });
    QUnit.test('updateDeep property', function () {
        var list = new DefineList([
            'A',
            'B'
        ]);
        list.updateDeep({
            count: 0,
            skip: 2,
            foo: {
                bar: 'zed',
                tar: 'yap'
            }
        });
        equal(list.get('count'), 0, 'Count set properly');
        list.updateDeep({ count: 1000 });
        equal(list.get('count'), 1000, 'Count set properly');
        equal(list.get('skip'), undefined, 'Skip is set to undefined');
        propEqual(list.get('foo'), undefined, 'Foo is set to undefined');
    });
    QUnit.test('registered symbols', function () {
        var a = new DefineMap({ 'a': 'a' });
        ok(a[canSymbol.for('can.isMapLike')], 'can.isMapLike');
        equal(a[canSymbol.for('can.getKeyValue')]('a'), 'a', 'can.getKeyValue');
        a[canSymbol.for('can.setKeyValue')]('a', 'b');
        equal(a.a, 'b', 'can.setKeyValue');
        function handler(val) {
            equal(val, 'c', 'can.onKeyValue');
        }
        a[canSymbol.for('can.onKeyValue')]('a', handler);
        a.a = 'c';
        a[canSymbol.for('can.offKeyValue')]('a', handler);
        a.a = 'd';
    });
    QUnit.test('cannot remove length', function () {
        var list = new DefineList(['a']);
        list.set('length', undefined);
        QUnit.equal(list.length, 1, 'list length is unchanged');
    });
    QUnit.test('cannot set length to a non-number', function () {
        var list = new DefineList(['a']);
        list.set('length', null);
        QUnit.equal(list.length, 1, 'list length is unchanged');
        list.set('length', 'foo');
        QUnit.equal(list.length, 1, 'list length is unchanged');
        list.set('length', {});
        QUnit.equal(list.length, 1, 'list length is unchanged');
    });
    QUnit.test('_length is not enumerable', function () {
        QUnit.ok(!Object.getOwnPropertyDescriptor(new DefineList(), '_length').enumerable, '_length is not enumerable');
    });
    QUnit.test('update with no indexed items sets length to 0', function () {
        var list = new DefineList(['a']);
        QUnit.equal(list.length, 1, 'list length is correct before update');
        list.update({ foo: 'bar' });
        QUnit.equal(list.length, 0, 'list length is correct after update');
    });
    [
        'length',
        '_length'
    ].forEach(function (prop) {
        QUnit.test('setting ' + prop + ' does not overwrite definition', function () {
            var list = new DefineList();
            list.get(prop);
            var proto = list, listDef, listDef2;
            while (!listDef && proto) {
                listDef = Object.getOwnPropertyDescriptor(proto, prop);
                proto = Object.getPrototypeOf(proto);
            }
            list.set(prop, 1);
            proto = list;
            while (!listDef2 && proto) {
                listDef2 = Object.getOwnPropertyDescriptor(proto, prop);
                proto = Object.getPrototypeOf(proto);
            }
            delete listDef2.value;
            delete listDef.value;
            QUnit.deepEqual(listDef2, listDef, 'descriptor hasn\'t changed');
        });
    });
    QUnit.test('iterator can recover from bad _length', function () {
        var list = new DefineList(['a']);
        list.set('_length', null);
        QUnit.equal(list._length, null, 'Bad value for _length');
        var iterator = list[canSymbol.iterator]();
        var iteration = iterator.next();
        QUnit.ok(iteration.done, 'Didn\'t fail');
    });
    QUnit.test('onPatches', function () {
        var list = new DefineList([
            'a',
            'b'
        ]);
        var PATCHES = [
            [{
                    deleteCount: 2,
                    index: 0
                }],
            [{
                    index: 0,
                    insert: [
                        'A',
                        'B'
                    ],
                    deleteCount: 0
                }]
        ];
        var handlerCalls = 0;
        var handler = function (patches) {
            QUnit.deepEqual(patches, PATCHES[handlerCalls], 'patches looked right for ' + handlerCalls);
            handlerCalls++;
        };
        list[canSymbol.for('can.onPatches')](handler, 'notify');
        list.replace([
            'A',
            'B'
        ]);
        list[canSymbol.for('can.offPatches')](handler, 'notify');
        list.replace([
            '1',
            '2'
        ]);
    });
    canTestHelpers.devOnlyTest('can.getName symbol behavior', function (assert) {
        var getName = function (instance) {
            return instance[canSymbol.for('can.getName')]();
        };
        assert.ok('DefineList[]', getName(new DefineList()), 'should use DefineList constructor name by default');
        var MyList = DefineList.extend('MyList', {});
        assert.ok('MyList[]', getName(new MyList()), 'should use custom list name when provided');
    });
    QUnit.test('length event should include previous value', function (assert) {
        var done = assert.async();
        var list = new DefineList([]);
        var other = new DefineList(['a']);
        var changes = [];
        list.on('length', function (_, current, previous) {
            changes.push({
                current: current,
                previous: previous
            });
        });
        list.push('x');
        list.pop();
        list.push('y', 'z');
        list.splice(2, 0, 'x', 'w');
        list.splice(0, 1);
        list.sort();
        list.replace(other);
        assert.expect(1);
        setTimeout(function () {
            assert.deepEqual(changes, [
                {
                    current: 1,
                    previous: 0
                },
                {
                    current: 0,
                    previous: 1
                },
                {
                    current: 2,
                    previous: 0
                },
                {
                    current: 4,
                    previous: 2
                },
                {
                    current: 3,
                    previous: 4
                },
                {
                    current: 3,
                    previous: 3
                },
                {
                    current: 1,
                    previous: 3
                }
            ], 'should include length before mutation');
            done();
        });
    });
    canTestHelpers.devOnlyTest('log all events', function (assert) {
        var done = assert.async();
        var list = new DefineList([
            'a',
            'b',
            'c'
        ]);
        list.set('total', 100);
        list.log();
        var keys = [];
        var log = dev.log;
        dev.log = function () {
            keys.push(JSON.parse(arguments[2]));
        };
        list.push('x');
        list.pop();
        list.set('total', 50);
        assert.expect(1);
        setTimeout(function () {
            dev.log = log;
            assert.deepEqual(keys, [
                'add',
                'length',
                'remove',
                'length',
                'total'
            ], 'should log \'add\', \'remove\', \'length\' and \'propertyName\' events');
            done();
        });
    });
    canTestHelpers.devOnlyTest('log single events', function (assert) {
        var done = assert.async();
        var list = new DefineList([
            'a',
            'b',
            'c'
        ]);
        list.set('total', 100);
        list.log('length');
        var keys = [];
        var log = dev.log;
        dev.log = function () {
            keys.push(JSON.parse(arguments[2]));
        };
        list.push('x');
        list.pop();
        list.set('total', 50);
        assert.expect(1);
        setTimeout(function () {
            dev.log = log;
            assert.deepEqual(keys, [
                'length',
                'length'
            ], 'should log \'length\' event');
            done();
        });
    });
    canTestHelpers.devOnlyTest('log multiple events', function (assert) {
        var done = assert.async();
        var list = new DefineList([
            'a',
            'b',
            'c'
        ]);
        list.set('total', 100);
        list.log('add');
        list.log('total');
        var keys = [];
        var log = dev.log;
        dev.log = function () {
            keys.push(JSON.parse(arguments[2]));
        };
        list.push('x');
        list.pop();
        list.set('total', 50);
        assert.expect(1);
        setTimeout(function () {
            dev.log = log;
            assert.deepEqual(keys, [
                'add',
                'total'
            ], 'should log add and total');
            done();
        });
    });
});
/*can-define@2.0.0-pre.11#map/map-test*/
define('can-define@2.0.0-pre.11#map/map-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-define/map/map',
    'can-define',
    'can-observation',
    'can-util/js/each/each',
    'can-util/js/assign/assign',
    'can-reflect',
    'can-symbol',
    'can-util/js/is-plain-object/is-plain-object',
    'can-util/js/dev/dev',
    'can-test-helpers/lib/dev',
    'can-define/list/list',
    'can-log/dev/dev'
], function (require, exports, module) {
    'use strict';
    var QUnit = require('steal-qunit');
    var DefineMap = require('can-define/map/map');
    var define = require('can-define');
    var Observation = require('can-observation');
    var each = require('can-util/js/each/each');
    var assign = require('can-util/js/assign/assign');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var isPlainObject = require('can-util/js/is-plain-object/is-plain-object');
    var canDev = require('can-util/js/dev/dev');
    var canTestHelpers = require('can-test-helpers/lib/dev');
    var DefineList = require('can-define/list/list');
    var dev = require('can-log/dev/dev');
    var sealWorks = function () {
        try {
            var o = {};
            Object.seal(o);
            o.prop = true;
            return false;
        } catch (e) {
            return true;
        }
    }();
    QUnit.module('can-define/map/map');
    QUnit.test('Map is an event emitter', function (assert) {
        var Base = DefineMap.extend({});
        assert.ok(Base.on, 'Base has event methods.');
        var Map = Base.extend({});
        assert.ok(Map.on, 'Map has event methods.');
    });
    QUnit.test('creating an instance', function () {
        var map = new DefineMap({ prop: 'foo' });
        map.on('prop', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'BAR');
            QUnit.equal(oldVal, 'foo');
        });
        map.prop = 'BAR';
    });
    QUnit.test('creating an instance with nested prop', function () {
        var map = new DefineMap({ name: { first: 'Justin' } });
        map.name.on('first', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'David');
            QUnit.equal(oldVal, 'Justin');
        });
        map.name.first = 'David';
    });
    QUnit.test('extending', function () {
        var MyMap = DefineMap.extend({ prop: {} });
        var map = new MyMap();
        map.on('prop', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'BAR');
            QUnit.equal(oldVal, undefined);
        });
        map.prop = 'BAR';
    });
    QUnit.test('loop only through defined serializable props', function () {
        var MyMap = DefineMap.extend({
            propA: {},
            propB: { serialize: false },
            propC: {
                get: function () {
                    return this.propA;
                }
            }
        });
        var inst = new MyMap({
            propA: 1,
            propB: 2
        });
        QUnit.deepEqual(Object.keys(inst.get()), ['propA']);
    });
    QUnit.test('get and set can setup expandos', function () {
        var map = new DefineMap();
        var oi = new Observation(function () {
            return map.get('foo');
        });
        canReflect.onValue(oi, function (newVal) {
            QUnit.equal(newVal, 'bar', 'updated to bar');
        });
        map.set('foo', 'bar');
    });
    QUnit.test('default settings', function () {
        var MyMap = DefineMap.extend({
            '*': 'string',
            foo: {}
        });
        var m = new MyMap();
        m.set('foo', 123);
        QUnit.ok(m.get('foo') === '123');
    });
    QUnit.test('default settings on unsealed', function () {
        var MyMap = DefineMap.extend({ seal: false }, { '*': 'string' });
        var m = new MyMap();
        m.set('foo', 123);
        QUnit.ok(m.get('foo') === '123');
    });
    if (!System.isEnv('production')) {
        QUnit.test('extends sealed objects (#48)', function () {
            var Map1 = DefineMap.extend({ seal: true }, {
                name: {
                    get: function (curVal) {
                        return 'computed ' + curVal;
                    }
                }
            });
            var Map2 = Map1.extend({ seal: false }, {});
            var Map3 = Map2.extend({ seal: true }, {});
            var map1 = new Map1({ name: 'Justin' });
            try {
                map1.foo = 'bar';
                if (map1.foo) {
                    QUnit.ok(false, 'map1 not sealed');
                } else {
                    QUnit.ok(true, 'map1 sealed - silent failure');
                }
            } catch (ex) {
                QUnit.ok(true, 'map1 sealed');
            }
            QUnit.equal(map1.name, 'computed Justin', 'map1.name property is computed');
            var map2 = new Map2({ name: 'Brian' });
            try {
                map2.foo = 'bar';
                if (map2.foo) {
                    QUnit.ok(true, 'map2 not sealed');
                } else {
                    QUnit.ok(false, 'map2 sealed');
                }
            } catch (ex) {
                QUnit.ok(false, 'map2 sealed');
            }
            QUnit.equal(map2.name, 'computed Brian', 'map2.name property is computed');
            var map3 = new Map3({ name: 'Curtis' });
            try {
                map3.foo = 'bar';
                if (map3.foo) {
                    QUnit.ok(false, 'map3 not sealed');
                } else {
                    QUnit.ok(true, 'map3 sealed');
                }
            } catch (ex) {
                QUnit.ok(true, 'map3 sealed');
            }
            QUnit.equal(map3.name, 'computed Curtis', 'map3.name property is computed');
        });
    }
    QUnit.test('get with dynamically added properties', function () {
        var map = new DefineMap();
        map.set('a', 1);
        map.set('b', 2);
        QUnit.deepEqual(map.get(), {
            a: 1,
            b: 2
        });
    });
    QUnit.test('set multiple props', function () {
        var map = new DefineMap();
        map.assign({
            a: 0,
            b: 2
        });
        QUnit.deepEqual(map.get(), {
            a: 0,
            b: 2
        }, 'added props');
        map.update({ a: 2 });
        QUnit.deepEqual(map.get(), { a: 2 }, 'removed b');
        map.assign({ foo: { bar: 'VALUE' } });
        QUnit.deepEqual(map.get(), {
            foo: { bar: 'VALUE' },
            a: 2
        }, 'works nested');
    });
    QUnit.test('serialize responds to added props', function () {
        var map = new DefineMap();
        var oi = new Observation(function () {
            return map.serialize();
        });
        canReflect.onValue(oi, function (newVal) {
            QUnit.deepEqual(newVal, {
                a: 1,
                b: 2
            }, 'updated right');
        });
        map.assign({
            a: 1,
            b: 2
        });
    });
    QUnit.test('initialize an undefined property', function () {
        var MyMap = DefineMap.extend({ seal: false }, {});
        var instance = new MyMap({ foo: 'bar' });
        equal(instance.foo, 'bar');
    });
    QUnit.test('set an already initialized null property', function () {
        var map = new DefineMap({ foo: null });
        map.assign({ foo: null });
        equal(map.foo, null);
    });
    QUnit.test('creating a new key doesn\'t cause two changes', 1, function () {
        var map = new DefineMap();
        var oi = new Observation(function () {
            return map.serialize();
        });
        canReflect.onValue(oi, function (newVal) {
            QUnit.deepEqual(newVal, { a: 1 }, 'updated right');
        });
        map.set('a', 1);
    });
    QUnit.test('setting nested object', function () {
        var m = new DefineMap({});
        m.assign({ foo: {} });
        m.assign({ foo: {} });
        QUnit.deepEqual(m.get(), { foo: {} });
    });
    QUnit.test('passing a DefineMap to DefineMap (#33)', function () {
        var MyMap = DefineMap.extend({ foo: 'observable' });
        var m = new MyMap({
            foo: {},
            bar: {}
        });
        var m2 = new MyMap(m);
        QUnit.deepEqual(m.get(), m2.get());
        QUnit.ok(m.foo === m2.foo, 'defined props the same');
        QUnit.ok(m.bar === m2.bar, 'expando props the same');
    });
    QUnit.test('serialize: function works (#38)', function () {
        var Something = DefineMap.extend({});
        var MyMap = DefineMap.extend({
            somethingRef: {
                type: function (val) {
                    return new Something({ id: val });
                },
                serialize: function (val) {
                    return val.id;
                }
            },
            somethingElseRef: {
                type: function (val) {
                    return new Something({ id: val });
                },
                serialize: false
            }
        });
        var myMap = new MyMap({
            somethingRef: 2,
            somethingElseRef: 3
        });
        QUnit.ok(myMap.somethingRef instanceof Something);
        QUnit.deepEqual(myMap.serialize(), { somethingRef: 2 }, 'serialize: function and serialize: false works');
        var MyMap2 = DefineMap.extend({
            '*': {
                serialize: function (value) {
                    return '' + value;
                }
            }
        });
        var myMap2 = new MyMap2({
            foo: 1,
            bar: 2
        });
        QUnit.deepEqual(myMap2.serialize(), {
            foo: '1',
            bar: '2'
        }, 'serialize: function on default works');
    });
    QUnit.test('get will not create properties', function () {
        var method = function () {
        };
        var MyMap = DefineMap.extend({ method: method });
        var m = new MyMap();
        m.get('foo');
        QUnit.equal(m.get('method'), method);
    });
    QUnit.test('Properties are enumerable', function () {
        QUnit.expect(4);
        var VM = DefineMap.extend({ foo: 'string' });
        var vm = new VM({
            foo: 'bar',
            baz: 'qux'
        });
        var i = 0;
        each(vm, function (value, key) {
            if (i === 0) {
                QUnit.equal(key, 'foo');
                QUnit.equal(value, 'bar');
            } else {
                QUnit.equal(key, 'baz');
                QUnit.equal(value, 'qux');
            }
            i++;
        });
    });
    QUnit.test('Getters are not enumerable', function () {
        QUnit.expect(2);
        var MyMap = DefineMap.extend({
            foo: 'string',
            baz: {
                get: function () {
                    return this.foo;
                }
            }
        });
        var map = new MyMap({ foo: 'bar' });
        each(map, function (value, key) {
            QUnit.equal(key, 'foo');
            QUnit.equal(value, 'bar');
        });
    });
    QUnit.test('extending DefineMap constructor functions (#18)', function () {
        var AType = DefineMap.extend('AType', {
            aProp: {},
            aMethod: function () {
            }
        });
        var BType = AType.extend('BType', {
            bProp: {},
            bMethod: function () {
            }
        });
        var CType = BType.extend('CType', {
            cProp: {},
            cMethod: function () {
            }
        });
        var map = new CType();
        map.on('aProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'PROP');
            QUnit.equal(oldVal, undefined);
        });
        map.on('bProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'FOO');
            QUnit.equal(oldVal, undefined);
        });
        map.on('cProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'BAR');
            QUnit.equal(oldVal, undefined);
        });
        map.aProp = 'PROP';
        map.bProp = 'FOO';
        map.cProp = 'BAR';
        QUnit.ok(map.aMethod);
        QUnit.ok(map.bMethod);
        QUnit.ok(map.cMethod);
    });
    QUnit.test('extending DefineMap constructor functions more than once (#18)', function () {
        var AType = DefineMap.extend('AType', {
            aProp: {},
            aMethod: function () {
            }
        });
        var BType = AType.extend('BType', {
            bProp: {},
            bMethod: function () {
            }
        });
        var CType = AType.extend('CType', {
            cProp: {},
            cMethod: function () {
            }
        });
        var map1 = new BType();
        var map2 = new CType();
        map1.on('aProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'PROP', 'aProp newVal on map1');
            QUnit.equal(oldVal, undefined);
        });
        map1.on('bProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'FOO', 'bProp newVal on map1');
            QUnit.equal(oldVal, undefined);
        });
        map2.on('aProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'PROP', 'aProp newVal on map2');
            QUnit.equal(oldVal, undefined);
        });
        map2.on('cProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'BAR', 'cProp newVal on map2');
            QUnit.equal(oldVal, undefined);
        });
        map1.aProp = 'PROP';
        map1.bProp = 'FOO';
        map2.aProp = 'PROP';
        map2.cProp = 'BAR';
        QUnit.ok(map1.aMethod, 'map1 aMethod');
        QUnit.ok(map1.bMethod);
        QUnit.ok(map2.aMethod);
        QUnit.ok(map2.cMethod, 'map2 cMethod');
    });
    QUnit.test('extending DefineMap constructor functions - value (#18)', function () {
        var AType = DefineMap.extend('AType', { aProp: { value: 1 } });
        var BType = AType.extend('BType', {});
        var CType = BType.extend('CType', {});
        var c = new CType();
        QUnit.equal(c.aProp, 1, 'got initial value');
    });
    QUnit.test('copying DefineMap excludes constructor', function () {
        var AType = DefineMap.extend('AType', { aProp: { value: 1 } });
        var a = new AType();
        var b = assign({}, a);
        QUnit.notEqual(a.constructor, b.constructor, 'Constructor prop not copied');
        QUnit.equal(a.aProp, b.aProp, 'Other values are unaffected');
    });
    QUnit.test('cloning from non-defined map excludes special keys on setup', function () {
        var MyType = DefineMap.extend({});
        var a = new MyType({ 'foo': 'bar' });
        var b = new DefineMap(a);
        QUnit.notEqual(a.constructor, b.constructor, 'Constructor prop not copied');
        QUnit.notEqual(a._data, b._data, '_data prop not copied');
        QUnit.notEqual(a._cid, b._cid, '_cid prop not copied');
        QUnit.equal(a.foo, b.foo, 'Other props copied');
    });
    QUnit.test('copying from .set() excludes special keys', function () {
        var MyType = DefineMap.extend({});
        var a = new MyType({
            'foo': 'bar',
            'existing': 'newVal'
        });
        var b = new DefineMap({ 'existing': 'oldVal' });
        b.assign(a);
        QUnit.notEqual(a.constructor, b.constructor, 'Constructor prop not copied');
        QUnit.notEqual(a._data, b._data, '_data prop not copied');
        QUnit.notEqual(a._cid, b._cid, '_cid prop not copied');
        QUnit.equal(a.foo, b.foo, 'NEw props copied');
    });
    QUnit.test('copying with assign() excludes special keys', function () {
        var a = {
            _data: {},
            constructor: function () {
            },
            __bindEvents: {},
            _cid: 'object0',
            'foo': 'bar',
            'existing': 'newVal'
        };
        var b = new DefineMap({ 'existing': 'oldVal' });
        assign(b, a);
        QUnit.notEqual(a.constructor, b.constructor, 'Constructor prop not copied');
        QUnit.notEqual(a._data, b._data, '_data prop not copied');
        QUnit.notEqual(a._cid, b._cid, '_cid prop not copied');
        QUnit.equal(a.foo, b.foo, 'New props copied');
        QUnit.equal(a.existing, b.existing, 'Existing props copied');
    });
    QUnit.test('shorthand getter setter (#56)', function () {
        var Person = DefineMap.extend({
            first: '*',
            last: '*',
            get fullName() {
                return this.first + ' ' + this.last;
            },
            set fullName(newVal) {
                var parts = newVal.split(' ');
                this.first = parts[0];
                this.last = parts[1];
            }
        });
        var p = new Person({
            first: 'Mohamed',
            last: 'Cherif'
        });
        p.on('fullName', function (ev, newVal, oldVal) {
            QUnit.equal(oldVal, 'Mohamed Cherif');
            QUnit.equal(newVal, 'Justin Meyer');
        });
        equal(p.fullName, 'Mohamed Cherif', 'fullName initialized right');
        p.fullName = 'Justin Meyer';
    });
    QUnit.test('compute props can be set to null or undefined (#2372)', function () {
        var VM = DefineMap.extend({ computeProp: { type: 'compute' } });
        var vmNull = new VM({ computeProp: null });
        QUnit.equal(vmNull.get('computeProp'), null, 'computeProp is null, no error thrown');
        var vmUndef = new VM({ computeProp: undefined });
        QUnit.equal(vmUndef.get('computeProp'), undefined, 'computeProp is undefined, no error thrown');
    });
    QUnit.test('Inheriting DefineMap .set doesn\'t work if prop is on base map (#74)', function () {
        var Base = DefineMap.extend({ baseProp: 'string' });
        var Inheriting = Base.extend();
        var inherting = new Inheriting();
        inherting.set('baseProp', 'value');
        QUnit.equal(inherting.baseProp, 'value', 'set prop');
    });
    if (sealWorks && System.env.indexOf('production') < 0) {
        QUnit.test('setting not defined property', function () {
            var MyMap = DefineMap.extend({ prop: {} });
            var mymap = new MyMap();
            try {
                mymap.notdefined = 'value';
                ok(false, 'no error');
            } catch (e) {
                ok(true, 'error thrown');
            }
        });
    }
    QUnit.test('.extend errors when re-defining a property (#117)', function () {
        var A = DefineMap.extend('A', {
            foo: {
                type: 'string',
                value: 'blah'
            }
        });
        A.extend('B', {
            foo: {
                type: 'string',
                value: 'flub'
            }
        });
        var C = DefineMap.extend('C', {
            foo: {
                get: function () {
                    return 'blah';
                }
            }
        });
        C.extend('D', {
            foo: {
                get: function () {
                    return 'flub';
                }
            }
        });
        QUnit.ok(true, 'extended without errors');
    });
    QUnit.test('.value functions should not be observable', function () {
        var outer = new DefineMap({ bam: 'baz' });
        var ItemsVM = DefineMap.extend({
            item: {
                value: function () {
                    (function () {
                    }(this.zed, outer.bam));
                    return new DefineMap({ foo: 'bar' });
                }
            },
            zed: 'string'
        });
        var items = new ItemsVM();
        var count = 0;
        var itemsList = new Observation(function () {
            count++;
            return items.item;
        });
        canReflect.onValue(itemsList, function () {
        });
        items.item.foo = 'changed';
        items.zed = 'changed';
        equal(count, 1);
    });
    QUnit.test('.value values are overwritten by props in DefineMap construction', function () {
        var Foo = DefineMap.extend({ bar: { value: 'baz' } });
        var foo = new Foo({ bar: 'quux' });
        equal(foo.bar, 'quux', 'Value set properly');
    });
    QUnit.test('can-reflect reflections work with DefineMap', function () {
        var b = new DefineMap({ 'foo': 'bar' });
        var c = new (DefineMap.extend({
            'baz': {
                get: function () {
                    return b.foo;
                }
            }
        }))({
            'foo': 'bar',
            thud: 'baz'
        });
        QUnit.equal(canReflect.getKeyValue(b, 'foo'), 'bar', 'unbound value');
        var handler = function (newValue) {
            QUnit.equal(newValue, 'quux', 'observed new value');
            canReflect.offKeyValue(c, 'baz', handler);
        };
        QUnit.ok(!canReflect.isValueLike(c), 'isValueLike is false');
        QUnit.ok(canReflect.isObservableLike(c), 'isObservableLike is true');
        QUnit.ok(canReflect.isMapLike(c), 'isMapLike is true');
        QUnit.ok(!canReflect.isListLike(c), 'isListLike is false');
        QUnit.ok(!canReflect.keyHasDependencies(b, 'foo'), 'keyHasDependencies -- false');
        canReflect.onKeyValue(c, 'baz', handler);
        canReflect.onKeyValue(c, 'thud', handler);
        QUnit.ok(canReflect.keyHasDependencies(c, 'baz'), 'keyHasDependencies -- true');
        b.foo = 'quux';
        c.thud = 'quux';
        QUnit.equal(canReflect.getKeyValue(c, 'baz'), 'quux', 'bound value');
        b.foo = 'thud';
        c.baz = 'jeek';
    });
    QUnit.test('can-reflect setKeyValue', function () {
        var a = new DefineMap({ 'a': 'b' });
        canReflect.setKeyValue(a, 'a', 'c');
        QUnit.equal(a.a, 'c', 'setKeyValue');
    });
    QUnit.test('can-reflect deleteKeyValue', function () {
        var a = new DefineMap({ 'a': 'b' });
        canReflect.deleteKeyValue(a, 'a');
        QUnit.equal(a.a, undefined, 'value is now undefined');
        QUnit.ok(!('a' in a.get()), 'value not included in serial');
    });
    QUnit.test('can-reflect getKeyDependencies', function () {
        var a = new DefineMap({ 'a': 'a' });
        var b = new (DefineMap.extend({
            'a': {
                get: function () {
                    return a.a;
                }
            }
        }))();
        ok(canReflect.getKeyDependencies(b, 'a'), 'dependencies exist');
        ok(!canReflect.getKeyDependencies(b, 'b'), 'no dependencies exist for unknown value');
        ok(canReflect.getKeyDependencies(b, 'a').valueDependencies.has(b._computed.a.compute), 'dependencies returned');
    });
    QUnit.test('can-reflect assign', function () {
        var aData = { 'a': 'b' };
        var bData = { 'b': 'c' };
        var a = new DefineMap(aData);
        var b = new DefineMap(bData);
        canReflect.assign(a, b);
        QUnit.deepEqual(a.get(), assign(aData, bData), 'when called with an object, should merge into existing object');
    });
    QUnit.test('Does not attempt to redefine _data if already defined', function () {
        var Bar = DefineMap.extend({ seal: false }, { baz: { value: 'thud' } });
        var baz = new Bar();
        define(baz, {
            quux: { value: 'jeek' },
            plonk: {
                get: function () {
                    return 'waldo';
                }
            }
        }, baz._define);
        QUnit.equal(baz.quux, 'jeek', 'New definitions successful');
        QUnit.equal(baz.plonk, 'waldo', 'New computed definitions successful');
        QUnit.equal(baz.baz, 'thud', 'Old definitions still available');
    });
    if (!System.isEnv('production')) {
        QUnit.test('redefines still not allowed on sealed objects', function () {
            QUnit.expect(6);
            var Bar = DefineMap.extend({ seal: true }, { baz: { value: 'thud' } });
            var baz = new Bar();
            try {
                define(baz, { quux: { value: 'jeek' } }, baz._define);
            } catch (e) {
                QUnit.ok(/is not extensible/i.test(e.message), 'Sealed object throws on data property defines');
                QUnit.ok(!Object.getOwnPropertyDescriptor(baz, 'quux'), 'nothing set on object');
                QUnit.ok(!Object.getOwnPropertyDescriptor(baz._data, 'quux'), 'nothing set on _data');
            }
            try {
                define(baz, {
                    plonk: {
                        get: function () {
                            return 'waldo';
                        }
                    }
                }, baz._define);
            } catch (e) {
                QUnit.ok(/is not extensible/i.test(e.message), 'Sealed object throws on computed property defines');
                QUnit.ok(!Object.getOwnPropertyDescriptor(baz, 'plonk'), 'nothing set on object');
                QUnit.ok(!Object.getOwnPropertyDescriptor(baz._computed, 'plonk'), 'nothing set on _computed');
            }
        });
    }
    QUnit.test('Call .get() when a nested object has its own get method', function () {
        var Bar = DefineMap.extend({ request: '*' });
        var request = {
            prop: 22,
            get: function () {
                if (arguments.length === 0) {
                    throw new Error('This function can\'t be called with 0 arguments');
                }
            }
        };
        var obj = new Bar({ request: request });
        var data = obj.get();
        QUnit.equal(data.request.prop, 22, 'obj did get()');
    });
    QUnit.test('DefineMap short-hand Type (#221)', function () {
        var Child = DefineMap.extend('child', { other: DefineMap });
        var c = new Child();
        c.other = { prop: 'hello' };
        QUnit.ok(c.other instanceof DefineMap, 'is a DefineMap');
    });
    QUnit.test('non-Object constructor', function () {
        var Constructor = DefineMap.extend();
        QUnit.ok(!isPlainObject(new DefineMap()), 'instance of DefineMap is not a plain object');
        QUnit.ok(!isPlainObject(new Constructor()), 'instance of extended DefineMap is not a plain object');
    });
    QUnit.test('Observation bound to getter using lastSetVal updates correctly (canjs#3541)', function () {
        var MyMap = DefineMap.extend({
            foo: {
                get: function (lastSetVal) {
                    if (lastSetVal) {
                        return lastSetVal;
                    }
                }
            }
        });
        var map = new MyMap();
        var oi = new Observation(function () {
            return map.get('foo');
        });
        canReflect.onValue(oi, function (newVal) {
            QUnit.equal(newVal, 'bar', 'updated to bar');
        });
        map.set('foo', 'bar');
    });
    QUnit.test('Observation bound to async getter updates correctly (canjs#3541)', function () {
        var MyMap = DefineMap.extend({
            foo: {
                get: function (lastSetVal, resolve) {
                    if (lastSetVal) {
                        return resolve(lastSetVal);
                    }
                }
            }
        });
        var map = new MyMap();
        var oi = new Observation(function () {
            return map.get('foo');
        });
        canReflect.onValue(oi, function (newVal) {
            QUnit.equal(newVal, 'bar', 'updated to bar');
        });
        map.set('foo', 'bar');
    });
    canTestHelpers.devOnlyTest('log all property changes', function (assert) {
        var done = assert.async();
        var Person = DefineMap.extend({
            first: 'string',
            last: 'string',
            children: { Type: DefineList },
            fullName: {
                get: function () {
                    return this.first + ' ' + this.last;
                }
            }
        });
        var changed = [];
        var log = dev.log;
        dev.log = function () {
            changed.push(JSON.parse(arguments[2]));
        };
        var p = new Person();
        p.log();
        p.on('fullName', function () {
        });
        p.first = 'Manuel';
        p.last = 'Mujica';
        assert.expect(1);
        setTimeout(function () {
            dev.log = log;
            assert.deepEqual(changed, [
                'first',
                'fullName',
                'last',
                'fullName'
            ], 'should log all property changes');
            done();
        });
    });
    canTestHelpers.devOnlyTest('log single property changes', function (assert) {
        var done = assert.async();
        var Person = DefineMap.extend({
            first: 'string',
            last: 'string',
            age: 'number'
        });
        var changed = [];
        var log = dev.log;
        dev.log = function () {
            changed.push(JSON.parse(arguments[2]));
        };
        var p = new Person();
        p.log('first');
        p.first = 'John';
        p.last = 'Doe';
        p.age = 99;
        assert.expect(1);
        setTimeout(function () {
            dev.log = log;
            assert.deepEqual(changed, ['first'], 'should log \'first\' changes');
            done();
        });
    });
    canTestHelpers.devOnlyTest('log multiple property changes', function (assert) {
        var done = assert.async();
        var Person = DefineMap.extend({
            first: 'string',
            last: 'string',
            age: 'number',
            company: 'string'
        });
        var changed = [];
        var log = dev.log;
        dev.log = function () {
            changed.push(JSON.parse(arguments[2]));
        };
        var p = new Person();
        p.log('first');
        p.log('age');
        p.first = 'John';
        p.last = 'Doe';
        p.company = 'Bitovi';
        p.age = 99;
        assert.expect(1);
        setTimeout(function () {
            dev.log = log;
            assert.deepEqual(changed, [
                'first',
                'age'
            ], 'should log first and age');
            done();
        });
    });
    if (System.env.indexOf('production') < 0) {
        QUnit.test('Setting a value with an object type generates a warning (#148)', function () {
            QUnit.expect(2);
            var oldwarn = canDev.warn;
            canDev.warn = function (mesg) {
                QUnit.equal(mesg, 'can-define: The value for options is set to an object. This will be shared by all instances of the DefineMap. Use a function that returns the object instead.');
            };
            DefineMap.extend({ options: { value: {} } });
            DefineMap.extend({ options: { value: [] } });
            DefineMap.extend({
                options: {
                    value: function () {
                    }
                }
            });
            DefineMap.extend({ options: { value: 2 } });
            canDev.warn = oldwarn;
        });
        QUnit.test('Setting a value to a constructor type generates a warning', function () {
            QUnit.expect(1);
            var oldwarn = canDev.warn;
            canDev.warn = function (mesg) {
                QUnit.equal(mesg, 'can-define: The "value" for options is set to a constructor. Did you mean "Value" instead?');
            };
            DefineMap.extend({ options: { value: DefineMap } });
            canDev.warn = oldwarn;
        });
    }
    canTestHelpers.devOnlyTest('can.getName symbol behavior', function (assert) {
        var getName = function (instance) {
            return instance[canSymbol.for('can.getName')]();
        };
        assert.ok('DefineMap{}', getName(new DefineMap()), 'should use DefineMap constructor name by default');
        var MyMap = DefineMap.extend('MyMap', {});
        assert.ok('MyMap{}', getName(new MyMap()), 'should use custom map name when provided');
    });
});
/*can-define@2.0.0-pre.11#define-test*/
define('can-define@2.0.0-pre.11#define-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-define',
    'can-queues',
    'can-util/js/each/each',
    'can-symbol',
    'can-util/js/dev/dev',
    'can-simple-observable'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var define = require('can-define');
    var queues = require('can-queues');
    var each = require('can-util/js/each/each');
    var canSymbol = require('can-symbol');
    var canDev = require('can-util/js/dev/dev');
    var SimpleObservable = require('can-simple-observable');
    QUnit.module('can-define');
    QUnit.test('basics on a prototype', 5, function () {
        var Person = function (first, last) {
            this.first = first;
            this.last = last;
        };
        define(Person.prototype, {
            first: '*',
            last: '*',
            fullName: {
                get: function () {
                    return this.first + ' ' + this.last;
                }
            }
        });
        var p = new Person('Mohamed', 'Cherif');
        p.bind('fullName', function (ev, newVal, oldVal) {
            QUnit.equal(oldVal, 'Mohamed Cherif');
            QUnit.equal(newVal, 'Justin Meyer');
        });
        equal(p.fullName, 'Mohamed Cherif', 'fullName initialized right');
        p.bind('first', function (el, newVal, oldVal) {
            QUnit.equal(newVal, 'Justin', 'first new value');
            QUnit.equal(oldVal, 'Mohamed', 'first old value');
        });
        queues.batch.start();
        p.first = 'Justin';
        p.last = 'Meyer';
        queues.batch.stop();
    });
    QUnit.test('basics set', 2, function () {
        var Defined = function (prop) {
            this.prop = prop;
        };
        define(Defined.prototype, {
            prop: {
                set: function (newVal) {
                    return 'foo' + newVal;
                }
            }
        });
        var def = new Defined();
        def.prop = 'bar';
        QUnit.equal(def.prop, 'foobar', 'setter works');
        var DefinedCB = function (prop) {
            this.prop = prop;
        };
        define(DefinedCB.prototype, {
            prop: {
                set: function (newVal, setter) {
                    setter('foo' + newVal);
                }
            }
        });
        var defCallback = new DefinedCB();
        defCallback.prop = 'bar';
        QUnit.equal(defCallback.prop, 'foobar', 'setter callback works');
    });
    QUnit.test('basic Type', function () {
        var Foo = function (name) {
            this.name = name;
        };
        Foo.prototype.getName = function () {
            return this.name;
        };
        var Typer = function (foo) {
            this.foo = foo;
        };
        define(Typer.prototype, { foo: { Type: Foo } });
        var t = new Typer('Justin');
        QUnit.equal(t.foo.getName(), 'Justin', 'correctly created an instance');
        var brian = new Foo('brian');
        t.foo = brian;
        QUnit.equal(t.foo, brian, 'same instances');
    });
    QUnit.test('type converters', function () {
        var Typer = function (date, string, number, bool, htmlbool, leaveAlone) {
            this.date = date;
            this.string = string;
            this.number = number;
            this.bool = bool;
            this.htmlbool = htmlbool;
            this.leaveAlone = leaveAlone;
        };
        define(Typer.prototype, {
            date: { type: 'date' },
            string: { type: 'string' },
            number: { type: 'number' },
            bool: { type: 'boolean' },
            htmlbool: { type: 'htmlbool' },
            leaveAlone: { type: '*' }
        });
        var obj = {};
        var t = new Typer(1395896701516, 5, '5', 'false', '', obj);
        QUnit.ok(t.date instanceof Date, 'converted to date');
        QUnit.equal(t.string, '5', 'converted to string');
        QUnit.equal(t.number, 5, 'converted to number');
        QUnit.equal(t.bool, false, 'converted to boolean');
        QUnit.equal(t.htmlbool, true, 'converted to htmlbool');
        QUnit.equal(t.leaveAlone, obj, 'left as object');
        t.number = '15';
        QUnit.ok(t.number === 15, 'converted to number');
    });
    QUnit.test('basics value', function () {
        var Typer = function (prop) {
            if (prop !== undefined) {
                this.prop = prop;
            }
        };
        define(Typer.prototype, { prop: { value: 'foo' } });
        var t = new Typer();
        QUnit.equal(t.prop, 'foo', 'value is used as default value');
        var Typer2 = function (prop) {
            if (prop !== undefined) {
                this.prop = prop;
            }
        };
        define(Typer2.prototype, {
            prop: {
                value: function () {
                    return [];
                },
                type: '*'
            }
        });
        var t1 = new Typer2(), t2 = new Typer2();
        QUnit.ok(t1.prop !== t2.prop, 'different array instances');
        QUnit.ok(Array.isArray(t1.prop), 'its an array');
    });
    test('basics Value', function () {
        var Typer = function (prop) {
        };
        define(Typer.prototype, {
            prop: {
                Value: Array,
                type: '*'
            }
        });
        var t1 = new Typer(), t2 = new Typer();
        QUnit.ok(t1.prop !== t2.prop, 'different array instances');
        QUnit.ok(Array.isArray(t1.prop), 'its an array');
    });
    test('setter with no arguments and returns undefined does the default behavior, the setter is for side effects only', function () {
        var Typer = function (prop) {
        };
        define(Typer.prototype, {
            prop: {
                set: function () {
                    this.foo = 'bar';
                }
            },
            foo: '*'
        });
        var t = new Typer();
        t.prop = false;
        deepEqual({
            foo: t.foo,
            prop: t.prop
        }, {
            foo: 'bar',
            prop: false
        }, 'got the right props');
    });
    test('type happens before the set', 2, function () {
        var Typer = function () {
        };
        define(Typer.prototype, {
            prop: {
                type: 'number',
                set: function (newValue) {
                    equal(typeof newValue, 'number', 'got a number');
                    return newValue + 1;
                }
            }
        });
        var map = new Typer();
        map.prop = '5';
        equal(map.prop, 6, 'number');
    });
    test('getter and setter work', function () {
        expect(5);
        var Paginate = define.Constructor({
            limit: '*',
            offset: '*',
            page: {
                set: function (newVal) {
                    this.offset = (parseInt(newVal) - 1) * this.limit;
                },
                get: function () {
                    return Math.floor(this.offset / this.limit) + 1;
                }
            }
        });
        var p = new Paginate({
            limit: 10,
            offset: 20
        });
        equal(p.page, 3, 'page get right');
        p.bind('page', function (ev, newValue, oldValue) {
            equal(newValue, 2, 'got new value event');
            equal(oldValue, 3, 'got old value event');
        });
        p.page = 2;
        equal(p.page, 2, 'page set right');
        equal(p.offset, 10, 'page offset set');
    });
    test('getter with initial value', function () {
        var comp = new SimpleObservable(1);
        var Grabber = define.Constructor({
            vals: {
                type: '*',
                Value: Array,
                get: function (current, setVal) {
                    if (setVal) {
                        current.push(comp.get());
                    }
                    return current;
                }
            }
        });
        var g = new Grabber();
        equal(g.vals.length, 0, 'zero items in array');
    });
    test('default behaviors with "*" work for attributes', function () {
        expect(6);
        var DefaultMap = define.Constructor({
            '*': {
                type: 'number',
                set: function (newVal) {
                    ok(true, 'set called');
                    return newVal;
                }
            },
            someNumber: { value: '5' },
            number: {}
        });
        var map = new DefaultMap();
        equal(map.someNumber, '5', 'default values are not type converted anymore');
        map.someNumber = '5';
        equal(map.someNumber, 5, 'on a set, they should be type converted');
        map.number = '10';
        equal(map.number, 10, 'value of number should be converted to a number');
    });
    test('nested define', function () {
        var nailedIt = 'Nailed it';
        var Example = define.Constructor({ name: { value: nailedIt } });
        var NestedMap = define.Constructor({
            isEnabled: { value: true },
            test: { Value: Example },
            examples: {
                type: {
                    one: { Value: Example },
                    two: {
                        type: { deep: { Value: Example } },
                        Value: Object
                    }
                },
                Value: Object
            }
        });
        var nested = new NestedMap();
        equal(nested.test.name, nailedIt);
        equal(nested.examples.one.name, nailedIt);
        equal(nested.examples.two.deep.name, nailedIt);
        ok(nested.test instanceof Example);
        ok(nested.examples.one instanceof Example);
        ok(nested.examples.two.deep instanceof Example);
    });
    test('Can make an attr alias a compute (#1470)', 9, function () {
        var computeValue = new SimpleObservable(1);
        var GetMap = define.Constructor({
            value: {
                set: function (newValue, setVal, oldValue) {
                    if (newValue instanceof SimpleObservable) {
                        return newValue;
                    }
                    if (oldValue && oldValue instanceof SimpleObservable) {
                        oldValue.set(newValue);
                        return oldValue;
                    }
                    return newValue;
                },
                get: function (value) {
                    return value instanceof SimpleObservable ? value.get() : value;
                }
            }
        });
        var getMap = new GetMap();
        getMap.value = computeValue;
        equal(getMap.value, 1, 'initial value read from compute');
        var bindCallbacks = 0;
        getMap.bind('value', function (ev, newVal, oldVal) {
            switch (bindCallbacks) {
            case 0:
                equal(newVal, 2, '0 - bind called with new val');
                equal(oldVal, 1, '0 - bind called with old val');
                break;
            case 1:
                equal(newVal, 3, '1 - bind called with new val');
                equal(oldVal, 2, '1 - bind called with old val');
                break;
            case 2:
                equal(newVal, 4, '2 - bind called with new val');
                equal(oldVal, 3, '2 - bind called with old val');
                break;
            }
            bindCallbacks++;
        });
        computeValue.set(2);
        getMap.value = 3;
        equal(getMap.value, 3, 'read value is 3');
        equal(computeValue.get(), 3, 'the compute value is 3');
        var newComputeValue = new SimpleObservable(4);
        getMap.value = newComputeValue;
    });
    test('One event on getters (#1585)', function () {
        var Person = define.Constructor({
            name: '*',
            id: 'number'
        });
        var AppState = define.Constructor({
            person: {
                get: function appState_person_get(lastSetValue, resolve) {
                    if (lastSetValue) {
                        return lastSetValue;
                    } else if (this.personId) {
                        resolve(new Person({
                            name: 'Jose',
                            id: 5
                        }));
                    } else {
                        return null;
                    }
                },
                Type: Person
            },
            personId: '*'
        });
        var appState = new AppState();
        var personEvents = 0;
        appState.bind('person', function addPersonEvents(ev, person) {
            personEvents++;
        });
        equal(appState.person, null, 'no personId and no lastSetValue');
        appState.personId = 5;
        equal(appState.person.name, 'Jose', 'a personId, providing Jose');
        ok(appState.person instanceof Person, 'got a person instance');
        appState.person = { name: 'Julia' };
        ok(appState.person instanceof Person, 'got a person instance');
        equal(personEvents, 2);
    });
    test('Can read a defined property with a set/get method (#1648)', function () {
        var Map = define.Constructor({
            foo: {
                value: '',
                set: function (setVal) {
                    return setVal;
                },
                get: function (lastSetVal) {
                    return lastSetVal;
                }
            }
        });
        var map = new Map();
        equal(map.foo, '', 'Calling .foo returned the correct value');
        map.foo = 'baz';
        equal(map.foo, 'baz', 'Calling .foo returned the correct value');
    });
    test('Can bind to a defined property with a set/get method (#1648)', 3, function () {
        var Map = define.Constructor({
            foo: {
                value: '',
                set: function (setVal) {
                    return setVal;
                },
                get: function (lastSetVal) {
                    return lastSetVal;
                }
            }
        });
        var map = new Map();
        map.bind('foo', function () {
            ok(true, 'Bound function is called');
        });
        equal(map.foo, '', 'Calling .attr(\'foo\') returned the correct value');
        map.foo = 'baz';
        equal(map.foo, 'baz', 'Calling .attr(\'foo\') returned the correct value');
    });
    test('type converters handle null and undefined in expected ways (1693)', function () {
        var Typer = define.Constructor({
            date: { type: 'date' },
            string: { type: 'string' },
            number: { type: 'number' },
            'boolean': { type: 'boolean' },
            htmlbool: { type: 'htmlbool' },
            leaveAlone: { type: '*' }
        });
        var t = new Typer({
            date: undefined,
            string: undefined,
            number: undefined,
            'boolean': undefined,
            htmlbool: undefined,
            leaveAlone: undefined
        });
        equal(t.date, undefined, 'converted to date');
        equal(t.string, undefined, 'converted to string');
        equal(t.number, undefined, 'converted to number');
        equal(t.boolean, undefined, 'converted to boolean');
        equal(t.htmlbool, false, 'converted to htmlbool');
        equal(t.leaveAlone, undefined, 'left as object');
        t = new Typer({
            date: null,
            string: null,
            number: null,
            'boolean': null,
            htmlbool: null,
            leaveAlone: null
        });
        equal(t.date, null, 'converted to date');
        equal(t.string, null, 'converted to string');
        equal(t.number, null, 'converted to number');
        equal(t.boolean, null, 'converted to boolean');
        equal(t.htmlbool, false, 'converted to htmlbool');
        equal(t.leaveAlone, null, 'left as object');
    });
    test('Initial value does not call getter', function () {
        expect(0);
        var Map = define.Constructor({
            count: {
                get: function (lastVal) {
                    ok(false, 'Should not be called');
                    return lastVal;
                }
            }
        });
        new Map({ count: 100 });
    });
    test('getters produce change events', function () {
        var Map = define.Constructor({
            count: {
                get: function (lastVal) {
                    return lastVal;
                }
            }
        });
        var map = new Map();
        map.bind('count', function () {
            ok(true, 'change called');
        });
        map.count = 22;
    });
    test('Asynchronous virtual properties cause extra recomputes (#1915)', function () {
        stop();
        var ran = false;
        var VM = define.Constructor({
            foo: {
                get: function (lastVal, setVal) {
                    setTimeout(function () {
                        if (setVal) {
                            setVal(5);
                        }
                    }, 10);
                }
            },
            bar: {
                get: function () {
                    var foo = this.foo;
                    if (foo) {
                        if (ran) {
                            ok(false, 'Getter ran twice');
                        }
                        ran = true;
                        return foo * 2;
                    }
                }
            }
        });
        var vm = new VM();
        vm.bind('bar', function () {
        });
        setTimeout(function () {
            equal(vm.bar, 10);
            start();
        }, 200);
    });
    QUnit.test('Default values cannot be set (#8)', function () {
        var Person = function () {
        };
        define(Person.prototype, {
            first: {
                type: 'string',
                value: 'Chris'
            },
            last: {
                type: 'string',
                value: 'Gomez'
            },
            fullName: {
                get: function () {
                    return this.first + ' ' + this.last;
                }
            }
        });
        var p = new Person();
        QUnit.equal(p.fullName, 'Chris Gomez', 'Fullname is correct');
        p.first = 'Sara';
        QUnit.equal(p.fullName, 'Sara Gomez', 'Fullname is correct after update');
    });
    QUnit.test('default type is setable', function () {
        var Person = function () {
        };
        define(Person.prototype, {
            '*': 'string',
            first: { value: 1 },
            last: { value: 2 }
        });
        var p = new Person();
        QUnit.ok(p.first === '1', typeof p.first);
        QUnit.ok(p.last === '2', typeof p.last);
    });
    QUnit.test('expandos are added in define.setup (#25)', function () {
        var MyMap = define.Constructor({});
        var map = new MyMap({ prop: 4 });
        map.on('prop', function () {
            QUnit.ok(true, 'prop event called');
        });
        map.prop = 5;
    });
    QUnit.test('Set property with type compute', function () {
        var MyMap = define.Constructor({ computeProp: { type: 'compute' } });
        var m = new MyMap();
        m.computeProp = new SimpleObservable(0);
        equal(m.computeProp, 0, 'Property has correct value');
        m.computeProp = new SimpleObservable(1);
        equal(m.computeProp, 1, 'Property has correct value');
    });
    QUnit.test('Compute type property can have a default value', function () {
        var MyMap = define.Constructor({
            computeProp: {
                type: 'compute',
                value: function () {
                    return 0;
                }
            }
        });
        var m = new MyMap();
        equal(m.computeProp, 0, 'Property has correct value');
        m.computeProp = 1;
        equal(m.computeProp, 1, 'Property has correct value');
    });
    QUnit.test('Compute type property with compute default value triggers change events when updated', function () {
        var expected = 0;
        var c = new SimpleObservable(0);
        var MyMap = define.Constructor({
            computeProp: {
                type: 'compute',
                value: function () {
                    return c;
                }
            }
        });
        var m = new MyMap();
        c.on(function (newVal) {
            equal(newVal, expected, 'Compute fired change event');
        });
        m.on('computeProp', function (ev, newVal) {
            equal(newVal, expected, 'Map fired change event');
        });
        expected = 1;
        m.computeProp = expected;
        expected = 2;
        c.set(expected);
    });
    QUnit.test('Compute type property can have a default value that is a compute', function () {
        var c = new SimpleObservable(0);
        var MyMap = define.Constructor({
            computeProp: {
                type: 'compute',
                value: function () {
                    return c;
                }
            }
        });
        var m = new MyMap();
        equal(m.computeProp, 0, 'Property has correct value');
        c.set(1);
        equal(m.computeProp, 1, 'Property has correct value');
    });
    QUnit.test('Extensions can modify definitions', function () {
        var oldExtensions = define.extensions;
        define.behaviors.push('extended');
        define.extensions = function (objPrototype, prop, definition) {
            if (definition.extended) {
                return { value: 'extended' };
            }
        };
        var MyMap = define.Constructor({
            foo: {
                value: 'defined',
                extended: true
            },
            bar: { value: 'defined' }
        });
        var map = new MyMap();
        QUnit.equal(map.foo, 'extended', 'Value was set via extension');
        QUnit.equal(map.bar, 'defined', 'Value was set via definition');
        define.extensions = oldExtensions;
    });
    QUnit.test('Properties are enumerable', function () {
        QUnit.expect(4);
        function VM(foo) {
            this.foo = foo;
        }
        define(VM.prototype, { foo: 'string' });
        var vm = new VM('bar');
        vm.baz = 'qux';
        var i = 0;
        each(vm, function (value, key) {
            if (i === 0) {
                QUnit.equal(key, 'foo');
                QUnit.equal(value, 'bar');
            } else {
                QUnit.equal(key, 'baz');
                QUnit.equal(value, 'qux');
            }
            i++;
        });
    });
    QUnit.test('Doesn\'t override canSymbol.iterator if already on the prototype', function () {
        function MyMap() {
        }
        MyMap.prototype[canSymbol.iterator || canSymbol.for('iterator')] = function () {
            var i = 0;
            return {
                next: function () {
                    if (i === 0) {
                        i++;
                        return {
                            value: [
                                'it',
                                'worked'
                            ],
                            done: false
                        };
                    }
                    return {
                        value: undefined,
                        done: true
                    };
                }
            };
        };
        define(MyMap.prototype, { foo: 'string' });
        var map = new MyMap();
        map.foo = 'bar';
        each(map, function (value, key) {
            QUnit.equal(value, 'worked');
            QUnit.equal(key, 'it');
        });
    });
    QUnit.test('nullish values are not converted for type or Type', function (assert) {
        var Foo = function () {
        };
        var MyMap = define.Constructor({
            map: { Type: Foo },
            notype: {}
        });
        var vm = new MyMap({
            map: {},
            notype: {}
        });
        assert.ok(vm.map instanceof Foo, 'map is another type');
        assert.ok(vm.notype instanceof Object, 'notype is an Object');
        vm.map = null;
        vm.notype = null;
        assert.equal(vm.map, null, 'map is null');
        assert.equal(vm.map, null, 'notype is null');
    });
    QUnit.test('shorthand getter (#56)', function () {
        var Person = function (first, last) {
            this.first = first;
            this.last = last;
        };
        define(Person.prototype, {
            first: '*',
            last: '*',
            get fullName() {
                return this.first + ' ' + this.last;
            }
        });
        var p = new Person('Mohamed', 'Cherif');
        p.on('fullName', function (ev, newVal, oldVal) {
            QUnit.equal(oldVal, 'Mohamed Cherif');
            QUnit.equal(newVal, 'Justin Meyer');
        });
        equal(p.fullName, 'Mohamed Cherif', 'fullName initialized right');
        queues.batch.start();
        p.first = 'Justin';
        p.last = 'Meyer';
        queues.batch.stop();
    });
    QUnit.test('shorthand getter setter (#56)', function () {
        var Person = function (first, last) {
            this.first = first;
            this.last = last;
        };
        define(Person.prototype, {
            first: '*',
            last: '*',
            get fullName() {
                return this.first + ' ' + this.last;
            },
            set fullName(newVal) {
                var parts = newVal.split(' ');
                this.first = parts[0];
                this.last = parts[1];
            }
        });
        var p = new Person('Mohamed', 'Cherif');
        p.on('fullName', function (ev, newVal, oldVal) {
            QUnit.equal(oldVal, 'Mohamed Cherif');
            QUnit.equal(newVal, 'Justin Meyer');
        });
        equal(p.fullName, 'Mohamed Cherif', 'fullName initialized right');
        p.fullName = 'Justin Meyer';
    });
    QUnit.test('set and value work together (#87)', function () {
        var Type = define.Constructor({
            prop: {
                value: 2,
                set: function (num) {
                    return num * num;
                }
            }
        });
        var instance = new Type();
        QUnit.equal(instance.prop, 4, 'used setter');
    });
    QUnit.test('async setter is provided', 5, function () {
        var RESOLVE;
        var Type = define.Constructor({
            prop: {
                value: 2,
                set: function (num, resolve) {
                    resolve(num * num);
                }
            },
            prop2: {
                value: 3,
                set: function (num, resolve) {
                    RESOLVE = resolve;
                }
            }
        });
        var instance = new Type();
        QUnit.equal(instance.prop, 4, 'used async setter');
        QUnit.equal(instance.prop2, undefined, 'used async setter');
        instance.on('prop2', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 9, 'updated');
            QUnit.equal(oldVal, undefined, 'updated');
        });
        RESOLVE(9);
        QUnit.equal(instance.prop2, 9, 'used async setter updates after');
    });
    QUnit.test('setter with default value causes an infinite loop (#142)', function () {
        var A = define.Constructor({
            val: {
                value: 'hello',
                set: function (val) {
                    if (this.val) {
                    }
                    return val;
                }
            }
        });
        var a = new A();
        QUnit.equal(a.val, 'hello', 'creating an instance should not cause an inifinte loop');
    });
    QUnit.test('defined properties are configurable', function () {
        var A = define.Constructor({
            val: {
                get: function () {
                    return 'foo';
                }
            }
        });
        var dataInitializers = A.prototype._define.dataInitializers, computedInitializers = A.prototype._define.computedInitializers;
        var newDefinition = {
            get: function () {
                return 'bar';
            }
        };
        define.property(A.prototype, 'val', newDefinition, dataInitializers, computedInitializers);
        var a = new A();
        QUnit.equal(a.val, 'bar', 'It was redefined');
    });
    QUnit.test('define() should add a CID (#246)', function () {
        var Greeting = function (message) {
            this.message = message;
        };
        define(Greeting.prototype, { message: { type: 'string' } });
        var g = new Greeting();
        QUnit.ok(g._cid, 'should have a CID property');
    });
    if (System.env.indexOf('production') < 0) {
        QUnit.test('Setting a value with only a get() generates a warning (#202)', function () {
            QUnit.expect(3);
            var VM = function () {
            };
            define(VM.prototype, {
                derivedProp: {
                    get: function () {
                        return 'Hello World';
                    }
                }
            });
            var vm = new VM();
            vm.on('derivedProp', function () {
            });
            var oldwarn = canDev.warn;
            canDev.warn = function (mesg) {
                QUnit.equal(mesg, 'can-define: Set value for property derivedProp ignored, as its definition has a zero-argument getter and no setter', 'Warning is expected message');
            };
            vm.derivedProp = 'prop is set';
            QUnit.equal(vm.derivedProp, 'Hello World', 'Getter value is preserved');
            VM.shortName = 'VM';
            canDev.warn = function (mesg) {
                QUnit.equal(mesg, 'can-define: Set value for property derivedProp on VM ignored, as its definition has a zero-argument getter and no setter', 'Warning is expected message');
            };
            vm.derivedProp = 'prop is set';
            canDev.warn = oldwarn;
        });
        QUnit.test('warn on using a Constructor for small-t type definintions', function () {
            expect(2);
            var oldWarn = canDev.warn;
            canDev.warn = function (mesg) {
                QUnit.equal(mesg, 'can-define: the definition for currency uses a constructor for "type". Did you mean "Type"?');
            };
            function Currency() {
                return this;
            }
            Currency.prototype = { symbol: 'USD' };
            function VM() {
            }
            define(VM.prototype, {
                currency: {
                    type: Currency,
                    value: function () {
                        return new Currency({});
                    }
                }
            });
            canDev.warn = function (mesg) {
                QUnit.equal(mesg, 'can-define: the definition for currency on VM2 uses a constructor for "type". Did you mean "Type"?');
            };
            function VM2() {
            }
            VM2.shortName = 'VM2';
            define(VM2.prototype, {
                currency: {
                    type: Currency,
                    value: function () {
                        return new Currency({});
                    }
                }
            });
            canDev.warn = oldWarn;
        });
    }
});
/*can-define@2.0.0-pre.11#test/test*/
define('can-define@2.0.0-pre.11#test/test', [
    'require',
    'exports',
    'module',
    '../list/list-test',
    '../map/map-test',
    '../define-test',
    'can-define/map/map',
    'can-define/list/list',
    'can-util/js/is-plain-object/is-plain-object',
    'can-observation',
    'can-reflect',
    'can-define',
    'steal-qunit'
], function (require, exports, module) {
    require('../list/list-test');
    require('../map/map-test');
    require('../define-test');
    var DefineMap = require('can-define/map/map');
    var DefineList = require('can-define/list/list');
    var isPlainObject = require('can-util/js/is-plain-object/is-plain-object');
    var Observation = require('can-observation');
    var canReflect = require('can-reflect');
    var define = require('can-define');
    var QUnit = require('steal-qunit');
    QUnit.module('can-define: map and list combined');
    QUnit.test('basics', function () {
        var items = new DefineMap({
            people: [
                { name: 'Justin' },
                { name: 'Brian' }
            ],
            count: 1000
        });
        QUnit.ok(items.people instanceof DefineList, 'people is list');
        QUnit.ok(items.people.item(0) instanceof DefineMap, '1st object is Map');
        QUnit.ok(items.people.item(1) instanceof DefineMap, '2nd object is Map');
        QUnit.equal(items.people.item(1).name, 'Brian', '2nd object\'s name is right');
        QUnit.equal(items.count, 1000, 'count is number');
    });
    QUnit.test('basic type', function () {
        QUnit.expect(6);
        var Typer = function (arrayWithAddedItem, listWithAddedItem) {
            this.arrayWithAddedItem = arrayWithAddedItem;
            this.listWithAddedItem = listWithAddedItem;
        };
        define(Typer.prototype, {
            arrayWithAddedItem: {
                type: function (value) {
                    if (value && value.push) {
                        value.push('item');
                    }
                    return value;
                }
            },
            listWithAddedItem: {
                type: function (value) {
                    if (value && value.push) {
                        value.push('item');
                    }
                    return value;
                },
                Type: DefineList
            }
        });
        var t = new Typer();
        deepEqual(Object.keys(t), [], 'no keys');
        var array = [];
        t.arrayWithAddedItem = array;
        deepEqual(array, ['item'], 'updated array');
        QUnit.equal(t.arrayWithAddedItem, array, 'leave value as array');
        t.listWithAddedItem = [];
        QUnit.ok(t.listWithAddedItem instanceof DefineList, 'convert to CanList');
        QUnit.equal(t.listWithAddedItem[0], 'item', 'has item in it');
        var observation = new Observation(function () {
            return t.listWithAddedItem.attr('length');
        });
        canReflect.onValue(observation, function (newVal) {
            QUnit.equal(newVal, 2, 'got a length change');
        });
        t.listWithAddedItem.push('another item');
    });
    QUnit.test('serialize works', function () {
        var Person = DefineMap.extend({
            first: 'string',
            last: 'string'
        });
        var People = DefineList.extend({ '*': Person });
        var people = new People([{
                first: 'j',
                last: 'm'
            }]);
        QUnit.deepEqual(people.serialize(), [{
                first: 'j',
                last: 'm'
            }]);
    });
    QUnit.test('Extended Map with empty def converts to default Observables', function () {
        var School = DefineMap.extend({
            students: {},
            teacher: {}
        });
        var school = new School();
        school.students = [{ name: 'J' }];
        school.teacher = { name: 'M' };
        ok(school.students instanceof DefineList, 'converted to DefineList');
        ok(school.teacher instanceof DefineMap, 'converted to DefineMap');
    });
    QUnit.test('default \'observable\' type prevents Type from working (#29)', function () {
        var M = DefineMap.extend('M', { id: 'number' });
        var L = DefineList.extend('L', { '*': M });
        var MyMap = DefineMap.extend({ l: L });
        var m = new MyMap({ l: [{ id: 5 }] });
        QUnit.ok(m.l[0] instanceof M, 'is instance');
        QUnit.equal(m.l[0].id, 5, 'correct props');
    });
    QUnit.test('inline DefineList Type', function () {
        var M = DefineMap.extend('M', { id: 'number' });
        var MyMap = DefineMap.extend({ l: { Type: [M] } });
        var m = new MyMap({ l: [{ id: 5 }] });
        QUnit.ok(m.l[0] instanceof M, 'is instance');
        QUnit.equal(m.l[0].id, 5, 'correct props');
    });
    QUnit.test('recursively `get`s (#31)', function () {
        var M = DefineMap.extend('M', { id: 'number' });
        var MyMap = DefineMap.extend({ l: { Type: [M] } });
        var m = new MyMap({ l: [{ id: 5 }] });
        var res = m.get();
        QUnit.ok(Array.isArray(res.l), 'is a plain array');
        QUnit.ok(isPlainObject(res.l[0]), 'plain object');
    });
    QUnit.test('DefineList trigger deprecation warning when set with Map.set (#93)', 0, function () {
        var map = new DefineMap({ things: [{ foo: 'bar' }] });
        map.things.attr = function () {
            ok(false, 'attr should not be called');
        };
        map.assign({ things: [{ baz: 'luhrmann' }] });
    });
    test('Value generator can read other properties', function () {
        var Map = define.Constructor({
            letters: { value: 'ABC' },
            numbers: {
                value: [
                    1,
                    2,
                    3
                ]
            },
            definedLetters: { value: 'DEF' },
            definedNumbers: {
                value: [
                    4,
                    5,
                    6
                ]
            },
            generatedLetters: {
                value: function () {
                    return 'GHI';
                }
            },
            generatedNumbers: {
                value: function () {
                    return new DefineList([
                        7,
                        8,
                        9
                    ]);
                }
            },
            firstLetter: {
                value: function () {
                    return this.letters.substr(0, 1);
                }
            },
            firstNumber: {
                value: function () {
                    return this.numbers[0];
                }
            },
            middleLetter: {
                value: function () {
                    return this.definedLetters.substr(1, 1);
                }
            },
            middleNumber: {
                value: function () {
                    return this.definedNumbers[1];
                }
            },
            lastLetter: {
                value: function () {
                    return this.generatedLetters.substr(2, 1);
                }
            },
            lastNumber: {
                value: function () {
                    return this.generatedNumbers[2];
                }
            }
        });
        var map = new Map();
        var prefix = 'Was able to read dependent value from ';
        equal(map.firstLetter, 'A', prefix + 'traditional can.Map style property definition');
        equal(map.firstNumber, 1, prefix + 'traditional can.Map style property definition');
        equal(map.middleLetter, 'E', prefix + 'define plugin style default property definition');
        equal(map.middleNumber, 5, prefix + 'define plugin style default property definition');
        equal(map.lastLetter, 'I', prefix + 'define plugin style generated default property definition');
        equal(map.lastNumber, 9, prefix + 'define plugin style generated default property definition');
    });
    test('value and get (#1521)', function () {
        var MyMap = define.Constructor({
            data: {
                value: function () {
                    return new DefineList(['test']);
                }
            },
            size: {
                value: 1,
                get: function (val) {
                    var list = this.data;
                    var length = list.attr('length');
                    return val + length;
                }
            }
        });
        var map = new MyMap({});
        equal(map.size, 2);
    });
    QUnit.test('Assign value on map', function () {
        var MyConstruct = DefineMap.extend({
            list: DefineList,
            name: 'string'
        });
        var obj = new MyConstruct({
            list: [
                'data',
                'data',
                'data'
            ],
            name: 'CanJS',
            foo: {
                bar: 'bar',
                zoo: 'say'
            }
        });
        obj.assign({
            list: ['another'],
            foo: { bar: 'zed' }
        });
        QUnit.equal(obj.list.length, 1, 'list length should be 1');
        QUnit.propEqual(obj.foo, { bar: 'zed' }, 'foo.bar is set correctly');
        QUnit.equal(obj.name, 'CanJS', 'name is unchanged');
    });
    QUnit.test('Update value on a map', function () {
        var MyConstruct = DefineMap.extend({
            list: DefineList,
            name: 'string'
        });
        var obj = new MyConstruct({
            list: [
                'data',
                'data',
                'data'
            ],
            name: 'CanJS',
            foo: { bar: 'bar' }
        });
        obj.update({
            list: ['another'],
            foo: { bar: 'zed' }
        });
        QUnit.equal(obj.list.length, 1, 'list length should be 1');
        QUnit.equal(obj.foo.bar, 'zed', 'foo.bar is set correctly');
        QUnit.equal(obj.name, undefined, 'name is removed');
    });
    QUnit.test('Deep assign a map', function () {
        var MyConstruct = DefineMap.extend({
            list: DefineList,
            name: 'string'
        });
        var obj = new MyConstruct({
            list: [
                'data',
                'data',
                'data'
            ],
            name: 'Test Name'
        });
        QUnit.equal(obj.list.length, 3, 'list length should be 3');
        obj.assignDeep({ list: ['something'] });
        QUnit.equal(obj.name, 'Test Name', 'Name property is still intact');
        QUnit.equal(obj.list[0], 'something', 'the first element in the list should be updated');
    });
    QUnit.test('Deep updating a map', function () {
        var MyConstruct = DefineMap.extend({
            list: DefineList,
            name: 'string'
        });
        var obj = new MyConstruct({
            list: [
                'data',
                'data',
                'data'
            ],
            name: 'Test Name'
        });
        QUnit.equal(obj.list.length, 3, 'list length should be 3');
        obj.updateDeep({ list: ['something'] });
        QUnit.equal(obj.name, undefined, 'Name property has been reset');
        QUnit.equal(obj.list[0], 'something', 'the first element of the list should be updated');
    });
});
/*can-stache-bindings@4.0.0-pre.8#test/helpers*/
define('can-stache-bindings@4.0.0-pre.8#test/helpers', [
    'require',
    'exports',
    'module',
    'can-globals',
    'can-util/dom/events/events',
    'can-util/dom/mutate/mutate',
    'can-util/dom/data/data',
    'can-vdom/make-document/make-document',
    'can-util/dom/events/inserted/inserted'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var globals = require('can-globals');
        var domEvents = require('can-util/dom/events/events');
        var domMutate = require('can-util/dom/mutate/mutate');
        var domData = require('can-util/dom/data/data');
        var makeDocument = require('can-vdom/make-document/make-document');
        require('can-util/dom/events/inserted/inserted');
        var helpers = {
            makeQUnitModule: function (name, doc, enableMO) {
                QUnit.module(name, {
                    setup: function () {
                        globals.setKeyValue('document', doc);
                        if (!enableMO) {
                            globals.setKeyValue('MutationObserver', null);
                        }
                        if (doc === document) {
                            this.fixture = document.getElementById('qunit-fixture');
                        } else {
                            this.fixture = doc.createElement('qunit-fixture');
                            doc.body.appendChild(this.fixture);
                        }
                    },
                    teardown: function () {
                        if (doc !== document) {
                            doc.body.removeChild(this.fixture);
                        }
                        stop();
                        helpers.afterMutation(function () {
                            globals.deleteKeyValue('document');
                            globals.deleteKeyValue('MutationObserver');
                            var fixture = document.getElementById('qunit-fixture');
                            while (fixture && fixture.hasChildNodes()) {
                                domData.delete.call(fixture.lastChild);
                                fixture.removeChild(fixture.lastChild);
                            }
                            start();
                        });
                    }
                });
            },
            afterMutation: function (cb) {
                var doc = globals.getKeyValue('document');
                var div = doc.createElement('div');
                domEvents.addEventListener.call(div, 'inserted', function () {
                    doc.body.removeChild(div);
                    setTimeout(cb, 5);
                });
                setTimeout(function () {
                    domMutate.appendChild.call(doc.body, div);
                }, 10);
            },
            makeTests: function (name, makeTest) {
                helpers.makeQUnitModule(name + ' - dom', document, true);
                makeTest(name + ' - dom', document, true, QUnit.test);
                var doc = makeDocument();
                helpers.makeQUnitModule(name + ' - vdom', doc, false);
                makeTest(name + ' - vdom', doc, false, function () {
                });
            }
        };
        module.exports = helpers;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-stache-bindings@4.0.0-pre.8#test/mock-component-simple-map*/
define('can-stache-bindings@4.0.0-pre.8#test/mock-component-simple-map', [
    'require',
    'exports',
    'module',
    'can-stache-bindings',
    'can-simple-map',
    'can-view-callbacks',
    'can-view-scope',
    'can-view-nodelist',
    'can-util/dom/data/data',
    'can-util/dom/mutate/mutate'
], function (require, exports, module) {
    var stacheBindings = require('can-stache-bindings');
    var CanSimpleMap = require('can-simple-map');
    var viewCallbacks = require('can-view-callbacks');
    var Scope = require('can-view-scope');
    var nodeLists = require('can-view-nodelist');
    var domData = require('can-util/dom/data/data');
    var domMutate = require('can-util/dom/mutate/mutate');
    var MockComponent;
    module.exports = MockComponent = {
        extend: function (proto) {
            viewCallbacks.tag(proto.tag, function (el, componentTagData) {
                var viewModel;
                var teardownBindings = stacheBindings.behaviors.viewModel(el, componentTagData, function (initialViewModelData) {
                    if (typeof proto.viewModel === 'function') {
                        return viewModel = new proto.viewModel(initialViewModelData);
                    } else if (proto.viewModel instanceof CanSimpleMap) {
                        proto.viewModel.set(initialViewModelData);
                        return viewModel = proto.viewModel;
                    } else {
                        var VM = CanSimpleMap.extend(proto.viewModel);
                        return viewModel = new VM(initialViewModelData);
                    }
                }, {});
                domData.set.call(el, 'viewModel', viewModel);
                domData.set.call(el, 'preventDataBindings', true);
                if (proto.template) {
                    var shadowScope = componentTagData.scope.add(new Scope.Refs()).add(viewModel, { viewModel: true });
                    domData.set.call(el, 'shadowScope', shadowScope);
                    var nodeList = nodeLists.register([], function () {
                        teardownBindings();
                    }, componentTagData.parentNodeList || true, false);
                    var frag = proto.template(shadowScope, componentTagData.options, nodeList);
                    domMutate.appendChild.call(el, frag);
                }
            });
        }
    };
});
/*can-stache-bindings@4.0.0-pre.8#test/colon/basics-test*/
define('can-stache-bindings@4.0.0-pre.8#test/colon/basics-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    '../helpers',
    'can-stache-bindings',
    'can-stache',
    'can-simple-map',
    '../mock-component-simple-map',
    'can-util/js/dev/dev'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var testHelpers = require('../helpers');
    var stacheBindings = require('can-stache-bindings');
    var stache = require('can-stache');
    var SimpleMap = require('can-simple-map');
    var MockComponent = require('../mock-component-simple-map');
    var dev = require('can-util/js/dev/dev');
    testHelpers.makeTests('can-stache-bindings - colon - basics', function (name, doc, enableMO) {
        test('basics', 5, function () {
            var viewModel = new SimpleMap({
                toChild: 'toChild',
                toParent: 'toParent',
                twoWay: 'twoWay'
            });
            MockComponent.extend({
                tag: 'basic-colon',
                viewModel: viewModel
            });
            var template = stache('<basic-colon ' + 'toChild:from=\'valueA\' toParent:to=\'valueB\' twoWay:bind=\'valueC\' ' + 'on:vmevent=\'methodD()\'' + '/>');
            var MySimpleMap = SimpleMap.extend({
                methodD: function () {
                    QUnit.ok(true, 'on:vmevent bindings work');
                }
            });
            var parent = new MySimpleMap({
                valueA: 'A',
                valueB: 'B',
                valueC: 'C'
            });
            template(parent);
            QUnit.deepEqual(parent.get(), {
                valueA: 'A',
                valueB: 'toParent',
                valueC: 'C'
            }, 'initial scope values correct');
            QUnit.deepEqual(viewModel.get(), {
                toChild: 'A',
                toParent: 'toParent',
                twoWay: 'C'
            }, 'initial VM values correct');
            parent.set({
                valueA: 'a',
                valueB: 'b',
                valueC: 'c'
            });
            QUnit.deepEqual(viewModel.get(), {
                toChild: 'a',
                toParent: 'toParent',
                twoWay: 'c'
            }, 'scope set VM values correct');
            viewModel.set({
                toChild: 'to-child',
                toParent: 'to-parent',
                twoWay: 'two-way'
            });
            QUnit.deepEqual(parent.get(), {
                valueA: 'a',
                valueB: 'to-parent',
                valueC: 'two-way'
            }, 'vm set scope values correct');
            viewModel.dispatch({ type: 'vmevent' });
        });
        test('getBindingInfo', function () {
            var info = stacheBindings.getBindingInfo({
                name: 'foo-ed:from',
                value: 'bar'
            });
            deepEqual(info, {
                parent: 'scope',
                child: 'viewModelOrAttribute',
                childEvent: undefined,
                parentToChild: true,
                childToParent: false,
                childName: 'foo-ed',
                parentName: 'bar',
                bindingAttributeName: 'foo-ed:from',
                initializeValues: true,
                syncChildWithParent: false
            }, ':from');
            info = stacheBindings.getBindingInfo({
                name: 'foo-ed:bind',
                value: 'bar'
            });
            deepEqual(info, {
                parent: 'scope',
                child: 'viewModelOrAttribute',
                childEvent: undefined,
                parentToChild: true,
                childToParent: true,
                childName: 'foo-ed',
                parentName: 'bar',
                bindingAttributeName: 'foo-ed:bind',
                initializeValues: true,
                syncChildWithParent: true
            }, ':bind');
            info = stacheBindings.getBindingInfo({
                name: 'foo-ed:to',
                value: 'bar'
            });
            deepEqual(info, {
                parent: 'scope',
                child: 'viewModelOrAttribute',
                childEvent: undefined,
                parentToChild: false,
                childToParent: true,
                childName: 'foo-ed',
                parentName: 'bar',
                bindingAttributeName: 'foo-ed:to',
                initializeValues: true,
                syncChildWithParent: false
            }, ':to');
            info = stacheBindings.getBindingInfo({
                name: 'foo-ed:from',
                value: 'bar'
            }, null, null, null, true);
            deepEqual(info, {
                parent: 'scope',
                child: 'viewModel',
                childEvent: undefined,
                parentToChild: true,
                childToParent: false,
                childName: 'foo-ed',
                parentName: 'bar',
                bindingAttributeName: 'foo-ed:from',
                initializeValues: true,
                syncChildWithParent: false
            }, ':from, favorViewModel=true');
            info = stacheBindings.getBindingInfo({
                name: 'foo-ed:bind',
                value: 'bar'
            }, null, null, null, true);
            deepEqual(info, {
                parent: 'scope',
                child: 'viewModel',
                childEvent: undefined,
                parentToChild: true,
                childToParent: true,
                childName: 'foo-ed',
                parentName: 'bar',
                bindingAttributeName: 'foo-ed:bind',
                initializeValues: true,
                syncChildWithParent: true
            }, ':bind, favorViewModel=true');
            info = stacheBindings.getBindingInfo({
                name: 'foo-ed:to',
                value: 'bar'
            }, null, null, null, true);
            deepEqual(info, {
                parent: 'scope',
                child: 'viewModel',
                childEvent: undefined,
                parentToChild: false,
                childToParent: true,
                childName: 'foo-ed',
                parentName: 'bar',
                bindingAttributeName: 'foo-ed:to',
                initializeValues: true,
                syncChildWithParent: false
            }, ':to, favorViewModel=true');
        });
        test('getBindingInfo for vm:', function () {
            var info = stacheBindings.getBindingInfo({
                name: 'vm:foo-ed:from',
                value: 'bar'
            });
            deepEqual(info, {
                parent: 'scope',
                child: 'viewModel',
                childEvent: undefined,
                parentToChild: true,
                childToParent: false,
                childName: 'foo-ed',
                parentName: 'bar',
                bindingAttributeName: 'vm:foo-ed:from',
                initializeValues: true,
                syncChildWithParent: false
            }, ':from');
            info = stacheBindings.getBindingInfo({
                name: 'vm:foo-ed:bind',
                value: 'bar'
            });
            deepEqual(info, {
                parent: 'scope',
                child: 'viewModel',
                childEvent: undefined,
                parentToChild: true,
                childToParent: true,
                childName: 'foo-ed',
                parentName: 'bar',
                bindingAttributeName: 'vm:foo-ed:bind',
                initializeValues: true,
                syncChildWithParent: true
            }, ':bind');
            info = stacheBindings.getBindingInfo({
                name: 'vm:foo-ed:to',
                value: 'bar'
            });
            deepEqual(info, {
                parent: 'scope',
                child: 'viewModel',
                childEvent: undefined,
                parentToChild: false,
                childToParent: true,
                childName: 'foo-ed',
                parentName: 'bar',
                bindingAttributeName: 'vm:foo-ed:to',
                initializeValues: true,
                syncChildWithParent: false
            }, ':to');
            info = stacheBindings.getBindingInfo({
                name: 'vm:foo-ed:from',
                value: 'bar'
            }, null, null, null, true);
            deepEqual(info, {
                parent: 'scope',
                child: 'viewModel',
                childEvent: undefined,
                parentToChild: true,
                childToParent: false,
                childName: 'foo-ed',
                parentName: 'bar',
                bindingAttributeName: 'vm:foo-ed:from',
                initializeValues: true,
                syncChildWithParent: false
            }, ':from, favorViewModel=true');
            info = stacheBindings.getBindingInfo({
                name: 'vm:foo-ed:bind',
                value: 'bar'
            }, null, null, null, true);
            deepEqual(info, {
                parent: 'scope',
                child: 'viewModel',
                childEvent: undefined,
                parentToChild: true,
                childToParent: true,
                childName: 'foo-ed',
                parentName: 'bar',
                bindingAttributeName: 'vm:foo-ed:bind',
                initializeValues: true,
                syncChildWithParent: true
            }, ':bind, favorViewModel=true');
            info = stacheBindings.getBindingInfo({
                name: 'vm:foo-ed:to',
                value: 'bar'
            }, null, null, null, true);
            deepEqual(info, {
                parent: 'scope',
                child: 'viewModel',
                childEvent: undefined,
                parentToChild: false,
                childToParent: true,
                childName: 'foo-ed',
                parentName: 'bar',
                bindingAttributeName: 'vm:foo-ed:to',
                initializeValues: true,
                syncChildWithParent: false
            }, ':to, favorViewModel=true');
        });
        test('getBindingInfo for el:', function () {
            var info = stacheBindings.getBindingInfo({
                name: 'el:foo-ed:from',
                value: 'bar'
            });
            deepEqual(info, {
                parent: 'scope',
                child: 'attribute',
                childEvent: undefined,
                parentToChild: true,
                childToParent: false,
                childName: 'foo-ed',
                parentName: 'bar',
                bindingAttributeName: 'el:foo-ed:from',
                initializeValues: true,
                syncChildWithParent: false
            }, ':from');
            info = stacheBindings.getBindingInfo({
                name: 'el:foo-ed:bind',
                value: 'bar'
            });
            deepEqual(info, {
                parent: 'scope',
                child: 'attribute',
                childEvent: undefined,
                parentToChild: true,
                childToParent: true,
                childName: 'foo-ed',
                parentName: 'bar',
                bindingAttributeName: 'el:foo-ed:bind',
                initializeValues: true,
                syncChildWithParent: true
            }, ':bind');
            info = stacheBindings.getBindingInfo({
                name: 'el:foo-ed:to',
                value: 'bar'
            });
            deepEqual(info, {
                parent: 'scope',
                child: 'attribute',
                childEvent: undefined,
                parentToChild: false,
                childToParent: true,
                childName: 'foo-ed',
                parentName: 'bar',
                bindingAttributeName: 'el:foo-ed:to',
                initializeValues: true,
                syncChildWithParent: false
            }, ':to');
            info = stacheBindings.getBindingInfo({
                name: 'el:foo-ed:from',
                value: 'bar'
            }, null, null, null, true);
            deepEqual(info, {
                parent: 'scope',
                child: 'attribute',
                childEvent: undefined,
                parentToChild: true,
                childToParent: false,
                childName: 'foo-ed',
                parentName: 'bar',
                bindingAttributeName: 'el:foo-ed:from',
                initializeValues: true,
                syncChildWithParent: false
            }, ':from, favorViewModel=true');
            info = stacheBindings.getBindingInfo({
                name: 'el:foo-ed:bind',
                value: 'bar'
            }, null, null, null, true);
            deepEqual(info, {
                parent: 'scope',
                child: 'attribute',
                childEvent: undefined,
                parentToChild: true,
                childToParent: true,
                childName: 'foo-ed',
                parentName: 'bar',
                bindingAttributeName: 'el:foo-ed:bind',
                initializeValues: true,
                syncChildWithParent: true
            }, ':bind, favorViewModel=true');
            info = stacheBindings.getBindingInfo({
                name: 'el:foo-ed:to',
                value: 'bar'
            }, null, null, null, true);
            deepEqual(info, {
                parent: 'scope',
                child: 'attribute',
                childEvent: undefined,
                parentToChild: false,
                childToParent: true,
                childName: 'foo-ed',
                parentName: 'bar',
                bindingAttributeName: 'el:foo-ed:to',
                initializeValues: true,
                syncChildWithParent: false
            }, ':to, favorViewModel=true');
        });
        QUnit.test('getBindingInfo works for value:to:on:click (#269)', function () {
            var info = stacheBindings.getBindingInfo({
                name: 'value:to:on:click',
                value: 'bar'
            });
            deepEqual(info, {
                parent: 'scope',
                child: 'viewModelOrAttribute',
                childEvent: 'click',
                parentToChild: false,
                childToParent: true,
                childName: 'value',
                parentName: 'bar',
                bindingAttributeName: 'value:to:on:click',
                initializeValues: false,
                syncChildWithParent: false
            }, 'new vm binding');
        });
        if (System.env.indexOf('production') < 0) {
            test('warning when binding to non-existing value (#136) (#119)', function () {
                var oldWarn = dev.warn;
                dev.warn = function (message) {
                    ok(true, message);
                };
                var template = stache('<div target:vm:bind=\'source.bar\'/>');
                expect(1);
                var map = new SimpleMap({ source: new SimpleMap({ foo: 'foo' }) });
                template(map);
                dev.warn = oldWarn;
            });
        }
    });
});
/*can-stache-bindings@4.0.0-pre.8#test/colon/element-test*/
define('can-stache-bindings@4.0.0-pre.8#test/colon/element-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    '../helpers',
    'can-stache-bindings',
    'can-stache',
    'can-simple-map',
    'can-define/list/list',
    'can-simple-observable',
    'can-symbol',
    'can-reflect',
    'can-util/dom/mutate/mutate',
    'can-util/dom/events/events',
    'can-util/js/each/each',
    'can-define/map/map'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var testHelpers = require('../helpers');
    require('can-stache-bindings');
    var stache = require('can-stache');
    var SimpleMap = require('can-simple-map');
    var DefineList = require('can-define/list/list');
    var SimpleObservable = require('can-simple-observable');
    var canSymbol = require('can-symbol');
    var canReflect = require('can-reflect');
    var domMutate = require('can-util/dom/mutate/mutate');
    var domEvents = require('can-util/dom/events/events');
    var canEach = require('can-util/js/each/each');
    var DefineMap = require('can-define/map/map');
    testHelpers.makeTests('can-stache-bindings - colon - element', function (name, doc, enableMO, testIfRealDocument) {
        QUnit.test('<input text> value:bind input text', function () {
            var template = stache('<input value:bind=\'age\'/>');
            var map = new SimpleMap();
            var frag = template(map);
            var ta = this.fixture;
            ta.appendChild(frag);
            var input = ta.getElementsByTagName('input')[0];
            equal(input.value, '', 'input value set correctly if key does not exist in map');
            map.set('age', '30');
            equal(input.value, '30', 'input value set correctly');
            map.set('age', '31');
            equal(input.value, '31', 'input value update correctly');
            input.value = '32';
            domEvents.dispatch.call(input, 'change');
            equal(map.get('age'), '32', 'updated from input');
        });
        QUnit.test('<input text> el:prop:to/:from/:bind work (#280)', function () {
            var template = stache('<input el:value:to=\'scope1\' value=\'1\'/>' + '<input el:value:from=\'scope2\' value=\'2\'/>' + '<input el:value:bind=\'scope3\' value=\'3\'/>');
            var scope = new SimpleMap({
                scope1: 'scope1',
                scope2: 'scope2',
                scope3: 'scope3'
            });
            var frag = template(scope);
            var ta = this.fixture;
            ta.appendChild(frag);
            var inputTo = ta.getElementsByTagName('input')[0];
            var inputFrom = ta.getElementsByTagName('input')[1];
            var inputBind = ta.getElementsByTagName('input')[2];
            equal(scope.attr('scope1'), '1', 'el:value:to - scope value set from attribute');
            inputTo.value = '4';
            domEvents.dispatch.call(inputTo, 'change');
            equal(scope.attr('scope1'), '4', 'el:value:to - scope updated when attribute changed');
            scope.attr('scope1', 'scope4');
            equal(inputTo.value, '4', 'el:value:to - attribute not updated when scope changed');
            equal(inputFrom.value, 'scope2', 'el:value:from - attribute set from scope');
            inputFrom.value = 'scope5';
            domEvents.dispatch.call(inputFrom, 'change');
            equal(scope.attr('scope2'), 'scope2', 'el:value:from - scope not updated when attribute changed');
            scope.attr('scope2', 'scope6');
            equal(inputFrom.value, 'scope6', 'el:value:from - attribute updated when scope changed');
            equal(inputBind.value, 'scope3', 'el:value:bind - attribute set from scope prop (parent -> child wins)');
            inputBind.value = 'scope6';
            domEvents.dispatch.call(inputBind, 'change');
            equal(scope.attr('scope3'), 'scope6', 'el:value:bind - scope updated when attribute changed');
            scope.attr('scope3', 'scope7');
            equal(inputBind.value, 'scope7', 'el:value:bind - attribute updated when scope changed');
        });
        if (System.env !== 'canjs-test') {
            test('<input text> dynamic attribute bindings (#2016)', function (assert) {
                var done = assert.async();
                var template = stache('<input value:bind=\'{{propName}}\'/>');
                var map = new SimpleMap({
                    propName: 'first',
                    first: 'Justin',
                    last: 'Meyer'
                });
                var frag = template(map);
                var ta = this.fixture;
                ta.appendChild(frag);
                var input = ta.getElementsByTagName('input')[0];
                testHelpers.afterMutation(function () {
                    equal(input.value, 'Justin', 'input value set correctly if key does not exist in map');
                    map.set('propName', 'last');
                    testHelpers.afterMutation(function () {
                        equal(input.value, 'Meyer', 'input value set correctly if key does not exist in map');
                        input.value = 'Lueke';
                        domEvents.dispatch.call(input, 'change');
                        testHelpers.afterMutation(function () {
                            equal(map.get('last'), 'Lueke', 'updated from input');
                            done();
                        });
                    });
                });
            });
        }
        test('value:bind compute rejects new value (#887)', function () {
            var template = stache('<input value:bind=\'age\'/>');
            var compute = new SimpleObservable(30);
            canReflect.assignSymbols(compute, {
                'can.setValue': function (newVal) {
                    if (isNaN(+newVal)) {
                    } else {
                        this.set(+newVal);
                    }
                }
            });
            var frag = template({ age: compute });
            var ta = this.fixture;
            ta.appendChild(frag);
            var input = ta.getElementsByTagName('input')[0];
            input.value = '30f';
            domEvents.dispatch.call(input, 'change');
            equal(compute.get(), 30, 'Still the old value');
            equal(input.value, '30', 'Text input has also not changed');
        });
        test('value:from works with camelCase and kebab-case properties', function () {
            var template = stache('<input value:from=\'theProp\'/>' + '<input value:from=\'the-prop\'/>');
            var map = new SimpleMap({});
            var frag = template(map);
            var ta = this.fixture;
            ta.appendChild(frag);
            var camelPropInput = ta.getElementsByTagName('input')[0];
            var kebabPropInput = ta.getElementsByTagName('input')[1];
            equal(camelPropInput.value, '', 'input bound to camelCase prop value set correctly if camelCase key does not exist in map');
            equal(kebabPropInput.value, '', 'input bound to kebab-case prop value set correctly if kebab-case key does not exist in map');
            map.attr('theProp', '30');
            equal(camelPropInput.value, '30', 'input bound to camelCase prop value set correctly when camelCase prop changes');
            equal(kebabPropInput.value, '', 'input bound to kebab-case prop value not updated when camelCase prop changes');
            map.attr('theProp', '31');
            equal(camelPropInput.value, '31', 'input bound to camelCase prop value updated correctly when camelCase prop changes');
            ok(!kebabPropInput.value, 'input bound to kebab-case prop value not updated when camelCase prop changes');
            camelPropInput.value = '32';
            domEvents.dispatch.call(camelPropInput, 'change');
            equal(map.attr('theProp'), '31', 'camelCase prop NOT updated when input bound to camelCase prop changes');
            ok(!map.attr('the-prop'), 'kebabCase prop NOT updated when input bound to camelCase prop changes');
            map.attr('the-prop', '33');
            equal(kebabPropInput.value, '33', 'input bound to kebab-case prop value set correctly when kebab-case prop changes');
            equal(camelPropInput.value, '32', 'input bound to camelCase prop value not updated when kebab-case prop changes');
            map.attr('the-prop', '34');
            equal(kebabPropInput.value, '34', 'input bound to kebab-case prop value updated correctly when kebab-case prop changes');
            equal(camelPropInput.value, '32', 'input bound to camelCase prop value not updated when kebab-case prop changes');
            kebabPropInput.value = '35';
            domEvents.dispatch.call(kebabPropInput, 'change');
            equal(map.attr('the-prop'), '34', 'kebab-case prop NOT updated from input bound to kebab-case prop');
            equal(map.attr('theProp'), '31', 'camelCase prop NOT updated from input bound to kebab-case prop');
        });
        test('value:to works with camelCase and kebab-case properties', function () {
            var template = stache('<input value:to=\'theProp\'/>' + '<input value:to=\'the-prop\'/>');
            var map = new SimpleMap({});
            var frag = template(map);
            var ta = this.fixture;
            ta.appendChild(frag);
            var camelPropInput = ta.getElementsByTagName('input')[0];
            var kebabPropInput = ta.getElementsByTagName('input')[1];
            camelPropInput.value = '32';
            domEvents.dispatch.call(camelPropInput, 'change');
            equal(map.attr('theProp'), '32', 'camelCaseProp updated from input bound to camelCase Prop');
            ok(!map.attr('the-prop'), 'kebabCaseProp NOT updated from input bound to camelCase Prop');
            map.attr('theProp', '30');
            equal(camelPropInput.value, '32', 'input bound to camelCase Prop value NOT updated when camelCase prop changes');
            ok(!kebabPropInput.value, 'input bound to kebabCase Prop value NOT updated when camelCase prop changes');
            kebabPropInput.value = '33';
            domEvents.dispatch.call(kebabPropInput, 'change');
            equal(map.attr('the-prop'), '33', 'kebabCaseProp updated from input bound to kebabCase Prop');
            equal(map.attr('theProp'), '30', 'camelCaseProp NOT updated from input bound to camelCase Prop');
            map.attr('theProp', '34');
            equal(kebabPropInput.value, '33', 'input bound to kebabCase Prop value NOT updated when kebabCase prop changes');
            equal(camelPropInput.value, '32', 'input bound to camelCase Prop value NOT updated when kebabCase prop changes');
        });
        test('value:bind works with camelCase and kebab-case properties', function () {
            var template = stache('<input value:bind=\'theProp\'/>' + '<input value:bind=\'the-prop\'/>');
            var map = new SimpleMap({});
            var frag = template(map);
            var ta = this.fixture;
            ta.appendChild(frag);
            var camelPropInput = ta.getElementsByTagName('input')[0];
            var kebabPropInput = ta.getElementsByTagName('input')[1];
            camelPropInput.value = '32';
            domEvents.dispatch.call(camelPropInput, 'change');
            equal(map.attr('theProp'), '32', 'camelCaseProp updated from input bound to camelCase Prop');
            ok(!map.attr('the-prop'), 'kebabCaseProp NOT updated from input bound to camelCase Prop');
            map.attr('theProp', '30');
            equal(camelPropInput.value, '30', 'input bound to camelCase Prop value updated when camelCase prop changes');
            ok(!kebabPropInput.value, 'input bound to kebabCase Prop value NOT updated when camelCase prop changes');
            kebabPropInput.value = '33';
            domEvents.dispatch.call(kebabPropInput, 'change');
            equal(map.attr('the-prop'), '33', 'kebabCaseProp updated from input bound to kebabCase Prop');
            equal(map.attr('theProp'), '30', 'camelCaseProp NOT updated from input bound to camelCase Prop');
            map.attr('theProp', '34');
            equal(kebabPropInput.value, '33', 'input bound to kebabCase Prop value NOT updated when kebabCase prop changes');
            equal(camelPropInput.value, '34', 'input bound to camelCase Prop value updated when kebabCase prop changes');
        });
        test('Bracket expression with dot and no explicit root and value:bind', function () {
            var template;
            var div = this.fixture;
            template = stache('<input value:bind="[\'two.hops\']" >');
            var data = new SimpleMap();
            var dom = template(data);
            div.appendChild(dom);
            var input = div.getElementsByTagName('input')[0];
            equal(input.value, '', 'input value set correctly if key does not exist in map');
            data.set('two.hops', 'slide to the left');
            equal(input.value, 'slide to the left', 'input value set correctly');
            data.set('two.hops', 'slide to the right');
            equal(input.value, 'slide to the right', 'input value update correctly');
            input.value = 'REVERSE REVERSE';
            domEvents.dispatch.call(input, 'change');
            equal(data.get('two.hops'), 'REVERSE REVERSE', 'updated from input');
        });
        test('Bracket expression with colon and no explicit root and value:bind', function () {
            var template;
            var div = this.fixture;
            template = stache('<input value:bind="[\'two:hops\']" >');
            var data = new SimpleMap();
            var dom = template(data);
            div.appendChild(dom);
            var input = div.getElementsByTagName('input')[0];
            equal(input.value, '', 'input value set correctly if key does not exist in map');
            data.set('two:hops', 'slide to the left');
            equal(input.value, 'slide to the left', 'input value set correctly');
            data.set('two:hops', 'slide to the right');
            equal(input.value, 'slide to the right', 'input value update correctly');
            input.value = 'REVERSE REVERSE';
            domEvents.dispatch.call(input, 'change');
            equal(data.get('two:hops'), 'REVERSE REVERSE', 'updated from input');
        });
        QUnit.test('el:prop:to/:from/:bind work (#280)', function () {
            var template = stache('<input el:value:to=\'scope1\' value=\'1\'/>' + '<input el:value:from=\'scope2\' value=\'2\'/>' + '<input el:value:bind=\'scope3\' value=\'3\'/>');
            var scope = new SimpleMap({
                scope1: 'scope1',
                scope2: 'scope2',
                scope3: 'scope3'
            });
            var frag = template(scope);
            var ta = this.fixture;
            ta.appendChild(frag);
            var inputTo = ta.getElementsByTagName('input')[0];
            var inputFrom = ta.getElementsByTagName('input')[1];
            var inputBind = ta.getElementsByTagName('input')[2];
            equal(scope.attr('scope1'), '1', 'el:value:to - scope value set from attribute');
            inputTo.value = '4';
            domEvents.dispatch.call(inputTo, 'change');
            equal(scope.attr('scope1'), '4', 'el:value:to - scope updated when attribute changed');
            scope.attr('scope1', 'scope4');
            equal(inputTo.value, '4', 'el:value:to - attribute not updated when scope changed');
            equal(inputFrom.value, 'scope2', 'el:value:from - attribute set from scope');
            inputFrom.value = 'scope5';
            domEvents.dispatch.call(inputFrom, 'change');
            equal(scope.attr('scope2'), 'scope2', 'el:value:from - scope not updated when attribute changed');
            scope.attr('scope2', 'scope6');
            equal(inputFrom.value, 'scope6', 'el:value:from - attribute updated when scope changed');
            equal(inputBind.value, 'scope3', 'el:value:bind - attribute set from scope prop (parent -> child wins)');
            inputBind.value = 'scope6';
            domEvents.dispatch.call(inputBind, 'change');
            equal(scope.attr('scope3'), 'scope6', 'el:value:bind - scope updated when attribute changed');
            scope.attr('scope3', 'scope7');
            equal(inputBind.value, 'scope7', 'el:value:bind - attribute updated when scope changed');
        });
        test('<input text> two-way - DOM - input text (#1700)', function () {
            var template = stache('<input value:bind=\'age\'/>');
            var map = new SimpleMap();
            var frag = template(map);
            var ta = this.fixture;
            ta.appendChild(frag);
            var input = ta.getElementsByTagName('input')[0];
            equal(input.value, '', 'input value set correctly if key does not exist in map');
            map.attr('age', '30');
            stop();
            testHelpers.afterMutation(function () {
                start();
                equal(input.value, '30', 'input value set correctly');
                map.attr('age', '31');
                stop();
                testHelpers.afterMutation(function () {
                    start();
                    equal(input.value, '31', 'input value update correctly');
                    input.value = '32';
                    domEvents.dispatch.call(input, 'change');
                    stop();
                    testHelpers.afterMutation(function () {
                        start();
                        equal(map.attr('age'), '32', 'updated from input');
                    });
                });
            });
        });
        QUnit.test('errors subproperties of undefined properties (#298)', function () {
            try {
                stache('<input value:to=\'prop.subprop\'/>')();
                ok(true, 'renderer was made without error');
            } catch (e) {
                ok(false, e.message);
            }
        });
        test('updates happen on two-way even when one binding is satisfied', function () {
            var template = stache('<input value:bind="firstName"/>');
            var viewModel = new SimpleMap({ firstName: 'jeffrey' });
            canReflect.assignSymbols(viewModel, {
                'can.setKeyValue': function (key, val) {
                    if (val) {
                        this.set(key, val.toLowerCase());
                    }
                }
            });
            stop();
            var frag = template(viewModel);
            domMutate.appendChild.call(this.fixture, frag);
            equal(this.fixture.firstChild.value, 'jeffrey');
            this.fixture.firstChild.value = 'JEFFREY';
            domEvents.dispatch.call(this.fixture.firstChild, 'change');
            equal(this.fixture.firstChild.value, 'jeffrey');
            testHelpers.afterMutation(start);
        });
        QUnit.test('updates happen on changed two-way even when one binding is satisfied', function () {
            stop();
            var template = stache('<input value:bind="{{bindValue}}"/>');
            var ViewModel = DefineMap.extend({
                firstName: {
                    set: function (newValue) {
                        if (newValue) {
                            return newValue.toLowerCase();
                        }
                    }
                },
                lastName: {
                    set: function (newValue) {
                        if (newValue) {
                            return newValue.toLowerCase();
                        }
                    }
                },
                bindValue: 'string'
            });
            var viewModel = new ViewModel({
                firstName: 'Jeffrey',
                lastName: 'King',
                bindValue: 'firstName'
            });
            var frag = template(viewModel);
            domMutate.appendChild.call(this.fixture, frag);
            testHelpers.afterMutation(function () {
                equal(this.fixture.firstChild.value, 'jeffrey');
                viewModel.bindValue = 'lastName';
                testHelpers.afterMutation(function () {
                    equal(this.fixture.firstChild.value, 'king');
                    this.fixture.firstChild.value = 'KING';
                    domEvents.dispatch.call(this.fixture.firstChild, 'change');
                    equal(this.fixture.firstChild.value, 'king');
                    start();
                }.bind(this));
            }.bind(this));
        });
        test('value:bind memory leak (#2270)', function () {
            var template = stache('<div><input value:bind="foo"></div>');
            var vm = new SimpleMap({ foo: '' });
            var frag = template(vm);
            var ta = this.fixture;
            domMutate.appendChild.call(ta, frag);
            QUnit.stop();
            testHelpers.afterMutation(function () {
                domMutate.removeChild.call(ta, ta.firstChild);
                testHelpers.afterMutation(function () {
                    var checkLifecycleBindings = function () {
                        var meta = vm[canSymbol.for('can.meta')];
                        if (meta.handlers.get([]).length === 0) {
                            QUnit.ok(true, 'no bindings');
                            start();
                        } else {
                            setTimeout(checkLifecycleBindings, 1000);
                        }
                    };
                    checkLifecycleBindings();
                });
            });
        });
        test('converters work (#2299)', function () {
            stache.registerConverter('numberToString', {
                get: function (source) {
                    return source() + '';
                },
                set: function (newVal, source) {
                    source(newVal === '' ? null : +newVal);
                }
            });
            var template = stache('<input value:bind="numberToString(~age)">');
            var map = new SimpleMap({ age: 25 });
            var frag = template(map);
            equal(frag.firstChild.value, '25');
            equal(map.get('age'), 25);
            map.set('age', 33);
            equal(frag.firstChild.value, '33');
            equal(map.get('age'), 33);
            frag.firstChild.value = '1';
            domEvents.dispatch.call(frag.firstChild, 'change');
            stop();
            testHelpers.afterMutation(function () {
                start();
                equal(frag.firstChild.value, '1');
                equal(map.get('age'), 1);
            });
        });
        testIfRealDocument('<input radio> checked:bind should trigger a radiochange event for radio buttons', function () {
            var template = stache([
                '<input type="radio" name="baz" checked:bind="foo"/><span>{{foo}}</span>',
                '<input type="radio" name="baz" checked:bind="bar"/><span>{{bar}}</span>'
            ].join(''));
            var data = new SimpleMap({
                foo: false,
                bar: false
            });
            var fragment = template(data);
            domMutate.appendChild.call(this.fixture, fragment);
            var self = this;
            function child(index) {
                return self.fixture.childNodes.item(index);
            }
            var fooRadio = child(0);
            var fooText = child(1);
            var barRadio = child(2);
            var barText = child(3);
            function text(node) {
                while (node && node.nodeType !== 3) {
                    node = node.firstChild;
                }
                return node && node.nodeValue;
            }
            fooRadio.checked = true;
            domEvents.dispatch.call(fooRadio, 'change');
            barRadio.checked = true;
            domEvents.dispatch.call(barRadio, 'change');
            equal(text(fooText), 'false', 'foo text is false');
            equal(text(barText), 'true', 'bar text is true');
            equal(data.get('foo'), false);
            equal(data.get('bar'), true);
        });
        QUnit.test('<input radio> change event handler set up when binding on radiochange (#206)', function () {
            var template = stache('<input type="radio" checked:bind="attending" />');
            var map = new SimpleMap({ attending: false });
            var frag = template(map);
            var input = frag.firstChild;
            input.checked = true;
            domEvents.dispatch.call(input, 'change');
            QUnit.equal(map.get('attending'), true, 'now it is true');
        });
        test('<input checkbox> one-way - DOM - with undefined (#135)', function () {
            var data = new SimpleMap({ completed: undefined }), frag = stache('<input type="checkbox" el:checked:from="completed"/>')(data);
            domMutate.appendChild.call(this.fixture, frag);
            var input = this.fixture.getElementsByTagName('input')[0];
            equal(input.checked, false, 'checkbox value should be false for undefined');
        });
        test('<input checkbox> two-way - DOM - with truthy and falsy values binds to checkbox (#1700)', function () {
            var data = new SimpleMap({ completed: 1 }), frag = stache('<input type="checkbox" el:checked:bind="completed"/>')(data);
            domMutate.appendChild.call(this.fixture, frag);
            var input = this.fixture.getElementsByTagName('input')[0];
            equal(input.checked, true, 'checkbox value bound (via attr check)');
            data.attr('completed', 0);
            stop();
            testHelpers.afterMutation(function () {
                start();
                equal(input.checked, false, 'checkbox value bound (via attr check)');
            });
        });
        test('<input checkbox> checkboxes with checked:bind bind properly (#628)', function () {
            var data = new SimpleMap({ completed: true }), frag = stache('<input type="checkbox" checked:bind="completed"/>')(data);
            domMutate.appendChild.call(this.fixture, frag);
            var input = this.fixture.getElementsByTagName('input')[0];
            equal(input.checked, data.get('completed'), 'checkbox value bound (via attr check)');
            data.attr('completed', false);
            equal(input.checked, data.get('completed'), 'checkbox value bound (via attr uncheck)');
            input.checked = true;
            domEvents.dispatch.call(input, 'change');
            equal(input.checked, true, 'checkbox value bound (via check)');
            equal(data.get('completed'), true, 'checkbox value bound (via check)');
            input.checked = false;
            domEvents.dispatch.call(input, 'change');
            equal(input.checked, false, 'checkbox value bound (via uncheck)');
            equal(data.get('completed'), false, 'checkbox value bound (via uncheck)');
        });
        testIfRealDocument('<select> keeps its value as <option>s change with {{#each}} (#1762)', function () {
            var template = stache('<select value:bind=\'id\'>{{#each values}}<option value=\'{{this}}\'>{{this}}</option>{{/each}}</select>');
            var values = new SimpleObservable([
                '1',
                '2',
                '3',
                '4'
            ]);
            var id = new SimpleObservable('2');
            var frag = template({
                values: values,
                id: id
            });
            stop();
            var select = frag.firstChild;
            var options = select.getElementsByTagName('option');
            testHelpers.afterMutation(function () {
                ok(options[1].selected, 'value is initially selected');
                values.set([
                    '7',
                    '2',
                    '5',
                    '4'
                ]);
                testHelpers.afterMutation(function () {
                    ok(options[1].selected, 'after changing options, value should still be selected');
                    start();
                });
            });
        });
        testIfRealDocument('<select> with undefined value selects option without value', function () {
            var template = stache('<select value:bind=\'opt\'><option>Loading...</option></select>');
            var map = new SimpleMap();
            var frag = template(map);
            var ta = this.fixture;
            ta.appendChild(frag);
            var select = ta.childNodes.item(0);
            QUnit.equal(select.selectedIndex, 0, 'Got selected index');
        });
        testIfRealDocument('<select> two-way bound values that do not match a select option set selectedIndex to -1 (#2027)', function () {
            var renderer = stache('<select el:value:bind="key"><option value="foo">foo</option><option value="bar">bar</option></select>');
            var map = new SimpleMap({});
            var frag = renderer(map);
            equal(frag.firstChild.selectedIndex, 0, 'undefined <- {($first value)}: selectedIndex = 0');
            map.attr('key', 'notfoo');
            stop();
            testHelpers.afterMutation(function () {
                start();
                equal(frag.firstChild.selectedIndex, -1, 'notfoo: selectedIndex = -1');
                map.attr('key', 'foo');
                strictEqual(frag.firstChild.selectedIndex, 0, 'foo: selectedIndex = 0');
                map.attr('key', 'notbar');
                stop();
                testHelpers.afterMutation(function () {
                    start();
                    equal(frag.firstChild.selectedIndex, -1, 'notbar: selectedIndex = -1');
                    map.attr('key', 'bar');
                    strictEqual(frag.firstChild.selectedIndex, 1, 'bar: selectedIndex = 1');
                    map.attr('key', 'bar');
                    strictEqual(frag.firstChild.selectedIndex, 1, 'bar (no change): selectedIndex = 1');
                });
            });
        });
        test('<select multiple> Multi-select empty string works(#1263)', function () {
            var data = new SimpleMap({
                isMultiple: 1,
                isSelect: 1,
                name: 'attribute_ 0',
                options: new DefineList([
                    {
                        label: 'empty',
                        value: ''
                    },
                    {
                        label: 'zero',
                        value: 0
                    },
                    {
                        label: 'one',
                        value: 1
                    },
                    {
                        label: 'two',
                        value: 2
                    },
                    {
                        label: 'three',
                        value: 3
                    },
                    {
                        label: 'four',
                        value: 4
                    }
                ]),
                value: new DefineList(['1'])
            });
            var template = stache('<select {{#if isMultiple}}multiple{{/if}} values:bind=\'value\'> ' + '{{#each options}} <option value=\'{{value}}\' >{{label}}</option>{{/each}} </select>');
            var frag = template(data);
            equal(frag.firstChild.getElementsByTagName('option')[0].selected, false, 'The first empty value is not selected');
            equal(frag.firstChild.getElementsByTagName('option')[2].selected, true, 'One is selected');
        });
        testIfRealDocument('<select multiple> applies initial value, when options rendered from array (#1414)', function () {
            var template = stache('<select values:bind=\'colors\' multiple>' + '{{#each allColors}}<option value=\'{{value}}\'>{{label}}</option>{{/each}}' + '</select>');
            var map = new SimpleMap({
                colors: new DefineList([
                    'red',
                    'green'
                ]),
                allColors: new DefineList([
                    {
                        value: 'red',
                        label: 'Red'
                    },
                    {
                        value: 'green',
                        label: 'Green'
                    },
                    {
                        value: 'blue',
                        label: 'Blue'
                    }
                ])
            });
            stop();
            var frag = template(map);
            var ta = this.fixture;
            ta.appendChild(frag);
            var select = ta.getElementsByTagName('select')[0], options = select.getElementsByTagName('option');
            testHelpers.afterMutation(function () {
                ok(options[0].selected, 'red should be set initially');
                ok(options[1].selected, 'green should be set initially');
                ok(!options[2].selected, 'blue should not be set initially');
                start();
            });
        });
        test('<select> one-way bindings keep value if options are replaced - each (#1762)', function () {
            var countries = [
                {
                    code: 'MX',
                    countryName: 'MEXICO'
                },
                {
                    code: 'US',
                    countryName: 'USA'
                }
            ];
            var data = new SimpleMap({
                countryCode: 'US',
                countries: new DefineList(countries)
            });
            var template = stache('<select el:value:from="countryCode">' + '{{#each countries}}' + '<option value="{{code}}">{{countryName}}</option>' + '{{/each}}' + '</select>');
            var frag = template(data);
            var select = frag.firstChild;
            stop();
            testHelpers.afterMutation(function () {
                data.get('countries').replace([]);
                testHelpers.afterMutation(function () {
                    data.attr('countries').replace(countries);
                    equal(data.attr('countryCode'), 'US', 'country kept as USA');
                    testHelpers.afterMutation(function () {
                        ok(select.getElementsByTagName('option')[1].selected, 'USA still selected');
                    });
                    start();
                });
            });
        });
        testIfRealDocument('<select> value:bind select single', function () {
            var template = stache('<select value:bind=\'color\'>' + '<option value=\'red\'>Red</option>' + '<option value=\'green\'>Green</option>' + '</select>');
            var map = new SimpleMap({ color: 'red' });
            var frag = template(map);
            var ta = this.fixture;
            ta.appendChild(frag);
            var inputs = ta.getElementsByTagName('select');
            equal(inputs[0].value, 'red', 'default value set');
            map.set('color', 'green');
            equal(inputs[0].value, 'green', 'alternate value set');
            canEach(ta.getElementsByTagName('option'), function (opt) {
                if (opt.value === 'red') {
                    opt.selected = 'selected';
                }
            });
            equal(map.get('color'), 'green', 'not yet updated from input');
            domEvents.dispatch.call(inputs[0], 'change');
            equal(map.get('color'), 'red', 'updated from input');
            canEach(ta.getElementsByTagName('option'), function (opt) {
                if (opt.value === 'green') {
                    opt.selected = 'selected';
                }
            });
            equal(map.get('color'), 'red', 'not yet updated from input');
            domEvents.dispatch.call(inputs[0], 'change');
            equal(map.get('color'), 'green', 'updated from input');
        });
        testIfRealDocument('<select> values:bind multiple select with a DefineList', function () {
            var template = stache('<select values:bind=\'colors\' multiple>' + '<option value=\'red\'>Red</option>' + '<option value=\'green\'>Green</option>' + '<option value=\'ultraviolet\'>Ultraviolet</option>' + '</select>');
            var list = new DefineList();
            stop();
            var frag = template({ colors: list });
            var ta = this.fixture;
            ta.appendChild(frag);
            var select = ta.getElementsByTagName('select')[0], options = select.getElementsByTagName('option');
            setTimeout(function () {
                options[0].selected = true;
                domEvents.dispatch.call(select, 'change');
                deepEqual(list.get(), ['red'], 'A DefineList value is set even if none existed');
                options[1].selected = true;
                domEvents.dispatch.call(select, 'change');
                deepEqual(list.get(), [
                    'red',
                    'green'
                ], 'Adds items to the list');
                options[0].selected = false;
                domEvents.dispatch.call(select, 'change');
                deepEqual(list.get(), ['green'], 'Removes items from the list');
                list.push('ultraviolet');
                options[0].selected = false;
                options[1].selected = true;
                options[2].selected = true;
                ta.removeChild(select);
                start();
            }, 1);
        });
        QUnit.test('<select> one-way bindings keep value if options are replaced (#1762)', function () {
            var countries = [
                {
                    code: 'MX',
                    countryName: 'MEXICO'
                },
                {
                    code: 'US',
                    countryName: 'USA'
                }
            ];
            var data = new SimpleMap({
                countryCode: 'US',
                countries: new DefineList(countries)
            });
            var template = stache('<select el:value:from="countryCode">' + '{{#countries}}' + '<option value="{{code}}">{{countryName}}</option>' + '{{/countries}}' + '</select>');
            var frag = template(data);
            var select = frag.firstChild;
            stop();
            testHelpers.afterMutation(function () {
                data.get('countries').replace([]);
                testHelpers.afterMutation(function () {
                    data.get('countries').replace(countries);
                    equal(data.get('countryCode'), 'US', 'country kept as USA');
                    testHelpers.afterMutation(function () {
                        ok(select.getElementsByTagName('option')[1].selected, 'USA still selected');
                    });
                    start();
                });
            });
        });
        testIfRealDocument('<select> two-way bindings update to `undefined` if options are replaced - each (#1762)', function () {
            var countries = [
                {
                    code: 'MX',
                    countryName: 'MEXICO'
                },
                {
                    code: 'US',
                    countryName: 'USA'
                }
            ];
            var data = new SimpleMap({
                countryCode: 'US',
                countries: new DefineList(countries)
            });
            var template = stache('<select el:value:bind="countryCode">' + '{{#each countries}}' + '<option value="{{code}}">{{countryName}}</option>' + '{{/each}}' + '</select>');
            template(data);
            stop();
            testHelpers.afterMutation(function () {
                data.attr('countries').replace([]);
                testHelpers.afterMutation(function () {
                    equal(data.get('countryCode'), undefined, 'countryCode set to undefined');
                    start();
                });
            });
        });
        testIfRealDocument('<select> - previously non-existing select value gets selected from a list when it is added (#1762)', function () {
            var template = stache('<select el:value:bind="{person}">' + '<option></option>' + '{{#each people}}<option value="{{.}}">{{.}}</option>{{/each}}' + '</select>' + '<input type="text" size="5" el:value:bind="person">');
            var people = new DefineList([
                'Justin',
                'Zed',
                'Tom',
                'Paula'
            ]);
            var vm = new SimpleMap({
                person: 'Brian',
                people: people
            });
            stop();
            vm.on('person', function (ev, newVal, oldVal) {
                ok(false, 'person attribute should not change');
            });
            var frag = template(vm);
            equal(vm.attr('person'), 'Brian', 'Person is still set');
            testHelpers.afterMutation(function () {
                people.push('Brian');
                testHelpers.afterMutation(function () {
                    var select = frag.firstChild;
                    ok(select.lastChild.selected, 'New child should be selected');
                    start();
                });
            });
        });
        test('<select> select bindings respond to changes immediately or during insert using bind (#2134)', function () {
            var countries = [
                {
                    code: 'MX',
                    countryName: 'MEXICO'
                },
                {
                    code: 'US',
                    countryName: 'USA'
                },
                {
                    code: 'IND',
                    countryName: 'INDIA'
                },
                {
                    code: 'RUS',
                    countryName: 'RUSSIA'
                }
            ];
            var template = stache('<select value:bind="countryCode">' + '{{#each countries}}' + '<option value="{{code}}">{{countryName}}</option>' + '{{/each}}' + '</select>');
            var data = new SimpleMap({
                countryCode: 'US',
                countries: new DefineList(countries)
            });
            var frag = template(data);
            data.set('countryCode', 'IND');
            stop();
            testHelpers.afterMutation(function () {
                start();
                equal(frag.firstChild.value, 'IND', 'got last updated value');
            });
        });
        testIfRealDocument('<select> two way bound select empty string null or undefined value (#2027)', function () {
            var template = stache('<select id=\'null-select\' value:bind=\'color-1\'>' + '<option value=\'\'>Choose</option>' + '<option value=\'red\'>Red</option>' + '<option value=\'green\'>Green</option>' + '</select>' + '<select id=\'undefined-select\' value:bind=\'color-2\'>' + '<option value=\'\'>Choose</option>' + '<option value=\'red\'>Red</option>' + '<option value=\'green\'>Green</option>' + '</select>' + '<select id=\'string-select\' value:bind=\'color-3\'>' + '<option value=\'\'>Choose</option>' + '<option value=\'red\'>Red</option>' + '<option value=\'green\'>Green</option>' + '</select>');
            var map = new SimpleMap({
                'color-1': null,
                'color-2': undefined,
                'color-3': ''
            });
            stop();
            var frag = template(map);
            domMutate.appendChild.call(this.fixture, frag);
            var nullInput = doc.getElementById('null-select');
            var nullInputOptions = nullInput.getElementsByTagName('option');
            var undefinedInput = doc.getElementById('undefined-select');
            var undefinedInputOptions = undefinedInput.getElementsByTagName('option');
            var stringInput = doc.getElementById('string-select');
            var stringInputOptions = stringInput.getElementsByTagName('option');
            testHelpers.afterMutation(function () {
                ok(!nullInputOptions[0].selected, 'default (null) value set');
                ok(undefinedInputOptions[0].selected, 'default (undefined) value set');
                ok(stringInputOptions[0].selected, 'default (\'\') value set');
                start();
            });
        });
        testIfRealDocument('<select> two way binding from a select\'s value to null has no selection (#2027)', function () {
            var template = stache('<select value:bind=\'key\'><option value=\'One\'>One</option></select>');
            var map = new SimpleMap({ key: null });
            var frag = template(map);
            var select = frag.childNodes.item(0);
            testHelpers.afterMutation(function () {
                equal(select.selectedIndex, -1, 'selectedIndex is 0 because no value exists on the map');
                equal(map.get('key'), null, 'The map\'s value property is set to the select\'s value');
                start();
            });
            stop();
        });
        testIfRealDocument('<select> One way binding from a select\'s value to a parent compute updates the parent with the select\'s initial value (#2027)', function () {
            var template = stache('<select value:to=\'value\'><option value=\'One\'>One</option></select>');
            var map = new SimpleMap();
            var frag = template(map);
            var select = frag.childNodes.item(0);
            testHelpers.afterMutation(function () {
                equal(select.selectedIndex, 0, 'selectedIndex is 0 because no value exists on the map');
                equal(map.attr('value'), 'One', 'The map\'s value property is set to the select\'s value');
                start();
            });
            stop();
        });
    });
});
/*can-stache-bindings@4.0.0-pre.8#test/colon/event-test*/
define('can-stache-bindings@4.0.0-pre.8#test/colon/event-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    '../helpers',
    'can-stache-bindings',
    'can-stache',
    '../mock-component-simple-map',
    'can-simple-map',
    'can-simple-observable',
    'can-view-model',
    'can-util/dom/data/data',
    'can-util/dom/mutate/mutate',
    'can-util/dom/events/events'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var testHelpers = require('../helpers');
    require('can-stache-bindings');
    var stache = require('can-stache');
    var MockComponent = require('../mock-component-simple-map');
    var SimpleMap = require('can-simple-map');
    var SimpleObservable = require('can-simple-observable');
    var canViewModel = require('can-view-model');
    var domData = require('can-util/dom/data/data');
    var domMutate = require('can-util/dom/mutate/mutate');
    var domEvents = require('can-util/dom/events/events');
    testHelpers.makeTests('can-stache-bindings - colon - event', function (name, doc, enableMO) {
        QUnit.test('on:enter', function () {
            var template = stache('<input on:enter=\'update()\'/>');
            var called = 0;
            var frag = template({
                update: function () {
                    called++;
                    equal(called, 1, 'update called once');
                }
            });
            var input = frag.childNodes.item(0);
            domEvents.dispatch.call(input, {
                type: 'keyup',
                keyCode: 38
            });
            domEvents.dispatch.call(input, {
                type: 'keyup',
                keyCode: 13
            });
        });
        test('can call intermediate functions before calling the final function(#1474)', function () {
            var ta = this.fixture;
            var template = stache('<div id=\'click-me\' on:click=\'does.some.thing(this)\'></div>');
            var frag = template({
                does: function () {
                    return {
                        some: function () {
                            return {
                                thing: function (context) {
                                    ok(typeof context.does === 'function');
                                    start();
                                }
                            };
                        }
                    };
                }
            });
            stop();
            ta.appendChild(frag);
            domEvents.dispatch.call(doc.getElementById('click-me'), 'click');
        });
        test('two bindings on one element call back the correct method', function () {
            expect(2);
            var template = stache('<input on:mousemove=\'first()\' on:click=\'second()\'/>');
            var callingFirst = false, callingSecond = false;
            var frag = template({
                first: function () {
                    ok(callingFirst, 'called first');
                },
                second: function () {
                    ok(callingSecond, 'called second');
                }
            });
            var input = frag.childNodes.item(0);
            callingFirst = true;
            domEvents.dispatch.call(input, { type: 'mousemove' });
            callingFirst = false;
            callingSecond = true;
            domEvents.dispatch.call(input, { type: 'click' });
        });
        test('event bindings should be removed when the bound element is', function (assert) {
            var template = stache('<div>{{#if isShowing}}<input on:el:click="onClick()"><span></span>{{/if}}</div>');
            var viewModel = new SimpleMap({ isShowing: false });
            viewModel.onClick = function () {
            };
            var bindingListenerCount = 0;
            var hasAddedBindingListener = false;
            var hasRemovedBindingListener = false;
            var fragment = template(viewModel);
            domMutate.appendChild.call(this.fixture, fragment);
            var isInputBindingEvent = function (element, eventName) {
                return element.nodeName === 'INPUT' && eventName === 'click';
            };
            var realAddEventListener = domEvents.addEventListener;
            var realRemoveEventListener = domEvents.removeEventListener;
            domEvents.addEventListener = function (eventName) {
                if (isInputBindingEvent(this, eventName)) {
                    bindingListenerCount++;
                    hasAddedBindingListener = true;
                }
                return realAddEventListener.apply(this, arguments);
            };
            domEvents.removeEventListener = function (eventName) {
                if (isInputBindingEvent(this, eventName)) {
                    bindingListenerCount--;
                    hasRemovedBindingListener = true;
                }
                return realRemoveEventListener.apply(this, arguments);
            };
            viewModel.set('isShowing', true);
            var andThen = function () {
                domEvents.removeEventListener.call(span, 'removed', andThen);
                start();
                domEvents.addEventListener = realAddEventListener;
                domEvents.removeEventListener = realRemoveEventListener;
                assert.ok(hasAddedBindingListener, 'An event listener should have been added for the binding');
                assert.ok(hasRemovedBindingListener, 'An event listener should have been removed for the binding');
                var message = bindingListenerCount + ' event listeners were added but not removed';
                if (removeEventListener < 0) {
                    message = 'Event listeners were removed more than necessary';
                }
                assert.equal(bindingListenerCount, 0, message);
            };
            var span = this.fixture.firstChild.lastChild;
            domEvents.addEventListener.call(span, 'removed', andThen);
            viewModel.set('isShowing', false);
            stop();
        });
        test('on:event throws an error when inside #if block (#1182)', function (assert) {
            var done = assert.async();
            var flag = new SimpleObservable(false), clickHandlerCount = 0;
            var frag = stache('<div {{#if flag}}on:click=\'foo\'{{/if}}>Click</div>')({
                flag: flag,
                foo: function () {
                    clickHandlerCount++;
                }
            });
            var fixture = this.fixture;
            var trig = function () {
                var div = fixture.getElementsByTagName('div')[0];
                domEvents.dispatch.call(div, { type: 'click' });
            };
            domMutate.appendChild.call(this.fixture, frag);
            trig();
            testHelpers.afterMutation(function () {
                equal(clickHandlerCount, 0, 'click handler not called');
                done();
            });
        });
        test('can listen to camelCase events using on:', function () {
            QUnit.stop();
            expect(1);
            var map = new SimpleMap({ someProp: 'foo' });
            map.someMethod = function () {
                QUnit.start();
                ok(true);
            };
            var template = stache('<div on:someProp:by:this=\'someMethod()\'/>');
            template(map);
            map.set('someProp', 'baz');
        });
        test('can listen to kebab-case events using on:', function () {
            QUnit.stop();
            expect(1);
            var map = new SimpleMap({ 'some-prop': 'foo' });
            map.someMethod = function () {
                QUnit.start();
                ok(true);
            };
            var template = stache('<div on:some-prop:by:this=\'someMethod()\'/>');
            template(map);
            map.set('some-prop', 'baz');
        });
        test('can bind to property on scope using :by:', function () {
            stop();
            expect(1);
            MockComponent.extend({ tag: 'view-model-able' });
            var template = stache('<view-model-able on:prop:by:obj=\'someMethod(%arguments)\'/>');
            var map = new SimpleMap({ obj: new SimpleMap({ prop: 'Mercury' }) });
            map.someMethod = function (args) {
                start();
                equal(args[0], 'Venus', 'method called');
            };
            template(map);
            map.get('obj').set('prop', 'Venus');
        });
        test('can bind to entire scope using :by:this', function () {
            stop();
            expect(1);
            MockComponent.extend({ tag: 'view-model-able' });
            var template = stache('<view-model-able on:prop:by:this=\'someMethod(%arguments[0])\'/>');
            var map = new SimpleMap({ prop: 'Mercury' });
            map.someMethod = function (newVal) {
                start();
                equal(newVal, 'Venus', 'method called');
            };
            template(map);
            map.set('prop', 'Venus');
        });
        test('can bind to viewModel using on:vm:prop', function () {
            stop();
            expect(1);
            var map = new SimpleMap({ prop: 'Mercury' });
            var MySimpleMap = SimpleMap.extend({
                someMethod: function (newVal) {
                    start();
                    equal(newVal, 'Venus', 'method called');
                }
            });
            var parent = new MySimpleMap();
            MockComponent.extend({
                tag: 'view-model-able',
                viewModel: map
            });
            var template = stache('<view-model-able on:vm:prop=\'someMethod(%arguments[0])\'/>');
            template(parent);
            map.attr('prop', 'Venus');
        });
        test('can bind to element using on:el:prop', function () {
            stop();
            expect(1);
            var map = new SimpleMap({ prop: 'Mercury' });
            var MySimpleMap = SimpleMap.extend({
                someMethod: function () {
                    start();
                    ok(true, 'method called');
                }
            });
            var parent = new MySimpleMap();
            MockComponent.extend({
                tag: 'view-model-able',
                viewModel: map
            });
            var template = stache('<view-model-able on:el:prop=\'someMethod()\'/>');
            var frag = template(parent);
            var element = frag.firstChild;
            domEvents.dispatch.call(element, 'prop');
        });
        test('call expressions work (#208)', function () {
            expect(2);
            stache.registerHelper('addTwo', function (arg) {
                return arg + 2;
            });
            stache.registerHelper('helperWithArgs', function (arg) {
                QUnit.equal(arg, 3, 'got the helper');
                ok(true, 'helper called');
            });
            var template = stache('<p on:click=\'helperWithArgs(addTwo(arg))\'></p>');
            var frag = template({ arg: 1 });
            this.fixture.appendChild(frag);
            var p0 = this.fixture.getElementsByTagName('p')[0];
            domEvents.dispatch.call(p0, 'click');
        });
        QUnit.test('events should bind when using a plain object', function () {
            var flip = false;
            var template = stache('<div {{#if test}}on:foo="log()"{{/if}}>Test</div>');
            var frag = template({
                log: function () {
                    flip = true;
                },
                test: true
            });
            domEvents.dispatch.call(frag.firstChild, 'foo');
            QUnit.ok(flip, 'Plain object method successfully called');
        });
        QUnit.test('%arguments gives the event arguments', function () {
            var template = stache('<button on:click=\'doSomething(%event, %arguments)\'>Default Args</button>');
            var MyMap = SimpleMap.extend({
                doSomething: function (ev, args) {
                    equal(args[0], ev, 'default arg is ev');
                }
            });
            var frag = template(new MyMap());
            var button = frag.firstChild;
            domEvents.dispatch.call(button, 'click');
        });
        test('special values get called', function (assert) {
            assert.expect(2);
            var done = assert.async(1);
            MockComponent.extend({
                tag: 'ref-syntax',
                template: stache('<input on:change="%scope.set(\'*foo\', %element.value)">'),
                viewModel: new (SimpleMap.extend({
                    method: function () {
                        assert.ok(true, 'method called');
                        done();
                    }
                }))()
            });
            var template = stache('<ref-syntax on:el:inserted="%viewModel.method()"></ref-syntax>');
            var frag = template({});
            domMutate.appendChild.call(this.fixture, frag);
            QUnit.stop();
            testHelpers.afterMutation(function () {
                var input = doc.getElementsByTagName('input')[0];
                input.value = 'bar';
                domEvents.dispatch.call(input, 'change');
                var scope = domData.get.call(this.fixture.firstChild).shadowScope;
                assert.equal(scope.get('*foo'), 'bar', 'Reference attribute set');
                start();
            }.bind(this));
        });
        QUnit.test('viewModel binding', function () {
            MockComponent.extend({
                tag: 'viewmodel-binding',
                viewModel: {
                    makeMyEvent: function () {
                        this.dispatch('myevent');
                    }
                }
            });
            var frag = stache('<viewmodel-binding on:myevent=\'doSomething()\'/>')({
                doSomething: function () {
                    ok(true, 'called!');
                }
            });
            canViewModel(frag.firstChild).makeMyEvent();
        });
        QUnit.test('methods on objects are called with call expressions (#1839)', function () {
            var template = stache('<div on:click=\'setSomething(person.message)\'/>');
            var data = {
                setSomething: function (message) {
                    equal(message, 'Matthew P finds good bugs');
                    equal(this, data, 'setSomething called with correct scope');
                },
                person: {
                    name: 'Matthew P',
                    message: function () {
                        return this.name + ' finds good bugs';
                    }
                }
            };
            var frag = template(data);
            domEvents.dispatch.call(frag.firstChild, 'click');
        });
    });
});
/*can-stache-bindings@4.0.0-pre.8#test/colon/view-model-test*/
define('can-stache-bindings@4.0.0-pre.8#test/colon/view-model-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    '../helpers',
    'can-stache-bindings',
    'can-stache',
    'can-simple-map',
    '../mock-component-simple-map',
    'can-util/dom/events/events',
    'can-util/dom/mutate/mutate',
    'can-view-callbacks',
    'can-util/js/dev/dev',
    'can-view-model',
    'can-symbol',
    'can-reflect',
    'can-queues'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var testHelpers = require('../helpers');
    require('can-stache-bindings');
    var stache = require('can-stache');
    var SimpleMap = require('can-simple-map');
    var MockComponent = require('../mock-component-simple-map');
    var domEvents = require('can-util/dom/events/events');
    var domMutate = require('can-util/dom/mutate/mutate');
    var viewCallbacks = require('can-view-callbacks');
    var dev = require('can-util/js/dev/dev');
    var canViewModel = require('can-view-model');
    var canSymbol = require('can-symbol');
    var canReflect = require('can-reflect');
    var queues = require('can-queues');
    testHelpers.makeTests('can-stache-bindings - colon - ViewModel', function (name, doc, enableMO) {
        QUnit.test('on:el:click works inside {{#if}} on element with a viewModel (#279)', function () {
            var map = new SimpleMap({});
            var MySimpleMap = SimpleMap.extend({
                show: true,
                method: function () {
                    ok(true, 'method called');
                }
            });
            var parent = new MySimpleMap();
            MockComponent.extend({
                tag: 'view-model-able',
                viewModel: map
            });
            var template = stache('<view-model-able {{#if show}} on:el:click=\'method()\' {{/if}} />');
            var frag = template(parent);
            var el = frag.firstChild;
            domEvents.dispatch.call(el, 'click');
        });
        QUnit.test('vm:prop:to/:from/:bind work (#280)', function () {
            var vm1 = new SimpleMap({ value: 'vm1' });
            var vm2 = new SimpleMap({ value: 'vm2' });
            var vm3 = new SimpleMap({ value: 'vm3' });
            MockComponent.extend({
                tag: 'comp-1',
                viewModel: vm1
            });
            MockComponent.extend({
                tag: 'comp-2',
                viewModel: vm2
            });
            MockComponent.extend({
                tag: 'comp-3',
                viewModel: vm3
            });
            var template = stache('<comp-1 vm:value:to=\'scope1\'/>' + '<comp-2 vm:value:from=\'scope2\'/>' + '<comp-3 vm:value:bind=\'scope3\'/>');
            var scope = new SimpleMap({
                scope1: 'scope1',
                scope2: 'scope2',
                scope3: 'scope3'
            });
            template(scope);
            equal(scope.attr('scope1'), 'vm1', 'vm:value:to - scope value set from vm');
            vm1.attr('value', 'vm4');
            equal(scope.attr('scope1'), 'vm4', 'vm:value:to - scope updated when vm changes');
            scope.attr('scope1', 'scope4');
            equal(vm1.attr('value'), 'vm4', 'vm:value:to - vm not updated when scope changes');
            equal(vm2.attr('value'), 'scope2', 'vm:value:from - vm value set from scope');
            scope.attr('scope2', 'scope5');
            equal(vm2.attr('value'), 'scope5', 'vm:value:from - vm updated when scope changes');
            vm2.attr('value', 'vm5');
            equal(scope.attr('scope2'), 'scope5', 'vm:value:from - scope not updated when vm changes');
            equal(vm3.attr('value'), 'scope3', 'vm:value:bind - vm value set from scope');
            scope.attr('scope3', 'scope6');
            equal(vm3.attr('value'), 'scope6', 'vm:value:bind - vm updated when scope changes');
            vm3.attr('value', 'vm6');
            equal(scope.attr('scope3'), 'vm6', 'vm:value:bind - scope updated when vm changes');
        });
        if (System.env.indexOf('production') < 0) {
            test('Warning happens when changing the map that a to-parent binding points to.', function () {
                var tagName = 'merge-warn-test';
                delete viewCallbacks._tags[tagName];
                expect(2);
                var step1 = { 'baz': 'quux' };
                var overwrite = { 'plonk': 'waldo' };
                var oldlog = dev.warn, message = 'can-stache-key: Merging data into "bar" because its parent is non-observable';
                var thisTest = QUnit.config.current;
                dev.warn = function (text) {
                    if (QUnit.config.current === thisTest) {
                        if (text === message) {
                            ok(true, 'Got expected message logged.');
                        }
                    }
                };
                var viewModel;
                MockComponent.extend({
                    tag: tagName,
                    viewModel: function () {
                        return viewModel = new SimpleMap({ 'foo': new SimpleMap({}) });
                    }
                });
                var template = stache('<merge-warn-test foo:bind=\'bar\'/>');
                var data = { bar: new SimpleMap(step1) };
                this.fixture.appendChild(template(data));
                viewModel.set('foo', overwrite);
                deepEqual(data.bar.get(), {
                    'baz': undefined,
                    'plonk': 'waldo'
                }, 'sanity check: parent binding set (default map -> default map)');
                dev.warn = oldlog;
            });
        }
        QUnit.test('changing a scope property calls registered stache helper\'s returned function', function () {
            expect(1);
            stop();
            var scope = new SimpleMap({ test: 'testval' });
            MockComponent.extend({
                tag: 'test-component',
                viewModel: scope,
                template: stache('<span>Hello world</span>')
            });
            stache.registerHelper('propChangeEventStacheHelper', function () {
                return function () {
                    start();
                    ok(true, 'helper\'s returned function called');
                };
            });
            var template = stache('<test-component on:test="propChangeEventStacheHelper()" />');
            template({});
            scope.set('test', 'changed');
        });
        test('one-way pass computes to components with ~', function (assert) {
            expect(6);
            MockComponent.extend({ tag: 'foo-bar' });
            var baseVm = new SimpleMap({ foo: 'bar' });
            this.fixture.appendChild(stache('<foo-bar compute:from="~foo"></foo-bar>')(baseVm));
            var vm = canViewModel(this.fixture.firstChild);
            ok(vm.get('compute')[canSymbol.for('can.getValue')], 'observable returned');
            equal(vm.get('compute')(), 'bar', 'Compute has correct value');
            canReflect.onValue(vm.get('compute'), function () {
                ok(true, 'Change handler called');
            });
            baseVm.set('foo', 'quux');
            equal(vm.get('compute')(), 'quux', 'Compute updates');
            vm.get('compute')('xyzzy');
            equal(baseVm.get('foo'), 'xyzzy', 'Compute does update the other direction');
        });
        test('Child bindings updated before parent (#2252)', function () {
            var template = stache('{{#eq page \'view\'}}<child-binder page:from=\'page\' title:from=\'title\'/>{{/eq}}');
            MockComponent.extend({
                tag: 'child-binder',
                template: stache('<span/>'),
                viewModel: function (props) {
                    var map = new SimpleMap(props);
                    canReflect.assignSymbols(map, {
                        'can.setKeyValue': function (key, value) {
                            if (key === 'page') {
                                equal(value, 'view', 'value should not be edit');
                            } else {
                                QUnit.equal(key, 'title', 'title was set, we are trapping right');
                            }
                            this.set(key, value);
                        }
                    });
                    return map;
                }
            });
            var data = new SimpleMap({ page: 'view' });
            template(data);
            data.set('title', 'foo');
            queues.batch.start();
            data.set('page', 'edit');
            queues.batch.stop();
        });
        test('backtrack path in to-parent bindings (#2132)', function () {
            MockComponent.extend({
                tag: 'parent-export',
                viewModel: { value: 'VALUE' }
            });
            var template = stache('{{#innerMap}}<parent-export value:to=\'../parentValue\'/>{{/innerMap}}');
            var data = new SimpleMap({ innerMap: new SimpleMap({}) });
            template(data);
            equal(data.get('parentValue'), 'VALUE', 'set on correct context');
            equal(data.get('innerMap').get('parentValue'), undefined, 'nothing on innerMap');
        });
        test('function reference to child binding (#2116)', function () {
            expect(2);
            var template = stache('<foo-bar vm:child:from="@parent"></foo-bar>');
            MockComponent.extend({
                tag: 'foo-bar',
                viewModel: {}
            });
            var VM = SimpleMap.extend({});
            var vm = new VM({});
            var frag = template(vm);
            vm.attr('parent', function () {
                ok(false, 'should not be called');
            });
            equal(typeof canViewModel(frag.firstChild).attr('child'), 'function', 'to child binding');
            template = stache('<foo-bar vm:@method:to="vmMethod"></foo-bar>');
            vm = new VM({});
            frag = template(vm);
            canViewModel(frag.firstChild).attr('method', function () {
                ok(false, 'method should not be called');
            });
            equal(typeof vm.get('vmMethod'), 'function', 'parent export function');
        });
        test('setter only gets called once (#2117)', function () {
            expect(1);
            var VM = SimpleMap.extend({
                attr: function (prop, val) {
                    if (prop === 'bar') {
                        equal(val, 'BAR');
                    }
                    return SimpleMap.prototype.attr.apply(this, arguments);
                }
            });
            MockComponent.extend({
                tag: 'foo-bar',
                viewModel: VM
            });
            var template = stache('<foo-bar vm:bar:from="bar"/>');
            template(new SimpleMap({ bar: 'BAR' }));
        });
        test('@function reference to child (#2116)', function () {
            expect(2);
            var template = stache('<foo-bar vm:@child:from="@parent"></foo-bar>');
            MockComponent.extend({
                tag: 'foo-bar',
                viewModel: {
                    method: function () {
                        ok(false, 'should not be called');
                    }
                }
            });
            var VM = SimpleMap.extend({
                parent: function () {
                    ok(false, 'should not be called');
                }
            });
            var vm = new VM({});
            var frag = template(vm);
            equal(typeof canViewModel(frag.firstChild).attr('child'), 'function', 'to child binding');
            template = stache('<foo-bar vm:@method:to="@vmMethod"></foo-bar>');
            vm = new VM({});
            template(vm);
            ok(typeof vm.attr('vmMethod') === 'function', 'parent export function');
        });
        test('exporting methods (#2051)', function () {
            expect(2);
            MockComponent.extend({
                tag: 'foo-bar',
                viewModel: {
                    method: function () {
                        ok(true, 'foo called');
                        return 5;
                    }
                }
            });
            var template = stache('<foo-bar @method:to=\'@*refKey\'></foo-bar>{{*refKey()}}');
            var frag = template({});
            equal(frag.lastChild.nodeValue, '5');
        });
        test('one way - child to parent - importing viewModel hypenatedProp:to="test"', function () {
            MockComponent.extend({
                tag: 'import-prop-scope',
                template: stache('Hello {{userName}}'),
                viewModel: {
                    userName: 'David',
                    age: 7,
                    updateName: function () {
                        this.set('userName', 'Justin');
                    }
                }
            });
            MockComponent.extend({
                tag: 'import-prop-parent',
                template: stache('<import-prop-scope vm:userName:to="test" vm:this:to="childComponent"></import-prop-scope>' + '<div>Imported: {{test}}</div>')
            });
            var template = stache('<import-prop-parent></import-prop-parent>');
            var frag = template({});
            var importPropParent = frag.firstChild;
            var importPropScope = importPropParent.getElementsByTagName('import-prop-scope')[0];
            canViewModel(importPropScope).updateName();
            var importPropParentViewModel = canViewModel(importPropParent);
            equal(importPropParentViewModel.get('test'), 'Justin', 'got hypenated prop');
            equal(importPropParentViewModel.get('childComponent'), canViewModel(importPropScope), 'got view model');
        });
        test('one way - child to parent - importing viewModel prop:to="test"', function () {
            MockComponent.extend({
                tag: 'import-prop-scope',
                template: stache('Hello {{name}}'),
                viewModel: {
                    name: 'David',
                    age: 7
                }
            });
            MockComponent.extend({
                tag: 'import-prop-parent',
                template: stache('<import-prop-scope vm:name:to="test"></import-prop-scope>' + '<div>Imported: {{test}}</div>')
            });
            var template = stache('<import-prop-parent></import-prop-parent>');
            var frag = template({});
            equal(frag.childNodes.item(0).childNodes.item(1).innerHTML, 'Imported: David', '{name} component scope imported into variable');
        });
        test('one-way - child to parent - viewModel', function () {
            MockComponent.extend({
                tag: 'view-model-able',
                viewModel: function () {
                    return new SimpleMap({ viewModelProp: 'Mercury' });
                }
            });
            var template = stache('<view-model-able vm:viewModelProp:to=\'scopeProp\'/>');
            var map = new SimpleMap({ scopeProp: 'Venus' });
            var frag = template(map);
            var viewModel = canViewModel(frag.firstChild);
            equal(viewModel.get('viewModelProp'), 'Mercury', 'initial value kept');
            equal(map.get('scopeProp'), 'Mercury', 'initial value set on parent');
            viewModel.set('viewModelProp', 'Earth');
            equal(map.get('scopeProp'), 'Earth', 'binding from child to parent');
            map.set('scopeProp', 'Mars');
            equal(viewModel.get('viewModelProp'), 'Earth', 'no binding from parent to child');
        });
        test('one-way - parent to child - viewModel', function () {
            var template = stache('<div vm:viewModelProp:from=\'scopeProp\'/>');
            var map = new SimpleMap({ scopeProp: 'Venus' });
            var frag = template(map);
            var viewModel = canViewModel(frag.firstChild);
            equal(viewModel.attr('viewModelProp'), 'Venus', 'initial value set');
            viewModel.attr('viewModelProp', 'Earth');
            equal(map.attr('scopeProp'), 'Venus', 'no binding from child to parent');
            map.attr('scopeProp', 'Mars');
            equal(viewModel.attr('viewModelProp'), 'Mars', 'binding from parent to child');
        });
        test('two-way - reference - child:bind="*ref" (#1700)', function () {
            var data = new SimpleMap({ person: new SimpleMap({ name: new SimpleMap({}) }) });
            MockComponent.extend({
                tag: 'reference-export',
                viewModel: function () {
                    return new SimpleMap({ tag: 'reference-export' });
                }
            });
            MockComponent.extend({
                tag: 'ref-import',
                viewModel: function () {
                    return new SimpleMap({ tag: 'ref-import' });
                }
            });
            var template = stache('<reference-export name:bind=\'*refName\'/>' + '<ref-import name:bind=\'*refName\'/> {{helperToGetScope}}');
            var scope;
            var frag = template(data, {
                helperToGetScope: function (options) {
                    scope = options.scope;
                }
            });
            var refExport = canViewModel(frag.firstChild);
            var refImport = canViewModel(frag.firstChild.nextSibling);
            refExport.set('name', 'v1');
            equal(scope.getRefs()._context.attr('*refName'), 'v1', 'reference scope updated');
            equal(refImport.get('name'), 'v1', 'updated ref-import');
            refImport.set('name', 'v2');
            equal(refExport.get('name'), 'v2', 'updated ref-export');
            equal(scope.getRefs()._context.attr('*refName'), 'v2', 'actually put in refs scope');
        });
        test('one-way - DOM - parent value undefined (#189)', function () {
            MockComponent.extend({
                tag: 'toggle-button',
                viewModel: function () {
                    var vm = new SimpleMap({ value: false });
                    vm.toggle = function () {
                        this.set('value', !this.get('value'));
                    };
                    return vm;
                },
                template: stache('<button type="button" on:el:click="toggle()">{{value}}</button>')
            });
            var template = stache('<toggle-button vm:value:bind="./does-not-exist" />');
            var fragment = template({});
            domMutate.appendChild.call(this.fixture, fragment);
            var button = this.fixture.getElementsByTagName('button')[0];
            function text(node) {
                while (node && node.nodeType !== 3) {
                    node = node.firstChild;
                }
                return node && node.nodeValue;
            }
            equal(text(button), 'false', 'Initial value is "false"');
            domEvents.dispatch.call(button, 'click');
            equal(text(button), 'true', 'Value is "true" after first click');
            domEvents.dispatch.call(button, 'click');
            equal(text(button), 'false', 'Value is "false" after second click');
        });
        test('two way - viewModel (#1700)', function () {
            var template = stache('<div vm:viewModelProp:bind=\'scopeProp\'/>');
            var map = new SimpleMap({ scopeProp: 'Hello' });
            var scopeMapSetCalled = 0;
            var origMapSetKeyValue = map[canSymbol.for('can.setKeyValue')];
            map[canSymbol.for('can.setKeyValue')] = function (attrName, value) {
                if (typeof attrName === 'string' && arguments.length > 1) {
                    scopeMapSetCalled++;
                }
                return origMapSetKeyValue.apply(this, arguments);
            };
            var frag = template(map);
            var viewModel = canViewModel(frag.firstChild);
            equal(scopeMapSetCalled, 0, 'set is not called on scope map');
            equal(viewModel.get('viewModelProp'), 'Hello', 'initial value set');
            viewModel = canViewModel(frag.firstChild);
            var viewModelSetCalled = 1;
            var origViewModelSet = viewModel[canSymbol.for('can.setKeyValue')];
            viewModel[canSymbol.for('can.setKeyValue')] = function (attrName) {
                if (typeof attrName === 'string' && arguments.length > 1) {
                    viewModelSetCalled++;
                }
                return origViewModelSet.apply(this, arguments);
            };
            viewModel.set('viewModelProp', 'HELLO');
            equal(map.get('scopeProp'), 'HELLO', 'binding from child to parent');
            equal(scopeMapSetCalled, 1, 'set is called on scope map');
            equal(viewModelSetCalled, 2, 'set is called viewModel');
            map.set('scopeProp', 'WORLD');
            equal(viewModel.get('viewModelProp'), 'WORLD', 'binding from parent to child');
            equal(scopeMapSetCalled, 1, 'can.setKey is not called again on scope map');
            equal(viewModelSetCalled, 3, 'set is called again on viewModel');
        });
    });
});
/*can-stache-bindings@4.0.0-pre.8#test/colon/hybrid-test*/
define('can-stache-bindings@4.0.0-pre.8#test/colon/hybrid-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    '../helpers',
    'can-stache-bindings',
    'can-stache',
    'can-simple-map',
    'can-util/dom/events/events'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var testHelpers = require('../helpers');
    require('can-stache-bindings');
    var stache = require('can-stache');
    var SimpleMap = require('can-simple-map');
    var domEvents = require('can-util/dom/events/events');
    testHelpers.makeTests('can-stache-bindings - colon - hybrids', function (name, doc, enableMO) {
        test('value:to:on:click and on:click:value:to work (#269)', function () {
            var template = stache('<input value:to:on:click=\'theProp\'/>' + '<input on:click:value:to=\'theProp\'/>');
            var map = new SimpleMap({});
            var frag = template(map);
            var ta = this.fixture;
            ta.appendChild(frag);
            var bindFirstInput = ta.getElementsByTagName('input')[0];
            bindFirstInput.value = '22';
            domEvents.dispatch.call(bindFirstInput, 'click');
            QUnit.equal(map.get('theProp'), '22');
            var eventFirstInput = ta.getElementsByTagName('input')[1];
            eventFirstInput.value = '23';
            domEvents.dispatch.call(eventFirstInput, 'click');
            QUnit.equal(map.get('theProp'), '23');
        });
        QUnit.test('on:input:value:to works (#289)', function () {
            var scope = new SimpleMap({ myProp: '' });
            var renderer = stache('<input type=\'text\' value=\'hai\' on:input:value:to=\'myProp\' />');
            var view = renderer(scope);
            var ta = this.fixture;
            ta.appendChild(view);
            var inputTo = ta.getElementsByTagName('input')[0];
            inputTo.value = 'wurld';
            domEvents.dispatch.call(inputTo, 'input');
            equal(scope.get('myProp'), 'wurld', 'Got the value on the scope');
        });
        QUnit.test('on:input:value:to does not initialize values (#289)', function () {
            try {
                stache('<input on:input:value:to=\'*editing.licensePlate\'/>')();
                ok(true, 'renderer was made without error');
            } catch (e) {
                ok(false, e.message);
            }
        });
    });
});
/*can-stache-bindings@4.0.0-pre.8#test/colon/tests*/
define('can-stache-bindings@4.0.0-pre.8#test/colon/tests', [
    'require',
    'exports',
    'module',
    './basics-test',
    './element-test',
    './event-test',
    './view-model-test',
    './hybrid-test'
], function (require, exports, module) {
    require('./basics-test');
    require('./element-test');
    require('./event-test');
    require('./view-model-test');
    require('./hybrid-test');
});
/*can-param@1.0.1#can-param*/
define('can-param@1.0.1#can-param', [
    'require',
    'exports',
    'module',
    'can-namespace'
], function (require, exports, module) {
    var namespace = require('can-namespace');
    function buildParam(prefix, obj, add) {
        if (Array.isArray(obj)) {
            for (var i = 0, l = obj.length; i < l; ++i) {
                add(prefix + '[]', obj[i]);
            }
        } else if (obj && typeof obj === 'object') {
            for (var name in obj) {
                buildParam(prefix + '[' + name + ']', obj[name], add);
            }
        } else {
            add(prefix, obj);
        }
    }
    module.exports = namespace.param = function param(object) {
        var pairs = [], add = function (key, value) {
                pairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
            };
        for (var name in object) {
            buildParam(name, object[name], add);
        }
        return pairs.join('&').replace(/%20/g, '+');
    };
});
/*can-ajax@1.0.9#can-ajax*/
define('can-ajax@1.0.9#can-ajax', [
    'require',
    'exports',
    'module',
    'can-globals/global/global',
    'can-assign',
    'can-namespace',
    'can-parse-uri',
    'can-param'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var Global = require('can-globals/global/global');
        var assign = require('can-assign');
        var namespace = require('can-namespace');
        var parseURI = require('can-parse-uri');
        var param = require('can-param');
        var xhrs = [
                function () {
                    return new XMLHttpRequest();
                },
                function () {
                    return new ActiveXObject('Microsoft.XMLHTTP');
                },
                function () {
                    return new ActiveXObject('MSXML2.XMLHTTP.3.0');
                },
                function () {
                    return new ActiveXObject('MSXML2.XMLHTTP');
                }
            ], _xhrf = null;
        var originUrl = parseURI(Global().location.href);
        var makeXhr = function () {
            if (_xhrf != null) {
                return _xhrf();
            }
            for (var i = 0, l = xhrs.length; i < l; i++) {
                try {
                    var f = xhrs[i], req = f();
                    if (req != null) {
                        _xhrf = f;
                        return req;
                    }
                } catch (e) {
                    continue;
                }
            }
            return function () {
            };
        };
        var contentTypes = {
            json: 'application/json',
            form: 'application/x-www-form-urlencoded'
        };
        var _xhrResp = function (xhr, options) {
            switch (options.dataType || xhr.getResponseHeader('Content-Type').split(';')[0]) {
            case 'text/xml':
            case 'xml':
                return xhr.responseXML;
            case 'text/json':
            case 'application/json':
            case 'text/javascript':
            case 'application/javascript':
            case 'application/x-javascript':
            case 'json':
                return JSON.parse(xhr.responseText);
            default:
                return xhr.responseText;
            }
        };
        module.exports = namespace.ajax = function (o) {
            var xhr = makeXhr(), timer, n = 0;
            var deferred = {};
            var promise = new Promise(function (resolve, reject) {
                deferred.resolve = resolve;
                deferred.reject = reject;
            });
            var requestUrl;
            promise.abort = function () {
                xhr.abort();
            };
            o = assign({
                userAgent: 'XMLHttpRequest',
                lang: 'en',
                type: 'GET',
                data: null,
                dataType: 'json'
            }, o);
            if (!o.contentType) {
                o.contentType = o.type.toUpperCase() === 'GET' ? contentTypes.form : contentTypes.json;
            }
            if (o.crossDomain == null) {
                try {
                    requestUrl = parseURI(o.url);
                    o.crossDomain = !!(requestUrl.protocol && requestUrl.protocol !== originUrl.protocol || requestUrl.host && requestUrl.host !== originUrl.host);
                } catch (e) {
                    o.crossDomain = true;
                }
            }
            if (o.timeout) {
                timer = setTimeout(function () {
                    xhr.abort();
                    if (o.timeoutFn) {
                        o.timeoutFn(o.url);
                    }
                }, o.timeout);
            }
            xhr.onreadystatechange = function () {
                try {
                    if (xhr.readyState === 4) {
                        if (timer) {
                            clearTimeout(timer);
                        }
                        if (xhr.status < 300) {
                            if (o.success) {
                                o.success(_xhrResp(xhr, o));
                            }
                        } else if (o.error) {
                            o.error(xhr, xhr.status, xhr.statusText);
                        }
                        if (o.complete) {
                            o.complete(xhr, xhr.statusText);
                        }
                        if (xhr.status >= 200 && xhr.status < 300) {
                            deferred.resolve(_xhrResp(xhr, o));
                        } else {
                            deferred.reject(xhr);
                        }
                    } else if (o.progress) {
                        o.progress(++n);
                    }
                } catch (e) {
                    deferred.reject(e);
                }
            };
            var url = o.url, data = null, type = o.type.toUpperCase();
            var isJsonContentType = o.contentType === contentTypes.json;
            var isPost = type === 'POST' || type === 'PUT';
            if (!isPost && o.data) {
                url += '?' + (isJsonContentType ? JSON.stringify(o.data) : param(o.data));
            }
            xhr.open(type, url);
            var isSimpleCors = o.crossDomain && [
                'GET',
                'POST',
                'HEAD'
            ].indexOf(type) !== -1;
            if (isPost) {
                data = isJsonContentType && !isSimpleCors ? typeof o.data === 'object' ? JSON.stringify(o.data) : o.data : param(o.data);
                var setContentType = isJsonContentType && !isSimpleCors ? 'application/json' : 'application/x-www-form-urlencoded';
                xhr.setRequestHeader('Content-Type', setContentType);
            } else {
                xhr.setRequestHeader('Content-Type', o.contentType);
            }
            if (!isSimpleCors) {
                xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
            }
            xhr.send(data);
            return promise;
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-make-map@1.0.0#can-make-map*/
define('can-make-map@1.0.0#can-make-map', function (require, exports, module) {
    function makeMap(str) {
        var obj = {}, items = str.split(',');
        items.forEach(function (name) {
            obj[name] = true;
        });
        return obj;
    }
    module.exports = makeMap;
});
/*qunitjs@2.4.1#qunit/qunit*/
(function (global$1) {
    'use strict';
    global$1 = 'default' in global$1 ? global$1['default'] : global$1;
    var window = global$1.window;
    var self$1 = global$1.self;
    var console = global$1.console;
    var setTimeout = global$1.setTimeout;
    var clearTimeout = global$1.clearTimeout;
    var document = window && window.document;
    var navigator = window && window.navigator;
    var localSessionStorage = function () {
        var x = 'qunit-test-string';
        try {
            global$1.sessionStorage.setItem(x, x);
            global$1.sessionStorage.removeItem(x);
            return global$1.sessionStorage;
        } catch (e) {
            return undefined;
        }
    }();
    var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
        return typeof obj;
    } : function (obj) {
        return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
    };
    var classCallCheck = function (instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError('Cannot call a class as a function');
        }
    };
    var createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor)
                    descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function (Constructor, protoProps, staticProps) {
            if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
                defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    var toConsumableArray = function (arr) {
        if (Array.isArray(arr)) {
            for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++)
                arr2[i] = arr[i];
            return arr2;
        } else {
            return Array.from(arr);
        }
    };
    var toString = Object.prototype.toString;
    var hasOwn = Object.prototype.hasOwnProperty;
    var now = Date.now || function () {
        return new Date().getTime();
    };
    var defined = {
        document: window && window.document !== undefined,
        setTimeout: setTimeout !== undefined
    };
    function diff(a, b) {
        var i, j, result = a.slice();
        for (i = 0; i < result.length; i++) {
            for (j = 0; j < b.length; j++) {
                if (result[i] === b[j]) {
                    result.splice(i, 1);
                    i--;
                    break;
                }
            }
        }
        return result;
    }
    function inArray(elem, array) {
        return array.indexOf(elem) !== -1;
    }
    function objectValues(obj) {
        var key, val, vals = is('array', obj) ? [] : {};
        for (key in obj) {
            if (hasOwn.call(obj, key)) {
                val = obj[key];
                vals[key] = val === Object(val) ? objectValues(val) : val;
            }
        }
        return vals;
    }
    function extend(a, b, undefOnly) {
        for (var prop in b) {
            if (hasOwn.call(b, prop)) {
                if (b[prop] === undefined) {
                    delete a[prop];
                } else if (!(undefOnly && typeof a[prop] !== 'undefined')) {
                    a[prop] = b[prop];
                }
            }
        }
        return a;
    }
    function objectType(obj) {
        if (typeof obj === 'undefined') {
            return 'undefined';
        }
        if (obj === null) {
            return 'null';
        }
        var match = toString.call(obj).match(/^\[object\s(.*)\]$/), type = match && match[1];
        switch (type) {
        case 'Number':
            if (isNaN(obj)) {
                return 'nan';
            }
            return 'number';
        case 'String':
        case 'Boolean':
        case 'Array':
        case 'Set':
        case 'Map':
        case 'Date':
        case 'RegExp':
        case 'Function':
        case 'Symbol':
            return type.toLowerCase();
        default:
            return typeof obj === 'undefined' ? 'undefined' : _typeof(obj);
        }
    }
    function is(type, obj) {
        return objectType(obj) === type;
    }
    function generateHash(module, testName) {
        var str = module + '\x1C' + testName;
        var hash = 0;
        for (var i = 0; i < str.length; i++) {
            hash = (hash << 5) - hash + str.charCodeAt(i);
            hash |= 0;
        }
        var hex = (4294967296 + hash).toString(16);
        if (hex.length < 8) {
            hex = '0000000' + hex;
        }
        return hex.slice(-8);
    }
    var equiv = function () {
        var pairs = [];
        var getProto = Object.getPrototypeOf || function (obj) {
            return obj.__proto__;
        };
        function useStrictEquality(a, b) {
            if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) === 'object') {
                a = a.valueOf();
            }
            if ((typeof b === 'undefined' ? 'undefined' : _typeof(b)) === 'object') {
                b = b.valueOf();
            }
            return a === b;
        }
        function compareConstructors(a, b) {
            var protoA = getProto(a);
            var protoB = getProto(b);
            if (a.constructor === b.constructor) {
                return true;
            }
            if (protoA && protoA.constructor === null) {
                protoA = null;
            }
            if (protoB && protoB.constructor === null) {
                protoB = null;
            }
            if (protoA === null && protoB === Object.prototype || protoB === null && protoA === Object.prototype) {
                return true;
            }
            return false;
        }
        function getRegExpFlags(regexp) {
            return 'flags' in regexp ? regexp.flags : regexp.toString().match(/[gimuy]*$/)[0];
        }
        function isContainer(val) {
            return [
                'object',
                'array',
                'map',
                'set'
            ].indexOf(objectType(val)) !== -1;
        }
        function breadthFirstCompareChild(a, b) {
            if (a === b) {
                return true;
            }
            if (!isContainer(a)) {
                return typeEquiv(a, b);
            }
            if (pairs.every(function (pair) {
                    return pair.a !== a || pair.b !== b;
                })) {
                pairs.push({
                    a: a,
                    b: b
                });
            }
            return true;
        }
        var callbacks = {
            'string': useStrictEquality,
            'boolean': useStrictEquality,
            'number': useStrictEquality,
            'null': useStrictEquality,
            'undefined': useStrictEquality,
            'symbol': useStrictEquality,
            'date': useStrictEquality,
            'nan': function nan() {
                return true;
            },
            'regexp': function regexp(a, b) {
                return a.source === b.source && getRegExpFlags(a) === getRegExpFlags(b);
            },
            'function': function _function() {
                return false;
            },
            'array': function array(a, b) {
                var i, len;
                len = a.length;
                if (len !== b.length) {
                    return false;
                }
                for (i = 0; i < len; i++) {
                    if (!breadthFirstCompareChild(a[i], b[i])) {
                        return false;
                    }
                }
                return true;
            },
            'set': function set$$1(a, b) {
                var innerEq, outerEq = true;
                if (a.size !== b.size) {
                    return false;
                }
                a.forEach(function (aVal) {
                    if (!outerEq) {
                        return;
                    }
                    innerEq = false;
                    b.forEach(function (bVal) {
                        var parentPairs;
                        if (innerEq) {
                            return;
                        }
                        parentPairs = pairs;
                        if (innerEquiv(bVal, aVal)) {
                            innerEq = true;
                        }
                        pairs = parentPairs;
                    });
                    if (!innerEq) {
                        outerEq = false;
                    }
                });
                return outerEq;
            },
            'map': function map(a, b) {
                var innerEq, outerEq = true;
                if (a.size !== b.size) {
                    return false;
                }
                a.forEach(function (aVal, aKey) {
                    if (!outerEq) {
                        return;
                    }
                    innerEq = false;
                    b.forEach(function (bVal, bKey) {
                        var parentPairs;
                        if (innerEq) {
                            return;
                        }
                        parentPairs = pairs;
                        if (innerEquiv([
                                bVal,
                                bKey
                            ], [
                                aVal,
                                aKey
                            ])) {
                            innerEq = true;
                        }
                        pairs = parentPairs;
                    });
                    if (!innerEq) {
                        outerEq = false;
                    }
                });
                return outerEq;
            },
            'object': function object(a, b) {
                var i, aProperties = [], bProperties = [];
                if (compareConstructors(a, b) === false) {
                    return false;
                }
                for (i in a) {
                    aProperties.push(i);
                    if (a.constructor !== Object && typeof a.constructor !== 'undefined' && typeof a[i] === 'function' && typeof b[i] === 'function' && a[i].toString() === b[i].toString()) {
                        continue;
                    }
                    if (!breadthFirstCompareChild(a[i], b[i])) {
                        return false;
                    }
                }
                for (i in b) {
                    bProperties.push(i);
                }
                return typeEquiv(aProperties.sort(), bProperties.sort());
            }
        };
        function typeEquiv(a, b) {
            var type = objectType(a);
            return objectType(b) === type && callbacks[type](a, b);
        }
        function innerEquiv(a, b) {
            var i, pair;
            if (arguments.length < 2) {
                return true;
            }
            pairs = [{
                    a: a,
                    b: b
                }];
            for (i = 0; i < pairs.length; i++) {
                pair = pairs[i];
                if (pair.a !== pair.b && !typeEquiv(pair.a, pair.b)) {
                    return false;
                }
            }
            return arguments.length === 2 || innerEquiv.apply(this, [].slice.call(arguments, 1));
        }
        return function () {
            var result = innerEquiv.apply(undefined, arguments);
            pairs.length = 0;
            return result;
        };
    }();
    var config = {
        queue: [],
        blocking: true,
        reorder: true,
        altertitle: true,
        collapse: true,
        scrolltop: true,
        maxDepth: 5,
        requireExpects: false,
        urlConfig: [],
        modules: [],
        currentModule: {
            name: '',
            tests: [],
            childModules: [],
            testsRun: 0,
            unskippedTestsRun: 0,
            hooks: {
                before: [],
                beforeEach: [],
                afterEach: [],
                after: []
            }
        },
        callbacks: {},
        storage: localSessionStorage
    };
    var globalConfig = window && window.QUnit && window.QUnit.config;
    if (window && window.QUnit && !window.QUnit.version) {
        extend(config, globalConfig);
    }
    config.modules.push(config.currentModule);
    var dump = function () {
        function quote(str) {
            return '"' + str.toString().replace(/\\/g, '\\\\').replace(/"/g, '\\"') + '"';
        }
        function literal(o) {
            return o + '';
        }
        function join(pre, arr, post) {
            var s = dump.separator(), base = dump.indent(), inner = dump.indent(1);
            if (arr.join) {
                arr = arr.join(',' + s + inner);
            }
            if (!arr) {
                return pre + post;
            }
            return [
                pre,
                inner + arr,
                base + post
            ].join(s);
        }
        function array(arr, stack) {
            var i = arr.length, ret = new Array(i);
            if (dump.maxDepth && dump.depth > dump.maxDepth) {
                return '[object Array]';
            }
            this.up();
            while (i--) {
                ret[i] = this.parse(arr[i], undefined, stack);
            }
            this.down();
            return join('[', ret, ']');
        }
        function isArray(obj) {
            return toString.call(obj) === '[object Array]' || typeof obj.length === 'number' && obj.item !== undefined && (obj.length ? obj.item(0) === obj[0] : obj.item(0) === null && obj[0] === undefined);
        }
        var reName = /^function (\w+)/, dump = {
                parse: function parse(obj, objType, stack) {
                    stack = stack || [];
                    var res, parser, parserType, objIndex = stack.indexOf(obj);
                    if (objIndex !== -1) {
                        return 'recursion(' + (objIndex - stack.length) + ')';
                    }
                    objType = objType || this.typeOf(obj);
                    parser = this.parsers[objType];
                    parserType = typeof parser === 'undefined' ? 'undefined' : _typeof(parser);
                    if (parserType === 'function') {
                        stack.push(obj);
                        res = parser.call(this, obj, stack);
                        stack.pop();
                        return res;
                    }
                    return parserType === 'string' ? parser : this.parsers.error;
                },
                typeOf: function typeOf(obj) {
                    var type;
                    if (obj === null) {
                        type = 'null';
                    } else if (typeof obj === 'undefined') {
                        type = 'undefined';
                    } else if (is('regexp', obj)) {
                        type = 'regexp';
                    } else if (is('date', obj)) {
                        type = 'date';
                    } else if (is('function', obj)) {
                        type = 'function';
                    } else if (obj.setInterval !== undefined && obj.document !== undefined && obj.nodeType === undefined) {
                        type = 'window';
                    } else if (obj.nodeType === 9) {
                        type = 'document';
                    } else if (obj.nodeType) {
                        type = 'node';
                    } else if (isArray(obj)) {
                        type = 'array';
                    } else if (obj.constructor === Error.prototype.constructor) {
                        type = 'error';
                    } else {
                        type = typeof obj === 'undefined' ? 'undefined' : _typeof(obj);
                    }
                    return type;
                },
                separator: function separator() {
                    if (this.multiline) {
                        return this.HTML ? '<br />' : '\n';
                    } else {
                        return this.HTML ? '&#160;' : ' ';
                    }
                },
                indent: function indent(extra) {
                    if (!this.multiline) {
                        return '';
                    }
                    var chr = this.indentChar;
                    if (this.HTML) {
                        chr = chr.replace(/\t/g, '   ').replace(/ /g, '&#160;');
                    }
                    return new Array(this.depth + (extra || 0)).join(chr);
                },
                up: function up(a) {
                    this.depth += a || 1;
                },
                down: function down(a) {
                    this.depth -= a || 1;
                },
                setParser: function setParser(name, parser) {
                    this.parsers[name] = parser;
                },
                quote: quote,
                literal: literal,
                join: join,
                depth: 1,
                maxDepth: config.maxDepth,
                parsers: {
                    window: '[Window]',
                    document: '[Document]',
                    error: function error(_error) {
                        return 'Error("' + _error.message + '")';
                    },
                    unknown: '[Unknown]',
                    'null': 'null',
                    'undefined': 'undefined',
                    'function': function _function(fn) {
                        var ret = 'function', name = 'name' in fn ? fn.name : (reName.exec(fn) || [])[1];
                        if (name) {
                            ret += ' ' + name;
                        }
                        ret += '(';
                        ret = [
                            ret,
                            dump.parse(fn, 'functionArgs'),
                            '){'
                        ].join('');
                        return join(ret, dump.parse(fn, 'functionCode'), '}');
                    },
                    array: array,
                    nodelist: array,
                    'arguments': array,
                    object: function object(map, stack) {
                        var keys, key, val, i, nonEnumerableProperties, ret = [];
                        if (dump.maxDepth && dump.depth > dump.maxDepth) {
                            return '[object Object]';
                        }
                        dump.up();
                        keys = [];
                        for (key in map) {
                            keys.push(key);
                        }
                        nonEnumerableProperties = [
                            'message',
                            'name'
                        ];
                        for (i in nonEnumerableProperties) {
                            key = nonEnumerableProperties[i];
                            if (key in map && !inArray(key, keys)) {
                                keys.push(key);
                            }
                        }
                        keys.sort();
                        for (i = 0; i < keys.length; i++) {
                            key = keys[i];
                            val = map[key];
                            ret.push(dump.parse(key, 'key') + ': ' + dump.parse(val, undefined, stack));
                        }
                        dump.down();
                        return join('{', ret, '}');
                    },
                    node: function node(_node) {
                        var len, i, val, open = dump.HTML ? '&lt;' : '<', close = dump.HTML ? '&gt;' : '>', tag = _node.nodeName.toLowerCase(), ret = open + tag, attrs = _node.attributes;
                        if (attrs) {
                            for (i = 0, len = attrs.length; i < len; i++) {
                                val = attrs[i].nodeValue;
                                if (val && val !== 'inherit') {
                                    ret += ' ' + attrs[i].nodeName + '=' + dump.parse(val, 'attribute');
                                }
                            }
                        }
                        ret += close;
                        if (_node.nodeType === 3 || _node.nodeType === 4) {
                            ret += _node.nodeValue;
                        }
                        return ret + open + '/' + tag + close;
                    },
                    functionArgs: function functionArgs(fn) {
                        var args, l = fn.length;
                        if (!l) {
                            return '';
                        }
                        args = new Array(l);
                        while (l--) {
                            args[l] = String.fromCharCode(97 + l);
                        }
                        return ' ' + args.join(', ') + ' ';
                    },
                    key: quote,
                    functionCode: '[code]',
                    attribute: quote,
                    string: quote,
                    date: quote,
                    regexp: literal,
                    number: literal,
                    'boolean': literal,
                    symbol: function symbol(sym) {
                        return sym.toString();
                    }
                },
                HTML: false,
                indentChar: '  ',
                multiline: true
            };
        return dump;
    }();
    var LISTENERS = Object.create(null);
    var SUPPORTED_EVENTS = [
        'runStart',
        'suiteStart',
        'testStart',
        'assertion',
        'testEnd',
        'suiteEnd',
        'runEnd'
    ];
    function emit(eventName, data) {
        if (objectType(eventName) !== 'string') {
            throw new TypeError('eventName must be a string when emitting an event');
        }
        var originalCallbacks = LISTENERS[eventName];
        var callbacks = originalCallbacks ? [].concat(toConsumableArray(originalCallbacks)) : [];
        for (var i = 0; i < callbacks.length; i++) {
            callbacks[i](data);
        }
    }
    function on(eventName, callback) {
        if (objectType(eventName) !== 'string') {
            throw new TypeError('eventName must be a string when registering a listener');
        } else if (!inArray(eventName, SUPPORTED_EVENTS)) {
            var events = SUPPORTED_EVENTS.join(', ');
            throw new Error('"' + eventName + '" is not a valid event; must be one of: ' + events + '.');
        } else if (objectType(callback) !== 'function') {
            throw new TypeError('callback must be a function when registering a listener');
        }
        if (!LISTENERS[eventName]) {
            LISTENERS[eventName] = [];
        }
        if (!inArray(callback, LISTENERS[eventName])) {
            LISTENERS[eventName].push(callback);
        }
    }
    function registerLoggingCallbacks(obj) {
        var i, l, key, callbackNames = [
                'begin',
                'done',
                'log',
                'testStart',
                'testDone',
                'moduleStart',
                'moduleDone'
            ];
        function registerLoggingCallback(key) {
            var loggingCallback = function loggingCallback(callback) {
                if (objectType(callback) !== 'function') {
                    throw new Error('QUnit logging methods require a callback function as their first parameters.');
                }
                config.callbacks[key].push(callback);
            };
            return loggingCallback;
        }
        for (i = 0, l = callbackNames.length; i < l; i++) {
            key = callbackNames[i];
            if (objectType(config.callbacks[key]) === 'undefined') {
                config.callbacks[key] = [];
            }
            obj[key] = registerLoggingCallback(key);
        }
    }
    function runLoggingCallbacks(key, args) {
        var i, l, callbacks;
        callbacks = config.callbacks[key];
        for (i = 0, l = callbacks.length; i < l; i++) {
            callbacks[i](args);
        }
    }
    var fileName = (sourceFromStacktrace(0) || '').replace(/(:\d+)+\)?/, '').replace(/.+\//, '');
    function extractStacktrace(e, offset) {
        offset = offset === undefined ? 4 : offset;
        var stack, include, i;
        if (e && e.stack) {
            stack = e.stack.split('\n');
            if (/^error$/i.test(stack[0])) {
                stack.shift();
            }
            if (fileName) {
                include = [];
                for (i = offset; i < stack.length; i++) {
                    if (stack[i].indexOf(fileName) !== -1) {
                        break;
                    }
                    include.push(stack[i]);
                }
                if (include.length) {
                    return include.join('\n');
                }
            }
            return stack[offset];
        }
    }
    function sourceFromStacktrace(offset) {
        var error = new Error();
        if (!error.stack) {
            try {
                throw error;
            } catch (err) {
                error = err;
            }
        }
        return extractStacktrace(error, offset);
    }
    var priorityCount = 0;
    var unitSampler = void 0;
    function advance() {
        var start = now();
        config.depth = (config.depth || 0) + 1;
        while (config.queue.length && !config.blocking) {
            var elapsedTime = now() - start;
            if (!defined.setTimeout || config.updateRate <= 0 || elapsedTime < config.updateRate) {
                if (priorityCount > 0) {
                    priorityCount--;
                }
                config.queue.shift()();
            } else {
                setTimeout(advance, 13);
                break;
            }
        }
        config.depth--;
        if (!config.blocking && !config.queue.length && config.depth === 0) {
            done();
        }
    }
    function addToQueueImmediate(callback) {
        if (objectType(callback) === 'array') {
            while (callback.length) {
                addToQueueImmediate(callback.pop());
            }
            return;
        }
        config.queue.unshift(callback);
        priorityCount++;
    }
    function addToQueue(callback, prioritize, seed) {
        if (prioritize) {
            config.queue.splice(priorityCount++, 0, callback);
        } else if (seed) {
            if (!unitSampler) {
                unitSampler = unitSamplerGenerator(seed);
            }
            var index = Math.floor(unitSampler() * (config.queue.length - priorityCount + 1));
            config.queue.splice(priorityCount + index, 0, callback);
        } else {
            config.queue.push(callback);
        }
    }
    function unitSamplerGenerator(seed) {
        var sample = parseInt(generateHash(seed), 16) || -1;
        return function () {
            sample ^= sample << 13;
            sample ^= sample >>> 17;
            sample ^= sample << 5;
            if (sample < 0) {
                sample += 4294967296;
            }
            return sample / 4294967296;
        };
    }
    function done() {
        var storage = config.storage;
        ProcessingQueue.finished = true;
        var runtime = now() - config.started;
        var passed = config.stats.all - config.stats.bad;
        emit('runEnd', globalSuite.end(true));
        runLoggingCallbacks('done', {
            passed: passed,
            failed: config.stats.bad,
            total: config.stats.all,
            runtime: runtime
        });
        if (storage && config.stats.bad === 0) {
            for (var i = storage.length - 1; i >= 0; i--) {
                var key = storage.key(i);
                if (key.indexOf('qunit-test-') === 0) {
                    storage.removeItem(key);
                }
            }
        }
    }
    var ProcessingQueue = {
        finished: false,
        add: addToQueue,
        addImmediate: addToQueueImmediate,
        advance: advance
    };
    var TestReport = function () {
        function TestReport(name, suite, options) {
            classCallCheck(this, TestReport);
            this.name = name;
            this.suiteName = suite.name;
            this.fullName = suite.fullName.concat(name);
            this.runtime = 0;
            this.assertions = [];
            this.skipped = !!options.skip;
            this.todo = !!options.todo;
            this.valid = options.valid;
            this._startTime = 0;
            this._endTime = 0;
            suite.pushTest(this);
        }
        createClass(TestReport, [
            {
                key: 'start',
                value: function start(recordTime) {
                    if (recordTime) {
                        this._startTime = Date.now();
                    }
                    return {
                        name: this.name,
                        suiteName: this.suiteName,
                        fullName: this.fullName.slice()
                    };
                }
            },
            {
                key: 'end',
                value: function end(recordTime) {
                    if (recordTime) {
                        this._endTime = Date.now();
                    }
                    return extend(this.start(), {
                        runtime: this.getRuntime(),
                        status: this.getStatus(),
                        errors: this.getFailedAssertions(),
                        assertions: this.getAssertions()
                    });
                }
            },
            {
                key: 'pushAssertion',
                value: function pushAssertion(assertion) {
                    this.assertions.push(assertion);
                }
            },
            {
                key: 'getRuntime',
                value: function getRuntime() {
                    return this._endTime - this._startTime;
                }
            },
            {
                key: 'getStatus',
                value: function getStatus() {
                    if (this.skipped) {
                        return 'skipped';
                    }
                    var testPassed = this.getFailedAssertions().length > 0 ? this.todo : !this.todo;
                    if (!testPassed) {
                        return 'failed';
                    } else if (this.todo) {
                        return 'todo';
                    } else {
                        return 'passed';
                    }
                }
            },
            {
                key: 'getFailedAssertions',
                value: function getFailedAssertions() {
                    return this.assertions.filter(function (assertion) {
                        return !assertion.passed;
                    });
                }
            },
            {
                key: 'getAssertions',
                value: function getAssertions() {
                    return this.assertions.slice();
                }
            },
            {
                key: 'slimAssertions',
                value: function slimAssertions() {
                    this.assertions = this.assertions.map(function (assertion) {
                        delete assertion.actual;
                        delete assertion.expected;
                        return assertion;
                    });
                }
            }
        ]);
        return TestReport;
    }();
    var focused$1 = false;
    function Test(settings) {
        var i, l;
        ++Test.count;
        this.expected = null;
        this.assertions = [];
        this.semaphore = 0;
        this.module = config.currentModule;
        this.stack = sourceFromStacktrace(3);
        this.steps = [];
        this.timeout = undefined;
        if (this.module.skip) {
            settings.skip = true;
            settings.todo = false;
        } else if (this.module.todo && !settings.skip) {
            settings.todo = true;
        }
        extend(this, settings);
        this.testReport = new TestReport(settings.testName, this.module.suiteReport, {
            todo: settings.todo,
            skip: settings.skip,
            valid: this.valid()
        });
        for (i = 0, l = this.module.tests; i < l.length; i++) {
            if (this.module.tests[i].name === this.testName) {
                this.testName += ' ';
            }
        }
        this.testId = generateHash(this.module.name, this.testName);
        this.module.tests.push({
            name: this.testName,
            testId: this.testId,
            skip: !!settings.skip
        });
        if (settings.skip) {
            this.callback = function () {
            };
            this.async = false;
            this.expected = 0;
        } else {
            if (typeof this.callback !== 'function') {
                var method = this.todo ? 'todo' : 'test';
                throw new TypeError('You must provide a function as a test callback to QUnit.' + method + '("' + settings.testName + '")');
            }
            this.assert = new Assert(this);
        }
    }
    Test.count = 0;
    function getNotStartedModules(startModule) {
        var module = startModule, modules = [];
        while (module && module.testsRun === 0) {
            modules.push(module);
            module = module.parentModule;
        }
        return modules;
    }
    Test.prototype = {
        before: function before() {
            var i, startModule, module = this.module, notStartedModules = getNotStartedModules(module);
            for (i = notStartedModules.length - 1; i >= 0; i--) {
                startModule = notStartedModules[i];
                startModule.stats = {
                    all: 0,
                    bad: 0,
                    started: now()
                };
                emit('suiteStart', startModule.suiteReport.start(true));
                runLoggingCallbacks('moduleStart', {
                    name: startModule.name,
                    tests: startModule.tests
                });
            }
            config.current = this;
            this.testEnvironment = extend({}, module.testEnvironment);
            this.started = now();
            emit('testStart', this.testReport.start(true));
            runLoggingCallbacks('testStart', {
                name: this.testName,
                module: module.name,
                testId: this.testId,
                previousFailure: this.previousFailure
            });
            if (!config.pollution) {
                saveGlobal();
            }
        },
        run: function run() {
            var promise;
            config.current = this;
            this.callbackStarted = now();
            if (config.notrycatch) {
                runTest(this);
                return;
            }
            try {
                runTest(this);
            } catch (e) {
                this.pushFailure('Died on test #' + (this.assertions.length + 1) + ' ' + this.stack + ': ' + (e.message || e), extractStacktrace(e, 0));
                saveGlobal();
                if (config.blocking) {
                    internalRecover(this);
                }
            }
            function runTest(test) {
                promise = test.callback.call(test.testEnvironment, test.assert);
                test.resolvePromise(promise);
                if (test.timeout === 0 && test.semaphore !== 0) {
                    pushFailure('Test did not finish synchronously even though assert.timeout( 0 ) was used.', sourceFromStacktrace(2));
                }
            }
        },
        after: function after() {
            checkPollution();
        },
        queueHook: function queueHook(hook, hookName, hookOwner) {
            var _this = this;
            var callHook = function callHook() {
                var promise = hook.call(_this.testEnvironment, _this.assert);
                _this.resolvePromise(promise, hookName);
            };
            var runHook = function runHook() {
                if (hookName === 'before') {
                    if (hookOwner.unskippedTestsRun !== 0) {
                        return;
                    }
                    _this.preserveEnvironment = true;
                }
                if (hookName === 'after' && hookOwner.unskippedTestsRun !== numberOfUnskippedTests(hookOwner) - 1 && config.queue.length > 2) {
                    return;
                }
                config.current = _this;
                if (config.notrycatch) {
                    callHook();
                    return;
                }
                try {
                    callHook();
                } catch (error) {
                    _this.pushFailure(hookName + ' failed on ' + _this.testName + ': ' + (error.message || error), extractStacktrace(error, 0));
                }
            };
            return runHook;
        },
        hooks: function hooks(handler) {
            var hooks = [];
            function processHooks(test, module) {
                if (module.parentModule) {
                    processHooks(test, module.parentModule);
                }
                if (module.hooks[handler].length) {
                    for (var i = 0; i < module.hooks[handler].length; i++) {
                        hooks.push(test.queueHook(module.hooks[handler][i], handler, module));
                    }
                }
            }
            if (!this.skip) {
                processHooks(this, this.module);
            }
            return hooks;
        },
        finish: function finish() {
            config.current = this;
            if (config.requireExpects && this.expected === null) {
                this.pushFailure('Expected number of assertions to be defined, but expect() was ' + 'not called.', this.stack);
            } else if (this.expected !== null && this.expected !== this.assertions.length) {
                this.pushFailure('Expected ' + this.expected + ' assertions, but ' + this.assertions.length + ' were run', this.stack);
            } else if (this.expected === null && !this.assertions.length) {
                this.pushFailure('Expected at least one assertion, but none were run - call ' + 'expect(0) to accept zero assertions.', this.stack);
            }
            var i, module = this.module, moduleName = module.name, testName = this.testName, skipped = !!this.skip, todo = !!this.todo, bad = 0, storage = config.storage;
            this.runtime = now() - this.started;
            config.stats.all += this.assertions.length;
            module.stats.all += this.assertions.length;
            for (i = 0; i < this.assertions.length; i++) {
                if (!this.assertions[i].result) {
                    bad++;
                    config.stats.bad++;
                    module.stats.bad++;
                }
            }
            notifyTestsRan(module, skipped);
            if (storage) {
                if (bad) {
                    storage.setItem('qunit-test-' + moduleName + '-' + testName, bad);
                } else {
                    storage.removeItem('qunit-test-' + moduleName + '-' + testName);
                }
            }
            emit('testEnd', this.testReport.end(true));
            this.testReport.slimAssertions();
            runLoggingCallbacks('testDone', {
                name: testName,
                module: moduleName,
                skipped: skipped,
                todo: todo,
                failed: bad,
                passed: this.assertions.length - bad,
                total: this.assertions.length,
                runtime: skipped ? 0 : this.runtime,
                assertions: this.assertions,
                testId: this.testId,
                source: this.stack
            });
            if (module.testsRun === numberOfTests(module)) {
                logSuiteEnd(module);
                var parent = module.parentModule;
                while (parent && parent.testsRun === numberOfTests(parent)) {
                    logSuiteEnd(parent);
                    parent = parent.parentModule;
                }
            }
            config.current = undefined;
            function logSuiteEnd(module) {
                emit('suiteEnd', module.suiteReport.end(true));
                runLoggingCallbacks('moduleDone', {
                    name: module.name,
                    tests: module.tests,
                    failed: module.stats.bad,
                    passed: module.stats.all - module.stats.bad,
                    total: module.stats.all,
                    runtime: now() - module.stats.started
                });
            }
        },
        preserveTestEnvironment: function preserveTestEnvironment() {
            if (this.preserveEnvironment) {
                this.module.testEnvironment = this.testEnvironment;
                this.testEnvironment = extend({}, this.module.testEnvironment);
            }
        },
        queue: function queue() {
            var test = this;
            if (!this.valid()) {
                return;
            }
            function runTest() {
                ProcessingQueue.addImmediate([
                    function () {
                        test.before();
                    },
                    test.hooks('before'),
                    function () {
                        test.preserveTestEnvironment();
                    },
                    test.hooks('beforeEach'),
                    function () {
                        test.run();
                    },
                    test.hooks('afterEach').reverse(),
                    test.hooks('after').reverse(),
                    function () {
                        test.after();
                    },
                    function () {
                        test.finish();
                    }
                ]);
            }
            var previousFailCount = config.storage && +config.storage.getItem('qunit-test-' + this.module.name + '-' + this.testName);
            var prioritize = config.reorder && !!previousFailCount;
            this.previousFailure = !!previousFailCount;
            ProcessingQueue.add(runTest, prioritize, config.seed);
            if (ProcessingQueue.finished) {
                ProcessingQueue.advance();
            }
        },
        pushResult: function pushResult(resultInfo) {
            if (this !== config.current) {
                throw new Error('Assertion occured after test had finished.');
            }
            var source, details = {
                    module: this.module.name,
                    name: this.testName,
                    result: resultInfo.result,
                    message: resultInfo.message,
                    actual: resultInfo.actual,
                    testId: this.testId,
                    negative: resultInfo.negative || false,
                    runtime: now() - this.started,
                    todo: !!this.todo
                };
            if (hasOwn.call(resultInfo, 'expected')) {
                details.expected = resultInfo.expected;
            }
            if (!resultInfo.result) {
                source = resultInfo.source || sourceFromStacktrace();
                if (source) {
                    details.source = source;
                }
            }
            this.logAssertion(details);
            this.assertions.push({
                result: !!resultInfo.result,
                message: resultInfo.message
            });
        },
        pushFailure: function pushFailure(message, source, actual) {
            if (!(this instanceof Test)) {
                throw new Error('pushFailure() assertion outside test context, was ' + sourceFromStacktrace(2));
            }
            this.pushResult({
                result: false,
                message: message || 'error',
                actual: actual || null,
                source: source
            });
        },
        logAssertion: function logAssertion(details) {
            runLoggingCallbacks('log', details);
            var assertion = {
                passed: details.result,
                actual: details.actual,
                expected: details.expected,
                message: details.message,
                stack: details.source,
                todo: details.todo
            };
            this.testReport.pushAssertion(assertion);
            emit('assertion', assertion);
        },
        resolvePromise: function resolvePromise(promise, phase) {
            var then, resume, message, test = this;
            if (promise != null) {
                then = promise.then;
                if (objectType(then) === 'function') {
                    resume = internalStop(test);
                    then.call(promise, function () {
                        resume();
                    }, function (error) {
                        message = 'Promise rejected ' + (!phase ? 'during' : phase.replace(/Each$/, '')) + ' "' + test.testName + '": ' + (error && error.message || error);
                        test.pushFailure(message, extractStacktrace(error, 0));
                        saveGlobal();
                        resume();
                    });
                }
            }
        },
        valid: function valid() {
            var filter = config.filter, regexFilter = /^(!?)\/([\w\W]*)\/(i?$)/.exec(filter), module = config.module && config.module.toLowerCase(), fullName = this.module.name + ': ' + this.testName;
            function moduleChainNameMatch(testModule) {
                var testModuleName = testModule.name ? testModule.name.toLowerCase() : null;
                if (testModuleName === module) {
                    return true;
                } else if (testModule.parentModule) {
                    return moduleChainNameMatch(testModule.parentModule);
                } else {
                    return false;
                }
            }
            function moduleChainIdMatch(testModule) {
                return inArray(testModule.moduleId, config.moduleId) || testModule.parentModule && moduleChainIdMatch(testModule.parentModule);
            }
            if (this.callback && this.callback.validTest) {
                return true;
            }
            if (config.moduleId && config.moduleId.length > 0 && !moduleChainIdMatch(this.module)) {
                return false;
            }
            if (config.testId && config.testId.length > 0 && !inArray(this.testId, config.testId)) {
                return false;
            }
            if (module && !moduleChainNameMatch(this.module)) {
                return false;
            }
            if (!filter) {
                return true;
            }
            return regexFilter ? this.regexFilter(!!regexFilter[1], regexFilter[2], regexFilter[3], fullName) : this.stringFilter(filter, fullName);
        },
        regexFilter: function regexFilter(exclude, pattern, flags, fullName) {
            var regex = new RegExp(pattern, flags);
            var match = regex.test(fullName);
            return match !== exclude;
        },
        stringFilter: function stringFilter(filter, fullName) {
            filter = filter.toLowerCase();
            fullName = fullName.toLowerCase();
            var include = filter.charAt(0) !== '!';
            if (!include) {
                filter = filter.slice(1);
            }
            if (fullName.indexOf(filter) !== -1) {
                return include;
            }
            return !include;
        }
    };
    function pushFailure() {
        if (!config.current) {
            throw new Error('pushFailure() assertion outside test context, in ' + sourceFromStacktrace(2));
        }
        var currentTest = config.current;
        return currentTest.pushFailure.apply(currentTest, arguments);
    }
    function saveGlobal() {
        config.pollution = [];
        if (config.noglobals) {
            for (var key in global$1) {
                if (hasOwn.call(global$1, key)) {
                    if (/^qunit-test-output/.test(key)) {
                        continue;
                    }
                    config.pollution.push(key);
                }
            }
        }
    }
    function checkPollution() {
        var newGlobals, deletedGlobals, old = config.pollution;
        saveGlobal();
        newGlobals = diff(config.pollution, old);
        if (newGlobals.length > 0) {
            pushFailure('Introduced global variable(s): ' + newGlobals.join(', '));
        }
        deletedGlobals = diff(old, config.pollution);
        if (deletedGlobals.length > 0) {
            pushFailure('Deleted global variable(s): ' + deletedGlobals.join(', '));
        }
    }
    function test(testName, callback) {
        if (focused$1) {
            return;
        }
        var newTest = new Test({
            testName: testName,
            callback: callback
        });
        newTest.queue();
    }
    function todo(testName, callback) {
        if (focused$1) {
            return;
        }
        var newTest = new Test({
            testName: testName,
            callback: callback,
            todo: true
        });
        newTest.queue();
    }
    function skip(testName) {
        if (focused$1) {
            return;
        }
        var test = new Test({
            testName: testName,
            skip: true
        });
        test.queue();
    }
    function only(testName, callback) {
        if (focused$1) {
            return;
        }
        config.queue.length = 0;
        focused$1 = true;
        var newTest = new Test({
            testName: testName,
            callback: callback
        });
        newTest.queue();
    }
    function internalStop(test) {
        test.semaphore += 1;
        config.blocking = true;
        if (defined.setTimeout) {
            var timeoutDuration = void 0;
            if (typeof test.timeout === 'number') {
                timeoutDuration = test.timeout;
            } else if (typeof config.testTimeout === 'number') {
                timeoutDuration = config.testTimeout;
            }
            if (typeof timeoutDuration === 'number' && timeoutDuration > 0) {
                clearTimeout(config.timeout);
                config.timeout = setTimeout(function () {
                    pushFailure('Test took longer than ' + timeoutDuration + 'ms; test timed out.', sourceFromStacktrace(2));
                    internalRecover(test);
                }, timeoutDuration);
            }
        }
        var released = false;
        return function resume() {
            if (released) {
                return;
            }
            released = true;
            test.semaphore -= 1;
            internalStart(test);
        };
    }
    function internalRecover(test) {
        test.semaphore = 0;
        internalStart(test);
    }
    function internalStart(test) {
        if (isNaN(test.semaphore)) {
            test.semaphore = 0;
            pushFailure('Invalid value on test.semaphore', sourceFromStacktrace(2));
            return;
        }
        if (test.semaphore > 0) {
            return;
        }
        if (test.semaphore < 0) {
            test.semaphore = 0;
            pushFailure('Tried to restart test while already started (test\'s semaphore was 0 already)', sourceFromStacktrace(2));
            return;
        }
        if (defined.setTimeout) {
            if (config.timeout) {
                clearTimeout(config.timeout);
            }
            config.timeout = setTimeout(function () {
                if (test.semaphore > 0) {
                    return;
                }
                if (config.timeout) {
                    clearTimeout(config.timeout);
                }
                begin();
            }, 13);
        } else {
            begin();
        }
    }
    function collectTests(module) {
        var tests = [].concat(module.tests);
        var modules = [].concat(toConsumableArray(module.childModules));
        while (modules.length) {
            var nextModule = modules.shift();
            tests.push.apply(tests, nextModule.tests);
            modules.push.apply(modules, toConsumableArray(nextModule.childModules));
        }
        return tests;
    }
    function numberOfTests(module) {
        return collectTests(module).length;
    }
    function numberOfUnskippedTests(module) {
        return collectTests(module).filter(function (test) {
            return !test.skip;
        }).length;
    }
    function notifyTestsRan(module, skipped) {
        module.testsRun++;
        if (!skipped) {
            module.unskippedTestsRun++;
        }
        while (module = module.parentModule) {
            module.testsRun++;
            if (!skipped) {
                module.unskippedTestsRun++;
            }
        }
    }
    function consoleProxy(method) {
        return function () {
            if (console) {
                console[method].apply(console, arguments);
            }
        };
    }
    var Logger = { warn: consoleProxy('warn') };
    var Assert = function () {
        function Assert(testContext) {
            classCallCheck(this, Assert);
            this.test = testContext;
        }
        createClass(Assert, [
            {
                key: 'timeout',
                value: function timeout(duration) {
                    if (typeof duration !== 'number') {
                        throw new Error('You must pass a number as the duration to assert.timeout');
                    }
                    this.test.timeout = duration;
                }
            },
            {
                key: 'step',
                value: function step(message) {
                    var result = !!message;
                    this.test.steps.push(message);
                    return this.pushResult({
                        result: result,
                        message: message || 'You must provide a message to assert.step'
                    });
                }
            },
            {
                key: 'verifySteps',
                value: function verifySteps(steps, message) {
                    this.deepEqual(this.test.steps, steps, message);
                }
            },
            {
                key: 'expect',
                value: function expect(asserts) {
                    if (arguments.length === 1) {
                        this.test.expected = asserts;
                    } else {
                        return this.test.expected;
                    }
                }
            },
            {
                key: 'async',
                value: function async(count) {
                    var test$$1 = this.test;
                    var popped = false, acceptCallCount = count;
                    if (typeof acceptCallCount === 'undefined') {
                        acceptCallCount = 1;
                    }
                    var resume = internalStop(test$$1);
                    return function done() {
                        if (config.current !== test$$1) {
                            throw Error('assert.async callback called after test finished.');
                        }
                        if (popped) {
                            test$$1.pushFailure('Too many calls to the `assert.async` callback', sourceFromStacktrace(2));
                            return;
                        }
                        acceptCallCount -= 1;
                        if (acceptCallCount > 0) {
                            return;
                        }
                        popped = true;
                        resume();
                    };
                }
            },
            {
                key: 'push',
                value: function push(result, actual, expected, message, negative) {
                    Logger.warn('assert.push is deprecated and will be removed in QUnit 3.0.' + ' Please use assert.pushResult instead (https://api.qunitjs.com/assert/pushResult).');
                    var currentAssert = this instanceof Assert ? this : config.current.assert;
                    return currentAssert.pushResult({
                        result: result,
                        actual: actual,
                        expected: expected,
                        message: message,
                        negative: negative
                    });
                }
            },
            {
                key: 'pushResult',
                value: function pushResult(resultInfo) {
                    var assert = this;
                    var currentTest = assert instanceof Assert && assert.test || config.current;
                    if (!currentTest) {
                        throw new Error('assertion outside test context, in ' + sourceFromStacktrace(2));
                    }
                    if (!(assert instanceof Assert)) {
                        assert = currentTest.assert;
                    }
                    return assert.test.pushResult(resultInfo);
                }
            },
            {
                key: 'ok',
                value: function ok(result, message) {
                    if (!message) {
                        message = result ? 'okay' : 'failed, expected argument to be truthy, was: ' + dump.parse(result);
                    }
                    this.pushResult({
                        result: !!result,
                        actual: result,
                        expected: true,
                        message: message
                    });
                }
            },
            {
                key: 'notOk',
                value: function notOk(result, message) {
                    if (!message) {
                        message = !result ? 'okay' : 'failed, expected argument to be falsy, was: ' + dump.parse(result);
                    }
                    this.pushResult({
                        result: !result,
                        actual: result,
                        expected: false,
                        message: message
                    });
                }
            },
            {
                key: 'equal',
                value: function equal(actual, expected, message) {
                    var result = expected == actual;
                    this.pushResult({
                        result: result,
                        actual: actual,
                        expected: expected,
                        message: message
                    });
                }
            },
            {
                key: 'notEqual',
                value: function notEqual(actual, expected, message) {
                    var result = expected != actual;
                    this.pushResult({
                        result: result,
                        actual: actual,
                        expected: expected,
                        message: message,
                        negative: true
                    });
                }
            },
            {
                key: 'propEqual',
                value: function propEqual(actual, expected, message) {
                    actual = objectValues(actual);
                    expected = objectValues(expected);
                    this.pushResult({
                        result: equiv(actual, expected),
                        actual: actual,
                        expected: expected,
                        message: message
                    });
                }
            },
            {
                key: 'notPropEqual',
                value: function notPropEqual(actual, expected, message) {
                    actual = objectValues(actual);
                    expected = objectValues(expected);
                    this.pushResult({
                        result: !equiv(actual, expected),
                        actual: actual,
                        expected: expected,
                        message: message,
                        negative: true
                    });
                }
            },
            {
                key: 'deepEqual',
                value: function deepEqual(actual, expected, message) {
                    this.pushResult({
                        result: equiv(actual, expected),
                        actual: actual,
                        expected: expected,
                        message: message
                    });
                }
            },
            {
                key: 'notDeepEqual',
                value: function notDeepEqual(actual, expected, message) {
                    this.pushResult({
                        result: !equiv(actual, expected),
                        actual: actual,
                        expected: expected,
                        message: message,
                        negative: true
                    });
                }
            },
            {
                key: 'strictEqual',
                value: function strictEqual(actual, expected, message) {
                    this.pushResult({
                        result: expected === actual,
                        actual: actual,
                        expected: expected,
                        message: message
                    });
                }
            },
            {
                key: 'notStrictEqual',
                value: function notStrictEqual(actual, expected, message) {
                    this.pushResult({
                        result: expected !== actual,
                        actual: actual,
                        expected: expected,
                        message: message,
                        negative: true
                    });
                }
            },
            {
                key: 'throws',
                value: function throws(block, expected, message) {
                    var actual = void 0, result = false;
                    var currentTest = this instanceof Assert && this.test || config.current;
                    if (objectType(expected) === 'string') {
                        if (message == null) {
                            message = expected;
                            expected = null;
                        } else {
                            throw new Error('throws/raises does not accept a string value for the expected argument.\n' + 'Use a non-string object value (e.g. regExp) instead if it\'s necessary.');
                        }
                    }
                    currentTest.ignoreGlobalErrors = true;
                    try {
                        block.call(currentTest.testEnvironment);
                    } catch (e) {
                        actual = e;
                    }
                    currentTest.ignoreGlobalErrors = false;
                    if (actual) {
                        var expectedType = objectType(expected);
                        if (!expected) {
                            result = true;
                            expected = null;
                        } else if (expectedType === 'regexp') {
                            result = expected.test(errorString(actual));
                        } else if (expectedType === 'function' && actual instanceof expected) {
                            result = true;
                        } else if (expectedType === 'object') {
                            result = actual instanceof expected.constructor && actual.name === expected.name && actual.message === expected.message;
                        } else if (expectedType === 'function' && expected.call({}, actual) === true) {
                            expected = null;
                            result = true;
                        }
                    }
                    currentTest.assert.pushResult({
                        result: result,
                        actual: actual,
                        expected: expected,
                        message: message
                    });
                }
            }
        ]);
        return Assert;
    }();
    Assert.prototype.raises = Assert.prototype['throws'];
    function errorString(error) {
        var resultErrorString = error.toString();
        if (resultErrorString.substring(0, 7) === '[object') {
            var name = error.name ? error.name.toString() : 'Error';
            var message = error.message ? error.message.toString() : '';
            if (name && message) {
                return name + ': ' + message;
            } else if (name) {
                return name;
            } else if (message) {
                return message;
            } else {
                return 'Error';
            }
        } else {
            return resultErrorString;
        }
    }
    function exportQUnit(QUnit) {
        if (defined.document) {
            if (window.QUnit && window.QUnit.version) {
                throw new Error('QUnit has already been defined.');
            }
            window.QUnit = QUnit;
        }
        if (typeof module !== 'undefined' && module && module.exports) {
            module.exports = QUnit;
            module.exports.QUnit = QUnit;
        }
        if (typeof exports !== 'undefined' && exports) {
            exports.QUnit = QUnit;
        }
        if (typeof define === 'function' && define.amd) {
            define('qunitjs@2.4.1#qunit/qunit', function () {
                return QUnit;
            });
            QUnit.config.autostart = false;
        }
        if (self$1 && self$1.WorkerGlobalScope && self$1 instanceof self$1.WorkerGlobalScope) {
            self$1.QUnit = QUnit;
        }
    }
    var SuiteReport = function () {
        function SuiteReport(name, parentSuite) {
            classCallCheck(this, SuiteReport);
            this.name = name;
            this.fullName = parentSuite ? parentSuite.fullName.concat(name) : [];
            this.tests = [];
            this.childSuites = [];
            if (parentSuite) {
                parentSuite.pushChildSuite(this);
            }
        }
        createClass(SuiteReport, [
            {
                key: 'start',
                value: function start(recordTime) {
                    if (recordTime) {
                        this._startTime = Date.now();
                    }
                    return {
                        name: this.name,
                        fullName: this.fullName.slice(),
                        tests: this.tests.map(function (test) {
                            return test.start();
                        }),
                        childSuites: this.childSuites.map(function (suite) {
                            return suite.start();
                        }),
                        testCounts: { total: this.getTestCounts().total }
                    };
                }
            },
            {
                key: 'end',
                value: function end(recordTime) {
                    if (recordTime) {
                        this._endTime = Date.now();
                    }
                    return {
                        name: this.name,
                        fullName: this.fullName.slice(),
                        tests: this.tests.map(function (test) {
                            return test.end();
                        }),
                        childSuites: this.childSuites.map(function (suite) {
                            return suite.end();
                        }),
                        testCounts: this.getTestCounts(),
                        runtime: this.getRuntime(),
                        status: this.getStatus()
                    };
                }
            },
            {
                key: 'pushChildSuite',
                value: function pushChildSuite(suite) {
                    this.childSuites.push(suite);
                }
            },
            {
                key: 'pushTest',
                value: function pushTest(test) {
                    this.tests.push(test);
                }
            },
            {
                key: 'getRuntime',
                value: function getRuntime() {
                    return this._endTime - this._startTime;
                }
            },
            {
                key: 'getTestCounts',
                value: function getTestCounts() {
                    var counts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
                        passed: 0,
                        failed: 0,
                        skipped: 0,
                        todo: 0,
                        total: 0
                    };
                    counts = this.tests.reduce(function (counts, test) {
                        if (test.valid) {
                            counts[test.getStatus()]++;
                            counts.total++;
                        }
                        return counts;
                    }, counts);
                    return this.childSuites.reduce(function (counts, suite) {
                        return suite.getTestCounts(counts);
                    }, counts);
                }
            },
            {
                key: 'getStatus',
                value: function getStatus() {
                    var _getTestCounts = this.getTestCounts(), total = _getTestCounts.total, failed = _getTestCounts.failed, skipped = _getTestCounts.skipped, todo = _getTestCounts.todo;
                    if (failed) {
                        return 'failed';
                    } else {
                        if (skipped === total) {
                            return 'skipped';
                        } else if (todo === total) {
                            return 'todo';
                        } else {
                            return 'passed';
                        }
                    }
                }
            }
        ]);
        return SuiteReport;
    }();
    function onError(error) {
        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
        }
        if (config.current) {
            if (config.current.ignoreGlobalErrors) {
                return true;
            }
            pushFailure.apply(undefined, [
                error.message,
                error.fileName + ':' + error.lineNumber
            ].concat(args));
        } else {
            test('global failure', extend(function () {
                pushFailure.apply(undefined, [
                    error.message,
                    error.fileName + ':' + error.lineNumber
                ].concat(args));
            }, { validTest: true }));
        }
        return false;
    }
    var focused = false;
    var QUnit = {};
    var globalSuite = new SuiteReport();
    config.currentModule.suiteReport = globalSuite;
    var moduleStack = [];
    var globalStartCalled = false;
    var runStarted = false;
    QUnit.isLocal = !(defined.document && window.location.protocol !== 'file:');
    QUnit.version = '2.4.1';
    function createModule(name, testEnvironment, modifiers) {
        var parentModule = moduleStack.length ? moduleStack.slice(-1)[0] : null;
        var moduleName = parentModule !== null ? [
            parentModule.name,
            name
        ].join(' > ') : name;
        var parentSuite = parentModule ? parentModule.suiteReport : globalSuite;
        var skip$$1 = parentModule !== null && parentModule.skip || modifiers.skip;
        var todo$$1 = parentModule !== null && parentModule.todo || modifiers.todo;
        var module = {
            name: moduleName,
            parentModule: parentModule,
            tests: [],
            moduleId: generateHash(moduleName),
            testsRun: 0,
            unskippedTestsRun: 0,
            childModules: [],
            suiteReport: new SuiteReport(name, parentSuite),
            skip: skip$$1,
            todo: skip$$1 ? false : todo$$1
        };
        var env = {};
        if (parentModule) {
            parentModule.childModules.push(module);
            extend(env, parentModule.testEnvironment);
        }
        extend(env, testEnvironment);
        module.testEnvironment = env;
        config.modules.push(module);
        return module;
    }
    function processModule(name, options, executeNow) {
        var modifiers = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
        var module = createModule(name, options, modifiers);
        var testEnvironment = module.testEnvironment;
        var hooks = module.hooks = {};
        setHookFromEnvironment(hooks, testEnvironment, 'before');
        setHookFromEnvironment(hooks, testEnvironment, 'beforeEach');
        setHookFromEnvironment(hooks, testEnvironment, 'afterEach');
        setHookFromEnvironment(hooks, testEnvironment, 'after');
        function setHookFromEnvironment(hooks, environment, name) {
            var potentialHook = environment[name];
            hooks[name] = typeof potentialHook === 'function' ? [potentialHook] : [];
            delete environment[name];
        }
        var moduleFns = {
            before: setHookFunction(module, 'before'),
            beforeEach: setHookFunction(module, 'beforeEach'),
            afterEach: setHookFunction(module, 'afterEach'),
            after: setHookFunction(module, 'after')
        };
        var currentModule = config.currentModule;
        if (objectType(executeNow) === 'function') {
            moduleStack.push(module);
            config.currentModule = module;
            executeNow.call(module.testEnvironment, moduleFns);
            moduleStack.pop();
            module = module.parentModule || currentModule;
        }
        config.currentModule = module;
    }
    function module$1(name, options, executeNow) {
        if (focused) {
            return;
        }
        if (arguments.length === 2) {
            if (objectType(options) === 'function') {
                executeNow = options;
                options = undefined;
            }
        }
        processModule(name, options, executeNow);
    }
    module$1.only = function () {
        if (focused) {
            return;
        }
        config.modules.length = 0;
        config.queue.length = 0;
        module$1.apply(undefined, arguments);
        focused = true;
    };
    module$1.skip = function (name, options, executeNow) {
        if (focused) {
            return;
        }
        if (arguments.length === 2) {
            if (objectType(options) === 'function') {
                executeNow = options;
                options = undefined;
            }
        }
        processModule(name, options, executeNow, { skip: true });
    };
    module$1.todo = function (name, options, executeNow) {
        if (focused) {
            return;
        }
        if (arguments.length === 2) {
            if (objectType(options) === 'function') {
                executeNow = options;
                options = undefined;
            }
        }
        processModule(name, options, executeNow, { todo: true });
    };
    extend(QUnit, {
        on: on,
        module: module$1,
        test: test,
        todo: todo,
        skip: skip,
        only: only,
        start: function start(count) {
            var globalStartAlreadyCalled = globalStartCalled;
            if (!config.current) {
                globalStartCalled = true;
                if (runStarted) {
                    throw new Error('Called start() while test already started running');
                } else if (globalStartAlreadyCalled || count > 1) {
                    throw new Error('Called start() outside of a test context too many times');
                } else if (config.autostart) {
                    throw new Error('Called start() outside of a test context when ' + 'QUnit.config.autostart was true');
                } else if (!config.pageLoaded) {
                    config.autostart = true;
                    if (!defined.document) {
                        QUnit.load();
                    }
                    return;
                }
            } else {
                throw new Error('QUnit.start cannot be called inside a test context.');
            }
            scheduleBegin();
        },
        config: config,
        is: is,
        objectType: objectType,
        extend: extend,
        load: function load() {
            config.pageLoaded = true;
            extend(config, {
                stats: {
                    all: 0,
                    bad: 0
                },
                started: 0,
                updateRate: 1000,
                autostart: true,
                filter: ''
            }, true);
            if (!runStarted) {
                config.blocking = false;
                if (config.autostart) {
                    scheduleBegin();
                }
            }
        },
        stack: function stack(offset) {
            offset = (offset || 0) + 2;
            return sourceFromStacktrace(offset);
        },
        onError: onError
    });
    QUnit.pushFailure = pushFailure;
    QUnit.assert = Assert.prototype;
    QUnit.equiv = equiv;
    QUnit.dump = dump;
    registerLoggingCallbacks(QUnit);
    function scheduleBegin() {
        runStarted = true;
        if (defined.setTimeout) {
            setTimeout(function () {
                begin();
            }, 13);
        } else {
            begin();
        }
    }
    function begin() {
        var i, l, modulesLog = [];
        if (!config.started) {
            config.started = now();
            if (config.modules[0].name === '' && config.modules[0].tests.length === 0) {
                config.modules.shift();
            }
            for (i = 0, l = config.modules.length; i < l; i++) {
                modulesLog.push({
                    name: config.modules[i].name,
                    tests: config.modules[i].tests
                });
            }
            emit('runStart', globalSuite.start(true));
            runLoggingCallbacks('begin', {
                totalTests: Test.count,
                modules: modulesLog
            });
        }
        config.blocking = false;
        ProcessingQueue.advance();
    }
    function setHookFunction(module, hookName) {
        return function setHook(callback) {
            module.hooks[hookName].push(callback);
        };
    }
    exportQUnit(QUnit);
    (function () {
        if (typeof window === 'undefined' || typeof document === 'undefined') {
            return;
        }
        var config = QUnit.config, hasOwn = Object.prototype.hasOwnProperty;
        function storeFixture() {
            if (hasOwn.call(config, 'fixture')) {
                return;
            }
            var fixture = document.getElementById('qunit-fixture');
            if (fixture) {
                config.fixture = fixture.innerHTML;
            }
        }
        QUnit.begin(storeFixture);
        function resetFixture() {
            if (config.fixture == null) {
                return;
            }
            var fixture = document.getElementById('qunit-fixture');
            if (fixture) {
                fixture.innerHTML = config.fixture;
            }
        }
        QUnit.testStart(resetFixture);
    }());
    (function () {
        var location = typeof window !== 'undefined' && window.location;
        if (!location) {
            return;
        }
        var urlParams = getUrlParams();
        QUnit.urlParams = urlParams;
        QUnit.config.moduleId = [].concat(urlParams.moduleId || []);
        QUnit.config.testId = [].concat(urlParams.testId || []);
        QUnit.config.module = urlParams.module;
        QUnit.config.filter = urlParams.filter;
        if (urlParams.seed === true) {
            QUnit.config.seed = Math.random().toString(36).slice(2);
        } else if (urlParams.seed) {
            QUnit.config.seed = urlParams.seed;
        }
        QUnit.config.urlConfig.push({
            id: 'hidepassed',
            label: 'Hide passed tests',
            tooltip: 'Only show tests and assertions that fail. Stored as query-strings.'
        }, {
            id: 'noglobals',
            label: 'Check for Globals',
            tooltip: 'Enabling this will test if any test introduces new properties on the ' + 'global object (`window` in Browsers). Stored as query-strings.'
        }, {
            id: 'notrycatch',
            label: 'No try-catch',
            tooltip: 'Enabling this will run tests outside of a try-catch block. Makes debugging ' + 'exceptions in IE reasonable. Stored as query-strings.'
        });
        QUnit.begin(function () {
            var i, option, urlConfig = QUnit.config.urlConfig;
            for (i = 0; i < urlConfig.length; i++) {
                option = QUnit.config.urlConfig[i];
                if (typeof option !== 'string') {
                    option = option.id;
                }
                if (QUnit.config[option] === undefined) {
                    QUnit.config[option] = urlParams[option];
                }
            }
        });
        function getUrlParams() {
            var i, param, name, value;
            var urlParams = Object.create(null);
            var params = location.search.slice(1).split('&');
            var length = params.length;
            for (i = 0; i < length; i++) {
                if (params[i]) {
                    param = params[i].split('=');
                    name = decodeQueryParam(param[0]);
                    value = param.length === 1 || decodeQueryParam(param.slice(1).join('='));
                    if (name in urlParams) {
                        urlParams[name] = [].concat(urlParams[name], value);
                    } else {
                        urlParams[name] = value;
                    }
                }
            }
            return urlParams;
        }
        function decodeQueryParam(param) {
            return decodeURIComponent(param.replace(/\+/g, '%20'));
        }
    }());
    var stats = {
        passedTests: 0,
        failedTests: 0,
        skippedTests: 0,
        todoTests: 0
    };
    function escapeText(s) {
        if (!s) {
            return '';
        }
        s = s + '';
        return s.replace(/['"<>&]/g, function (s) {
            switch (s) {
            case '\'':
                return '&#039;';
            case '"':
                return '&quot;';
            case '<':
                return '&lt;';
            case '>':
                return '&gt;';
            case '&':
                return '&amp;';
            }
        });
    }
    (function () {
        if (typeof window === 'undefined' || !window.document) {
            return;
        }
        var config = QUnit.config, document$$1 = window.document, collapseNext = false, hasOwn = Object.prototype.hasOwnProperty, unfilteredUrl = setUrl({
                filter: undefined,
                module: undefined,
                moduleId: undefined,
                testId: undefined
            }), modulesList = [];
        function addEvent(elem, type, fn) {
            elem.addEventListener(type, fn, false);
        }
        function removeEvent(elem, type, fn) {
            elem.removeEventListener(type, fn, false);
        }
        function addEvents(elems, type, fn) {
            var i = elems.length;
            while (i--) {
                addEvent(elems[i], type, fn);
            }
        }
        function hasClass(elem, name) {
            return (' ' + elem.className + ' ').indexOf(' ' + name + ' ') >= 0;
        }
        function addClass(elem, name) {
            if (!hasClass(elem, name)) {
                elem.className += (elem.className ? ' ' : '') + name;
            }
        }
        function toggleClass(elem, name, force) {
            if (force || typeof force === 'undefined' && !hasClass(elem, name)) {
                addClass(elem, name);
            } else {
                removeClass(elem, name);
            }
        }
        function removeClass(elem, name) {
            var set = ' ' + elem.className + ' ';
            while (set.indexOf(' ' + name + ' ') >= 0) {
                set = set.replace(' ' + name + ' ', ' ');
            }
            elem.className = typeof set.trim === 'function' ? set.trim() : set.replace(/^\s+|\s+$/g, '');
        }
        function id(name) {
            return document$$1.getElementById && document$$1.getElementById(name);
        }
        function abortTests() {
            var abortButton = id('qunit-abort-tests-button');
            if (abortButton) {
                abortButton.disabled = true;
                abortButton.innerHTML = 'Aborting...';
            }
            QUnit.config.queue.length = 0;
            return false;
        }
        function interceptNavigation(ev) {
            applyUrlParams();
            if (ev && ev.preventDefault) {
                ev.preventDefault();
            }
            return false;
        }
        function getUrlConfigHtml() {
            var i, j, val, escaped, escapedTooltip, selection = false, urlConfig = config.urlConfig, urlConfigHtml = '';
            for (i = 0; i < urlConfig.length; i++) {
                val = config.urlConfig[i];
                if (typeof val === 'string') {
                    val = {
                        id: val,
                        label: val
                    };
                }
                escaped = escapeText(val.id);
                escapedTooltip = escapeText(val.tooltip);
                if (!val.value || typeof val.value === 'string') {
                    urlConfigHtml += '<label for=\'qunit-urlconfig-' + escaped + '\' title=\'' + escapedTooltip + '\'><input id=\'qunit-urlconfig-' + escaped + '\' name=\'' + escaped + '\' type=\'checkbox\'' + (val.value ? ' value=\'' + escapeText(val.value) + '\'' : '') + (config[val.id] ? ' checked=\'checked\'' : '') + ' title=\'' + escapedTooltip + '\' />' + escapeText(val.label) + '</label>';
                } else {
                    urlConfigHtml += '<label for=\'qunit-urlconfig-' + escaped + '\' title=\'' + escapedTooltip + '\'>' + val.label + ': </label><select id=\'qunit-urlconfig-' + escaped + '\' name=\'' + escaped + '\' title=\'' + escapedTooltip + '\'><option></option>';
                    if (QUnit.is('array', val.value)) {
                        for (j = 0; j < val.value.length; j++) {
                            escaped = escapeText(val.value[j]);
                            urlConfigHtml += '<option value=\'' + escaped + '\'' + (config[val.id] === val.value[j] ? (selection = true) && ' selected=\'selected\'' : '') + '>' + escaped + '</option>';
                        }
                    } else {
                        for (j in val.value) {
                            if (hasOwn.call(val.value, j)) {
                                urlConfigHtml += '<option value=\'' + escapeText(j) + '\'' + (config[val.id] === j ? (selection = true) && ' selected=\'selected\'' : '') + '>' + escapeText(val.value[j]) + '</option>';
                            }
                        }
                    }
                    if (config[val.id] && !selection) {
                        escaped = escapeText(config[val.id]);
                        urlConfigHtml += '<option value=\'' + escaped + '\' selected=\'selected\' disabled=\'disabled\'>' + escaped + '</option>';
                    }
                    urlConfigHtml += '</select>';
                }
            }
            return urlConfigHtml;
        }
        function toolbarChanged() {
            var updatedUrl, value, tests, field = this, params = {};
            if ('selectedIndex' in field) {
                value = field.options[field.selectedIndex].value || undefined;
            } else {
                value = field.checked ? field.defaultValue || true : undefined;
            }
            params[field.name] = value;
            updatedUrl = setUrl(params);
            if ('hidepassed' === field.name && 'replaceState' in window.history) {
                QUnit.urlParams[field.name] = value;
                config[field.name] = value || false;
                tests = id('qunit-tests');
                if (tests) {
                    toggleClass(tests, 'hidepass', value || false);
                }
                window.history.replaceState(null, '', updatedUrl);
            } else {
                window.location = updatedUrl;
            }
        }
        function setUrl(params) {
            var key, arrValue, i, querystring = '?', location = window.location;
            params = QUnit.extend(QUnit.extend({}, QUnit.urlParams), params);
            for (key in params) {
                if (hasOwn.call(params, key) && params[key] !== undefined) {
                    arrValue = [].concat(params[key]);
                    for (i = 0; i < arrValue.length; i++) {
                        querystring += encodeURIComponent(key);
                        if (arrValue[i] !== true) {
                            querystring += '=' + encodeURIComponent(arrValue[i]);
                        }
                        querystring += '&';
                    }
                }
            }
            return location.protocol + '//' + location.host + location.pathname + querystring.slice(0, -1);
        }
        function applyUrlParams() {
            var i, selectedModules = [], modulesList = id('qunit-modulefilter-dropdown-list').getElementsByTagName('input'), filter = id('qunit-filter-input').value;
            for (i = 0; i < modulesList.length; i++) {
                if (modulesList[i].checked) {
                    selectedModules.push(modulesList[i].value);
                }
            }
            window.location = setUrl({
                filter: filter === '' ? undefined : filter,
                moduleId: selectedModules.length === 0 ? undefined : selectedModules,
                module: undefined,
                testId: undefined
            });
        }
        function toolbarUrlConfigContainer() {
            var urlConfigContainer = document$$1.createElement('span');
            urlConfigContainer.innerHTML = getUrlConfigHtml();
            addClass(urlConfigContainer, 'qunit-url-config');
            addEvents(urlConfigContainer.getElementsByTagName('input'), 'change', toolbarChanged);
            addEvents(urlConfigContainer.getElementsByTagName('select'), 'change', toolbarChanged);
            return urlConfigContainer;
        }
        function abortTestsButton() {
            var button = document$$1.createElement('button');
            button.id = 'qunit-abort-tests-button';
            button.innerHTML = 'Abort';
            addEvent(button, 'click', abortTests);
            return button;
        }
        function toolbarLooseFilter() {
            var filter = document$$1.createElement('form'), label = document$$1.createElement('label'), input = document$$1.createElement('input'), button = document$$1.createElement('button');
            addClass(filter, 'qunit-filter');
            label.innerHTML = 'Filter: ';
            input.type = 'text';
            input.value = config.filter || '';
            input.name = 'filter';
            input.id = 'qunit-filter-input';
            button.innerHTML = 'Go';
            label.appendChild(input);
            filter.appendChild(label);
            filter.appendChild(document$$1.createTextNode(' '));
            filter.appendChild(button);
            addEvent(filter, 'submit', interceptNavigation);
            return filter;
        }
        function moduleListHtml() {
            var i, checked, html = '';
            for (i = 0; i < config.modules.length; i++) {
                if (config.modules[i].name !== '') {
                    checked = config.moduleId.indexOf(config.modules[i].moduleId) > -1;
                    html += '<li><label class=\'clickable' + (checked ? ' checked' : '') + '\'><input type=\'checkbox\' ' + 'value=\'' + config.modules[i].moduleId + '\'' + (checked ? ' checked=\'checked\'' : '') + ' />' + escapeText(config.modules[i].name) + '</label></li>';
                }
            }
            return html;
        }
        function toolbarModuleFilter() {
            var allCheckbox, commit, reset, moduleFilter = document$$1.createElement('form'), label = document$$1.createElement('label'), moduleSearch = document$$1.createElement('input'), dropDown = document$$1.createElement('div'), actions = document$$1.createElement('span'), dropDownList = document$$1.createElement('ul'), dirty = false;
            moduleSearch.id = 'qunit-modulefilter-search';
            addEvent(moduleSearch, 'input', searchInput);
            addEvent(moduleSearch, 'input', searchFocus);
            addEvent(moduleSearch, 'focus', searchFocus);
            addEvent(moduleSearch, 'click', searchFocus);
            label.id = 'qunit-modulefilter-search-container';
            label.innerHTML = 'Module: ';
            label.appendChild(moduleSearch);
            actions.id = 'qunit-modulefilter-actions';
            actions.innerHTML = '<button style=\'display:none\'>Apply</button>' + '<button type=\'reset\' style=\'display:none\'>Reset</button>' + '<label class=\'clickable' + (config.moduleId.length ? '' : ' checked') + '\'><input type=\'checkbox\'' + (config.moduleId.length ? '' : ' checked=\'checked\'') + '>All modules</label>';
            allCheckbox = actions.lastChild.firstChild;
            commit = actions.firstChild;
            reset = commit.nextSibling;
            addEvent(commit, 'click', applyUrlParams);
            dropDownList.id = 'qunit-modulefilter-dropdown-list';
            dropDownList.innerHTML = moduleListHtml();
            dropDown.id = 'qunit-modulefilter-dropdown';
            dropDown.style.display = 'none';
            dropDown.appendChild(actions);
            dropDown.appendChild(dropDownList);
            addEvent(dropDown, 'change', selectionChange);
            selectionChange();
            moduleFilter.id = 'qunit-modulefilter';
            moduleFilter.appendChild(label);
            moduleFilter.appendChild(dropDown);
            addEvent(moduleFilter, 'submit', interceptNavigation);
            addEvent(moduleFilter, 'reset', function () {
                window.setTimeout(selectionChange);
            });
            function searchFocus() {
                if (dropDown.style.display !== 'none') {
                    return;
                }
                dropDown.style.display = 'block';
                addEvent(document$$1, 'click', hideHandler);
                addEvent(document$$1, 'keydown', hideHandler);
                function hideHandler(e) {
                    var inContainer = moduleFilter.contains(e.target);
                    if (e.keyCode === 27 || !inContainer) {
                        if (e.keyCode === 27 && inContainer) {
                            moduleSearch.focus();
                        }
                        dropDown.style.display = 'none';
                        removeEvent(document$$1, 'click', hideHandler);
                        removeEvent(document$$1, 'keydown', hideHandler);
                        moduleSearch.value = '';
                        searchInput();
                    }
                }
            }
            function searchInput() {
                var i, item, searchText = moduleSearch.value.toLowerCase(), listItems = dropDownList.children;
                for (i = 0; i < listItems.length; i++) {
                    item = listItems[i];
                    if (!searchText || item.textContent.toLowerCase().indexOf(searchText) > -1) {
                        item.style.display = '';
                    } else {
                        item.style.display = 'none';
                    }
                }
            }
            function selectionChange(evt) {
                var i, item, checkbox = evt && evt.target || allCheckbox, modulesList = dropDownList.getElementsByTagName('input'), selectedNames = [];
                toggleClass(checkbox.parentNode, 'checked', checkbox.checked);
                dirty = false;
                if (checkbox.checked && checkbox !== allCheckbox) {
                    allCheckbox.checked = false;
                    removeClass(allCheckbox.parentNode, 'checked');
                }
                for (i = 0; i < modulesList.length; i++) {
                    item = modulesList[i];
                    if (!evt) {
                        toggleClass(item.parentNode, 'checked', item.checked);
                    } else if (checkbox === allCheckbox && checkbox.checked) {
                        item.checked = false;
                        removeClass(item.parentNode, 'checked');
                    }
                    dirty = dirty || item.checked !== item.defaultChecked;
                    if (item.checked) {
                        selectedNames.push(item.parentNode.textContent);
                    }
                }
                commit.style.display = reset.style.display = dirty ? '' : 'none';
                moduleSearch.placeholder = selectedNames.join(', ') || allCheckbox.parentNode.textContent;
                moduleSearch.title = 'Type to filter list. Current selection:\n' + (selectedNames.join('\n') || allCheckbox.parentNode.textContent);
            }
            return moduleFilter;
        }
        function appendToolbar() {
            var toolbar = id('qunit-testrunner-toolbar');
            if (toolbar) {
                toolbar.appendChild(toolbarUrlConfigContainer());
                toolbar.appendChild(toolbarModuleFilter());
                toolbar.appendChild(toolbarLooseFilter());
                toolbar.appendChild(document$$1.createElement('div')).className = 'clearfix';
            }
        }
        function appendHeader() {
            var header = id('qunit-header');
            if (header) {
                header.innerHTML = '<a href=\'' + escapeText(unfilteredUrl) + '\'>' + header.innerHTML + '</a> ';
            }
        }
        function appendBanner() {
            var banner = id('qunit-banner');
            if (banner) {
                banner.className = '';
            }
        }
        function appendTestResults() {
            var tests = id('qunit-tests'), result = id('qunit-testresult'), controls;
            if (result) {
                result.parentNode.removeChild(result);
            }
            if (tests) {
                tests.innerHTML = '';
                result = document$$1.createElement('p');
                result.id = 'qunit-testresult';
                result.className = 'result';
                tests.parentNode.insertBefore(result, tests);
                result.innerHTML = '<div id="qunit-testresult-display">Running...<br />&#160;</div>' + '<div id="qunit-testresult-controls"></div>' + '<div class="clearfix"></div>';
                controls = id('qunit-testresult-controls');
            }
            if (controls) {
                controls.appendChild(abortTestsButton());
            }
        }
        function appendFilteredTest() {
            var testId = QUnit.config.testId;
            if (!testId || testId.length <= 0) {
                return '';
            }
            return '<div id=\'qunit-filteredTest\'>Rerunning selected tests: ' + escapeText(testId.join(', ')) + ' <a id=\'qunit-clearFilter\' href=\'' + escapeText(unfilteredUrl) + '\'>Run all tests</a></div>';
        }
        function appendUserAgent() {
            var userAgent = id('qunit-userAgent');
            if (userAgent) {
                userAgent.innerHTML = '';
                userAgent.appendChild(document$$1.createTextNode('QUnit ' + QUnit.version + '; ' + navigator.userAgent));
            }
        }
        function appendInterface() {
            var qunit = id('qunit');
            if (qunit) {
                qunit.innerHTML = '<h1 id=\'qunit-header\'>' + escapeText(document$$1.title) + '</h1>' + '<h2 id=\'qunit-banner\'></h2>' + '<div id=\'qunit-testrunner-toolbar\'></div>' + appendFilteredTest() + '<h2 id=\'qunit-userAgent\'></h2>' + '<ol id=\'qunit-tests\'></ol>';
            }
            appendHeader();
            appendBanner();
            appendTestResults();
            appendUserAgent();
            appendToolbar();
        }
        function appendTestsList(modules) {
            var i, l, x, z, test, moduleObj;
            for (i = 0, l = modules.length; i < l; i++) {
                moduleObj = modules[i];
                for (x = 0, z = moduleObj.tests.length; x < z; x++) {
                    test = moduleObj.tests[x];
                    appendTest(test.name, test.testId, moduleObj.name);
                }
            }
        }
        function appendTest(name, testId, moduleName) {
            var title, rerunTrigger, testBlock, assertList, tests = id('qunit-tests');
            if (!tests) {
                return;
            }
            title = document$$1.createElement('strong');
            title.innerHTML = getNameHtml(name, moduleName);
            rerunTrigger = document$$1.createElement('a');
            rerunTrigger.innerHTML = 'Rerun';
            rerunTrigger.href = setUrl({ testId: testId });
            testBlock = document$$1.createElement('li');
            testBlock.appendChild(title);
            testBlock.appendChild(rerunTrigger);
            testBlock.id = 'qunit-test-output-' + testId;
            assertList = document$$1.createElement('ol');
            assertList.className = 'qunit-assert-list';
            testBlock.appendChild(assertList);
            tests.appendChild(testBlock);
        }
        QUnit.begin(function (details) {
            var i, moduleObj, tests;
            for (i = 0; i < details.modules.length; i++) {
                moduleObj = details.modules[i];
                if (moduleObj.name) {
                    modulesList.push(moduleObj.name);
                }
            }
            modulesList.sort(function (a, b) {
                return a.localeCompare(b);
            });
            appendInterface();
            appendTestsList(details.modules);
            tests = id('qunit-tests');
            if (tests && config.hidepassed) {
                addClass(tests, 'hidepass');
            }
        });
        QUnit.done(function (details) {
            var banner = id('qunit-banner'), tests = id('qunit-tests'), abortButton = id('qunit-abort-tests-button'), totalTests = stats.passedTests + stats.skippedTests + stats.todoTests + stats.failedTests, html = [
                    totalTests,
                    ' tests completed in ',
                    details.runtime,
                    ' milliseconds, with ',
                    stats.failedTests,
                    ' failed, ',
                    stats.skippedTests,
                    ' skipped, and ',
                    stats.todoTests,
                    ' todo.<br />',
                    '<span class=\'passed\'>',
                    details.passed,
                    '</span> assertions of <span class=\'total\'>',
                    details.total,
                    '</span> passed, <span class=\'failed\'>',
                    details.failed,
                    '</span> failed.'
                ].join(''), test, assertLi, assertList;
            if (abortButton && abortButton.disabled) {
                html = 'Tests aborted after ' + details.runtime + ' milliseconds.';
                for (var i = 0; i < tests.children.length; i++) {
                    test = tests.children[i];
                    if (test.className === '' || test.className === 'running') {
                        test.className = 'aborted';
                        assertList = test.getElementsByTagName('ol')[0];
                        assertLi = document$$1.createElement('li');
                        assertLi.className = 'fail';
                        assertLi.innerHTML = 'Test aborted.';
                        assertList.appendChild(assertLi);
                    }
                }
            }
            if (banner && (!abortButton || abortButton.disabled === false)) {
                banner.className = stats.failedTests ? 'qunit-fail' : 'qunit-pass';
            }
            if (abortButton) {
                abortButton.parentNode.removeChild(abortButton);
            }
            if (tests) {
                id('qunit-testresult-display').innerHTML = html;
            }
            if (config.altertitle && document$$1.title) {
                document$$1.title = [
                    stats.failedTests ? '\u2716' : '\u2714',
                    document$$1.title.replace(/^[\u2714\u2716] /i, '')
                ].join(' ');
            }
            if (config.scrolltop && window.scrollTo) {
                window.scrollTo(0, 0);
            }
        });
        function getNameHtml(name, module) {
            var nameHtml = '';
            if (module) {
                nameHtml = '<span class=\'module-name\'>' + escapeText(module) + '</span>: ';
            }
            nameHtml += '<span class=\'test-name\'>' + escapeText(name) + '</span>';
            return nameHtml;
        }
        QUnit.testStart(function (details) {
            var running, testBlock, bad;
            testBlock = id('qunit-test-output-' + details.testId);
            if (testBlock) {
                testBlock.className = 'running';
            } else {
                appendTest(details.name, details.testId, details.module);
            }
            running = id('qunit-testresult-display');
            if (running) {
                bad = QUnit.config.reorder && details.previousFailure;
                running.innerHTML = [
                    bad ? 'Rerunning previously failed test: <br />' : 'Running: <br />',
                    getNameHtml(details.name, details.module)
                ].join('');
            }
        });
        function stripHtml(string) {
            return string.replace(/<\/?[^>]+(>|$)/g, '').replace(/\&quot;/g, '').replace(/\s+/g, '');
        }
        QUnit.log(function (details) {
            var assertList, assertLi, message, expected, actual, diff, showDiff = false, testItem = id('qunit-test-output-' + details.testId);
            if (!testItem) {
                return;
            }
            message = escapeText(details.message) || (details.result ? 'okay' : 'failed');
            message = '<span class=\'test-message\'>' + message + '</span>';
            message += '<span class=\'runtime\'>@ ' + details.runtime + ' ms</span>';
            if (!details.result && hasOwn.call(details, 'expected')) {
                if (details.negative) {
                    expected = 'NOT ' + QUnit.dump.parse(details.expected);
                } else {
                    expected = QUnit.dump.parse(details.expected);
                }
                actual = QUnit.dump.parse(details.actual);
                message += '<table><tr class=\'test-expected\'><th>Expected: </th><td><pre>' + escapeText(expected) + '</pre></td></tr>';
                if (actual !== expected) {
                    message += '<tr class=\'test-actual\'><th>Result: </th><td><pre>' + escapeText(actual) + '</pre></td></tr>';
                    if (typeof details.actual === 'number' && typeof details.expected === 'number') {
                        if (!isNaN(details.actual) && !isNaN(details.expected)) {
                            showDiff = true;
                            diff = details.actual - details.expected;
                            diff = (diff > 0 ? '+' : '') + diff;
                        }
                    } else if (typeof details.actual !== 'boolean' && typeof details.expected !== 'boolean') {
                        diff = QUnit.diff(expected, actual);
                        showDiff = stripHtml(diff).length !== stripHtml(expected).length + stripHtml(actual).length;
                    }
                    if (showDiff) {
                        message += '<tr class=\'test-diff\'><th>Diff: </th><td><pre>' + diff + '</pre></td></tr>';
                    }
                } else if (expected.indexOf('[object Array]') !== -1 || expected.indexOf('[object Object]') !== -1) {
                    message += '<tr class=\'test-message\'><th>Message: </th><td>' + 'Diff suppressed as the depth of object is more than current max depth (' + QUnit.config.maxDepth + ').<p>Hint: Use <code>QUnit.dump.maxDepth</code> to ' + ' run with a higher max depth or <a href=\'' + escapeText(setUrl({ maxDepth: -1 })) + '\'>' + 'Rerun</a> without max depth.</p></td></tr>';
                } else {
                    message += '<tr class=\'test-message\'><th>Message: </th><td>' + 'Diff suppressed as the expected and actual results have an equivalent' + ' serialization</td></tr>';
                }
                if (details.source) {
                    message += '<tr class=\'test-source\'><th>Source: </th><td><pre>' + escapeText(details.source) + '</pre></td></tr>';
                }
                message += '</table>';
            } else if (!details.result && details.source) {
                message += '<table>' + '<tr class=\'test-source\'><th>Source: </th><td><pre>' + escapeText(details.source) + '</pre></td></tr>' + '</table>';
            }
            assertList = testItem.getElementsByTagName('ol')[0];
            assertLi = document$$1.createElement('li');
            assertLi.className = details.result ? 'pass' : 'fail';
            assertLi.innerHTML = message;
            assertList.appendChild(assertLi);
        });
        QUnit.testDone(function (details) {
            var testTitle, time, testItem, assertList, good, bad, testCounts, skipped, sourceName, tests = id('qunit-tests');
            if (!tests) {
                return;
            }
            testItem = id('qunit-test-output-' + details.testId);
            assertList = testItem.getElementsByTagName('ol')[0];
            good = details.passed;
            bad = details.failed;
            var testPassed = details.failed > 0 ? details.todo : !details.todo;
            if (testPassed) {
                addClass(assertList, 'qunit-collapsed');
            } else if (config.collapse) {
                if (!collapseNext) {
                    collapseNext = true;
                } else {
                    addClass(assertList, 'qunit-collapsed');
                }
            }
            testTitle = testItem.firstChild;
            testCounts = bad ? '<b class=\'failed\'>' + bad + '</b>, ' + '<b class=\'passed\'>' + good + '</b>, ' : '';
            testTitle.innerHTML += ' <b class=\'counts\'>(' + testCounts + details.assertions.length + ')</b>';
            if (details.skipped) {
                stats.skippedTests++;
                testItem.className = 'skipped';
                skipped = document$$1.createElement('em');
                skipped.className = 'qunit-skipped-label';
                skipped.innerHTML = 'skipped';
                testItem.insertBefore(skipped, testTitle);
            } else {
                addEvent(testTitle, 'click', function () {
                    toggleClass(assertList, 'qunit-collapsed');
                });
                testItem.className = testPassed ? 'pass' : 'fail';
                if (details.todo) {
                    var todoLabel = document$$1.createElement('em');
                    todoLabel.className = 'qunit-todo-label';
                    todoLabel.innerHTML = 'todo';
                    testItem.className += ' todo';
                    testItem.insertBefore(todoLabel, testTitle);
                }
                time = document$$1.createElement('span');
                time.className = 'runtime';
                time.innerHTML = details.runtime + ' ms';
                testItem.insertBefore(time, assertList);
                if (!testPassed) {
                    stats.failedTests++;
                } else if (details.todo) {
                    stats.todoTests++;
                } else {
                    stats.passedTests++;
                }
            }
            if (details.source) {
                sourceName = document$$1.createElement('p');
                sourceName.innerHTML = '<strong>Source: </strong>' + details.source;
                addClass(sourceName, 'qunit-source');
                if (testPassed) {
                    addClass(sourceName, 'qunit-collapsed');
                }
                addEvent(testTitle, 'click', function () {
                    toggleClass(sourceName, 'qunit-collapsed');
                });
                testItem.appendChild(sourceName);
            }
        });
        var notPhantom = function (p) {
            return !(p && p.version && p.version.major > 0);
        }(window.phantom);
        if (notPhantom && document$$1.readyState === 'complete') {
            QUnit.load();
        } else {
            addEvent(window, 'load', QUnit.load);
        }
        var originalWindowOnError = window.onerror;
        window.onerror = function (message, fileName, lineNumber) {
            var ret = false;
            if (originalWindowOnError) {
                for (var _len = arguments.length, args = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
                    args[_key - 3] = arguments[_key];
                }
                ret = originalWindowOnError.call.apply(originalWindowOnError, [
                    this,
                    message,
                    fileName,
                    lineNumber
                ].concat(args));
            }
            if (ret !== true) {
                var error = {
                    message: message,
                    fileName: fileName,
                    lineNumber: lineNumber
                };
                ret = QUnit.onError(error);
            }
            return ret;
        };
    }());
    QUnit.diff = function () {
        function DiffMatchPatch() {
        }
        var DIFF_DELETE = -1, DIFF_INSERT = 1, DIFF_EQUAL = 0;
        DiffMatchPatch.prototype.DiffMain = function (text1, text2, optChecklines) {
            var deadline, checklines, commonlength, commonprefix, commonsuffix, diffs;
            deadline = new Date().getTime() + 1000;
            if (text1 === null || text2 === null) {
                throw new Error('Null input. (DiffMain)');
            }
            if (text1 === text2) {
                if (text1) {
                    return [[
                            DIFF_EQUAL,
                            text1
                        ]];
                }
                return [];
            }
            if (typeof optChecklines === 'undefined') {
                optChecklines = true;
            }
            checklines = optChecklines;
            commonlength = this.diffCommonPrefix(text1, text2);
            commonprefix = text1.substring(0, commonlength);
            text1 = text1.substring(commonlength);
            text2 = text2.substring(commonlength);
            commonlength = this.diffCommonSuffix(text1, text2);
            commonsuffix = text1.substring(text1.length - commonlength);
            text1 = text1.substring(0, text1.length - commonlength);
            text2 = text2.substring(0, text2.length - commonlength);
            diffs = this.diffCompute(text1, text2, checklines, deadline);
            if (commonprefix) {
                diffs.unshift([
                    DIFF_EQUAL,
                    commonprefix
                ]);
            }
            if (commonsuffix) {
                diffs.push([
                    DIFF_EQUAL,
                    commonsuffix
                ]);
            }
            this.diffCleanupMerge(diffs);
            return diffs;
        };
        DiffMatchPatch.prototype.diffCleanupEfficiency = function (diffs) {
            var changes, equalities, equalitiesLength, lastequality, pointer, preIns, preDel, postIns, postDel;
            changes = false;
            equalities = [];
            equalitiesLength = 0;
            lastequality = null;
            pointer = 0;
            preIns = false;
            preDel = false;
            postIns = false;
            postDel = false;
            while (pointer < diffs.length) {
                if (diffs[pointer][0] === DIFF_EQUAL) {
                    if (diffs[pointer][1].length < 4 && (postIns || postDel)) {
                        equalities[equalitiesLength++] = pointer;
                        preIns = postIns;
                        preDel = postDel;
                        lastequality = diffs[pointer][1];
                    } else {
                        equalitiesLength = 0;
                        lastequality = null;
                    }
                    postIns = postDel = false;
                } else {
                    if (diffs[pointer][0] === DIFF_DELETE) {
                        postDel = true;
                    } else {
                        postIns = true;
                    }
                    if (lastequality && (preIns && preDel && postIns && postDel || lastequality.length < 2 && preIns + preDel + postIns + postDel === 3)) {
                        diffs.splice(equalities[equalitiesLength - 1], 0, [
                            DIFF_DELETE,
                            lastequality
                        ]);
                        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
                        equalitiesLength--;
                        lastequality = null;
                        if (preIns && preDel) {
                            postIns = postDel = true;
                            equalitiesLength = 0;
                        } else {
                            equalitiesLength--;
                            pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
                            postIns = postDel = false;
                        }
                        changes = true;
                    }
                }
                pointer++;
            }
            if (changes) {
                this.diffCleanupMerge(diffs);
            }
        };
        DiffMatchPatch.prototype.diffPrettyHtml = function (diffs) {
            var op, data, x, html = [];
            for (x = 0; x < diffs.length; x++) {
                op = diffs[x][0];
                data = diffs[x][1];
                switch (op) {
                case DIFF_INSERT:
                    html[x] = '<ins>' + escapeText(data) + '</ins>';
                    break;
                case DIFF_DELETE:
                    html[x] = '<del>' + escapeText(data) + '</del>';
                    break;
                case DIFF_EQUAL:
                    html[x] = '<span>' + escapeText(data) + '</span>';
                    break;
                }
            }
            return html.join('');
        };
        DiffMatchPatch.prototype.diffCommonPrefix = function (text1, text2) {
            var pointermid, pointermax, pointermin, pointerstart;
            if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0)) {
                return 0;
            }
            pointermin = 0;
            pointermax = Math.min(text1.length, text2.length);
            pointermid = pointermax;
            pointerstart = 0;
            while (pointermin < pointermid) {
                if (text1.substring(pointerstart, pointermid) === text2.substring(pointerstart, pointermid)) {
                    pointermin = pointermid;
                    pointerstart = pointermin;
                } else {
                    pointermax = pointermid;
                }
                pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
            }
            return pointermid;
        };
        DiffMatchPatch.prototype.diffCommonSuffix = function (text1, text2) {
            var pointermid, pointermax, pointermin, pointerend;
            if (!text1 || !text2 || text1.charAt(text1.length - 1) !== text2.charAt(text2.length - 1)) {
                return 0;
            }
            pointermin = 0;
            pointermax = Math.min(text1.length, text2.length);
            pointermid = pointermax;
            pointerend = 0;
            while (pointermin < pointermid) {
                if (text1.substring(text1.length - pointermid, text1.length - pointerend) === text2.substring(text2.length - pointermid, text2.length - pointerend)) {
                    pointermin = pointermid;
                    pointerend = pointermin;
                } else {
                    pointermax = pointermid;
                }
                pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
            }
            return pointermid;
        };
        DiffMatchPatch.prototype.diffCompute = function (text1, text2, checklines, deadline) {
            var diffs, longtext, shorttext, i, hm, text1A, text2A, text1B, text2B, midCommon, diffsA, diffsB;
            if (!text1) {
                return [[
                        DIFF_INSERT,
                        text2
                    ]];
            }
            if (!text2) {
                return [[
                        DIFF_DELETE,
                        text1
                    ]];
            }
            longtext = text1.length > text2.length ? text1 : text2;
            shorttext = text1.length > text2.length ? text2 : text1;
            i = longtext.indexOf(shorttext);
            if (i !== -1) {
                diffs = [
                    [
                        DIFF_INSERT,
                        longtext.substring(0, i)
                    ],
                    [
                        DIFF_EQUAL,
                        shorttext
                    ],
                    [
                        DIFF_INSERT,
                        longtext.substring(i + shorttext.length)
                    ]
                ];
                if (text1.length > text2.length) {
                    diffs[0][0] = diffs[2][0] = DIFF_DELETE;
                }
                return diffs;
            }
            if (shorttext.length === 1) {
                return [
                    [
                        DIFF_DELETE,
                        text1
                    ],
                    [
                        DIFF_INSERT,
                        text2
                    ]
                ];
            }
            hm = this.diffHalfMatch(text1, text2);
            if (hm) {
                text1A = hm[0];
                text1B = hm[1];
                text2A = hm[2];
                text2B = hm[3];
                midCommon = hm[4];
                diffsA = this.DiffMain(text1A, text2A, checklines, deadline);
                diffsB = this.DiffMain(text1B, text2B, checklines, deadline);
                return diffsA.concat([[
                        DIFF_EQUAL,
                        midCommon
                    ]], diffsB);
            }
            if (checklines && text1.length > 100 && text2.length > 100) {
                return this.diffLineMode(text1, text2, deadline);
            }
            return this.diffBisect(text1, text2, deadline);
        };
        DiffMatchPatch.prototype.diffHalfMatch = function (text1, text2) {
            var longtext, shorttext, dmp, text1A, text2B, text2A, text1B, midCommon, hm1, hm2, hm;
            longtext = text1.length > text2.length ? text1 : text2;
            shorttext = text1.length > text2.length ? text2 : text1;
            if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
                return null;
            }
            dmp = this;
            function diffHalfMatchI(longtext, shorttext, i) {
                var seed, j, bestCommon, prefixLength, suffixLength, bestLongtextA, bestLongtextB, bestShorttextA, bestShorttextB;
                seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
                j = -1;
                bestCommon = '';
                while ((j = shorttext.indexOf(seed, j + 1)) !== -1) {
                    prefixLength = dmp.diffCommonPrefix(longtext.substring(i), shorttext.substring(j));
                    suffixLength = dmp.diffCommonSuffix(longtext.substring(0, i), shorttext.substring(0, j));
                    if (bestCommon.length < suffixLength + prefixLength) {
                        bestCommon = shorttext.substring(j - suffixLength, j) + shorttext.substring(j, j + prefixLength);
                        bestLongtextA = longtext.substring(0, i - suffixLength);
                        bestLongtextB = longtext.substring(i + prefixLength);
                        bestShorttextA = shorttext.substring(0, j - suffixLength);
                        bestShorttextB = shorttext.substring(j + prefixLength);
                    }
                }
                if (bestCommon.length * 2 >= longtext.length) {
                    return [
                        bestLongtextA,
                        bestLongtextB,
                        bestShorttextA,
                        bestShorttextB,
                        bestCommon
                    ];
                } else {
                    return null;
                }
            }
            hm1 = diffHalfMatchI(longtext, shorttext, Math.ceil(longtext.length / 4));
            hm2 = diffHalfMatchI(longtext, shorttext, Math.ceil(longtext.length / 2));
            if (!hm1 && !hm2) {
                return null;
            } else if (!hm2) {
                hm = hm1;
            } else if (!hm1) {
                hm = hm2;
            } else {
                hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
            }
            if (text1.length > text2.length) {
                text1A = hm[0];
                text1B = hm[1];
                text2A = hm[2];
                text2B = hm[3];
            } else {
                text2A = hm[0];
                text2B = hm[1];
                text1A = hm[2];
                text1B = hm[3];
            }
            midCommon = hm[4];
            return [
                text1A,
                text1B,
                text2A,
                text2B,
                midCommon
            ];
        };
        DiffMatchPatch.prototype.diffLineMode = function (text1, text2, deadline) {
            var a, diffs, linearray, pointer, countInsert, countDelete, textInsert, textDelete, j;
            a = this.diffLinesToChars(text1, text2);
            text1 = a.chars1;
            text2 = a.chars2;
            linearray = a.lineArray;
            diffs = this.DiffMain(text1, text2, false, deadline);
            this.diffCharsToLines(diffs, linearray);
            this.diffCleanupSemantic(diffs);
            diffs.push([
                DIFF_EQUAL,
                ''
            ]);
            pointer = 0;
            countDelete = 0;
            countInsert = 0;
            textDelete = '';
            textInsert = '';
            while (pointer < diffs.length) {
                switch (diffs[pointer][0]) {
                case DIFF_INSERT:
                    countInsert++;
                    textInsert += diffs[pointer][1];
                    break;
                case DIFF_DELETE:
                    countDelete++;
                    textDelete += diffs[pointer][1];
                    break;
                case DIFF_EQUAL:
                    if (countDelete >= 1 && countInsert >= 1) {
                        diffs.splice(pointer - countDelete - countInsert, countDelete + countInsert);
                        pointer = pointer - countDelete - countInsert;
                        a = this.DiffMain(textDelete, textInsert, false, deadline);
                        for (j = a.length - 1; j >= 0; j--) {
                            diffs.splice(pointer, 0, a[j]);
                        }
                        pointer = pointer + a.length;
                    }
                    countInsert = 0;
                    countDelete = 0;
                    textDelete = '';
                    textInsert = '';
                    break;
                }
                pointer++;
            }
            diffs.pop();
            return diffs;
        };
        DiffMatchPatch.prototype.diffBisect = function (text1, text2, deadline) {
            var text1Length, text2Length, maxD, vOffset, vLength, v1, v2, x, delta, front, k1start, k1end, k2start, k2end, k2Offset, k1Offset, x1, x2, y1, y2, d, k1, k2;
            text1Length = text1.length;
            text2Length = text2.length;
            maxD = Math.ceil((text1Length + text2Length) / 2);
            vOffset = maxD;
            vLength = 2 * maxD;
            v1 = new Array(vLength);
            v2 = new Array(vLength);
            for (x = 0; x < vLength; x++) {
                v1[x] = -1;
                v2[x] = -1;
            }
            v1[vOffset + 1] = 0;
            v2[vOffset + 1] = 0;
            delta = text1Length - text2Length;
            front = delta % 2 !== 0;
            k1start = 0;
            k1end = 0;
            k2start = 0;
            k2end = 0;
            for (d = 0; d < maxD; d++) {
                if (new Date().getTime() > deadline) {
                    break;
                }
                for (k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
                    k1Offset = vOffset + k1;
                    if (k1 === -d || k1 !== d && v1[k1Offset - 1] < v1[k1Offset + 1]) {
                        x1 = v1[k1Offset + 1];
                    } else {
                        x1 = v1[k1Offset - 1] + 1;
                    }
                    y1 = x1 - k1;
                    while (x1 < text1Length && y1 < text2Length && text1.charAt(x1) === text2.charAt(y1)) {
                        x1++;
                        y1++;
                    }
                    v1[k1Offset] = x1;
                    if (x1 > text1Length) {
                        k1end += 2;
                    } else if (y1 > text2Length) {
                        k1start += 2;
                    } else if (front) {
                        k2Offset = vOffset + delta - k1;
                        if (k2Offset >= 0 && k2Offset < vLength && v2[k2Offset] !== -1) {
                            x2 = text1Length - v2[k2Offset];
                            if (x1 >= x2) {
                                return this.diffBisectSplit(text1, text2, x1, y1, deadline);
                            }
                        }
                    }
                }
                for (k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
                    k2Offset = vOffset + k2;
                    if (k2 === -d || k2 !== d && v2[k2Offset - 1] < v2[k2Offset + 1]) {
                        x2 = v2[k2Offset + 1];
                    } else {
                        x2 = v2[k2Offset - 1] + 1;
                    }
                    y2 = x2 - k2;
                    while (x2 < text1Length && y2 < text2Length && text1.charAt(text1Length - x2 - 1) === text2.charAt(text2Length - y2 - 1)) {
                        x2++;
                        y2++;
                    }
                    v2[k2Offset] = x2;
                    if (x2 > text1Length) {
                        k2end += 2;
                    } else if (y2 > text2Length) {
                        k2start += 2;
                    } else if (!front) {
                        k1Offset = vOffset + delta - k2;
                        if (k1Offset >= 0 && k1Offset < vLength && v1[k1Offset] !== -1) {
                            x1 = v1[k1Offset];
                            y1 = vOffset + x1 - k1Offset;
                            x2 = text1Length - x2;
                            if (x1 >= x2) {
                                return this.diffBisectSplit(text1, text2, x1, y1, deadline);
                            }
                        }
                    }
                }
            }
            return [
                [
                    DIFF_DELETE,
                    text1
                ],
                [
                    DIFF_INSERT,
                    text2
                ]
            ];
        };
        DiffMatchPatch.prototype.diffBisectSplit = function (text1, text2, x, y, deadline) {
            var text1a, text1b, text2a, text2b, diffs, diffsb;
            text1a = text1.substring(0, x);
            text2a = text2.substring(0, y);
            text1b = text1.substring(x);
            text2b = text2.substring(y);
            diffs = this.DiffMain(text1a, text2a, false, deadline);
            diffsb = this.DiffMain(text1b, text2b, false, deadline);
            return diffs.concat(diffsb);
        };
        DiffMatchPatch.prototype.diffCleanupSemantic = function (diffs) {
            var changes, equalities, equalitiesLength, lastequality, pointer, lengthInsertions2, lengthDeletions2, lengthInsertions1, lengthDeletions1, deletion, insertion, overlapLength1, overlapLength2;
            changes = false;
            equalities = [];
            equalitiesLength = 0;
            lastequality = null;
            pointer = 0;
            lengthInsertions1 = 0;
            lengthDeletions1 = 0;
            lengthInsertions2 = 0;
            lengthDeletions2 = 0;
            while (pointer < diffs.length) {
                if (diffs[pointer][0] === DIFF_EQUAL) {
                    equalities[equalitiesLength++] = pointer;
                    lengthInsertions1 = lengthInsertions2;
                    lengthDeletions1 = lengthDeletions2;
                    lengthInsertions2 = 0;
                    lengthDeletions2 = 0;
                    lastequality = diffs[pointer][1];
                } else {
                    if (diffs[pointer][0] === DIFF_INSERT) {
                        lengthInsertions2 += diffs[pointer][1].length;
                    } else {
                        lengthDeletions2 += diffs[pointer][1].length;
                    }
                    if (lastequality && lastequality.length <= Math.max(lengthInsertions1, lengthDeletions1) && lastequality.length <= Math.max(lengthInsertions2, lengthDeletions2)) {
                        diffs.splice(equalities[equalitiesLength - 1], 0, [
                            DIFF_DELETE,
                            lastequality
                        ]);
                        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
                        equalitiesLength--;
                        equalitiesLength--;
                        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
                        lengthInsertions1 = 0;
                        lengthDeletions1 = 0;
                        lengthInsertions2 = 0;
                        lengthDeletions2 = 0;
                        lastequality = null;
                        changes = true;
                    }
                }
                pointer++;
            }
            if (changes) {
                this.diffCleanupMerge(diffs);
            }
            pointer = 1;
            while (pointer < diffs.length) {
                if (diffs[pointer - 1][0] === DIFF_DELETE && diffs[pointer][0] === DIFF_INSERT) {
                    deletion = diffs[pointer - 1][1];
                    insertion = diffs[pointer][1];
                    overlapLength1 = this.diffCommonOverlap(deletion, insertion);
                    overlapLength2 = this.diffCommonOverlap(insertion, deletion);
                    if (overlapLength1 >= overlapLength2) {
                        if (overlapLength1 >= deletion.length / 2 || overlapLength1 >= insertion.length / 2) {
                            diffs.splice(pointer, 0, [
                                DIFF_EQUAL,
                                insertion.substring(0, overlapLength1)
                            ]);
                            diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlapLength1);
                            diffs[pointer + 1][1] = insertion.substring(overlapLength1);
                            pointer++;
                        }
                    } else {
                        if (overlapLength2 >= deletion.length / 2 || overlapLength2 >= insertion.length / 2) {
                            diffs.splice(pointer, 0, [
                                DIFF_EQUAL,
                                deletion.substring(0, overlapLength2)
                            ]);
                            diffs[pointer - 1][0] = DIFF_INSERT;
                            diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlapLength2);
                            diffs[pointer + 1][0] = DIFF_DELETE;
                            diffs[pointer + 1][1] = deletion.substring(overlapLength2);
                            pointer++;
                        }
                    }
                    pointer++;
                }
                pointer++;
            }
        };
        DiffMatchPatch.prototype.diffCommonOverlap = function (text1, text2) {
            var text1Length, text2Length, textLength, best, length, pattern, found;
            text1Length = text1.length;
            text2Length = text2.length;
            if (text1Length === 0 || text2Length === 0) {
                return 0;
            }
            if (text1Length > text2Length) {
                text1 = text1.substring(text1Length - text2Length);
            } else if (text1Length < text2Length) {
                text2 = text2.substring(0, text1Length);
            }
            textLength = Math.min(text1Length, text2Length);
            if (text1 === text2) {
                return textLength;
            }
            best = 0;
            length = 1;
            while (true) {
                pattern = text1.substring(textLength - length);
                found = text2.indexOf(pattern);
                if (found === -1) {
                    return best;
                }
                length += found;
                if (found === 0 || text1.substring(textLength - length) === text2.substring(0, length)) {
                    best = length;
                    length++;
                }
            }
        };
        DiffMatchPatch.prototype.diffLinesToChars = function (text1, text2) {
            var lineArray, lineHash, chars1, chars2;
            lineArray = [];
            lineHash = {};
            lineArray[0] = '';
            function diffLinesToCharsMunge(text) {
                var chars, lineStart, lineEnd, lineArrayLength, line;
                chars = '';
                lineStart = 0;
                lineEnd = -1;
                lineArrayLength = lineArray.length;
                while (lineEnd < text.length - 1) {
                    lineEnd = text.indexOf('\n', lineStart);
                    if (lineEnd === -1) {
                        lineEnd = text.length - 1;
                    }
                    line = text.substring(lineStart, lineEnd + 1);
                    lineStart = lineEnd + 1;
                    var lineHashExists = lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) : lineHash[line] !== undefined;
                    if (lineHashExists) {
                        chars += String.fromCharCode(lineHash[line]);
                    } else {
                        chars += String.fromCharCode(lineArrayLength);
                        lineHash[line] = lineArrayLength;
                        lineArray[lineArrayLength++] = line;
                    }
                }
                return chars;
            }
            chars1 = diffLinesToCharsMunge(text1);
            chars2 = diffLinesToCharsMunge(text2);
            return {
                chars1: chars1,
                chars2: chars2,
                lineArray: lineArray
            };
        };
        DiffMatchPatch.prototype.diffCharsToLines = function (diffs, lineArray) {
            var x, chars, text, y;
            for (x = 0; x < diffs.length; x++) {
                chars = diffs[x][1];
                text = [];
                for (y = 0; y < chars.length; y++) {
                    text[y] = lineArray[chars.charCodeAt(y)];
                }
                diffs[x][1] = text.join('');
            }
        };
        DiffMatchPatch.prototype.diffCleanupMerge = function (diffs) {
            var pointer, countDelete, countInsert, textInsert, textDelete, commonlength, changes, diffPointer, position;
            diffs.push([
                DIFF_EQUAL,
                ''
            ]);
            pointer = 0;
            countDelete = 0;
            countInsert = 0;
            textDelete = '';
            textInsert = '';
            while (pointer < diffs.length) {
                switch (diffs[pointer][0]) {
                case DIFF_INSERT:
                    countInsert++;
                    textInsert += diffs[pointer][1];
                    pointer++;
                    break;
                case DIFF_DELETE:
                    countDelete++;
                    textDelete += diffs[pointer][1];
                    pointer++;
                    break;
                case DIFF_EQUAL:
                    if (countDelete + countInsert > 1) {
                        if (countDelete !== 0 && countInsert !== 0) {
                            commonlength = this.diffCommonPrefix(textInsert, textDelete);
                            if (commonlength !== 0) {
                                if (pointer - countDelete - countInsert > 0 && diffs[pointer - countDelete - countInsert - 1][0] === DIFF_EQUAL) {
                                    diffs[pointer - countDelete - countInsert - 1][1] += textInsert.substring(0, commonlength);
                                } else {
                                    diffs.splice(0, 0, [
                                        DIFF_EQUAL,
                                        textInsert.substring(0, commonlength)
                                    ]);
                                    pointer++;
                                }
                                textInsert = textInsert.substring(commonlength);
                                textDelete = textDelete.substring(commonlength);
                            }
                            commonlength = this.diffCommonSuffix(textInsert, textDelete);
                            if (commonlength !== 0) {
                                diffs[pointer][1] = textInsert.substring(textInsert.length - commonlength) + diffs[pointer][1];
                                textInsert = textInsert.substring(0, textInsert.length - commonlength);
                                textDelete = textDelete.substring(0, textDelete.length - commonlength);
                            }
                        }
                        if (countDelete === 0) {
                            diffs.splice(pointer - countInsert, countDelete + countInsert, [
                                DIFF_INSERT,
                                textInsert
                            ]);
                        } else if (countInsert === 0) {
                            diffs.splice(pointer - countDelete, countDelete + countInsert, [
                                DIFF_DELETE,
                                textDelete
                            ]);
                        } else {
                            diffs.splice(pointer - countDelete - countInsert, countDelete + countInsert, [
                                DIFF_DELETE,
                                textDelete
                            ], [
                                DIFF_INSERT,
                                textInsert
                            ]);
                        }
                        pointer = pointer - countDelete - countInsert + (countDelete ? 1 : 0) + (countInsert ? 1 : 0) + 1;
                    } else if (pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL) {
                        diffs[pointer - 1][1] += diffs[pointer][1];
                        diffs.splice(pointer, 1);
                    } else {
                        pointer++;
                    }
                    countInsert = 0;
                    countDelete = 0;
                    textDelete = '';
                    textInsert = '';
                    break;
                }
            }
            if (diffs[diffs.length - 1][1] === '') {
                diffs.pop();
            }
            changes = false;
            pointer = 1;
            while (pointer < diffs.length - 1) {
                if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {
                    diffPointer = diffs[pointer][1];
                    position = diffPointer.substring(diffPointer.length - diffs[pointer - 1][1].length);
                    if (position === diffs[pointer - 1][1]) {
                        diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);
                        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
                        diffs.splice(pointer - 1, 1);
                        changes = true;
                    } else if (diffPointer.substring(0, diffs[pointer + 1][1].length) === diffs[pointer + 1][1]) {
                        diffs[pointer - 1][1] += diffs[pointer + 1][1];
                        diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
                        diffs.splice(pointer + 1, 1);
                        changes = true;
                    }
                }
                pointer++;
            }
            if (changes) {
                this.diffCleanupMerge(diffs);
            }
        };
        return function (o, n) {
            var diff, output, text;
            diff = new DiffMatchPatch();
            output = diff.DiffMain(o, n);
            diff.diffCleanupEfficiency(output);
            text = diff.diffPrettyHtml(output);
            return text;
        };
    }();
}(function () {
    return this;
}()));
/*can-ajax@1.0.9#test/qunit*/
define('can-ajax@1.0.9#test/qunit', [
    'require',
    'exports',
    'module',
    'qunitjs',
    'steal-qunit'
], function (require, exports, module) {
    'use strict';
    var testType = typeof process !== 'undefined' && process.env.TEST;
    var isMochaQUnitUI = testType === 'mocha';
    var isQunit = testType === 'qunit';
    if (isMochaQUnitUI) {
        QUnit.assert.async = function () {
            QUnit.stop();
            return function done(error) {
                if (error) {
                    return QUnit.ok(false, '' + error);
                }
                QUnit.start();
            };
        };
        QUnit.test = test;
        module.exports = QUnit;
    } else if (isQunit) {
        module.exports = require('qunitjs');
    } else {
        module.exports = require('steal-qunit');
    }
});
/*can-ajax@1.0.9#test/helpers*/
define('can-ajax@1.0.9#test/helpers', [
    'require',
    'exports',
    'module',
    'can-globals/global/global'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var getGlobal = require('can-globals/global/global');
        function isProduction() {
            var root = getGlobal();
            if (root.System) {
                return root.System.env.indexOf('production') !== -1;
            }
            if (root.process) {
                var nodeEnv = root.process.env.NODE_ENV;
                return nodeEnv === 'production' || nodeEnv === 'window-production';
            }
            return false;
        }
        function isServer() {
            var root = getGlobal();
            var testType = root.process && root.process.env.TEST;
            return testType === 'qunit';
        }
        module.exports = {
            isProduction: isProduction,
            isServer: isServer
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-ajax@1.0.9#can-ajax-test*/
define('can-ajax@1.0.9#can-ajax-test', [
    'require',
    'exports',
    'module',
    './can-ajax',
    'can-namespace',
    'can-make-map',
    'can-globals/global/global',
    'can-parse-uri',
    './test/qunit',
    './test/helpers'
], function (require, exports, module) {
    (function (global, __dirname, require, exports, module) {
        'use strict';
        var ajax = require('./can-ajax');
        var namespace = require('can-namespace');
        var makeMap = require('can-make-map');
        var GLOBAL = require('can-globals/global/global');
        var parseURI = require('can-parse-uri');
        var QUnit = require('./test/qunit');
        var helpers = require('./test/helpers');
        var isMainCanTest = typeof System === 'object' && System.env !== 'canjs-test';
        var hasLocalServer = !helpers.isServer() && !helpers.isProduction();
        QUnit.module('can-ajax');
        var makeFixture = function (XHR) {
            var oldXhr = window.XMLHttpRequest || window.ActiveXObject;
            if (window.XMLHttpRequest) {
                window.XMLHttpRequest = XHR;
            } else if (window.ActiveXObject) {
                window.ActiveXObject = XHR;
            }
            return function restoreXHR() {
                if (window.XMLHttpRequest) {
                    window.XMLHttpRequest = oldXhr;
                } else if (window.ActiveXObject) {
                    window.ActiveXObject = oldXhr;
                }
            };
        };
        var makePredicateContains = function (str) {
            var obj = makeMap(str);
            return function (val) {
                return obj[val];
            };
        };
        if (hasLocalServer) {
            QUnit.test('basic get request', function (assert) {
                var done = assert.async();
                ajax({
                    type: 'get',
                    url: __dirname + '/can-ajax-test-result.json'
                }).then(function (resp) {
                    assert.equal(resp.message, 'VALUE');
                    done();
                });
            });
        }
        QUnit.test('added to namespace (#99)', function (assert) {
            assert.equal(namespace.ajax, ajax);
        });
        if (hasLocalServer) {
            QUnit.test('GET requests with dataType parse JSON (#106)', function (assert) {
                var done = assert.async();
                ajax({
                    type: 'get',
                    url: __dirname + '/can-ajax-test-result.txt',
                    dataType: 'json'
                }).then(function (resp) {
                    assert.equal(resp.message, 'VALUE');
                    done();
                });
            });
        }
        QUnit.test('ignores case of type parameter for a post request (#100)', function (assert) {
            var done = assert.async();
            var requestHeaders = { CONTENT_TYPE: 'Content-Type' }, restore = makeFixture(function () {
                    this.open = function (type, url) {
                    };
                    this.send = function () {
                        this.readyState = 4;
                        this.status = 200;
                        this.onreadystatechange();
                    };
                    this.setRequestHeader = function (header, value) {
                        if (header === requestHeaders.CONTENT_TYPE) {
                            var o = {};
                            o[header] = value;
                            this.responseText = JSON.stringify(o);
                        }
                    };
                });
            ajax({
                type: 'post',
                url: 'http://anotherdomain.com/foo',
                data: { bar: 'qux' }
            }).then(function (value) {
                assert.equal(value[requestHeaders.CONTENT_TYPE], 'application/x-www-form-urlencoded');
            }, function (reason) {
                assert.notOk(reason, 'request failed with reason = ', reason);
            }).then(function () {
                restore();
                done();
            });
        });
        QUnit.test('url encodes GET requests when no contentType', function (assert) {
            var done = assert.async();
            var restore = makeFixture(function () {
                var o = {};
                this.open = function (type, url) {
                    o.url = url;
                };
                this.send = function (data) {
                    o.data = data;
                    this.readyState = 4;
                    this.status = 200;
                    this.responseText = JSON.stringify(o);
                    this.onreadystatechange();
                };
                this.setRequestHeader = function (header, value) {
                    if (header === 'Content-Type') {
                        o[header] = value;
                    }
                };
            });
            ajax({
                type: 'get',
                url: 'http://anotherdomain.com/foo',
                data: { foo: 'bar' }
            }).then(function (value) {
                assert.equal(value['Content-Type'], 'application/x-www-form-urlencoded');
                assert.equal(value.data, undefined, 'No data provided because it\'s a GET');
                assert.equal(value.url, 'http://anotherdomain.com/foo?foo=bar');
            }, function (reason) {
                assert.notOk(reason, 'request failed with reason = ', reason);
            }).then(function () {
                restore();
                done();
            });
        });
        QUnit.test('Stringifies GET requests when contentType=application/json', function (assert) {
            var done = assert.async();
            var restore = makeFixture(function () {
                var o = {};
                this.open = function (type, url) {
                    o.url = url;
                };
                this.send = function (data) {
                    o.data = data;
                    this.readyState = 4;
                    this.status = 200;
                    this.responseText = JSON.stringify(o);
                    this.onreadystatechange();
                };
                this.setRequestHeader = function (header, value) {
                    if (header === 'Content-Type') {
                        o[header] = value;
                    }
                };
            });
            ajax({
                type: 'get',
                url: 'http://anotherdomain.com/foo',
                data: { foo: 'bar' },
                contentType: 'application/json'
            }).then(function (value) {
                assert.equal(value['Content-Type'], 'application/json');
                assert.equal(value.data, undefined, 'No data provided because it\'s a GET');
                assert.equal(value.url, 'http://anotherdomain.com/foo?{"foo":"bar"}');
            }, function (reason) {
                assert.notOk(reason, 'request failed with reason = ', reason);
            }).then(function () {
                restore();
                done();
            });
        });
        QUnit.test('Stringifies POST requests when there is no contentType', function (assert) {
            var done = assert.async();
            var restore = makeFixture(function () {
                var o = {};
                this.open = function (type, url) {
                    o.url = url;
                };
                this.send = function (data) {
                    o.data = data;
                    this.readyState = 4;
                    this.status = 200;
                    this.responseText = JSON.stringify(o);
                    this.onreadystatechange();
                };
                this.setRequestHeader = function (header, value) {
                    if (header === 'Content-Type') {
                        o[header] = value;
                    }
                };
            });
            var origin = parseURI(GLOBAL().location.href);
            var url = origin.protocol + origin.authority + '/foo';
            ajax({
                type: 'post',
                url: url,
                data: { foo: 'bar' }
            }).then(function (value) {
                assert.equal(value['Content-Type'], 'application/json');
                assert.equal(value.data, '{"foo":"bar"}', 'Data was stringified');
                assert.equal(value.url, url);
            }, function (reason) {
                assert.notOk(reason, 'request failed with reason = ', reason);
            }).then(function () {
                restore();
                done();
            });
        });
        QUnit.test('url encodes POST requests when contentType=application/x-www-form-urlencoded', function (assert) {
            var done = assert.async();
            var restore = makeFixture(function () {
                var o = {};
                this.open = function (type, url) {
                    o.url = url;
                };
                this.send = function (data) {
                    o.data = data;
                    this.readyState = 4;
                    this.status = 200;
                    this.responseText = JSON.stringify(o);
                    this.onreadystatechange();
                };
                this.setRequestHeader = function (header, value) {
                    if (header === 'Content-Type') {
                        o[header] = value;
                    }
                };
            });
            ajax({
                type: 'post',
                url: 'http://anotherdomain.com/foo',
                data: { foo: 'bar' },
                contentType: 'application/x-www-form-urlencoded'
            }).then(function (value) {
                assert.equal(value['Content-Type'], 'application/x-www-form-urlencoded');
                assert.equal(value.data, 'foo=bar', 'Data was url encoded');
                assert.equal(value.url, 'http://anotherdomain.com/foo');
            }, function (reason) {
                assert.notOk(reason, 'request failed with reason = ', reason);
            }).then(function () {
                restore();
                done();
            });
        });
        if (typeof XDomainRequest === 'undefined') {
            if (!helpers.isServer()) {
                QUnit.test('cross domain post request should change data to form data (#90)', function (assert) {
                    var done = assert.async();
                    ajax({
                        type: 'POST',
                        url: 'http://httpbin.org/post',
                        data: { 'message': 'VALUE' },
                        dataType: 'application/json'
                    }).then(function (resp) {
                        assert.equal(resp.form.message, 'VALUE');
                        done();
                    });
                });
            }
            QUnit.test('GET CORS should be a simple request - without a preflight (#187)', function (assert) {
                var done = assert.async();
                var isSimpleRequest = true, restore;
                var isSimpleMethod = makePredicateContains('GET,POST,HEAD');
                var isSimpleHeader = makePredicateContains('Accept,Accept-Language,Content-Language,Content-Type,DPR,Downlink,Save-Data,Viewport-Width,Width');
                var isSimpleContentType = makePredicateContains('application/x-www-form-urlencoded,multipart/form-data,text/plain');
                restore = makeFixture(function () {
                    this.open = function (type, url) {
                        if (!isSimpleMethod(type)) {
                            isSimpleRequest = false;
                        }
                    };
                    var response = {};
                    this.send = function () {
                        this.responseText = JSON.stringify(response);
                        this.readyState = 4;
                        this.status = 200;
                        this.onreadystatechange();
                    };
                    this.setRequestHeader = function (header, value) {
                        if (header === 'Content-Type' && !isSimpleContentType(value)) {
                            isSimpleRequest = false;
                        }
                        if (isSimpleRequest && !isSimpleHeader(header)) {
                            isSimpleRequest = false;
                        }
                        response[header] = value;
                    };
                });
                ajax({
                    url: 'http://query.yahooapis.com/v1/public/yql',
                    data: {
                        q: 'select * from geo.places where text="sunnyvale, ca"',
                        format: 'json'
                    }
                }).then(function (response) {
                    assert.ok(isSimpleRequest, 'CORS GET is simple');
                    restore();
                    done();
                }, function (err) {
                    assert.ok(false, 'Should be resolved');
                    restore();
                    done();
                });
            });
        }
        if (isMainCanTest && hasLocalServer) {
            QUnit.test('abort', function (assert) {
                var done = assert.async();
                var promise = ajax({
                    type: 'get',
                    url: __dirname + '/can-ajax-test-result.json'
                });
                promise.catch(function (xhr) {
                    if (xhr instanceof Error) {
                        assert.equal(xhr.message, 'Could not complete the operation due to error c00c023f.');
                        done();
                    } else {
                        setTimeout(function () {
                            assert.equal(xhr.readyState, 0, 'aborts the promise');
                            done();
                        }, 50);
                    }
                });
                promise.abort();
            });
        }
        QUnit.test('crossDomain is true for relative requests', function (assert) {
            var done = assert.async();
            var headers = {}, restore = makeFixture(function () {
                    this.open = function (type, url) {
                    };
                    this.send = function () {
                        this.readyState = 4;
                        this.status = 200;
                        this.responseText = JSON.stringify({ great: 'success' });
                        this.onreadystatechange();
                    };
                    this.setRequestHeader = function (header, value) {
                        headers[header] = value;
                    };
                });
            ajax({
                type: 'post',
                url: '/foo',
                data: { bar: 'qux' },
                dataType: 'json'
            }).then(function (value) {
                assert.deepEqual(headers, {
                    'Content-Type': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest'
                });
            }, function (reason) {
                assert.notOk(reason, 'request failed with reason = ', reason);
            }).then(function () {
                restore();
                done();
            });
        });
        if (hasLocalServer) {
            QUnit.test('correctly serializes null and undefined values (#177)', function (assert) {
                var done = assert.async();
                ajax({
                    type: 'get',
                    url: __dirname + '/can-ajax-test-result.txt',
                    data: { foo: null }
                }).then(function (resp) {
                    assert.equal(resp.message, 'VALUE');
                    done();
                });
            });
        }
    }(function () {
        return this;
    }(), '/', require, exports, module));
});
/*can-construct@3.2.2#can-construct_test*/
define('can-construct@3.2.2#can-construct_test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-construct',
    'can-util/js/dev/',
    'can-util/js/make-array/'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        QUnit = require('steal-qunit');
        var Construct = require('can-construct');
        var dev = require('can-util/js/dev/');
        var makeArray = require('can-util/js/make-array/');
        QUnit.module('can-construct', {
            setup: function () {
                var Animal = this.Animal = Construct.extend({
                    count: 0,
                    test: function () {
                        return this.match ? true : false;
                    }
                }, {
                    init: function () {
                        this.constructor.count++;
                        this.eyes = false;
                    }
                });
                var Dog = this.Dog = this.Animal.extend({ match: /abc/ }, {
                    init: function () {
                        Animal.prototype.init.apply(this, arguments);
                    },
                    talk: function () {
                        return 'Woof';
                    }
                });
                this.Ajax = this.Dog.extend({ count: 0 }, {
                    init: function (hairs) {
                        Dog.prototype.init.apply(this, arguments);
                        this.hairs = hairs;
                        this.setEyes();
                    },
                    setEyes: function () {
                        this.eyes = true;
                    }
                });
            }
        });
        test('inherit', function () {
            var Base = Construct({});
            ok(new Base() instanceof Construct);
            var Inherit = Base({});
            ok(new Inherit() instanceof Base);
        });
        test('Creating', function () {
            new this.Dog();
            var a1 = new this.Animal();
            new this.Animal();
            var ajax = new this.Ajax(1000);
            equal(2, this.Animal.count, 'right number of animals');
            equal(1, this.Dog.count, 'right number of animals');
            ok(this.Dog.match, 'right number of animals');
            ok(!this.Animal.match, 'right number of animals');
            ok(this.Dog.test(), 'right number of animals');
            ok(!this.Animal.test(), 'right number of animals');
            equal(1, this.Ajax.count, 'right number of animals');
            equal(2, this.Animal.count, 'right number of animals');
            equal(true, ajax.eyes, 'right number of animals');
            equal(1000, ajax.hairs, 'right number of animals');
            ok(a1 instanceof this.Animal);
            ok(a1 instanceof Construct);
        });
        test('new instance', function () {
            var d = this.Ajax.newInstance(6);
            equal(6, d.hairs);
        });
        test('namespaces', function () {
            var fb = Construct.extend('Bar');
            ok(!window.Bar, 'not added to global namespace');
            equal(fb.shortName, 'Bar', 'short name is right');
        });
        test('setups', function () {
            var order = 0, staticSetup, staticSetupArgs, staticInit, staticInitArgs, protoSetup, protoInitArgs, protoInit, staticProps = {
                    setup: function () {
                        staticSetup = ++order;
                        staticSetupArgs = arguments;
                        return ['something'];
                    },
                    init: function () {
                        staticInit = ++order;
                        staticInitArgs = arguments;
                    }
                }, protoProps = {
                    setup: function (name) {
                        protoSetup = ++order;
                        return ['Ford: ' + name];
                    },
                    init: function () {
                        protoInit = ++order;
                        protoInitArgs = arguments;
                    }
                };
            var Car = Construct.extend('Car', staticProps, protoProps);
            new Car('geo');
            equal(staticSetup, 1);
            equal(staticInit, 2);
            equal(protoSetup, 3);
            equal(protoInit, 4);
            deepEqual(makeArray(staticInitArgs), ['something']);
            deepEqual(makeArray(protoInitArgs), ['Ford: geo']);
            deepEqual(makeArray(staticSetupArgs), [
                Construct,
                'Car',
                staticProps,
                protoProps
            ], 'static construct');
            Car.extend('Truck');
            equal(staticSetup, 5, 'Static setup is called if overwriting');
        });
        test('Creating without extend', function () {
            var Bar = Construct('Bar', {
                ok: function () {
                    ok(true, 'ok called');
                }
            });
            new Bar().ok();
            var Foo = Bar('Foo', {
                dude: function () {
                    ok(true, 'dude called');
                }
            });
            new Foo().dude(true);
        });
        test('setup called with original arguments', function () {
            var o2 = {};
            var o1 = {
                setup: function (base, arg1, arg2) {
                    equal(o1, arg1, 'first argument is correct');
                    equal(o2, arg2, 'second argument is correct');
                }
            };
            Construct.extend(o1, o2);
        });
        test('legacy namespace strings (A.B.C) accepted', function () {
            var Type = Construct.extend('Foo.Bar.Baz');
            var expectedValue = ~steal.config('env').indexOf('production') ? '' : 'Foo_Bar_Baz';
            ok(new Type() instanceof Construct, 'No unexpected behavior in the prototype chain');
            if (Function.prototype.name) {
                equal(Type.name, expectedValue, 'Name becomes underscored');
            }
        });
        test('reserved words accepted', function () {
            var Type = Construct.extend('const');
            var expectedValue = ~steal.config('env').indexOf('production') ? '' : 'Const';
            ok(new Type() instanceof Construct, 'No unexpected behavior in the prototype chain');
            if (Function.prototype.name) {
                equal(Type.name, expectedValue, 'Name becomes capitalized');
            }
        });
        test('basic injection attacks thwarted', function () {
            var rootToken = typeof window === 'undefined' ? 'global' : 'window';
            var rootObject = typeof window === 'undefined' ? global : window;
            var expando = 'foo' + Math.random().toString(10).slice(2);
            var MalignantType;
            try {
                MalignantType = Construct.extend('(){};' + rootToken + '.' + expando + '=\'bar\';var f=function');
            } catch (e) {
            } finally {
                equal(rootObject[expando], undefined, 'Injected code doesn\'t run');
            }
            delete rootObject[expando];
            try {
                MalignantType = Construct.extend('(){},' + rootToken + '.' + expando + '=\'baz\',function');
            } catch (e) {
            } finally {
                equal(rootObject[expando], undefined, 'Injected code doesn\'t run');
            }
        });
        QUnit.test('setters not invoked on extension (#28)', function () {
            var extending = true;
            var Base = Construct.extend('Base', {
                set something(value) {
                    QUnit.ok(!extending, 'called when not extending');
                },
                get something() {
                }
            });
            Base.extend('Extended', { something: 'value' });
            extending = false;
            new Base().something = 'foo';
        });
        QUnit.test('return alternative value simple', function () {
            var Alternative = function () {
            };
            var Base = Construct.extend({
                setup: function () {
                    return new Construct.ReturnValue(new Alternative());
                }
            });
            QUnit.ok(new Base() instanceof Alternative, 'Should create an instance of Alternative');
        });
        QUnit.test('return alternative value on setup (full case)', function () {
            var Student = function (name, school) {
                this.name = name;
                this.school = school;
                this.isStudent = true;
            };
            var Person = Construct.extend({
                setup: function (opts) {
                    if (opts.age >= 16) {
                        return new Construct.ReturnValue(new Student(opts.name, opts.school));
                    }
                    opts.isStudent = false;
                    return [opts];
                },
                init: function (params) {
                    this.age = params.age;
                    this.name = params.name;
                    this.isStudent = params.isStudent;
                }
            });
            QUnit.equal(new Person({ age: 12 }).isStudent, false, 'Age 12 cannot be a student');
            QUnit.equal(new Person({ age: 30 }).isStudent, true, 'Age 20 can be a student');
            QUnit.ok(new Person({ age: 30 }) instanceof Student, 'Should return an instance of Student');
        });
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-util@3.10.12#js/omit/omit*/
define('can-util@3.10.12#js/omit/omit', function (require, exports, module) {
    'use strict';
    module.exports = function (source, propsToOmit) {
        var result = {};
        for (var prop in source) {
            if (propsToOmit.indexOf(prop) < 0) {
                result[prop] = source[prop];
            }
        }
        return result;
    };
});
/*can-util@3.10.12#dom/ajax/ajax*/
define('can-util@3.10.12#dom/ajax/ajax', [
    'require',
    'exports',
    'module',
    'can-log/dev/dev',
    'can-ajax'
], function (require, exports, module) {
    'use strict';
    var canDev = require('can-log/dev/dev');
    module.exports = require('can-ajax');
});
/*can-util@3.10.12#dom/dom*/
define('can-util@3.10.12#dom/dom', [
    'require',
    'exports',
    'module',
    './ajax/ajax',
    './attr/attr',
    './child-nodes/child-nodes',
    './class-name/class-name',
    './contains/contains',
    './data/data',
    './dispatch/dispatch',
    './document/document',
    './events/events',
    './frag/frag',
    './fragment/fragment',
    './is-of-global-document/is-of-global-document',
    './matches/matches',
    './mutate/mutate',
    './mutation-observer/mutation-observer'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        module.exports = {
            ajax: require('./ajax/ajax'),
            attr: require('./attr/attr'),
            childNodes: require('./child-nodes/child-nodes'),
            className: require('./class-name/class-name'),
            contains: require('./contains/contains'),
            data: require('./data/data'),
            dispatch: require('./dispatch/dispatch'),
            document: require('./document/document'),
            events: require('./events/events'),
            frag: require('./frag/frag'),
            fragment: require('./fragment/fragment'),
            isOfGlobalDocument: require('./is-of-global-document/is-of-global-document'),
            matches: require('./matches/matches'),
            mutate: require('./mutate/mutate'),
            mutationObserver: require('./mutation-observer/mutation-observer')
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-util@3.10.12#js/is-browser-window/is-browser-window*/
define('can-util@3.10.12#js/is-browser-window/is-browser-window', [
    'require',
    'exports',
    'module',
    'can-globals/is-browser-window/is-browser-window'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        module.exports = require('can-globals/is-browser-window/is-browser-window');
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-util@3.10.12#js/is-node/is-node*/
define('can-util@3.10.12#js/is-node/is-node', function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        module.exports = function () {
            return typeof process === 'object' && {}.toString.call(process) === '[object process]';
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-util@3.10.12#js/is-promise/is-promise*/
define('can-util@3.10.12#js/is-promise/is-promise', [
    'require',
    'exports',
    'module',
    'can-reflect'
], function (require, exports, module) {
    'use strict';
    var canReflect = require('can-reflect');
    module.exports = function (obj) {
        return canReflect.isPromise(obj);
    };
});
/*can-util@3.10.12#js/is-string/is-string*/
define('can-util@3.10.12#js/is-string/is-string', [
    'require',
    'exports',
    'module',
    'can-log/dev/dev'
], function (require, exports, module) {
    'use strict';
    var dev = require('can-log/dev/dev');
    var hasWarned = false;
    module.exports = function isString(obj) {
        return typeof obj === 'string';
    };
});
/*can-util@3.10.12#js/is-web-worker/is-web-worker*/
define('can-util@3.10.12#js/is-web-worker/is-web-worker', function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        module.exports = function () {
            return typeof WorkerGlobalScope !== 'undefined' && this instanceof WorkerGlobalScope;
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-util@3.10.12#js/js*/
define('can-util@3.10.12#js/js', [
    'require',
    'exports',
    'module',
    'can-assign',
    'can-cid',
    './deep-assign/deep-assign',
    './dev/dev',
    './diff/diff',
    './each/each',
    './global/global',
    './import/import',
    './is-array/is-array',
    './is-array-like/is-array-like',
    './is-browser-window/is-browser-window',
    './is-empty-object/is-empty-object',
    './is-function/is-function',
    './is-node/is-node',
    './is-plain-object/is-plain-object',
    './is-promise/is-promise',
    './is-string/is-string',
    './is-web-worker/is-web-worker',
    './join-uris/join-uris',
    './last/last',
    './make-array/make-array',
    './omit/omit',
    './set-immediate/set-immediate',
    './string/string',
    'can-types'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        module.exports = {
            assign: require('can-assign'),
            cid: require('can-cid'),
            deepAssign: require('./deep-assign/deep-assign'),
            dev: require('./dev/dev'),
            diff: require('./diff/diff'),
            each: require('./each/each'),
            global: require('./global/global'),
            'import': require('./import/import'),
            isArray: require('./is-array/is-array'),
            isArrayLike: require('./is-array-like/is-array-like'),
            isBrowserWindow: require('./is-browser-window/is-browser-window'),
            isEmptyObject: require('./is-empty-object/is-empty-object'),
            isFunction: require('./is-function/is-function'),
            isNode: require('./is-node/is-node'),
            isPlainObject: require('./is-plain-object/is-plain-object'),
            isPromise: require('./is-promise/is-promise'),
            isString: require('./is-string/is-string'),
            isWebWorker: require('./is-web-worker/is-web-worker'),
            joinURIs: require('./join-uris/join-uris'),
            last: require('./last/last'),
            makeArray: require('./make-array/make-array'),
            omit: require('./omit/omit'),
            setImmediate: require('./set-immediate/set-immediate'),
            string: require('./string/string'),
            types: require('can-types')
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-util@3.10.12#can-util*/
define('can-util@3.10.12#can-util', [
    'require',
    'exports',
    'module',
    './js/deep-assign/deep-assign',
    './js/omit/omit',
    'can-namespace',
    './dom/dom',
    './js/js'
], function (require, exports, module) {
    var deepAssign = require('./js/deep-assign/deep-assign');
    var omit = require('./js/omit/omit');
    var namespace = require('can-namespace');
    module.exports = deepAssign(namespace, require('./dom/dom'), omit(require('./js/js'), [
        'cid',
        'types'
    ]));
});
/*can-construct-super@3.1.2#can-construct-super*/
define('can-construct-super@3.1.2#can-construct-super', [
    'require',
    'exports',
    'module',
    'can-util',
    'can-construct'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var can = require('can-util');
        var Construct = require('can-construct');
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var isFunction = can.isFunction, fnTest = /xyz/.test(function () {
                return this.xyz;
            }) ? /\b_super\b/ : /.*/, getset = [
                'get',
                'set'
            ], getSuper = function (base, name, fn) {
                return function () {
                    var hasExistingValue = false;
                    var existingValue;
                    var prototype = getPrototypeOf(this);
                    var existingPrototypeValue = prototype._super;
                    if (hasOwnProperty.call(this, '_super')) {
                        hasExistingValue = true;
                        existingValue = this._super;
                        delete this._super;
                    }
                    prototype._super = base[name];
                    var ret = fn.apply(this, arguments);
                    prototype._super = existingPrototypeValue;
                    if (hasExistingValue) {
                        this._super = existingValue;
                    }
                    return ret;
                };
            };
        Construct._defineProperty = function (addTo, base, name, descriptor) {
            var _super = Object.getOwnPropertyDescriptor(base, name);
            if (_super) {
                can.each(getset, function (method) {
                    if (isFunction(_super[method]) && isFunction(descriptor[method])) {
                        descriptor[method] = getSuper(_super, method, descriptor[method]);
                    } else if (!isFunction(descriptor[method])) {
                        descriptor[method] = _super[method];
                    }
                });
            }
            Object.defineProperty(addTo, name, descriptor);
        };
        var getPrototypeOf = Object.getPrototypeOf || function (obj) {
            return obj.__proto__;
        };
        var getPropertyDescriptor = Object.getPropertyDescriptor || function (subject, name) {
            if (name in subject) {
                var pd = Object.getOwnPropertyDescriptor(subject, name);
                var proto = getPrototypeOf(subject);
                while (pd === undefined && proto !== null) {
                    pd = Object.getOwnPropertyDescriptor(proto, name);
                    proto = getPrototypeOf(proto);
                }
                return pd;
            }
        };
        Construct._overwrite = function (addTo, base, name, val) {
            var baseDescriptor = getPropertyDescriptor(base, name);
            var baseValue = baseDescriptor && baseDescriptor.value;
            Object.defineProperty(addTo, name, {
                value: isFunction(val) && isFunction(baseValue) && fnTest.test(val) ? getSuper(base, name, val) : val,
                configurable: true,
                enumerable: true,
                writable: true
            });
        };
        module.exports = Construct;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-construct-super@3.1.2#test/can-construct-super_test*/
define('can-construct-super@3.1.2#test/can-construct-super_test', [
    'require',
    'exports',
    'module',
    'can-construct-super',
    'steal-qunit'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var Construct = require('can-construct-super');
        var QUnit = require('steal-qunit');
        QUnit.module('can-construct-super');
        test('prototype super', function () {
            var A = Construct.extend({
                init: function (arg) {
                    this.arg = arg + 1;
                },
                add: function (num) {
                    return this.arg + num;
                }
            });
            var B = A({
                init: function (arg) {
                    this._super(arg + 2);
                },
                add: function (arg) {
                    return this._super(arg + 1);
                }
            });
            var b = new B(1);
            equal(b.arg, 4);
            equal(b.add(2), 7);
        });
        test('static super', function () {
            var First = Construct.extend({
                raise: function (num) {
                    return num;
                }
            }, {});
            var Second = First.extend({
                raise: function (num) {
                    return this._super(num) * num;
                }
            }, {});
            equal(Second.raise(2), 4);
        });
        test('findAll super', function () {
            var Parent = Construct.extend({
                findAll: function () {
                    equal(this.shortName, 'child');
                    return Promise.resolve();
                },
                shortName: 'parent'
            }, {});
            var Child = Parent.extend({
                findAll: function () {
                    return this._super();
                },
                shortName: 'child'
            }, {});
            stop();
            expect(1);
            Child.findAll({});
            start();
        });
        if (Object.getOwnPropertyDescriptor) {
            test('_super supports getters and setters', function () {
                var Person = Construct.extend({
                    get age() {
                        return 42;
                    },
                    set name(value) {
                        this._name = value;
                    },
                    get name() {
                        return this._name;
                    }
                });
                var OtherPerson = Person.extend({
                    get age() {
                        return this._super() + 8;
                    },
                    set name(value) {
                        this._super(value + '_super');
                    }
                });
                var test = new OtherPerson();
                test.base = 2;
                equal(test.age, 50, 'Getter and _super works');
                test.name = 'David';
                equal(test.name, 'David_super', 'Setter ran');
            });
        }
        QUnit.test('setters not invoked on extension (#9)', function () {
            var extending = true;
            var Base = Construct.extend('Base', {
                set something(value) {
                    QUnit.ok(!extending, 'set not called when not extending');
                },
                get something() {
                    QUnit.ok(!extending, 'get not called when not extending');
                }
            });
            Base.extend('Extended', { something: 'value' });
            extending = false;
            new Base().something = 'foo';
        });
        QUnit.test('_super isn\'t always available (#11)', function () {
            var Parent = Construct.extend({});
            var Child = Parent.extend({
                init: function () {
                    this._super();
                    ok(true);
                }
            });
            new Child();
        });
        QUnit.test('_super should work for sealed instances', function () {
            var A = Construct.extend({
                init: function (arg) {
                    this.arg = arg + 1;
                },
                add: function (num) {
                    return this.arg + num;
                }
            });
            var B = A({
                init: function (arg) {
                    this._super(arg + 2);
                },
                add: function (arg) {
                    return this._super(arg + 1);
                }
            });
            var b = new B(1);
            Object.seal(b);
            equal(b.arg, 4, 'should instantiate properly');
            equal(b.add(2), 7, 'should call methods properly');
        });
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-control@4.0.0-pre.2#can-control_test*/
define('can-control@4.0.0-pre.2#can-control_test', [
    'require',
    'exports',
    'module',
    'can-control',
    'steal-qunit',
    'can-util/dom/fragment/',
    'can-util/dom/data/',
    'can-util/js/dev/',
    'can-util/dom/dispatch/',
    'can-util/dom/class-name/',
    'can-util/dom/mutate/',
    'can-simple-map',
    'can-define/map/',
    'can-simple-observable'
], function (require, exports, module) {
    var Control = require('can-control');
    var QUnit = require('steal-qunit');
    var fragment = require('can-util/dom/fragment/');
    var domData = require('can-util/dom/data/');
    var dev = require('can-util/js/dev/');
    var domDispatch = require('can-util/dom/dispatch/');
    var className = require('can-util/dom/class-name/');
    var domMutate = require('can-util/dom/mutate/');
    var SimpleMap = require('can-simple-map');
    var DefineMap = require('can-define/map/');
    var SimpleObservable = require('can-simple-observable');
    QUnit.module('can-control', {
        setup: function () {
            this.fixture = document.getElementById('qunit-fixture');
        }
    });
    test('data', function () {
        var Things = Control.extend({});
        this.fixture.appendChild(fragment('<div id=\'things\'>div<span>span</span></div>'));
        var things = document.getElementById('things');
        var c1 = new Things('#things', {});
        var c2 = new Things('#things', {});
        equal(domData.get.call(things, 'controls').length, 2, 'there are 2 items in the data array');
        c1.destroy();
        equal(domData.get.call(things, 'controls').length, 1, 'there is 1 item in the data array');
        c2.destroy();
        equal(domData.get.call(things, 'controls').length, 0, 'there are 0 items in the data array');
    });
    test('parameterized actions', function () {
        var called = false, WeirderBind = Control.extend({
                '{parameterized}': function () {
                    called = true;
                }
            }), a;
        this.fixture.appendChild(fragment('<div id=\'crazy\'></div>'));
        a = document.getElementById('crazy');
        new WeirderBind(a, { parameterized: 'sillyEvent' });
        domDispatch.call(a, 'sillyEvent');
        ok(called, 'heard the trigger');
    });
    test('windowresize', function () {
        var called = false, WindowBind = Control.extend('', {
                '{window} resize': function () {
                    called = true;
                }
            });
        this.fixture.appendChild(fragment('<div id=\'weird\'>'));
        new WindowBind('#weird');
        domDispatch.call(window, 'resize');
        ok(called, 'got window resize event');
    });
    test('on', 9, function () {
        var called = false, DelegateTest = Control.extend({
                click: function () {
                }
            }), Tester = Control.extend({
                init: function (el, ops) {
                    this.on(window, 'click', function (ev) {
                        ok(true, 'Got window click event');
                    });
                    this.on(window, 'click', 'clicked');
                    this.on('click', function () {
                        ok(true, 'Directly clicked element');
                    });
                    this.on('click', 'clicked');
                },
                clicked: function (context) {
                    ok(true, 'Controller action delegated click triggered, too');
                }
            }), div = document.createElement('div');
        this.fixture.appendChild(div);
        var rb = new Tester(div);
        this.fixture.appendChild(fragment('<div id=\'els\'><span id=\'elspan\'><a href=\'javascript://\' id=\'elsa\'>click me</a></span></div>'));
        var dt = new DelegateTest('#els');
        dt.on(document.querySelector('#els span'), 'a', 'click', function () {
            called = true;
        });
        domDispatch.call(document.querySelector('#els a'), 'click');
        ok(called, 'delegate works');
        domMutate.removeChild.call(this.fixture, document.querySelector('#els'));
        domDispatch.call(div, 'click');
        domDispatch.call(window, 'click');
        rb.destroy();
    });
    test('inherit', function () {
        var called = false, Parent = Control.extend({
                click: function () {
                    called = true;
                }
            }), Child = Parent.extend({});
        this.fixture.appendChild(fragment('<div id=\'els\'><span id=\'elspan\'><a href=\'#\' id=\'elsa\'>click me</a></span></div>'));
        new Child('#els');
        domDispatch.call(document.querySelector('#els'), 'click');
        ok(called, 'inherited the click method');
    });
    test('space makes event', 1, function () {
        var Dot = Control.extend({
            ' foo': function () {
                ok(true, 'called');
            }
        });
        this.fixture.appendChild(fragment('<div id=\'els\'><span id=\'elspan\'><a href=\'#\' id=\'elsa\'>click me</a></span></div>'));
        new Dot('#els');
        domDispatch.call(document.querySelector('#els'), 'foo');
    });
    test('custom events with hyphens work', 1, function () {
        this.fixture.appendChild(fragment('<div id=\'customEvent\'><span></span></div>'));
        var FooBar = Control.extend({
            'span custom-event': function () {
                ok(true, 'Custom event was fired.');
            }
        });
        new FooBar('#customEvent');
        domDispatch.call(document.querySelector('#customEvent span'), 'custom-event');
    });
    test('inherit defaults', function () {
        var BASE = Control.extend({ defaults: { foo: 'bar' } }, {});
        var INHERIT = BASE.extend({ defaults: { newProp: 'newVal' } }, {});
        ok(INHERIT.defaults.foo === 'bar', 'Class must inherit defaults from the parent class');
        ok(INHERIT.defaults.newProp === 'newVal', 'Class must have own defaults');
        var inst = new INHERIT(document.createElement('div'), {});
        ok(inst.options.foo === 'bar', 'Instance must inherit defaults from the parent class');
        ok(inst.options.newProp === 'newVal', 'Instance must have defaults of it`s class');
    });
    test('on rebinding', 2, function () {
        var first = true;
        var Rebinder = Control.extend({
            '{item} foo': function (item, ev) {
                if (first) {
                    equal(item.get('id'), 1, 'first item');
                    first = false;
                } else {
                    equal(item.get('id'), 2, 'first item');
                }
            }
        });
        var item1 = new SimpleMap({ id: 1 }), item2 = new SimpleMap({ id: 2 }), rb = new Rebinder(document.createElement('div'), { item: item1 });
        item1.dispatch('foo');
        rb.options = { item: item2 };
        rb.on();
        item2.dispatch('foo');
    });
    test('actions provide method names', function () {
        var item1 = new SimpleMap({});
        var item2 = new SimpleMap({});
        var Tester = Control.extend({
            '{item1} foo': 'food',
            '{item2} bar': 'food',
            food: function (item, ev, data) {
                ok(true, 'food called');
                ok(item === item1 || item === item2, 'called with an item');
            }
        });
        new Tester(document.createElement('div'), {
            item1: item1,
            item2: item2
        });
        item1.dispatch('foo');
        item2.dispatch('bar');
    });
    test('Don\'t bind if there are undefined values in templates', function () {
        var C = Control.extend({}, {
            '{noExistStuff} proc': function () {
            }
        });
        var c = new C(document.createElement('div'));
        equal(c._bindings.user.length, 1, 'There is only one binding');
        var C2 = Control.extend({
            '{noExistStuff} click': function () {
                ok(false, 'should not fall through to click handler');
            }
        });
        var div = document.createElement('div');
        new C2(div, {});
        domDispatch.call(div, 'click');
    });
    test('Multiple calls to destroy', 2, function () {
        var C = Control.extend({
                destroy: function () {
                    ok(true);
                    Control.prototype.destroy.call(this);
                }
            }), div = document.createElement('div'), c = new C(div);
        c.destroy();
        c.destroy();
    });
    test('drag and drop events', function () {
        expect(7);
        var DragDrop = Control.extend('', {
            ' dragstart': function () {
                ok(true, 'dragstart called');
            },
            ' dragenter': function () {
                ok(true, 'dragenter called');
            },
            ' dragover': function () {
                ok(true, 'dragover called');
            },
            ' dragleave': function () {
                ok(true, 'dragleave called');
            },
            ' drag': function () {
                ok(true, 'drag called');
            },
            ' drop': function () {
                ok(true, 'drop called');
            },
            ' dragend': function () {
                ok(true, 'dragend called');
            }
        });
        this.fixture.appendChild(fragment('<div id="draggable"/>'));
        new DragDrop('#draggable');
        var draggable = document.getElementById('draggable');
        domDispatch.call(draggable, 'dragstart');
        domDispatch.call(draggable, 'dragenter');
        domDispatch.call(draggable, 'dragover');
        domDispatch.call(draggable, 'dragleave');
        domDispatch.call(draggable, 'drag');
        domDispatch.call(draggable, 'drop');
        domDispatch.call(draggable, 'dragend');
    });
    test('beforeremove event', function () {
        expect(1);
        var Foo = Control.extend('', {
            'beforeremove': function () {
                ok(true, 'beforeremove called');
            }
        });
        var el = fragment('<div id="foo"/>');
        new Foo(el);
        domDispatch.call(el, 'beforeremove');
    });
    if (System.env.indexOf('production') < 0) {
        test('Control is logging information in dev mode', function () {
            expect(2);
            var oldlog = dev.log;
            var oldwarn = dev.warn;
            dev.log = function (text) {
                equal(text, 'can-control: No property found for handling {dummy} change', 'Text logged as expected');
            };
            var C = Control.extend({
                '{dummy} change': function () {
                }
            });
            var instance = new C(document.createElement('div'));
            dev.warn = function (text) {
                equal(text, 'can-control: Control already destroyed', 'control destroyed warning');
            };
            instance.destroy();
            instance.destroy();
            dev.warn = oldwarn;
            dev.log = oldlog;
        });
    }
    test('event handlers should rebind when target is replaced', function () {
        var nameChanges = 0;
        var MyControl = Control.extend('MyControl', {
            '{person.name} first': function () {
                nameChanges++;
            },
            name: function (name) {
                this.options.person.set('name', name);
            }
        });
        var c = new MyControl(document.createElement('div'), { person: new SimpleMap({ name: new SimpleMap({ first: 'Kevin' }) }) });
        c.options.person.get('name').set('first', 'Tracy');
        c.name(new SimpleMap({ first: 'Kim' }));
        c.options.person.get('name').get('first', 'Max');
        equal(nameChanges, 2);
    });
    test('{element} event handling', function () {
        expect(3);
        stop();
        var MyControl = Control.extend({
            '{element} click': function (element) {
                if (element === this.element) {
                    ok(true, '`{element} click` should catch clicking on the element');
                } else {
                    ok(true, '`{element} click` should catch clicking on a child of the element');
                }
            },
            '{element} p click': function () {
                ok(true, '`{element} p click` works');
                start();
            }
        });
        var div = document.createElement('div');
        var p = document.createElement('p');
        div.appendChild(p);
        new MyControl(div, { foo: 'bar' });
        domDispatch.call(div, 'click');
        domDispatch.call(p, 'click');
    });
    test('Passing a Map as options works', function () {
        expect(2);
        stop();
        var MyControl = Control.extend({ defaults: { testEndEvent: 'mouseleave' } }, {
            '{element} {eventType}': function () {
                ok(true, 'catches handler from options');
            },
            '{element} {testEndEvent}': function () {
                ok(true, 'catches handler from defaults');
                start();
            }
        });
        var map = new SimpleMap({ eventType: 'click' });
        var div = document.createElement('div');
        new MyControl(div, map);
        map.attr('eventType', 'mouseenter');
        domDispatch.call(div, 'mouseenter');
        domDispatch.call(div, 'mouseleave');
    });
    test('Passing a DefineMap as options works', function () {
        expect(2);
        stop();
        var MyControl = Control.extend({ defaults: { testEndEvent: 'mouseleave' } }, {
            '{element} {eventType}': function () {
                ok(true, 'catches handler from options');
            },
            '{element} {testEndEvent}': function () {
                ok(true, 'catches handler from defaults');
                start();
            }
        });
        var MyMap = DefineMap.extend({
            eventType: 'string',
            testEndEvent: 'string'
        });
        var map = new MyMap();
        map.eventType = 'click';
        var div = document.createElement('div');
        new MyControl(div, map);
        map.eventType = 'mousenter';
        domDispatch.call(div, 'mousenter');
        domDispatch.call(div, 'mouseleave');
    });
    test('Creating an instance of a named control without passing an element', function () {
        var MyControl = Control.extend('MyControl');
        try {
            new MyControl();
        } catch (e) {
            ok(true, 'Caught an exception');
        }
    });
    test('Creating an instance of a named control passing a selector', function () {
        this.fixture.appendChild(fragment('<div id=\'my-control\'>d</div>'));
        var MyControl = Control.extend('MyControl');
        var myControlInstance = new MyControl('#my-control');
        ok(className.has.call(myControlInstance.element, 'MyControl'), 'Element has the correct class name');
    });
    test('destroy should not throw when domData is removed (#57)', function () {
        var Things = Control.extend({
            destroy: function () {
                if (this.element) {
                    domData.delete.call(this.element);
                }
                Control.prototype.destroy.call(this);
            }
        });
        this.fixture.appendChild(fragment('<div id=\'things\'>div<span>span</span></div>'));
        var things = document.getElementById('things');
        var c1 = new Things('#things', {});
        new Things('#things', {});
        equal(domData.get.call(things, 'controls').length, 2, 'there are 2 items in the data array');
        try {
            c1.destroy();
            QUnit.ok(true);
        } catch (e) {
            QUnit.ok(false, e);
        }
    });
    QUnit.test('can watch SimpleObservable', function () {
        var MyControl = Control.extend({
            '{simple}': function (simple, newVal) {
                QUnit.equal(newVal, 6);
            }
        });
        var div = document.createElement('div');
        var simple = new SimpleObservable(5);
        new MyControl(div, { simple: simple });
        simple.set(6);
    });
});
/*can-define-lazy-value@1.0.0#define-lazy-value-test*/
define('can-define-lazy-value@1.0.0#define-lazy-value-test', [
    'steal-qunit',
    './define-lazy-value'
], function (_stealQunit, _defineLazyValue) {
    'use strict';
    var _stealQunit2 = _interopRequireDefault(_stealQunit);
    var _defineLazyValue2 = _interopRequireDefault(_defineLazyValue);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    _stealQunit2.default.module('can-define-lazy-value');
    _stealQunit2.default.test('docs', function () {
        var _id = 1;
        function getId() {
            return _id++;
        }
        function MyObj(name) {
            this.name = name;
        }
        (0, _defineLazyValue2.default)(MyObj.prototype, 'id', getId);
        var obj1 = new MyObj('obj1');
        var obj2 = new MyObj('obj2');
        _stealQunit2.default.equal(obj2.id, 1, 'first object read should get id 1');
        _stealQunit2.default.equal(obj1.id, 2, 'second object read should get id 2');
        try {
            obj1.id = 3;
        } catch (e) {
            _stealQunit2.default.ok(true, 'obj1.id should not be writable by default');
        }
        (0, _defineLazyValue2.default)(MyObj.prototype, 'id', getId, true);
        var obj3 = new MyObj('obj3');
        _stealQunit2.default.equal(obj3.id, 3, 'obj3 should have id');
        obj3.id = 4;
        _stealQunit2.default.equal(obj3.id, 4, 'obj3.id should be writeable');
    });
});
/*can-deparam@1.0.1#can-deparam*/
define('can-deparam@1.0.1#can-deparam', [
    'require',
    'exports',
    'module',
    'can-namespace'
], function (require, exports, module) {
    var namespace = require('can-namespace');
    var digitTest = /^\d+$/, keyBreaker = /([^\[\]]+)|(\[\])/g, paramTest = /([^?#]*)(#.*)?$/, entityRegex = /%([^0-9a-f][0-9a-f]|[0-9a-f][^0-9a-f]|[^0-9a-f][^0-9a-f])/i, prep = function (str) {
            str = str.replace(/\+/g, ' ');
            try {
                return decodeURIComponent(str);
            } catch (e) {
                return decodeURIComponent(str.replace(entityRegex, function (match, hex) {
                    return '%25' + hex;
                }));
            }
        };
    module.exports = namespace.deparam = function (params) {
        var data = {}, pairs, lastPart;
        if (params && paramTest.test(params)) {
            pairs = params.split('&');
            pairs.forEach(function (pair) {
                var parts = pair.split('='), key = prep(parts.shift()), value = prep(parts.join('=')), current = data;
                if (key) {
                    parts = key.match(keyBreaker);
                    for (var j = 0, l = parts.length - 1; j < l; j++) {
                        if (!current[parts[j]]) {
                            current[parts[j]] = digitTest.test(parts[j + 1]) || parts[j + 1] === '[]' ? [] : {};
                        }
                        current = current[parts[j]];
                    }
                    lastPart = parts.pop();
                    if (lastPart === '[]') {
                        current.push(value);
                    } else {
                        current[lastPart] = value;
                    }
                }
            });
        }
        return data;
    };
});
/*can-deparam@1.0.1#can-deparam-test*/
define('can-deparam@1.0.1#can-deparam-test', [
    'require',
    'exports',
    'module',
    './can-deparam',
    'steal-qunit'
], function (require, exports, module) {
    var deparam = require('./can-deparam');
    var QUnit = require('steal-qunit');
    QUnit.module('can/util/string/deparam');
    test('Nested deparam', function () {
        var data = deparam('a[b]=1&a[c]=2');
        equal(data.a.b, 1);
        equal(data.a.c, 2);
        data = deparam('a[]=1&a[]=2');
        equal(data.a[0], 1);
        equal(data.a[1], 2);
        data = deparam('a[b][]=1&a[b][]=2');
        equal(data.a.b[0], 1);
        equal(data.a.b[1], 2);
        data = deparam('a[0]=1&a[1]=2');
        equal(data.a[0], 1);
        equal(data.a[1], 2);
    });
    test('Remaining ampersand', function () {
        var data = deparam('a[b]=1&a[c]=2&');
        deepEqual(data, {
            a: {
                b: '1',
                c: '2'
            }
        });
    });
    test('Invalid encoding', function () {
        var data = deparam('foo=%0g');
        deepEqual(data, { foo: '%0g' });
    });
});
/*can-event-queue@0.2.2#can-event-queue-test*/
define('can-event-queue@0.2.2#can-event-queue-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-event-queue',
    'can-queues'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var eventQueue = require('can-event-queue');
    var queues = require('can-queues');
    QUnit.module('can-event-queue', {
        setup: function () {
        },
        teardown: function () {
        }
    });
    QUnit.test('basics', function () {
        var collecting;
        var secondFired = false;
        var obj = eventQueue({});
        obj.on('first', function (ev, arg1, arg2) {
            QUnit.equal(arg1, 1, 'first arg');
            QUnit.equal(arg2, 2, 'second arg');
            QUnit.ok(!collecting, 'not collecting b/c we\'re not in a batch yet');
            obj.dispatch('second');
            QUnit.equal(secondFired, false, 'don\'t fire yet, put in next batch');
        });
        obj.on('second', function (ev) {
            secondFired = true;
            QUnit.ok(ev.batchNum, 'got a batch number');
        });
        queues.batch.start();
        obj.dispatch('first', [
            1,
            2
        ]);
        queues.batch.stop();
    });
    test('Everything is part of a batch', function () {
        var obj = eventQueue({});
        obj.on('foo', function (ev) {
            ok(ev.batchNum);
        });
        obj.dispatch('foo');
    });
    QUnit.test('flushing works (#18)', 3, function () {
        var firstFired, secondFired, thirdFired;
        var obj = eventQueue({});
        obj.on('first', function () {
            eventQueue.flush();
            QUnit.ok(firstFired, 'first fired');
            QUnit.ok(secondFired, 'second fired');
            QUnit.ok(thirdFired, 'third fired');
        });
        obj.on('first', function () {
            firstFired = true;
        });
        obj.on('second', function () {
            secondFired = true;
        });
        obj.on('third', function () {
            thirdFired = true;
        });
        queues.batch.start();
        obj.dispatch('first');
        obj.dispatch('second');
        obj.dispatch('third');
        queues.batch.stop();
    });
    QUnit.test('flushing a future batch (#18)', 3, function () {
        var firstFired, secondFired, thirdFired;
        var obj = eventQueue({});
        obj.on('first', function () {
            queues.batch.start();
            obj.dispatch('second');
            obj.dispatch('third');
            queues.batch.stop();
            eventQueue.flush();
            QUnit.ok(firstFired, 'first fired');
            QUnit.ok(secondFired, 'second fired');
            QUnit.ok(thirdFired, 'third fired');
        });
        obj.on('first', function () {
            firstFired = true;
        });
        obj.on('second', function () {
            secondFired = true;
        });
        obj.on('third', function () {
            thirdFired = true;
        });
        queues.batch.start();
        obj.dispatch('first');
        queues.batch.stop();
    });
});
/*can-globals@0.2.3#test-wrapper*/
define('can-globals@0.2.3#test-wrapper', [
    'require',
    'exports',
    'module',
    'qunitjs',
    'steal-qunit'
], function (require, exports, module) {
    var testType = typeof process !== 'undefined' && process.env.TEST;
    var isMochaQUnitUI = testType === 'mocha';
    var isQunit = testType === 'qunit';
    if (isMochaQUnitUI) {
        QUnit.assert.async = function () {
            QUnit.stop();
            return function done(error) {
                if (error) {
                    return QUnit.ok(false, '' + error);
                }
                QUnit.start();
            };
        };
        QUnit.test = test;
        module.exports = QUnit;
    } else if (isQunit) {
        module.exports = require('qunitjs');
    } else {
        module.exports = require('steal-qunit');
    }
});
/*can-globals@0.2.3#spy*/
define('can-globals@0.2.3#spy', function (require, exports, module) {
    'use strict';
    function spy(value) {
        var fn;
        var calls = [];
        if (typeof value === 'function') {
            fn = value;
        } else {
            fn = function () {
                return value;
            };
        }
        function wrapper() {
            var args = Array.prototype.slice.call(arguments);
            var ret = fn.apply(this, args);
            calls.push({
                calledWith: args,
                returned: ret
            });
            return ret;
        }
        Object.defineProperties(wrapper, {
            reset: {
                value: function () {
                    calls = [];
                }
            },
            callCount: {
                get: function () {
                    return calls.length;
                }
            },
            calls: {
                get: function () {
                    return calls;
                }
            }
        });
        return wrapper;
    }
    module.exports = spy;
});
/*can-globals@0.2.3#can-globals-test*/
define('can-globals@0.2.3#can-globals-test', [
    'require',
    'exports',
    'module',
    './can-globals-proto',
    './test-wrapper',
    './spy'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var Globals = require('./can-globals-proto');
        var QUnit = require('./test-wrapper');
        var spy = require('./spy');
        var globals;
        function mapEvents(spy) {
            return spy.calls.reduce(function (acc, cur) {
                return acc.concat(cur.calledWith[0]);
            }, []);
        }
        function loop(fn, count, ctx) {
            for (var i = count; i > 0; i--) {
                if (ctx) {
                    fn.call(ctx, i);
                    continue;
                }
                fn(i);
            }
        }
        QUnit.module('can-globals/can-globals-proto');
        QUnit.test('getKeyValue of undefined property', function () {
            globals = new Globals();
            globals.getKeyValue('test');
            ok(true);
        });
        QUnit.test('setKeyValue of undefined property', function () {
            globals = new Globals();
            globals.setKeyValue('foo', 'bar');
            equal(globals.getKeyValue('foo'), 'bar');
        });
        QUnit.test('deleteKeyValue of undefined property', function () {
            globals = new Globals();
            globals.deleteKeyValue('test');
            ok(true);
        });
        QUnit.test('onKeyValue of undefined property', function () {
            globals = new Globals();
            globals.onKeyValue('test', function () {
            });
            ok(true);
        });
        QUnit.test('offKeyValue of undefined property', function () {
            globals = new Globals();
            globals.offKeyValue('test', function () {
            });
            ok(true);
        });
        QUnit.test('makeExport of undefined property', function () {
            globals = new Globals();
            globals.makeExport('test');
            ok(true);
        });
        QUnit.test('define with cache disabled', function () {
            var getter = spy('bar');
            globals = new Globals();
            globals.define('foo', getter, false);
            loop(function () {
                globals.getKeyValue('foo');
            }, 5);
            equal(getter.callCount, 5);
        });
        QUnit.test('define with cache enabled', function () {
            var getter = spy('bar');
            globals = new Globals();
            globals.define('foo', getter);
            loop(function () {
                globals.getKeyValue('foo');
            }, 5);
            equal(getter.callCount, 1);
        });
        QUnit.test('define and get a new property', function () {
            globals = new Globals();
            globals.define('test', 'default');
            equal(globals.getKeyValue('test'), 'default');
        });
        QUnit.test('setKeyValue of existing property to string', function () {
            globals = new Globals();
            globals.define('test', 'default');
            globals.setKeyValue('test', 'updated');
            equal(globals.getKeyValue('test'), 'updated');
        });
        QUnit.test('setKeyValue of existing property to undefined', function () {
            globals = new Globals();
            globals.define('test', 'default');
            globals.setKeyValue('test', undefined);
            equal(globals.getKeyValue('test'), undefined);
        });
        QUnit.test('setKeyValue of existing property to a function', function () {
            globals = new Globals();
            globals.define('test', 'default');
            globals.setKeyValue('test', function () {
                return 'foo';
            });
            equal(globals.getKeyValue('test'), 'foo');
        });
        QUnit.test('setKeyValue on an existing property should reset cache', function () {
            var globals = new Globals();
            var bar = function () {
                return 'bar';
            };
            globals.define('foo', bar);
            globals.getKeyValue('foo');
            globals.setKeyValue('foo', function () {
                return 'baz';
            });
            equal(globals.getKeyValue('foo'), 'baz');
        });
        QUnit.test('deleteKeyValue to reset property to default', function () {
            var globals = new Globals();
            globals.define('test', 'default');
            globals.setKeyValue('test', 'updated');
            globals.deleteKeyValue('test');
            equal(globals.getKeyValue('test'), 'default');
        });
        QUnit.test('deleteKeyValue should clear cache', function () {
            var globals = new Globals();
            var bar = spy('bar');
            globals.define('foo', bar);
            globals.getKeyValue('foo');
            globals.setKeyValue('foo', function () {
                return 'baz';
            });
            globals.deleteKeyValue('foo');
            globals.getKeyValue('foo');
            equal(bar.callCount, 2);
        });
        QUnit.test('listen for key change', function () {
            var globals = new Globals();
            var handler = spy();
            globals.define('test', 'default');
            globals.define('foo', 'bar');
            globals.onKeyValue('test', handler);
            globals.setKeyValue('test', 'updated');
            globals.setKeyValue('foo', 'baz');
            globals.deleteKeyValue('test');
            equal(handler.callCount, 2);
            deepEqual(mapEvents(handler), [
                'updated',
                'default'
            ]);
        });
        QUnit.test('remove event listener for key', function () {
            var globals = new Globals();
            var handler = spy();
            globals.define('test', 'foo');
            globals.onKeyValue('test', handler);
            globals.offKeyValue('test', handler);
            globals.setKeyValue('test', 'updated');
            equal(handler.callCount, 0);
        });
        QUnit.test('makeExport of key', function () {
            var globals = new Globals();
            globals.define('foo', 'bar');
            var e = globals.makeExport('foo');
            equal(e(), 'bar');
            e('baz');
            equal(e(), 'baz');
            e(undefined);
            equal(e(), 'bar');
        });
        QUnit.test('reset export value with null (can-stache#288)', function () {
            var globals = new Globals();
            globals.define('foo', 'bar');
            var e = globals.makeExport('foo');
            equal(e(), 'bar');
            e('baz');
            equal(e(), 'baz');
            e(null);
            equal(e(), 'bar');
        });
        QUnit.test('reset all keys', function () {
            var globals = new Globals();
            var bar = spy('bar');
            var qux = spy('qux');
            globals.define('foo', bar);
            globals.define('baz', qux);
            loop(function () {
                globals.getKeyValue('foo');
                globals.getKeyValue('baz');
            }, 5);
            globals.reset();
            loop(function () {
                globals.getKeyValue('foo');
                globals.getKeyValue('baz');
            }, 5);
            equal(bar.callCount, 2);
            equal(qux.callCount, 2);
        });
        QUnit.test('reset triggers events', function () {
            var globals = new Globals();
            var fooHandler = spy();
            var barHandler = spy();
            globals.define('foo', true);
            globals.define('bar', true);
            globals.setKeyValue('foo', false);
            globals.setKeyValue('bar', false);
            globals.onKeyValue('foo', fooHandler);
            globals.onKeyValue('bar', barHandler);
            globals.reset();
            equal(fooHandler.callCount, 1);
            equal(barHandler.callCount, 1);
        });
        QUnit.test('export helper value can be set to a function', function () {
            var globals = new Globals();
            var foo = spy();
            globals.setKeyValue('foo', function () {
                return function () {
                };
            });
            var fooExport = globals.makeExport('foo');
            fooExport(foo);
            QUnit.equal(typeof fooExport(), 'function');
            QUnit.equal(foo.callCount, 0);
            fooExport()();
            QUnit.equal(foo.callCount, 1);
        });
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-key-tree@0.1.0#can-key-tree-test*/
define('can-key-tree@0.1.0#can-key-tree-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    './can-key-tree',
    'can-reflect'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var KeyTree = require('./can-key-tree');
    var canReflect = require('can-reflect');
    QUnit.module('can-key-tree');
    QUnit.test('basics', function () {
        var keyTree = new KeyTree([
            Object,
            Object,
            Array
        ]);
        function handler1() {
        }
        function handler2() {
        }
        QUnit.equal(keyTree.size(), 0, 'empty');
        keyTree.add([
            'click',
            'li',
            handler1
        ]);
        keyTree.add([
            'click',
            'li',
            handler2
        ]);
        QUnit.equal(keyTree.size(), 2, '2');
        QUnit.deepEqual(keyTree.get([
            'click',
            'li'
        ]), [
            handler1,
            handler2
        ]);
        keyTree.delete([
            'click',
            'li',
            handler1
        ]);
        QUnit.equal(keyTree.size(), 1, '1');
        keyTree.delete([
            'click',
            'li',
            handler1
        ]);
        QUnit.equal(keyTree.size(), 1, 'empty');
        keyTree.delete([
            'click',
            'li',
            handler2
        ]);
        QUnit.equal(keyTree.size(), 0, 'empty');
    });
    QUnit.test('root isnt a constructor', function () {
        var root = {};
        var keyTree = new KeyTree([
            root,
            Object,
            Array
        ]);
        function handler1() {
        }
        function handler2() {
        }
        QUnit.equal(keyTree.size(), 0, 'empty');
        keyTree.add([
            'click',
            'li',
            handler1
        ]);
        keyTree.add([
            'click',
            'li',
            handler2
        ]);
        QUnit.equal(canReflect.size(root), 1, '2');
        QUnit.deepEqual(keyTree.get([
            'click',
            'li'
        ]), [
            handler1,
            handler2
        ]);
        keyTree.delete([
            'click',
            'li',
            handler1
        ]);
        QUnit.equal(keyTree.size(), 1, '1');
        keyTree.delete([
            'click',
            'li',
            handler1
        ]);
        QUnit.equal(keyTree.size(), 1, 'empty');
        keyTree.delete([
            'click',
            'li',
            handler2
        ]);
        QUnit.equal(keyTree.size(), 0, 'empty');
    });
    QUnit.test('delete base recursively removes all properties', 2, function () {
        var MyMap = function (parentKey) {
            QUnit.equal(parentKey, 'element', 'got the right parent key');
            this.data = {};
        };
        canReflect.assignSymbols(MyMap.prototype, {
            'can.setKeyValue': function (key, value) {
                this.data[key] = value;
            },
            'can.getKeyValue': function (key) {
                return this.data[key];
            },
            'can.deleteKeyValue': function (key) {
                QUnit.equal(key, 'click', 'deleted 2');
                delete this.data[key];
            },
            'can.getOwnEnumerableKeys': function () {
                return Object.keys(this.data);
            }
        });
        var myTree = new KeyTree([
            Object,
            MyMap,
            Object,
            Array
        ]);
        myTree.add([
            'element',
            'click',
            'li',
            'A'
        ]);
        myTree.add([
            'element',
            'click',
            'li',
            'B'
        ]);
        myTree.delete(['element']);
    });
    if (typeof document !== 'undefined' && document.body && document.body.matches) {
        QUnit.test('event delegation example', function () {
            var fixture = document.querySelector('#qunit-fixture');
            fixture.innerHTML = '<li><a id=\'anchor\'>click</a></li>';
            var EventHandler = function (parentKey) {
                this.element = parentKey;
                this.events = {};
                this.delegated = {};
            };
            canReflect.assignSymbols(EventHandler.prototype, {
                'can.setKeyValue': function (eventName, handlersBySelector) {
                    this.delegated[eventName] = function (ev) {
                        canReflect.each(handlersBySelector, function (handlers, selector) {
                            var cur = ev.target;
                            do {
                                if (cur.matches(selector)) {
                                    handlers.forEach(function (handler) {
                                        handler.call(cur, ev);
                                    });
                                }
                                cur = cur.parentNode;
                            } while (cur && cur !== ev.currentTarget);
                        });
                    };
                    this.events[eventName] = handlersBySelector;
                    this.element.addEventListener(eventName, this.delegated[eventName]);
                },
                'can.getKeyValue': function (eventName) {
                    return this.events[eventName];
                },
                'can.deleteKeyValue': function (eventName) {
                    this.element.removeEventListener(eventName, this.delegated[eventName]);
                    delete this.delegated[eventName];
                    delete this.events[eventName];
                },
                'can.getOwnEnumerableKeys': function () {
                    return Object.keys(this.events);
                }
            });
            var eventTree = new KeyTree([
                Map,
                EventHandler,
                Object,
                Array
            ]);
            var dispatchNum = 0;
            function dispatch(el) {
                var event = document.createEvent('HTMLEvents');
                event.initEvent('click', true, false);
                dispatchNum++;
                document.querySelector(el).dispatchEvent(event);
            }
            function handler1() {
                QUnit.equal(dispatchNum, 1, 'only dispatched once');
            }
            eventTree.add([
                fixture,
                'click',
                'li',
                handler1
            ]);
            dispatch('#anchor');
            eventTree.delete([
                fixture,
                'click',
                'li',
                handler1
            ]);
            dispatch('#anchor');
            function handler2() {
                QUnit.equal(dispatchNum, 3, 'handler2');
            }
            function handler3() {
                QUnit.equal(dispatchNum, 3, 'handler3');
            }
            eventTree.add([
                fixture,
                'click',
                'li',
                handler2
            ]);
            eventTree.add([
                fixture,
                'click',
                'li',
                handler3
            ]);
            dispatch('#anchor');
            eventTree.delete([fixture]);
            dispatch('#anchor');
        });
    }
    QUnit.test('.getNode and .get', function () {
        var keyTree = new KeyTree([
            Object,
            Object,
            Array
        ]);
        function handler1() {
        }
        function handler2() {
        }
        keyTree.add([
            'click',
            'li',
            handler1
        ]);
        keyTree.add([
            'click',
            'li',
            handler2
        ]);
        keyTree.add([
            'click',
            'span',
            handler2
        ]);
        QUnit.deepEqual(keyTree.getNode(['click']), {
            li: [
                handler1,
                handler2
            ],
            span: [handler2]
        }, '.getNode works');
        QUnit.deepEqual(keyTree.get(['click']), [
            handler1,
            handler2,
            handler2
        ], '.get works');
    });
    QUnit.test('lifecycle callbacks', function () {
        var calls = 0;
        var keyTree = new KeyTree([
            Object,
            Object,
            Array
        ], {
            onFirst: function () {
                QUnit.equal(calls, 1, 'called when the first node is added');
            },
            onEmpty: function () {
                QUnit.equal(calls, 3, 'called when all nodes are removed');
            }
        });
        function handler1() {
        }
        function handler2() {
        }
        calls++;
        keyTree.add([
            'click',
            'li',
            handler1
        ]);
        calls++;
        keyTree.add([
            'click',
            'li',
            handler2
        ]);
        calls++;
        keyTree.delete([]);
    });
    QUnit.test('handle missing keys', function () {
        var keyTree = new KeyTree([
            Object,
            Array
        ]);
        QUnit.notOk(keyTree.delete(['abc']));
        QUnit.ok(true, 'no error');
    });
    QUnit.test('add too deep (#3)', function () {
        var keyTree = new KeyTree([
            Object,
            Array
        ]);
        try {
            keyTree.add([
                1,
                2,
                3,
                4,
                5
            ]);
        } catch (e) {
            QUnit.equal(e.message, 'can-key-tree: Can not add path deeper than tree.');
        }
    });
    QUnit.test('empty deep', function () {
        var keyTree = new KeyTree([
            Object,
            Object,
            Object,
            Array
        ]);
        QUnit.deepEqual(keyTree.get('foo'), []);
    });
});
/*can-param@1.0.1#can-param-test*/
define('can-param@1.0.1#can-param-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    './can-param'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var param = require('./can-param');
    QUnit.module('can-param');
    QUnit.test('can-param', function () {
        QUnit.deepEqual(param({
            foo: 'bar',
            baz: 'zed'
        }), 'foo=bar&baz=zed', 'Regular object');
        QUnit.deepEqual(param({ foo: { bar: 'baz' } }), encodeURI('foo[bar]=baz'), 'Nested object');
        QUnit.deepEqual(param({
            foo: [
                'bar',
                'baz'
            ]
        }), encodeURI('foo[]=bar&foo[]=baz'), 'Nested array');
        QUnit.deepEqual(param({ foo: 'bar & baz' }), 'foo=bar+%26+baz', 'Spec chars values');
    });
});
/*can-queues@0.2.6#queue-test*/
define('can-queues@0.2.6#queue-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-queues',
    'can-util/js/dev/dev',
    './completion-queue'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var queues = require('can-queues');
    var canDev = require('can-util/js/dev/dev');
    var CompletionQueue = require('./completion-queue');
    QUnit.module('can-queues');
    QUnit.test('basics', function () {
        function makeCallbackMeta(handler, context) {
            return { log: [handler.name + ' by ' + context.name] };
        }
        var callbackOrder = [];
        var gc1, gc2, derivedChild, writableChild, root;
        gc1 = {
            name: 'gc1',
            notifyHandlers: [function derivedChild_queueUpdate() {
                    callbackOrder.push('derivedChild_queueUpdate');
                    derivedChild.queueUpdate();
                }],
            mutateHandlers: [function gc1_eventHandler_writableChild_dispatch() {
                    callbackOrder.push('gc1_eventHandler_writableChild_dispatch');
                    writableChild.dispatch();
                }],
            dispatch: function () {
                callbackOrder.push('gc1.dispatch');
                queues.enqueueByQueue({
                    notify: this.notifyHandlers,
                    mutate: this.mutateHandlers
                }, this, [], makeCallbackMeta);
            }
        };
        gc2 = {
            name: 'gc2',
            notifyHandlers: [function deriveChild_queueUpdate() {
                    callbackOrder.push('deriveChild_queueUpdate');
                }],
            mutateHandlers: [],
            dispatch: function () {
                callbackOrder.push('gc2.dispatch');
                queues.enqueueByQueue({
                    notify: this.notifyHandlers,
                    mutate: this.mutateHandlers
                }, this, [], makeCallbackMeta);
            }
        };
        derivedChild = {
            name: 'derivedChild',
            queueUpdate: function () {
                callbackOrder.push('derivedChild.queueUpdate');
                queues.deriveQueue.enqueue(this.update, this, [], {
                    priority: 1,
                    log: ['update on ' + this.name]
                });
            },
            update: function () {
                callbackOrder.push('derivedChild.update');
                queues.enqueueByQueue({
                    notify: this.notifyHandlers,
                    mutate: this.mutateHandlers
                }, this, [], makeCallbackMeta);
            },
            notifyHandlers: [function root_queueUpdate() {
                    callbackOrder.push('root_queueUpdate');
                    root.queueUpdate();
                }]
        };
        derivedChild.update = derivedChild.update.bind(derivedChild);
        writableChild = {
            name: 'writableChild',
            dispatch: function () {
                callbackOrder.push('writableChild.dispatch');
                queues.enqueueByQueue({
                    notify: this.notifyHandlers,
                    mutate: this.mutateHandlers
                }, this, [], makeCallbackMeta);
            },
            notifyHandlers: [function root_queueUpdate() {
                    callbackOrder.push('root_queueUpdate');
                    root.queueUpdate();
                }],
            mutateHandlers: [function eventHandler() {
                    callbackOrder.push('writableChild.eventHandler');
                }]
        };
        root = {
            name: 'root',
            queueUpdate: function () {
                callbackOrder.push('root.queueUpdate');
                queues.deriveQueue.enqueue(this.update, this, [], {
                    priority: 1,
                    log: ['update on ' + this.name]
                });
            },
            update: function () {
                callbackOrder.push('root.update');
                queues.enqueueByQueue({
                    notify: this.notifyHandlers,
                    mutate: this.mutateHandlers
                }, this, [], makeCallbackMeta);
            },
            mutateHandlers: [function eventHandler() {
                    callbackOrder.push('root.eventHandler');
                }]
        };
        root.update = root.update.bind(root);
        queues.batch.start();
        gc1.dispatch();
        gc2.dispatch();
        queues.batch.stop();
        QUnit.deepEqual(callbackOrder, [
            'gc1.dispatch',
            'gc2.dispatch',
            'derivedChild_queueUpdate',
            'derivedChild.queueUpdate',
            'deriveChild_queueUpdate',
            'derivedChild.update',
            'root_queueUpdate',
            'root.queueUpdate',
            'root.update',
            'gc1_eventHandler_writableChild_dispatch',
            'writableChild.dispatch',
            'root_queueUpdate',
            'root.queueUpdate',
            'root.update',
            'root.eventHandler',
            'writableChild.eventHandler',
            'root.eventHandler'
        ], 'abc');
    });
    if (System.env.indexOf('production') < 0) {
        QUnit.test('log basics', function () {
            var oldLog = canDev.log;
            canDev.log = function (area, name) {
                QUnit.equal('Test enqueuing:', area);
                QUnit.equal('fnName', name);
                canDev.log = function (area, name) {
                    QUnit.equal('Test running  :', area);
                    QUnit.equal('fnName', name);
                };
            };
            var queue = new queues.Queue('Test');
            queue.log();
            queue.enqueue(function fnName() {
            }, null, []);
            queue.flush();
            canDev.log = oldLog;
        });
        QUnit.test('logStack', function () {
            function makeCallbackMeta(handler, context) {
                return { log: [handler.name + ' by ' + context.name] };
            }
            var callbackOrder = [];
            var map, fullName, mapFullName;
            map = {
                name: 'map',
                notifyHandlers: [function derivedChild_queueUpdate() {
                        callbackOrder.push('derivedChild_queueUpdate');
                        fullName.queueUpdate();
                    }],
                dispatch: function () {
                    callbackOrder.push('map.dispatch');
                    queues.enqueueByQueue({
                        notify: this.notifyHandlers,
                        mutate: this.mutateHandlers
                    }, this, [], makeCallbackMeta, ['map.first = \'ramiya\'']);
                }
            };
            fullName = {
                name: 'fullName',
                queueUpdate: function () {
                    callbackOrder.push('fullName.queueUpdate');
                    queues.deriveQueue.enqueue(this.update, this, [], {
                        priority: 1,
                        log: ['update on ' + this.name]
                    });
                },
                update: function update() {
                    callbackOrder.push('fullName.update');
                    queues.enqueueByQueue({
                        notify: this.notifyHandlers,
                        mutate: this.mutateHandlers
                    }, this, [], makeCallbackMeta);
                },
                notifyHandlers: [],
                mutateHandlers: [function fullName_setFullNameProperty() {
                        mapFullName.dispatch();
                    }]
            };
            mapFullName = {
                name: 'map.fullName',
                mutateHandlers: [function mapFullName_handler() {
                        callbackOrder.push('gc1_eventHandler_writableChild_dispatch');
                        var stack = queues.stack();
                        QUnit.deepEqual(stack.map(function (task) {
                            return task.meta.stack.name + ' ' + task.context.name + ' ' + task.fn.name;
                        }), [
                            'NOTIFY map derivedChild_queueUpdate',
                            'DERIVE fullName update',
                            'MUTATE fullName fullName_setFullNameProperty',
                            'MUTATE map.fullName mapFullName_handler'
                        ]);
                        QUnit.deepEqual(stack[0].meta.reasonLog, ['map.first = \'ramiya\'']);
                    }],
                dispatch: function () {
                    callbackOrder.push('mapFullName.dispatch');
                    queues.enqueueByQueue({
                        notify: this.notifyHandlers,
                        mutate: this.mutateHandlers
                    }, this, [], makeCallbackMeta, ['map.fullName = \'Ramiya Meyer\'']);
                }
            };
            map.dispatch();
        });
    }
    QUnit.test('priority queue orders tasks correctly', function () {
        var queue = new queues.PriorityQueue('priority');
        var order = 0;
        queue.enqueue(function () {
            order++;
            QUnit.equal(order, 3, 'priority 1 ran after priority 0');
        }, null, [], { priority: 1 });
        var fn = function () {
            order++;
            QUnit.equal(order, 2, 'priority 2 ran after priority 0 because it was flushed');
        };
        queue.enqueue(function () {
            order++;
            QUnit.equal(order, 1, 'priority 0 ran first');
            queue.flushQueuedTask(fn);
        }, null, [], { priority: 0 });
        queue.enqueue(fn, null, [], { priority: 2 });
        queue.flush();
    });
    QUnit.test('priority queue works with holes in the order', function () {
        var queue = new queues.PriorityQueue('priority');
        var ran = [];
        queue.enqueue(function () {
            ran.push('priority 0');
        }, null, [], { priority: 0 });
        queue.enqueue(function () {
            ran.push('priority 10');
        }, null, [], { priority: 10 });
        queue.flush();
        QUnit.deepEqual(ran, [
            'priority 0',
            'priority 10'
        ]);
    });
    QUnit.test('DOM_UI_QUEUE', function () {
        var ran = [];
        queues.enqueueByQueue({
            'notify': [function notify() {
                    ran.push('notify');
                }],
            'derive': [
                function derive1() {
                    ran.push('derive1');
                },
                function derive2() {
                    ran.push('derive2');
                }
            ],
            'domUI': [function domUI() {
                    ran.push('domUI');
                }],
            'mutate': [function domUI() {
                    ran.push('mutate');
                }]
        });
        QUnit.deepEqual(ran, [
            'notify',
            'derive1',
            'derive2',
            'domUI',
            'mutate'
        ], 'ran all tasks');
    });
    QUnit.test('CompletionQueue', function () {
        var queue = new CompletionQueue('DOM');
        var ran = [];
        queue.enqueue(function () {
            ran.push('task 1:a');
            queue.enqueue(function () {
                ran.push('task 3');
            }, null, [], {});
            queue.flush();
            ran.push('task 1:b');
        }, null, [], {});
        queue.enqueue(function () {
            ran.push('task 2');
        }, null, [], {});
        queue.flush();
        QUnit.deepEqual(ran, [
            'task 1:a',
            'task 1:b',
            'task 2',
            'task 3'
        ]);
    });
    QUnit.test('priority queue can\'t flush already ran task', function () {
        var queue = new queues.PriorityQueue('priority');
        var ran = [];
        var task1 = function () {
            ran.push('1');
        };
        queue.enqueue(task1, null, [], { priority: 0 });
        queue.enqueue(function () {
            QUnit.equal(queue.isEnqueued(task1), false, 'not enqueued');
            queue.flushQueuedTask(task1);
            ran.push('2');
        }, null, [], { priority: 0 });
        queue.enqueue(function () {
            ran.push('3');
        }, null, [], { priority: 0 });
        queue.flush();
        QUnit.deepEqual(ran, [
            '1',
            '2',
            '3'
        ]);
    });
});
/*can-reflect@1.7.1#reflections/get-name/get-name-test*/
define('can-reflect@1.7.1#reflections/get-name/get-name-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-symbol',
    './get-name'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var canSymbol = require('can-symbol');
    var reflexions = require('./get-name');
    var supportsFunctionName = function name() {
    }.name === 'name';
    QUnit.module('can-reflect: getName');
    QUnit.test('it works with strings', function (assert) {
        var f = function () {
        };
        reflexions.setName(f, 'Christopher');
        assert.equal(reflexions.getName(f), 'Christopher');
    });
    QUnit.test('it works with functions', function (assert) {
        var f = function () {
        };
        reflexions.setName(f, function () {
            return 'Christopher';
        });
        assert.equal(reflexions.getName(f), 'Christopher');
    });
    if (supportsFunctionName) {
        QUnit.test('returns function name by default', function (assert) {
            assert.equal(reflexions.getName(function foo() {
            }), 'foo', 'should return function name');
        });
        QUnit.test('returns empty string for anonymous functions', function (assert) {
            assert.equal(reflexions.getName(function () {
            }), '', 'should return empty string');
        });
        QUnit.test('returns constructor name by default', function (assert) {
            assert.equal(reflexions.getName({}), 'Object{}', 'should return constructor name');
        });
    }
    QUnit.test('handles list-likes', function (assert) {
        function ListThing(id) {
            this.id = id;
        }
        ListThing.prototype[canSymbol.for('can.isMoreListLikeThanMapLike')] = true;
        if (supportsFunctionName) {
            assert.equal(reflexions.getName(new ListThing()), 'ListThing[]', 'should use can.getName symbol behavior');
        }
        reflexions.setName(ListThing, 'ListThing');
        assert.equal(reflexions.getName(new ListThing()), 'ListThing[]', 'should use can.getName symbol behavior');
    });
    QUnit.test('handles map-likes', function (assert) {
        function MapThing(id) {
            this.id = id;
        }
        MapThing.prototype[canSymbol.for('can.isMapLike')] = true;
        if (supportsFunctionName) {
            assert.equal(reflexions.getName(new MapThing()), 'MapThing{}', 'should use can.getName symbol behavior');
        }
        reflexions.setName(MapThing, 'MapThing');
        assert.equal(reflexions.getName(new MapThing()), 'MapThing{}', 'should use can.getName symbol behavior');
    });
    QUnit.test('handles value-likes', function (assert) {
        function ValueThing(id) {
            this.id = id;
        }
        ValueThing.prototype[canSymbol.for('can.isValueLike')] = true;
        if (supportsFunctionName) {
            assert.equal(reflexions.getName(new ValueThing()), 'ValueThing<>', 'should use can.getName symbol behavior');
        }
        reflexions.setName(ValueThing, 'ValueThing');
        assert.equal(reflexions.getName(new ValueThing()), 'ValueThing<>', 'should use can.getName symbol behavior');
    });
});
/*can-reflect@1.7.1#can-reflect-test_helpers*/
define('can-reflect@1.7.1#can-reflect-test_helpers', [
    'require',
    'exports',
    'module',
    'can-symbol'
], function (require, exports, module) {
    var canSymbol = require('can-symbol');
    var mapSupported = function () {
        if (typeof Map !== 'undefined' && typeof Map.prototype.keys === 'function') {
            var myMap = new Map();
            return myMap.toString() === '[object Map]';
        }
        return false;
    }();
    var setSupported = function () {
        if (typeof Set !== 'undefined') {
            var mySet = new Set();
            return mySet.toString() === '[object Set]' && canSymbol.iterator in mySet;
        }
        return false;
    }();
    var helpers = {
        mapSupported: mapSupported,
        setSupported: setSupported
    };
    module.exports = helpers;
});
/*can-reflect@1.7.1#reflections/type/type-test*/
define('can-reflect@1.7.1#reflections/type/type-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-symbol',
    './type',
    '../get-set/get-set',
    '../../can-reflect-test_helpers'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var canSymbol = require('can-symbol');
    var typeReflections = require('./type');
    var getSetReflections = require('../get-set/get-set');
    var testHelpers = require('../../can-reflect-test_helpers');
    QUnit.module('can-reflect: type reflections');
    QUnit.test('isConstructorLike', function () {
        var Constructor = function () {
        };
        Constructor.prototype.method = function () {
        };
        ok(typeReflections.isConstructorLike(Constructor));
        ok(!typeReflections.isConstructorLike(Constructor.prototype.method));
        var obj = {};
        getSetReflections.setKeyValue(obj, canSymbol.for('can.new'), function () {
        });
        ok(typeReflections.isConstructorLike(obj));
        ok(!typeReflections.isConstructorLike({}));
    });
    QUnit.test('isFunctionLike', function () {
        ok(!typeReflections.isFunctionLike({}), 'object is not function like');
        ok(typeReflections.isFunctionLike(function () {
        }), 'function is function like');
        var nonFunctionFunction = function () {
        };
        getSetReflections.setKeyValue(nonFunctionFunction, canSymbol.for('can.isFunctionLike'), false);
        ok(!typeReflections.isFunctionLike(nonFunctionFunction), 'function with can.isFunctionLike set to false is not function like');
        var obj = {};
        var func = function () {
        };
        getSetReflections.setKeyValue(obj, canSymbol.for('can.new'), func);
        getSetReflections.setKeyValue(obj, canSymbol.for('can.apply'), func);
        ok(typeReflections.isFunctionLike(obj), 'object with can.new and can.apply symbols is function like');
        getSetReflections.setKeyValue(obj, canSymbol.for('can.isFunctionLike'), false);
        ok(!typeReflections.isFunctionLike(obj), 'object with can.new, can.apply, and can.isFunctionLike set to false is not function like');
    });
    QUnit.test('isIteratorLike', function () {
        ok(!typeReflections.isIteratorLike({}));
        ok(typeReflections.isIteratorLike({
            next: function () {
            }
        }));
    });
    QUnit.test('isListLike', function () {
        ok(typeReflections.isListLike({
            0: 1,
            length: 1
        }));
        ok(typeReflections.isListLike('yes'), 'string');
        ok(typeReflections.isListLike({ length: 0 }), 'object with 0 length');
        var symboled = {};
        getSetReflections.setKeyValue(symboled, canSymbol.for('can.isListLike'), false);
        ok(!typeReflections.isListLike(symboled), '!@@can.isListLike');
        getSetReflections.setKeyValue(symboled, canSymbol.for('can.isListLike'), true);
        ok(typeReflections.isListLike(symboled), '@@can.isListLike');
        if (typeof document !== 'undefined') {
            var ul = document.createElement('ul');
            ul.innerHTML = '<li/><li/>';
            ok(typeReflections.isListLike(ul.childNodes), 'nodeList');
        }
        if (testHelpers.setSupported) {
            ok(typeReflections.isListLike(new Set()), 'Set');
        }
    });
    QUnit.test('isMapLike', function () {
        ok(typeReflections.isMapLike({}), 'Object');
        ok(typeReflections.isMapLike([]), 'Array');
        var symboled = {};
        getSetReflections.setKeyValue(symboled, canSymbol.for('can.isMapLike'), false);
        ok(!typeReflections.isMapLike(symboled), '!@@can.isMapLike');
        getSetReflections.setKeyValue(symboled, canSymbol.for('can.isMapLike'), true);
        ok(typeReflections.isMapLike(symboled), '@@can.isMapLike');
        ok(!typeReflections.isMapLike('String'), 'String');
    });
    QUnit.test('isMoreListLikeThanMapLike', function () {
        QUnit.equal(typeReflections.isMoreListLikeThanMapLike({}), false, 'Object');
        QUnit.equal(typeReflections.isMoreListLikeThanMapLike([]), true, 'Array');
    });
    QUnit.test('isObservableLike', function () {
        ok(typeReflections.isObservableLike({}) === false, 'Object');
        ok(typeReflections.isObservableLike([]) === false, 'Array');
        var obj = {};
        getSetReflections.setKeyValue(obj, canSymbol.for('can.onValue'), function () {
        });
        ok(typeReflections.isObservableLike(obj), 'Object');
    });
    QUnit.test('isPrimitive', function () {
        ok(!typeReflections.isPrimitive({}), 'Object');
        ok(typeReflections.isPrimitive(null), 'null');
        ok(typeReflections.isPrimitive(1), '1');
    });
    QUnit.test('isBuiltIn', function () {
        ok(typeReflections.isBuiltIn(1), 'Primitive');
        ok(typeReflections.isBuiltIn({}), 'Object');
        ok(typeReflections.isBuiltIn([]), 'Array');
        ok(typeReflections.isBuiltIn(function () {
        }), 'Function');
        ok(typeReflections.isBuiltIn(new Date()), 'Date');
        ok(typeReflections.isBuiltIn(/[foo].[bar]/), 'RegEx');
        if (document) {
            ok(typeReflections.isBuiltIn(document.createElement('div')), 'Elements');
        }
        var Foo = function () {
        };
        var customObj = new Foo();
        ok(!typeReflections.isBuiltIn(customObj), 'Custom Object');
        if (testHelpers.mapSupported) {
            var map = new Map();
            ok(typeReflections.isBuiltIn(map), 'Map');
        }
    });
    QUnit.test('isValueLike', function () {
        ok(!typeReflections.isValueLike({}), 'Object');
        ok(!typeReflections.isValueLike(function () {
        }), 'Function');
        ok(typeReflections.isValueLike('String'), 'String');
        var obj = {};
        getSetReflections.setKeyValue(obj, canSymbol.for('can.getValue'), true);
        ok(typeReflections.isValueLike(obj), 'symboled');
        var symboled = {};
        getSetReflections.setKeyValue(symboled, canSymbol.for('can.isValueLike'), false);
        ok(!typeReflections.isValueLike(symboled), '!@@can.isValueLike');
        getSetReflections.setKeyValue(symboled, canSymbol.for('can.isValueLike'), true);
        ok(typeReflections.isValueLike(symboled), '@@can.isValueLike');
    });
    QUnit.test('isSymbolLike', function () {
        if (typeof Symbol !== 'undefined') {
            ok(typeReflections.isSymbolLike(Symbol('a symbol')), 'Native Symbol');
        }
        ok(typeReflections.isSymbolLike(canSymbol('another Symbol')), 'canSymbol Symbol');
    });
    QUnit.test('isPromise', function () {
        QUnit.ok(!typeReflections.isPromise({}), 'Object is not a promise');
        QUnit.ok(!typeReflections.isPromise({
            catch: function () {
            },
            then: function () {
            }
        }), 'function with then and catch is not a Promise');
        QUnit.ok(typeReflections.isPromise(new Promise(function () {
        })), 'a new Promise() is a Promise');
    });
    QUnit.test('isConstructor - non enumerable properties on the prototype chain (#18)', function () {
        var Constructor = function () {
        };
        Object.defineProperty(Constructor.prototype, 'prop', {
            enumerable: false,
            value: 1
        });
        QUnit.ok(typeReflections.isConstructorLike(Constructor), 'decorated prototype means constructor');
    });
    QUnit.test('functions without prototypes (#20)', function () {
        var method = function () {
        }.bind({});
        QUnit.notOk(typeReflections.isConstructorLike(method), 'not a constructor');
    });
    QUnit.test('functions with deep non enumerable properties - non default proto chains (#22)', function () {
        var Base = function () {
        };
        Object.defineProperty(Base.prototype, 'prop', {
            enumerable: false,
            value: 1
        });
        var Constructor = function () {
        };
        Constructor.prototype = new Base();
        Constructor.prototype.constructor = Constructor;
        QUnit.ok(typeReflections.isConstructorLike(Constructor), 'decorated prototype means constructor');
    });
});
/*can-reflect@1.7.1#reflections/shape/shape-test*/
define('can-reflect@1.7.1#reflections/shape/shape-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-symbol',
    './shape',
    '../get-set/get-set',
    '../../can-reflect-test_helpers'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var canSymbol = require('can-symbol');
    var shapeReflections = require('./shape');
    var getSetReflections = require('../get-set/get-set');
    var testHelpers = require('../../can-reflect-test_helpers');
    QUnit.module('can-reflect: shape reflections: own+enumerable');
    function testModifiedMap(callback, symbolToMethod) {
        symbolToMethod = symbolToMethod || {
            getOwnEnumerableKeys: 'keys',
            hasOwnKey: 'has',
            getKeyValue: 'get'
        };
        if (testHelpers.mapSupported) {
            shapeReflections.eachKey(symbolToMethod, function (method, symbol) {
                getSetReflections.setKeyValue(Map.prototype, canSymbol.for('can.' + symbol), function () {
                    return this[method].apply(this, arguments);
                });
            });
            callback();
            shapeReflections.eachKey(symbolToMethod, function (symbol) {
                delete Map.prototype[canSymbol.for('can.' + symbol)];
            });
        }
    }
    QUnit.test('getOwnEnumerableKeys (aka: keys)', function () {
        QUnit.deepEqual(shapeReflections.keys({
            foo: 1,
            bar: 2
        }), [
            'foo',
            'bar'
        ], 'POJO');
        QUnit.deepEqual(shapeReflections.keys([
            '0',
            '1'
        ]), Object.keys([
            1,
            2
        ]), 'Array');
        testModifiedMap(function () {
            var map = new Map(), obj = {};
            map.set('foo', 1);
            map.set(obj, 2);
            QUnit.deepEqual(shapeReflections.toArray(shapeReflections.keys(map)), [
                'foo',
                {}
            ], 'Decorated Map with can.getOwnEnumerableKeys');
        });
        var proto = {};
        getSetReflections.setKeyValue(proto, canSymbol.for('can.getOwnKeys'), function () {
            return [
                'a',
                'b',
                'c'
            ];
        });
        getSetReflections.setKeyValue(proto, canSymbol.for('can.getOwnKeyDescriptor'), function (key) {
            return {
                a: { enumerable: false },
                b: { enumerable: true },
                c: { enumerable: true }
            }[key];
        });
        var defineMapLike = Object.create(proto, {});
        QUnit.deepEqual(shapeReflections.toArray(shapeReflections.keys(defineMapLike)), [
            'b',
            'c'
        ], 'Decorated Object with can.getOwnKeys and can.getOwnKeyDescriptor');
    });
    QUnit.test('eachIndex', function () {
        var Ctr = function () {
        };
        var arr = [
            'a',
            'b'
        ];
        getSetReflections.setKeyValue(Ctr.prototype, canSymbol.iterator, function () {
            return {
                i: 0,
                next: function () {
                    if (this.i === 1) {
                        return {
                            value: undefined,
                            done: true
                        };
                    }
                    this.i++;
                    return {
                        value: arr,
                        done: false
                    };
                }
            };
        });
        var obj = new Ctr();
        shapeReflections.eachIndex(obj, function (value, index) {
            QUnit.equal(index, 0);
            QUnit.equal(value, arr);
        });
        shapeReflections.eachIndex(['a'], function (value, index) {
            QUnit.equal(index, 0);
            QUnit.equal(value, 'a');
        });
        function ArrayLike() {
        }
        ArrayLike.prototype = [];
        ArrayLike.prototype[canSymbol.iterator] = null;
        var noniterator = new ArrayLike();
        noniterator.push('a');
        shapeReflections.eachIndex(noniterator, function (value, index) {
            QUnit.equal(index, 0);
            QUnit.equal(value, 'a');
        });
    });
    QUnit.test('eachKey', function () {
        var index;
        var answers, map;
        testModifiedMap(function () {
            var o1 = {}, o2 = {};
            map = new Map([
                [
                    o1,
                    '1'
                ],
                [
                    o2,
                    2
                ]
            ]);
            index = 0;
            answers = [
                [
                    o1,
                    '1'
                ],
                [
                    o2,
                    2
                ]
            ];
            shapeReflections.eachKey(map, function (value, key) {
                var answer = answers[index++];
                QUnit.equal(value, answer[1], 'map value');
                QUnit.equal(key, answer[0], 'map key');
            });
        });
        var obj = {
            a: '1',
            b: '2'
        };
        index = 0;
        answers = [
            [
                'a',
                '1'
            ],
            [
                'b',
                '2'
            ]
        ];
        shapeReflections.eachKey(obj, function (value, key) {
            var answer = answers[index++];
            QUnit.equal(value, answer[1], 'object value');
            QUnit.equal(key, answer[0], 'object key');
        });
    });
    QUnit.test('each', function () {
        shapeReflections.each({ foo: 'bar' }, function (value, key) {
            QUnit.equal(key, 'foo');
            QUnit.equal(value, 'bar');
        });
        shapeReflections.each(['bar'], function (value, index) {
            QUnit.equal(index, 0);
            QUnit.equal(value, 'bar');
        });
    });
    QUnit.test('toArray', function () {
        if (typeof document !== 'undefined') {
            var ul = document.createElement('ul');
            ul.innerHTML = '<li/><li/>';
            var arr = shapeReflections.toArray(ul.childNodes);
            QUnit.equal(arr.length, 2, 'childNodes');
            QUnit.equal(arr[0].nodeName.toLowerCase(), 'li', 'childNodes');
        }
    });
    QUnit.module('can-reflect: shape reflections: own');
    QUnit.test('hasOwnKey', function () {
        var map;
        testModifiedMap(function () {
            var o1 = {};
            map = new Map();
            map.set(o1, '1');
            QUnit.ok(shapeReflections.hasOwnKey(map, o1), 'Map');
        });
        var obj = { foo: 'bar' };
        QUnit.ok(shapeReflections.hasOwnKey(obj, 'foo'), 'obj');
        QUnit.ok(!shapeReflections.hasOwnKey(obj, 'bar'), 'obj');
    });
    QUnit.test('getOwnKeys', function () {
        var obj = Object.create(null, {
            foo: {
                value: '1',
                enumerable: true
            },
            bar: {
                value: '2',
                enumerable: false
            }
        });
        QUnit.deepEqual(shapeReflections.getOwnKeys(obj), [
            'foo',
            'bar'
        ], 'obj');
    });
    QUnit.test('getOwnKeyDescriptor', function () {
        var obj = { foo: 'bar' };
        QUnit.deepEqual(shapeReflections.getOwnKeyDescriptor(obj, 'foo'), Object.getOwnPropertyDescriptor(obj, 'foo'), 'POJO');
        var obj2 = {};
        getSetReflections.setKeyValue(obj2, canSymbol.for('can.getOwnKeyDescriptor'), function (key) {
            return {
                foo: {
                    enumerable: true,
                    type: 'thing'
                }
            }[key];
        });
        QUnit.deepEqual(shapeReflections.getOwnKeyDescriptor(obj2, 'foo'), {
            enumerable: true,
            type: 'thing'
        }, 'w/ symbol');
    });
    QUnit.test('unwrap basics', function () {
        var list = {};
        getSetReflections.setKeyValue(list, canSymbol.iterator, function () {
            return {
                i: 0,
                next: function () {
                    if (this.i === 3) {
                        return {
                            value: undefined,
                            done: true
                        };
                    }
                    this.i++;
                    return {
                        value: (this.i - 1) * 2,
                        done: false
                    };
                }
            };
        });
        getSetReflections.setKeyValue(list, canSymbol.for('can.isMoreListLikeThanMapLike'), true);
        var compute = {};
        getSetReflections.setKeyValue(compute, canSymbol.for('can.getValue'), function () {
            var map = {};
            getSetReflections.setKeyValue(map, canSymbol.for('can.getOwnEnumerableKeys'), function () {
                return [
                    'a',
                    'b',
                    'c',
                    'list'
                ];
            });
            getSetReflections.setKeyValue(map, canSymbol.for('can.getKeyValue'), function (key) {
                return key === 'list' ? list : key.toUpperCase();
            });
            return map;
        });
        var plain = shapeReflections.unwrap(compute);
        QUnit.deepEqual(plain, {
            a: 'A',
            b: 'B',
            c: 'C',
            list: [
                0,
                2,
                4
            ]
        });
    });
    QUnit.test('unwrap handles POJOs', function () {
        var a = { foo: 'bar' };
        var plain = shapeReflections.unwrap(a);
        QUnit.deepEqual(plain, a);
        QUnit.ok(a !== plain, 'returns copy');
    });
    if (typeof Map !== 'undefined') {
        QUnit.test('handles cycles', function () {
            var a = {}, b = {};
            a.b = b;
            b.a = a;
            var plain = shapeReflections.unwrap(a, Map);
            QUnit.equal(plain.b.a, plain, 'cycle intact');
            QUnit.ok(a !== plain, 'returns copy');
        });
    }
    QUnit.test('isBuiltIn is only called after decorators are checked in shouldSerialize', function () {
        var arr = [];
        QUnit.ok(shapeReflections.isSerializable(arr));
        arr[canSymbol.for('can.setKeyValue')] = function () {
        };
        QUnit.ok(!shapeReflections.isSerializable(arr));
        if (testHelpers.setSupported) {
            var set = new Set([
                {},
                {},
                {}
            ]);
            QUnit.ok(shapeReflections.isSerializable(set));
            set[canSymbol.for('can.setKeyValue')] = function () {
            };
            QUnit.ok(!shapeReflections.isSerializable(set));
        }
    });
    QUnit.test('.serialize handles recursion with .unwrap', function () {
        var list = {};
        getSetReflections.setKeyValue(list, canSymbol.iterator, function () {
            return {
                i: 0,
                next: function () {
                    if (this.i === 3) {
                        return {
                            value: undefined,
                            done: true
                        };
                    }
                    this.i++;
                    return {
                        value: (this.i - 1) * 2,
                        done: false
                    };
                }
            };
        });
        getSetReflections.setKeyValue(list, canSymbol.for('can.isMoreListLikeThanMapLike'), true);
        var compute = {};
        getSetReflections.setKeyValue(compute, canSymbol.for('can.getValue'), function () {
            var map = {};
            getSetReflections.setKeyValue(map, canSymbol.for('can.getOwnEnumerableKeys'), function () {
                return [
                    'a',
                    'b',
                    'c',
                    'list'
                ];
            });
            getSetReflections.setKeyValue(map, canSymbol.for('can.getKeyValue'), function (key) {
                return key === 'list' ? list : key.toUpperCase();
            });
            return map;
        });
        var plain = shapeReflections.unwrap(compute);
        QUnit.deepEqual(plain, {
            a: 'A',
            b: 'B',
            c: 'C',
            list: [
                0,
                2,
                4
            ]
        });
    });
    QUnit.test('updateDeep basics', function () {
        var obj = {
            name: 'Justin',
            hobbies: [
                {
                    id: 1,
                    name: 'js'
                },
                {
                    id: 2,
                    name: 'foosball'
                }
            ]
        };
        var hobbies = obj.hobbies;
        var js = obj.hobbies[0];
        shapeReflections.updateDeep(obj, {
            age: 34,
            hobbies: [{
                    id: 1,
                    name: 'JS',
                    fun: true
                }]
        });
        QUnit.deepEqual(obj, {
            age: 34,
            hobbies: [{
                    id: 1,
                    name: 'JS',
                    fun: true
                }]
        });
        QUnit.equal(obj.hobbies, hobbies, 'merged hobbies');
        QUnit.equal(obj.hobbies[0], js, 'merged js');
        shapeReflections.updateDeep(obj, {
            age: 34,
            hobbies: [
                {
                    id: 1,
                    name: 'JS',
                    fun: true
                },
                {
                    id: 2,
                    name: 'foosball'
                }
            ]
        });
        QUnit.deepEqual(obj, {
            age: 34,
            hobbies: [
                {
                    id: 1,
                    name: 'JS',
                    fun: true
                },
                {
                    id: 2,
                    name: 'foosball'
                }
            ]
        }, 'added foosball');
        QUnit.equal(obj.hobbies, hobbies, 'merged hobbies');
        QUnit.equal(obj.hobbies[0], js, 'merged js');
    });
    QUnit.test('updateDeep', function () {
        var a = [];
        shapeReflections.updateDeep(a, [
            'a',
            'b'
        ]);
        QUnit.deepEqual(a, [
            'a',
            'b'
        ]);
    });
    QUnit.test('can assign undefined values', function () {
        var obj = shapeReflections.assignMap({}, { foo: undefined });
        QUnit.ok(obj.hasOwnProperty('foo'), 'has an undefined foo');
    });
    QUnit.test('assignMap', function () {
        var target = shapeReflections.assignSymbols({}, {
            'can.setKeyValue': function (key, value) {
                this[key] = value * 2;
            },
            'can.getKeyValue': function (key) {
                return this[key] !== undefined ? this[key] / 2 : undefined;
            }
        });
        target.a = 22;
        var source = shapeReflections.assignSymbols({}, {
            'can.setKeyValue': function (key, value) {
                this[key] = value * 3;
            },
            'can.getKeyValue': function (key) {
                return this[key] !== undefined ? this[key] / 3 : undefined;
            }
        });
        shapeReflections.assignMap(source, {
            a: 1,
            b: 2
        });
        QUnit.deepEqual(source, {
            a: 3,
            b: 6
        }, 'set values on source');
        shapeReflections.assignMap(target, source);
        QUnit.deepEqual(target, {
            a: 2,
            b: 4
        }, 'set values on target');
    });
    QUnit.test('getOwnEnumerableKeys with primitives', function () {
        QUnit.deepEqual(shapeReflections.getOwnEnumerableKeys(1), [], 'works with primitive');
    });
    if (typeof Symbol !== 'undefined') {
        QUnit.test('assignSymbols can set Symbol.iterator', function () {
            var fn = function () {
            };
            var obj = shapeReflections.assignSymbols({}, { 'iterator': fn });
            QUnit.equal(obj[Symbol.iterator], fn, 'works');
        });
    }
});
/*can-reflect@1.7.1#reflections/get-set/get-set-test*/
define('can-reflect@1.7.1#reflections/get-set/get-set-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-symbol',
    '../shape/shape',
    './get-set'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var canSymbol = require('can-symbol');
    var shapeReflections = require('../shape/shape');
    var getSetReflections = require('./get-set');
    QUnit.module('can-reflect: get-set reflections: key');
    QUnit.test('getKeyValue', function () {
        QUnit.equal(getSetReflections.getKeyValue({ foo: 'bar' }, 'foo'), 'bar', 'POJO');
        QUnit.equal(getSetReflections.getKeyValue([1], 'length'), 1, 'Array length');
        QUnit.equal(getSetReflections.getKeyValue([2], 0), 2, 'Array index');
        var obj = {};
        getSetReflections.setKeyValue(obj, canSymbol.for('can.getKeyValue'), function (key) {
            return { foo: 'bar' }[key];
        });
        QUnit.equal(getSetReflections.getKeyValue(obj, 'foo'), 'bar');
    });
    QUnit.test('get / set alias', function () {
        QUnit.equal(getSetReflections.get, getSetReflections.getKeyValue);
        QUnit.equal(getSetReflections.set, getSetReflections.setKeyValue);
    });
    QUnit.test('setKeyValue', function () {
        var obj = {};
        var mysymbol = canSymbol('some symbol');
        if (typeof mysymbol === 'object') {
            getSetReflections.setKeyValue(obj, mysymbol, 'VALUE');
            QUnit.deepEqual(Object.getOwnPropertyDescriptor(obj, mysymbol.toString()), {
                enumerable: false,
                writable: true,
                configurable: true,
                value: 'VALUE'
            });
        }
        obj = {};
        getSetReflections.setKeyValue(obj, 'prop', 'VALUE');
        QUnit.equal(obj.prop, 'VALUE');
        getSetReflections.setKeyValue(obj, canSymbol.for('can.setKeyValue'), function (prop, value) {
            QUnit.equal(prop, 'someProp', 'can.setKeyValue');
            QUnit.equal(value, 'someValue', 'can.setKeyValue');
        });
        getSetReflections.setKeyValue(obj, 'someProp', 'someValue');
    });
    QUnit.test('deleteKeyValue', function () {
        var obj = { prop: 'Value' };
        getSetReflections.deleteKeyValue(obj, 'prop');
        QUnit.equal(obj.prop, undefined, 'deleted');
    });
    QUnit.module('can-reflect: get-set reflections: value');
    QUnit.test('getValue', function () {
        [
            true,
            1,
            null,
            undefined,
            {}
        ].forEach(function (value) {
            QUnit.equal(getSetReflections.getValue(value), value, 'Value: ' + value);
        });
        var obj = { value: 0 };
        getSetReflections.setKeyValue(obj, canSymbol.for('can.getValue'), function () {
            return this.value;
        });
        QUnit.equal(getSetReflections.getValue(obj), 0);
    });
    QUnit.test('setValue', function () {
        try {
            getSetReflections.setValue({}, {});
            QUnit.ok(false, 'set POJO');
        } catch (e) {
            QUnit.ok(true, 'set POJO errors');
        }
        var obj = { value: 0 };
        getSetReflections.setKeyValue(obj, canSymbol.for('can.setValue'), function (value) {
            this.value = value;
        });
        getSetReflections.setValue(obj, 2);
        QUnit.deepEqual(obj, { value: 2 }, 'can.setValue');
    });
});
/*can-reflect@1.7.1#reflections/call/call-test*/
define('can-reflect@1.7.1#reflections/call/call-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-symbol',
    './call',
    '../get-set/get-set'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var canSymbol = require('can-symbol');
    var callReflections = require('./call');
    var getSetReflections = require('../get-set/get-set');
    QUnit.module('can-reflect: function reflections');
    QUnit.test('call', function () {
        var obj = {};
        var ret = callReflections.call(function (arg1, arg2) {
            QUnit.equal(this, obj, 'this');
            QUnit.equal(arg1, 1, 'arg1');
            QUnit.equal(arg2, 2, 'arg2');
            return 3;
        }, obj, 1, 2);
        QUnit.equal(ret, 3, 'return value');
        var func = {};
        getSetReflections.setKeyValue(func, canSymbol.for('can.apply'), function (context, args) {
            QUnit.equal(this, func, 'this');
            QUnit.equal(context, obj, 'context');
            QUnit.equal(args[0], 1, 'arg1');
            QUnit.equal(args[1], 2, 'arg2');
            return 3;
        });
        ret = callReflections.call(func, obj, 1, 2);
        QUnit.equal(ret, 3, 'return value');
    });
    QUnit.test('apply', function () {
        var obj = {};
        var ret = callReflections.apply(function (arg1, arg2) {
            QUnit.equal(this, obj, 'this');
            QUnit.equal(arg1, 1, 'arg1');
            QUnit.equal(arg2, 2, 'arg2');
            return 3;
        }, obj, [
            1,
            2
        ]);
        QUnit.equal(ret, 3, 'return value');
        var func = {};
        getSetReflections.setKeyValue(func, canSymbol.for('can.apply'), function (context, args) {
            QUnit.equal(this, func, 'this');
            QUnit.equal(context, obj, 'context');
            QUnit.equal(args[0], 1, 'arg1');
            QUnit.equal(args[1], 2, 'arg2');
            return 3;
        });
        ret = callReflections.apply(func, obj, [
            1,
            2
        ]);
        QUnit.equal(ret, 3, 'return value');
    });
    QUnit.test('new', function () {
        var Constructor = function (arg1, arg2) {
            QUnit.ok(this instanceof Constructor, 'this');
            QUnit.equal(arg1, 1, 'arg1');
            QUnit.equal(arg2, 2, 'arg2');
            return 3;
        };
        var instance = callReflections['new'](Constructor, 1, 2);
        QUnit.ok(instance instanceof Constructor, 'this');
        var Func = {};
        getSetReflections.setKeyValue(Func, canSymbol.for('can.new'), function (arg1, arg2) {
            QUnit.equal(this, Func, 'this');
            QUnit.equal(arg1, 1, 'arg1');
            QUnit.equal(arg2, 2, 'arg2');
            return 3;
        });
        var ret = callReflections.new(Func, 1, 2);
        QUnit.equal(ret, 3, 'return value');
    });
});
/*can-reflect@1.7.1#reflections/observe/observe-test*/
define('can-reflect@1.7.1#reflections/observe/observe-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-symbol',
    './observe',
    '../get-set/get-set'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var canSymbol = require('can-symbol');
    var observeReflections = require('./observe');
    var getSetReflections = require('../get-set/get-set');
    QUnit.module('can-reflect: observe reflections: key');
    QUnit.test('onKeyValue / offKeyValue', function () {
        var obj = { callbacks: { foo: [] } };
        getSetReflections.setKeyValue(obj, canSymbol.for('can.onKeyValue'), function (key, callback) {
            this.callbacks[key].push(callback);
        });
        var callback = function (ev, value) {
            QUnit.equal(value, 'bar');
        };
        observeReflections.onKeyValue(obj, 'foo', callback);
        obj.callbacks.foo[0]({}, 'bar');
        getSetReflections.setKeyValue(obj, canSymbol.for('can.offKeyValue'), function (key, callback) {
            var index = this.callbacks[key].indexOf(callback);
            this.callbacks[key].splice(index, 1);
        });
        observeReflections.offKeyValue(obj, 'foo', callback);
        QUnit.equal(obj.callbacks.foo.length, 0, 'no event handlers');
    });
    QUnit.test('onKeys', function () {
        try {
            observeReflections.onKeys({}, function () {
            });
            QUnit.ok(false, 'should throw error');
        } catch (e) {
            QUnit.ok(true, 'threw error');
        }
    });
    QUnit.test('onKeysAdded / onKeysRemoved', function () {
        try {
            observeReflections.onKeysAdded({}, function () {
            });
            QUnit.ok(false, 'should throw error');
        } catch (e) {
            QUnit.ok(true, 'threw error');
        }
        try {
            observeReflections.onKeysRemoved({}, function () {
            });
            QUnit.ok(false, 'should throw error');
        } catch (e) {
            QUnit.ok(true, 'threw error');
        }
    });
    QUnit.test('getKeyDependencies', function () {
        try {
            observeReflections.getKeyDependencies({});
            QUnit.ok(false, 'should throw error');
        } catch (e) {
            QUnit.ok(true, 'threw error');
        }
    });
    QUnit.module('can-reflect: observe reflections: value');
    QUnit.test('onValue / offValue', function () {
        var obj = { callbacks: [] };
        getSetReflections.setKeyValue(obj, canSymbol.for('can.onValue'), function (callback) {
            this.callbacks.push(callback);
        });
        var callback = function (ev, value) {
            QUnit.equal(value, 'bar');
        };
        observeReflections.onValue(obj, callback);
        obj.callbacks[0]({}, 'bar');
        getSetReflections.setKeyValue(obj, canSymbol.for('can.offValue'), function (callback) {
            var index = this.callbacks.indexOf(callback);
            this.callbacks.splice(index, 1);
        });
        observeReflections.offValue(obj, callback);
        QUnit.equal(obj.callbacks.length, 0, 'no event handlers');
    });
    QUnit.test('getValueDependencies', function () {
        try {
            observeReflections.getValueDependencies({});
            QUnit.ok(false, 'should throw error');
        } catch (e) {
            QUnit.ok(true, 'threw error');
        }
    });
    QUnit.module('can-reflect: observe reflections: event');
    QUnit.test('onEvent / offEvent', function () {
        var cb = function () {
        };
        var obj = {
            addEventListener: function (arg1, arg2) {
                QUnit.equal(this, obj);
                QUnit.equal(arg2, cb);
                QUnit.equal(arg1, 'click', 'eventName');
            },
            removeEventListener: function (arg1, arg2) {
                QUnit.equal(this, obj);
                QUnit.equal(arg1, 'click', 'event name');
                QUnit.equal(arg2, cb);
            }
        };
        observeReflections.onEvent(obj, 'click', cb);
        observeReflections.offEvent(obj, 'click', cb);
    });
    QUnit.test('onEvent / offEvent gets 3rd argument', function () {
        var cb = function () {
        };
        var obj = {
            addEventListener: function (arg1, arg2, queue) {
                QUnit.equal(this, obj);
                QUnit.equal(arg2, cb);
                QUnit.equal(arg1, 'click', 'eventName');
                QUnit.equal(queue, 'mutate', 'queue');
            },
            removeEventListener: function (arg1, arg2, queue) {
                QUnit.equal(this, obj);
                QUnit.equal(arg1, 'click', 'event name');
                QUnit.equal(arg2, cb);
                QUnit.equal(queue, 'mutate', 'queue');
            }
        };
        observeReflections.onEvent(obj, 'click', cb, 'mutate');
        observeReflections.offEvent(obj, 'click', cb, 'mutate');
    });
    QUnit.test('setPriority', function () {
        var obj = {};
        QUnit.equal(observeReflections.setPriority(obj, 5), false, 'unable to set priority');
        var obj2 = {};
        getSetReflections.setKeyValue(obj2, canSymbol.for('can.setPriority'), function (number) {
            this.priority = number;
        });
        QUnit.equal(observeReflections.setPriority(obj2, 5), true, 'unable to set priority');
        QUnit.equal(obj2.priority, 5, 'set priority');
    });
    QUnit.test('getPriority', function () {
        var obj = {};
        QUnit.equal(observeReflections.getPriority(obj), undefined, 'no priority');
        var obj2 = {};
        getSetReflections.setKeyValue(obj2, canSymbol.for('can.getPriority'), function () {
            return 5;
        });
        QUnit.equal(observeReflections.getPriority(obj2), 5, 'unable to set priority');
    });
});
/*can-reflect@1.7.1#types/map-test*/
define('can-reflect@1.7.1#types/map-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    '../reflections/shape/shape',
    './map'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var shape = require('../reflections/shape/shape');
    require('./map');
    if (typeof Map !== 'undefined') {
        QUnit.module('can-reflect/types/map Map');
        QUnit.test('assign', function () {
            var map = new Map();
            shape.assign(map, { name: 'CanJS' });
            QUnit.equal(map.get('name'), 'CanJS', 'object to map');
            var map1 = new Map();
            map = new Map();
            var o1 = { name: 'foo' };
            var o2 = { name: 'bar' };
            map1.set(o1, o2);
            shape.assign(map, map1);
            QUnit.equal(map.get(o1), o2, 'map to map');
        });
        QUnit.test('has', function () {
            var map = new Map();
            var o1 = { name: 'foo' };
            var o2 = { name: 'bar' };
            map.set(o1, o2);
            QUnit.ok(shape.hasOwnKey(map, o1), 'Shape has object key');
        });
        QUnit.test('update', function () {
            var map = new Map();
            var o1 = { name: 'o1' };
            var o2 = { name: 'o2' };
            var o3 = { name: 'o3' };
            map.set(o1, o2);
            map.set(o2, o1);
            var map2 = new Map();
            map2.set(o1, o3);
            map2.set(o3, o1);
            shape.update(map, map2);
            QUnit.notOk(map.has(o2), 'removed key');
            QUnit.equal(map.get(o3), o1, 'added key');
            QUnit.equal(map.get(o1), o3, 'updated key');
        });
    }
    if (typeof WeakMap !== 'undefined') {
        QUnit.module('can-reflect/types/map WeakMap');
        QUnit.test('assign', function () {
            var canjs = new Map();
            var name = { name: 'toUpperCase' };
            canjs.set(name, 'CANJS');
            var map = new WeakMap();
            shape.assign(map, canjs);
            QUnit.equal(map.get(name), 'CANJS', 'map to weakmap');
            map = new WeakMap();
            var map1 = new Map();
            var o1 = { name: 'foo' };
            var o2 = { name: 'bar' };
            map1.set(o1, o2);
            shape.assign(map, map1);
            QUnit.equal(map.get(o1), o2, 'map to map');
        });
        QUnit.test('has', function () {
            var map = new WeakMap();
            var o1 = { name: 'foo' };
            var o2 = { name: 'bar' };
            map.set(o1, o2);
            QUnit.ok(shape.hasOwnKey(map, o1), 'Shape has object key');
        });
        QUnit.test('update', function () {
            var map = new WeakMap();
            var o1 = { name: 'o1' };
            var o2 = { name: 'o2' };
            var o3 = { name: 'o3' };
            map.set(o1, o2);
            map.set(o2, o1);
            var map2 = new WeakMap();
            map2.set(o1, o3);
            map2.set(o3, o1);
            try {
                shape.update(map, map2);
            } catch (e) {
                QUnit.ok(true, 'throws an error');
            }
        });
    }
});
/*can-reflect@1.7.1#types/set-test*/
define('can-reflect@1.7.1#types/set-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    '../reflections/shape/shape',
    '../reflections/type/type',
    './set'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var shape = require('../reflections/shape/shape');
    var type = require('../reflections/type/type');
    require('./set');
    function assertSetMatchesArray(set, array, msg) {
        QUnit.equal(set.size, array.length, msg + ' - size matches');
        for (var i = 0; i < array.length; i++) {
            QUnit.ok(set.has(array[i]), msg + ' - set contains ' + array[i]);
        }
    }
    if (typeof Set !== 'undefined') {
        QUnit.module('can-reflect/types/set Set');
        QUnit.test('isListLike', function () {
            QUnit.ok(type.isListLike(new Set()), 'isListLike');
            QUnit.ok(type.isMoreListLikeThanMapLike(new Set()), 'isMoreListLikeThanMapLike');
        });
        QUnit.test('shape.each', function () {
            var arr = [
                'a',
                'b'
            ];
            var set = new Set();
            arr.forEach(function (val) {
                set.add(val);
            });
            var count = 0;
            shape.each(set, function (value) {
                QUnit.equal(value, arr[count++], 'got the right values back');
            });
        });
        QUnit.test('shape.update', function () {
            var set = new Set([
                'a',
                'b'
            ]);
            shape.update(set, [
                'a',
                'a',
                'c'
            ]);
            assertSetMatchesArray(set, [
                'a',
                'c'
            ], '.update');
        });
        QUnit.test('shape.assign', function () {
            var arr = [
                'a',
                'b'
            ];
            var set = new Set();
            arr.forEach(function (val) {
                set.add(val);
            });
            shape.assign(set, [
                'a',
                'a',
                'c'
            ]);
            assertSetMatchesArray(set, [
                'a',
                'b',
                'c'
            ], '.assign');
        });
    }
    if (typeof WeakSet !== 'undefined') {
        QUnit.module('can-reflect/types/set WeakSet');
        QUnit.test('isListLike', function () {
            QUnit.ok(type.isListLike(new WeakSet()), 'isListLike');
            QUnit.ok(type.isMoreListLikeThanMapLike(new WeakSet()), 'isMoreListLikeThanMapLike');
        });
        QUnit.test('shape.each', function () {
            var arr = [
                {},
                {}
            ];
            var set = new WeakSet(arr);
            try {
                shape.each(set, function () {
                });
            } catch (e) {
                QUnit.ok(true, 'Error ' + e.message);
            }
        });
        QUnit.test('shape.update', function () {
            var a = {}, b = {}, c = {};
            var set = new WeakSet([
                a,
                b
            ]);
            try {
                shape.update(set, [
                    a,
                    a,
                    c
                ]);
            } catch (e) {
                QUnit.ok(true, 'Error ' + e.message);
            }
        });
        QUnit.test('shape.assign', function () {
            var a = {}, b = {}, c = {};
            var set = new WeakSet([
                a,
                b
            ]);
            shape.assign(set, [
                a,
                a,
                c
            ]);
            QUnit.ok(set.has(a));
            QUnit.ok(set.has(b));
            QUnit.ok(set.has(c));
        });
    }
});
/*can-reflect@1.7.1#can-reflect-test*/
define('can-reflect@1.7.1#can-reflect-test', [
    'require',
    'exports',
    'module',
    './reflections/get-name/get-name-test',
    './reflections/type/type-test',
    './reflections/shape/shape-test',
    './reflections/get-set/get-set-test',
    './reflections/call/call-test',
    './reflections/observe/observe-test',
    './types/map-test',
    './types/set-test',
    './can-reflect'
], function (require, exports, module) {
    require('./reflections/get-name/get-name-test');
    require('./reflections/type/type-test');
    require('./reflections/shape/shape-test');
    require('./reflections/get-set/get-set-test');
    require('./reflections/call/call-test');
    require('./reflections/observe/observe-test');
    require('./types/map-test');
    require('./types/set-test');
    require('./can-reflect');
});
/*can-reflect-promise@2.0.0-pre.4#test/can-reflect-promise_test*/
define('can-reflect-promise@2.0.0-pre.4#test/can-reflect-promise_test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-util/js/global/global',
    'can-symbol',
    'can-reflect-promise',
    'can-observation-recorder'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var QUnit = require('steal-qunit');
        var GLOBAL = require('can-util/js/global/global');
        var canSymbol = require('can-symbol');
        var canReflectPromise = require('can-reflect-promise');
        var ObservationRecorder = require('can-observation-recorder');
        var nativePromise = GLOBAL().Promise;
        var Promise;
        QUnit.module('can-reflect-promise', {
            setup: function () {
                function tempPromise() {
                    if ('Reflect' in GLOBAL() && typeof GLOBAL().Reflect.construct === 'function') {
                        return GLOBAL().Reflect.construct(nativePromise, arguments, tempPromise);
                    } else {
                        nativePromise.apply(this, arguments);
                        return this;
                    }
                }
                [
                    'resolve',
                    'reject'
                ].forEach(function (key) {
                    if (~nativePromise[key].toString().indexOf('[native code]')) {
                        tempPromise[key] = nativePromise[key];
                    } else {
                        tempPromise[key] = new Function('value', 'return new this(function(resolve, reject) { ' + key + '(value); });');
                    }
                });
                var protoDefs = {};
                protoDefs[canSymbol.for('can.observeData')] = {
                    value: null,
                    writable: true,
                    configurable: true
                };
                protoDefs[canSymbol.for('can.getKeyValue')] = {
                    value: null,
                    writable: true,
                    configurable: true
                };
                tempPromise.prototype = Object.create(nativePromise.prototype, protoDefs);
                Promise = tempPromise;
            },
            teardown: function () {
                Promise = null;
            }
        });
        QUnit.test('decorates promise', function () {
            QUnit.ok(!Promise.prototype[canSymbol.for('can.getKeyValue')], 'no decoration');
            canReflectPromise(new Promise(function () {
            }));
            QUnit.ok(Promise.prototype[canSymbol.for('can.getKeyValue')], 'has decoration');
        });
        QUnit.test('has all necessary symbols', function () {
            var p = new Promise(function () {
            });
            canReflectPromise(p);
            QUnit.ok(p[canSymbol.for('can.getKeyValue')], 'can.getKeyValue');
            QUnit.ok(p[canSymbol.for('can.getValue')], 'can.getValue');
            QUnit.ok(p[canSymbol.for('can.onKeyValue')], 'can.onKeyValue');
            QUnit.ok(p[canSymbol.for('can.offKeyValue')], 'can.offKeyValue');
            QUnit.equal(p[canSymbol.for('can.isValueLike')], false, 'can.isValueLike');
        });
        QUnit.test('getKeyValue for promise-specific values', 8, function () {
            var p = Promise.resolve('a');
            canReflectPromise(p);
            QUnit.equal(p[canSymbol.for('can.getKeyValue')]('isPending'), true, 'isPending true in sync');
            QUnit.equal(p[canSymbol.for('can.getKeyValue')]('isResolved'), false, 'isResolved false in sync');
            QUnit.equal(p[canSymbol.for('can.getKeyValue')]('value'), undefined, 'no value in sync');
            QUnit.equal(p[canSymbol.for('can.getKeyValue')]('state'), 'pending', 'state pending in sync');
            stop();
            setTimeout(function () {
                QUnit.equal(p[canSymbol.for('can.getKeyValue')]('value'), 'a', 'value in async');
                QUnit.equal(p[canSymbol.for('can.getKeyValue')]('isPending'), false, 'isPending false in async');
                QUnit.equal(p[canSymbol.for('can.getKeyValue')]('isResolved'), true, 'isResolved true in async');
                QUnit.equal(p[canSymbol.for('can.getKeyValue')]('state'), 'resolved', 'state resolved in async');
                start();
            }, 30);
        });
        QUnit.test('computable', 4, function () {
            stop(3);
            var p = Promise.resolve('a');
            canReflectPromise(p);
            ObservationRecorder.start();
            p[canSymbol.for('can.getKeyValue')]('value');
            var deps = ObservationRecorder.stop();
            QUnit.ok(deps.keyDependencies.has(p), 'has the key dep');
            p[canSymbol.for('can.onKeyValue')]('value', function (newVal) {
                QUnit.equal(newVal, 'a', 'value updates on event');
                start();
            });
            p[canSymbol.for('can.onKeyValue')]('isResolved', function (newVal) {
                QUnit.equal(newVal, true, 'isResolved updates on event');
                start();
            });
            p[canSymbol.for('can.onKeyValue')]('state', function (newVal) {
                QUnit.equal(newVal, 'resolved', 'state updates on event');
                start();
            });
        });
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-simple-dom@1.3.0#test/support*/
define('can-simple-dom@1.3.0#test/support', [
    'exports',
    'can-simple-dom/simple-dom/document'
], function (exports, _document) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.document = undefined;
    exports.element = element;
    exports.fragment = fragment;
    exports.text = text;
    exports.comment = comment;
    var _document2 = _interopRequireDefault(_document);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    var root = typeof window !== 'undefined' ? window : global;
    var document = exports.document = undefined;
    exports.document = document = new _document2.default();
    function element(tagName, attrs) {
        var el = document.createElement(tagName);
        for (var key in attrs) {
            el.setAttribute(key, attrs[key]);
        }
        for (var i = 2; i < arguments.length; i++) {
            el.appendChild(arguments[i]);
        }
        return el;
    }
    function fragment() {
        var frag = document.createDocumentFragment();
        for (var i = 0; i < arguments.length; i++) {
            frag.appendChild(arguments[i]);
        }
        return frag;
    }
    function text(s) {
        return document.createTextNode(s);
    }
    function comment(s) {
        return document.createComment(s);
    }
});
/*can-simple-dom@1.3.0#test/element-test*/
define('can-simple-dom@1.3.0#test/element-test', [
    'can-simple-dom/simple-dom/document',
    'can-simple-dom/simple-dom/html-serializer',
    'can-simple-dom/simple-dom/void-map',
    './support',
    'steal-qunit'
], function (_document, _htmlSerializer, _voidMap, _support, _stealQunit) {
    'use strict';
    var _document2 = _interopRequireDefault(_document);
    var _htmlSerializer2 = _interopRequireDefault(_htmlSerializer);
    var _voidMap2 = _interopRequireDefault(_voidMap);
    var _stealQunit2 = _interopRequireDefault(_stealQunit);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    _stealQunit2.default.module('can-simple-dom - Element');
    _stealQunit2.default.test('appending a document fragment appends the fragment\'s children and not the fragment itself', function (assert) {
        var document = new _document2.default();
        var frag = document.createDocumentFragment();
        var elem = document.createElement('div');
        var head = document.head;
        var body = document.body;
        assert.ok(!!head, 'There is a <head> element');
        assert.ok(!!body, 'There is a <body> element');
        assert.strictEqual(body.firstChild, null, 'body has no children');
        frag.appendChild(elem);
        body.appendChild(frag);
        assert.strictEqual(body.firstChild.tagName, 'DIV', 'fragment\'s child is added as child of document');
    });
    _stealQunit2.default.test('appending a document fragment (via insertBefore) appends the fragment\'s children and not the fragment itself', function (assert) {
        var document = new _document2.default();
        var frag = document.createDocumentFragment();
        var elem = document.createElement('div');
        var existing = document.createElement('main');
        var body = document.body;
        body.appendChild(existing);
        assert.strictEqual(body.firstChild.tagName, 'MAIN', 'sanity check: the main element was actually inserted');
        assert.strictEqual(body.lastChild.tagName, 'MAIN', 'sanity check: the main element was actually inserted');
        frag.appendChild(elem);
        body.insertBefore(frag, existing);
        assert.strictEqual(body.firstChild.tagName, 'DIV', 'The body\'s first child is now DIV');
        assert.strictEqual(body.lastChild.tagName, 'MAIN', 'The body\'s last child is now MAIN');
    });
    _stealQunit2.default.test('child nodes can be access via item()', function (assert) {
        var document = new _document2.default();
        var parent = document.createElement('div');
        var child1 = document.createElement('p');
        var child2 = document.createElement('img');
        assert.strictEqual(parent.childNodes.item(0), null, 'attempting to access an item that doesn\'t exist returns null');
        parent.appendChild(child1);
        parent.appendChild(child2);
        assert.strictEqual(parent.childNodes.item(0), child1);
        assert.strictEqual(parent.childNodes.item(1), child2);
        assert.strictEqual(parent.childNodes.item(2), null);
        parent.removeChild(child1);
        assert.strictEqual(parent.childNodes.item(0), child2);
        assert.strictEqual(parent.childNodes.item(1), null);
        parent.removeChild(child2);
        assert.strictEqual(parent.childNodes.item(0), null);
        assert.strictEqual(parent.childNodes.item(1), null);
    });
    _stealQunit2.default.test('insertBefore can insert before the last child node', function (assert) {
        var document = new _document2.default();
        var parent = document.createElement('div');
        var child1 = document.createElement('p');
        var child2 = document.createElement('img');
        var child3 = document.createElement('span');
        parent.appendChild(child1);
        parent.appendChild(child2);
        parent.insertBefore(child3, child2);
        assert.strictEqual(parent.childNodes.item(1), child3);
    });
    _stealQunit2.default.test('cloneNode(true) recursively clones nodes', function (assert) {
        var parent = (0, _support.element)('div');
        var child1 = (0, _support.element)('p');
        var child2 = (0, _support.element)('img', { src: 'hamster.png' });
        var child3 = (0, _support.element)('span');
        parent.appendChild(child1);
        parent.appendChild(child2);
        parent.appendChild(child3);
        var child11 = (0, _support.text)('hello');
        var child12 = (0, _support.element)('span');
        child12.appendChild((0, _support.text)(' world'));
        var child13 = (0, _support.text)('!');
        child1.appendChild(child11);
        child1.appendChild(child12);
        child1.appendChild(child13);
        var clone = parent.cloneNode(true);
        assert.notEqual(parent.firstChild, null);
        assert.notStrictEqual(clone.firstChild, parent.firstChild);
        var clone2 = parent.cloneNode(true);
        assert.notEqual(parent.firstChild, null);
        assert.notStrictEqual(clone2.firstChild, clone.firstChild);
        assert.notStrictEqual(clone2.firstChild, parent.firstChild);
        var actual = new _htmlSerializer2.default(_voidMap2.default).serialize((0, _support.fragment)(clone));
        assert.equal(actual, '<div><p>hello<span> world</span>!</p><img src="hamster.png"><span></span></div>');
    });
    _stealQunit2.default.test('anchor element is created successfully - micro-location works (see #11)', function (assert) {
        assert.expect(0);
        var document = new _document2.default();
        try {
            document.createElement('a');
        } catch (ex) {
            assert.ok(false, 'Anchor throws exception');
        }
    });
    _stealQunit2.default.test('style.cssText is two way bound to the style attribute (#13)', function (assert) {
        var document = new _document2.default();
        var el = document.createElement('div');
        el.style.cssText = 'color: green;';
        assert.equal(el.getAttribute('style'), 'color: green;');
    });
    _stealQunit2.default.test('replaceChild works', function (assert) {
        var document = new _document2.default();
        var parent = document.createElement('div');
        var one = document.createElement('p');
        var two = document.createElement('span');
        parent.appendChild(one);
        assert.equal(parent.firstChild.nodeName, 'P', 'first child is a p');
        var oldChild = parent.replaceChild(two, one);
        assert.equal(oldChild, one, 'correct return value');
        assert.equal(parent.firstChild.nodeName, 'SPAN', 'child is now the span');
    });
    _stealQunit2.default.test('Replacing the document\'s firstChild updates documentElement', function (assert) {
        var document = new _document2.default();
        var first = document.documentElement;
        var html = document.createElement('html');
        var head = document.createElement('head');
        var body = document.createElement('body');
        html.appendChild(head);
        html.appendChild(body);
        document.replaceChild(html, document.documentElement);
        assert.equal(document.documentElement, html, 'documentElement is updated');
        assert.equal(document.body, body, 'document.body is updated');
        assert.equal(document.head, head, 'document.head is updated');
    });
    _stealQunit2.default.test('setAttribute(\'class\', value) updates the className', function (assert) {
        var document = new _document2.default();
        var el = document.createElement('div');
        el.setAttribute('class', 'foo bar');
        assert.equal(el.className, 'foo bar', 'Element\'s className is same as the attribute class');
    });
    _stealQunit2.default.test('innerHTML does not parse the contents of SCRIPT and STYLE nodes', function (assert) {
        var document = new _document2.default();
        var div = document.createElement('div');
        var script = document.createElement('script');
        try {
            div.innerHTML = '<span>foo</span>';
            ok(0, 'should not make it here b/c no parser is shipped');
        } catch (ex) {
            ok(1, 'tried to parse content');
        }
        var jsCode = 'var foo = \'<span>bar</span>\';';
        try {
            script.innerHTML = jsCode;
            equal(script.firstChild, script.lastChild, 'script has one child');
            equal(script.firstChild.nodeType, 3, 'only child is a text node');
            equal(script.firstChild.nodeValue, jsCode, 'code matches');
        } catch (ex) {
            ok(0, 'should not cause an error');
        }
    });
    _stealQunit2.default.test('removeChild should return the removed node', function (assert) {
        var document = new _document2.default();
        var parent = document.createElement('div');
        var child = document.createElement('p');
        parent.appendChild(child);
        var removedNode = parent.removeChild(child);
        assert.strictEqual(removedNode, child, 'removeChild should return the removed node');
    });
    _stealQunit2.default.test('Input\'s type property is two-way bound to the attribute', function (assert) {
        var document = new _document2.default();
        var input = document.createElement('input');
        input.setAttribute('type', 'text');
        assert.equal(input.type, 'text');
        input.type = 'radio';
        assert.equal(input.type, 'radio');
        assert.equal(input.getAttribute('type'), 'radio');
    });
    _stealQunit2.default.test('Input\'s value property is two-way bound to the attribute', function (assert) {
        var document = new _document2.default();
        var input = document.createElement('input');
        input.setAttribute('value', 'foo');
        assert.equal(input.value, 'foo');
        input.value = 'bar';
        assert.equal(input.value, 'bar');
        assert.equal(input.getAttribute('value'), 'bar');
    });
    _stealQunit2.default.test('Input\'s checked value is two-way bound', function (assert) {
        var document = new _document2.default();
        var input = document.createElement('input');
        input.setAttribute('checked', '');
        assert.ok(input.checked);
        input.checked = false;
        assert.equal(input.hasAttribute('checked'), false);
        assert.equal(input.checked, false);
    });
    _stealQunit2.default.test('Select\'s value attribute is two-way bound', function (assert) {
        var document = new _document2.default();
        var select = document.createElement('select');
        select.setAttribute('value', 'foo');
        assert.equal(select.value, 'foo');
        select.value = 'bar';
        assert.equal(select.value, 'bar');
        assert.equal(select.getAttribute('value'), 'bar');
    });
    _stealQunit2.default.test('Option\'s value attribute is two-way bound', function (assert) {
        var document = new _document2.default();
        var option = document.createElement('option');
        option.setAttribute('value', 'foo');
        assert.equal(option.value, 'foo');
        option.value = 'bar';
        assert.equal(option.value, 'bar');
        assert.equal(option.getAttribute('value'), 'bar');
    });
    _stealQunit2.default.test('Option\'s selected value is tied to parent select\'s value', function (assert) {
        var document = new _document2.default();
        var select = document.createElement('select');
        var option = document.createElement('option');
        select.appendChild(option);
        select.value = 'foo';
        option.value = 'foo';
        assert.equal(option.selected, true);
        option.value = 'bar';
        assert.equal(option.selected, false);
        option.selected = true;
        assert.equal(select.value, 'bar');
    });
    _stealQunit2.default.test('option\'s selected property is configurable and enumerable', function (assert) {
        var document = new _document2.default();
        var option = document.createElement('option');
        var proto = Object.getPrototypeOf(option);
        var desc = Object.getOwnPropertyDescriptor(proto, 'selected');
        assert.equal(desc.enumerable, true, 'selected is enumerable');
        assert.equal(desc.configurable, true, 'selected is configurable');
    });
    _stealQunit2.default.test('The className property is configurable and enumerable', function (assert) {
        var document = new _document2.default();
        var option = document.createElement('some-el');
        var proto = Object.getPrototypeOf(option);
        var desc = Object.getOwnPropertyDescriptor(proto, 'className');
        assert.equal(desc.enumerable, true, 'selected is enumerable');
        assert.equal(desc.configurable, true, 'selected is configurable');
    });
    _stealQunit2.default.test('The innerHTML property is configurable and enumerable', function (assert) {
        var document = new _document2.default();
        var option = document.createElement('some-el');
        var proto = Object.getPrototypeOf(option);
        var desc = Object.getOwnPropertyDescriptor(proto, 'innerHTML');
        assert.equal(desc.enumerable, true, 'selected is enumerable');
        assert.equal(desc.configurable, true, 'selected is configurable');
    });
    _stealQunit2.default.test('Elements created in one document but inserted into another have their ownerDocument updated', function (assert) {
        var doc1 = new _document2.default();
        var doc2 = new _document2.default();
        var div = doc1.createElement('div');
        var span = doc1.createElement('span');
        div.appendChild(span);
        doc2.body.appendChild(div);
        assert.equal(div.ownerDocument, doc2, 'The ownerDocument was updated');
        assert.equal(span.ownerDocument, doc2, 'ownerDocument on a child was updated too');
    });
    _stealQunit2.default.test('Elements created in one document but inserted into another have their ownerDocument updated (documentElement)', function (assert) {
        var doc1 = new _document2.default();
        var doc2 = new _document2.default();
        var html = doc1.createElement('html');
        doc2.replaceChild(html, doc2.documentElement);
        assert.equal(html.ownerDocument, doc2, 'The ownerDocument was updated');
    });
    _stealQunit2.default.test('Elements created in one document but inserted into another have their ownerDocument updated (DocumentFragment)', function (assert) {
        var doc1 = new _document2.default();
        var doc2 = new _document2.default();
        var div = doc1.createElement('div');
        var span = doc1.createElement('span');
        div.appendChild(span);
        var frag = doc1.createDocumentFragment();
        frag.appendChild(div);
        doc2.body.appendChild(frag);
        assert.equal(div.ownerDocument, doc2, 'The ownerDocument was updated');
        assert.equal(span.ownerDocument, doc2, 'ownerDocument on a child was updated too');
    });
    _stealQunit2.default.test('Setting an element\'s textContent inserts TextNode', function (assert) {
        var document = new _document2.default();
        var el = document.createElement('div');
        el.textContent = 'foo';
        var tn = el.childNodes.item(0);
        assert.equal(tn.nodeType, 3, 'It is a TextNode');
        assert.equal(tn.nodeValue, 'foo', 'With the text');
        assert.equal(el.textContent, 'foo', 'Getter works');
    });
    _stealQunit2.default.test('Setting textContent when there is already a child', function (assert) {
        var document = new _document2.default();
        var el = document.createElement('div');
        el.appendChild(document.createElement('span'));
        assert.equal(el.childNodes.item(0).nodeName, 'SPAN', 'starts as a span');
        el.textContent = 'hello world';
        var tn = el.childNodes.item(0);
        assert.equal(tn.nodeType, 3, 'It is a TextNode');
        assert.equal(tn.nodeValue, 'hello world', 'With the text');
        assert.equal(el.textContent, 'hello world', 'Getter works');
        assert.equal(el.childNodes.item(1), null, 'span is gone');
    });
});
/*can-simple-dom@1.3.0#test/serializer-test*/
define('can-simple-dom@1.3.0#test/serializer-test', [
    './support',
    'can-simple-dom/simple-dom/html-serializer',
    'can-simple-dom/simple-dom/void-map',
    'steal-qunit'
], function (_support, _htmlSerializer, _voidMap, _stealQunit) {
    'use strict';
    var _htmlSerializer2 = _interopRequireDefault(_htmlSerializer);
    var _voidMap2 = _interopRequireDefault(_voidMap);
    var _stealQunit2 = _interopRequireDefault(_stealQunit);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    _stealQunit2.default.module('can-simple-dom - Serializer', {
        beforeEach: function beforeEach() {
            this.serializer = new _htmlSerializer2.default(_voidMap2.default);
        }
    });
    _stealQunit2.default.test('simple text', function (assert) {
        var actual = this.serializer.serialize((0, _support.fragment)((0, _support.text)('hello > world &amp; &nbsp;&nbsp; & goodbye')));
        assert.equal(actual, 'hello &gt; world &amp; &nbsp;&nbsp; &amp; goodbye');
    });
    _stealQunit2.default.test('serializes correctly', function (assert) {
        var actual = this.serializer.serialize((0, _support.fragment)((0, _support.element)('div', {
            id: 'foo',
            title: '&amp;&"'
        }, (0, _support.element)('b', {}, (0, _support.text)('Foo & Bar &amp; Baz < Buz > Biz \xA9')))));
        assert.equal(actual, '<div id="foo" title="&amp;&amp;&quot;"><b>Foo &amp; Bar &amp; Baz &lt; Buz &gt; Biz \xA9</b></div>');
    });
    _stealQunit2.default.test('serializes image correctly', function (assert) {
        var actual = this.serializer.serialize((0, _support.fragment)((0, _support.element)('img', { src: 'https://foo.com/foobar.jpg?foo=bar&bar=foo' })));
        assert.equal(actual, '<img src="https://foo.com/foobar.jpg?foo=bar&bar=foo">');
    });
    _stealQunit2.default.test('serializes textContent', function (assert) {
        var el, actual, frag;
        el = (0, _support.element)('div', {});
        el.textContent = 'hello world';
        actual = this.serializer.serialize((0, _support.fragment)(el));
        assert.equal(actual, '<div>hello world</div>');
    });
    _stealQunit2.default.test('correctly serializes code blocks', function (assert) {
        var el, actual, frag;
        el = (0, _support.element)('script', {});
        el.appendChild((0, _support.text)('<anonymous>'));
        actual = this.serializer.serialize((0, _support.fragment)(el));
        assert.equal(actual, '<script><anonymous></script>', 'script tag content serialized');
    });
});
/*simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/utils*/
define('simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/utils', ['exports'], function (exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.isSpace = isSpace;
    exports.isAlpha = isAlpha;
    exports.preprocessInput = preprocessInput;
    var WSP = /[\t\n\f ]/;
    var ALPHA = /[A-Za-z]/;
    var CRLF = /\r\n?/g;
    function isSpace(char) {
        return WSP.test(char);
    }
    function isAlpha(char) {
        return ALPHA.test(char);
    }
    function preprocessInput(input) {
        return input.replace(CRLF, '\n');
    }
});
/*simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/evented-tokenizer*/
define('simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/evented-tokenizer', [
    'exports',
    './utils'
], function (exports, _utils) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    function EventedTokenizer(delegate, entityParser) {
        this.delegate = delegate;
        this.entityParser = entityParser;
        this.state = null;
        this.input = null;
        this.index = -1;
        this.line = -1;
        this.column = -1;
        this.tagLine = -1;
        this.tagColumn = -1;
        this.reset();
    }
    EventedTokenizer.prototype = {
        reset: function reset() {
            this.state = 'beforeData';
            this.input = '';
            this.index = 0;
            this.line = 1;
            this.column = 0;
            this.tagLine = -1;
            this.tagColumn = -1;
            this.delegate.reset();
        },
        tokenize: function tokenize(input) {
            this.reset();
            this.tokenizePart(input);
            this.tokenizeEOF();
        },
        tokenizePart: function tokenizePart(input) {
            this.input += (0, _utils.preprocessInput)(input);
            while (this.index < this.input.length) {
                this.states[this.state].call(this);
            }
        },
        tokenizeEOF: function tokenizeEOF() {
            this.flushData();
        },
        flushData: function flushData() {
            if (this.state === 'data') {
                this.delegate.finishData();
                this.state = 'beforeData';
            }
        },
        peek: function peek() {
            return this.input.charAt(this.index);
        },
        consume: function consume() {
            var char = this.peek();
            this.index++;
            if (char === '\n') {
                this.line++;
                this.column = 0;
            } else {
                this.column++;
            }
            return char;
        },
        consumeCharRef: function consumeCharRef() {
            var endIndex = this.input.indexOf(';', this.index);
            if (endIndex === -1) {
                return;
            }
            var entity = this.input.slice(this.index, endIndex);
            var chars = this.entityParser.parse(entity);
            if (chars) {
                var count = entity.length;
                while (count) {
                    this.consume();
                    count--;
                }
                this.consume();
                return chars;
            }
        },
        markTagStart: function markTagStart() {
            this.tagLine = this.line;
            this.tagColumn = this.column;
            if (this.delegate.tagOpen) {
                this.delegate.tagOpen();
            }
        },
        states: {
            beforeData: function beforeData() {
                var char = this.peek();
                if (char === '<') {
                    this.state = 'tagOpen';
                    this.markTagStart();
                    this.consume();
                } else {
                    this.state = 'data';
                    this.delegate.beginData();
                }
            },
            data: function data() {
                var char = this.peek();
                if (char === '<') {
                    this.delegate.finishData();
                    this.state = 'tagOpen';
                    this.markTagStart();
                    this.consume();
                } else if (char === '&') {
                    this.consume();
                    this.delegate.appendToData(this.consumeCharRef() || '&');
                } else {
                    this.consume();
                    this.delegate.appendToData(char);
                }
            },
            tagOpen: function tagOpen() {
                var char = this.consume();
                if (char === '!') {
                    this.state = 'markupDeclaration';
                } else if (char === '/') {
                    this.state = 'endTagOpen';
                } else if ((0, _utils.isAlpha)(char)) {
                    this.state = 'tagName';
                    this.delegate.beginStartTag();
                    this.delegate.appendToTagName(char.toLowerCase());
                }
            },
            markupDeclaration: function markupDeclaration() {
                var char = this.consume();
                if (char === '-' && this.input.charAt(this.index) === '-') {
                    this.consume();
                    this.state = 'commentStart';
                    this.delegate.beginComment();
                }
            },
            commentStart: function commentStart() {
                var char = this.consume();
                if (char === '-') {
                    this.state = 'commentStartDash';
                } else if (char === '>') {
                    this.delegate.finishComment();
                    this.state = 'beforeData';
                } else {
                    this.delegate.appendToCommentData(char);
                    this.state = 'comment';
                }
            },
            commentStartDash: function commentStartDash() {
                var char = this.consume();
                if (char === '-') {
                    this.state = 'commentEnd';
                } else if (char === '>') {
                    this.delegate.finishComment();
                    this.state = 'beforeData';
                } else {
                    this.delegate.appendToCommentData('-');
                    this.state = 'comment';
                }
            },
            comment: function comment() {
                var char = this.consume();
                if (char === '-') {
                    this.state = 'commentEndDash';
                } else {
                    this.delegate.appendToCommentData(char);
                }
            },
            commentEndDash: function commentEndDash() {
                var char = this.consume();
                if (char === '-') {
                    this.state = 'commentEnd';
                } else {
                    this.delegate.appendToCommentData('-' + char);
                    this.state = 'comment';
                }
            },
            commentEnd: function commentEnd() {
                var char = this.consume();
                if (char === '>') {
                    this.delegate.finishComment();
                    this.state = 'beforeData';
                } else {
                    this.delegate.appendToCommentData('--' + char);
                    this.state = 'comment';
                }
            },
            tagName: function tagName() {
                var char = this.consume();
                if ((0, _utils.isSpace)(char)) {
                    this.state = 'beforeAttributeName';
                } else if (char === '/') {
                    this.state = 'selfClosingStartTag';
                } else if (char === '>') {
                    this.delegate.finishTag();
                    this.state = 'beforeData';
                } else {
                    this.delegate.appendToTagName(char);
                }
            },
            beforeAttributeName: function beforeAttributeName() {
                var char = this.peek();
                if ((0, _utils.isSpace)(char)) {
                    this.consume();
                    return;
                } else if (char === '/') {
                    this.state = 'selfClosingStartTag';
                    this.consume();
                } else if (char === '>') {
                    this.consume();
                    this.delegate.finishTag();
                    this.state = 'beforeData';
                } else {
                    this.state = 'attributeName';
                    this.delegate.beginAttribute();
                    this.consume();
                    this.delegate.appendToAttributeName(char);
                }
            },
            attributeName: function attributeName() {
                var char = this.peek();
                if ((0, _utils.isSpace)(char)) {
                    this.state = 'afterAttributeName';
                    this.consume();
                } else if (char === '/') {
                    this.delegate.beginAttributeValue(false);
                    this.delegate.finishAttributeValue();
                    this.consume();
                    this.state = 'selfClosingStartTag';
                } else if (char === '=') {
                    this.state = 'beforeAttributeValue';
                    this.consume();
                } else if (char === '>') {
                    this.delegate.beginAttributeValue(false);
                    this.delegate.finishAttributeValue();
                    this.consume();
                    this.delegate.finishTag();
                    this.state = 'beforeData';
                } else {
                    this.consume();
                    this.delegate.appendToAttributeName(char);
                }
            },
            afterAttributeName: function afterAttributeName() {
                var char = this.peek();
                if ((0, _utils.isSpace)(char)) {
                    this.consume();
                    return;
                } else if (char === '/') {
                    this.delegate.beginAttributeValue(false);
                    this.delegate.finishAttributeValue();
                    this.consume();
                    this.state = 'selfClosingStartTag';
                } else if (char === '=') {
                    this.consume();
                    this.state = 'beforeAttributeValue';
                } else if (char === '>') {
                    this.delegate.beginAttributeValue(false);
                    this.delegate.finishAttributeValue();
                    this.consume();
                    this.delegate.finishTag();
                    this.state = 'beforeData';
                } else {
                    this.delegate.beginAttributeValue(false);
                    this.delegate.finishAttributeValue();
                    this.consume();
                    this.state = 'attributeName';
                    this.delegate.beginAttribute();
                    this.delegate.appendToAttributeName(char);
                }
            },
            beforeAttributeValue: function beforeAttributeValue() {
                var char = this.peek();
                if ((0, _utils.isSpace)(char)) {
                    this.consume();
                } else if (char === '"') {
                    this.state = 'attributeValueDoubleQuoted';
                    this.delegate.beginAttributeValue(true);
                    this.consume();
                } else if (char === '\'') {
                    this.state = 'attributeValueSingleQuoted';
                    this.delegate.beginAttributeValue(true);
                    this.consume();
                } else if (char === '>') {
                    this.delegate.beginAttributeValue(false);
                    this.delegate.finishAttributeValue();
                    this.consume();
                    this.delegate.finishTag();
                    this.state = 'beforeData';
                } else {
                    this.state = 'attributeValueUnquoted';
                    this.delegate.beginAttributeValue(false);
                    this.consume();
                    this.delegate.appendToAttributeValue(char);
                }
            },
            attributeValueDoubleQuoted: function attributeValueDoubleQuoted() {
                var char = this.consume();
                if (char === '"') {
                    this.delegate.finishAttributeValue();
                    this.state = 'afterAttributeValueQuoted';
                } else if (char === '&') {
                    this.delegate.appendToAttributeValue(this.consumeCharRef('"') || '&');
                } else {
                    this.delegate.appendToAttributeValue(char);
                }
            },
            attributeValueSingleQuoted: function attributeValueSingleQuoted() {
                var char = this.consume();
                if (char === '\'') {
                    this.delegate.finishAttributeValue();
                    this.state = 'afterAttributeValueQuoted';
                } else if (char === '&') {
                    this.delegate.appendToAttributeValue(this.consumeCharRef('\'') || '&');
                } else {
                    this.delegate.appendToAttributeValue(char);
                }
            },
            attributeValueUnquoted: function attributeValueUnquoted() {
                var char = this.peek();
                if ((0, _utils.isSpace)(char)) {
                    this.delegate.finishAttributeValue();
                    this.consume();
                    this.state = 'beforeAttributeName';
                } else if (char === '&') {
                    this.consume();
                    this.delegate.appendToAttributeValue(this.consumeCharRef('>') || '&');
                } else if (char === '>') {
                    this.delegate.finishAttributeValue();
                    this.consume();
                    this.delegate.finishTag();
                    this.state = 'beforeData';
                } else {
                    this.consume();
                    this.delegate.appendToAttributeValue(char);
                }
            },
            afterAttributeValueQuoted: function afterAttributeValueQuoted() {
                var char = this.peek();
                if ((0, _utils.isSpace)(char)) {
                    this.consume();
                    this.state = 'beforeAttributeName';
                } else if (char === '/') {
                    this.consume();
                    this.state = 'selfClosingStartTag';
                } else if (char === '>') {
                    this.consume();
                    this.delegate.finishTag();
                    this.state = 'beforeData';
                } else {
                    this.state = 'beforeAttributeName';
                }
            },
            selfClosingStartTag: function selfClosingStartTag() {
                var char = this.peek();
                if (char === '>') {
                    this.consume();
                    this.delegate.markTagAsSelfClosing();
                    this.delegate.finishTag();
                    this.state = 'beforeData';
                } else {
                    this.state = 'beforeAttributeName';
                }
            },
            endTagOpen: function endTagOpen() {
                var char = this.consume();
                if ((0, _utils.isAlpha)(char)) {
                    this.state = 'tagName';
                    this.delegate.beginEndTag();
                    this.delegate.appendToTagName(char.toLowerCase());
                }
            }
        }
    };
    exports.default = EventedTokenizer;
});
/*simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/tokenizer*/
define('simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/tokenizer', [
    'exports',
    './evented-tokenizer'
], function (exports, _eventedTokenizer) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    var _eventedTokenizer2 = _interopRequireDefault(_eventedTokenizer);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    function Tokenizer(entityParser, options) {
        this.token = null;
        this.startLine = 1;
        this.startColumn = 0;
        this.options = options || {};
        this.tokenizer = new _eventedTokenizer2.default(this, entityParser);
    }
    Tokenizer.prototype = {
        tokenize: function tokenize(input) {
            this.tokens = [];
            this.tokenizer.tokenize(input);
            return this.tokens;
        },
        tokenizePart: function tokenizePart(input) {
            this.tokens = [];
            this.tokenizer.tokenizePart(input);
            return this.tokens;
        },
        tokenizeEOF: function tokenizeEOF() {
            this.tokens = [];
            this.tokenizer.tokenizeEOF();
            return this.tokens[0];
        },
        reset: function reset() {
            this.token = null;
            this.startLine = 1;
            this.startColumn = 0;
        },
        addLocInfo: function addLocInfo() {
            if (this.options.loc) {
                this.token.loc = {
                    start: {
                        line: this.startLine,
                        column: this.startColumn
                    },
                    end: {
                        line: this.tokenizer.line,
                        column: this.tokenizer.column
                    }
                };
            }
            this.startLine = this.tokenizer.line;
            this.startColumn = this.tokenizer.column;
        },
        beginData: function beginData() {
            this.token = {
                type: 'Chars',
                chars: ''
            };
            this.tokens.push(this.token);
        },
        appendToData: function appendToData(char) {
            this.token.chars += char;
        },
        finishData: function finishData() {
            this.addLocInfo();
        },
        beginComment: function beginComment() {
            this.token = {
                type: 'Comment',
                chars: ''
            };
            this.tokens.push(this.token);
        },
        appendToCommentData: function appendToCommentData(char) {
            this.token.chars += char;
        },
        finishComment: function finishComment() {
            this.addLocInfo();
        },
        beginStartTag: function beginStartTag() {
            this.token = {
                type: 'StartTag',
                tagName: '',
                attributes: [],
                selfClosing: false
            };
            this.tokens.push(this.token);
        },
        beginEndTag: function beginEndTag() {
            this.token = {
                type: 'EndTag',
                tagName: ''
            };
            this.tokens.push(this.token);
        },
        finishTag: function finishTag() {
            this.addLocInfo();
        },
        markTagAsSelfClosing: function markTagAsSelfClosing() {
            this.token.selfClosing = true;
        },
        appendToTagName: function appendToTagName(char) {
            this.token.tagName += char;
        },
        beginAttribute: function beginAttribute() {
            this._currentAttribute = [
                '',
                '',
                null
            ];
            this.token.attributes.push(this._currentAttribute);
        },
        appendToAttributeName: function appendToAttributeName(char) {
            this._currentAttribute[0] += char;
        },
        beginAttributeValue: function beginAttributeValue(isQuoted) {
            this._currentAttribute[2] = isQuoted;
        },
        appendToAttributeValue: function appendToAttributeValue(char) {
            this._currentAttribute[1] = this._currentAttribute[1] || '';
            this._currentAttribute[1] += char;
        },
        finishAttributeValue: function finishAttributeValue() {
        }
    };
    exports.default = Tokenizer;
});
/*simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/entity-parser*/
define('simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/entity-parser', ['exports'], function (exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    function EntityParser(named) {
        this.named = named;
    }
    var HEXCHARCODE = /^#[xX]([A-Fa-f0-9]+)$/;
    var CHARCODE = /^#([0-9]+)$/;
    var NAMED = /^([A-Za-z0-9]+)$/;
    EntityParser.prototype.parse = function (entity) {
        if (!entity) {
            return;
        }
        var matches = entity.match(HEXCHARCODE);
        if (matches) {
            return String.fromCharCode(parseInt(matches[1], 16));
        }
        matches = entity.match(CHARCODE);
        if (matches) {
            return String.fromCharCode(parseInt(matches[1], 10));
        }
        matches = entity.match(NAMED);
        if (matches) {
            return this.named[matches[1]];
        }
    };
    exports.default = EntityParser;
});
/*simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/html5-named-char-refs*/
define('simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/html5-named-char-refs', ['exports'], function (exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.default = {
        Aacute: 'Á',
        aacute: 'á',
        Abreve: 'Ă',
        abreve: 'ă',
        ac: '\u223E',
        acd: '\u223F',
        acE: '\u223E̳',
        Acirc: 'Â',
        acirc: 'â',
        acute: '\xB4',
        Acy: 'А',
        acy: 'а',
        AElig: 'Æ',
        aelig: 'æ',
        af: '\u2061',
        Afr: '\uD835\uDD04',
        afr: '\uD835\uDD1E',
        Agrave: 'À',
        agrave: 'à',
        alefsym: 'ℵ',
        aleph: 'ℵ',
        Alpha: 'Α',
        alpha: 'α',
        Amacr: 'Ā',
        amacr: 'ā',
        amalg: '\u2A3F',
        AMP: '&',
        amp: '&',
        And: '\u2A53',
        and: '\u2227',
        andand: '\u2A55',
        andd: '\u2A5C',
        andslope: '\u2A58',
        andv: '\u2A5A',
        ang: '\u2220',
        ange: '\u29A4',
        angle: '\u2220',
        angmsd: '\u2221',
        angmsdaa: '\u29A8',
        angmsdab: '\u29A9',
        angmsdac: '\u29AA',
        angmsdad: '\u29AB',
        angmsdae: '\u29AC',
        angmsdaf: '\u29AD',
        angmsdag: '\u29AE',
        angmsdah: '\u29AF',
        angrt: '\u221F',
        angrtvb: '\u22BE',
        angrtvbd: '\u299D',
        angsph: '\u2222',
        angst: 'Å',
        angzarr: '\u237C',
        Aogon: 'Ą',
        aogon: 'ą',
        Aopf: '\uD835\uDD38',
        aopf: '\uD835\uDD52',
        ap: '\u2248',
        apacir: '\u2A6F',
        apE: '\u2A70',
        ape: '\u224A',
        apid: '\u224B',
        apos: '\'',
        ApplyFunction: '\u2061',
        approx: '\u2248',
        approxeq: '\u224A',
        Aring: 'Å',
        aring: 'å',
        Ascr: '\uD835\uDC9C',
        ascr: '\uD835\uDCB6',
        Assign: '\u2254',
        ast: '*',
        asymp: '\u2248',
        asympeq: '\u224D',
        Atilde: 'Ã',
        atilde: 'ã',
        Auml: 'Ä',
        auml: 'ä',
        awconint: '\u2233',
        awint: '\u2A11',
        backcong: '\u224C',
        backepsilon: '\u03F6',
        backprime: '\u2035',
        backsim: '\u223D',
        backsimeq: '\u22CD',
        Backslash: '\u2216',
        Barv: '\u2AE7',
        barvee: '\u22BD',
        Barwed: '\u2306',
        barwed: '\u2305',
        barwedge: '\u2305',
        bbrk: '\u23B5',
        bbrktbrk: '\u23B6',
        bcong: '\u224C',
        Bcy: 'Б',
        bcy: 'б',
        bdquo: '\u201E',
        becaus: '\u2235',
        Because: '\u2235',
        because: '\u2235',
        bemptyv: '\u29B0',
        bepsi: '\u03F6',
        bernou: 'ℬ',
        Bernoullis: 'ℬ',
        Beta: 'Β',
        beta: 'β',
        beth: 'ℶ',
        between: '\u226C',
        Bfr: '\uD835\uDD05',
        bfr: '\uD835\uDD1F',
        bigcap: '\u22C2',
        bigcirc: '\u25EF',
        bigcup: '\u22C3',
        bigodot: '\u2A00',
        bigoplus: '\u2A01',
        bigotimes: '\u2A02',
        bigsqcup: '\u2A06',
        bigstar: '\u2605',
        bigtriangledown: '\u25BD',
        bigtriangleup: '\u25B3',
        biguplus: '\u2A04',
        bigvee: '\u22C1',
        bigwedge: '\u22C0',
        bkarow: '\u290D',
        blacklozenge: '\u29EB',
        blacksquare: '\u25AA',
        blacktriangle: '\u25B4',
        blacktriangledown: '\u25BE',
        blacktriangleleft: '\u25C2',
        blacktriangleright: '\u25B8',
        blank: '\u2423',
        blk12: '\u2592',
        blk14: '\u2591',
        blk34: '\u2593',
        block: '\u2588',
        bne: '=⃥',
        bnequiv: '\u2261⃥',
        bNot: '\u2AED',
        bnot: '\u2310',
        Bopf: '\uD835\uDD39',
        bopf: '\uD835\uDD53',
        bot: '\u22A5',
        bottom: '\u22A5',
        bowtie: '\u22C8',
        boxbox: '\u29C9',
        boxDL: '\u2557',
        boxDl: '\u2556',
        boxdL: '\u2555',
        boxdl: '\u2510',
        boxDR: '\u2554',
        boxDr: '\u2553',
        boxdR: '\u2552',
        boxdr: '\u250C',
        boxH: '\u2550',
        boxh: '\u2500',
        boxHD: '\u2566',
        boxHd: '\u2564',
        boxhD: '\u2565',
        boxhd: '\u252C',
        boxHU: '\u2569',
        boxHu: '\u2567',
        boxhU: '\u2568',
        boxhu: '\u2534',
        boxminus: '\u229F',
        boxplus: '\u229E',
        boxtimes: '\u22A0',
        boxUL: '\u255D',
        boxUl: '\u255C',
        boxuL: '\u255B',
        boxul: '\u2518',
        boxUR: '\u255A',
        boxUr: '\u2559',
        boxuR: '\u2558',
        boxur: '\u2514',
        boxV: '\u2551',
        boxv: '\u2502',
        boxVH: '\u256C',
        boxVh: '\u256B',
        boxvH: '\u256A',
        boxvh: '\u253C',
        boxVL: '\u2563',
        boxVl: '\u2562',
        boxvL: '\u2561',
        boxvl: '\u2524',
        boxVR: '\u2560',
        boxVr: '\u255F',
        boxvR: '\u255E',
        boxvr: '\u251C',
        bprime: '\u2035',
        Breve: '\u02D8',
        breve: '\u02D8',
        brvbar: '\xA6',
        Bscr: 'ℬ',
        bscr: '\uD835\uDCB7',
        bsemi: '\u204F',
        bsim: '\u223D',
        bsime: '\u22CD',
        bsol: '\\',
        bsolb: '\u29C5',
        bsolhsub: '\u27C8',
        bull: '\u2022',
        bullet: '\u2022',
        bump: '\u224E',
        bumpE: '\u2AAE',
        bumpe: '\u224F',
        Bumpeq: '\u224E',
        bumpeq: '\u224F',
        Cacute: 'Ć',
        cacute: 'ć',
        Cap: '\u22D2',
        cap: '\u2229',
        capand: '\u2A44',
        capbrcup: '\u2A49',
        capcap: '\u2A4B',
        capcup: '\u2A47',
        capdot: '\u2A40',
        CapitalDifferentialD: 'ⅅ',
        caps: '\u2229︀',
        caret: '\u2041',
        caron: 'ˇ',
        Cayleys: 'ℭ',
        ccaps: '\u2A4D',
        Ccaron: 'Č',
        ccaron: 'č',
        Ccedil: 'Ç',
        ccedil: 'ç',
        Ccirc: 'Ĉ',
        ccirc: 'ĉ',
        Cconint: '\u2230',
        ccups: '\u2A4C',
        ccupssm: '\u2A50',
        Cdot: 'Ċ',
        cdot: 'ċ',
        cedil: '\xB8',
        Cedilla: '\xB8',
        cemptyv: '\u29B2',
        cent: '\xA2',
        CenterDot: '\xB7',
        centerdot: '\xB7',
        Cfr: 'ℭ',
        cfr: '\uD835\uDD20',
        CHcy: 'Ч',
        chcy: 'ч',
        check: '\u2713',
        checkmark: '\u2713',
        Chi: 'Χ',
        chi: 'χ',
        cir: '\u25CB',
        circ: 'ˆ',
        circeq: '\u2257',
        circlearrowleft: '\u21BA',
        circlearrowright: '\u21BB',
        circledast: '\u229B',
        circledcirc: '\u229A',
        circleddash: '\u229D',
        CircleDot: '\u2299',
        circledR: '\xAE',
        circledS: '\u24C8',
        CircleMinus: '\u2296',
        CirclePlus: '\u2295',
        CircleTimes: '\u2297',
        cirE: '\u29C3',
        cire: '\u2257',
        cirfnint: '\u2A10',
        cirmid: '\u2AEF',
        cirscir: '\u29C2',
        ClockwiseContourIntegral: '\u2232',
        CloseCurlyDoubleQuote: '\u201D',
        CloseCurlyQuote: '\u2019',
        clubs: '\u2663',
        clubsuit: '\u2663',
        Colon: '\u2237',
        colon: ':',
        Colone: '\u2A74',
        colone: '\u2254',
        coloneq: '\u2254',
        comma: ',',
        commat: '@',
        comp: '\u2201',
        compfn: '\u2218',
        complement: '\u2201',
        complexes: 'ℂ',
        cong: '\u2245',
        congdot: '\u2A6D',
        Congruent: '\u2261',
        Conint: '\u222F',
        conint: '\u222E',
        ContourIntegral: '\u222E',
        Copf: 'ℂ',
        copf: '\uD835\uDD54',
        coprod: '\u2210',
        Coproduct: '\u2210',
        COPY: '\xA9',
        copy: '\xA9',
        copysr: '\u2117',
        CounterClockwiseContourIntegral: '\u2233',
        crarr: '\u21B5',
        Cross: '\u2A2F',
        cross: '\u2717',
        Cscr: '\uD835\uDC9E',
        cscr: '\uD835\uDCB8',
        csub: '\u2ACF',
        csube: '\u2AD1',
        csup: '\u2AD0',
        csupe: '\u2AD2',
        ctdot: '\u22EF',
        cudarrl: '\u2938',
        cudarrr: '\u2935',
        cuepr: '\u22DE',
        cuesc: '\u22DF',
        cularr: '\u21B6',
        cularrp: '\u293D',
        Cup: '\u22D3',
        cup: '\u222A',
        cupbrcap: '\u2A48',
        CupCap: '\u224D',
        cupcap: '\u2A46',
        cupcup: '\u2A4A',
        cupdot: '\u228D',
        cupor: '\u2A45',
        cups: '\u222A︀',
        curarr: '\u21B7',
        curarrm: '\u293C',
        curlyeqprec: '\u22DE',
        curlyeqsucc: '\u22DF',
        curlyvee: '\u22CE',
        curlywedge: '\u22CF',
        curren: '\xA4',
        curvearrowleft: '\u21B6',
        curvearrowright: '\u21B7',
        cuvee: '\u22CE',
        cuwed: '\u22CF',
        cwconint: '\u2232',
        cwint: '\u2231',
        cylcty: '\u232D',
        Dagger: '\u2021',
        dagger: '\u2020',
        daleth: 'ℸ',
        Darr: '\u21A1',
        dArr: '\u21D3',
        darr: '\u2193',
        dash: '\u2010',
        Dashv: '\u2AE4',
        dashv: '\u22A3',
        dbkarow: '\u290F',
        dblac: '\u02DD',
        Dcaron: 'Ď',
        dcaron: 'ď',
        Dcy: 'Д',
        dcy: 'д',
        DD: 'ⅅ',
        dd: 'ⅆ',
        ddagger: '\u2021',
        ddarr: '\u21CA',
        DDotrahd: '\u2911',
        ddotseq: '\u2A77',
        deg: '\xB0',
        Del: '\u2207',
        Delta: 'Δ',
        delta: 'δ',
        demptyv: '\u29B1',
        dfisht: '\u297F',
        Dfr: '\uD835\uDD07',
        dfr: '\uD835\uDD21',
        dHar: '\u2965',
        dharl: '\u21C3',
        dharr: '\u21C2',
        DiacriticalAcute: '\xB4',
        DiacriticalDot: '\u02D9',
        DiacriticalDoubleAcute: '\u02DD',
        DiacriticalGrave: '`',
        DiacriticalTilde: '\u02DC',
        diam: '\u22C4',
        Diamond: '\u22C4',
        diamond: '\u22C4',
        diamondsuit: '\u2666',
        diams: '\u2666',
        die: '\xA8',
        DifferentialD: 'ⅆ',
        digamma: 'ϝ',
        disin: '\u22F2',
        div: '\xF7',
        divide: '\xF7',
        divideontimes: '\u22C7',
        divonx: '\u22C7',
        DJcy: 'Ђ',
        djcy: 'ђ',
        dlcorn: '\u231E',
        dlcrop: '\u230D',
        dollar: '$',
        Dopf: '\uD835\uDD3B',
        dopf: '\uD835\uDD55',
        Dot: '\xA8',
        dot: '\u02D9',
        DotDot: '⃜',
        doteq: '\u2250',
        doteqdot: '\u2251',
        DotEqual: '\u2250',
        dotminus: '\u2238',
        dotplus: '\u2214',
        dotsquare: '\u22A1',
        doublebarwedge: '\u2306',
        DoubleContourIntegral: '\u222F',
        DoubleDot: '\xA8',
        DoubleDownArrow: '\u21D3',
        DoubleLeftArrow: '\u21D0',
        DoubleLeftRightArrow: '\u21D4',
        DoubleLeftTee: '\u2AE4',
        DoubleLongLeftArrow: '\u27F8',
        DoubleLongLeftRightArrow: '\u27FA',
        DoubleLongRightArrow: '\u27F9',
        DoubleRightArrow: '\u21D2',
        DoubleRightTee: '\u22A8',
        DoubleUpArrow: '\u21D1',
        DoubleUpDownArrow: '\u21D5',
        DoubleVerticalBar: '\u2225',
        DownArrow: '\u2193',
        Downarrow: '\u21D3',
        downarrow: '\u2193',
        DownArrowBar: '\u2913',
        DownArrowUpArrow: '\u21F5',
        DownBreve: '̑',
        downdownarrows: '\u21CA',
        downharpoonleft: '\u21C3',
        downharpoonright: '\u21C2',
        DownLeftRightVector: '\u2950',
        DownLeftTeeVector: '\u295E',
        DownLeftVector: '\u21BD',
        DownLeftVectorBar: '\u2956',
        DownRightTeeVector: '\u295F',
        DownRightVector: '\u21C1',
        DownRightVectorBar: '\u2957',
        DownTee: '\u22A4',
        DownTeeArrow: '\u21A7',
        drbkarow: '\u2910',
        drcorn: '\u231F',
        drcrop: '\u230C',
        Dscr: '\uD835\uDC9F',
        dscr: '\uD835\uDCB9',
        DScy: 'Ѕ',
        dscy: 'ѕ',
        dsol: '\u29F6',
        Dstrok: 'Đ',
        dstrok: 'đ',
        dtdot: '\u22F1',
        dtri: '\u25BF',
        dtrif: '\u25BE',
        duarr: '\u21F5',
        duhar: '\u296F',
        dwangle: '\u29A6',
        DZcy: 'Џ',
        dzcy: 'џ',
        dzigrarr: '\u27FF',
        Eacute: 'É',
        eacute: 'é',
        easter: '\u2A6E',
        Ecaron: 'Ě',
        ecaron: 'ě',
        ecir: '\u2256',
        Ecirc: 'Ê',
        ecirc: 'ê',
        ecolon: '\u2255',
        Ecy: 'Э',
        ecy: 'э',
        eDDot: '\u2A77',
        Edot: 'Ė',
        eDot: '\u2251',
        edot: 'ė',
        ee: 'ⅇ',
        efDot: '\u2252',
        Efr: '\uD835\uDD08',
        efr: '\uD835\uDD22',
        eg: '\u2A9A',
        Egrave: 'È',
        egrave: 'è',
        egs: '\u2A96',
        egsdot: '\u2A98',
        el: '\u2A99',
        Element: '\u2208',
        elinters: '\u23E7',
        ell: 'ℓ',
        els: '\u2A95',
        elsdot: '\u2A97',
        Emacr: 'Ē',
        emacr: 'ē',
        empty: '\u2205',
        emptyset: '\u2205',
        EmptySmallSquare: '\u25FB',
        emptyv: '\u2205',
        EmptyVerySmallSquare: '\u25AB',
        emsp: '\u2003',
        emsp13: '\u2004',
        emsp14: '\u2005',
        ENG: 'Ŋ',
        eng: 'ŋ',
        ensp: '\u2002',
        Eogon: 'Ę',
        eogon: 'ę',
        Eopf: '\uD835\uDD3C',
        eopf: '\uD835\uDD56',
        epar: '\u22D5',
        eparsl: '\u29E3',
        eplus: '\u2A71',
        epsi: 'ε',
        Epsilon: 'Ε',
        epsilon: 'ε',
        epsiv: 'ϵ',
        eqcirc: '\u2256',
        eqcolon: '\u2255',
        eqsim: '\u2242',
        eqslantgtr: '\u2A96',
        eqslantless: '\u2A95',
        Equal: '\u2A75',
        equals: '=',
        EqualTilde: '\u2242',
        equest: '\u225F',
        Equilibrium: '\u21CC',
        equiv: '\u2261',
        equivDD: '\u2A78',
        eqvparsl: '\u29E5',
        erarr: '\u2971',
        erDot: '\u2253',
        Escr: 'ℰ',
        escr: 'ℯ',
        esdot: '\u2250',
        Esim: '\u2A73',
        esim: '\u2242',
        Eta: 'Η',
        eta: 'η',
        ETH: 'Ð',
        eth: 'ð',
        Euml: 'Ë',
        euml: 'ë',
        euro: '\u20AC',
        excl: '!',
        exist: '\u2203',
        Exists: '\u2203',
        expectation: 'ℰ',
        ExponentialE: 'ⅇ',
        exponentiale: 'ⅇ',
        fallingdotseq: '\u2252',
        Fcy: 'Ф',
        fcy: 'ф',
        female: '\u2640',
        ffilig: 'ﬃ',
        fflig: 'ﬀ',
        ffllig: 'ﬄ',
        Ffr: '\uD835\uDD09',
        ffr: '\uD835\uDD23',
        filig: 'ﬁ',
        FilledSmallSquare: '\u25FC',
        FilledVerySmallSquare: '\u25AA',
        fjlig: 'fj',
        flat: '\u266D',
        fllig: 'ﬂ',
        fltns: '\u25B1',
        fnof: 'ƒ',
        Fopf: '\uD835\uDD3D',
        fopf: '\uD835\uDD57',
        ForAll: '\u2200',
        forall: '\u2200',
        fork: '\u22D4',
        forkv: '\u2AD9',
        Fouriertrf: 'ℱ',
        fpartint: '\u2A0D',
        frac12: '\xBD',
        frac13: '\u2153',
        frac14: '\xBC',
        frac15: '\u2155',
        frac16: '\u2159',
        frac18: '\u215B',
        frac23: '\u2154',
        frac25: '\u2156',
        frac34: '\xBE',
        frac35: '\u2157',
        frac38: '\u215C',
        frac45: '\u2158',
        frac56: '\u215A',
        frac58: '\u215D',
        frac78: '\u215E',
        frasl: '\u2044',
        frown: '\u2322',
        Fscr: 'ℱ',
        fscr: '\uD835\uDCBB',
        gacute: 'ǵ',
        Gamma: 'Γ',
        gamma: 'γ',
        Gammad: 'Ϝ',
        gammad: 'ϝ',
        gap: '\u2A86',
        Gbreve: 'Ğ',
        gbreve: 'ğ',
        Gcedil: 'Ģ',
        Gcirc: 'Ĝ',
        gcirc: 'ĝ',
        Gcy: 'Г',
        gcy: 'г',
        Gdot: 'Ġ',
        gdot: 'ġ',
        gE: '\u2267',
        ge: '\u2265',
        gEl: '\u2A8C',
        gel: '\u22DB',
        geq: '\u2265',
        geqq: '\u2267',
        geqslant: '\u2A7E',
        ges: '\u2A7E',
        gescc: '\u2AA9',
        gesdot: '\u2A80',
        gesdoto: '\u2A82',
        gesdotol: '\u2A84',
        gesl: '\u22DB︀',
        gesles: '\u2A94',
        Gfr: '\uD835\uDD0A',
        gfr: '\uD835\uDD24',
        Gg: '\u22D9',
        gg: '\u226B',
        ggg: '\u22D9',
        gimel: 'ℷ',
        GJcy: 'Ѓ',
        gjcy: 'ѓ',
        gl: '\u2277',
        gla: '\u2AA5',
        glE: '\u2A92',
        glj: '\u2AA4',
        gnap: '\u2A8A',
        gnapprox: '\u2A8A',
        gnE: '\u2269',
        gne: '\u2A88',
        gneq: '\u2A88',
        gneqq: '\u2269',
        gnsim: '\u22E7',
        Gopf: '\uD835\uDD3E',
        gopf: '\uD835\uDD58',
        grave: '`',
        GreaterEqual: '\u2265',
        GreaterEqualLess: '\u22DB',
        GreaterFullEqual: '\u2267',
        GreaterGreater: '\u2AA2',
        GreaterLess: '\u2277',
        GreaterSlantEqual: '\u2A7E',
        GreaterTilde: '\u2273',
        Gscr: '\uD835\uDCA2',
        gscr: 'ℊ',
        gsim: '\u2273',
        gsime: '\u2A8E',
        gsiml: '\u2A90',
        GT: '>',
        Gt: '\u226B',
        gt: '>',
        gtcc: '\u2AA7',
        gtcir: '\u2A7A',
        gtdot: '\u22D7',
        gtlPar: '\u2995',
        gtquest: '\u2A7C',
        gtrapprox: '\u2A86',
        gtrarr: '\u2978',
        gtrdot: '\u22D7',
        gtreqless: '\u22DB',
        gtreqqless: '\u2A8C',
        gtrless: '\u2277',
        gtrsim: '\u2273',
        gvertneqq: '\u2269︀',
        gvnE: '\u2269︀',
        Hacek: 'ˇ',
        hairsp: '\u200A',
        half: '\xBD',
        hamilt: 'ℋ',
        HARDcy: 'Ъ',
        hardcy: 'ъ',
        hArr: '\u21D4',
        harr: '\u2194',
        harrcir: '\u2948',
        harrw: '\u21AD',
        Hat: '^',
        hbar: 'ℏ',
        Hcirc: 'Ĥ',
        hcirc: 'ĥ',
        hearts: '\u2665',
        heartsuit: '\u2665',
        hellip: '\u2026',
        hercon: '\u22B9',
        Hfr: 'ℌ',
        hfr: '\uD835\uDD25',
        HilbertSpace: 'ℋ',
        hksearow: '\u2925',
        hkswarow: '\u2926',
        hoarr: '\u21FF',
        homtht: '\u223B',
        hookleftarrow: '\u21A9',
        hookrightarrow: '\u21AA',
        Hopf: 'ℍ',
        hopf: '\uD835\uDD59',
        horbar: '\u2015',
        HorizontalLine: '\u2500',
        Hscr: 'ℋ',
        hscr: '\uD835\uDCBD',
        hslash: 'ℏ',
        Hstrok: 'Ħ',
        hstrok: 'ħ',
        HumpDownHump: '\u224E',
        HumpEqual: '\u224F',
        hybull: '\u2043',
        hyphen: '\u2010',
        Iacute: 'Í',
        iacute: 'í',
        ic: '\u2063',
        Icirc: 'Î',
        icirc: 'î',
        Icy: 'И',
        icy: 'и',
        Idot: 'İ',
        IEcy: 'Е',
        iecy: 'е',
        iexcl: '\xA1',
        iff: '\u21D4',
        Ifr: 'ℑ',
        ifr: '\uD835\uDD26',
        Igrave: 'Ì',
        igrave: 'ì',
        ii: 'ⅈ',
        iiiint: '\u2A0C',
        iiint: '\u222D',
        iinfin: '\u29DC',
        iiota: '\u2129',
        IJlig: 'Ĳ',
        ijlig: 'ĳ',
        Im: 'ℑ',
        Imacr: 'Ī',
        imacr: 'ī',
        image: 'ℑ',
        ImaginaryI: 'ⅈ',
        imagline: 'ℐ',
        imagpart: 'ℑ',
        imath: 'ı',
        imof: '\u22B7',
        imped: 'Ƶ',
        Implies: '\u21D2',
        in: '\u2208',
        incare: '\u2105',
        infin: '\u221E',
        infintie: '\u29DD',
        inodot: 'ı',
        Int: '\u222C',
        int: '\u222B',
        intcal: '\u22BA',
        integers: 'ℤ',
        Integral: '\u222B',
        intercal: '\u22BA',
        Intersection: '\u22C2',
        intlarhk: '\u2A17',
        intprod: '\u2A3C',
        InvisibleComma: '\u2063',
        InvisibleTimes: '\u2062',
        IOcy: 'Ё',
        iocy: 'ё',
        Iogon: 'Į',
        iogon: 'į',
        Iopf: '\uD835\uDD40',
        iopf: '\uD835\uDD5A',
        Iota: 'Ι',
        iota: 'ι',
        iprod: '\u2A3C',
        iquest: '\xBF',
        Iscr: 'ℐ',
        iscr: '\uD835\uDCBE',
        isin: '\u2208',
        isindot: '\u22F5',
        isinE: '\u22F9',
        isins: '\u22F4',
        isinsv: '\u22F3',
        isinv: '\u2208',
        it: '\u2062',
        Itilde: 'Ĩ',
        itilde: 'ĩ',
        Iukcy: 'І',
        iukcy: 'і',
        Iuml: 'Ï',
        iuml: 'ï',
        Jcirc: 'Ĵ',
        jcirc: 'ĵ',
        Jcy: 'Й',
        jcy: 'й',
        Jfr: '\uD835\uDD0D',
        jfr: '\uD835\uDD27',
        jmath: 'ȷ',
        Jopf: '\uD835\uDD41',
        jopf: '\uD835\uDD5B',
        Jscr: '\uD835\uDCA5',
        jscr: '\uD835\uDCBF',
        Jsercy: 'Ј',
        jsercy: 'ј',
        Jukcy: 'Є',
        jukcy: 'є',
        Kappa: 'Κ',
        kappa: 'κ',
        kappav: 'ϰ',
        Kcedil: 'Ķ',
        kcedil: 'ķ',
        Kcy: 'К',
        kcy: 'к',
        Kfr: '\uD835\uDD0E',
        kfr: '\uD835\uDD28',
        kgreen: 'ĸ',
        KHcy: 'Х',
        khcy: 'х',
        KJcy: 'Ќ',
        kjcy: 'ќ',
        Kopf: '\uD835\uDD42',
        kopf: '\uD835\uDD5C',
        Kscr: '\uD835\uDCA6',
        kscr: '\uD835\uDCC0',
        lAarr: '\u21DA',
        Lacute: 'Ĺ',
        lacute: 'ĺ',
        laemptyv: '\u29B4',
        lagran: 'ℒ',
        Lambda: 'Λ',
        lambda: 'λ',
        Lang: '\u27EA',
        lang: '\u27E8',
        langd: '\u2991',
        langle: '\u27E8',
        lap: '\u2A85',
        Laplacetrf: 'ℒ',
        laquo: '\xAB',
        Larr: '\u219E',
        lArr: '\u21D0',
        larr: '\u2190',
        larrb: '\u21E4',
        larrbfs: '\u291F',
        larrfs: '\u291D',
        larrhk: '\u21A9',
        larrlp: '\u21AB',
        larrpl: '\u2939',
        larrsim: '\u2973',
        larrtl: '\u21A2',
        lat: '\u2AAB',
        lAtail: '\u291B',
        latail: '\u2919',
        late: '\u2AAD',
        lates: '\u2AAD︀',
        lBarr: '\u290E',
        lbarr: '\u290C',
        lbbrk: '\u2772',
        lbrace: '{',
        lbrack: '[',
        lbrke: '\u298B',
        lbrksld: '\u298F',
        lbrkslu: '\u298D',
        Lcaron: 'Ľ',
        lcaron: 'ľ',
        Lcedil: 'Ļ',
        lcedil: 'ļ',
        lceil: '\u2308',
        lcub: '{',
        Lcy: 'Л',
        lcy: 'л',
        ldca: '\u2936',
        ldquo: '\u201C',
        ldquor: '\u201E',
        ldrdhar: '\u2967',
        ldrushar: '\u294B',
        ldsh: '\u21B2',
        lE: '\u2266',
        le: '\u2264',
        LeftAngleBracket: '\u27E8',
        LeftArrow: '\u2190',
        Leftarrow: '\u21D0',
        leftarrow: '\u2190',
        LeftArrowBar: '\u21E4',
        LeftArrowRightArrow: '\u21C6',
        leftarrowtail: '\u21A2',
        LeftCeiling: '\u2308',
        LeftDoubleBracket: '\u27E6',
        LeftDownTeeVector: '\u2961',
        LeftDownVector: '\u21C3',
        LeftDownVectorBar: '\u2959',
        LeftFloor: '\u230A',
        leftharpoondown: '\u21BD',
        leftharpoonup: '\u21BC',
        leftleftarrows: '\u21C7',
        LeftRightArrow: '\u2194',
        Leftrightarrow: '\u21D4',
        leftrightarrow: '\u2194',
        leftrightarrows: '\u21C6',
        leftrightharpoons: '\u21CB',
        leftrightsquigarrow: '\u21AD',
        LeftRightVector: '\u294E',
        LeftTee: '\u22A3',
        LeftTeeArrow: '\u21A4',
        LeftTeeVector: '\u295A',
        leftthreetimes: '\u22CB',
        LeftTriangle: '\u22B2',
        LeftTriangleBar: '\u29CF',
        LeftTriangleEqual: '\u22B4',
        LeftUpDownVector: '\u2951',
        LeftUpTeeVector: '\u2960',
        LeftUpVector: '\u21BF',
        LeftUpVectorBar: '\u2958',
        LeftVector: '\u21BC',
        LeftVectorBar: '\u2952',
        lEg: '\u2A8B',
        leg: '\u22DA',
        leq: '\u2264',
        leqq: '\u2266',
        leqslant: '\u2A7D',
        les: '\u2A7D',
        lescc: '\u2AA8',
        lesdot: '\u2A7F',
        lesdoto: '\u2A81',
        lesdotor: '\u2A83',
        lesg: '\u22DA︀',
        lesges: '\u2A93',
        lessapprox: '\u2A85',
        lessdot: '\u22D6',
        lesseqgtr: '\u22DA',
        lesseqqgtr: '\u2A8B',
        LessEqualGreater: '\u22DA',
        LessFullEqual: '\u2266',
        LessGreater: '\u2276',
        lessgtr: '\u2276',
        LessLess: '\u2AA1',
        lesssim: '\u2272',
        LessSlantEqual: '\u2A7D',
        LessTilde: '\u2272',
        lfisht: '\u297C',
        lfloor: '\u230A',
        Lfr: '\uD835\uDD0F',
        lfr: '\uD835\uDD29',
        lg: '\u2276',
        lgE: '\u2A91',
        lHar: '\u2962',
        lhard: '\u21BD',
        lharu: '\u21BC',
        lharul: '\u296A',
        lhblk: '\u2584',
        LJcy: 'Љ',
        ljcy: 'љ',
        Ll: '\u22D8',
        ll: '\u226A',
        llarr: '\u21C7',
        llcorner: '\u231E',
        Lleftarrow: '\u21DA',
        llhard: '\u296B',
        lltri: '\u25FA',
        Lmidot: 'Ŀ',
        lmidot: 'ŀ',
        lmoust: '\u23B0',
        lmoustache: '\u23B0',
        lnap: '\u2A89',
        lnapprox: '\u2A89',
        lnE: '\u2268',
        lne: '\u2A87',
        lneq: '\u2A87',
        lneqq: '\u2268',
        lnsim: '\u22E6',
        loang: '\u27EC',
        loarr: '\u21FD',
        lobrk: '\u27E6',
        LongLeftArrow: '\u27F5',
        Longleftarrow: '\u27F8',
        longleftarrow: '\u27F5',
        LongLeftRightArrow: '\u27F7',
        Longleftrightarrow: '\u27FA',
        longleftrightarrow: '\u27F7',
        longmapsto: '\u27FC',
        LongRightArrow: '\u27F6',
        Longrightarrow: '\u27F9',
        longrightarrow: '\u27F6',
        looparrowleft: '\u21AB',
        looparrowright: '\u21AC',
        lopar: '\u2985',
        Lopf: '\uD835\uDD43',
        lopf: '\uD835\uDD5D',
        loplus: '\u2A2D',
        lotimes: '\u2A34',
        lowast: '\u2217',
        lowbar: '_',
        LowerLeftArrow: '\u2199',
        LowerRightArrow: '\u2198',
        loz: '\u25CA',
        lozenge: '\u25CA',
        lozf: '\u29EB',
        lpar: '(',
        lparlt: '\u2993',
        lrarr: '\u21C6',
        lrcorner: '\u231F',
        lrhar: '\u21CB',
        lrhard: '\u296D',
        lrm: '\u200E',
        lrtri: '\u22BF',
        lsaquo: '\u2039',
        Lscr: 'ℒ',
        lscr: '\uD835\uDCC1',
        Lsh: '\u21B0',
        lsh: '\u21B0',
        lsim: '\u2272',
        lsime: '\u2A8D',
        lsimg: '\u2A8F',
        lsqb: '[',
        lsquo: '\u2018',
        lsquor: '\u201A',
        Lstrok: 'Ł',
        lstrok: 'ł',
        LT: '<',
        Lt: '\u226A',
        lt: '<',
        ltcc: '\u2AA6',
        ltcir: '\u2A79',
        ltdot: '\u22D6',
        lthree: '\u22CB',
        ltimes: '\u22C9',
        ltlarr: '\u2976',
        ltquest: '\u2A7B',
        ltri: '\u25C3',
        ltrie: '\u22B4',
        ltrif: '\u25C2',
        ltrPar: '\u2996',
        lurdshar: '\u294A',
        luruhar: '\u2966',
        lvertneqq: '\u2268︀',
        lvnE: '\u2268︀',
        macr: '\xAF',
        male: '\u2642',
        malt: '\u2720',
        maltese: '\u2720',
        Map: '\u2905',
        map: '\u21A6',
        mapsto: '\u21A6',
        mapstodown: '\u21A7',
        mapstoleft: '\u21A4',
        mapstoup: '\u21A5',
        marker: '\u25AE',
        mcomma: '\u2A29',
        Mcy: 'М',
        mcy: 'м',
        mdash: '\u2014',
        mDDot: '\u223A',
        measuredangle: '\u2221',
        MediumSpace: '\u205F',
        Mellintrf: 'ℳ',
        Mfr: '\uD835\uDD10',
        mfr: '\uD835\uDD2A',
        mho: '\u2127',
        micro: 'µ',
        mid: '\u2223',
        midast: '*',
        midcir: '\u2AF0',
        middot: '\xB7',
        minus: '\u2212',
        minusb: '\u229F',
        minusd: '\u2238',
        minusdu: '\u2A2A',
        MinusPlus: '\u2213',
        mlcp: '\u2ADB',
        mldr: '\u2026',
        mnplus: '\u2213',
        models: '\u22A7',
        Mopf: '\uD835\uDD44',
        mopf: '\uD835\uDD5E',
        mp: '\u2213',
        Mscr: 'ℳ',
        mscr: '\uD835\uDCC2',
        mstpos: '\u223E',
        Mu: 'Μ',
        mu: 'μ',
        multimap: '\u22B8',
        mumap: '\u22B8',
        nabla: '\u2207',
        Nacute: 'Ń',
        nacute: 'ń',
        nang: '\u2220⃒',
        nap: '\u2249',
        napE: '\u2A70̸',
        napid: '\u224B̸',
        napos: 'ŉ',
        napprox: '\u2249',
        natur: '\u266E',
        natural: '\u266E',
        naturals: 'ℕ',
        nbsp: '\xA0',
        nbump: '\u224E̸',
        nbumpe: '\u224F̸',
        ncap: '\u2A43',
        Ncaron: 'Ň',
        ncaron: 'ň',
        Ncedil: 'Ņ',
        ncedil: 'ņ',
        ncong: '\u2247',
        ncongdot: '\u2A6D̸',
        ncup: '\u2A42',
        Ncy: 'Н',
        ncy: 'н',
        ndash: '\u2013',
        ne: '\u2260',
        nearhk: '\u2924',
        neArr: '\u21D7',
        nearr: '\u2197',
        nearrow: '\u2197',
        nedot: '\u2250̸',
        NegativeMediumSpace: '\u200B',
        NegativeThickSpace: '\u200B',
        NegativeThinSpace: '\u200B',
        NegativeVeryThinSpace: '\u200B',
        nequiv: '\u2262',
        nesear: '\u2928',
        nesim: '\u2242̸',
        NestedGreaterGreater: '\u226B',
        NestedLessLess: '\u226A',
        NewLine: '\n',
        nexist: '\u2204',
        nexists: '\u2204',
        Nfr: '\uD835\uDD11',
        nfr: '\uD835\uDD2B',
        ngE: '\u2267̸',
        nge: '\u2271',
        ngeq: '\u2271',
        ngeqq: '\u2267̸',
        ngeqslant: '\u2A7E̸',
        nges: '\u2A7E̸',
        nGg: '\u22D9̸',
        ngsim: '\u2275',
        nGt: '\u226B⃒',
        ngt: '\u226F',
        ngtr: '\u226F',
        nGtv: '\u226B̸',
        nhArr: '\u21CE',
        nharr: '\u21AE',
        nhpar: '\u2AF2',
        ni: '\u220B',
        nis: '\u22FC',
        nisd: '\u22FA',
        niv: '\u220B',
        NJcy: 'Њ',
        njcy: 'њ',
        nlArr: '\u21CD',
        nlarr: '\u219A',
        nldr: '\u2025',
        nlE: '\u2266̸',
        nle: '\u2270',
        nLeftarrow: '\u21CD',
        nleftarrow: '\u219A',
        nLeftrightarrow: '\u21CE',
        nleftrightarrow: '\u21AE',
        nleq: '\u2270',
        nleqq: '\u2266̸',
        nleqslant: '\u2A7D̸',
        nles: '\u2A7D̸',
        nless: '\u226E',
        nLl: '\u22D8̸',
        nlsim: '\u2274',
        nLt: '\u226A⃒',
        nlt: '\u226E',
        nltri: '\u22EA',
        nltrie: '\u22EC',
        nLtv: '\u226A̸',
        nmid: '\u2224',
        NoBreak: '\u2060',
        NonBreakingSpace: '\xA0',
        Nopf: 'ℕ',
        nopf: '\uD835\uDD5F',
        Not: '\u2AEC',
        not: '\xAC',
        NotCongruent: '\u2262',
        NotCupCap: '\u226D',
        NotDoubleVerticalBar: '\u2226',
        NotElement: '\u2209',
        NotEqual: '\u2260',
        NotEqualTilde: '\u2242̸',
        NotExists: '\u2204',
        NotGreater: '\u226F',
        NotGreaterEqual: '\u2271',
        NotGreaterFullEqual: '\u2267̸',
        NotGreaterGreater: '\u226B̸',
        NotGreaterLess: '\u2279',
        NotGreaterSlantEqual: '\u2A7E̸',
        NotGreaterTilde: '\u2275',
        NotHumpDownHump: '\u224E̸',
        NotHumpEqual: '\u224F̸',
        notin: '\u2209',
        notindot: '\u22F5̸',
        notinE: '\u22F9̸',
        notinva: '\u2209',
        notinvb: '\u22F7',
        notinvc: '\u22F6',
        NotLeftTriangle: '\u22EA',
        NotLeftTriangleBar: '\u29CF̸',
        NotLeftTriangleEqual: '\u22EC',
        NotLess: '\u226E',
        NotLessEqual: '\u2270',
        NotLessGreater: '\u2278',
        NotLessLess: '\u226A̸',
        NotLessSlantEqual: '\u2A7D̸',
        NotLessTilde: '\u2274',
        NotNestedGreaterGreater: '\u2AA2̸',
        NotNestedLessLess: '\u2AA1̸',
        notni: '\u220C',
        notniva: '\u220C',
        notnivb: '\u22FE',
        notnivc: '\u22FD',
        NotPrecedes: '\u2280',
        NotPrecedesEqual: '\u2AAF̸',
        NotPrecedesSlantEqual: '\u22E0',
        NotReverseElement: '\u220C',
        NotRightTriangle: '\u22EB',
        NotRightTriangleBar: '\u29D0̸',
        NotRightTriangleEqual: '\u22ED',
        NotSquareSubset: '\u228F̸',
        NotSquareSubsetEqual: '\u22E2',
        NotSquareSuperset: '\u2290̸',
        NotSquareSupersetEqual: '\u22E3',
        NotSubset: '\u2282⃒',
        NotSubsetEqual: '\u2288',
        NotSucceeds: '\u2281',
        NotSucceedsEqual: '\u2AB0̸',
        NotSucceedsSlantEqual: '\u22E1',
        NotSucceedsTilde: '\u227F̸',
        NotSuperset: '\u2283⃒',
        NotSupersetEqual: '\u2289',
        NotTilde: '\u2241',
        NotTildeEqual: '\u2244',
        NotTildeFullEqual: '\u2247',
        NotTildeTilde: '\u2249',
        NotVerticalBar: '\u2224',
        npar: '\u2226',
        nparallel: '\u2226',
        nparsl: '\u2AFD⃥',
        npart: '\u2202̸',
        npolint: '\u2A14',
        npr: '\u2280',
        nprcue: '\u22E0',
        npre: '\u2AAF̸',
        nprec: '\u2280',
        npreceq: '\u2AAF̸',
        nrArr: '\u21CF',
        nrarr: '\u219B',
        nrarrc: '\u2933̸',
        nrarrw: '\u219D̸',
        nRightarrow: '\u21CF',
        nrightarrow: '\u219B',
        nrtri: '\u22EB',
        nrtrie: '\u22ED',
        nsc: '\u2281',
        nsccue: '\u22E1',
        nsce: '\u2AB0̸',
        Nscr: '\uD835\uDCA9',
        nscr: '\uD835\uDCC3',
        nshortmid: '\u2224',
        nshortparallel: '\u2226',
        nsim: '\u2241',
        nsime: '\u2244',
        nsimeq: '\u2244',
        nsmid: '\u2224',
        nspar: '\u2226',
        nsqsube: '\u22E2',
        nsqsupe: '\u22E3',
        nsub: '\u2284',
        nsubE: '\u2AC5̸',
        nsube: '\u2288',
        nsubset: '\u2282⃒',
        nsubseteq: '\u2288',
        nsubseteqq: '\u2AC5̸',
        nsucc: '\u2281',
        nsucceq: '\u2AB0̸',
        nsup: '\u2285',
        nsupE: '\u2AC6̸',
        nsupe: '\u2289',
        nsupset: '\u2283⃒',
        nsupseteq: '\u2289',
        nsupseteqq: '\u2AC6̸',
        ntgl: '\u2279',
        Ntilde: 'Ñ',
        ntilde: 'ñ',
        ntlg: '\u2278',
        ntriangleleft: '\u22EA',
        ntrianglelefteq: '\u22EC',
        ntriangleright: '\u22EB',
        ntrianglerighteq: '\u22ED',
        Nu: 'Ν',
        nu: 'ν',
        num: '#',
        numero: '\u2116',
        numsp: '\u2007',
        nvap: '\u224D⃒',
        nVDash: '\u22AF',
        nVdash: '\u22AE',
        nvDash: '\u22AD',
        nvdash: '\u22AC',
        nvge: '\u2265⃒',
        nvgt: '>⃒',
        nvHarr: '\u2904',
        nvinfin: '\u29DE',
        nvlArr: '\u2902',
        nvle: '\u2264⃒',
        nvlt: '<⃒',
        nvltrie: '\u22B4⃒',
        nvrArr: '\u2903',
        nvrtrie: '\u22B5⃒',
        nvsim: '\u223C⃒',
        nwarhk: '\u2923',
        nwArr: '\u21D6',
        nwarr: '\u2196',
        nwarrow: '\u2196',
        nwnear: '\u2927',
        Oacute: 'Ó',
        oacute: 'ó',
        oast: '\u229B',
        ocir: '\u229A',
        Ocirc: 'Ô',
        ocirc: 'ô',
        Ocy: 'О',
        ocy: 'о',
        odash: '\u229D',
        Odblac: 'Ő',
        odblac: 'ő',
        odiv: '\u2A38',
        odot: '\u2299',
        odsold: '\u29BC',
        OElig: 'Œ',
        oelig: 'œ',
        ofcir: '\u29BF',
        Ofr: '\uD835\uDD12',
        ofr: '\uD835\uDD2C',
        ogon: '\u02DB',
        Ograve: 'Ò',
        ograve: 'ò',
        ogt: '\u29C1',
        ohbar: '\u29B5',
        ohm: 'Ω',
        oint: '\u222E',
        olarr: '\u21BA',
        olcir: '\u29BE',
        olcross: '\u29BB',
        oline: '\u203E',
        olt: '\u29C0',
        Omacr: 'Ō',
        omacr: 'ō',
        Omega: 'Ω',
        omega: 'ω',
        Omicron: 'Ο',
        omicron: 'ο',
        omid: '\u29B6',
        ominus: '\u2296',
        Oopf: '\uD835\uDD46',
        oopf: '\uD835\uDD60',
        opar: '\u29B7',
        OpenCurlyDoubleQuote: '\u201C',
        OpenCurlyQuote: '\u2018',
        operp: '\u29B9',
        oplus: '\u2295',
        Or: '\u2A54',
        or: '\u2228',
        orarr: '\u21BB',
        ord: '\u2A5D',
        order: 'ℴ',
        orderof: 'ℴ',
        ordf: 'ª',
        ordm: 'º',
        origof: '\u22B6',
        oror: '\u2A56',
        orslope: '\u2A57',
        orv: '\u2A5B',
        oS: '\u24C8',
        Oscr: '\uD835\uDCAA',
        oscr: 'ℴ',
        Oslash: 'Ø',
        oslash: 'ø',
        osol: '\u2298',
        Otilde: 'Õ',
        otilde: 'õ',
        Otimes: '\u2A37',
        otimes: '\u2297',
        otimesas: '\u2A36',
        Ouml: 'Ö',
        ouml: 'ö',
        ovbar: '\u233D',
        OverBar: '\u203E',
        OverBrace: '\u23DE',
        OverBracket: '\u23B4',
        OverParenthesis: '\u23DC',
        par: '\u2225',
        para: '\xB6',
        parallel: '\u2225',
        parsim: '\u2AF3',
        parsl: '\u2AFD',
        part: '\u2202',
        PartialD: '\u2202',
        Pcy: 'П',
        pcy: 'п',
        percnt: '%',
        period: '.',
        permil: '\u2030',
        perp: '\u22A5',
        pertenk: '\u2031',
        Pfr: '\uD835\uDD13',
        pfr: '\uD835\uDD2D',
        Phi: 'Φ',
        phi: 'φ',
        phiv: 'ϕ',
        phmmat: 'ℳ',
        phone: '\u260E',
        Pi: 'Π',
        pi: 'π',
        pitchfork: '\u22D4',
        piv: 'ϖ',
        planck: 'ℏ',
        planckh: 'ℎ',
        plankv: 'ℏ',
        plus: '+',
        plusacir: '\u2A23',
        plusb: '\u229E',
        pluscir: '\u2A22',
        plusdo: '\u2214',
        plusdu: '\u2A25',
        pluse: '\u2A72',
        PlusMinus: '\xB1',
        plusmn: '\xB1',
        plussim: '\u2A26',
        plustwo: '\u2A27',
        pm: '\xB1',
        Poincareplane: 'ℌ',
        pointint: '\u2A15',
        Popf: 'ℙ',
        popf: '\uD835\uDD61',
        pound: '\xA3',
        Pr: '\u2ABB',
        pr: '\u227A',
        prap: '\u2AB7',
        prcue: '\u227C',
        prE: '\u2AB3',
        pre: '\u2AAF',
        prec: '\u227A',
        precapprox: '\u2AB7',
        preccurlyeq: '\u227C',
        Precedes: '\u227A',
        PrecedesEqual: '\u2AAF',
        PrecedesSlantEqual: '\u227C',
        PrecedesTilde: '\u227E',
        preceq: '\u2AAF',
        precnapprox: '\u2AB9',
        precneqq: '\u2AB5',
        precnsim: '\u22E8',
        precsim: '\u227E',
        Prime: '\u2033',
        prime: '\u2032',
        primes: 'ℙ',
        prnap: '\u2AB9',
        prnE: '\u2AB5',
        prnsim: '\u22E8',
        prod: '\u220F',
        Product: '\u220F',
        profalar: '\u232E',
        profline: '\u2312',
        profsurf: '\u2313',
        prop: '\u221D',
        Proportion: '\u2237',
        Proportional: '\u221D',
        propto: '\u221D',
        prsim: '\u227E',
        prurel: '\u22B0',
        Pscr: '\uD835\uDCAB',
        pscr: '\uD835\uDCC5',
        Psi: 'Ψ',
        psi: 'ψ',
        puncsp: '\u2008',
        Qfr: '\uD835\uDD14',
        qfr: '\uD835\uDD2E',
        qint: '\u2A0C',
        Qopf: 'ℚ',
        qopf: '\uD835\uDD62',
        qprime: '\u2057',
        Qscr: '\uD835\uDCAC',
        qscr: '\uD835\uDCC6',
        quaternions: 'ℍ',
        quatint: '\u2A16',
        quest: '?',
        questeq: '\u225F',
        QUOT: '"',
        quot: '"',
        rAarr: '\u21DB',
        race: '\u223Ḏ',
        Racute: 'Ŕ',
        racute: 'ŕ',
        radic: '\u221A',
        raemptyv: '\u29B3',
        Rang: '\u27EB',
        rang: '\u27E9',
        rangd: '\u2992',
        range: '\u29A5',
        rangle: '\u27E9',
        raquo: '\xBB',
        Rarr: '\u21A0',
        rArr: '\u21D2',
        rarr: '\u2192',
        rarrap: '\u2975',
        rarrb: '\u21E5',
        rarrbfs: '\u2920',
        rarrc: '\u2933',
        rarrfs: '\u291E',
        rarrhk: '\u21AA',
        rarrlp: '\u21AC',
        rarrpl: '\u2945',
        rarrsim: '\u2974',
        Rarrtl: '\u2916',
        rarrtl: '\u21A3',
        rarrw: '\u219D',
        rAtail: '\u291C',
        ratail: '\u291A',
        ratio: '\u2236',
        rationals: 'ℚ',
        RBarr: '\u2910',
        rBarr: '\u290F',
        rbarr: '\u290D',
        rbbrk: '\u2773',
        rbrace: '}',
        rbrack: ']',
        rbrke: '\u298C',
        rbrksld: '\u298E',
        rbrkslu: '\u2990',
        Rcaron: 'Ř',
        rcaron: 'ř',
        Rcedil: 'Ŗ',
        rcedil: 'ŗ',
        rceil: '\u2309',
        rcub: '}',
        Rcy: 'Р',
        rcy: 'р',
        rdca: '\u2937',
        rdldhar: '\u2969',
        rdquo: '\u201D',
        rdquor: '\u201D',
        rdsh: '\u21B3',
        Re: 'ℜ',
        real: 'ℜ',
        realine: 'ℛ',
        realpart: 'ℜ',
        reals: 'ℝ',
        rect: '\u25AD',
        REG: '\xAE',
        reg: '\xAE',
        ReverseElement: '\u220B',
        ReverseEquilibrium: '\u21CB',
        ReverseUpEquilibrium: '\u296F',
        rfisht: '\u297D',
        rfloor: '\u230B',
        Rfr: 'ℜ',
        rfr: '\uD835\uDD2F',
        rHar: '\u2964',
        rhard: '\u21C1',
        rharu: '\u21C0',
        rharul: '\u296C',
        Rho: 'Ρ',
        rho: 'ρ',
        rhov: 'ϱ',
        RightAngleBracket: '\u27E9',
        RightArrow: '\u2192',
        Rightarrow: '\u21D2',
        rightarrow: '\u2192',
        RightArrowBar: '\u21E5',
        RightArrowLeftArrow: '\u21C4',
        rightarrowtail: '\u21A3',
        RightCeiling: '\u2309',
        RightDoubleBracket: '\u27E7',
        RightDownTeeVector: '\u295D',
        RightDownVector: '\u21C2',
        RightDownVectorBar: '\u2955',
        RightFloor: '\u230B',
        rightharpoondown: '\u21C1',
        rightharpoonup: '\u21C0',
        rightleftarrows: '\u21C4',
        rightleftharpoons: '\u21CC',
        rightrightarrows: '\u21C9',
        rightsquigarrow: '\u219D',
        RightTee: '\u22A2',
        RightTeeArrow: '\u21A6',
        RightTeeVector: '\u295B',
        rightthreetimes: '\u22CC',
        RightTriangle: '\u22B3',
        RightTriangleBar: '\u29D0',
        RightTriangleEqual: '\u22B5',
        RightUpDownVector: '\u294F',
        RightUpTeeVector: '\u295C',
        RightUpVector: '\u21BE',
        RightUpVectorBar: '\u2954',
        RightVector: '\u21C0',
        RightVectorBar: '\u2953',
        ring: '\u02DA',
        risingdotseq: '\u2253',
        rlarr: '\u21C4',
        rlhar: '\u21CC',
        rlm: '\u200F',
        rmoust: '\u23B1',
        rmoustache: '\u23B1',
        rnmid: '\u2AEE',
        roang: '\u27ED',
        roarr: '\u21FE',
        robrk: '\u27E7',
        ropar: '\u2986',
        Ropf: 'ℝ',
        ropf: '\uD835\uDD63',
        roplus: '\u2A2E',
        rotimes: '\u2A35',
        RoundImplies: '\u2970',
        rpar: ')',
        rpargt: '\u2994',
        rppolint: '\u2A12',
        rrarr: '\u21C9',
        Rrightarrow: '\u21DB',
        rsaquo: '\u203A',
        Rscr: 'ℛ',
        rscr: '\uD835\uDCC7',
        Rsh: '\u21B1',
        rsh: '\u21B1',
        rsqb: ']',
        rsquo: '\u2019',
        rsquor: '\u2019',
        rthree: '\u22CC',
        rtimes: '\u22CA',
        rtri: '\u25B9',
        rtrie: '\u22B5',
        rtrif: '\u25B8',
        rtriltri: '\u29CE',
        RuleDelayed: '\u29F4',
        ruluhar: '\u2968',
        rx: '\u211E',
        Sacute: 'Ś',
        sacute: 'ś',
        sbquo: '\u201A',
        Sc: '\u2ABC',
        sc: '\u227B',
        scap: '\u2AB8',
        Scaron: 'Š',
        scaron: 'š',
        sccue: '\u227D',
        scE: '\u2AB4',
        sce: '\u2AB0',
        Scedil: 'Ş',
        scedil: 'ş',
        Scirc: 'Ŝ',
        scirc: 'ŝ',
        scnap: '\u2ABA',
        scnE: '\u2AB6',
        scnsim: '\u22E9',
        scpolint: '\u2A13',
        scsim: '\u227F',
        Scy: 'С',
        scy: 'с',
        sdot: '\u22C5',
        sdotb: '\u22A1',
        sdote: '\u2A66',
        searhk: '\u2925',
        seArr: '\u21D8',
        searr: '\u2198',
        searrow: '\u2198',
        sect: '\xA7',
        semi: ';',
        seswar: '\u2929',
        setminus: '\u2216',
        setmn: '\u2216',
        sext: '\u2736',
        Sfr: '\uD835\uDD16',
        sfr: '\uD835\uDD30',
        sfrown: '\u2322',
        sharp: '\u266F',
        SHCHcy: 'Щ',
        shchcy: 'щ',
        SHcy: 'Ш',
        shcy: 'ш',
        ShortDownArrow: '\u2193',
        ShortLeftArrow: '\u2190',
        shortmid: '\u2223',
        shortparallel: '\u2225',
        ShortRightArrow: '\u2192',
        ShortUpArrow: '\u2191',
        shy: '\xAD',
        Sigma: 'Σ',
        sigma: 'σ',
        sigmaf: 'ς',
        sigmav: 'ς',
        sim: '\u223C',
        simdot: '\u2A6A',
        sime: '\u2243',
        simeq: '\u2243',
        simg: '\u2A9E',
        simgE: '\u2AA0',
        siml: '\u2A9D',
        simlE: '\u2A9F',
        simne: '\u2246',
        simplus: '\u2A24',
        simrarr: '\u2972',
        slarr: '\u2190',
        SmallCircle: '\u2218',
        smallsetminus: '\u2216',
        smashp: '\u2A33',
        smeparsl: '\u29E4',
        smid: '\u2223',
        smile: '\u2323',
        smt: '\u2AAA',
        smte: '\u2AAC',
        smtes: '\u2AAC︀',
        SOFTcy: 'Ь',
        softcy: 'ь',
        sol: '/',
        solb: '\u29C4',
        solbar: '\u233F',
        Sopf: '\uD835\uDD4A',
        sopf: '\uD835\uDD64',
        spades: '\u2660',
        spadesuit: '\u2660',
        spar: '\u2225',
        sqcap: '\u2293',
        sqcaps: '\u2293︀',
        sqcup: '\u2294',
        sqcups: '\u2294︀',
        Sqrt: '\u221A',
        sqsub: '\u228F',
        sqsube: '\u2291',
        sqsubset: '\u228F',
        sqsubseteq: '\u2291',
        sqsup: '\u2290',
        sqsupe: '\u2292',
        sqsupset: '\u2290',
        sqsupseteq: '\u2292',
        squ: '\u25A1',
        Square: '\u25A1',
        square: '\u25A1',
        SquareIntersection: '\u2293',
        SquareSubset: '\u228F',
        SquareSubsetEqual: '\u2291',
        SquareSuperset: '\u2290',
        SquareSupersetEqual: '\u2292',
        SquareUnion: '\u2294',
        squarf: '\u25AA',
        squf: '\u25AA',
        srarr: '\u2192',
        Sscr: '\uD835\uDCAE',
        sscr: '\uD835\uDCC8',
        ssetmn: '\u2216',
        ssmile: '\u2323',
        sstarf: '\u22C6',
        Star: '\u22C6',
        star: '\u2606',
        starf: '\u2605',
        straightepsilon: 'ϵ',
        straightphi: 'ϕ',
        strns: '\xAF',
        Sub: '\u22D0',
        sub: '\u2282',
        subdot: '\u2ABD',
        subE: '\u2AC5',
        sube: '\u2286',
        subedot: '\u2AC3',
        submult: '\u2AC1',
        subnE: '\u2ACB',
        subne: '\u228A',
        subplus: '\u2ABF',
        subrarr: '\u2979',
        Subset: '\u22D0',
        subset: '\u2282',
        subseteq: '\u2286',
        subseteqq: '\u2AC5',
        SubsetEqual: '\u2286',
        subsetneq: '\u228A',
        subsetneqq: '\u2ACB',
        subsim: '\u2AC7',
        subsub: '\u2AD5',
        subsup: '\u2AD3',
        succ: '\u227B',
        succapprox: '\u2AB8',
        succcurlyeq: '\u227D',
        Succeeds: '\u227B',
        SucceedsEqual: '\u2AB0',
        SucceedsSlantEqual: '\u227D',
        SucceedsTilde: '\u227F',
        succeq: '\u2AB0',
        succnapprox: '\u2ABA',
        succneqq: '\u2AB6',
        succnsim: '\u22E9',
        succsim: '\u227F',
        SuchThat: '\u220B',
        Sum: '\u2211',
        sum: '\u2211',
        sung: '\u266A',
        Sup: '\u22D1',
        sup: '\u2283',
        sup1: '\xB9',
        sup2: '\xB2',
        sup3: '\xB3',
        supdot: '\u2ABE',
        supdsub: '\u2AD8',
        supE: '\u2AC6',
        supe: '\u2287',
        supedot: '\u2AC4',
        Superset: '\u2283',
        SupersetEqual: '\u2287',
        suphsol: '\u27C9',
        suphsub: '\u2AD7',
        suplarr: '\u297B',
        supmult: '\u2AC2',
        supnE: '\u2ACC',
        supne: '\u228B',
        supplus: '\u2AC0',
        Supset: '\u22D1',
        supset: '\u2283',
        supseteq: '\u2287',
        supseteqq: '\u2AC6',
        supsetneq: '\u228B',
        supsetneqq: '\u2ACC',
        supsim: '\u2AC8',
        supsub: '\u2AD4',
        supsup: '\u2AD6',
        swarhk: '\u2926',
        swArr: '\u21D9',
        swarr: '\u2199',
        swarrow: '\u2199',
        swnwar: '\u292A',
        szlig: 'ß',
        Tab: '\t',
        target: '\u2316',
        Tau: 'Τ',
        tau: 'τ',
        tbrk: '\u23B4',
        Tcaron: 'Ť',
        tcaron: 'ť',
        Tcedil: 'Ţ',
        tcedil: 'ţ',
        Tcy: 'Т',
        tcy: 'т',
        tdot: '⃛',
        telrec: '\u2315',
        Tfr: '\uD835\uDD17',
        tfr: '\uD835\uDD31',
        there4: '\u2234',
        Therefore: '\u2234',
        therefore: '\u2234',
        Theta: 'Θ',
        theta: 'θ',
        thetasym: 'ϑ',
        thetav: 'ϑ',
        thickapprox: '\u2248',
        thicksim: '\u223C',
        ThickSpace: '\u205F\u200A',
        thinsp: '\u2009',
        ThinSpace: '\u2009',
        thkap: '\u2248',
        thksim: '\u223C',
        THORN: 'Þ',
        thorn: 'þ',
        Tilde: '\u223C',
        tilde: '\u02DC',
        TildeEqual: '\u2243',
        TildeFullEqual: '\u2245',
        TildeTilde: '\u2248',
        times: '\xD7',
        timesb: '\u22A0',
        timesbar: '\u2A31',
        timesd: '\u2A30',
        tint: '\u222D',
        toea: '\u2928',
        top: '\u22A4',
        topbot: '\u2336',
        topcir: '\u2AF1',
        Topf: '\uD835\uDD4B',
        topf: '\uD835\uDD65',
        topfork: '\u2ADA',
        tosa: '\u2929',
        tprime: '\u2034',
        TRADE: '\u2122',
        trade: '\u2122',
        triangle: '\u25B5',
        triangledown: '\u25BF',
        triangleleft: '\u25C3',
        trianglelefteq: '\u22B4',
        triangleq: '\u225C',
        triangleright: '\u25B9',
        trianglerighteq: '\u22B5',
        tridot: '\u25EC',
        trie: '\u225C',
        triminus: '\u2A3A',
        TripleDot: '⃛',
        triplus: '\u2A39',
        trisb: '\u29CD',
        tritime: '\u2A3B',
        trpezium: '\u23E2',
        Tscr: '\uD835\uDCAF',
        tscr: '\uD835\uDCC9',
        TScy: 'Ц',
        tscy: 'ц',
        TSHcy: 'Ћ',
        tshcy: 'ћ',
        Tstrok: 'Ŧ',
        tstrok: 'ŧ',
        twixt: '\u226C',
        twoheadleftarrow: '\u219E',
        twoheadrightarrow: '\u21A0',
        Uacute: 'Ú',
        uacute: 'ú',
        Uarr: '\u219F',
        uArr: '\u21D1',
        uarr: '\u2191',
        Uarrocir: '\u2949',
        Ubrcy: 'Ў',
        ubrcy: 'ў',
        Ubreve: 'Ŭ',
        ubreve: 'ŭ',
        Ucirc: 'Û',
        ucirc: 'û',
        Ucy: 'У',
        ucy: 'у',
        udarr: '\u21C5',
        Udblac: 'Ű',
        udblac: 'ű',
        udhar: '\u296E',
        ufisht: '\u297E',
        Ufr: '\uD835\uDD18',
        ufr: '\uD835\uDD32',
        Ugrave: 'Ù',
        ugrave: 'ù',
        uHar: '\u2963',
        uharl: '\u21BF',
        uharr: '\u21BE',
        uhblk: '\u2580',
        ulcorn: '\u231C',
        ulcorner: '\u231C',
        ulcrop: '\u230F',
        ultri: '\u25F8',
        Umacr: 'Ū',
        umacr: 'ū',
        uml: '\xA8',
        UnderBar: '_',
        UnderBrace: '\u23DF',
        UnderBracket: '\u23B5',
        UnderParenthesis: '\u23DD',
        Union: '\u22C3',
        UnionPlus: '\u228E',
        Uogon: 'Ų',
        uogon: 'ų',
        Uopf: '\uD835\uDD4C',
        uopf: '\uD835\uDD66',
        UpArrow: '\u2191',
        Uparrow: '\u21D1',
        uparrow: '\u2191',
        UpArrowBar: '\u2912',
        UpArrowDownArrow: '\u21C5',
        UpDownArrow: '\u2195',
        Updownarrow: '\u21D5',
        updownarrow: '\u2195',
        UpEquilibrium: '\u296E',
        upharpoonleft: '\u21BF',
        upharpoonright: '\u21BE',
        uplus: '\u228E',
        UpperLeftArrow: '\u2196',
        UpperRightArrow: '\u2197',
        Upsi: 'ϒ',
        upsi: 'υ',
        upsih: 'ϒ',
        Upsilon: 'Υ',
        upsilon: 'υ',
        UpTee: '\u22A5',
        UpTeeArrow: '\u21A5',
        upuparrows: '\u21C8',
        urcorn: '\u231D',
        urcorner: '\u231D',
        urcrop: '\u230E',
        Uring: 'Ů',
        uring: 'ů',
        urtri: '\u25F9',
        Uscr: '\uD835\uDCB0',
        uscr: '\uD835\uDCCA',
        utdot: '\u22F0',
        Utilde: 'Ũ',
        utilde: 'ũ',
        utri: '\u25B5',
        utrif: '\u25B4',
        uuarr: '\u21C8',
        Uuml: 'Ü',
        uuml: 'ü',
        uwangle: '\u29A7',
        vangrt: '\u299C',
        varepsilon: 'ϵ',
        varkappa: 'ϰ',
        varnothing: '\u2205',
        varphi: 'ϕ',
        varpi: 'ϖ',
        varpropto: '\u221D',
        vArr: '\u21D5',
        varr: '\u2195',
        varrho: 'ϱ',
        varsigma: 'ς',
        varsubsetneq: '\u228A︀',
        varsubsetneqq: '\u2ACB︀',
        varsupsetneq: '\u228B︀',
        varsupsetneqq: '\u2ACC︀',
        vartheta: 'ϑ',
        vartriangleleft: '\u22B2',
        vartriangleright: '\u22B3',
        Vbar: '\u2AEB',
        vBar: '\u2AE8',
        vBarv: '\u2AE9',
        Vcy: 'В',
        vcy: 'в',
        VDash: '\u22AB',
        Vdash: '\u22A9',
        vDash: '\u22A8',
        vdash: '\u22A2',
        Vdashl: '\u2AE6',
        Vee: '\u22C1',
        vee: '\u2228',
        veebar: '\u22BB',
        veeeq: '\u225A',
        vellip: '\u22EE',
        Verbar: '\u2016',
        verbar: '|',
        Vert: '\u2016',
        vert: '|',
        VerticalBar: '\u2223',
        VerticalLine: '|',
        VerticalSeparator: '\u2758',
        VerticalTilde: '\u2240',
        VeryThinSpace: '\u200A',
        Vfr: '\uD835\uDD19',
        vfr: '\uD835\uDD33',
        vltri: '\u22B2',
        vnsub: '\u2282⃒',
        vnsup: '\u2283⃒',
        Vopf: '\uD835\uDD4D',
        vopf: '\uD835\uDD67',
        vprop: '\u221D',
        vrtri: '\u22B3',
        Vscr: '\uD835\uDCB1',
        vscr: '\uD835\uDCCB',
        vsubnE: '\u2ACB︀',
        vsubne: '\u228A︀',
        vsupnE: '\u2ACC︀',
        vsupne: '\u228B︀',
        Vvdash: '\u22AA',
        vzigzag: '\u299A',
        Wcirc: 'Ŵ',
        wcirc: 'ŵ',
        wedbar: '\u2A5F',
        Wedge: '\u22C0',
        wedge: '\u2227',
        wedgeq: '\u2259',
        weierp: '\u2118',
        Wfr: '\uD835\uDD1A',
        wfr: '\uD835\uDD34',
        Wopf: '\uD835\uDD4E',
        wopf: '\uD835\uDD68',
        wp: '\u2118',
        wr: '\u2240',
        wreath: '\u2240',
        Wscr: '\uD835\uDCB2',
        wscr: '\uD835\uDCCC',
        xcap: '\u22C2',
        xcirc: '\u25EF',
        xcup: '\u22C3',
        xdtri: '\u25BD',
        Xfr: '\uD835\uDD1B',
        xfr: '\uD835\uDD35',
        xhArr: '\u27FA',
        xharr: '\u27F7',
        Xi: 'Ξ',
        xi: 'ξ',
        xlArr: '\u27F8',
        xlarr: '\u27F5',
        xmap: '\u27FC',
        xnis: '\u22FB',
        xodot: '\u2A00',
        Xopf: '\uD835\uDD4F',
        xopf: '\uD835\uDD69',
        xoplus: '\u2A01',
        xotime: '\u2A02',
        xrArr: '\u27F9',
        xrarr: '\u27F6',
        Xscr: '\uD835\uDCB3',
        xscr: '\uD835\uDCCD',
        xsqcup: '\u2A06',
        xuplus: '\u2A04',
        xutri: '\u25B3',
        xvee: '\u22C1',
        xwedge: '\u22C0',
        Yacute: 'Ý',
        yacute: 'ý',
        YAcy: 'Я',
        yacy: 'я',
        Ycirc: 'Ŷ',
        ycirc: 'ŷ',
        Ycy: 'Ы',
        ycy: 'ы',
        yen: '\xA5',
        Yfr: '\uD835\uDD1C',
        yfr: '\uD835\uDD36',
        YIcy: 'Ї',
        yicy: 'ї',
        Yopf: '\uD835\uDD50',
        yopf: '\uD835\uDD6A',
        Yscr: '\uD835\uDCB4',
        yscr: '\uD835\uDCCE',
        YUcy: 'Ю',
        yucy: 'ю',
        Yuml: 'Ÿ',
        yuml: 'ÿ',
        Zacute: 'Ź',
        zacute: 'ź',
        Zcaron: 'Ž',
        zcaron: 'ž',
        Zcy: 'З',
        zcy: 'з',
        Zdot: 'Ż',
        zdot: 'ż',
        zeetrf: 'ℨ',
        ZeroWidthSpace: '\u200B',
        Zeta: 'Ζ',
        zeta: 'ζ',
        Zfr: 'ℨ',
        zfr: '\uD835\uDD37',
        ZHcy: 'Ж',
        zhcy: 'ж',
        zigrarr: '\u21DD',
        Zopf: 'ℤ',
        zopf: '\uD835\uDD6B',
        Zscr: '\uD835\uDCB5',
        zscr: '\uD835\uDCCF',
        zwj: '‍',
        zwnj: '‌'
    };
});
/*simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/tokenize*/
define('simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/tokenize', [
    'exports',
    './tokenizer',
    './entity-parser',
    './html5-named-char-refs'
], function (exports, _tokenizer, _entityParser, _html5NamedCharRefs) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.default = tokenize;
    var _tokenizer2 = _interopRequireDefault(_tokenizer);
    var _entityParser2 = _interopRequireDefault(_entityParser);
    var _html5NamedCharRefs2 = _interopRequireDefault(_html5NamedCharRefs);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    function tokenize(input, options) {
        var tokenizer = new _tokenizer2.default(new _entityParser2.default(_html5NamedCharRefs2.default), options);
        return tokenizer.tokenize(input);
    }
});
/*can-simple-dom@1.3.0#simple-dom/default-tokenize*/
define('can-simple-dom@1.3.0#simple-dom/default-tokenize', [
    'exports',
    'simple-html-tokenizer/lib/simple-html-tokenizer/tokenize'
], function (exports, _tokenize) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.default = function (input) {
        return (0, _tokenize2.default)(input);
    };
    var _tokenize2 = _interopRequireDefault(_tokenize);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    ;
});
/*can-simple-dom@1.3.0#test/element-sp-test*/
define('can-simple-dom@1.3.0#test/element-sp-test', [
    'can-simple-dom',
    'steal-qunit',
    'can-simple-dom/simple-dom/html-parser',
    'can-simple-dom/simple-dom/void-map',
    'can-simple-dom/simple-dom/html-serializer',
    'can-simple-dom/simple-dom/default-tokenize'
], function (_canSimpleDom, _stealQunit, _htmlParser, _voidMap, _htmlSerializer, _defaultTokenize) {
    'use strict';
    var _stealQunit2 = _interopRequireDefault(_stealQunit);
    var _htmlParser2 = _interopRequireDefault(_htmlParser);
    var _voidMap2 = _interopRequireDefault(_voidMap);
    var _htmlSerializer2 = _interopRequireDefault(_htmlSerializer);
    var _defaultTokenize2 = _interopRequireDefault(_defaultTokenize);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    _stealQunit2.default.module('can-simple-dom - Element with serialization and parsing');
    _stealQunit2.default.test('document.implementation is supported (#23)', function () {
        var document = new _canSimpleDom.Document();
        document.__addSerializerAndParser(new _htmlSerializer2.default(_voidMap2.default), new _htmlParser2.default(_defaultTokenize2.default, document, _voidMap2.default));
        ok(document.implementation, 'implementation exists');
        var doc2 = document.implementation.createHTMLDocument('');
        ok(doc2.body, 'has a body');
    });
    _stealQunit2.default.test('innerHTML supported', function () {
        var document = new _canSimpleDom.Document();
        document.__addSerializerAndParser(new _htmlSerializer2.default(_voidMap2.default), new _htmlParser2.default(_defaultTokenize2.default, document, _voidMap2.default));
        document.body.innerHTML = '<span class=\'bar\'>HI</span>';
        _stealQunit2.default.equal(document.body.firstChild.nodeName, 'SPAN');
        _stealQunit2.default.equal(document.body.firstChild.className, 'bar');
        _stealQunit2.default.equal(document.body.firstChild.firstChild.nodeValue, 'HI');
        _stealQunit2.default.equal(document.body.innerHTML, '<span class="bar">HI</span>');
    });
    _stealQunit2.default.test('outerHTML supported', function () {
        var document = new _canSimpleDom.Document();
        document.__addSerializerAndParser(new _htmlSerializer2.default(_voidMap2.default), new _htmlParser2.default(_defaultTokenize2.default, document, _voidMap2.default));
        document.body.innerHTML = '<span/><div id=\'item\'>HI</div><span/>';
        var item = document.getElementById('item');
        _stealQunit2.default.equal(item.outerHTML, '<div id="item">HI</div>', 'getter');
        item.outerHTML = '<label>IT</label>';
        _stealQunit2.default.equal(document.body.innerHTML, '<span></span><label>IT</label><span></span>', 'setter');
    });
});
/*can-simple-dom@1.3.0#test/element-event-test*/
define('can-simple-dom@1.3.0#test/element-event-test', [
    'can-simple-dom/simple-dom/document',
    'can-simple-dom/simple-dom/html-serializer',
    'can-simple-dom/simple-dom/void-map',
    './support',
    'steal-qunit'
], function (_document, _htmlSerializer, _voidMap, _support, _stealQunit) {
    'use strict';
    var _document2 = _interopRequireDefault(_document);
    var _htmlSerializer2 = _interopRequireDefault(_htmlSerializer);
    var _voidMap2 = _interopRequireDefault(_voidMap);
    var _stealQunit2 = _interopRequireDefault(_stealQunit);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    _stealQunit2.default.module('can-simple-dom - Event');
    _stealQunit2.default.test('basic bubbling', 4, function (assert) {
        var document = new _document2.default();
        var elem = document.createElement('div');
        document.body.appendChild(elem);
        document.addEventListener('foo', function (event) {
            assert.strictEqual(event.currentTarget, document, 'document current target');
        });
        document.documentElement.addEventListener('foo', function (event) {
            assert.strictEqual(event.currentTarget, document.documentElement, 'documentElement current target');
        });
        document.body.addEventListener('foo', function (event) {
            assert.strictEqual(event.currentTarget, document.body, 'body current target');
        });
        elem.addEventListener('foo', function (event) {
            assert.strictEqual(event.currentTarget, elem, 'elem current target');
        });
        document.body.appendChild(elem);
        var ev = document.createEvent('HTMLEvents');
        ev.initEvent('foo', true, false);
        elem.dispatchEvent(ev);
    });
    _stealQunit2.default.test('stop propagation', 2, function (assert) {
        var document = new _document2.default();
        var elem = document.createElement('div');
        document.body.appendChild(elem);
        document.addEventListener('foo', function (event) {
            assert.strictEqual(event.currentTarget, document, 'document current target');
        });
        document.documentElement.addEventListener('foo', function (event) {
            assert.strictEqual(event.currentTarget, document.documentElement, 'documentElement current target');
        });
        document.body.addEventListener('foo', function (event) {
            assert.strictEqual(event.currentTarget, document.body, 'body current target');
            event.stopPropagation();
        });
        elem.addEventListener('foo', function (event) {
            assert.strictEqual(event.currentTarget, elem, 'elem current target');
        });
        document.body.appendChild(elem);
        var ev = document.createEvent('HTMLEvents');
        ev.initEvent('foo', true, false);
        elem.dispatchEvent(ev);
    });
    _stealQunit2.default.test('initEvent without bubbling', 2, function (assert) {
        var document = new _document2.default();
        var elem = document.createElement('div');
        document.body.appendChild(elem);
        document.body.addEventListener('foo', function (event) {
            assert.strictEqual(event.currentTarget, document.body, 'body current target');
            event.stopPropagation();
        });
        elem.addEventListener('foo', function (event) {
            assert.strictEqual(event.currentTarget, elem, 'elem current target');
        });
        elem.addEventListener('foo', function (event) {
            assert.strictEqual(event.currentTarget, elem, 'elem current target');
        });
        document.body.appendChild(elem);
        var ev = document.createEvent('HTMLEvents');
        ev.initEvent('foo', false, false);
        elem.dispatchEvent(ev);
    });
    _stealQunit2.default.test('this inside event handler', function (assert) {
        var document = new _document2.default();
        var elem = document.createElement('div');
        document.body.appendChild(elem);
        elem.addEventListener('foo', function () {
            assert.equal(this, elem, 'this is the element');
        });
        var ev = document.createEvent('HTMLEvents');
        ev.initEvent('foo', true, false);
        elem.dispatchEvent(ev);
    });
});
/*can-simple-dom@1.3.0#test/parser-test*/
define('can-simple-dom@1.3.0#test/parser-test', [
    './support',
    'can-simple-dom/simple-dom/html-parser',
    'can-simple-dom/simple-dom/void-map',
    'can-simple-dom/simple-dom/default-tokenize',
    'steal-qunit'
], function (_support, _htmlParser, _voidMap, _defaultTokenize, _stealQunit) {
    'use strict';
    var _htmlParser2 = _interopRequireDefault(_htmlParser);
    var _voidMap2 = _interopRequireDefault(_voidMap);
    var _defaultTokenize2 = _interopRequireDefault(_defaultTokenize);
    var _stealQunit2 = _interopRequireDefault(_stealQunit);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    _stealQunit2.default.module('can-simple-dom - Basic HTML parsing', {
        beforeEach: function beforeEach() {
            this.parser = new _htmlParser2.default(_defaultTokenize2.default, _support.document, _voidMap2.default);
        }
    });
    _stealQunit2.default.test('simple parse', function (assert) {
        var fragment = this.parser.parse('<div>Hello</div>');
        assert.ok(fragment);
        var node = fragment.firstChild;
        assert.ok(node);
        assert.equal(node.nodeType, 1);
        assert.equal(node.nodeName.toLowerCase(), 'div');
        assert.ok(node.firstChild);
        assert.equal(node.firstChild.nodeType, 3);
        assert.equal(node.firstChild.nodeValue, 'Hello');
    });
    _stealQunit2.default.test('nested parse', function (assert) {
        var fragment = this.parser.parse('text before<div>Hello</div>text between<div id=foo title="Hello World">World</div>text after');
        assert.ok(fragment);
        var node = fragment.firstChild;
        assert.ok(node);
        assert.equal(node.nodeType, 3);
        assert.equal(node.nodeValue, 'text before');
        node = node.nextSibling;
        assert.ok(node);
        assert.equal(node.nodeType, 1);
        assert.equal(node.nodeName, 'DIV');
        assert.ok(node.firstChild);
        assert.equal(node.firstChild.nodeType, 3);
        assert.equal(node.firstChild.nodeValue, 'Hello');
        node = node.nextSibling;
        assert.ok(node);
        assert.equal(node.nodeType, 3);
        assert.equal(node.nodeValue, 'text between');
        node = node.nextSibling;
        assert.ok(node);
        assert.equal(node.nodeType, 1);
        assert.equal(node.nodeName, 'DIV');
        var expectedValues = {
            id: 'foo',
            title: 'Hello World'
        };
        assert.equal(node.attributes.length, 2);
        assert.equal(node.attributes[0].value, expectedValues[node.attributes[0].name]);
        assert.equal(node.attributes[1].value, expectedValues[node.attributes[1].name]);
        assert.equal(node.attributes.length, 2);
        assert.ok(node.firstChild);
        assert.equal(node.firstChild.nodeType, 3);
        assert.equal(node.firstChild.nodeValue, 'World');
        node = node.nextSibling;
        assert.ok(node);
        assert.equal(node.nodeType, 3);
        assert.equal(node.nodeValue, 'text after');
    });
    _stealQunit2.default.test('void tags', function (assert) {
        var fragment = this.parser.parse('<div>Hello<br>World<img src="http://example.com/image.png?foo=bar&bar=foo"></div>');
        assert.ok(fragment);
        var node = fragment.firstChild;
        assert.ok(node);
        assert.equal(node.nodeType, 1);
        assert.equal(node.nodeName, 'DIV');
        node = node.firstChild;
        assert.ok(node);
        assert.equal(node.nodeType, 3);
        assert.equal(node.nodeValue, 'Hello');
        node = node.nextSibling;
        assert.ok(node);
        assert.equal(node.nodeType, 1);
        assert.equal(node.nodeName, 'BR');
        node = node.nextSibling;
        assert.ok(node);
        assert.equal(node.nodeType, 3);
        assert.equal(node.nodeValue, 'World');
        node = node.nextSibling;
        assert.ok(node);
        assert.equal(node.nodeType, 1);
        assert.equal(node.nodeName, 'IMG');
        assert.equal(node.getAttribute('src'), 'http://example.com/image.png?foo=bar&bar=foo');
        assert.equal(node.nextSibling, null);
    });
    _stealQunit2.default.test('node attribute charater encode', function (assert) {
        var fragment = this.parser.parse('<div title="&nbsp;foo & bar &amp; baz < buz > biz"></div>');
        assert.ok(fragment);
        var node = fragment.firstChild;
        assert.ok(node);
        assert.equal(node.nodeType, 1);
        assert.equal(node.nodeName, 'DIV');
        var attibutes = node.attributes;
        assert.ok(attibutes.length);
        var title = attibutes[0];
        assert.equal(title.name, 'title');
        assert.equal(title.value, '&#xA0;foo &#x26; bar &#x26; baz &#x3C; buz &#x3E; biz');
    });
});
/*can-simple-dom@1.3.0#test/style-test*/
define('can-simple-dom@1.3.0#test/style-test', [
    'steal-qunit',
    'can-simple-dom/simple-dom/document/style'
], function (_stealQunit, _style) {
    'use strict';
    var _stealQunit2 = _interopRequireDefault(_stealQunit);
    var _style2 = _interopRequireDefault(_style);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
        return typeof obj;
    } : function (obj) {
        return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
    };
    _stealQunit2.default.module('can-simple-dom - CSStyleDeclaration');
    _stealQunit2.default.test('cssText is enumerable', function () {
        var proto = _style2.default.prototype;
        var descriptor = Object.getOwnPropertyDescriptor(proto, 'cssText');
        _stealQunit2.default.equal(descriptor.enumerable, true, 'it is enumerable');
    });
    _stealQunit2.default.test('cssText is configurable', function () {
        var proto = _style2.default.prototype;
        var descriptor = Object.getOwnPropertyDescriptor(proto, 'cssText');
        _stealQunit2.default.equal(descriptor.configurable, true, 'it is configurable');
    });
    _stealQunit2.default.test('getPropertyValue must be a function', function () {
        var proto = _style2.default.prototype;
        _stealQunit2.default.equal(_typeof(proto.getPropertyValue), 'function', 'it is a function');
    });
});
/*can-simple-dom@1.3.0#test/test*/
define('can-simple-dom@1.3.0#test/test', [
    './element-test',
    './serializer-test',
    './element-sp-test',
    './element-event-test',
    './parser-test',
    './style-test'
], function () {
    'use strict';
});
/*can-simple-observable@2.0.0-pre.16#settable/settable-test*/
define('can-simple-observable@2.0.0-pre.16#settable/settable-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    './settable',
    '../can-simple-observable',
    'can-reflect'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var SettableObservable = require('./settable');
    var SimpleObservable = require('../can-simple-observable');
    var canReflect = require('can-reflect');
    QUnit.module('can-simple-observable/settable');
    QUnit.test('basics', function () {
        var value = new SimpleObservable(2);
        var obs = new SettableObservable(function (lastSet) {
            return lastSet * value.get();
        }, null, 1);
        QUnit.equal(canReflect.getValue(obs), 2, 'getValue unbound');
        var changes = 0;
        var handler = function (newValue) {
            changes++;
            if (changes === 1) {
                QUnit.equal(newValue, 4, 'set observable');
                obs.set(3);
            } else if (changes === 2) {
                QUnit.equal(newValue, 6, 'set observable in handler');
                value.set(3);
            } else {
                QUnit.equal(newValue, 9, 'set source');
            }
        };
        canReflect.onValue(obs, handler);
        canReflect.setValue(obs, 2);
        QUnit.equal(canReflect.getValue(obs), 9, 'after bound');
        canReflect.offValue(obs, handler);
        canReflect.setValue(obs, 5);
        QUnit.equal(canReflect.getValue(obs), 15, 'after unbound');
    });
    QUnit.test('get and set Priority', function () {
        var value = new SimpleObservable(2);
        var obs = new SettableObservable(function (lastSet) {
            return lastSet * value.get();
        }, null, 1);
        canReflect.setPriority(obs, 5);
        QUnit.equal(canReflect.getPriority(obs), 5, 'set priority');
    });
    if (System.env.indexOf('production') < 0) {
        QUnit.test('log observable changes', function (assert) {
            var done = assert.async();
            var obs = new SettableObservable(function (lastSet) {
                return lastSet * 5;
            }, null, 1);
            obs.log();
            var changes = [];
            obs._log = function (previous, current) {
                changes.push({
                    current: current,
                    previous: previous
                });
            };
            canReflect.onValue(obs, function () {
            });
            canReflect.setValue(obs, 2);
            canReflect.setValue(obs, 3);
            assert.expect(1);
            setTimeout(function () {
                assert.deepEqual(changes, [
                    {
                        current: 10,
                        previous: 5
                    },
                    {
                        current: 15,
                        previous: 10
                    }
                ], 'should print out current/previous values');
                done();
            });
        });
    }
    QUnit.test('getValueDependencies', function (assert) {
        var value = new SimpleObservable(2);
        var obs = new SettableObservable(function (lastSet) {
            return lastSet * value.get();
        }, null, 1);
        assert.equal(typeof canReflect.getValueDependencies(obs), 'undefined', 'returns undefined when the observable is unbound');
        canReflect.onValue(obs, function () {
        });
        assert.deepEqual(canReflect.getValueDependencies(obs).valueDependencies, new Set([
            obs.lastSetValue,
            value
        ]), 'should return the internal observation dependencies');
    });
});
/*can-simple-observable@2.0.0-pre.16#async/async-test*/
define('can-simple-observable@2.0.0-pre.16#async/async-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    './async',
    '../can-simple-observable',
    'can-reflect',
    'can-observation-recorder'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var AsyncObservable = require('./async');
    var SimpleObservable = require('../can-simple-observable');
    var canReflect = require('can-reflect');
    var ObservationRecorder = require('can-observation-recorder');
    QUnit.module('can-simple-observable/async');
    QUnit.test('basics', function (assert) {
        var done = assert.async();
        var value = new SimpleObservable(1);
        var obs = new AsyncObservable(function (lastSet, resolve) {
            if (!resolve) {
                return 'default';
            }
            if (value.get() === 1) {
                setTimeout(function () {
                    resolve('a');
                }, 1);
            } else {
                setTimeout(function () {
                    resolve('b');
                }, 1);
            }
        });
        QUnit.equal(canReflect.getValue(obs), 'default', 'getValue unbound');
        ObservationRecorder.start();
        QUnit.equal(canReflect.getValue(obs), undefined, 'getValue being bound');
        var dependencies = ObservationRecorder.stop();
        QUnit.ok(!dependencies.valueDependencies.has(value), 'did not record value');
        QUnit.ok(dependencies.valueDependencies.has(obs), 'did record observable');
        QUnit.equal(dependencies.valueDependencies.size, 1, 'only one value to listen to');
        var changes = 0;
        var handler = function (newValue) {
            changes++;
            if (changes === 1) {
                QUnit.equal(newValue, 'a', 'onValue a');
                value.set(2);
            } else {
                QUnit.equal(newValue, 'b', 'onValue b');
                done();
            }
        };
        canReflect.onValue(obs, handler);
    });
    QUnit.test('get and set Priority', function () {
        var value = new SimpleObservable(1);
        var obs = new AsyncObservable(function (lastSet, resolve) {
            if (!resolve) {
                return 'default';
            }
            if (value.get() === 1) {
                setTimeout(function () {
                    resolve('a');
                }, 1);
            } else {
                setTimeout(function () {
                    resolve('b');
                }, 1);
            }
        });
        canReflect.setPriority(obs, 5);
        QUnit.equal(canReflect.getPriority(obs), 5, 'set priority');
    });
    QUnit.test('prevent a getter returning undefined from overwriting last resolved value', function () {
        var value = new SimpleObservable(1);
        var obs = new AsyncObservable(function (lastSet, resolve) {
            if (value.get() === 1) {
                return null;
            } else {
                resolve(4);
            }
        });
        obs.on(function () {
        });
        QUnit.equal(obs.get(), null);
        value.set(2);
        QUnit.equal(obs.get(), 4);
    });
    QUnit.test('prevent a getter returning undefined from overwriting last resolved value at the start', function () {
        var value = new SimpleObservable(1);
        var obs = new AsyncObservable(function (lastSet, resolve) {
            resolve(value.get() * 2);
        });
        obs.on(function () {
        });
        QUnit.equal(obs.get(), 2);
        value.set(2);
        QUnit.equal(obs.get(), 4);
    });
    if (System.env.indexOf('production') < 0) {
        QUnit.test('log async observable changes', function (assert) {
            var done = assert.async();
            var value = new SimpleObservable(1);
            var obs = new AsyncObservable(function (lastSet, resolve) {
                if (value.get() === 1) {
                    setTimeout(function () {
                        resolve('b');
                    }, 1);
                } else {
                    setTimeout(function () {
                        resolve('c');
                    }, 1);
                }
            }, null, 'a');
            obs.log();
            var changes = [];
            obs._log = function (previous, current) {
                changes.push({
                    previous: previous,
                    current: current
                });
            };
            canReflect.onValue(obs, function () {
            });
            value.set('2');
            assert.expect(1);
            setTimeout(function () {
                assert.deepEqual(changes, [
                    {
                        current: 'b',
                        previous: undefined
                    },
                    {
                        current: 'c',
                        previous: 'b'
                    }
                ]);
                done();
            }, 10);
        });
    }
    QUnit.test('getValueDependencies', function (assert) {
        var value = new SimpleObservable(1);
        var obs = new AsyncObservable(function (lastSet, resolve) {
            return value.get() === 1 ? lastSet : resolve(4);
        });
        assert.equal(typeof canReflect.getValueDependencies(obs), 'undefined', 'should be undefined when observable is unbound');
        canReflect.onValue(obs, function () {
        });
        assert.deepEqual(canReflect.getValueDependencies(obs).valueDependencies, new Set([
            obs.lastSetValue,
            value
        ]));
    });
});
/*can-simple-observable@2.0.0-pre.16#setter/setter-test*/
define('can-simple-observable@2.0.0-pre.16#setter/setter-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    './setter',
    '../can-simple-observable',
    'can-reflect'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var SetterObservable = require('./setter');
    var SimpleObservable = require('../can-simple-observable');
    var canReflect = require('can-reflect');
    QUnit.module('can-simple-observable/setter');
    QUnit.test('basics', function (assert) {
        var value = new SimpleObservable(2);
        var obs = new SetterObservable(function () {
            return value.get();
        }, function (newVal) {
            value.set(newVal);
        });
        assert.equal(canReflect.getValue(obs), 2, 'getValue unbound');
        canReflect.setValue(obs, 3);
        assert.equal(canReflect.getValue(value), 3, 'value set');
        assert.equal(canReflect.getValue(obs), 3, 'getValue unbound');
    });
    QUnit.test('get and set Priority', function (assert) {
        var value = new SimpleObservable(2);
        var obs = new SetterObservable(function () {
            return value.get();
        }, function (newVal) {
            value.set(newVal);
        });
        canReflect.setPriority(obs, 5);
        assert.equal(canReflect.getPriority(obs), 5, 'set priority');
    });
    if (System.env.indexOf('production') < 0) {
        QUnit.test('log observable changes', function (assert) {
            var done = assert.async();
            var value = new SimpleObservable(2);
            var obs = new SetterObservable(function () {
                return value.get();
            }, function (newVal) {
                value.set(newVal);
            });
            obs.log();
            var changes = [];
            obs._log = function (previous, current) {
                changes.push({
                    current: current,
                    previous: previous
                });
            };
            canReflect.onValue(obs, function () {
            });
            canReflect.setValue(obs, 3);
            canReflect.setValue(obs, 4);
            assert.expect(1);
            setTimeout(function () {
                assert.deepEqual(changes, [
                    {
                        current: 3,
                        previous: 2
                    },
                    {
                        current: 4,
                        previous: 3
                    }
                ], 'should print out current/previous values');
                done();
            });
        });
    }
    QUnit.test('getValueDependencies', function (assert) {
        var value = new SimpleObservable(2);
        var obs = new SetterObservable(function () {
            return value.get();
        }, function (newVal) {
            value.set(newVal);
        });
        assert.equal(typeof canReflect.getValueDependencies(obs), 'undefined', 'should be undefined when observable is unbound');
        canReflect.onValue(obs, function () {
        });
        assert.deepEqual(canReflect.getValueDependencies(obs).valueDependencies, new Set([value]));
    });
});
/*can-simple-observable@2.0.0-pre.16#can-simple-observable-test*/
define('can-simple-observable@2.0.0-pre.16#can-simple-observable-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-simple-observable',
    'can-reflect',
    'can-observation-recorder',
    './settable/settable-test',
    './async/async-test',
    './setter/setter-test'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var SimpleObservable = require('can-simple-observable');
    var canReflect = require('can-reflect');
    var ObservationRecorder = require('can-observation-recorder');
    require('./settable/settable-test');
    require('./async/async-test');
    require('./setter/setter-test');
    QUnit.module('can-simple-observable');
    QUnit.test('basics', function () {
        expect(5);
        var obs = new SimpleObservable('one');
        QUnit.equal(canReflect.getValue(obs), 'one', 'getValue');
        canReflect.setValue(obs, 'two');
        ObservationRecorder.start();
        QUnit.equal(canReflect.getValue(obs), 'two', 'setValue');
        var dependencies = ObservationRecorder.stop();
        QUnit.ok(dependencies.valueDependencies.has(obs), 'was recorded');
        var handler = function (newValue) {
            QUnit.equal(newValue, 'three', 'onValue');
        };
        canReflect.onValue(obs, handler);
        canReflect.setValue(obs, 'three');
        canReflect.offValue(obs, handler);
        canReflect.setValue(obs, 'four');
        QUnit.equal(canReflect.getValue(obs), 'four', 'getValue after offValue');
    });
    if (System.env.indexOf('production') < 0) {
        QUnit.test('log observable changes', function (assert) {
            var done = assert.async();
            var obs = new SimpleObservable('one');
            obs.log();
            assert.expect(2);
            obs._log = function (previous, current) {
                assert.equal(current, 'two', 'should get current value');
                assert.equal(previous, 'one', 'should get previous value');
                done();
            };
            canReflect.setValue(obs, 'two');
        });
    }
});
/*can-stache-key@1.0.0-pre.8#can-stache-key-test*/
define('can-stache-key@1.0.0-pre.8#can-stache-key-test', [
    'require',
    'exports',
    'module',
    'can-stache-key',
    'steal-qunit',
    'can-observation',
    'can-event-queue',
    'can-util/js/dev/dev',
    'can-simple-observable',
    'can-simple-map',
    'can-reflect'
], function (require, exports, module) {
    var observeReader = require('can-stache-key');
    var QUnit = require('steal-qunit');
    var Observation = require('can-observation');
    var eventQueue = require('can-event-queue');
    var dev = require('can-util/js/dev/dev');
    var SimpleObservable = require('can-simple-observable');
    var SimpleMap = require('can-simple-map');
    var canReflect = require('can-reflect');
    QUnit.module('can-stache-key', {});
    test('can read a promise (#179)', function () {
        var data = {
            promise: new Promise(function (resolve) {
                setTimeout(function () {
                    resolve('Something');
                }, 2);
            })
        };
        var calls = 0;
        var c = new Observation(function () {
            return observeReader.read(data, observeReader.reads('promise.value')).value;
        });
        canReflect.onValue(c, function (newVal, oldVal) {
            calls++;
            equal(calls, 1, 'only one call');
            equal(newVal, 'Something', 'new value');
            equal(oldVal, undefined, 'oldVal');
            start();
        });
        stop();
    });
    test('can.Compute.read can read a promise-like (#82)', function () {
        var data = {
            promiseLike: {
                then: function (resolve) {
                    setTimeout(function () {
                        resolve('Something');
                    }, 2);
                }
            }
        };
        var calls = 0;
        var c = new Observation(function () {
            return observeReader.read(data, observeReader.reads('promiseLike.value')).value;
        });
        canReflect.onValue(c, function (newVal, oldVal) {
            calls++;
            equal(calls, 1, 'only one call');
            equal(newVal, 'Something', 'new value');
            equal(oldVal, undefined, 'oldVal');
            start();
        });
        stop();
    });
    test('can.compute.reads', function () {
        deepEqual(observeReader.reads('@foo'), [{
                key: 'foo',
                at: true
            }]);
        deepEqual(observeReader.reads('@foo.bar'), [
            {
                key: 'foo',
                at: true
            },
            {
                key: 'bar',
                at: false
            }
        ]);
        deepEqual(observeReader.reads('@foo\\.bar'), [{
                key: 'foo.bar',
                at: true
            }]);
        deepEqual(observeReader.reads('foo.bar@zed'), [
            {
                key: 'foo',
                at: false
            },
            {
                key: 'bar',
                at: false
            },
            {
                key: 'zed',
                at: true
            }
        ]);
    });
    test('able to read things like can-define', 3, function () {
        var obj = eventQueue({});
        var prop = 'PROP';
        Object.defineProperty(obj, 'prop', {
            get: function () {
                Observation.add(obj, 'prop');
                return prop;
            },
            set: function (val) {
                var old = prop;
                prop = val;
                this.dispatch('prop', prop, old);
            }
        });
        var data = { obj: obj };
        var c = new Observation(function () {
            var value = observeReader.read(data, observeReader.reads('obj.prop'), {
                foundObservable: function (obs, index) {
                    equal(obs, obj, 'got an observable');
                    equal(index, 1, 'got the right index');
                }
            }).value;
            equal(value, 'PROP');
        });
        canReflect.onValue(c, function () {
        });
    });
    test('foundObservable called with observable object (#7)', function () {
        var map = {
            isSaving: function () {
                Observation.add(this, '_saving');
            },
            addEventListener: function () {
            }
        };
        var c = new Observation(function () {
            observeReader.read(map, observeReader.reads('isSaving'), {
                foundObservable: function (obs) {
                    QUnit.equal(obs, map);
                }
            });
        });
        canReflect.onValue(c, function () {
        });
    });
    test('can read from strings', function () {
        var context = ' hi there ';
        var result = observeReader.read(context, observeReader.reads('trim'), {});
        QUnit.ok(result, context.trim);
    });
    test('read / write to DefineMap', function () {
        var map = new SimpleMap();
        var c = new Observation(function () {
            var data = observeReader.read(map, observeReader.reads('value'), {
                foundObservable: function (obs) {
                    QUnit.equal(obs, map, 'got map');
                }
            });
            return data.value;
        });
        canReflect.onValue(c, function (newVal) {
            QUnit.equal(newVal, 1, 'got updated');
        });
        observeReader.write(map, 'value', 1);
    });
    test('write deep in DefineMap', function () {
        var map = new SimpleMap();
        observeReader.write(map, 'foo', new SimpleMap());
        observeReader.write(map, 'foo.bar', 1);
        QUnit.equal(map.get('foo').get('bar'), 1, 'value set');
    });
    test('write to compute in object', function () {
        var value = 2;
        var computeObject = {};
        canReflect.assignSymbols(computeObject, {
            'can.getValue': function () {
                return value;
            },
            'can.setValue': function (newVal) {
                value = newVal;
            }
        });
        var obj = { compute: computeObject };
        observeReader.write(obj, 'compute', 3);
        QUnit.equal(value, 3, 'value set');
    });
    test('write to a map in a compute', function () {
        var map = new SimpleMap({ complete: true });
        var computeObject = {};
        canReflect.assignSymbols(computeObject, {
            'can.getValue': function () {
                return map;
            },
            'can.setValue': function (newVal) {
                map = newVal;
            }
        });
        observeReader.write(computeObject, 'complete', false);
        QUnit.equal(map.attr('complete'), false, 'value set');
    });
    if (System.env.indexOf('production') < 0) {
        test('promise readers throw errors (#70)', function () {
            expect(1);
            var oldError = dev.error;
            dev.error = function () {
                dev.error = oldError;
                ok(true);
                start();
            };
            var promise = new Promise(function (resolve, reject) {
                setTimeout(function () {
                    reject('Something');
                }, 0);
            });
            var c = new Observation(function () {
                return observeReader.read(promise, observeReader.reads('value'), {}).value;
            }, null, {
                updater: function () {
                }
            });
            c.start();
            stop();
        });
    }
    QUnit.test('reads can be passed a number (can-stache#207)', function () {
        var reads = observeReader.reads(0);
        QUnit.deepEqual(reads, [{
                key: '0',
                at: false
            }], 'number converted to string');
    });
    QUnit.test('can read primitive numbers (#88)', function () {
        var reads = observeReader.reads('num@toFixed');
        var toFixed = observeReader.read({ num: 5 }, reads, {}).value;
        QUnit.equal(typeof toFixed, 'function', 'got to fixed');
    });
    test('it returns null when promise getter is null #2', function () {
        var nullPromise = observeReader.read(null, observeReader.reads('value'));
        QUnit.equal(typeof nullPromise, 'object');
    });
    QUnit.test('set onto observable objects and values', function () {
        var map = new SimpleMap();
        observeReader.write({ map: map }, 'map', { a: 'b' });
        QUnit.equal(map.get('a'), 'b', 'merged');
        var simple = new SimpleObservable();
        observeReader.write({ simple: simple }, 'simple', 1);
        QUnit.equal(simple.get(), 1);
    });
});
/*can-symbol@1.4.1#can-symbol-test*/
define('can-symbol@1.4.1#can-symbol-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-symbol'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var canSymbol = require('can-symbol');
    QUnit.module('can-symbol');
    QUnit.test('for and keyFor', function () {
        var symbol = canSymbol.for('abc');
        QUnit.ok(canSymbol.for('abc') === canSymbol.for('abc'));
        QUnit.equal(canSymbol.keyFor(symbol), 'abc', 'key for');
    });
    QUnit.test('can get/set symbols', function () {
        var obj = {};
        var symbol1 = canSymbol('prop1'), symbol2 = canSymbol('prop2');
        obj[symbol1] = 'VALUE';
        QUnit.equal(obj[symbol1], 'VALUE', 'got value');
        Object.defineProperty(obj, symbol2, { value: 'DP-VALUE' });
        QUnit.equal(obj[symbol2], 'DP-VALUE', 'got define property value');
    });
});
/*can-test-helpers@1.1.0#can-test-helpers*/
define('can-test-helpers@1.1.0#can-test-helpers', [
    'require',
    'exports',
    'module',
    'can-test-helpers/lib/dev'
], function (require, exports, module) {
    var dev = require('can-test-helpers/lib/dev');
    module.exports = { dev: dev };
});
/*can-view-live@4.0.0-pre.11#test/html-test*/
define('can-view-live@4.0.0-pre.11#test/html-test', [
    'require',
    'exports',
    'module',
    'can-view-live',
    'can-define/list/list',
    'can-observation',
    'steal-qunit',
    'can-simple-observable',
    'can-view-nodelist',
    'can-test-helpers'
], function (require, exports, module) {
    var live = require('can-view-live');
    var DefineList = require('can-define/list/list');
    var Observation = require('can-observation');
    var QUnit = require('steal-qunit');
    var SimpleObservable = require('can-simple-observable');
    var NodeLists = require('can-view-nodelist');
    var testHelpers = require('can-test-helpers');
    QUnit.module('can-view-live.html');
    test('basics', function () {
        var div = document.createElement('div'), span = document.createElement('span');
        div.appendChild(span);
        var items = new DefineList([
            'one',
            'two'
        ]);
        var html = new Observation(function itemsHTML() {
            var html = '';
            items.forEach(function (item) {
                html += '<label>' + item + '</label>';
            });
            return html;
        });
        live.html(span, html, div);
        equal(div.getElementsByTagName('label').length, 2);
        items.push('three');
        equal(div.getElementsByTagName('label').length, 3);
    });
    test('html live binding handles getting a function from a compute', 5, function () {
        var handler = function (el) {
            ok(true, 'called handler');
            equal(el.nodeType, 3, 'got a placeholder');
        };
        var div = document.createElement('div'), placeholder = document.createTextNode('');
        div.appendChild(placeholder);
        var count = new SimpleObservable(0);
        var html = new Observation(function () {
            if (count.get() === 0) {
                return '<h1>Hello World</h1>';
            } else {
                return handler;
            }
        });
        live.html(placeholder, html, div);
        equal(div.getElementsByTagName('h1').length, 1, 'got h1');
        count.set(1);
        equal(div.getElementsByTagName('h1').length, 0, 'got h1');
        count.set(0);
        equal(div.getElementsByTagName('h1').length, 1, 'got h1');
    });
    QUnit.test('Works with Observations - .html', function () {
        var div = document.createElement('div'), span = document.createElement('span');
        div.appendChild(span);
        var items = new DefineList([
            'one',
            'two'
        ]);
        var html = new Observation(function () {
            var html = '';
            items.each(function (item) {
                html += '<label>' + item + '</label>';
            });
            return html;
        });
        live.html(span, html, div);
        equal(div.getElementsByTagName('label').length, 2);
        items.push('three');
        equal(div.getElementsByTagName('label').length, 3);
    });
    testHelpers.dev.devOnlyTest('child elements must disconnect before parents can re-evaluate', 1, function () {
        var observable = new SimpleObservable('value');
        var childObservation = new Observation(function child() {
            QUnit.ok(true, 'called child content once');
            observable.get();
            return 'CHILD CONTENT';
        }, null, { priority: 1 });
        var htmlNodeList = [];
        var parentObservation = new Observation(function parent() {
            var result = observable.get();
            if (result === 'value') {
                var childTextNode = document.createTextNode('');
                var childFrag = document.createDocumentFragment();
                childFrag.appendChild(childTextNode);
                var nodeList = [childTextNode];
                NodeLists.register(nodeList, null, htmlNodeList, true);
                live.html(childTextNode, childObservation, null, nodeList);
                return childFrag;
            } else {
                return 'NEW CONTENT';
            }
        }, null, { priority: 0 });
        var parentTextNode = document.createTextNode('');
        var div = document.createElement('div');
        div.appendChild(parentTextNode);
        htmlNodeList.push(parentTextNode);
        NodeLists.register(htmlNodeList, function () {
        }, true, true);
        live.html(parentTextNode, parentObservation, div, htmlNodeList);
        observable.set('VALUE');
    });
});
/*can-view-live@4.0.0-pre.11#test/patcher-test*/
define('can-view-live@4.0.0-pre.11#test/patcher-test', [
    'require',
    'exports',
    'module',
    'can-define/list/list',
    'steal-qunit',
    'can-symbol',
    '../lib/patcher'
], function (require, exports, module) {
    var DefineList = require('can-define/list/list');
    var QUnit = require('steal-qunit');
    var canSymbol = require('can-symbol');
    var Patcher = require('../lib/patcher');
    QUnit.module('can-view-live patcher', {
        setup: function () {
            this.fixture = document.getElementById('qunit-fixture');
        }
    });
    QUnit.test('multiple lists can be updated at once', 2, function () {
        var list = new DefineList([
            'a',
            'b'
        ]);
        var p1 = new Patcher(list), p2 = new Patcher(list);
        p1[canSymbol.for('can.onPatches')](function () {
            QUnit.ok(true, 'called p1');
        });
        p2[canSymbol.for('can.onPatches')](function () {
            QUnit.ok(true, 'called p2');
        });
        list.push('c');
    });
});
/*can-view-live@4.0.0-pre.11#test/list-test*/
define('can-view-live@4.0.0-pre.11#test/list-test', [
    'require',
    'exports',
    'module',
    'can-view-live',
    'can-define/list/list',
    'can-observation',
    'steal-qunit',
    'can-simple-observable',
    'can-simple-map',
    'can-reflect',
    'can-queues',
    'can-util/dom/fragment/fragment',
    'can-view-nodelist',
    'can-util/dom/mutate/mutate',
    'can-symbol',
    'can-util/dom/events/events',
    'can-test-helpers'
], function (require, exports, module) {
    var live = require('can-view-live');
    var DefineList = require('can-define/list/list');
    var Observation = require('can-observation');
    var QUnit = require('steal-qunit');
    var SimpleObservable = require('can-simple-observable');
    var SimpleMap = require('can-simple-map');
    var canReflect = require('can-reflect');
    var queues = require('can-queues');
    var fragment = require('can-util/dom/fragment/fragment');
    var NodeLists = require('can-view-nodelist');
    var domMutate = require('can-util/dom/mutate/mutate');
    var canSymbol = require('can-symbol');
    var domEvents = require('can-util/dom/events/events');
    var testHelpers = require('can-test-helpers');
    QUnit.module('can-view-live.list', {
        setup: function () {
            this.fixture = document.getElementById('qunit-fixture');
        }
    });
    QUnit.test('basics', function () {
        var div = document.createElement('div'), list = new DefineList([
                'sloth',
                'bear'
            ]), template = function (animal) {
                return '<label>Animal=</label> <span>' + animal.get() + '</span>';
            };
        div.innerHTML = 'my <b>fav</b> animals: <span></span> !';
        var el = div.getElementsByTagName('span')[0];
        live.list(el, list, template, {});
        equal(div.getElementsByTagName('label').length, 2, 'There are 2 labels');
        div.getElementsByTagName('label')[0].myexpando = 'EXPANDO-ED';
        list.push('turtle');
        equal(div.getElementsByTagName('label')[0].myexpando, 'EXPANDO-ED', 'same expando');
        equal(div.getElementsByTagName('span')[2].innerHTML, 'turtle', 'turtle added');
    });
    QUnit.test('list within an Observation', 5, function () {
        var div = document.createElement('div'), map = new SimpleMap({
                animals: new DefineList([
                    'bear',
                    'turtle'
                ])
            }), template = function (animal) {
                return '<label>Animal=</label> <span>' + animal.get() + '</span>';
            };
        var listCompute = new Observation(function animalsFromMap() {
            return map.attr('animals');
        });
        div.innerHTML = 'my <b>fav</b> animals: <span></span> !';
        var el = div.getElementsByTagName('span')[0];
        live.list(el, listCompute, template, {});
        equal(div.getElementsByTagName('label').length, 2, 'There are 2 labels');
        div.getElementsByTagName('label')[0].myexpando = 'EXPANDO-ED';
        map.attr('animals').push('turtle');
        equal(div.getElementsByTagName('label')[0].myexpando, 'EXPANDO-ED', 'same expando');
        equal(div.getElementsByTagName('span')[2].innerHTML, 'turtle', 'turtle added');
        map.attr('animals', new DefineList([
            'sloth',
            'bear',
            'turtle'
        ]));
        var spans = div.getElementsByTagName('span');
        equal(spans.length, 3, 'there are 3 spans');
        ok(!div.getElementsByTagName('label')[0].myexpando, 'no expando');
    });
    QUnit.test('.list within a observable value holding an Array list', function () {
        var div = document.createElement('div');
        var template = function (num) {
            return '<label>num=</label> <span>' + num + '</span>';
        };
        var arr = new SimpleObservable([
            0,
            1
        ]);
        div.innerHTML = 'my <b>fav</b> nums: <span></span> !';
        var el = div.getElementsByTagName('span')[0];
        live.list(el, arr, template, {});
        equal(div.getElementsByTagName('label').length, 2, 'There are 2 labels');
        arr.set([
            0,
            1,
            2
        ]);
        var spans = div.getElementsByTagName('span');
        equal(spans.length, 3, 'there are 3 spans');
    });
    test('live.list should handle move patches', function (assert) {
        var parent = document.createElement('div');
        var child = document.createElement('div');
        parent.appendChild(child);
        var onPatchesHandler;
        var list = [
            'a',
            'b',
            'c'
        ];
        canReflect.assignSymbols(list, {
            'can.onPatches': function (handler) {
                onPatchesHandler = handler;
            }
        });
        var template = function (num) {
            return '<span>' + num.get() + '</span>';
        };
        live.list(child, list, template, {});
        list.shift();
        list.splice(1, 0, 'a');
        queues.batch.start();
        onPatchesHandler([{
                type: 'move',
                fromIndex: 0,
                toIndex: 1
            }]);
        queues.batch.stop();
        assert.ok(true, 'The list should not blow up');
        var values = canReflect.toArray(parent.getElementsByTagName('span')).map(function (span) {
            return span.innerHTML;
        });
        QUnit.deepEqual(values, [
            'b',
            'a',
            'c'
        ]);
    });
    QUnit.test('list and an falsey section (#1979)', function () {
        var div = document.createElement('div'), template = function (num) {
                return '<label>num=</label> <span>' + num + '</span>';
            }, falseyTemplate = function () {
                return '<p>NOTHING</p>';
            };
        var listCompute = new SimpleObservable([
            0,
            1
        ]);
        div.innerHTML = 'my <b>fav</b> nums: <span></span> !';
        var el = div.getElementsByTagName('span')[0];
        live.list(el, listCompute, template, {}, undefined, undefined, falseyTemplate);
        equal(div.getElementsByTagName('label').length, 2, 'There are 2 labels');
        listCompute.set([]);
        var spans = div.getElementsByTagName('span');
        equal(spans.length, 0, 'there are 0 spans');
        var ps = div.getElementsByTagName('p');
        equal(ps.length, 1, 'there is 1 p');
        listCompute.set([2]);
        spans = div.getElementsByTagName('span');
        equal(spans.length, 1, 'there is 1 spans');
        ps = div.getElementsByTagName('p');
        equal(ps.length, 0, 'there is 1 p');
    });
    QUnit.test('list and an initial falsey section (#1979)', function () {
        var div = document.createElement('div'), template = function (num) {
                return '<label>num=</label> <span>' + num + '</span>';
            }, falseyTemplate = function () {
                return '<p>NOTHING</p>';
            };
        var listCompute = new SimpleObservable([]);
        div.innerHTML = 'my <b>fav</b> nums: <span></span> !';
        var el = div.getElementsByTagName('span')[0];
        live.list(el, listCompute, template, {}, undefined, undefined, falseyTemplate);
        var spans = div.getElementsByTagName('span');
        equal(spans.length, 0, 'there are 0 spans');
        var ps = div.getElementsByTagName('p');
        equal(ps.length, 1, 'there is 1 p');
        listCompute.set([2]);
        spans = div.getElementsByTagName('span');
        equal(spans.length, 1, 'there is 1 spans');
        ps = div.getElementsByTagName('p');
        equal(ps.length, 0, 'there is 1 p');
    });
    test('list items should be correct even if renderer flushes batch (#8)', function () {
        var partial = document.createElement('div');
        var placeholderElement = document.createElement('span');
        var list = new DefineList([
            'one',
            'two'
        ]);
        var renderer = function (item) {
            queues.flush();
            return '<span>' + item.get() + '</span>';
        };
        partial.appendChild(placeholderElement);
        live.list(placeholderElement, list, renderer, {});
        equal(partial.getElementsByTagName('span').length, 2, 'should be two items');
        equal(partial.getElementsByTagName('span')[0].firstChild.data, 'one', 'list item 0 is "one"');
        equal(partial.getElementsByTagName('span')[1].firstChild.data, 'two', 'list item 1 is "two"');
        queues.batch.start();
        list.splice(0, 0, 'three');
        list.splice(2, 1);
        queues.batch.stop();
        equal(partial.getElementsByTagName('span').length, 2, 'should be two items');
        equal(partial.getElementsByTagName('span')[0].firstChild.data, 'three', 'list item 0 is "three"');
        equal(partial.getElementsByTagName('span')[1].firstChild.data, 'one', 'list item 1 is "one"');
    });
    test('changing items in a live.list after it has been unregistered works (#55)', function () {
        var map = new SimpleMap({
            show: true,
            list: new DefineList(['one'])
        });
        var htmlNodeList = canReflect.toArray(fragment('<div></div>').childNodes);
        NodeLists.register(htmlNodeList, function () {
        }, true);
        var listNodeList = canReflect.toArray(fragment('<div></div>').childNodes);
        NodeLists.register(listNodeList, function () {
        }, htmlNodeList, true);
        var listTextNode = document.createTextNode('');
        var listFrag = document.createDocumentFragment();
        listFrag.appendChild(listTextNode);
        var htmlTextNode = document.createTextNode('');
        var div = document.createElement('div');
        div.appendChild(htmlTextNode);
        var listObs = new Observation(function list() {
            return map.attr('list');
        }, { priority: 2 });
        var listRenderer = function (item) {
            Observation.temporarilyBind(item);
            return item.get();
        };
        live.list(listTextNode, listObs, listRenderer, map, listTextNode.parentNode, listNodeList);
        var htmlObservation = new Observation(function if_show_html() {
            return map.attr('show') ? listFrag : undefined;
        }, { priority: 1 });
        live.html(htmlTextNode, htmlObservation, htmlTextNode.parentNode, htmlNodeList);
        queues.batch.start();
        map.attr('show', false);
        map.attr('list').replace([
            'two',
            'three'
        ]);
        queues.batch.stop();
        QUnit.ok(true, 'should not throw');
    });
    QUnit.test('Works with Observations - .list', function () {
        var div = document.createElement('div'), map = new SimpleMap({
                animals: new DefineList([
                    'bear',
                    'turtle'
                ])
            }), template = function (animal) {
                return '<label>Animal=</label> <span>' + animal.get() + '</span>';
            };
        var listObservation = new Observation(function () {
            return map.attr('animals');
        });
        div.innerHTML = 'my <b>fav</b> animals: <span></span> !';
        var el = div.getElementsByTagName('span')[0];
        live.list(el, listObservation, template, {});
        equal(div.getElementsByTagName('label').length, 2, 'There are 2 labels');
        div.getElementsByTagName('label')[0].myexpando = 'EXPANDO-ED';
        map.attr('animals').push('turtle');
        equal(div.getElementsByTagName('label')[0].myexpando, 'EXPANDO-ED', 'same expando');
        equal(div.getElementsByTagName('span')[2].innerHTML, 'turtle', 'turtle added');
        map.attr('animals', new DefineList([
            'sloth',
            'bear',
            'turtle'
        ]));
        var spans = div.getElementsByTagName('span');
        equal(spans.length, 3, 'there are 3 spans');
        ok(!div.getElementsByTagName('label')[0].myexpando, 'no expando');
    });
    test('no memory leaks', function () {
        var div = document.createElement('div'), map = new SimpleMap({
                animals: new DefineList([
                    'bear',
                    'turtle'
                ])
            }), template = function (animal) {
                return '<label>Animal=</label> <span>' + animal.get() + '</span>';
            };
        var listObservation = new Observation(function () {
            return map.attr('animals');
        });
        div.innerHTML = 'my <b>fav</b> animals: <span></span> !';
        var el = div.getElementsByTagName('span')[0];
        this.fixture.appendChild(div);
        var fixture = this.fixture;
        live.list(el, listObservation, template, {});
        QUnit.stop();
        setTimeout(function () {
            domMutate.removeChild.call(fixture, div);
            setTimeout(function () {
                var handlers = map[canSymbol.for('can.meta')].handlers.get([]);
                equal(handlers.length, 0, 'there are no bindings');
                start();
            }, 50);
        }, 10);
    });
    testHelpers.dev.devOnlyTest('getValueDependencies', function (assert) {
        var done = assert.async();
        assert.expect(2);
        var div = document.createElement('div');
        div.innerHTML = 'my <b>fav</b> animals: <span></span> !';
        document.body.appendChild(div);
        var el = div.getElementsByTagName('span')[0];
        var list = new DefineList([
            'sloth',
            'bear'
        ]);
        var template = function (animal) {
            return '<label>Animal=</label> <span>' + animal.get() + '</span>';
        };
        live.list(el, list, template, {});
        assert.deepEqual(canReflect.getValueDependencies(div).valueDependencies, new Set([list]));
        domEvents.addEventListener.call(div, 'removed', function checkTeardown() {
            domEvents.removeEventListener.call(div, 'removed', checkTeardown);
            assert.equal(typeof canReflect.getValueDependencies(div), 'undefined', 'dependencies should be cleared when parent node is removed');
            done();
        });
        div.remove();
    });
});
/*can-view-live@4.0.0-pre.11#test/text-test*/
define('can-view-live@4.0.0-pre.11#test/text-test', [
    'require',
    'exports',
    'module',
    'can-view-live',
    'can-observation',
    'steal-qunit',
    'can-simple-observable',
    'can-util/dom/mutate/mutate',
    'can-view-nodelist',
    'can-reflect',
    'can-util/dom/events/events',
    'can-test-helpers'
], function (require, exports, module) {
    var live = require('can-view-live');
    var Observation = require('can-observation');
    var QUnit = require('steal-qunit');
    var SimpleObservable = require('can-simple-observable');
    var domMutate = require('can-util/dom/mutate/mutate');
    var nodeLists = require('can-view-nodelist');
    var canReflect = require('can-reflect');
    var domEvents = require('can-util/dom/events/events');
    var testHelpers = require('can-test-helpers');
    QUnit.module('can-view-live.text', {
        setup: function () {
            this.fixture = document.getElementById('qunit-fixture');
        }
    });
    var esc = function (str) {
        return str.replace(/</g, '&lt;').replace(/>/g, '&gt;');
    };
    QUnit.test('text', function () {
        var div = document.createElement('div'), span = document.createElement('span');
        div.appendChild(span);
        var value = new SimpleObservable([
            'one',
            'two'
        ]);
        var text = new Observation(function html() {
            var html = '';
            value.get().forEach(function (item) {
                html += '<label>' + item + '</label>';
            });
            return html;
        });
        live.text(span, text, div);
        equal(div.innerHTML, esc('<label>one</label><label>two</label>'));
        value.set([
            'one',
            'two',
            'three'
        ]);
        equal(div.innerHTML, esc('<label>one</label><label>two</label><label>three</label>'));
    });
    QUnit.test('text binding is memory safe (#666)', function () {
        nodeLists.nodeMap.clear();
        var div = document.createElement('div'), span = document.createElement('span'), text = new Observation(function () {
                return 'foo';
            });
        div.appendChild(span);
        domMutate.appendChild.call(this.fixture, div);
        live.text(span, text, div);
        domMutate.removeChild.call(this.fixture, div);
        stop();
        setTimeout(function () {
            ok(!nodeLists.nodeMap.size, 'nothing in nodeMap');
            start();
        }, 100);
    });
    testHelpers.dev.devOnlyTest('getValueDependencies', function (assert) {
        var done = assert.async();
        assert.expect(2);
        var div = document.createElement('div');
        var span = document.createElement('span');
        div.appendChild(span);
        document.body.appendChild(div);
        var value = new SimpleObservable([
            'one',
            'two'
        ]);
        var text = new Observation(function html() {
            return value.get().map(function (item) {
                return '<label>' + item + '</label>';
            }).join('');
        });
        live.text(span, text, div);
        assert.deepEqual(canReflect.getValueDependencies(div).valueDependencies, new Set([text]));
        domEvents.addEventListener.call(div, 'removed', function checkTeardown() {
            domEvents.removeEventListener.call(div, 'removed', checkTeardown);
            assert.equal(typeof canReflect.getValueDependencies(div), 'undefined', 'dependencies should be clear out when elements is removed');
            done();
        });
        div.remove();
    });
});
/*can-view-live@4.0.0-pre.11#test/attr-test*/
define('can-view-live@4.0.0-pre.11#test/attr-test', [
    'require',
    'exports',
    'module',
    'can-view-live',
    'can-observation',
    'steal-qunit',
    'can-util/dom/attr/attr',
    'can-simple-observable',
    'can-reflect',
    'can-util/dom/events/events',
    'can-test-helpers'
], function (require, exports, module) {
    var live = require('can-view-live');
    var Observation = require('can-observation');
    var QUnit = require('steal-qunit');
    var domAttr = require('can-util/dom/attr/attr');
    var SimpleObservable = require('can-simple-observable');
    var canReflect = require('can-reflect');
    var domEvents = require('can-util/dom/events/events');
    var testHelpers = require('can-test-helpers');
    QUnit.module('can-view-live.attr', {
        setup: function () {
            this.fixture = document.getElementById('qunit-fixture');
        }
    });
    QUnit.test('basics', function () {
        var div = document.createElement('div');
        var firstValue = new SimpleObservable(null);
        var first = new Observation(function () {
            return firstValue.get() ? 'selected' : '';
        });
        var secondValue = new SimpleObservable(null);
        var second = new Observation(function () {
            return secondValue.get() ? 'active' : '';
        });
        var className = new Observation(function () {
            return 'foo ' + first.get() + ' ' + second.get() + ' end';
        });
        live.attr(div, 'class', className);
        equal(div.className, 'foo   end');
        firstValue.set(true);
        equal(div.className, 'foo selected  end');
        secondValue.set(true);
        equal(div.className, 'foo selected active end');
        firstValue.set(false);
        equal(div.className, 'foo  active end');
    });
    QUnit.test('specialAttribute with new line', function () {
        var div = document.createElement('div');
        var style = new SimpleObservable('width: 50px;\nheight:50px;');
        live.attr(div, 'style', style);
        equal(div.style.height, '50px');
        equal(div.style.width, '50px');
    });
    QUnit.test('can.live.attr works with non-string attributes (#1790)', function () {
        var el = document.createElement('div'), attrCompute = new Observation(function () {
                return 2;
            });
        domAttr.set(el, 'value', 1);
        live.attr(el, 'value', attrCompute);
        ok(true, 'No exception thrown.');
    });
    testHelpers.dev.devOnlyTest('getValueDependencies', function (assert) {
        var done = assert.async();
        assert.expect(2);
        var div = document.createElement('div');
        document.body.appendChild(div);
        var id = new SimpleObservable('foo');
        var title = new SimpleObservable('something');
        live.attr(div, 'id', id);
        live.attr(div, 'title', title);
        assert.deepEqual(canReflect.getValueDependencies(div).valueDependencies, new Set([
            id,
            title
        ]), 'should return the two SimpleObservable as dependencies');
        domEvents.addEventListener.call(div, 'removed', function checkTeardown() {
            domEvents.removeEventListener.call(div, 'removed', checkTeardown);
            assert.equal(typeof canReflect.getValueDependencies(div), 'undefined', 'dependencies should be cleared out when elements is removed');
            done();
        });
        div.remove();
    });
});
/*can-view-live@4.0.0-pre.11#test/attrs-test*/
define('can-view-live@4.0.0-pre.11#test/attrs-test', [
    'require',
    'exports',
    'module',
    'can-view-live',
    'can-observation',
    'steal-qunit',
    'can-simple-observable',
    'can-queues',
    'can-util/dom/events/events',
    'can-util/dom/mutate/mutate',
    'can-reflect',
    'can-test-helpers'
], function (require, exports, module) {
    var live = require('can-view-live');
    var Observation = require('can-observation');
    var QUnit = require('steal-qunit');
    var SimpleObservable = require('can-simple-observable');
    var queues = require('can-queues');
    var domEvents = require('can-util/dom/events/events');
    var domMutate = require('can-util/dom/mutate/mutate');
    var canReflect = require('can-reflect');
    var testHelpers = require('can-test-helpers');
    QUnit.module('can-view-live.attrs', {
        setup: function () {
            this.fixture = document.getElementById('qunit-fixture');
        }
    });
    QUnit.test('basics', function () {
        var div = document.createElement('div');
        var property = new SimpleObservable('class'), value = new SimpleObservable('foo');
        var text = new Observation(function () {
            var html = '';
            if (property.get() && value.get()) {
                html += property.get() + '=\'' + value.get() + '\'';
            }
            return html;
        });
        live.attrs(div, text);
        equal(div.className, 'foo');
        property.set(null);
        equal(div.className, '');
        queues.batch.start();
        property.set('foo');
        value.set('bar');
        queues.batch.stop();
        equal(div.getAttribute('foo'), 'bar');
    });
    QUnit.test('should remove `removed` events listener', function () {
        QUnit.stop();
        var origAddEventListener = domEvents.addEventListener;
        var origRemoveEventListener = domEvents.removeEventListener;
        domEvents.addEventListener = function () {
            QUnit.ok(true, 'addEventListener called');
            origAddEventListener.apply(this, arguments);
            domEvents.addEventListener = origAddEventListener;
        };
        domEvents.removeEventListener = function () {
            QUnit.ok(true, 'addEventListener called');
            origRemoveEventListener.apply(this, arguments);
            domEvents.removeEventListener = origRemoveEventListener;
            QUnit.start();
        };
        var div = document.createElement('div');
        var text = new SimpleObservable('hello');
        domMutate.appendChild.call(this.fixture, div);
        live.attrs(div, text);
        domMutate.removeChild.call(this.fixture, div);
    });
    testHelpers.dev.devOnlyTest('getValueDependencies', function (assert) {
        var done = assert.async();
        assert.expect(2);
        var div = document.createElement('div');
        document.body.appendChild(div);
        var attr = new SimpleObservable('class');
        var value = new SimpleObservable('foo');
        var text = new Observation(function () {
            var html = '';
            if (attr.get() && value.get()) {
                html += attr.get() + '="' + value.get() + '"';
            }
            return html;
        });
        live.attrs(div, text);
        assert.deepEqual(canReflect.getValueDependencies(div).valueDependencies, new Set([text]));
        domEvents.addEventListener.call(div, 'removed', function checkTeardown() {
            domEvents.removeEventListener.call(div, 'removed', checkTeardown);
            assert.equal(typeof canReflect.getValueDependencies(div), 'undefined', 'dependencies should be cleared out when element is removed');
            done();
        });
        div.remove();
    });
});
/*can-view-live@4.0.0-pre.11#test/test*/
define('can-view-live@4.0.0-pre.11#test/test', [
    'require',
    'exports',
    'module',
    './html-test',
    './patcher-test',
    './list-test',
    './text-test',
    './attr-test',
    './attrs-test'
], function (require, exports, module) {
    require('./html-test');
    require('./patcher-test');
    require('./list-test');
    require('./text-test');
    require('./attr-test');
    require('./attrs-test');
});
/*can-view-model@4.0.0-pre.3#can-view-model_test*/
define('can-view-model@4.0.0-pre.3#can-view-model_test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-view-model',
    'can-simple-map'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var viewModel = require('can-view-model');
    var SimpleMap = require('can-simple-map');
    QUnit.module('can-view-model');
    QUnit.test('basics', function () {
        var el = document.createElement('div');
        viewModel(el, 'foo', 'bar');
        QUnit.equal(viewModel(el, 'foo'), 'bar');
        QUnit.ok(viewModel(el) instanceof SimpleMap, 'is SimpleMap');
    });
    QUnit.test('a selector can be passed as the first argument (#6)', function () {
        var el = document.createElement('div');
        el.className = 'the-el';
        document.getElementById('qunit-fixture').appendChild(el);
        viewModel('.the-el', 'foo', 'bar');
        QUnit.equal(viewModel('.the-el', 'foo'), 'bar');
        QUnit.ok(viewModel(el) instanceof SimpleMap, 'is can-map');
    });
    QUnit.test('set custom can-simple-map on element (#5)', function () {
        var vm, elVm;
        var CustomMap = SimpleMap.extend({});
        var el = document.createElement('div');
        document.getElementById('qunit-fixture').appendChild(el);
        vm = new CustomMap({ foo: 'bar' });
        elVm = viewModel(el, vm);
        QUnit.equal(viewModel(el, 'foo'), 'bar');
    });
    QUnit.test('Allow passing array like (jQuery) element', function () {
        var $el = {};
        var el = document.createElement('div');
        el.className = 'the-el';
        $el[0] = el;
        $el.length = 1;
        document.getElementById('qunit-fixture').appendChild(el);
        viewModel($el, 'foo', 'bar');
        QUnit.equal(viewModel('.the-el', 'foo'), 'bar', 'It reads view scope from html element');
        QUnit.equal(viewModel($el, 'foo'), 'bar', 'It reads view scope from array like (jQuery) element');
        QUnit.ok(viewModel(el) instanceof SimpleMap, 'is can-map');
    });
    QUnit.test('elements with length property not treated as arraylikes (#31)', function () {
        var el = document.createElement('select');
        document.getElementById('qunit-fixture').appendChild(el);
        QUnit.equal(el.length, 0, 'Select has length property (0 for empty)');
        QUnit.deepEqual(viewModel(el).get(), {}, 'viewModel created on empty select');
        var opt = document.createElement('option');
        el.appendChild(opt);
        QUnit.equal(el.length, 1, 'Select has length 1');
        QUnit.deepEqual(viewModel(el).get(), {}, 'viewModel created on non-empty select');
    });
});
/*can-view-model@4.0.0-pre.3#test/test*/
define('can-view-model@4.0.0-pre.3#test/test', [
    'require',
    'exports',
    'module',
    '../can-view-model_test'
], function (require, exports, module) {
    require('../can-view-model_test');
});
/*can-view-nodelist@3.1.0#test/can-view-nodelist-test*/
define('can-view-nodelist@3.1.0#test/can-view-nodelist-test', [
    'require',
    'exports',
    'module',
    'can-view-nodelist',
    'can-util/dom/fragment/fragment',
    'can-util/js/make-array/make-array',
    'can-util/dom/frag/frag',
    'steal-qunit'
], function (require, exports, module) {
    var nodeLists = require('can-view-nodelist');
    var fragment = require('can-util/dom/fragment/fragment');
    var makeArray = require('can-util/js/make-array/make-array');
    var frag = require('can-util/dom/frag/frag');
    var QUnit = require('steal-qunit');
    QUnit.module('can-view-nodelist');
    test('unregisters child nodeLists', function () {
        expect(3);
        var spansFrag = fragment('<span>1</span><span>2</span>');
        var spansList = makeArray(spansFrag.childNodes);
        nodeLists.register(spansList, function () {
            ok(true, 'unregistered spansList');
        });
        var labelFrag = fragment('<label>l</label>');
        var labelList = makeArray(labelFrag.childNodes);
        nodeLists.register(labelList, function () {
            ok(true, 'unregistered labelList');
        });
        var ifPreHookupFrag = frag([
                '~',
                '',
                '-',
                ''
            ]), ifChildNodes = ifPreHookupFrag.childNodes, ifEls = makeArray(ifChildNodes);
        nodeLists.replace([ifChildNodes[1]], spansFrag);
        nodeLists.replace([ifChildNodes[4]], labelFrag);
        var ifList = makeArray(ifPreHookupFrag.childNodes);
        nodeLists.register(ifList, function () {
            ok(true, 'unregistered ifList');
        });
        deepEqual(ifList, [
            ifEls[0],
            spansList,
            ifEls[2],
            labelList
        ]);
        nodeLists.update(ifList, [document.createTextNode('empty')]);
    });
});
/*can-view-parser@3.6.2#test/can-view-parser-test*/
define('can-view-parser@3.6.2#test/can-view-parser-test', [
    'require',
    'exports',
    'module',
    'can-view-parser',
    'steal-qunit',
    'can-log/dev/dev',
    'can-attribute-encoder',
    'can-test-helpers'
], function (require, exports, module) {
    var parser = require('can-view-parser');
    var QUnit = require('steal-qunit');
    var canDev = require('can-log/dev/dev');
    var encoder = require('can-attribute-encoder');
    var testHelpers = require('can-test-helpers');
    QUnit.module('can-view-parser');
    var makeChecks = function (tests) {
        var count = 0;
        var makeCheck = function (name) {
            return function () {
                if (count >= tests.length) {
                    ok(false, 'called ' + name + ' with ' + JSON.stringify([].slice.call(arguments)));
                } else {
                    var test = tests[count], args = test[1];
                    equal(name, test[0], 'test ' + count + ' ' + name + '(');
                    for (var i = 0; i < args.length; i++) {
                        equal(arguments[i], args[i], i + 1 + ' arg -> ' + args[i]);
                    }
                    count++;
                }
            };
        };
        return {
            start: makeCheck('start'),
            end: makeCheck('end'),
            close: makeCheck('close'),
            attrStart: makeCheck('attrStart'),
            attrEnd: makeCheck('attrEnd'),
            attrValue: makeCheck('attrValue'),
            chars: makeCheck('chars'),
            comment: makeCheck('comment'),
            special: makeCheck('special'),
            done: makeCheck('done')
        };
    };
    test('html to html', function () {
        var tests = [
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'attrStart',
                ['id']
            ],
            [
                'attrValue',
                ['foo']
            ],
            [
                'attrEnd',
                ['id']
            ],
            [
                'special',
                ['#if']
            ],
            [
                'special',
                ['.']
            ],
            [
                'special',
                ['/if']
            ],
            [
                'attrStart',
                ['class']
            ],
            [
                'attrValue',
                ['a']
            ],
            [
                'special',
                ['foo']
            ],
            [
                'attrEnd',
                ['class']
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'chars',
                ['Hello ']
            ],
            [
                'special',
                ['message']
            ],
            [
                'chars',
                ['!']
            ],
            [
                'close',
                ['h1']
            ],
            [
                'done',
                []
            ]
        ];
        parser('<h1 id=\'foo\' {{#if}}{{.}}{{/if}} class=\'a{{foo}}\'>Hello {{message}}!</h1>', makeChecks(tests));
    });
    test('uppercase html to html', function () {
        var tests = [
            [
                'start',
                [
                    'div',
                    false
                ]
            ],
            [
                'end',
                [
                    'div',
                    false
                ]
            ],
            [
                'chars',
                ['sibling']
            ],
            [
                'close',
                ['div']
            ],
            [
                'start',
                [
                    'div',
                    false
                ]
            ],
            [
                'end',
                [
                    'div',
                    false
                ]
            ],
            [
                'chars',
                ['sibling']
            ],
            [
                'close',
                ['div']
            ],
            [
                'done',
                []
            ]
        ];
        parser('<DIV>sibling</DIV><DIV>sibling</DIV>', makeChecks(tests));
    });
    test('camelCase attributes stay untouched (svg) - #22', function () {
        var tests = [
            [
                'start',
                [
                    'svg',
                    false
                ]
            ],
            [
                'attrStart',
                ['viewBox']
            ],
            [
                'attrValue',
                ['0 0 15 22']
            ],
            [
                'attrEnd',
                ['viewBox']
            ],
            [
                'end',
                [
                    'svg',
                    false
                ]
            ],
            [
                'close',
                ['svg']
            ],
            [
                'done',
                []
            ]
        ];
        parser('<svg viewBox="0 0 15 22"></svg>', makeChecks(tests));
    });
    test('camelCase tags stay untouched (svg)', function () {
        var tests = [
            [
                'start',
                [
                    'svg',
                    false
                ]
            ],
            [
                'end',
                [
                    'svg',
                    false
                ]
            ],
            [
                'start',
                [
                    'radialGradient',
                    false
                ]
            ],
            [
                'end',
                [
                    'radialGradient',
                    false
                ]
            ],
            [
                'close',
                ['radialGradient']
            ],
            [
                'close',
                ['svg']
            ],
            [
                'done',
                []
            ]
        ];
        parser('<svg><radialGradient></radialGradient></svg>', makeChecks(tests));
    });
    test('special in an attribute in an in-tag section', function () {
        parser('<div {{#truthy}}foo=\'{{baz}}\'{{/truthy}}></div>', makeChecks([
            [
                'start',
                [
                    'div',
                    false
                ]
            ],
            [
                'special',
                ['#truthy']
            ],
            [
                'attrStart',
                ['foo']
            ],
            [
                'special',
                ['baz']
            ],
            [
                'attrEnd',
                ['foo']
            ],
            [
                'special',
                ['/truthy']
            ],
            [
                'end',
                [
                    'div',
                    false
                ]
            ],
            [
                'close',
                ['div']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('special with a custom attribute', function () {
        parser('<div {{#attribute}} {{name}}="{{value}}" {{/attribute}}></div>', makeChecks([
            [
                'start',
                [
                    'div',
                    false
                ]
            ],
            [
                'special',
                ['#attribute']
            ],
            [
                'special',
                ['name']
            ],
            [
                'attrStart',
                ['']
            ],
            [
                'special',
                ['value']
            ],
            [
                'attrEnd',
                ['']
            ],
            [
                'special',
                ['/attribute']
            ],
            [
                'end',
                [
                    'div',
                    false
                ]
            ],
            [
                'close',
                ['div']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('single attribute value', function () {
        parser('<input DISABLED/>', makeChecks([
            [
                'start',
                [
                    'input',
                    true
                ]
            ],
            [
                'attrStart',
                ['DISABLED']
            ],
            [
                'attrEnd',
                ['DISABLED']
            ],
            [
                'end',
                [
                    'input',
                    true
                ]
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('trailing linebreaks in IE', function () {
        parser('12345{{!\n  This is a\n  multi-line comment...\n}}67890\n', makeChecks([
            [
                'chars',
                ['12345']
            ],
            [
                'special',
                ['!\n  This is a\n  multi-line comment...\n']
            ],
            [
                'chars',
                ['67890\n']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('block are allowed inside anchor tags', function () {
        parser('<a><div></div></a>', makeChecks([
            [
                'start',
                [
                    'a',
                    false
                ]
            ],
            [
                'end',
                [
                    'a',
                    false
                ]
            ],
            [
                'start',
                [
                    'div',
                    false
                ]
            ],
            [
                'end',
                [
                    'div',
                    false
                ]
            ],
            [
                'close',
                ['div']
            ],
            [
                'close',
                ['a']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('anchors are allowed as children of inline elements - #2169', function () {
        parser('<span><a></a></span>', makeChecks([
            [
                'start',
                [
                    'span',
                    false
                ]
            ],
            [
                'end',
                [
                    'span',
                    false
                ]
            ],
            [
                'start',
                [
                    'a',
                    false
                ]
            ],
            [
                'end',
                [
                    'a',
                    false
                ]
            ],
            [
                'close',
                ['a']
            ],
            [
                'close',
                ['span']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('inline tags encapsulate inner block elements', function () {
        parser('<span><div></div></span>', makeChecks([
            [
                'start',
                [
                    'span',
                    false
                ]
            ],
            [
                'end',
                [
                    'span',
                    false
                ]
            ],
            [
                'start',
                [
                    'div',
                    false
                ]
            ],
            [
                'end',
                [
                    'div',
                    false
                ]
            ],
            [
                'close',
                ['div']
            ],
            [
                'close',
                ['span']
            ],
            [
                'done',
                []
            ]
        ]));
        parser('<em><h1></h1></em>', makeChecks([
            [
                'start',
                [
                    'em',
                    false
                ]
            ],
            [
                'end',
                [
                    'em',
                    false
                ]
            ],
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'close',
                ['h1']
            ],
            [
                'close',
                ['em']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('unordered lists will contain their list items', function () {
        parser('<ul><li></li><li></li></ul>', makeChecks([
            [
                'start',
                [
                    'ul',
                    false
                ]
            ],
            [
                'end',
                [
                    'ul',
                    false
                ]
            ],
            [
                'start',
                [
                    'li',
                    false
                ]
            ],
            [
                'end',
                [
                    'li',
                    false
                ]
            ],
            [
                'close',
                ['li']
            ],
            [
                'start',
                [
                    'li',
                    false
                ]
            ],
            [
                'end',
                [
                    'li',
                    false
                ]
            ],
            [
                'close',
                ['li']
            ],
            [
                'close',
                ['ul']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('supports single character attributes (#1132)', function () {
        parser('<circle r="25"></circle>', makeChecks([
            [
                'start',
                [
                    'circle',
                    false
                ]
            ],
            [
                'attrStart',
                ['r']
            ],
            [
                'attrValue',
                ['25']
            ],
            [
                'attrEnd',
                ['r']
            ],
            [
                'end',
                [
                    'circle',
                    false
                ]
            ],
            [
                'close',
                ['circle']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('accept custom tag with colon ":" #1108', function () {
        parser('<x:widget/>', makeChecks([
            [
                'start',
                [
                    'x:widget',
                    true
                ]
            ],
            [
                'end',
                [
                    'x:widget',
                    true
                ]
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('output json', function () {
        var tests = [
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'attrStart',
                ['id']
            ],
            [
                'attrValue',
                ['foo']
            ],
            [
                'attrEnd',
                ['id']
            ],
            [
                'special',
                ['#if']
            ],
            [
                'special',
                ['.']
            ],
            [
                'special',
                ['/if']
            ],
            [
                'attrStart',
                ['class']
            ],
            [
                'attrValue',
                ['a']
            ],
            [
                'special',
                ['foo']
            ],
            [
                'attrEnd',
                ['class']
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'chars',
                ['Hello ']
            ],
            [
                'special',
                ['message']
            ],
            [
                'chars',
                ['!']
            ],
            [
                'close',
                ['h1']
            ],
            [
                'done',
                []
            ]
        ];
        var intermediate = parser('<h1 id=\'foo\' {{#if}}{{.}}{{/if}} class=\'a{{foo}}\'>Hello {{message}}!</h1>', makeChecks(tests), true);
        parser(intermediate, makeChecks(tests));
    });
    test('less than outside of an element', function () {
        var tests = [
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'chars',
                [' < ']
            ],
            [
                'close',
                ['h1']
            ],
            [
                'done',
                []
            ]
        ];
        var intermediate = parser('<h1> < </h1>', makeChecks(tests), true);
        parser(intermediate, makeChecks(tests));
    });
    test('allow () and [] to enclose attributes', function () {
        parser('<p [click]="test"></p>', makeChecks([
            [
                'start',
                [
                    'p',
                    false
                ]
            ],
            [
                'attrStart',
                ['[click]']
            ],
            [
                'attrValue',
                ['test']
            ],
            [
                'attrEnd',
                ['[click]']
            ],
            [
                'end',
                ['p']
            ],
            [
                'close',
                ['p']
            ],
            [
                'done',
                []
            ]
        ]));
        parser('<p (click)="test"></p>', makeChecks([
            [
                'start',
                [
                    'p',
                    false
                ]
            ],
            [
                'attrStart',
                [encoder.encode('(click)')]
            ],
            [
                'attrValue',
                ['test']
            ],
            [
                'attrEnd',
                [encoder.encode('(click)')]
            ],
            [
                'end',
                ['p']
            ],
            [
                'close',
                ['p']
            ],
            [
                'done',
                []
            ]
        ]));
        parser('<p (click-me)="test"></p>', makeChecks([
            [
                'start',
                [
                    'p',
                    false
                ]
            ],
            [
                'attrStart',
                [encoder.encode('(click-me)')]
            ],
            [
                'attrValue',
                ['test']
            ],
            [
                'attrEnd',
                [encoder.encode('(click-me)')]
            ],
            [
                'end',
                ['p']
            ],
            [
                'close',
                ['p']
            ],
            [
                'done',
                []
            ]
        ]));
        parser('<p (click_me)="test"></p>', makeChecks([
            [
                'start',
                [
                    'p',
                    false
                ]
            ],
            [
                'attrStart',
                [encoder.encode('(click_me)')]
            ],
            [
                'attrValue',
                ['test']
            ],
            [
                'attrEnd',
                [encoder.encode('(click_me)')]
            ],
            [
                'end',
                ['p']
            ],
            [
                'close',
                ['p']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('allow {} to enclose attributes', function () {
        parser.parseAttrs('{a}="b" {{#c}}d{{/c}}', makeChecks([
            [
                'attrStart',
                [encoder.encode('{a}')]
            ],
            [
                'attrValue',
                ['b']
            ],
            [
                'attrEnd',
                [encoder.encode('{a}')]
            ],
            [
                'special',
                ['#c']
            ],
            [
                'attrStart',
                ['d']
            ],
            [
                'attrEnd',
                ['d']
            ],
            [
                'special',
                ['/c']
            ]
        ]));
    });
    test('tripple curly in attrs', function () {
        parser.parseAttrs('items="{{{ completed }}}"', makeChecks([
            [
                'attrStart',
                ['items']
            ],
            [
                'special',
                ['{ completed ']
            ],
            [
                'attrEnd',
                ['items']
            ]
        ]));
    });
    test('something', function () {
        parser.parseAttrs('c d=\'e\'', makeChecks([
            [
                'attrStart',
                ['c']
            ],
            [
                'attrEnd',
                ['c']
            ],
            [
                'attrStart',
                ['d']
            ],
            [
                'attrValue',
                ['e']
            ],
            [
                'attrEnd',
                ['d']
            ]
        ]));
    });
    test('references', function () {
        parser('<year-selector *y />', makeChecks([
            [
                'start',
                [
                    'year-selector',
                    true
                ]
            ],
            [
                'attrStart',
                ['*y']
            ],
            [
                'attrEnd',
                ['*y']
            ],
            [
                'end',
                ['year-selector']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('quotes around attributes and other lazy attribute writing (#2097)', function () {
        parser('<c-d a={z}/>', makeChecks([
            [
                'start',
                [
                    'c-d',
                    true
                ]
            ],
            [
                'attrStart',
                ['a']
            ],
            [
                'attrValue',
                ['{z}']
            ],
            [
                'attrEnd',
                ['a']
            ],
            [
                'end',
                ['c-d']
            ],
            [
                'done',
                []
            ]
        ]));
        parser('<span v={{.}}/>', makeChecks([
            [
                'start',
                [
                    'span',
                    true
                ]
            ],
            [
                'attrStart',
                ['v']
            ],
            [
                'special',
                ['.']
            ],
            [
                'attrEnd',
                ['v']
            ],
            [
                'end',
                ['span']
            ],
            [
                'done',
                []
            ]
        ]));
        parser('<div {{^f}} d {{/f}}/>', makeChecks([
            [
                'start',
                [
                    'div',
                    true
                ]
            ],
            [
                'special',
                ['^f']
            ],
            [
                'attrStart',
                ['d']
            ],
            [
                'attrEnd',
                ['d']
            ],
            [
                'special',
                ['/f']
            ],
            [
                'end',
                ['div']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('camelCased attributes are converted to spinal-case', function () {
        parser.parseAttrs('({camelCase})=\'assigned\'', makeChecks([
            [
                'attrStart',
                [encoder.encode('({camelCase})')]
            ],
            [
                'attrValue',
                ['assigned']
            ],
            [
                'attrEnd',
                [encoder.encode('({camelCase})')]
            ]
        ]));
    });
    test('elements that have attributes with equal signs and no values are handled appropriately (#17)', function () {
        parser('<input class=\'toggle\' type=\'checkbox\' {($checked)}=\'complete\' ($change)=>', makeChecks([
            [
                'start',
                [
                    'input',
                    true
                ]
            ],
            [
                'attrStart',
                ['class']
            ],
            [
                'attrValue',
                ['toggle']
            ],
            [
                'attrEnd',
                ['class']
            ],
            [
                'attrStart',
                ['type']
            ],
            [
                'attrValue',
                ['checkbox']
            ],
            [
                'attrEnd',
                ['type']
            ],
            [
                'attrStart',
                [encoder.encode('{($checked)}')]
            ],
            [
                'attrValue',
                ['complete']
            ],
            [
                'attrEnd',
                [encoder.encode('{($checked)}')]
            ],
            [
                'attrStart',
                [encoder.encode('($change)')]
            ],
            [
                'attrEnd',
                [encoder.encode('($change)')]
            ],
            [
                'end',
                ['input']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('supports other delimiters (#31)', function () {
        var checks = makeChecks([
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'attrStart',
                ['id']
            ],
            [
                'attrValue',
                ['foo']
            ],
            [
                'attrEnd',
                ['id']
            ],
            [
                'special',
                ['#if']
            ],
            [
                'special',
                ['.']
            ],
            [
                'special',
                ['/if']
            ],
            [
                'attrStart',
                ['class']
            ],
            [
                'attrValue',
                ['a']
            ],
            [
                'special',
                ['foo']
            ],
            [
                'attrEnd',
                ['class']
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'chars',
                ['Hello ']
            ],
            [
                'special',
                ['message']
            ],
            [
                'chars',
                ['!']
            ],
            [
                'close',
                ['h1']
            ],
            [
                'done',
                []
            ]
        ]);
        checks.magicStart = '{';
        checks.magicMatch = /\{([^\}]*)\}/g;
        parser('<h1 id=\'foo\' {#if}{.}{/if} class=\'a{foo}\'>Hello {message}!</h1>', checks);
    });
    test('{{}} in attribute values are handled correctly (#34)', function () {
        var tests = [
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'attrStart',
                ['class']
            ],
            [
                'special',
                ['foo']
            ],
            [
                'attrValue',
                ['a']
            ],
            [
                'attrEnd',
                ['class']
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'close',
                ['h1']
            ],
            [
                'done',
                []
            ]
        ];
        parser('<h1 class=\'{{foo}}a\'></h1>', makeChecks(tests));
    });
    test('tags with data attributes are allowed in comments (#2)', function () {
        parser('{{! foo }}', makeChecks([
            [
                'special',
                ['! foo ']
            ],
            [
                'done',
                []
            ]
        ]));
        parser('{{! <foo /> }}', makeChecks([
            [
                'special',
                ['! <foo /> ']
            ],
            [
                'done',
                []
            ]
        ]));
        parser('{{! <foo bar="{bam}" /> }}', makeChecks([
            [
                'special',
                ['! <foo bar="{bam}" /> ']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('multiline special comments (#14)', function () {
        parser('{{! foo !}}', makeChecks([
            [
                'special',
                ['! foo !']
            ],
            [
                'done',
                []
            ]
        ]));
        parser('{{! {{foo}} {{bar}} !}}', makeChecks([
            [
                'special',
                ['! {{foo}} {{bar}} !']
            ],
            [
                'done',
                []
            ]
        ]));
        parser('{{!\n{{foo}}\n{{bar}}\n!}}', makeChecks([
            [
                'special',
                ['!\n{{foo}}\n{{bar}}\n!']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('spaces in attribute names that start with `{` or `(` are encoded (#48)', function () {
        var tests = [
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'attrStart',
                [encoder.encode('{foo bar}')]
            ],
            [
                'attrValue',
                ['a']
            ],
            [
                'attrEnd',
                [encoder.encode('{foo bar}')]
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'close',
                ['h1']
            ],
            [
                'done',
                []
            ]
        ];
        parser('<h1 {foo bar}=\'a\'></h1>', makeChecks(tests));
    });
    test('for attributes without values, spaces in attribute names that start with `{` or `(` are encoded (#48)', function () {
        var tests = [
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'attrStart',
                [encoder.encode('{foo }')]
            ],
            [
                'attrEnd',
                [encoder.encode('{foo }')]
            ],
            [
                'attrStart',
                [encoder.encode('{bar }')]
            ],
            [
                'attrEnd',
                [encoder.encode('{bar }')]
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'close',
                ['h1']
            ],
            [
                'done',
                []
            ]
        ];
        parser('<h1 {foo } {bar }></h1>', makeChecks(tests));
    });
    test('mismatched brackets work: {(foo})', function () {
        var tests = [
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'attrStart',
                [encoder.encode('{(foo})')]
            ],
            [
                'attrValue',
                ['a']
            ],
            [
                'attrEnd',
                [encoder.encode('{(foo})')]
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'close',
                ['h1']
            ],
            [
                'done',
                []
            ]
        ];
        parser('<h1 {(foo})=\'a\'></h1>', makeChecks(tests));
    });
    test('mismatched brackets work: ({foo)}', function () {
        var tests = [
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'attrStart',
                [encoder.encode('({foo)}')]
            ],
            [
                'attrValue',
                ['a']
            ],
            [
                'attrEnd',
                [encoder.encode('({foo)}')]
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'close',
                ['h1']
            ],
            [
                'done',
                []
            ]
        ];
        parser('<h1 ({foo)}=\'a\'></h1>', makeChecks(tests));
    });
    test('forward slashes are encoded (#52)', function () {
        var tests = [
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'attrStart',
                [encoder.encode('{foo/bar}')]
            ],
            [
                'attrValue',
                ['a']
            ],
            [
                'attrEnd',
                [encoder.encode('{foo/bar}')]
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'close',
                ['h1']
            ],
            [
                'done',
                []
            ]
        ];
        parser('<h1 {foo/bar}=\'a\'></h1>', makeChecks(tests));
    });
    test('camelCase properties are encoded with on:, :to, :from, :bind bindings', function () {
        var tests = [
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'attrStart',
                [encoder.encode('on:aB')]
            ],
            [
                'attrValue',
                ['c']
            ],
            [
                'attrEnd',
                [encoder.encode('on:aB')]
            ],
            [
                'attrStart',
                [encoder.encode('dE:to')]
            ],
            [
                'attrValue',
                ['f']
            ],
            [
                'attrEnd',
                [encoder.encode('dE:to')]
            ],
            [
                'attrStart',
                [encoder.encode('gH:from')]
            ],
            [
                'attrValue',
                ['i']
            ],
            [
                'attrEnd',
                [encoder.encode('gH:from')]
            ],
            [
                'attrStart',
                [encoder.encode('jK:bind')]
            ],
            [
                'attrValue',
                ['l']
            ],
            [
                'attrEnd',
                [encoder.encode('jK:bind')]
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'close',
                ['h1']
            ],
            [
                'done',
                []
            ]
        ];
        parser('<h1 on:aB=\'c\' dE:to=\'f\' gH:from=\'i\' jK:bind=\'l\'></h1>', makeChecks(tests));
    });
    testHelpers.dev.devOnlyTest('Warn on missing attribute value end quotes (canjs/can-view-parser#7)', function () {
        var makeWarnChecks = function (input, texts) {
            var count = 0;
            var teardown = testHelpers.dev.willWarn(/End quote is missing for/, function (message, matched) {
                ok(matched, texts[count++]);
            });
            parser(input, {
                start: function (tagName, unary) {
                },
                end: function (tagName, unary) {
                },
                attrStart: function (attrName) {
                },
                attrEnd: function (attrName) {
                },
                attrValue: function (val) {
                },
                done: function () {
                }
            });
            equal(count, teardown());
        };
        makeWarnChecks('<my-input {value}="name" (value)="updateNameOnEven(%viewModel.value)/>', ['1: End quote is missing for updateNameOnEven(%viewModel.value)']);
        makeWarnChecks('<input on:click="callback />', ['1: End quote is missing for callback']);
        makeWarnChecks('<my-input {an-attr}="aValue />', ['1: End quote is missing for aValue']);
        makeWarnChecks('<my-input {an-other-attr}=\'anotherValue />', ['1: End quote is missing for anotherValue']);
    });
    testHelpers.dev.devOnlyTest('Fix false warning on missing closed quote (canjs/can-view-parser#7#issuecomment-336468766)', function () {
        var makeWarnChecks = function (input, texts) {
            var count = 0;
            var teardown = testHelpers.dev.willWarn(/End quote is missing for/, function (message, matched) {
                notOk(matched, texts[count++]);
            });
            parser(input, {
                start: function (tagName, unary) {
                },
                end: function (tagName, unary) {
                },
                attrStart: function (attrName) {
                },
                attrEnd: function (attrName) {
                },
                attrValue: function (val) {
                },
                done: function () {
                },
                special: function () {
                    return [
                        '#if',
                        '/if'
                    ];
                }
            });
            equal(count, teardown());
        };
        var truthy = true;
        makeWarnChecks('<div {{#if truthy}} class="current-page"{{/if}} />', ['1: End quote is missing for current-page']);
        makeWarnChecks('<div class="current-page"($click)="" />', ['1: End quote is missing for current-page']);
        makeWarnChecks('<input type="text">', ['1: End quote is missing for current-page']);
    });
});
/*can-view-scope@4.0.0-pre.22#test/scope-test*/
define('can-view-scope@4.0.0-pre.22#test/scope-test', [
    'require',
    'exports',
    'module',
    'can-view-scope',
    'can-stache-key',
    '../reference-map',
    'can-symbol',
    'steal-qunit',
    'can-reflect',
    'can-observation',
    'can-test-helpers',
    'can-simple-map',
    'can-simple-observable',
    'can-observation-recorder'
], function (require, exports, module) {
    var Scope = require('can-view-scope');
    var observeReader = require('can-stache-key');
    var ReferenceMap = require('../reference-map');
    var canSymbol = require('can-symbol');
    var QUnit = require('steal-qunit');
    var canReflect = require('can-reflect');
    var Observation = require('can-observation');
    var testHelpers = require('can-test-helpers');
    var SimpleMap = require('can-simple-map');
    var SimpleObservable = require('can-simple-observable');
    var ObservationRecorder = require('can-observation-recorder');
    QUnit.module('can/view/scope');
    test('basics', function () {
        var address = new SimpleMap({ zip: 60647 });
        var person = new SimpleMap({
            name: 'Justin',
            address: address
        });
        var items = new SimpleMap({
            people: person,
            count: 1000
        });
        var itemsScope = new Scope(items), personScope = new Scope(person, itemsScope), zipScope = new Scope(address, personScope);
        var nameInfo;
        var c = new Observation(function () {
            nameInfo = zipScope.read('name');
        });
        canReflect.onValue(c, function () {
        });
        deepEqual(nameInfo.reads, [{
                key: 'name',
                at: false
            }], 'reads');
        equal(nameInfo.scope, personScope, 'scope');
        equal(nameInfo.value, 'Justin', 'value');
        equal(nameInfo.rootObserve, person, 'rootObserve');
    });
    test('Scope.prototype.computeData', function () {
        var map = new SimpleMap();
        var base = new Scope(map);
        var age = base.computeData('age').compute;
        equal(age(), undefined, 'age is not set');
        age.bind('change', function (ev, newVal, oldVal) {
            equal(newVal, 31, 'newVal is provided correctly');
            equal(oldVal, undefined, 'oldVal is undefined');
        });
        age(31);
        equal(map.attr('age'), 31, 'maps age is set correctly');
    });
    test('backtrack path (#163)', function () {
        var row = new SimpleMap({ first: 'Justin' }), col = { format: 'str' }, base = new Scope(row), cur = base.add(col);
        equal(cur.peek('.'), col, 'got col');
        equal(cur.peek('..'), row, 'got row');
        equal(cur.peek('../first'), 'Justin', 'got row');
    });
    test('nested properties with compute', function () {
        var me = new SimpleMap({ name: new SimpleMap({ first: 'Justin' }) });
        var cur = new Scope(me);
        var compute = cur.computeData('name.first').compute;
        var changes = 0;
        var handler = function (ev, newVal, oldVal) {
            if (changes === 0) {
                equal(oldVal, 'Justin');
                equal(newVal, 'Brian');
            } else if (changes === 1) {
                equal(oldVal, 'Brian');
                equal(newVal, undefined);
            } else if (changes === 2) {
                equal(oldVal, undefined);
                equal(newVal, 'Payal');
            } else if (changes === 3) {
                equal(oldVal, 'Payal');
                equal(newVal, 'Curtis');
            }
            changes++;
        };
        compute.bind('change', handler);
        equal(compute(), 'Justin', 'read value after bind');
        me.attr('name').attr('first', 'Brian');
        me.attr('name', undefined);
        me.attr('name', { first: 'Payal' });
        me.attr('name', new SimpleMap({ first: 'Curtis' }));
        compute.unbind('change', handler);
    });
    test('function at the end', function () {
        var compute = new Scope({
            me: {
                info: function () {
                    return 'Justin';
                }
            }
        }).computeData('me.info').compute;
        equal(compute(), 'Justin');
        var fn = function () {
            return this.name;
        };
        var compute2 = new Scope({
            me: {
                info: fn,
                name: 'Hank'
            }
        }).computeData('me.info', {
            isArgument: true,
            args: []
        }).compute;
        equal(compute2()(), 'Hank');
    });
    test('binds to the right scope only', function () {
        var baseMap = new SimpleMap({ me: new SimpleMap({ name: new SimpleMap({ first: 'Justin' }) }) });
        var base = new Scope(baseMap);
        var topMap = new SimpleMap({ me: new SimpleMap({ name: new SimpleMap({}) }) });
        var scope = base.add(topMap);
        var compute = scope.computeData('me.name.first').compute;
        compute.bind('change', function (ev, newVal, oldVal) {
            equal(oldVal, 'Justin');
            equal(newVal, 'Brian');
        });
        equal(compute(), 'Justin');
        topMap.attr('me').attr('name').attr('first', 'Payal');
        baseMap.attr('me').attr('name').attr('first', 'Brian');
    });
    test('Scope read returnObserveMethods=true', function () {
        var MapConstruct = SimpleMap.extend({
            foo: function (arg) {
                equal(this, data.map, 'correct this');
                equal(arg, true, 'correct arg');
            }
        });
        var data = { map: new MapConstruct() };
        var res = Scope.read(data, observeReader.reads('map.foo'), { isArgument: true });
        res.value(true);
    });
    test('rooted observable is able to update correctly', function () {
        var baseMap = new SimpleMap({ name: new SimpleMap({ first: 'Justin' }) });
        var scope = new Scope(baseMap);
        var compute = scope.computeData('name.first').compute;
        equal(compute(), 'Justin');
        baseMap.attr('name', new SimpleMap({ first: 'Brian' }));
        equal(compute(), 'Brian');
    });
    test('computeData reading an object with a compute', function () {
        var sourceAge = 21;
        var age = new SimpleObservable(21);
        var scope = new Scope({ person: { age: age } });
        var computeData = scope.computeData('person.age');
        var value = computeData.compute();
        equal(value, 21, 'correct value');
        computeData.compute(31);
        equal(age.get(), 31, 'age updated');
    });
    test('computeData with initial empty compute (#638)', function () {
        expect(2);
        var c = new SimpleObservable();
        var scope = new Scope({ compute: c });
        var computeData = scope.computeData('compute');
        equal(computeData.compute(), undefined);
        computeData.compute.bind('change', function (ev, newVal) {
            equal(newVal, 'compute value');
        });
        c.set('compute value');
    });
    test('Can read static properties on constructors (#634)', function () {
        var Foo = SimpleMap.extend({ static_prop: 'baz' }, { proto_prop: 'thud' });
        var data = new Foo({ own_prop: 'quux' }), scope = new Scope(data);
        equal(scope.computeData('constructor.static_prop').compute(), 'baz', 'static prop');
    });
    test('Can read static properties on constructors (#634)', function () {
        var Foo = SimpleMap.extend({ static_prop: 'baz' }, { proto_prop: 'thud' });
        var data = new Foo({ own_prop: 'quux' }), scope = new Scope(data);
        equal(scope.computeData('constructor.static_prop').compute(), 'baz', 'static prop');
    });
    test('Scope lookup restricted to current scope with ./ (#874)', function () {
        var current;
        var scope = new Scope(new SimpleMap({ value: 'A Value' })).add(current = new SimpleMap({}));
        var compute = scope.computeData('./value').compute;
        equal(compute(), undefined, 'no initial value');
        compute.bind('change', function (ev, newVal) {
            equal(newVal, 'B Value', 'changed');
        });
        compute('B Value');
        equal(current.attr('value'), 'B Value', 'updated');
    });
    test('reading properties on undefined (#1314)', function () {
        var scope = new Scope(undefined);
        var compute = scope.compute('property');
        equal(compute(), undefined, 'got back undefined');
    });
    test('Scope attributes can be set (#1297, #1304)', function () {
        var comp = new SimpleObservable('Test');
        var map = new SimpleMap({ other: new SimpleMap({ name: 'Justin' }) });
        var scope = new Scope({
            name: 'Matthew',
            other: {
                person: { name: 'David' },
                comp: comp
            }
        });
        scope.set('name', 'Wilbur');
        equal(scope.get('name'), 'Wilbur', 'Value updated');
        scope.set('other.person.name', 'Dave');
        equal(scope.get('other.person.name'), 'Dave', 'Value updated');
        scope.set('other.comp', 'Changed');
        equal(comp.get(), 'Changed', 'Compute updated');
        scope = new Scope(map);
        scope.set('other.name', 'Brian');
        equal(scope.get('other.name'), 'Brian', 'Value updated');
        equal(map.attr('other').attr('name'), 'Brian', 'Name update in map');
    });
    testHelpers.dev.devOnlyTest('Setting a value to an attribute with an undefined parent errors (canjs/can-stache-bindings#298)', function () {
        var teardown = testHelpers.dev.willError(/Attempting to set a value at (.+) where (.+) is undefined./);
        var scope = new Scope({});
        scope.set('person.name', 'Christopher');
        QUnit.equal(teardown(), 1, 'saw errors');
    });
    test('computeData.compute get/sets computes in maps', function () {
        var cmpt = new SimpleObservable(4);
        var map = new SimpleMap();
        map.attr('computer', cmpt);
        var scope = new Scope(map);
        var computeData = scope.computeData('computer', {});
        equal(computeData.compute(), 4, 'got the value');
        computeData.compute(5);
        equal(cmpt.get(), 5, 'updated compute value');
        equal(computeData.compute(), 5, 'the compute has the right value');
    });
    test('computesData can find update when initially undefined parent scope becomes defined (#579)', function () {
        expect(2);
        var map = new SimpleMap();
        var scope = new Scope(map);
        var top = scope.add(new SimpleMap());
        var computeData = top.computeData('value', {});
        equal(computeData.compute(), undefined, 'initially undefined');
        computeData.compute.bind('change', function (ev, newVal) {
            equal(newVal, 'first');
        });
        map.attr('value', 'first');
    });
    test('A scope\'s %root is the last context', function () {
        var map = new SimpleMap();
        var refs = Scope.refsScope();
        var scope = refs.add(map).add(new Scope.Refs()).add(new SimpleMap());
        var root = scope.peek('%root');
        ok(!(root instanceof Scope.Refs), 'root isn\'t a reference');
        equal(root, map, 'The root is the map passed into the scope');
    });
    test('can set scope attributes with ../ (#2132)', function () {
        var map = new SimpleMap();
        var scope = new Scope(map);
        var top = scope.add(new SimpleMap());
        top.set('../foo', 'bar');
        equal(map.attr('foo'), 'bar');
    });
    test('can read parent context with ../ (#2244)', function () {
        var map = new SimpleMap();
        var scope = new Scope(map);
        var top = scope.add(new SimpleMap());
        equal(top.peek('../'), map, 'looked up value correctly');
    });
    test('reading from a string in a nested scope doesn\'t throw an error (#22)', function () {
        var foo = new SimpleObservable('foo');
        var bar = new SimpleObservable('bar');
        var scope = new Scope(foo);
        var localScope = scope.add(bar);
        equal(localScope.read('foo').value, undefined);
    });
    test('Optimize for compute().observableProperty (#29)', function () {
        var map = new SimpleMap({ value: 'a' });
        var wrap = new SimpleObservable(map);
        var scope = new Scope(wrap);
        var scopeKeyData = scope.computeData('value');
        var scopeCompute = scopeKeyData.compute;
        var changeNumber = 0;
        scopeCompute.on('change', function (ev, newVal, oldVal) {
            if (changeNumber === 1) {
                QUnit.equal(newVal, 'b');
                QUnit.equal(oldVal, 'a');
                QUnit.ok(scopeKeyData.fastPath, 'still fast path');
                changeNumber++;
                wrap.set(new SimpleMap({ value: 'c' }));
            } else if (changeNumber === 2) {
                QUnit.equal(newVal, 'c', 'got new value');
                QUnit.equal(oldVal, 'b', 'got old value');
                QUnit.notOk(scopeKeyData.fastPath, 'still fast path');
            }
        });
        QUnit.ok(scopeKeyData.fastPath, 'fast path');
        changeNumber++;
        map.attr('value', 'b');
    });
    test('read should support passing %scope (#24)', function () {
        var scope = new Scope(new SimpleMap({
            foo: '',
            bar: ''
        }));
        equal(scope.read('%scope').value, scope, 'looked up %scope correctly');
    });
    test('a compute can observe the ScopeKeyData', 3, function () {
        var map = new SimpleMap({
            value: 'a',
            other: 'b'
        });
        var wrap = new SimpleObservable(map);
        var scope = new Scope(wrap);
        var scopeKeyData = scope.computeData('value');
        var oldOnValue = scopeKeyData[canSymbol.for('can.onValue')];
        scopeKeyData[canSymbol.for('can.onValue')] = function () {
            QUnit.ok(true, 'bound on the scopeKeyData');
            return oldOnValue.apply(this, arguments);
        };
        var c = new Observation(function () {
            return scopeKeyData.get() + map.attr('other');
        });
        canReflect.onValue(c, function (newValue) {
            QUnit.equal(newValue, 'Ab', 'observation changed');
        });
        map.attr('value', 'A');
    });
    QUnit.asyncTest('unbinding clears all event bindings', function () {
        var map = new SimpleMap({
            value: 'a',
            other: 'b'
        });
        var wrap = new SimpleObservable(map);
        var scope = new Scope(wrap);
        var scopeKeyData = scope.computeData('value');
        var c = new Observation(function () {
            return scopeKeyData.get() + map.attr('other');
        });
        var handlers = function (newValue) {
            QUnit.equal(newValue, 'Ab');
        };
        canReflect.onValue(c, handlers);
        canReflect.offValue(c, handlers);
        setTimeout(function () {
            var handlers = map[canSymbol.for('can.meta')].handlers.get([]);
            equal(handlers.length, 0, 'there are no bindings');
            start();
        }, 30);
    });
    QUnit.test('computes are read as this and . and  ../', function () {
        var value = new SimpleObservable(1);
        var scope = new Scope(value);
        QUnit.equal(scope.get('this'), 1, 'this read value');
        QUnit.equal(scope.get('.'), 1, '. read value');
        scope = scope.add({});
        QUnit.equal(scope.get('..'), 1, '.. read value');
    });
    QUnit.test('computes are set as this and . and  ../', function () {
        var value = new SimpleObservable(1);
        var scope = new Scope(value);
        scope.set('this', 2);
        QUnit.equal(scope.get('this'), 2, 'this read value');
        scope.set('.', 3);
        QUnit.equal(scope.get('this'), 3, '. read value');
        scope = scope.add({});
        scope.set('..', 4);
        QUnit.equal(scope.get('..'), 4, '.. read value');
    });
    QUnit.test('maps are set with this.foo and ./foo', function () {
        var map = new SimpleObservable(new SimpleMap({ value: 1 }));
        var scope = new Scope(map);
        scope.set('this.value', 2);
        QUnit.equal(scope.get('this.value'), 2, 'this read value');
        scope.set('./value', 3);
        QUnit.equal(scope.get('./value'), 3, '. read value');
    });
    QUnit.test('setting a key on a non observable context', function () {
        var context = { colors: new SimpleMap() };
        var scope = new Scope(context);
        scope.set('colors', { prop: 'bar' });
        QUnit.deepEqual(context.colors.attr(), { prop: 'bar' }, 'can updateDeep');
    });
    QUnit.test('observing scope key data does not observe observation', function () {
        var map = new SimpleMap({ value: 'a' });
        var scope = new Scope(map);
        var computeData = scope.computeData('value');
        var c = new Observation(function () {
            return computeData.get();
        });
        canReflect.onValue(c, function () {
        });
        var dependencies = canReflect.getValueDependencies(c);
        QUnit.ok(dependencies.valueDependencies.has(computeData), 'compute has computeData');
        QUnit.equal(dependencies.valueDependencies.size, 1, 'compute only has computeData');
        var computeDataDependencies = canReflect.getValueDependencies(computeData);
        QUnit.ok(computeDataDependencies.valueDependencies.has(computeData.observation), 'computeData has internal observation');
        QUnit.equal(computeDataDependencies.valueDependencies.size, 1, 'computeData only has internal observation');
        var observationDependencies = canReflect.getValueDependencies(computeData.observation);
        QUnit.ok(observationDependencies.keyDependencies.has(map), 'internal observation');
        QUnit.equal(observationDependencies.keyDependencies.size, 1, 'internal observation');
    });
    QUnit.test('scopeKeyData offValue resets dependencyChange/start', function () {
        var map = new SimpleMap({
            value: 'a',
            other: 'b'
        });
        var wrap = new SimpleObservable(map);
        var scope = new Scope(wrap);
        var scopeKeyData = scope.computeData('value');
        var handler = function () {
        };
        canReflect.onValue(scopeKeyData, handler);
        canReflect.offValue(scopeKeyData, handler);
        QUnit.equal(scopeKeyData.observation.dependencyChange, Observation.prototype.dependencyChange, 'dependencyChange should be restored');
        QUnit.equal(scopeKeyData.observation.start, Observation.prototype.start, 'start should be restored');
    });
    QUnit.test('Rendering a template with a custom scope (#55)', function () {
        var scope = new Scope({}), scopeRefs;
        try {
            scopeRefs = scope.getRefs();
            scopeRefs._read;
            QUnit.ok(true, 'Did not throw');
        } catch (e) {
            QUnit.ok(false, e.message);
        }
        QUnit.equal(scope.get('name'), undefined, 'No name');
        scope.set('name', 'John');
        QUnit.equal(scope.get('name'), 'John', 'Got the name');
        scope = scope.add({ name: 'Justin' });
        QUnit.equal(scope.get('name'), 'Justin', 'Got the top scope name');
        try {
            scopeRefs = scope.getRefs();
            scopeRefs._read;
            QUnit.ok(true, 'Did not throw');
        } catch (e) {
            QUnit.ok(false, e.message);
        }
    });
    QUnit.test('generated refs scope is a Scope', function () {
        var scope = new Scope({});
        QUnit.equal(scope._parent, undefined, 'scope initially has no parent');
        var refScope = scope.getRefs();
        QUnit.ok(refScope instanceof Scope, 'refScope is a scope');
        QUnit.ok(refScope._context instanceof Scope.Refs, 'refScope context is a refs object');
        QUnit.equal(scope._parent, refScope, 'refScope is a parent of scope');
    });
    QUnit.test('this works everywhere (#45)', function () {
        var obj = { foo: 'bar' };
        var scope = new Scope(obj);
        QUnit.equal(scope.get('this.foo'), 'bar');
    });
    QUnit.test('\'this\' and %context give the context', 1, function () {
        var vm;
        var MyMap = SimpleMap.extend({
            doSomething: function () {
                QUnit.equal(this, vm, 'event callback called on context');
            }
        });
        vm = new MyMap();
        var compute = new Scope(vm).computeData('this.doSomething', {
            isArgument: true,
            args: []
        }).compute;
        compute()();
    });
    QUnit.test('that .set with ../ is able to skip notContext scopes (#43)', function () {
        var instance = new SimpleMap({ prop: 0 });
        var notContextContext = { NAME: 'NOT CONTEXT' };
        var top = { NAME: 'TOP' };
        var scope = new Scope(instance).add(notContextContext, { notContext: true }).add(top);
        scope.set('../prop', 1);
        QUnit.equal(instance.attr('prop'), 1);
    });
    test('undefined props should be a scope hit (#20)', function () {
        var MyType = SimpleMap.extend('MyType', {
            init: function () {
                this.value = undefined;
            }
        });
        var EmptyType = SimpleMap.extend('EmptyType', {});
        var instance = new MyType();
        var scope = new Scope(instance).add(new EmptyType());
        var c1 = scope.computeData('value').compute;
        c1.on('change', function () {
        });
        c1('BAR');
        QUnit.equal(instance.attr('value'), 'BAR');
        var instance2 = new MyType();
        var scope2 = new Scope(instance2).add(new SimpleObservable());
        var c2 = scope2.computeData('value').compute;
        c2.on('change', function () {
        });
        c2('BAR');
        QUnit.equal(instance2.attr('value'), 'BAR');
    });
    QUnit.test('ScopeKeyData can.valueHasDependencies', function () {
        var map = new SimpleMap({ age: 21 });
        var base = new Scope(map);
        var age = base.computeData('age');
        QUnit.equal(canReflect.valueHasDependencies(age), undefined, 'undefined');
        canReflect.onValue(age, function () {
        });
        QUnit.equal(canReflect.valueHasDependencies(age), true, 'undefined');
    });
    QUnit.test('get and set Priority', function () {
        var map = new SimpleMap({ age: 21 });
        var base = new Scope(map);
        var age = base.computeData('age');
        canReflect.setPriority(age, 5);
        QUnit.equal(canReflect.getPriority(age), 5, 'set priority');
        var compute = age.compute;
        QUnit.equal(canReflect.getPriority(compute), 5, 'set priority');
    });
    QUnit.test('fast path checking does not leak ObservationRecord.adds', function () {
        var map = new SimpleMap({ age: 21 });
        Object.defineProperty(map, 'age', {
            get: function () {
                return this.attr('age');
            },
            set: function (newVal) {
                this.attr('age', newVal);
            }
        });
        var base = new Scope(map);
        var age = base.computeData('age');
        ObservationRecorder.start();
        age.get();
        var dependencies = ObservationRecorder.stop();
        QUnit.equal(dependencies.keyDependencies.size, 0, 'no key dependencies');
        QUnit.equal(dependencies.valueDependencies.size, 1, 'only sees age');
        QUnit.ok(dependencies.valueDependencies.has(age), 'only sees age');
    });
});
/*can-view-target@3.1.4#test/test*/
define('can-view-target@3.1.4#test/test', [
    'require',
    'exports',
    'module',
    'can-view-target',
    'can-simple-dom',
    'steal-qunit',
    'can-globals/mutation-observer/mutation-observer'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var target = require('can-view-target');
        var simpleDom = require('can-simple-dom');
        var QUnit = require('steal-qunit');
        var MUTATION_OBSERVER = require('can-globals/mutation-observer/mutation-observer');
        QUnit.module('can-view-target');
        test('basics', function () {
            var classCallback = function () {
                    equal(this.nodeName.toLowerCase(), 'h1', 'class on the right element');
                    this.className = 'selected';
                }, attributesCallback = function () {
                    equal(this.nodeName.toLowerCase(), 'h1', 'attributes on the right element');
                }, textNodeCallback = function () {
                    equal(this.nodeType, 3, 'got a text node');
                    this.nodeValue = 'World';
                };
            var data = target([{
                    tag: 'h1',
                    attrs: {
                        'id': 'myh1',
                        'class': classCallback
                    },
                    attributes: [attributesCallback],
                    children: [{
                            tag: 'span',
                            children: [
                                'Hello ',
                                textNodeCallback,
                                '!'
                            ]
                        }]
                }]);
            equal(data.clone.childNodes.length, 1, 'there is one child');
            var h1 = data.clone.childNodes[0];
            equal(h1.nodeName.toLowerCase(), 'h1', 'there is one h1');
            equal(h1.id, 'myh1', 'the h1 has the right id');
            equal(h1.childNodes.length, 1, 'the h1 has span');
            equal(h1.childNodes[0].childNodes.length, 3, 'the span has 3 children');
            deepEqual(data.paths, [{
                    path: [0],
                    callbacks: [
                        { callback: classCallback },
                        { callback: attributesCallback }
                    ],
                    paths: [{
                            path: [
                                0,
                                1
                            ],
                            callbacks: [{ callback: target.keepsTextNodes ? textNodeCallback : data.paths[0].paths[0].callbacks[0].callback }]
                        }]
                }]);
            var result = data.hydrate();
            var newH1 = result.childNodes[0];
            equal(newH1.className, 'selected', 'got selected class name');
            equal(newH1.innerHTML.toLowerCase(), '<span>hello world!</span>');
        });
        test('replacing items', function () {
            var data = target([
                function () {
                    this.parentNode.insertBefore(document.createTextNode('inserted'), this.nextSibling);
                },
                'hi',
                function () {
                    equal(this.previousSibling.nodeValue, 'hi', 'previous is as expected');
                }
            ]);
            data.hydrate();
        });
        test('comments', function () {
            var data = target([
                { tag: 'h1' },
                { comment: 'foo bar' }
            ]);
            var node = data.clone.childNodes[1];
            equal(node.nodeValue, 'foo bar', 'node value is right');
            equal(node.nodeType, 8, 'node is a comment');
        });
        test('paths should be run in reverse order (#966)', function () {
            var data = target([{
                    tag: 'h1',
                    attributes: [function () {
                        }],
                    children: [
                        function () {
                            this.parentNode.insertBefore(document.createElement('div'), this.nextSibling);
                        },
                        {
                            tag: 'span',
                            children: [function () {
                                    equal(this.nodeType, 3, 'got an element');
                                }]
                        }
                    ]
                }]);
            data.hydrate();
        });
        test('renderToVirtualDOM', function () {
            var simpleDocument = new simpleDom.Document();
            var innerData = target([{ tag: 'span' }], simpleDocument);
            var outerData = target([{
                    tag: 'h1',
                    children: [
                        function (data) {
                            this.parentNode.insertBefore(innerData.hydrate(data), this);
                            this.parentNode.removeChild(this);
                        },
                        'foo'
                    ]
                }], simpleDocument);
            var out = outerData.hydrate({ foo: true });
            equal(out.firstChild.nodeName, 'H1');
            equal(out.firstChild.firstChild.nodeName, 'SPAN');
            equal(out.firstChild.lastChild.nodeValue, 'foo');
        });
        test('cloneNode works in IE11', function () {
            var frag = document.createDocumentFragment();
            var text = document.createTextNode('some-text');
            var MO = MUTATION_OBSERVER();
            var observer;
            frag.appendChild(text);
            var clone = target.cloneNode(frag);
            equal(clone.childNodes.length, 1, 'cloneNode should work');
            if (MO) {
                observer = new MO(function (mutations) {
                });
                observer.observe(document.documentElement, {
                    childList: true,
                    subtree: true
                });
                clone = target.cloneNode(frag);
                equal(clone.childNodes.length, 1, 'cloneNode should work after creating MutationObserver');
            }
        });
        test('cloneNode keeps non-default element namespace', function () {
            var frag = document.createDocumentFragment();
            var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            frag.appendChild(svg);
            var clone = target.cloneNode(frag);
            equal(clone.firstChild.namespaceURI, 'http://www.w3.org/2000/svg', 'cloneNode should keep non-default element namespace');
        });
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-ndjson-stream@0.1.6#can-ndjson-stream*/
define('can-ndjson-stream@0.1.6#can-ndjson-stream', [
    'require',
    'exports',
    'module',
    'can-namespace'
], function (require, exports, module) {
    var namespace = require('can-namespace');
    var ndjsonStream = function (response) {
        var is_reader, cancellationRequest = false;
        return new ReadableStream({
            start: function (controller) {
                var reader = response.getReader();
                is_reader = reader;
                var decoder = new TextDecoder();
                var data_buf = '';
                reader.read().then(function processResult(result) {
                    if (result.done) {
                        if (cancellationRequest) {
                            return;
                        }
                        data_buf = data_buf.trim();
                        if (data_buf.length !== 0) {
                            try {
                                var data_l = JSON.parse(data_buf);
                                controller.enqueue(data_l);
                            } catch (e) {
                                controller.error(e);
                                return;
                            }
                        }
                        controller.close();
                        return;
                    }
                    var data = decoder.decode(result.value, { stream: true });
                    data_buf += data;
                    var lines = data_buf.split('\n');
                    for (var i = 0; i < lines.length - 1; ++i) {
                        var l = lines[i].trim();
                        if (l.length > 0) {
                            try {
                                var data_line = JSON.parse(l);
                                controller.enqueue(data_line);
                            } catch (e) {
                                controller.error(e);
                                cancellationRequest = true;
                                reader.cancel();
                                return;
                            }
                        }
                    }
                    data_buf = lines[lines.length - 1];
                    return reader.read().then(processResult);
                });
            },
            cancel: function (reason) {
                console.log('Cancel registered due to ', reason);
                cancellationRequest = true;
                is_reader.cancel();
            }
        });
    };
    module.exports = namespace.ndjsonStream = ndjsonStream;
});
/*can-ndjson-stream@0.1.6#can-ndjson-stream-test*/
define('can-ndjson-stream@0.1.6#can-ndjson-stream-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-ndjson-stream'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var ndjsonStream = require('can-ndjson-stream');
    var isReadStreamSupported = true;
    try {
        new ReadableStream();
    } catch (err) {
        isReadStreamSupported = false;
    }
    var conditionalTest = isReadStreamSupported ? QUnit.test : QUnit.skip;
    var conditionalAsyncTest = isReadStreamSupported ? QUnit.asyncTest : QUnit.skip;
    function readableStreamFromString(s) {
        return new ReadableStream({
            start: function (controller) {
                var encoder = new TextEncoder();
                var pos = 0;
                var chunkSize = 1;
                function push() {
                    if (pos >= s.length) {
                        controller.close();
                        return;
                    }
                    controller.enqueue(encoder.encode(s.slice(pos, pos + chunkSize)));
                    pos += chunkSize;
                    push();
                }
                push();
            },
            cancel: function () {
            }
        });
    }
    function inputStream(objArray) {
        var jsons = objArray.map(function (obj) {
            return JSON.stringify(obj);
        });
        return readableStreamFromString(jsons.join('\n'));
    }
    QUnit.module('can-ndjson-stream');
    conditionalTest('Initialized the plugin', function () {
        QUnit.equal(typeof ndjsonStream, 'function');
    });
    conditionalAsyncTest('simple_test_from_stream', function (assert) {
        var testObject = [
            {
                'date': '2017-02-24 03:07:45',
                'user': '21109850',
                'fuel': '37',
                'ammo': '2',
                'steel': '13',
                'baux': '5',
                'seaweed': '0',
                'type': 'LOOT',
                'product': '134'
            },
            {
                'date': '2017-02-22 04:40:13',
                'user': '21109850',
                'fuel': '37',
                'ammo': '2',
                'steel': '13',
                'baux': '5',
                'seaweed': '0',
                'type': 'LOOT',
                'product': '75'
            },
            {
                'date': '2017-02-21 20:47:51',
                'user': '26464462',
                'fuel': '37',
                'ammo': '3',
                'steel': '19',
                'baux': '5',
                'seaweed': '1',
                'type': 'LOOT',
                'product': '81'
            }
        ];
        var readObjects = [];
        var todoStream = ndjsonStream(inputStream(testObject));
        function test(todosStream) {
            var reader = todosStream.getReader();
            reader.read().then(function read(result) {
                if (result.done) {
                    assert.deepEqual(readObjects, testObject, 'Two arrays should be the same in value');
                    QUnit.start();
                    return;
                }
                readObjects.push(result.value);
                reader.read().then(read);
            });
        }
        test(todoStream);
    });
    conditionalAsyncTest('maleformed json', function (assert) {
        var maleformed_string = '{"1":2}\n{sss: 2}';
        var readObjects = [];
        var todoStream = ndjsonStream(readableStreamFromString(maleformed_string));
        var reader = todoStream.getReader();
        var errorCaught = false;
        function errCheck() {
            errorCaught = true;
        }
        var allDone = reader.read().then(function read(result) {
            if (result.done) {
                return;
            }
            readObjects.push(result.value);
            return reader.read().then(read, errCheck);
        }, errCheck);
        allDone.then(function () {
            assert.strictEqual(errorCaught, true, 'maleformed json string should cause an error');
            QUnit.start();
        }, function () {
            assert.strictEqual(errorCaught, true, 'rejected: maleformed json string should cause an error');
            QUnit.start();
        });
    });
});
/*can@4.0.0-pre.0#test/test*/
define('can@4.0.0-pre.0#test/test', [
    'require',
    'exports',
    'module',
    'can-component/test/tests',
    'can-define/test/test',
    'can-stache-bindings/test/colon/tests',
    'can-ajax/can-ajax-test',
    'can-construct/can-construct_test',
    'can-construct-super/test/can-construct-super_test',
    'can-control/can-control_test',
    'can-define-lazy-value/define-lazy-value-test',
    'can-deparam/can-deparam-test',
    'can-event-queue/can-event-queue-test',
    'can-globals/can-globals-test',
    'can-key-tree/can-key-tree-test',
    'can-param/can-param-test',
    'can-queues/queue-test',
    'can-reflect/can-reflect-test',
    'can-reflect-promise/test/can-reflect-promise_test',
    'can-simple-dom/test/test',
    'can-simple-observable/can-simple-observable-test',
    'can-stache-key/can-stache-key-test',
    'can-symbol/can-symbol-test',
    'can-view-live/test/test',
    'can-view-model/test/test',
    'can-view-nodelist/test/can-view-nodelist-test',
    'can-view-parser/test/can-view-parser-test',
    'can-view-scope/test/scope-test',
    'can-view-target/test/test',
    'can-ndjson-stream/can-ndjson-stream-test'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        require('can-component/test/tests');
        require('can-define/test/test');
        require('can-stache-bindings/test/colon/tests');
        require('can-ajax/can-ajax-test');
        require('can-construct/can-construct_test');
        require('can-construct-super/test/can-construct-super_test');
        require('can-control/can-control_test');
        require('can-define-lazy-value/define-lazy-value-test');
        require('can-deparam/can-deparam-test');
        require('can-event-queue/can-event-queue-test');
        require('can-globals/can-globals-test');
        require('can-key-tree/can-key-tree-test');
        require('can-param/can-param-test');
        require('can-queues/queue-test');
        require('can-reflect/can-reflect-test');
        require('can-reflect-promise/test/can-reflect-promise_test');
        require('can-simple-dom/test/test');
        require('can-simple-observable/can-simple-observable-test');
        require('can-stache-key/can-stache-key-test');
        require('can-symbol/can-symbol-test');
        require('can-view-live/test/test');
        require('can-view-model/test/test');
        require('can-view-nodelist/test/can-view-nodelist-test');
        require('can-view-parser/test/can-view-parser-test');
        require('can-view-scope/test/scope-test');
        require('can-view-target/test/test');
        require('can-ndjson-stream/can-ndjson-stream-test');
    }(function () {
        return this;
    }(), require, exports, module));
});